# SKMutablePayment

Instance Property

# productIdentifier

A string that identifies a product that can be purchased from within your app.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var productIdentifier: String { get set }

## Discussion

The product identifier is a string previously agreed on between your app and
the Apple App Store.

## See Also

### Getting and Setting Attributes

`var quantity: Int`

The number of items the user wants to purchase.

`var requestData: Data?`

Reserved for future use.

`var applicationUsername: String?`

A string that associates the transaction with a user account on your service.

### Related Documentation

In-App Purchase Programming Guide

Instance Property

# quantity

The number of items the user wants to purchase.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var quantity: Int { get set }

## Discussion

The quantity property must be greater than `0`.

## See Also

### Getting and Setting Attributes

`var productIdentifier: String`

A string that identifies a product that can be purchased from within your app.

`var requestData: Data?`

Reserved for future use.

`var applicationUsername: String?`

A string that associates the transaction with a user account on your service.

Instance Property

# requestData

Reserved for future use.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var requestData: Data? { get set }

## Discussion

The default value is `nil`. If `requestData` is not `nil`, your payment will
be rejected by the Apple App Store.

## See Also

### Getting and Setting Attributes

`var productIdentifier: String`

A string that identifies a product that can be purchased from within your app.

`var quantity: Int`

The number of items the user wants to purchase.

`var applicationUsername: String?`

A string that associates the transaction with a user account on your service.

Instance Property

# applicationUsername

A string that associates the transaction with a user account on your service.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var applicationUsername: String? { get set }

## Discussion

Consider assigning a UUID to the `applicationUsername` property. When this
value is a UUID, the App Store server stores it as an `appAccountToken`. In
this scenario, the following happens:

  * In the App Store Server API, the `JWSTransactionDecodedPayload` object returns the `applicationUsername` value in the `appAccountToken` field.

  * In App Store Server Notifications, the `JWSTransactionDecodedPayload` object returns the `applicationUsername` value in the `appAccountToken` field. 

  * When you call the verifyReceipt endpoint to verify an App Store receipt, the App Store server returns the `applicationUsername` value in the `app_account_token` field of the `responseBody.Latest_receipt_info`.

The sample code below shows how to assign a UUID value to
`applicationUsername`. You may choose to generate the UUID on your server.
Assign the value before adding the payment to the payment queue.

If you don’t assign a UUID string value to `applicationUsername`, the App
Store server doesn’t persist the value. The value won’t appear in the
`app_account_token` fields in notifications or receipts.

Important

An `applicationUsername` property that isn’t a UUID isn’t guaranteed to
persist between the time when you add the payment transaction to the queue and
when the queue updates the transaction.

## See Also

### Getting and Setting Attributes

`var productIdentifier: String`

A string that identifies a product that can be purchased from within your app.

`var quantity: Int`

The number of items the user wants to purchase.

`var requestData: Data?`

Reserved for future use.

Instance Property

# simulatesAskToBuyInSandbox

A Boolean value that produces an “ask to buy” flow for this payment in the
sandbox.

iOS 8.3+  iPadOS 8.3+  macOS 10.14+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var simulatesAskToBuyInSandbox: Bool { get set }

Instance Property

# paymentDiscount

The details of the discount offer to apply to the payment.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    @NSCopying
    var paymentDiscount: SKPaymentDiscount? { get set }



# External link account

Property List Key

# com.apple.developer.storekit.external-link.account

A Boolean value that indicates whether your app can link to an external
website for account creation or management.

iOS 15.4+  iPadOS 15.4+  tvOS 16.4+

##  Details

Type

    

boolean

## Discussion

If your developer account has this entitlement, add it to your app by opening
the project’s entitlements file in Xcode. Add the following key and set the
corresponding value to `true`:

    
    
    <plist>
    <dict>
        <key>com.apple.developer.storekit.external-link.account</key>
        <true/>
    </dict>
    </plist>
    

## See Also

### StoreKit

`com.apple.developer.storekit.external-purchase`

A Boolean value that indicates whether your app can offer external purchases.

`com.apple.developer.storekit.external-purchase-link`

A Boolean value that indicates whether your app can include a link that
directs people to a website to make an external purchase.

Property List Key

# SKExternalLinkAccount

A dictionary that contains localized URLs to an external website for account
creation or management.

iOS 15.4+  iPadOS 15.4+  tvOS 16.4+

##  Details

Type

    

dictionary

## Properties

`Any Key`

`string`

A dictionary with keys that are lowercase ISO 3166-1 alpha-2 country codes and
values that are URLs. The dictionary must contain a key with the string `*`
that maps to a default URL.

## Discussion

Use this information property list key if your app has the
`com.apple.developer.storekit.external-link.account` entitlement. The
following shows a property list with a default URL and a specific URL for the
`jp` locale:

    
    
    <plist>
    <dict>
        <key>SKExternalLinkAccount</key>
        <dict>
            <key>*</key>
            <string>https://example.com</string>
            <key>jp</key>
            <string>https://example.com/jp</string>
        </dict>
    </dict>
    </plist>
    

## See Also

### External accounts

`com.apple.developer.storekit.external-link.account`

A Boolean value that indicates whether your app can link to an external
website for account creation or management.

`enum ExternalLinkAccount`

Enables qualifying apps to link to an external website for account creation or
management.



# Transaction.Transactions.AsyncIterator

Instance Method

# next()

Advances to the next element and returns either the element or `nil` if there
isn’t a next element.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    mutating func next() async -> VerificationResult<Transaction>?

## Return Value

The next element in the underlying sequence, if a next element exists;
otherwise, `nil`.

## Relationships

### From Protocol

  * `AsyncIteratorProtocol`

## See Also

### Getting the Next Element

`typealias Transaction.Transactions.AsyncIterator.Element`

The type of element produced by this iterator.

Type Alias

# Transaction.Transactions.AsyncIterator.Element

The type of element produced by this iterator.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Transaction.Transactions.AsyncIterator.Element = VerificationResult<Transaction>

## See Also

### Getting the Next Element

`func next() -> VerificationResult<Transaction>?`

Advances to the next element and returns either the element or `nil` if there
isn’t a next element.



# SKANError

Type Property

# errorDomain

A string containing the error domain for SKAdNetwork errors.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var errorDomain: String { get }

Instance Property

# code

The error code.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var code: Code { get }

## See Also

### Getting Error Properties

`var errorCode: Int`

The integer error code.

`var userInfo: [String : Any]`

The user information dictionary associated with the error.

`var errorUserInfo: [String : Any]`

The error user information dictionary associated with the error.

`var localizedDescription: String`

A string containing the localized description of the error.

Instance Property

# errorCode

The integer error code.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var errorCode: Int { get }

## See Also

### Getting Error Properties

`var code: Code`

The error code.

`var userInfo: [String : Any]`

The user information dictionary associated with the error.

`var errorUserInfo: [String : Any]`

The error user information dictionary associated with the error.

`var localizedDescription: String`

A string containing the localized description of the error.

Instance Property

# userInfo

The user information dictionary associated with the error.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var userInfo: [String : Any] { get }

## See Also

### Getting Error Properties

`var code: Code`

The error code.

`var errorCode: Int`

The integer error code.

`var errorUserInfo: [String : Any]`

The error user information dictionary associated with the error.

`var localizedDescription: String`

A string containing the localized description of the error.

Instance Property

# errorUserInfo

The error user information dictionary associated with the error.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var errorUserInfo: [String : Any] { get }

## See Also

### Getting Error Properties

`var code: Code`

The error code.

`var errorCode: Int`

The integer error code.

`var userInfo: [String : Any]`

The user information dictionary associated with the error.

`var localizedDescription: String`

A string containing the localized description of the error.

Instance Property

# localizedDescription

A string containing the localized description of the error.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

## See Also

### Getting Error Properties

`var code: Code`

The error code.

`var errorCode: Int`

The integer error code.

`var userInfo: [String : Any]`

The user information dictionary associated with the error.

`var errorUserInfo: [String : Any]`

The error user information dictionary associated with the error.

Type Property

# adNetworkIdMissing

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var adNetworkIdMissing: SKANError.Code { get }

## Discussion

The value you specify for your ad network identifier in your ad impresion must
match the value in the `Info.plist`. ``An app that participates in ad
campaigns by displaying ads must include the ad network identifiers in its
`Info.plist`. For more information, see Configuring a source app.

## See Also

### Getting Error Codes

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# impressionMissingRequiredValue

A required value is missing from a view-through ad impression.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var impressionMissingRequiredValue: SKANError.Code { get }

## Discussion

Check that your instance of `SKAdImpression` provides all of the required
values.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# impressionNotFound

The system can’t find the ad impression.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var impressionNotFound: SKANError.Code { get }

## Discussion

This error may occur if an app calls `endImpression(_:completionHandler:)`
before calling `startImpression(_:completionHandler:)`.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# impressionTooShort

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var impressionTooShort: SKANError.Code { get }

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# invalidAdvertisedAppId

The App Store ID of the advertised app is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var invalidAdvertisedAppId: SKANError.Code { get }

## Discussion

Ad networks provide an advertised app identifier when signing an ad
impression. If you’re providing a StoreKit-rendered ad, check that the value
you set for `SKStoreProductParameterITunesItemIdentifier` in
`loadProduct(withParameters:completionBlock:)` is a valid app identifer. If
you’re providing a view-through ad, check the value of
`advertisedAppStoreItemIdentifier`.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# invalidCampaignId

The campaign identifier that you provided is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var invalidCampaignId: SKANError.Code { get }

## Discussion

Check that the campaign identifier is a valid value. For more information, see
`SKStoreProductParameterAdNetworkCampaignIdentifier` for StoreKit-rendered
ads, and `adCampaignIdentifier` for view-through ads.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# invalidConversionValue

The conversion value is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var invalidConversionValue: SKANError.Code { get }

## Discussion

Apps provide a conversion value when calling
`updatePostbackConversionValue(_:completionHandler:)` or
`updateConversionValue(_:)`. Check that the conversion value you provide is
within the allowed range.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# invalidSourceAppId

The App Store ID of the app displaying the ad is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var invalidSourceAppId: SKANError.Code { get }

## Discussion

Check that the value you provide for
`SKStoreProductParameterAdNetworkSourceAppStoreIdentifier` or
`sourceAppStoreItemIdentifier` is correct and matches the App Store ID of the
app that’s displaying the ad.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# invalidVersion

The SKAdNetwork version number is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var invalidVersion: SKANError.Code { get }

## Discussion

Ad networks provide an SKAdNetwork version number when preparing an ad
impression, in `SKStoreProductParameterAdNetworkVersion` or `version`. Check
that the version number is valid and that you follow the version-specific
instructions to generate a signature. For more information about versions, see
SKAdNetwork release notes.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# mismatchedSourceAppId

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var mismatchedSourceAppId: SKANError.Code { get }

## Discussion

Check that the `sourceAppStoreItemIdentifier` you provide in the
`SKAdImpression` object matches the app identifier of the app displaying the
ad.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var unknown: SKANError.Code`

An unknown error occurred.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# unknown

An unknown error occurred.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var unknown: SKANError.Code { get }

## Discussion

If this error appears, continue processing the ad; an ad impression may
succeed despite this error.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unsupported: SKANError.Code`

Your app attempted to use functionality that isn’t supported in the specified
version.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Type Property

# unsupported

Your app attempted to use functionality that isn’t supported in the specified
version.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static var unsupported: SKANError.Code { get }

## Discussion

For information about supported features by version number, see SKAdNetwork
release notes. For example, to provide view-through ads, use SKAdNetwork
version 2.2 or later.

## See Also

### Getting Error Codes

`static var adNetworkIdMissing: SKANError.Code`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`static var impressionMissingRequiredValue: SKANError.Code`

A required value is missing from a view-through ad impression.

`static var impressionNotFound: SKANError.Code`

The system can’t find the ad impression.

`static var impressionTooShort: SKANError.Code`

`static var invalidAdvertisedAppId: SKANError.Code`

The App Store ID of the advertised app is invalid.

`static var invalidCampaignId: SKANError.Code`

The campaign identifier that you provided is invalid.

`static var invalidConversionValue: SKANError.Code`

The conversion value is invalid.

`static var invalidSourceAppId: SKANError.Code`

The App Store ID of the app displaying the ad is invalid.

`static var invalidVersion: SKANError.Code`

The SKAdNetwork version number is invalid.

`static var mismatchedSourceAppId: SKANError.Code`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`static var unknown: SKANError.Code`

An unknown error occurred.

`enum SKANError.Code`

Constants that indicate the type of error for an ad network attribution
operation.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static func != (lhs: SKANError, rhs: SKANError) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Errors

`static func == (SKANError, SKANError) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    static func == (lhs: SKANError, rhs: SKANError) -> Bool

## See Also

### Comparing and Hashing Errors

`static func != (SKANError, SKANError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and Hashing Errors

`static func != (SKANError, SKANError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (SKANError, SKANError) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and Hashing Errors

`static func != (SKANError, SKANError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (SKANError, SKANError) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Initializer

# init(_:userInfo:)

Initializes an error structure with a code and custom data.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 13.3+

    
    
    init(
        _ code: Code,
        userInfo: [String : Any] = [:]
    )

##  Parameters

`code`

    

The error code.

`userInfo`

    

The dictionary of additional information to pass with the error.



# DisplayMessageAction

Instance Method

# callAsFunction(_:)

Tells StoreKit to display the App Store message, if appropriate.

StoreKit  SwiftUI  iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+
Xcode 14.0+

    
    
    @MainActor
    func callAsFunction(_ message: Message) throws

##  Parameters

`message`

    

The App Store message to display.

## Discussion

Don’t call this method directly. SwiftUI calls it when you call the
`DisplayMessageAction` structure using `message` as an argument.

For information about how Swift uses the `callAsFunction()` method to simplify
call site syntax, see Methods with Special Names in _The Swift Programming
Language_.



# AppStore

Type Property

# canMakePayments

A Boolean value that indicates whether the person can make purchases.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var canMakePayments: Bool { get }

## Discussion

Use `canMakePayments` to determine at runtime whether a person can authorize
payments. If your app is configured with entitlements for the External
Purchase APIs, `canMakePayments` informs your app at runtime whether it can
call the External Purchase APIs or use the StoreKit In-App Purchase API.

Important

Your app might need to alter its behavior or appearance when people aren’t
allowed to make purchases. For example, don't enable your user interface for
making in-app purchases when purchases are blocked.

If your app uses only StoreKit In-App Purchase APIs, and:

  * `canMakePayments` is `true`, someone can authorize purchases in the App Store.

  * `canMakePayments` is `false`, don't offer in-app purchases using StoreKit In-App Purchase APIs.

The following conditions can cause the value of `canMakePayments` to be
`false`:

  * A person sets the Content & Privacy Restrictions in Screen Time to block purchases. For more information, see Use parental controls on your child's iPhone, iPad, and iPod touch. 

  * The device has a mobile device management (MDM) profile that blocks purchases. For more information, see Device Management. 

  * StoreKit In-App Purchase APIs are unavailable because the app must use the External Purchase APIs instead. See the section below, Interpret this value in apps that use the External Purchase APIs, for more details.

### Interpret this value in apps that use the External Purchase APIs

If your app has the entitlements to use the External Purchase APIs, use
`canMakePayments` to determine at runtime whether to use the External Purchase
or StoreKit In-App Purchase API based on the operating system, as follows:

For apps built with an SDK starting with iOS 17.4, iPadOS 17.4, macOS 14.4,
Mac Catalyst 17.4, tvOS 17.4, watchOS 10.4, and Xcode 13.3, and:

  * `canMakePayments` is `false`, your app can use only External Purchase APIs. 

  * `canMakePayments` is `true`, your app can use only the StoreKit In-App Purchase APIs and can offer in-app purchases.

For apps built with the iOS 15.4 through 17.3 SDKs, or iPadOS 15.4 through
17.3 SDKs:

  * Your app must check `canMakePayments` before attempting to use External Purchase APIs.

  * If `canMakePayments` is `true`, your app may proceed to call External Purchase APIs. 

  * If `canMakePayments` is `false`, don't call External Purchase APIs.

For all apps:

  * Anytime `canMakePayments` is `false`, your app can't use StoreKit In-App Purchase for offering in-app purchases.

Note

The StoreKit APIs always enable your app to view existing transactions and
receive auto-renewable subscription renewals, so your app can support your
customer’s existing purchases made through the App Store.

Type Property

# deviceVerificationID

The device verification identifier to use to verify whether signed information
is valid for the current device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var deviceVerificationID: UUID? { get }

## Discussion

Use this property to verify whether an App Store-signed JSON Web Signature
(JWS) is valid for the current device. The JWS may be one of the following:

  * A `jwsRepresentation` representing a signed transaction

  * A `jwsRepresentation` representing a signed subscription renewal information 

  * A `jwsRepresentation` representing a signed app transaction.

To verify that the JWS is valid for the current device, follow these steps:

  1. Append the lowercased UUID string representation of this property, `deviceVerificationID`, after the lowercased UUID string representation of the device verification nonce. For a transaction, the nonce is `deviceVerificationNonce`. For subscription renewal information, the nonce is `deviceVerificationNonce`. For an app transaction, the nonce is `deviceVerificationNonce`.

  2. Compute the SHA-384 hash of the appended UUID strings.

  3. Verify that the SHA-384 digest is equal to the device verification property. For a transaction, the device verification property is `deviceVerification`. For subscription renewal information, the device verification property is `deviceVerification`. For an app transaction, the device verifcation property is `deviceVerification`.

Type Method

# showManageSubscriptions(in:)

Presents the App Store sheet for managing subscriptions.

iOS 15.0+  iPadOS 15.0+  Mac Catalyst 15.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @MainActor
    static func showManageSubscriptions(in scene: UIWindowScene) async throws

##  Parameters

`scene`

    

The `UIWindowScene` that the system displays the sheet on.

## Discussion

Use this function to display the manage subscriptions sheet within your app.
Consider adding a manage subscriptions option to your app. For design guidance
on supporting this functionality, see Human Interface Guidelines > In-App
Purchase > Helping People Manage Their Subscriptions.

The `showManageSubscriptions(in:)` function presents a manage subscription
sheet that’s the same as what customers can view in their account settings in
the App Store app or by choosing Settings > Apple ID > Subscriptions on an iOS
or iPadOS device. The sheet displays the customer’s currently active
subscription for your app and the options to view, upgrade, downgrade, or
cancel their subscription.

If you’re using SwiftUI, call the `manageSubscriptionsSheet(isPresented:)`view
modifier.

Avoid showing the user interface for this feature in Mac apps built with Mac
Catalyst and on iOS apps running on Mac computers with Apple silicon because
this sheet isn’t supported in macOS.

  * In Mac apps built with Mac Catalyst, enclose the code in a compilation conditional block that uses the `targetEnvironment(): `platform condition. For more information on Mac Catalyst, see Creating a Mac version of your iPad app. 

  * For iOS apps running on Apple silicon, if `isiOSAppOnMac` is `true,` avoid showing the user interface for this feature.

### Test managing subscriptions

Test the managing subscriptions functionality in the sandbox environment and
StoreKit testing in Xcode. For more information about testing, see Testing at
all stages of development with Xcode and the sandbox and Setting up StoreKit
Testing in Xcode.

## See Also

### Managing subscriptions

`static func showManageSubscriptions(in: UIWindowScene, subscriptionGroupID:
String)`

Presents the App Store sheet for managing subscriptions for a subscription
group.

Type Method

# showManageSubscriptions(in:subscriptionGroupID:)

Presents the App Store sheet for managing subscriptions for a subscription
group.

iOS 17.0+  iPadOS 17.0+  Mac Catalyst 17.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @MainActor
    static func showManageSubscriptions(
        in scene: UIWindowScene,
        subscriptionGroupID: String
    ) async throws

##  Parameters

`scene`

    

The `UIWindowScene` that the system displays the sheet on.

`subscriptionGroupID`

    

The subscription group identifier that the subscription belongs to.

## See Also

### Managing subscriptions

`static func showManageSubscriptions(in: UIWindowScene)`

Presents the App Store sheet for managing subscriptions.

Type Method

# requestReview(in:)

Tells StoreKit to request an App Store rating or review from the user, if
appropriate, using the specified scene.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    @MainActor
    static func requestReview(in scene: UIWindowScene)

##  Parameters

`scene`

    

The `UIWindowScene` that StoreKit uses to present the rating and review
request interface.

## Discussion

When you call this method in your shipping app and the system displays a
rating and review request view, the system handles the entire process for you.
Although you normally call this method when it makes sense in the user
experience flow of your app, App Store policy governs the actual display of a
rating and review request view. When your app calls this API, StoreKit uses
the following criteria:

  * If the person hasn’t rated or reviewed your app on this device, StoreKit displays the ratings and review request a maximum of three times within a 365-day period.

  * If the person has rated or reviewed your app on this device, StoreKit displays the ratings and review request if the app version is new, and if more than 365 days have passed since the person’s previous review.

Note

Because this method may not present an alert, don’t call `requestReview()` or
`requestReview(in:)` in response to a button tap or other user action.

It’s up to your app to decide on the best timing for requesting reviews. For
design guidance, see Human Interface Guidelines > Ratings and reviews.

### Test review requests

When your app calls this method while it’s in development mode, StoreKit
always displays the rating and review request view, so you can test the user
interface and experience. However, this method has no effect in apps that you
distribute for beta testing using TestFlight.

### Provide a persistent link to your product page (optional)

Your customers can review your app at any time on the App Store. To make it
easier for people to leave reviews, you may include a persistent link to your
App Store product page in your app’s settings or configuration screens. Append
the query parameter `action=write-review` to your product page URL to
automatically open the App Store page where users can write a review.

## See Also

### Requesting reviews

`struct RequestReviewAction`

An instance that tells StoreKit to request an App Store rating or review, if
appropriate.

`static func requestReview(in: NSViewController)`

Tells StoreKit to request an App Store rating or review from the user, if
appropriate, using the specified view controller.

Type Method

# requestReview(in:)

Tells StoreKit to request an App Store rating or review from the user, if
appropriate, using the specified view controller.

macOS 13.0+  Xcode 14.0+

    
    
    @MainActor
    static func requestReview(in controller: NSViewController)

##  Parameters

`controller`

    

The `NSViewController` that StoreKit uses to present the rating and review
request interface.

## Discussion

When you call this method in your shipping app and the system displays a
rating and review request view, the system handles the entire process for you.
Although you normally call this method when it makes sense in the user
experience flow of your app, App Store policy governs the actual display of a
rating and review request view. When your app calls this API, StoreKit uses
the following criteria:

  * If the person hasn’t rated or reviewed your app on this device, StoreKit displays the ratings and review request a maximum of three times within a 365-day period.

  * If the person has rated or reviewed your app on this device, StoreKit displays the ratings and review request if the app version is new, and if more than 365 days have passed since the person’s previous review.

Note

Because this method may not present an alert, don’t call `requestReview(in:)`
in response to a button tap or other user action.

It’s up to your app to decide on the best timing for requesting reviews. For
design guidance, see Human Interface Guidelines > Ratings and reviews.

### Test review requests

When your app calls this method while it’s in development mode, StoreKit
always displays the rating and review request view, so you can test the user
interface and experience. However, this method has no effect in apps that you
distribute for beta testing using TestFlight.

### Provide a persistent link to your product page (optional)

Your customers can review your app at any time on the App Store. To make it
easier for people to leave reviews, you may include a persistent link to your
App Store product page in your app’s settings or configuration screens. Append
the query parameter `action=write-review` to your product page URL to
automatically open the App Store page where users can write a review.

## See Also

### Requesting reviews

`struct RequestReviewAction`

An instance that tells StoreKit to request an App Store rating or review, if
appropriate.

`static func requestReview(in: UIWindowScene)`

Tells StoreKit to request an App Store rating or review from the user, if
appropriate, using the specified scene.

Article

# Supporting subscription offer codes in your app

Provide subscription service for customers who redeem offer codes through the
App Store or within your app.

## Overview

To help you acquire, retain, and win back subscribers, you can use offer
codes. Offer codes are alphanumeric codes that provide subscriptions at a
discount or for free for a specific duration. Configure the offers and create
offer codes in App Store Connect, and distribute them to your customers.
Customers can redeem offer codes in the App Store, using offer code redemption
URLs, or in your app if you’ve implemented one of the following APIs:

  * `offerCodeRedemption(isPresented:onCompletion:)` or `presentOfferCodeRedeemSheet(in:)`, which are available in iOS 16 and later and iPadOS 16 and later

  * `presentCodeRedemptionSheet()`, which is available in iOS 14 and later and iPadOS 14 and later

When customers redeem a valid offer code, your app receives a successful
transaction. If customers redeem offer codes in the App Store and don’t have
your app installed, they’re prompted to download it as part of the redemption
flow. Successfully redeeming an offer code entitles the customer to the auto-
renewable subscription, the same as a purchase does. Your app needs to provide
service for the product.

### Set up offer codes in App Store Connect

Configure offers and manage your offer codes in App Store Connect. You can
have up to 10 active offers per subscription, and create codes for a maximum
of 1,000,000 redemptions per app, per quarter. There are two types of offer
codes: one-time use codes, and custom codes. The offer code redemption APIs
support both.

Download the offer codes from App Store Connect to distribute them to your
customers. For more information on creating and distributing offer codes, and
to learn which type of offer code may work for your campaign, see Set up offer
codes.

### Redeem offer codes in your app

To display the system sheet for customers to redeem offer codes within your
app, call one of the redemption APIs, depending on your app’s UI
implementation:

  * Call `offerCodeRedemption(isPresented:onCompletion:)` if your app uses SwiftUI.

  * Call `presentOfferCodeRedeemSheet(in:)` if your app uses UIKit.

  * Call `presentCodeRedemptionSheet()` for apps running on devices prior to iOS 16 and iPadOS 16.

The redemption sheet takes care of the redemption flow, including alerting
users about invalid entries, as appropriate. Invalid entries may include, for
example, expired offer codes, invalid codes, or codes that would result in a
subscription downgrade.

Including the redemption sheet in your app is recommended, but optional. For
more guidance on supporting offer code redemption within your app, see Human
Interface Guidelines > In-app purchase.

### Support offer codes redeemed outside of your app

Customers may redeem offer codes outside your app, by entering the offer code
in the App Store, or by using a redemption URL. To handle offer codes — and
other transactions that can occur outside of your app — your app needs to use
`updates` on `Transaction` to receive new transactions while the app is
running. Create a `Task` to iterate through the transactions from the listener
as soon as your app launches. For more information and sample code, see
`updates`.

When the app launches, it needs to check `all` or `currentEntitlements` on
`Transaction` to get any transactions that may have occurred while the app
wasn’t running. Process the transactions to ensure your app provides service
for all products it’s entitled to.

### Identify subscriptions purchased with offer codes

When customers successfully redeem subscription offer codes, the transaction
or subscription renewal information contain fields that identify the offer and
its offer type. Find the offer code details in the transaction information, in
your app and on your server, as follows.

In your app, use the following StoreKit APIs to locate the offer code
information:

  * See the `Transaction` properties `offerID` and `offerType`. An offer type value of `code` indicates the customer redeemed an offer code.

  * Some offer code redemptions may apply to an auto-renewable subscription’s next renewal period, for example, if the customer is already subscribed. In this case, see the `Product.SubscriptionInfo.RenewalInfo` properties `offerID` and `offerType`. An offer type value of `code` indicates the customer redeemed an offer code.

On your server, use the following server-side APIs to locate offer code
information:

  * In the App Store Server API, when you call endpoints such as Get Transaction History, Get All Subscription Statuses, and others, the response contains the signed transaction, `JWSTransaction`. In its decoded payload, `JWSTransactionDecodedPayload`, look for the fields `offerIdentifier` and `offerType`. An `offerType` value of `3` indicates the customer redeemed an offer code.

  * The App Store Server Notifications V2 sends a notification with an `OFFER_REDEEMED` `notificationType` when someone redeems an offer code. The decoded payloads `JWSTransactionDecodedPayload` and `JWSRenewalInfoDecodedPayload` contain the fields `offerIdentifier` and `offerType`. An `offerType` value of `3` indicates the customer redeemed an offer code.

### Provide subscription service to new and existing customers

When you acquire new customers with an offer code, they already have an auto-
renewable subscription when they open your app for the first time. In addition
to providing subscription service, you may need to update your backend
system’s records. Your app follows these steps:

  1. When the app launches, check `all` or `currentEntitlements` on `Transaction` to get all transactions or current entitlements, respectively. StoreKit automatically validates the transactions, and returns verified results in `VerificationResult.verified(_:)`. To perform your own validation, use the `jwsRepresentation` property.

  2. To determine if a subscription results from an offer code redemption, check the `offerID` and `offerType` properties on the subscription’s `Transaction`. 

  3. Provide the subscription service based on the offer and call `finish()` on `Transaction`. 

  4. Guide new customers through your new-user experience, as needed. Update your backend system’s records.

When an existing customer redeems an offer code within your app, the
transaction comes in through the `updates` sequence on `Transaction`. Process
the transaction as usual, providing service based on the offer, and call
`finish()`.

Type Method

# presentOfferCodeRedeemSheet(in:)

Displays a sheet in the window scene that enables users to redeem a
subscription offer code that you configure in App Store Connect.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    @MainActor
    static func presentOfferCodeRedeemSheet(in scene: UIWindowScene) async throws

##  Parameters

`scene`

    

The `UIWindowScene` that StoreKit uses to display the offer code redemption
sheet.

## Discussion

The `presentOfferCodeRedeemSheet(in:)` method displays a system sheet in the
window scene, where customers can enter and redeem subscription offer codes.
If you generate subscription offer codes in App Store Connect, call this
function to enable users to redeem the offer. To display the sheet using
SwiftUI, see `offerCodeRedemption(isPresented:onCompletion:)`.

Important

Set up subscription offer codes in App Store Connect before calling this API.
Customers can only redeem these offers in your app through the redemption
sheet; don’t use a custom UI.

For more information on offer codes, see Supporting subscription offer codes
in your app.

When customers redeem an offer code, StoreKit emits the resulting transaction
in `updates`. Set up a transaction listener as soon as your app launches to
receive new transactions while the app is running. For more information, see
`updates`.

In Mac apps built with Mac Catalyst, this method throws a
`StoreKitError.unknown` error.

## See Also

### Presenting the offer code redemption sheet

Supporting subscription offer codes in your app

Provide subscription service for customers who redeem offer codes through the
App Store or within your app.

`func offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: @MainActor
(Result<Void, any Error>) -> Void) -> View`

Presents a sheet that enables users to redeem subscription offer codes that
you configure in App Store Connect.

Instance Method

# offerCodeRedemption(isPresented:onCompletion:)

Presents a sheet that enables users to redeem subscription offer codes that
you configure in App Store Connect.

StoreKit  SwiftUI  iOS 16.0+  iPadOS 16.0+  Mac Catalyst 17.0+  visionOS 1.0+
Xcode 14.0+

    
    
    func offerCodeRedemption(
        isPresented: Binding<Bool>,
        onCompletion: @escaping @MainActor (Result<Void, any Error>) -> Void = { _ in }
    ) -> some View

##  Parameters

`isPresented`

    

A binding to a Boolean value that determines whether the system displays the
sheet. You set the Boolean value to `true` to cause the system to display the
sheet. The system sets it to `false` when it dismisses the sheet.

`onCompletion`

    

A closure that returns the result of the presentation.

In Mac apps built with Mac Catalyst, the completion handler returns a failure
with an error.

## Discussion

The `offerCodeRedemption(isPresented:onCompletion:)` method displays a system
sheet where customers can enter and redeem subscription offer codes. If you
generate subscription offer codes in App Store Connect, call this function to
enable users to redeem the offer. To display the sheet using UIKit, see
`presentOfferCodeRedeemSheet(in:)`.

Important

Set up subscription offer codes in App Store Connect before calling this API.
Customers can only redeem these offers in your app through the redemption
sheet; don’t use a custom UI.

For more information, see Supporting subscription offer codes in your app.

The following code example shows a view that displays the offer code
redemption sheet upon a button press:

When customers redeem an offer code, StoreKit emits the resulting transaction
in `updates`. Set up a transaction listener as soon as your app launches to
receive new transactions while the app is running. For more information, see
`updates`.

In Mac apps built with Mac Catalyst, the completion handler returns a failure
with an error.

## See Also

### Presenting the offer code redemption sheet

Supporting subscription offer codes in your app

Provide subscription service for customers who redeem offer codes through the
App Store or within your app.

`static func presentOfferCodeRedeemSheet(in: UIWindowScene)`

Displays a sheet in the window scene that enables users to redeem a
subscription offer code that you configure in App Store Connect.

Type Method

# sync()

Synchronizes your app’s transaction information and subscription status with
information from the App Store.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func sync() async throws

## Discussion

Include some mechanism in your app, such as a Restore Purchases button, to let
users restore their in-app purchases. In rare cases when a user suspects the
app isn’t showing all the transactions, call `sync()`. By calling `sync()`,
you force the app to obtain transaction information and subscription status
from the App Store.

Important

Calling `sync()`displays a system prompt that asks users to authenticate with
their App Store credentials. Call this function only in response to an
explicit user action, like tapping or clicking a button.

In regular operations, there’s no need to call `sync()`. StoreKit
automatically keeps up to date transaction information and subscription status
available to your app. When users reinstall your app or download it on a new
device, the app automatically has all transactions available to it upon
initial launch. There’s no need for users to ask your app to restore
transactions — your app can immediately get the current entitlements using
`currentEntitlements` and transaction history using `all`. For more
information about transactions, see `Transaction`.



# StoreButtonKind

Type Property

# cancellation

A type of button that people use to dismiss the current store presentation.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var cancellation: StoreButtonKind { get }

## See Also

### Getting button types for store views

`static var restorePurchases: StoreButtonKind`

A type of button that people use to restore purchases.

Type Property

# restorePurchases

A type of button that people use to restore purchases.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var restorePurchases: StoreButtonKind { get }

## See Also

### Getting button types for store views

`static var cancellation: StoreButtonKind`

A type of button that people use to dismiss the current store presentation.

Type Property

# signIn

A type of button that people use to sign in.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var signIn: StoreButtonKind { get }

## See Also

### Getting additional button types for subscription store views

`static var redeemCode: StoreButtonKind`

A type of button that people use to redeem an offer code.

`static var policies: StoreButtonKind`

A type of button that people use to display store policies.

Type Property

# redeemCode

A type of button that people use to redeem an offer code.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  Mac Catalyst 17.0+  visionOS 1.0+
Xcode 15.0+

    
    
    static var redeemCode: StoreButtonKind { get }

## See Also

### Getting additional button types for subscription store views

`static var signIn: StoreButtonKind`

A type of button that people use to sign in.

`static var policies: StoreButtonKind`

A type of button that people use to display store policies.

Type Property

# policies

A type of button that people use to display store policies.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var policies: StoreButtonKind { get }

## See Also

### Getting additional button types for subscription store views

`static var signIn: StoreButtonKind`

A type of button that people use to sign in.

`static var redeemCode: StoreButtonKind`

A type of button that people use to redeem an offer code.

Type Property

# cancellation

A type of button that people use to dismiss the current store presentation.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var cancellation: StoreButtonKind { get }

## See Also

### Getting button types for store views

`static var restorePurchases: StoreButtonKind`

A type of button that people use to restore purchases.

Type Property

# restorePurchases

A type of button that people use to restore purchases.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var restorePurchases: StoreButtonKind { get }

## See Also

### Getting button types for store views

`static var cancellation: StoreButtonKind`

A type of button that people use to dismiss the current store presentation.

Type Property

# signIn

A type of button that people use to sign in.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var signIn: StoreButtonKind { get }

## See Also

### Getting additional button types for subscription store views

`static var redeemCode: StoreButtonKind`

A type of button that people use to redeem an offer code.

`static var policies: StoreButtonKind`

A type of button that people use to display store policies.

Type Property

# redeemCode

A type of button that people use to redeem an offer code.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  Mac Catalyst 17.0+  visionOS 1.0+
Xcode 15.0+

    
    
    static var redeemCode: StoreButtonKind { get }

## See Also

### Getting additional button types for subscription store views

`static var signIn: StoreButtonKind`

A type of button that people use to sign in.

`static var policies: StoreButtonKind`

A type of button that people use to display store policies.

Type Property

# policies

A type of button that people use to display store policies.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var policies: StoreButtonKind { get }

## See Also

### Getting additional button types for subscription store views

`static var signIn: StoreButtonKind`

A type of button that people use to sign in.

`static var redeemCode: StoreButtonKind`

A type of button that people use to redeem an offer code.



# RegularProductViewStyle

Type Property

# regular

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var regular: RegularProductViewStyle { get }

Instance Method

# makeBody(configuration:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func makeBody(configuration: RegularProductViewStyle.Configuration) -> some View

## Relationships

### From Protocol

  * `ProductViewStyle`

## See Also

### Creating the style

`typealias RegularProductViewStyle.Body`

`init()`

Type Alias

# RegularProductViewStyle.Body

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias RegularProductViewStyle.Body = some View

## Relationships

### From Protocol

  * `ProductViewStyle`

## See Also

### Creating the style

`func makeBody(configuration: RegularProductViewStyle.Configuration) -> View`

`init()`

Initializer

# init()

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init()

## See Also

### Creating the style

`func makeBody(configuration: RegularProductViewStyle.Configuration) -> View`

`typealias RegularProductViewStyle.Body`



# Product

Generic Type Method

# products(for:)

Requests product data from the App Store.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func products<Identifiers>(for identifiers: Identifiers) async throws -> [Product] where Identifiers : Collection, Identifiers.Element == String

##  Parameters

`identifiers`

    

A collection of unique in-app purchase product identifiers that you previously
configured in App Store Connect. StoreKit ignores any duplicate identifiers in
the collection.

## Return Value

An array of products, returned from the App Store.

## Discussion

Use this method to get an instance of `Product`. Your app must have its
product identifiers available to provide them to this function. The following
example illustrates requesting two products using hard-coded identifiers.

You initially create product identifiers when you configure in-app purchases
in App Store Connect; for more information, see Create an in-app purchase.
Your app can store or retrieve product identifiers in several ways, such as
embedding the identifiers in the app bundle, or fetching them from your
server.

If any identifiers are invalid or the App Store can’t find them, the App Store
excludes them from the return value. The `products(for:)` function can throw a
`StoreKitError` for system-related errors.

Instance Property

# displayName

The localized display name of the product, if it exists.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let displayName: String

## Discussion

The storefront of the device determines the language of the display name, not
the preferred language set on the device. For more information, see
`Storefront`.

Note

When you create a new product in App Store Connect or in a StoreKit
configuration file, you can test it before you add a product localization. The
`displayName` value is an empty string until you add a localization. For more
information on localizations, see Add and remove localizations.

## See Also

### Displaying a product description and price

`let description: String`

The localized description of the product.

`let displayPrice: String`

The localized string representation of the product price, suitable for
display.

`let price: Decimal`

The decimal representation of the cost of the product, in local currency.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency`

The format style for the numbers in the price of the product.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var subscriptionPeriodFormatStyle:
Date.ComponentsFormatStyle`

The format style for the date components related to a subscription’s duration.

`var subscriptionPeriodUnitFormatStyle:
Product.SubscriptionPeriod.Unit.FormatStyle`

The format style for subscription period units, such as week, month, or year.

Instance Property

# description

The localized description of the product.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let description: String

## Discussion

The storefront of the device determines the language of the `description`, not
the preferred language set on the device. For more information, see
`Storefront`.

Note

When you create a new product in App Store Connect or in a StoreKit
configuration file, you can test it before you add a product localization. The
`description` value is an empty string until you add a localization. For more
information on localizations, see Add and remove localizations.

## See Also

### Displaying a product description and price

`let displayName: String`

The localized display name of the product, if it exists.

`let displayPrice: String`

The localized string representation of the product price, suitable for
display.

`let price: Decimal`

The decimal representation of the cost of the product, in local currency.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency`

The format style for the numbers in the price of the product.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var subscriptionPeriodFormatStyle:
Date.ComponentsFormatStyle`

The format style for the date components related to a subscription’s duration.

`var subscriptionPeriodUnitFormatStyle:
Product.SubscriptionPeriod.Unit.FormatStyle`

The format style for subscription period units, such as week, month, or year.

Instance Property

# displayPrice

The localized string representation of the product price, suitable for
display.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let displayPrice: String

## Discussion

Use this string to display the price, formatted for the locale. The storefront
that the user’s device is connected to determines the locale. For more
information, see `Storefront`.

To perform arithmetic calculations with the price, use the `price` property
instead.

## See Also

### Displaying a product description and price

`let displayName: String`

The localized display name of the product, if it exists.

`let description: String`

The localized description of the product.

`let price: Decimal`

The decimal representation of the cost of the product, in local currency.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency`

The format style for the numbers in the price of the product.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var subscriptionPeriodFormatStyle:
Date.ComponentsFormatStyle`

The format style for the date components related to a subscription’s duration.

`var subscriptionPeriodUnitFormatStyle:
Product.SubscriptionPeriod.Unit.FormatStyle`

The format style for subscription period units, such as week, month, or year.

Instance Property

# price

The decimal representation of the cost of the product, in local currency.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let price: Decimal

## Discussion

Use this property to perform arithmetic calculations with the price of the
product. For a localized string representation of the price to display to
customers, use the `displayPrice` property instead.

## See Also

### Displaying a product description and price

`let displayName: String`

The localized display name of the product, if it exists.

`let description: String`

The localized description of the product.

`let displayPrice: String`

The localized string representation of the product price, suitable for
display.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency`

The format style for the numbers in the price of the product.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var subscriptionPeriodFormatStyle:
Date.ComponentsFormatStyle`

The format style for the date components related to a subscription’s duration.

`var subscriptionPeriodUnitFormatStyle:
Product.SubscriptionPeriod.Unit.FormatStyle`

The format style for subscription period units, such as week, month, or year.

Instance Property

# priceFormatStyle

The format style for the numbers in the price of the product.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var priceFormatStyle: Decimal.FormatStyle.Currency { get }

## Discussion

The `priceFormatStyle` value is a localized number suitable for display.

To display the `price` directly, rather than making calculations, use the
`displayPrice` string instead.

## See Also

### Displaying a product description and price

`let displayName: String`

The localized display name of the product, if it exists.

`let description: String`

The localized description of the product.

`let displayPrice: String`

The localized string representation of the product price, suitable for
display.

`let price: Decimal`

The decimal representation of the cost of the product, in local currency.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var subscriptionPeriodFormatStyle:
Date.ComponentsFormatStyle`

The format style for the date components related to a subscription’s duration.

`var subscriptionPeriodUnitFormatStyle:
Product.SubscriptionPeriod.Unit.FormatStyle`

The format style for subscription period units, such as week, month, or year.

Instance Property

# subscriptionPeriodFormatStyle

The format style for the date components related to a subscription’s duration.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var subscriptionPeriodFormatStyle: Date.ComponentsFormatStyle { get }

## Discussion

Use this format style to format text that describes a subscription period,
including its length and unit, such as “1 week”, “2 months”, and so on.

## See Also

### Displaying a product description and price

`let displayName: String`

The localized display name of the product, if it exists.

`let description: String`

The localized description of the product.

`let displayPrice: String`

The localized string representation of the product price, suitable for
display.

`let price: Decimal`

The decimal representation of the cost of the product, in local currency.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency`

The format style for the numbers in the price of the product.

`var subscriptionPeriodUnitFormatStyle:
Product.SubscriptionPeriod.Unit.FormatStyle`

The format style for subscription period units, such as week, month, or year.

Instance Property

# subscriptionPeriodUnitFormatStyle

The format style for subscription period units, such as week, month, or year.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var subscriptionPeriodUnitFormatStyle: Product.SubscriptionPeriod.Unit.FormatStyle { get }

## See Also

### Displaying a product description and price

`let displayName: String`

The localized display name of the product, if it exists.

`let description: String`

The localized description of the product.

`let displayPrice: String`

The localized string representation of the product price, suitable for
display.

`let price: Decimal`

The decimal representation of the cost of the product, in local currency.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency`

The format style for the numbers in the price of the product.

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var subscriptionPeriodFormatStyle:
Date.ComponentsFormatStyle`

The format style for the date components related to a subscription’s duration.

Instance Method

# purchase(options:)

Initiates a purchase for the product with the App Store and displays the
confirmation sheet.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  Xcode 13.0+

    
    
    func purchase(options: Set<Product.PurchaseOption> = []) async throws -> Product.PurchaseResult

##  Parameters

`options`

    

A set of options you can associate with the purchase.

## Return Value

Returns a `Product.PurchaseResult`.

## Discussion

StoreKit provides several APIs you can use to enable customers to initiate a
purchase. Before using `purchase(options:)` consider the following APIs and
choose the one that best suits your app’s implementation:

  * Use `PurchaseAction` for apps that use SwiftUI, including multi-scene apps for visionOS.

  * Use `purchase(confirmIn:options:)` for apps that use UIKit.

  * Use `purchase(options:)` if your app runs on watchOS or macOS.

Important

If you use StoreKit views such as `ProductView`, `StoreView`, or
`SubscriptionStoreView` you don’t need to call any other API to initiate a
purchase. StoreKit manages the purchase action automatically, including
presenting the purchase confirmation UI. For more information, see StoreKit
views.

### Use the purchase API

Call the `purchase(options:)` method when a customer initiates a purchase,
either within your app or after selecting a promoted in-app purchase on the
App Store. This method brings up the system-confirmation sheet. The user can
confirm to complete the transaction or cancel it.

Include the purchase options to provide additional information about the
purchase, such as:

  * `appAccountToken(_:)` to associate the purchase with the resulting transaction

  * `promotionalOffer(offerID:keyID:nonce:signature:timestamp:)`, if the customer is redeeming a promotional offer for an auto-renewable subscription

  * `quantity(_:)`, if the customer is purchasing more than one of the product

The following example illustrates calling `purchase(options:)` using the
`options` parameter to provide an app account token:

If you’re testing your app in the sandbox environment, test an Ask to Buy
scenario by setting the `simulatesAskToBuyInSandbox(_:)` purchase option to
`true`. For more information about Ask to Buy, see Approve what kids buy with
Ask to Buy.

This method may throw a `Product.PurchaseError` or `StoreKitError`.

For more information about purchases that users initiate on the App Store, see
Promoting in-app purchases.

## See Also

### Purchasing a product

`func purchase(confirmIn: some UIScene, options: Set<Product.PurchaseOption>)
-> Product.PurchaseResult`

Initiates a purchase for the product with the App Store and displays the
confirmation sheet.

`struct Product.PurchaseOption`

Optional settings for a product purchase.

`enum Product.PurchaseResult`

The result of a purchase.

`enum Product.PurchaseError`

Error information for product purchase errors.

Instance Method

# purchase(confirmIn:options:)

Initiates a purchase for the product with the App Store and displays the
confirmation sheet.

iOS 17.0+  iPadOS 17.0+  Mac Catalyst 17.0+  tvOS 17.0+  visionOS 1.0+  Xcode
15.0+

    
    
    func purchase(
        confirmIn scene: some UIScene,
        options: Set<Product.PurchaseOption> = []
    ) async throws -> Product.PurchaseResult

##  Parameters

`scene`

    

The `UIScene` the system uses to show the purchase confirmation UI.

`options`

    

A set of options (`Product.PurchaseOption`) you can associate with the
purchase.

## Return Value

The result of the purchase, `Product.PurchaseResult`.

## Discussion

StoreKit provides several APIs you can use to enable customers to initiate a
purchase. Before using `purchase(confirmIn:options:)`, consider the following
APIs and choose the one that best suits your app’s implementation:

  * Use `PurchaseAction` for apps that use SwiftUI, including multi-scene apps for visionOS.

  * Use `purchase(confirmIn:options:)` for apps that use UIKit.

  * Use `purchase(options:)` if your app runs on watchOS or macOS.

Important

If you use StoreKit views such as `ProductView`, `StoreView`, or
`SubscriptionStoreView` you don’t need to call any other API to initiate a
purchase. StoreKit manages the purchase action automatically, including
presenting the purchase confirmation UI. For more information, see StoreKit
views.

The `purchase(confirmIn:options:)` method may throw a `Product.PurchaseError`
or `StoreKitError`.

## See Also

### Purchasing a product

`func purchase(options: Set<Product.PurchaseOption>) ->
Product.PurchaseResult`

Initiates a purchase for the product with the App Store and displays the
confirmation sheet.

`struct Product.PurchaseOption`

Optional settings for a product purchase.

`enum Product.PurchaseResult`

The result of a purchase.

`enum Product.PurchaseError`

Error information for product purchase errors.

Instance Property

# currentEntitlement

The transaction that entitles the user to the product.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var currentEntitlement: VerificationResult<Transaction>? { get async }

## Discussion

This value is `nil` if the user isn’t currently entitled to this product.
Current entitlement information applies only to non-consumables, non-renewing
subscriptions, and auto-renewable subscriptions. The following example checks
the current entitlement for a product.

Instance Property

# latestTransaction

The most recent transaction for the product.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var latestTransaction: VerificationResult<Transaction>? { get async }

## Discussion

This value is `nil` if the user has never purchased this product. The
following example illustrates requesting the latest transaction for a product
to determine whether the user has purchased the product.

Instance Property

# subscription

The subscription information for an auto-renewable subscripton.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let subscription: Product.SubscriptionInfo?

## Discussion

A `nil` value indicates that this product isn’t an auto-renewable
subscription.

For more information about subscriptions, see Auto-renewable Subscriptions.

## See Also

### Getting subscription information

`struct Product.SubscriptionInfo`

Information about an auto-renewable subscription, such as its status, period,
subscription group, and subscription offer details.

`struct Product.SubscriptionPeriod`

Values that represent the duration of time between subscription renewals.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

`struct Product.SubscriptionInfo.Status`

The renewal status information for an auto-renewable subscription.

Instance Property

# id

The unique product identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let id: String

## Relationships

### From Protocol

  * `Identifiable`

## See Also

### Getting product identifiers and type

`typealias Product.ID`

A type representing a unique product identifier.

`let type: Product.ProductType`

The in-app purchase product type.

`struct Product.ProductType`

The types of in-app purchases.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Product` conforms to `AnyObject`.

Type Alias

# Product.ID

A type representing a unique product identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.ID = String

## See Also

### Getting product identifiers and type

`let id: String`

The unique product identifier.

`let type: Product.ProductType`

The in-app purchase product type.

`struct Product.ProductType`

The types of in-app purchases.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Product` conforms to `AnyObject`.

Instance Property

# type

The in-app purchase product type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let type: Product.ProductType

## See Also

### Getting product identifiers and type

`let id: String`

The unique product identifier.

`typealias Product.ID`

A type representing a unique product identifier.

`struct Product.ProductType`

The types of in-app purchases.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Product` conforms to `AnyObject`.

Instance Property

# id

The stable identity of the entity associated with this instance.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 11.0+

    
    
    var id: ObjectIdentifier { get }

Available when `Product` conforms to `AnyObject`.

## Discussion

Note

This documentation comment was inherited from `Identifiable`.

## See Also

### Getting product identifiers and type

`let id: String`

The unique product identifier.

`typealias Product.ID`

A type representing a unique product identifier.

`let type: Product.ProductType`

The in-app purchase product type.

`struct Product.ProductType`

The types of in-app purchases.

Instance Property

# isFamilyShareable

A Boolean value that indicates whether the product is available for Family
Sharing in App Store Connect.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let isFamilyShareable: Bool

## Discussion

Check the value of `isFamilyShareable` to learn whether an in-app purchase is
sharable with the family group.

When displaying in-app purchases in your app, indicate whether the product
includes Family Sharing to help customers make a selection that best fits
their needs.

Configure your in-app purchases to allow Family Sharing in App Store Connect.
For more information about setting up Family Sharing, see Turn-on Family
Sharing for in-app purchases.

Instance Property

# jsonRepresentation

The raw JSON representation of the product information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var jsonRepresentation: Data { get }

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product, rhs: Product) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing products

`static func == (Product, Product) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (lhs: Product, rhs: Product) -> Bool

## See Also

### Comparing and hashing products

`static func != (Product, Product) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing products

`static func != (Product, Product) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product, Product) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing products

`static func != (Product, Product) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product, Product) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Instance Property

# debugDescription

A string representation of the product structure, suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`



# SKPayment

Initializer

# init(product:)

Returns a new payment for the specified product.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    convenience init(product: SKProduct)

##  Parameters

`product`

    

The product the user wishes to purchase.

## Return Value

A new payment object.

## Discussion

This Object creation uses the `productIdentifier` property obtained from the
`product` parameter to create and return a new payment with that identifier.
The quantity property defaults to `1`.

To create a `SKPayment` object with a quantity greater than `1`, create a
`SKMutablePayment` object, adjust its `quantity` property and then add it to
the payment queue.

## See Also

### Related Documentation

In-App Purchase Programming Guide

Instance Property

# productIdentifier

A string used to identify a product that can be purchased from within your
app.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var productIdentifier: String { get }

## Discussion

The product identifier is a string previously agreed on between your app and
the Apple App Store.

## See Also

### Getting Payment Details

`var quantity: Int`

The number of items the user wants to purchase.

`var requestData: Data?`

Reserved for future use.

`var applicationUsername: String?`

A string that associates the transaction with a user account on your service.

Instance Property

# quantity

The number of items the user wants to purchase.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var quantity: Int { get }

## Discussion

The default value is 1, the minimum value is 1, and the maximum value is 10.

## See Also

### Getting Payment Details

`var productIdentifier: String`

A string used to identify a product that can be purchased from within your
app.

`var requestData: Data?`

Reserved for future use.

`var applicationUsername: String?`

A string that associates the transaction with a user account on your service.

Instance Property

# requestData

Reserved for future use.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var requestData: Data? { get }

## Discussion

The default value is `nil`. If `requestData` is not `nil`, your payment
request will be rejected.

## See Also

### Getting Payment Details

`var productIdentifier: String`

A string used to identify a product that can be purchased from within your
app.

`var quantity: Int`

The number of items the user wants to purchase.

`var applicationUsername: String?`

A string that associates the transaction with a user account on your service.

Instance Property

# applicationUsername

A string that associates the transaction with a user account on your service.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var applicationUsername: String? { get }

## Discussion

For more information on how to set and use this property, see
`applicationUsername`.

## See Also

### Getting Payment Details

`var productIdentifier: String`

A string used to identify a product that can be purchased from within your
app.

`var quantity: Int`

The number of items the user wants to purchase.

`var requestData: Data?`

Reserved for future use.

Instance Property

# simulatesAskToBuyInSandbox

A Boolean value that produces an "ask to buy" flow for this payment in the
sandbox.

iOS 8.3+  iPadOS 8.3+  macOS 10.14+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var simulatesAskToBuyInSandbox: Bool { get }

Instance Property

# paymentDiscount

The details of the discount offer to apply to the payment.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    @NSCopying
    var paymentDiscount: SKPaymentDiscount? { get }

## See Also

### Getting Discount Details

`class SKPaymentDiscount`

The signed discount to apply to a payment.



# SKPaymentDiscount

Initializer

# init(identifier:keyIdentifier:nonce:signature:timestamp:)

Initializes the payment discount with a signature and the parameters used by
the signature.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    init(
        identifier: String,
        keyIdentifier: String,
        nonce: UUID,
        signature: String,
        timestamp: NSNumber
    )

Instance Property

# identifier

A string used to uniquely identify a discount offer for a product.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var identifier: String { get }

## Discussion

You set up offers and their identifiers in App Store Connect. If the
`identifier` is not valid, an `SKError.Code.invalidOfferIdentifier` error can
result.

## See Also

### Identifying the Discount

`var keyIdentifier: String`

A string that identifies the key used to generate the signature.

Instance Property

# keyIdentifier

A string that identifies the key used to generate the signature.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var keyIdentifier: String { get }

## Discussion

You generate and download keys from App Store Connect. See the “KEY ID” column
in App Store Connect to use as the `keyIdentifier`.

## See Also

### Identifying the Discount

`var identifier: String`

A string used to uniquely identify a discount offer for a product.

Instance Property

# nonce

A universally unique ID (UUID) value that you define.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var nonce: UUID { get }

## Discussion

Your server generates a unique `nonce` when it creates the `signature` string
for the payment discount. The string representation of the `nonce` must be
lowercase.

You can use a `nonce` one time; generate a new one for every buy request.

## See Also

### Validating the Discount

`var signature: String`

A string representing the properties of a specific promotional offer,
cryptographically signed.

`var timestamp: NSNumber`

The date and time of the signature's creation in milliseconds, formatted in
Unix epoch time.

Instance Property

# signature

A string representing the properties of a specific promotional offer,
cryptographically signed.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var signature: String { get }

## Discussion

The `signature` is a string signed with your private key that represents the
properties of a specific promotional offer. To keep your private key secure,
generate the `signature` on a server.

Generate the `signature` using the Elliptic Curve Digital Signature Algorithm
(ECDSA) with SHA 256. For more information, see Generating a signature for
promotional offers.

## See Also

### Validating the Discount

`var nonce: UUID`

A universally unique ID (UUID) value that you define.

`var timestamp: NSNumber`

The date and time of the signature's creation in milliseconds, formatted in
Unix epoch time.

Instance Property

# timestamp

The date and time of the signature's creation in milliseconds, formatted in
Unix epoch time.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    @NSCopying
    var timestamp: NSNumber { get }

## Discussion

The `timestamp` keeps the payment discount active for 24 hours.

## See Also

### Validating the Discount

`var nonce: UUID`

A universally unique ID (UUID) value that you define.

`var signature: String`

A string representing the properties of a specific promotional offer,
cryptographically signed.

Initializer

# init(identifier:keyIdentifier:nonce:signature:timestamp:)

Initializes the payment discount with a signature and the parameters used by
the signature.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    init(
        identifier: String,
        keyIdentifier: String,
        nonce: UUID,
        signature: String,
        timestamp: NSNumber
    )

Instance Property

# identifier

A string used to uniquely identify a discount offer for a product.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var identifier: String { get }

## Discussion

You set up offers and their identifiers in App Store Connect. If the
`identifier` is not valid, an `SKError.Code.invalidOfferIdentifier` error can
result.

## See Also

### Identifying the Discount

`var keyIdentifier: String`

A string that identifies the key used to generate the signature.

Instance Property

# keyIdentifier

A string that identifies the key used to generate the signature.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var keyIdentifier: String { get }

## Discussion

You generate and download keys from App Store Connect. See the “KEY ID” column
in App Store Connect to use as the `keyIdentifier`.

## See Also

### Identifying the Discount

`var identifier: String`

A string used to uniquely identify a discount offer for a product.

Instance Property

# nonce

A universally unique ID (UUID) value that you define.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var nonce: UUID { get }

## Discussion

Your server generates a unique `nonce` when it creates the `signature` string
for the payment discount. The string representation of the `nonce` must be
lowercase.

You can use a `nonce` one time; generate a new one for every buy request.

## See Also

### Validating the Discount

`var signature: String`

A string representing the properties of a specific promotional offer,
cryptographically signed.

`var timestamp: NSNumber`

The date and time of the signature's creation in milliseconds, formatted in
Unix epoch time.

Instance Property

# signature

A string representing the properties of a specific promotional offer,
cryptographically signed.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var signature: String { get }

## Discussion

The `signature` is a string signed with your private key that represents the
properties of a specific promotional offer. To keep your private key secure,
generate the `signature` on a server.

Generate the `signature` using the Elliptic Curve Digital Signature Algorithm
(ECDSA) with SHA 256. For more information, see Generating a signature for
promotional offers.

## See Also

### Validating the Discount

`var nonce: UUID`

A universally unique ID (UUID) value that you define.

`var timestamp: NSNumber`

The date and time of the signature's creation in milliseconds, formatted in
Unix epoch time.

Instance Property

# timestamp

The date and time of the signature's creation in milliseconds, formatted in
Unix epoch time.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    @NSCopying
    var timestamp: NSNumber { get }

## Discussion

The `timestamp` keeps the payment discount active for 24 hours.

## See Also

### Validating the Discount

`var nonce: UUID`

A universally unique ID (UUID) value that you define.

`var signature: String`

A string representing the properties of a specific promotional offer,
cryptographically signed.



# SKStorefront

Instance Property

# countryCode

The three-letter code representing the country or region associated with the
App Store storefront.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 13.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var countryCode: String { get }

## Discussion

This property uses the ISO 3166-1 Alpha-3 country code representation.

## See Also

### Identifying the Storefront

`var identifier: String`

A value defined by Apple that uniquely identifies an App Store storefront.

Instance Property

# identifier

A value defined by Apple that uniquely identifies an App Store storefront.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 13.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var identifier: String { get }

## See Also

### Identifying the Storefront

`var countryCode: String`

The three-letter code representing the country or region associated with the
App Store storefront.



# Transaction properties

Instance Property

# environment

The server environment that generates and signs the transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let environment: AppStore.Environment

## See Also

### Getting the environment and storefront

`let storefront: Storefront`

The App Store storefront associated with the transaction.

Instance Property

# storefront

The App Store storefront associated with the transaction.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    let storefront: Storefront

## See Also

### Getting the environment and storefront

`let environment: AppStore.Environment`

The server environment that generates and signs the transaction.

Instance Property

# originalID

The original transaction identifier of a purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let originalID: UInt64

## Discussion

The original transaction identifier, `originalID`, is identical to `id` except
when the user restores a purchase or renews a transaction. You can use this
value to:

  * Identify one or more renewals for the same subscription.

  * Differentiate a purchase transaction from a restore or a renewal transaction. For restore and renewal transactions, the original transaction identifier, `originalID`, and transaction identifier, `id`, differ.

  * Match a transaction in the app with a transaction you receive on your server in an App Store Server Notifications event.

## See Also

### Getting the original transaction identifier

`let originalPurchaseDate: Date`

The date of purchase for the original transaction.

Instance Property

# originalPurchaseDate

The date of purchase for the original transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let originalPurchaseDate: Date

## See Also

### Getting the original transaction identifier

`let originalID: UInt64`

The original transaction identifier of a purchase.

Instance Property

# id

The unique identifier for the transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let id: UInt64

## Discussion

Every transaction such as an in-app purchase, restore, or subscription renewal
has a unique transaction identifier.

## Relationships

### From Protocol

  * `Identifiable`

## See Also

### Identifying a transaction

`typealias Transaction.ID`

A type representing the transaction identifier.

`let webOrderLineItemID: String?`

A unique ID that identifies subscription purchase events across devices,
including subscription renewals.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Transaction` conforms to `AnyObject`.

Type Alias

# Transaction.ID

A type representing the transaction identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Transaction.ID = UInt64

## See Also

### Identifying a transaction

`let id: UInt64`

The unique identifier for the transaction.

`let webOrderLineItemID: String?`

A unique ID that identifies subscription purchase events across devices,
including subscription renewals.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Transaction` conforms to `AnyObject`.

Instance Property

# webOrderLineItemID

A unique ID that identifies subscription purchase events across devices,
including subscription renewals.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let webOrderLineItemID: String?

## See Also

### Identifying a transaction

`let id: UInt64`

The unique identifier for the transaction.

`typealias Transaction.ID`

A type representing the transaction identifier.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Transaction` conforms to `AnyObject`.

Instance Property

# id

The stable identity of the entity associated with this instance.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 11.0+

    
    
    var id: ObjectIdentifier { get }

Available when `Transaction` conforms to `AnyObject`.

## Discussion

Note

This documentation comment was inherited from `Identifiable`.

## See Also

### Identifying a transaction

`let id: UInt64`

The unique identifier for the transaction.

`typealias Transaction.ID`

A type representing the transaction identifier.

`let webOrderLineItemID: String?`

A unique ID that identifies subscription purchase events across devices,
including subscription renewals.

Instance Property

# appBundleID

The bundle identifier for the app.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let appBundleID: String

## See Also

### Identifying the app and product

`let productID: String`

The product identifier of the in-app purchase.

`let productType: Product.ProductType`

The type of the in-app purchase.

`let subscriptionGroupID: String?`

The identifier of the subscription group that the subscription belongs to.

Instance Property

# productID

The product identifier of the in-app purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let productID: String

## Discussion

You create product identifiers for in-app purchases in App Store Connect.

## See Also

### Identifying the app and product

`let appBundleID: String`

The bundle identifier for the app.

`let productType: Product.ProductType`

The type of the in-app purchase.

`let subscriptionGroupID: String?`

The identifier of the subscription group that the subscription belongs to.

Instance Property

# productType

The type of the in-app purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let productType: Product.ProductType

## See Also

### Identifying the app and product

`let appBundleID: String`

The bundle identifier for the app.

`let productID: String`

The product identifier of the in-app purchase.

`let subscriptionGroupID: String?`

The identifier of the subscription group that the subscription belongs to.

Instance Property

# subscriptionGroupID

The identifier of the subscription group that the subscription belongs to.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let subscriptionGroupID: String?

## See Also

### Identifying the app and product

`let appBundleID: String`

The bundle identifier for the app.

`let productID: String`

The product identifier of the in-app purchase.

`let productType: Product.ProductType`

The type of the in-app purchase.

Instance Property

# purchaseDate

The date that the App Store charged the user’s account for a purchased or
restored product, or for a subscription purchase or renewal after a lapse.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let purchaseDate: Date

## See Also

### Getting purchase and expiration dates

`let expirationDate: Date?`

The date the subscription expires or renews.

Instance Property

# expirationDate

The date the subscription expires or renews.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let expirationDate: Date?

## See Also

### Getting purchase and expiration dates

`let purchaseDate: Date`

The date that the App Store charged the user’s account for a purchased or
restored product, or for a subscription purchase or renewal after a lapse.

Instance Property

# isUpgraded

A Boolean that indicates whether the user upgraded to another subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let isUpgraded: Bool

## Discussion

If `isUpgraded` is `true`, the user has upgraded the subscription represented
by this transaction to another subscription. This value appears in the
transaction only when the value is `true`. To determine the service that the
customer is entitled to, look for another transaction that has a subscription
with a higher level of service.

## See Also

### Getting purchase details

`let ownershipType: Transaction.OwnershipType`

A value that indicates whether the transaction was purchased by the user, or
is made available to them through Family Sharing.

`typealias Transaction.OwnershipType.RawValue`

The type that represents the raw value of a transaction’s ownership type.

`struct Transaction.OwnershipType`

The types the system uses to describe whether the user purchased the product
or it’s available to them through Family Sharing.

`let purchasedQuantity: Int`

The number of consumable products purchased.

Instance Property

# ownershipType

A value that indicates whether the transaction was purchased by the user, or
is made available to them through Family Sharing.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let ownershipType: Transaction.OwnershipType

## See Also

### Getting purchase details

`let isUpgraded: Bool`

A Boolean that indicates whether the user upgraded to another subscription.

`typealias Transaction.OwnershipType.RawValue`

The type that represents the raw value of a transaction’s ownership type.

`struct Transaction.OwnershipType`

The types the system uses to describe whether the user purchased the product
or it’s available to them through Family Sharing.

`let purchasedQuantity: Int`

The number of consumable products purchased.

Type Alias

# Transaction.OwnershipType.RawValue

The type that represents the raw value of a transaction’s ownership type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Transaction.OwnershipType.RawValue = String

## See Also

### Accessing the raw value

`let rawValue: String`

The raw string value that represents a transaction ownership type.

Instance Property

# purchasedQuantity

The number of consumable products purchased.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let purchasedQuantity: Int

## See Also

### Getting purchase details

`let isUpgraded: Bool`

A Boolean that indicates whether the user upgraded to another subscription.

`let ownershipType: Transaction.OwnershipType`

A value that indicates whether the transaction was purchased by the user, or
is made available to them through Family Sharing.

`typealias Transaction.OwnershipType.RawValue`

The type that represents the raw value of a transaction’s ownership type.

`struct Transaction.OwnershipType`

The types the system uses to describe whether the user purchased the product
or it’s available to them through Family Sharing.

Instance Property

# subscriptionStatus

An array that contains status information for a subscription group, including
renewal and transaction information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 17.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0)
    var subscriptionStatus: Product.SubscriptionInfo.Status? { get async }

## Discussion

This value is `nil` if the product in the transaction isn’t an auto-renewable
subscription, specifically, if the `productType` is anything other than
`autoRenewable`.

The array can have more than one subscription status, for example, if your
subscription supports Family Sharing. Provide the customer with service for
the subscription based on the highest level of service where the subscription
status is `subscribed`.

Instance Property

# reason

The cause of the purchase transaction, whether it’s a customer’s purchase or
an auto-renewable subscription renewal that the system initiates.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    let reason: Transaction.Reason

## See Also

### Getting transaction reason

`struct Transaction.Reason`

A cause of a purchase transaction, indicating whether it’s a customer’s
purchase or an auto-renewable subscription renewal that the system initiates.

Instance Property

# offer

The subscription offer that applies to the transaction, including its offer
type, payment mode, and ID.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    let offer: Transaction.Offer?

## Discussion

This value is `nil` if the transaction doesn’t include an offer.

Subscription offers include introductory offers, promotional offers, and offer
codes. You set up subscription offers in App Store Connect. If a customer
redeems an offer, this property contains the offer details, including its
`type`, `paymentMode`, and `id`. For more information about the details, see
`Transaction.Offer`.

## See Also

### Identifying subscription offers

`struct Transaction.Offer`

The subscription offers that apply to a transaction.

Instance Property

# revocationDate

The date that the App Store refunded the transaction or revoked it from Family
Sharing.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let revocationDate: Date?

## See Also

### Getting revocation status

`let revocationReason: Transaction.RevocationReason?`

The reason that the App Store refunded the transaction or revoked it from
Family Sharing.

`struct Transaction.RevocationReason`

Reasons that describe why the App Store may refund a transaction or revoke it
from Family Sharing.

`typealias Transaction.RevocationReason.RawValue`

The type that represents the raw value of a transaction revocation reason.

Instance Property

# revocationReason

The reason that the App Store refunded the transaction or revoked it from
Family Sharing.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let revocationReason: Transaction.RevocationReason?

## See Also

### Getting revocation status

`let revocationDate: Date?`

The date that the App Store refunded the transaction or revoked it from Family
Sharing.

`struct Transaction.RevocationReason`

Reasons that describe why the App Store may refund a transaction or revoke it
from Family Sharing.

`typealias Transaction.RevocationReason.RawValue`

The type that represents the raw value of a transaction revocation reason.

Type Alias

# Transaction.RevocationReason.RawValue

The type that represents the raw value of a transaction revocation reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Transaction.RevocationReason.RawValue = Int

## See Also

### Revocation reasons

`static let developerIssue: Transaction.RevocationReason`

The value that indicates a customer canceled the transaction due to an actual
or perceived issue within your app.

`static let other: Transaction.RevocationReason`

The value that indicates a customer canceled the transaction for other
reasons.

Instance Property

# appAccountToken

A UUID that associates the transaction with a user on your own service.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let appAccountToken: UUID?

## Discussion

You create an `appAccountToken(_:)` and send it to the App Store when a
customer initiates an in-app purchase. The App Store returns the same value in
`appAccountToken` in the transaction information after the customer completes
the purchase.

Instance Property

# environmentStringRepresentation

A string representation of the server environment.

iOS 15.0–16.0  Deprecated  iPadOS 15.0–16.0  Deprecated  macOS 12.0–13.0
Deprecated  Mac Catalyst 16.0–16.0  Deprecated  tvOS 15.0–16.0  Deprecated
watchOS 8.0–9.0  Deprecated  Xcode 13.0–14.0  Deprecated

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var environmentStringRepresentation: String { get }

Deprecated

Use `environment` instead.

## See Also

### Deprecated

`var offerID: String?`

A string that identifies an offer applied to the current subscription.

Deprecated

`@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var
offerPaymentModeStringRepresentation: String?`

The string representation of the payment mode for a subscription offer.

Deprecated

`var offerType: Transaction.OfferType?`

The subscription offer type for the current subscription period.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var reasonStringRepresentation: String`

The string representation of the transaction reason.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var storefrontCountryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront of the purchase.

Deprecated

Instance Property

# offerID

A string that identifies an offer applied to the current subscription.

iOS 15.0–17.2  Deprecated  iPadOS 15.0–17.2  Deprecated  macOS 12.0–14.2
Deprecated  Mac Catalyst 15.0–17.2  Deprecated  tvOS 15.0–17.2  Deprecated
watchOS 8.0–10.2  Deprecated  visionOS 1.0–1.1  Deprecated  Xcode 13.0–15.1
Deprecated

    
    
    var offerID: String? { get }

Deprecated

Use `offer` instead.

## Discussion

This value is `nil` if there isn’t an offer, or if the offer type is
`introductory`.

If the offer type is `promotional`, this value contains the promotional offer
identifier you set up in App Store Connect. For more information about
promotional offers, see Set up promotional offers for auto-renewable
subscriptions.

If the offer type is `code`, this value contains the reference name of the
offer code you set up in App Store Connect. For more information about offer
codes, see Set up offer codes.

## See Also

### Deprecated

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

A string representation of the server environment.

Deprecated

`@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var
offerPaymentModeStringRepresentation: String?`

The string representation of the payment mode for a subscription offer.

Deprecated

`var offerType: Transaction.OfferType?`

The subscription offer type for the current subscription period.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var reasonStringRepresentation: String`

The string representation of the transaction reason.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var storefrontCountryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront of the purchase.

Deprecated

Instance Property

# offerPaymentModeStringRepresentation

The string representation of the payment mode for a subscription offer.

iOS 15.0–17.2  Deprecated  iPadOS 15.0–17.2  Deprecated  macOS 12.0–14.2
Deprecated  Mac Catalyst 17.2–17.2  Deprecated  tvOS 15.0–17.2  Deprecated
watchOS 8.0–10.2  Deprecated  visionOS 1.1–1.1  Deprecated  Xcode 13.0–15.1
Deprecated

    
    
    @backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2)
    var offerPaymentModeStringRepresentation: String? { get }

Deprecated

Use `paymentMode` instead.

## See Also

### Deprecated

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

A string representation of the server environment.

Deprecated

`var offerID: String?`

A string that identifies an offer applied to the current subscription.

Deprecated

`var offerType: Transaction.OfferType?`

The subscription offer type for the current subscription period.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var reasonStringRepresentation: String`

The string representation of the transaction reason.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var storefrontCountryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront of the purchase.

Deprecated

Instance Property

# offerType

The subscription offer type for the current subscription period.

iOS 15.0–17.2  Deprecated  iPadOS 15.0–17.2  Deprecated  macOS 12.0–14.2
Deprecated  Mac Catalyst 15.0–17.2  Deprecated  tvOS 15.0–17.2  Deprecated
watchOS 8.0–10.2  Deprecated  visionOS 1.0–1.1  Deprecated  Xcode 13.0–15.1
Deprecated

    
    
    var offerType: Transaction.OfferType? { get }

Deprecated

Use `offer` instead.

## Discussion

If this value is `nil`, there’s no offer applied.

## See Also

### Deprecated

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

A string representation of the server environment.

Deprecated

`var offerID: String?`

A string that identifies an offer applied to the current subscription.

Deprecated

`@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var
offerPaymentModeStringRepresentation: String?`

The string representation of the payment mode for a subscription offer.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var reasonStringRepresentation: String`

The string representation of the transaction reason.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var storefrontCountryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront of the purchase.

Deprecated

Instance Property

# reasonStringRepresentation

The string representation of the transaction reason.

iOS 15.0–16.0  Deprecated  iPadOS 15.0–16.0  Deprecated  macOS 12.0–13.0
Deprecated  Mac Catalyst 17.0–17.0  Deprecated  tvOS 15.0–16.0  Deprecated
watchOS 8.0–9.0  Deprecated  Xcode 13.0–14.0  Deprecated

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0)
    var reasonStringRepresentation: String { get }

Deprecated

Use `reason` instead.

## Discussion

For more information, see `reason`.

## See Also

### Deprecated

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

A string representation of the server environment.

Deprecated

`var offerID: String?`

A string that identifies an offer applied to the current subscription.

Deprecated

`@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var
offerPaymentModeStringRepresentation: String?`

The string representation of the payment mode for a subscription offer.

Deprecated

`var offerType: Transaction.OfferType?`

The subscription offer type for the current subscription period.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var storefrontCountryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront of the purchase.

Deprecated

Instance Property

# storefrontCountryCode

The three-letter code that represents the country or region associated with
the App Store storefront of the purchase.

iOS 15.0–17.0  Deprecated  iPadOS 15.0–17.0  Deprecated  macOS 12.0–14.0
Deprecated  Mac Catalyst 17.0–17.0  Deprecated  tvOS 15.0–17.0  Deprecated
watchOS 8.0–10.0  Deprecated  Xcode 13.0–15.0  Deprecated

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0)
    var storefrontCountryCode: String { get }

Deprecated

Use `storefront` instead.

## Discussion

This property uses the ISO 3166-1 alpha-3 country code representation.

## See Also

### Deprecated

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

A string representation of the server environment.

Deprecated

`var offerID: String?`

A string that identifies an offer applied to the current subscription.

Deprecated

`@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var
offerPaymentModeStringRepresentation: String?`

The string representation of the payment mode for a subscription offer.

Deprecated

`var offerType: Transaction.OfferType?`

The subscription offer type for the current subscription period.

Deprecated

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var reasonStringRepresentation: String`

The string representation of the transaction reason.

Deprecated



# SKCloudServiceCapability

Initializer

# init(rawValue:)

Initializes a cloud service capability with the provided raw value.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+  Xcode 7.1+

    
    
    init(rawValue: UInt)

Type Property

# musicCatalogPlayback

The device allows playback of Apple Music catalog tracks.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    static var musicCatalogPlayback: SKCloudServiceCapability { get }

## See Also

### Identifying Cloud Service Capabilities

`static var musicCatalogSubscriptionEligible: SKCloudServiceCapability`

The device allows subscription to the Apple Music catalog.

`static var addToCloudMusicLibrary: SKCloudServiceCapability`

The device allows tracks to be added to the user’s music library.

Type Property

# musicCatalogSubscriptionEligible

The device allows subscription to the Apple Music catalog.

iOS 10.1+  iPadOS 10.1+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 10.1+  watchOS
7.0+

    
    
    static var musicCatalogSubscriptionEligible: SKCloudServiceCapability { get }

## See Also

### Identifying Cloud Service Capabilities

`static var musicCatalogPlayback: SKCloudServiceCapability`

The device allows playback of Apple Music catalog tracks.

`static var addToCloudMusicLibrary: SKCloudServiceCapability`

The device allows tracks to be added to the user’s music library.

Type Property

# addToCloudMusicLibrary

The device allows tracks to be added to the user’s music library.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    static var addToCloudMusicLibrary: SKCloudServiceCapability { get }

## See Also

### Identifying Cloud Service Capabilities

`static var musicCatalogPlayback: SKCloudServiceCapability`

The device allows playback of Apple Music catalog tracks.

`static var musicCatalogSubscriptionEligible: SKCloudServiceCapability`

The device allows subscription to the Apple Music catalog.



# SKDownload

Instance Property

# expectedContentLength

The length of the downloadable content, in bytes.

iOS 13.0–16.0  Deprecated  iPadOS 13.0–16.0  Deprecated  macOS 10.15–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 13.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var expectedContentLength: Int64 { get }

## See Also

### Getting Content Information

`var contentIdentifier: String`

A string that uniquely identifies the downloadable content.

Deprecated

`var contentVersion: String`

A string that identifies which version of the content is available for
download.

Deprecated

`var transaction: SKPaymentTransaction`

The transaction associated with the downloadable file.

Deprecated

`var contentLength: Int64`

The length of the downloadable content, in bytes.

Deprecated

Instance Property

# contentIdentifier

A string that uniquely identifies the downloadable content.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var contentIdentifier: String { get }

## Discussion

Each piece of downloadable content associated with a product has its own
unique identifier. The content identifier is specified in App Store Connect
when you add the content.

## See Also

### Getting Content Information

`var expectedContentLength: Int64`

The length of the downloadable content, in bytes.

Deprecated

`var contentVersion: String`

A string that identifies which version of the content is available for
download.

Deprecated

`var transaction: SKPaymentTransaction`

The transaction associated with the downloadable file.

Deprecated

`var contentLength: Int64`

The length of the downloadable content, in bytes.

Deprecated

### Related Documentation

In-App Purchase Programming Guide

Instance Property

# contentVersion

A string that identifies which version of the content is available for
download.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var contentVersion: String { get }

## Discussion

The version string must be formatted as a series of integers separated by
periods.

## See Also

### Getting Content Information

`var expectedContentLength: Int64`

The length of the downloadable content, in bytes.

Deprecated

`var contentIdentifier: String`

A string that uniquely identifies the downloadable content.

Deprecated

`var transaction: SKPaymentTransaction`

The transaction associated with the downloadable file.

Deprecated

`var contentLength: Int64`

The length of the downloadable content, in bytes.

Deprecated

Instance Property

# transaction

The transaction associated with the downloadable file.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.11–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var transaction: SKPaymentTransaction { get }

## Discussion

A download object is always associated with a payment transaction. The
download object may only be queued after payment is processed and before the
transaction is finished.

## See Also

### Getting Content Information

`var expectedContentLength: Int64`

The length of the downloadable content, in bytes.

Deprecated

`var contentIdentifier: String`

A string that uniquely identifies the downloadable content.

Deprecated

`var contentVersion: String`

A string that identifies which version of the content is available for
download.

Deprecated

`var contentLength: Int64`

The length of the downloadable content, in bytes.

Deprecated

Instance Property

# contentLength

The length of the downloadable content, in bytes.

iOS 6.0–13.0  Deprecated  iPadOS 6.0–13.0  Deprecated  macOS 10.8–10.15
Deprecated  Mac Catalyst 13.0–13.0  Deprecated  tvOS 9.0–13.0  Deprecated

**iOS, iPadOS, Mac Catalyst, tvOS**

    
    
     var contentLength: Int64 { get }

**macOS**

    
    
     @NSCopying
    var contentLength: NSNumber { get }

Deprecated

Use `expectedContentLength` instead.

## See Also

### Getting Content Information

`var expectedContentLength: Int64`

The length of the downloadable content, in bytes.

Deprecated

`var contentIdentifier: String`

A string that uniquely identifies the downloadable content.

Deprecated

`var contentVersion: String`

A string that identifies which version of the content is available for
download.

Deprecated

`var transaction: SKPaymentTransaction`

The transaction associated with the downloadable file.

Deprecated

Instance Property

# state

The current state of the download object.

iOS 12.0–16.0  Deprecated  iPadOS 12.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 12.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var state: SKDownloadState { get }

## Discussion

After you queue a download object, the payment queue object calls your
transaction observer when the state of the download object changes. Your
transaction observer should read the `state` property and use it to determine
how to proceed. For more information on the different states, see
`SKDownloadState`.

## See Also

### Getting State Information

`var progress: Float`

A value that indicates how much of the file has been downloaded.

Deprecated

`var timeRemaining: TimeInterval`

An estimated time, in seconds, to finish downloading the content.

Deprecated

`var SKDownloadTimeRemainingUnknown: TimeInterval`

Indicates that the system cannot determine how much time is needed to finish
downloading the content.

Deprecated

`enum SKDownloadState`

The states that a download operation can be in.

Deprecated

`var downloadState: SKDownloadState`

The current state of the download object.

Deprecated

Instance Property

# progress

A value that indicates how much of the file has been downloaded.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var progress: Float { get }

## Discussion

The value of this property is a floating point number between `0.0` and `1.0`,
inclusive, where `0.0` means no data has been download and `1.0` means all the
data has been downloaded. Typically, your app uses the value of this property
to update a user interface element, such as a progress bar, that displays how
much of the file has been downloaded.

Do not use the value of this property to determine whether the download has
completed. Instead, use the `downloadState` property.

## See Also

### Getting State Information

`var state: SKDownloadState`

The current state of the download object.

Deprecated

`var timeRemaining: TimeInterval`

An estimated time, in seconds, to finish downloading the content.

Deprecated

`var SKDownloadTimeRemainingUnknown: TimeInterval`

Indicates that the system cannot determine how much time is needed to finish
downloading the content.

Deprecated

`enum SKDownloadState`

The states that a download operation can be in.

Deprecated

`var downloadState: SKDownloadState`

The current state of the download object.

Deprecated

Instance Property

# timeRemaining

An estimated time, in seconds, to finish downloading the content.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var timeRemaining: TimeInterval { get }

## Discussion

The system attempts to estimate how long it will take to finish downloading
the file. If it cannot create a good estimate, the value of this property is
set to `SKDownloadTimeRemainingUnknown`.

## See Also

### Getting State Information

`var state: SKDownloadState`

The current state of the download object.

Deprecated

`var progress: Float`

A value that indicates how much of the file has been downloaded.

Deprecated

`var SKDownloadTimeRemainingUnknown: TimeInterval`

Indicates that the system cannot determine how much time is needed to finish
downloading the content.

Deprecated

`enum SKDownloadState`

The states that a download operation can be in.

Deprecated

`var downloadState: SKDownloadState`

The current state of the download object.

Deprecated

Global Variable

# SKDownloadTimeRemainingUnknown

Indicates that the system cannot determine how much time is needed to finish
downloading the content.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.14–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var SKDownloadTimeRemainingUnknown: TimeInterval

## See Also

### Getting State Information

`var state: SKDownloadState`

The current state of the download object.

Deprecated

`var progress: Float`

A value that indicates how much of the file has been downloaded.

Deprecated

`var timeRemaining: TimeInterval`

An estimated time, in seconds, to finish downloading the content.

Deprecated

`enum SKDownloadState`

The states that a download operation can be in.

Deprecated

`var downloadState: SKDownloadState`

The current state of the download object.

Deprecated

Instance Property

# downloadState

The current state of the download object.

iOS 6.0–12.0  Deprecated  iPadOS 6.0–12.0  Deprecated  Mac Catalyst 13.1–13.1
Deprecated  tvOS 9.0–12.0  Deprecated

    
    
    var downloadState: SKDownloadState { get }

## Discussion

After you queue a download object, the payment queue object calls your
transaction observer when the state of the download object changes. Your
transaction observer should read the `downloadState` property and use it to
determine how to proceed. For more information on the different states, see
`SKDownloadState`.

## See Also

### Getting State Information

`var state: SKDownloadState`

The current state of the download object.

Deprecated

`var progress: Float`

A value that indicates how much of the file has been downloaded.

Deprecated

`var timeRemaining: TimeInterval`

An estimated time, in seconds, to finish downloading the content.

Deprecated

`var SKDownloadTimeRemainingUnknown: TimeInterval`

Indicates that the system cannot determine how much time is needed to finish
downloading the content.

Deprecated

`enum SKDownloadState`

The states that a download operation can be in.

Deprecated

Instance Property

# error

The error that prevented the content from being downloaded.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var error: (any Error)? { get }

## Discussion

The value of this property is valid only when the `downloadState` property is
set to `SKDownloadState.failed`.

## See Also

### Accessing a Completed Download

`var contentURL: URL?`

The local location of the downloaded file.

Deprecated

Instance Property

# contentURL

The local location of the downloaded file.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var contentURL: URL? { get }

## Discussion

The value of this property is valid only when the `downloadState` property is
set to `SKDownloadState.finished`. The URL becomes invalid after the
transaction object associated with the download is finalized.

## See Also

### Accessing a Completed Download

`var error: (any Error)?`

The error that prevented the content from being downloaded.

Deprecated

Type Method

# contentURL(forProductID:)

Returns the local location for the previously downloaded flie.

macOS 10.8–13.0  Deprecated  Mac Catalyst 13.0–16.0  Deprecated

    
    
    class func contentURL(forProductID productID: String) -> URL?

##  Parameters

`productID`

    

The product identifier.

## Return Value

The local location for the previously downloaded flie.

## Discussion

Use this method to locate the content on subsequent launches of your app.

## See Also

### Managing Downloaded Content

`class func deleteContent(forProductID: String)`

Deletes the previously downloaded file.

Deprecated

Type Method

# deleteContent(forProductID:)

Deletes the previously downloaded file.

macOS 10.8–13.0  Deprecated  Mac Catalyst 13.0–16.0  Deprecated

    
    
    class func deleteContent(forProductID productID: String)

##  Parameters

`productID`

    

The product identifier.

## See Also

### Managing Downloaded Content

`class func contentURL(forProductID: String) -> URL?`

Returns the local location for the previously downloaded flie.

Deprecated



# SKDownloadState

Enumeration Case

# SKDownloadState.waiting

Indicates that the download has not started yet.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    case waiting = 0

Enumeration Case

# SKDownloadState.active

Indicates that the content is currently being downloaded.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    case active = 1

Enumeration Case

# SKDownloadState.paused

Indicates that your app paused the download.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    case paused = 2

Enumeration Case

# SKDownloadState.finished

Indicates that the content was successfully downloaded.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    case finished = 3

Enumeration Case

# SKDownloadState.failed

Indicates that an error occurred while the file was being downloaded.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    case failed = 4

Enumeration Case

# SKDownloadState.cancelled

Indicates that your app canceled the download.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    case cancelled = 5



# StoreKit views

Instance Method

# productViewStyle(_:)

Sets the style for in-app purchase product views within a view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func productViewStyle(_ style: some ProductViewStyle) -> some View

##  Parameters

`style`

    

The style to apply to the in-app purchase product views within the view.

## Discussion

This modifier styles any `ProductView` or `StoreView` instances within a view.

Instance Method

# subscriptionStorePickerItemBackground(_:)

Sets the background style for picker items of the subscription store view
instances within a view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStorePickerItemBackground(_ backgroundStyle: some ShapeStyle) -> some View

## See Also

### Configuring subscription store view controls

`func subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo)
-> some View) -> View`

Sets a view to use to decorate individual subscription options within a
subscription store view.

`func subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View`

Configures the subscription store views within a view to use a specified
button label.

`struct SubscriptionStoreButtonLabel`

The label of the subscribe button that a subscription store view uses.

`func subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) ->
View`

Sets the control style for subscription store views within a view.

Instance Method

# subscriptionStoreControlStyle(_:)

Sets the control style for subscription store views within a view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStoreControlStyle(_ style: some SubscriptionStoreControlStyle) -> some View

## Discussion

Modify the control style of the in-app subscription store,
`SubscriptionStoreView`. This has no effect on `StoreView` and `ProductView`
instances.

## See Also

### Styling subscription store views

`func subscriptionStorePickerItemBackground(some ShapeStyle) -> View`

Sets the background style for picker items of the subscription store view
instances within a view.

`protocol SubscriptionStoreControlStyle`

A type that specifies the appearance and interaction of controls in the
subscription store view instances within the view hierarchy.

`func subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo)
-> some View) -> View`

Sets a view to use to decorate individual subscription options within a
subscription store view.

`struct SubscriptionStoreControlBackground`

Instance Method

# subscriptionStoreControlIcon(icon:)

Sets a view to use to decorate individual subscription options within a
subscription store view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStoreControlIcon(@ViewBuilder icon: @escaping (Product, Product.SubscriptionInfo) -> some View) -> some View

##  Parameters

`icon`

    

A closure that takes a `Product` and `Product.SubscriptionInfo` and returns a
view.

## Discussion

You can adjust this view to provide a different appearance for each
subscription option.

## See Also

### Configuring subscription store view controls

`func subscriptionStorePickerItemBackground(some ShapeStyle) -> View`

Sets the background style for picker items of the subscription store view
instances within a view.

`func subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View`

Configures the subscription store views within a view to use a specified
button label.

`struct SubscriptionStoreButtonLabel`

The label of the subscribe button that a subscription store view uses.

`func subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) ->
View`

Sets the control style for subscription store views within a view.

Structure

# ContainerBackgroundPlacement

The placement of a container background.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+

    
    
    struct ContainerBackgroundPlacement

## Overview

This method controls where to place a background that you specify with the
`containerBackground(_:for:)` or `containerBackground(for:alignment:content:)`
modifier.

## Topics

### Getting placements

`static let navigation: ContainerBackgroundPlacement`

A background placement inside a `NavigationStack` or `NavigationSplitView`

`static let tabView: ContainerBackgroundPlacement`

A background placement inside a `TabView`.

`static let widget: ContainerBackgroundPlacement`

The container background placement for a widget.

### Getting StoreKit placements

`static var subscriptionStore: ContainerBackgroundPlacement`

A background placement inside a `SubscriptionStoreView`.

`static var subscriptionStoreFullHeight: ContainerBackgroundPlacement`

A background placement that spans the full height of a
`SubscriptionStoreView`.

`static var subscriptionStoreHeader: ContainerBackgroundPlacement`

A background placement inside the marketing content of a
`SubscriptionStoreView`

## Relationships

### Conforms To

  * `Equatable`
  * `Hashable`
  * `Sendable`

## See Also

### Layering views

Adding a background to your view

Compose a background behind your view and extend it beyond the safe area
insets.

`struct ZStack`

A view that overlays its subviews, aligning them in both axes.

`func zIndex(Double) -> some View`

Controls the display order of overlapping views.

`func background<V>(alignment: Alignment, content: () -> V) -> some View`

Layers the views that you specify behind this view.

`func background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View`

Sets the view’s background to a style.

`func background(ignoresSafeAreaEdges: Edge.Set) -> some View`

Sets the view’s background to the default background style.

`func background<S, T>(S, in: T, fillStyle: FillStyle) -> some View`

Sets the view’s background to an insettable shape filled with a style.

`func background<S>(in: S, fillStyle: FillStyle) -> some View`

Sets the view’s background to an insettable shape filled with the default
background style.

`func background<S, T>(S, in: T, fillStyle: FillStyle) -> some View`

Sets the view’s background to a shape filled with a style.

`func background<S>(in: S, fillStyle: FillStyle) -> some View`

Sets the view’s background to a shape filled with the default background
style.

`func overlay<V>(alignment: Alignment, content: () -> V) -> some View`

Layers the views that you specify in front of this view.

`func overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View`

Layers the specified style in front of this view.

`func overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View`

Layers a shape that you specify in front of this view.

`var backgroundMaterial: Material?`

The material underneath the current view.

`func containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some
View`

Sets the container background of the enclosing container using a view.

`func containerBackground<V>(for: ContainerBackgroundPlacement, alignment:
Alignment, content: () -> V) -> some View`

Sets the container background of the enclosing container using a view.

Type Property

# subscriptionStore

A background placement inside a `SubscriptionStoreView`.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+

    
    
    static var subscriptionStore: ContainerBackgroundPlacement { get }

## See Also

### Getting StoreKit placements

`static var subscriptionStoreFullHeight: ContainerBackgroundPlacement`

A background placement that spans the full height of a
`SubscriptionStoreView`.

`static var subscriptionStoreHeader: ContainerBackgroundPlacement`

A background placement inside the marketing content of a
`SubscriptionStoreView`

Type Property

# subscriptionStoreHeader

A background placement inside the marketing content of a
`SubscriptionStoreView`

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+

    
    
    static var subscriptionStoreHeader: ContainerBackgroundPlacement { get }

## See Also

### Getting StoreKit placements

`static var subscriptionStore: ContainerBackgroundPlacement`

A background placement inside a `SubscriptionStoreView`.

`static var subscriptionStoreFullHeight: ContainerBackgroundPlacement`

A background placement that spans the full height of a
`SubscriptionStoreView`.

Type Property

# subscriptionStoreFullHeight

A background placement that spans the full height of a
`SubscriptionStoreView`.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+

    
    
    static var subscriptionStoreFullHeight: ContainerBackgroundPlacement { get }

## See Also

### Getting StoreKit placements

`static var subscriptionStore: ContainerBackgroundPlacement`

A background placement inside a `SubscriptionStoreView`.

`static var subscriptionStoreHeader: ContainerBackgroundPlacement`

A background placement inside the marketing content of a
`SubscriptionStoreView`



# Product.ProductType

Type Property

# consumable

A consumable in-app purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let consumable: Product.ProductType

## See Also

### Getting the Product Type

`static let nonConsumable: Product.ProductType`

A non-consumable in-app purchase.

`static let nonRenewable: Product.ProductType`

A non-renewing subscription.

`static let autoRenewable: Product.ProductType`

An auto-renewable subscription.

Type Property

# nonConsumable

A non-consumable in-app purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let nonConsumable: Product.ProductType

## See Also

### Getting the Product Type

`static let consumable: Product.ProductType`

A consumable in-app purchase.

`static let nonRenewable: Product.ProductType`

A non-renewing subscription.

`static let autoRenewable: Product.ProductType`

An auto-renewable subscription.

Type Property

# nonRenewable

A non-renewing subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let nonRenewable: Product.ProductType

## See Also

### Getting the Product Type

`static let consumable: Product.ProductType`

A consumable in-app purchase.

`static let nonConsumable: Product.ProductType`

A non-consumable in-app purchase.

`static let autoRenewable: Product.ProductType`

An auto-renewable subscription.

Type Property

# autoRenewable

An auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let autoRenewable: Product.ProductType

## See Also

### Getting the Product Type

`static let consumable: Product.ProductType`

A consumable in-app purchase.

`static let nonConsumable: Product.ProductType`

A non-consumable in-app purchase.

`static let nonRenewable: Product.ProductType`

A non-renewing subscription.

Instance Property

# localizedDescription

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: String)

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating a Product Type

`let rawValue: String`

The value for product type as a backing value.

`typealias Product.ProductType.RawValue`

Instance Property

# rawValue

The value for product type as a backing value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating a Product Type

`init(rawValue: String)`

`typealias Product.ProductType.RawValue`

Type Alias

# Product.ProductType.RawValue

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.ProductType.RawValue = String

## See Also

### Creating a Product Type

`init(rawValue: String)`

`let rawValue: String`

The value for product type as a backing value.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.ProductType, rhs: Product.ProductType) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Product Types

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and Hashing Product Types

`static func != (Product.ProductType, Product.ProductType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and Hashing Product Types

`static func != (Product.ProductType, Product.ProductType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# PurchaseIntent.PurchaseIntents

Instance Method

# makeAsyncIterator()

Creates the iterator that produces elements of the asynchronous sequence.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    func makeAsyncIterator() -> PurchaseIntent.PurchaseIntents.AsyncIterator

## Relationships

### From Protocol

  * `AsyncSequence`

## See Also

### Iterating over purchase intents

`struct PurchaseIntent.PurchaseIntents.AsyncIterator`

An iterator that produces elements of the asynchronous purchase intents
sequence.

`typealias PurchaseIntent.PurchaseIntents.Element`

A type that represents a purchase intents element.

Type Alias

# PurchaseIntent.PurchaseIntents.Element

A type that represents a purchase intents element.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    typealias PurchaseIntent.PurchaseIntents.Element = PurchaseIntent

## See Also

### Iterating over purchase intents

`func makeAsyncIterator() -> PurchaseIntent.PurchaseIntents.AsyncIterator`

Creates the iterator that produces elements of the asynchronous sequence.

`struct PurchaseIntent.PurchaseIntents.AsyncIterator`

An iterator that produces elements of the asynchronous purchase intents
sequence.

Instance Method

# allSatisfy(_:)

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    func allSatisfy(_ predicate: (PurchaseIntent) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
satisfies a condition.

## Return Value

`true` if the sequence contains only elements that satisfy `predicate`;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether all
elements produced by the sequence are less than `10`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate returns `false` or the sequence ends.

If the asynchronous sequence is empty, this method returns `true`.

## See Also

### Filtering and matching purchase intents

`func contains(PurchaseIntent) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((PurchaseIntent) -> Bool) ->
AsyncFilterSequence<PurchaseIntent.PurchaseIntents>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(_:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    func contains(_ search: PurchaseIntent) async rethrows -> Bool

##  Parameters

`search`

    

The element to find in the asynchronous sequence.

## Return Value

`true` if the method found the element in the asynchronous sequence;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(_:)` method checks to see whether the
sequence produces the value `5`:

## See Also

### Filtering and matching purchase intents

`func allSatisfy((PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((PurchaseIntent) -> Bool) ->
AsyncFilterSequence<PurchaseIntent.PurchaseIntents>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(where:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    func contains(where predicate: (PurchaseIntent) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
represents a match.

## Return Value

`true` if the sequence contains an element that satisfies predicate;
otherwise, `false`.

## Discussion

You can use the predicate to check for an element of a type that doesn’t
conform to the `Equatable` protocol, or to find an element that satisfies a
general condition.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(where:)` method checks to see whether
the sequence produces a value divisible by `3`:

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching purchase intents

`func allSatisfy((PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(PurchaseIntent) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func filter((PurchaseIntent) -> Bool) ->
AsyncFilterSequence<PurchaseIntent.PurchaseIntents>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# filter(_:)

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func filter(_ isIncluded: @escaping @Sendable (PurchaseIntent) async -> Bool) -> AsyncFilterSequence<PurchaseIntent.PurchaseIntents>

##  Parameters

`isIncluded`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether to include the element in
the filtered sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements of the base
sequence that satisfy the given predicate.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `filter(_:)` method returns `true` for even
values and `false` for odd values, thereby filtering out the odd values:

## See Also

### Filtering and matching purchase intents

`func allSatisfy((PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(PurchaseIntent) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# first(where:)

Returns the first element of the sequence that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    func first(where predicate: (PurchaseIntent) async throws -> Bool) async rethrows -> PurchaseIntent?

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the element is a match.

## Return Value

The first element of the sequence that satisfies `predicate`, or `nil` if
there is no element that satisfies `predicate`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `first(where:)` method returns the first member
of the sequence that’s evenly divisible by both `2` and `3`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching purchase intents

`func allSatisfy((PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(PurchaseIntent) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((PurchaseIntent) -> Bool) ->
AsyncFilterSequence<PurchaseIntent.PurchaseIntents>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# max(by:)

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @warn_unqualified_access
    func max(by areInIncreasingOrder: (PurchaseIntent, PurchaseIntent) async throws -> Bool) async rethrows -> PurchaseIntent?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `max(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Filtering and matching purchase intents

`func allSatisfy((PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(PurchaseIntent) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((PurchaseIntent) -> Bool) ->
AsyncFilterSequence<PurchaseIntent.PurchaseIntents>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the first element of the sequence that satisfies the given predicate.

`func min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# min(by:)

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @warn_unqualified_access
    func min(by areInIncreasingOrder: (PurchaseIntent, PurchaseIntent) async throws -> Bool) async rethrows -> PurchaseIntent?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `min(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Filtering and matching purchase intents

`func allSatisfy((PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(PurchaseIntent) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (PurchaseIntent) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((PurchaseIntent) -> Bool) ->
AsyncFilterSequence<PurchaseIntent.PurchaseIntents>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (PurchaseIntent) async -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Because there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence.

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (PurchaseIntent) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns a transformed value of the same or of a
different type. If `transform` throws an error, the sequence ends.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure. The sequence ends either when the base
sequence ends or when `transform` throws an error.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Since there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence. When the value is `5`, the closure throws `MyError`,
terminating the sequence.

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (PurchaseIntent) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns an `AsyncSequence`. If `transform`
throws an error, the sequence ends.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`. The sequence ends either
when the last sequence created from the last element from base sequence ends,
or when `transform` throws an error.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`. However, when
the closure receives `4`, it throws an error, terminating the sequence.

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (PurchaseIntent) async -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns an `AsyncSequence`.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`.

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (PurchaseIntent) async -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces:

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (PurchaseIntent) async throws -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.
`transform` can also throw an error, which ends the transformed sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces.
Also, the dictionary doesn’t provide a key for `4`, and the closure throws an
error for any key it can’t look up, so receiving this value from `Counter`
ends the modified sequence with an error.

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(_:)

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    func prefix(_ count: Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>

##  Parameters

`count`

    

The maximum number of elements to return. The value of `count` must be greater
than or equal to zero.

## Return Value

An asynchronous sequence starting at the beginning of the base sequence with
at most `count` elements.

## Discussion

Use `prefix(_:)` to reduce the number of elements produced by the asynchronous
sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(_:)` method causes the modified sequence
to pass through the first six values, then end.

If the count passed to `prefix(_:)` exceeds the number of elements in the base
sequence, the result contains all of the elements in the sequence.

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(while:)

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func prefix(while predicate: @escaping @Sendable (PurchaseIntent) async -> Bool) rethrows -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether the element should be included in the modified sequence.

## Return Value

An asynchronous sequence of the initial, consecutive elements that satisfy
`predicate`.

## Discussion

Use `prefix(while:)` to produce values while elements from the base sequence
meet a condition you specify. The modified sequence ends when the predicate
closure returns `false`.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(while:)` method causes the modified
sequence to pass along values so long as they aren’t divisible by `2` and `3`.
Upon reaching `6`, the sequence ends:

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(_:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    func reduce<Result>(
        _ initialResult: Result,
        _ nextPartialResult: (Result, PurchaseIntent) async throws -> Result
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure runs.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(_:_:)` method to produce a single value from the elements of
an entire sequence. For example, you can use this method on an sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `4`. The `reduce(_:_:)` method sums the values received
from the asynchronous sequence.

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(into:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    func reduce<Result>(
        into initialResult: Result,
        _ updateAccumulatingResult: (inout Result, PurchaseIntent) async throws -> Void
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure executes.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(into:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on a sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

Prefer this method over `reduce(_:_:)` for efficiency when the result is a
copy-on-write type, for example an `Array` or `Dictionary`.

## See Also

### Transforming purchase intents

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) ->
AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((PurchaseIntent) -> Transformed) ->
AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (PurchaseIntent) -> Bool) ->
AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

Instance Method

# drop(while:)

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    @preconcurrency
    func drop(while predicate: @escaping @Sendable (PurchaseIntent) async -> Bool) -> AsyncDropWhileSequence<PurchaseIntent.PurchaseIntents>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether to drop the element from the modified sequence.

## Return Value

An asynchronous sequence that skips over values from the base sequence until
the provided closure returns `false`.

## Discussion

Use `drop(while:)` to omit elements from an asynchronous sequence until the
element received meets a condition you specify.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `drop(while:)` method causes the modified
sequence to ignore received values until it encounters one that is divisible
by `3`:

After the predicate returns `false`, the sequence never executes it again, and
from then on the sequence passes through elements from its underlying sequence
as-is.

## See Also

### Excluding purchase intents

`func dropFirst(Int) ->
AsyncDropFirstSequence<PurchaseIntent.PurchaseIntents>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

Instance Method

# dropFirst(_:)

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 16.4+  Xcode 11.0+

    
    
    func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<PurchaseIntent.PurchaseIntents>

##  Parameters

`count`

    

The number of elements to drop from the beginning of the sequence. `count`
must be greater than or equal to zero.

## Return Value

An asynchronous sequence that drops the first `count` elements from the base
sequence.

## Discussion

Use `dropFirst(_:)` when you want to drop the first _n_ elements from the base
sequence and pass through the remaining elements.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `dropFirst(_:)` method causes the modified
sequence to ignore the values `1` through `3`, and instead emit `4` through
`10`:

If the number of elements to drop exceeds the number of elements in the
sequence, the result is an empty sequence.

## See Also

### Excluding purchase intents

`func drop(while: (PurchaseIntent) -> Bool) ->
AsyncDropWhileSequence<PurchaseIntent.PurchaseIntents>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.



# AutomaticSubscriptionStoreControlStyle

Type Property

# automatic

A subscription store control style that resolves its appearance automatically,
based on the current context.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var automatic: AutomaticSubscriptionStoreControlStyle { get }

Instance Method

# makeBody(configuration:)

Creates a view that represents the body of an automatic subscription store
control style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func makeBody(configuration: AutomaticSubscriptionStoreControlStyle.Configuration) -> some View

##  Parameters

`configuration`

    

The properties of an automatic subscription store control.

## Relationships

### From Protocol

  * `SubscriptionStoreControlStyle`

## See Also

### Creating the style

`typealias AutomaticSubscriptionStoreControlStyle.Body`

A type that represents the body of an automatic subscription store control
style.

`init()`

Creates an automatic subscription store control style.

Type Alias

# AutomaticSubscriptionStoreControlStyle.Body

A type that represents the body of an automatic subscription store control
style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias AutomaticSubscriptionStoreControlStyle.Body = some View

## Relationships

### From Protocol

  * `SubscriptionStoreControlStyle`

## See Also

### Creating the style

`func makeBody(configuration:
AutomaticSubscriptionStoreControlStyle.Configuration) -> View`

Creates a view that represents the body of an automatic subscription store
control style.

`init()`

Creates an automatic subscription store control style.

Initializer

# init()

Creates an automatic subscription store control style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init()

## See Also

### Creating the style

`func makeBody(configuration:
AutomaticSubscriptionStoreControlStyle.Configuration) -> View`

Creates a view that represents the body of an automatic subscription store
control style.

`typealias AutomaticSubscriptionStoreControlStyle.Body`

A type that represents the body of an automatic subscription store control
style.



# Product.TaskState

Enumeration Case

# Product.TaskState.loading

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case loading

## See Also

### Task states

`case success(Product)`

`case unavailable`

`case failure(any Error)`

Enumeration Case

# Product.TaskState.success(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case success(Product)

## See Also

### Task states

`case loading`

`case unavailable`

`case failure(any Error)`

Enumeration Case

# Product.TaskState.unavailable

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case unavailable

## See Also

### Task states

`case loading`

`case success(Product)`

`case failure(any Error)`

Enumeration Case

# Product.TaskState.failure(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case failure(any Error)

## See Also

### Task states

`case loading`

`case success(Product)`

`case unavailable`



# ExternalLinkAccount

Type Property

# canOpen

A Boolean value that indicates whether the app can open the external link
account.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 17.4+  tvOS 16.4+  Xcode 14.0+

    
    
    static var canOpen: Bool { get async }

## Discussion

Check this property before showing any user-interface controls that enable
people to open the external link account.

Don’t check this property again in response to user input; instead, call
`open()` immediately.

Important

Only show user-interface controls that call the `open()` method if this
property is `true`. The `open()` method always throws an error when `canOpen`
is `false`.

## See Also

### Linking to external accounts

`static func open()`

Presents a continuation sheet that enables people to choose whether to open
your app’s link to an external website for account creation or management.

Type Method

# open()

Presents a continuation sheet that enables people to choose whether to open
your app’s link to an external website for account creation or management.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 17.4+  tvOS 16.4+  Xcode 14.0+

    
    
    static func open() async throws

## Discussion

Call this method in response to deliberate user interaction, for example,
tapping a button. Call `canOpen` to determine whether to display a button or
other user-interface control. If `canOpen` is `false`, this method always
throws a `StoreKitError` instance.

## See Also

### Linking to external accounts

`static var canOpen: Bool`

A Boolean value that indicates whether the app can open the external link
account.



# Storefront.Storefronts.AsyncIterator

Instance Method

# next()

Advances to the next element and returns either the element or `nil` if there
isn’t a next element.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    mutating func next() async -> Storefront?

## Return Value

The next element in the underlying sequence, if a next element exists;
otherwise, `nil`.

## Relationships

### From Protocol

  * `AsyncIteratorProtocol`

## See Also

### Getting the Next Element

`typealias Storefront.Storefronts.AsyncIterator.Element`

The type of element produced by this iterator.

`typealias Storefront.Storefronts.Element`

A type that represents the element of a storefront sequence.

Type Alias

# Storefront.Storefronts.AsyncIterator.Element

The type of element produced by this iterator.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Storefront.Storefronts.AsyncIterator.Element = Storefront

## Discussion

The iterator produces `Storefront` elements.

## See Also

### Getting the Next Element

`func next() -> Storefront?`

Advances to the next element and returns either the element or `nil` if there
isn’t a next element.

`typealias Storefront.Storefronts.Element`

A type that represents the element of a storefront sequence.

Type Alias

# Storefront.Storefronts.Element

A type that represents the element of a storefront sequence.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Storefront.Storefronts.Element = Storefront

## See Also

### Getting the Next Element

`func next() -> Storefront?`

Advances to the next element and returns either the element or `nil` if there
isn’t a next element.

`typealias Storefront.Storefronts.AsyncIterator.Element`

The type of element produced by this iterator.



# Product.SubscriptionInfo

Instance Property

# status

An array that contains status information for a subscription group, including
renewal and transaction information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var status: [Product.SubscriptionInfo.Status] { get async throws }

## Discussion

This array is empty if the customer was never subscribed to a product in this
subscription group.

The array can have more than one subscription status if your subscription
supports Family Sharing. Provide the customer with service for the
subscription based on the highest level of service where the state is
`subscribed`.

## See Also

### Determining the subscription status

`static func status(for: String) -> [Product.SubscriptionInfo.Status]`

Gets the subscription status for a subscription group identifier.

`struct Product.SubscriptionInfo.Status`

The renewal status information for an auto-renewable subscription.

Type Method

# status(for:)

Gets the subscription status for a subscription group identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func status(for groupID: String) async throws -> [Product.SubscriptionInfo.Status]

##  Parameters

`groupID`

    

The subscription group identifier of the subscription to get status for.

## Return Value

An array of `Product.SubscriptionInfo.Status`. This array is empty if the
customer has never subscribed to a product in this subscription group.

## Discussion

To get the subscription group identifier of a subscription, see
`subscriptionGroupID` in `Product.SubscriptionInfo`, or `subscriptionGroupID`
in `Transaction`. You originally create subscription group identifiers when
you set up in-app purchases in App Store Connect. For more information, see
Offer auto-renewable subscriptions.

Users can only buy one auto-renewable subscription within a group at a time.
However, the returned array may contain multiple status values if your
subscription supports Family Sharing, and the person has access to other
subscriptions in the group through Family Sharing. For more information about
Family Sharing, see Enable Family Sharing for your subscriptions.

## See Also

### Determining the subscription status

`var status: [Product.SubscriptionInfo.Status]`

An array that contains status information for a subscription group, including
renewal and transaction information.

`struct Product.SubscriptionInfo.Status`

The renewal status information for an auto-renewable subscription.

Instance Property

# subscriptionGroupID

The subscription group identifier for this subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let subscriptionGroupID: String

## Discussion

Auto-renewable subscriptions always belong to a subscription group. You create
the subscription group identifiers in App Store Connect before you create and
add an auto-renewable subscription. For more information about subscription
groups, see Offer auto-renewable subscriptions.

## See Also

### Identifying the subscription group

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var
groupDisplayName: String`

The localized name of the subscription group, suitable for display.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var
groupLevel: Int`

The rank of the subscription relative to other subscriptions in the same
subscription group.

Instance Property

# groupDisplayName

The localized name of the subscription group, suitable for display.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 17.0+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0)
    var groupDisplayName: String { get }

## Discussion

You provide a group display name in App Store Connect when you set up a
subscription group. For more information, see Offer auto-renewable
subscriptions.

The `SubscriptionStoreView` uses this value as part of the automatic marketing
content if you don’t provide a marketing content view.

Note

When you create a new product in App Store Connect or in a StoreKit
configuration file, you can test it before you add a product localization. The
`groupDisplayName` value is an empty string until you add a localization. For
more information on localizations, see Add localizations.

## See Also

### Identifying the subscription group

`let subscriptionGroupID: String`

The subscription group identifier for this subscription.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var
groupLevel: Int`

The rank of the subscription relative to other subscriptions in the same
subscription group.

Instance Property

# groupLevel

The rank of the subscription relative to other subscriptions in the same
subscription group.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 17.0+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0)
    var groupLevel: Int { get }

## Discussion

If you offer multiple auto-renewable subscriptions with different price tiers,
you can assign each to a level in App Store Connect. Ranking your
subscriptions determines the upgrade, downgrade, and crossgrade paths
available.

Subscriptions with the highest level of service within a subscription group
have a `groupLevel` value of `1`. Subscriptions with lower levels of service
or content have `groupLevel` values of `2` or greater. For example, when
comparing two subscriptions, moving from a subscription with a `groupLevel` of
`2` to a subscription with a `groupLevel` of `1` represents an upgrade.

For more information on ranking, see Ranking subscriptions within the group.
For information on assigning subscription levels in App Store Connect, see
Assign subscription levels.

Note

On systems earlier than iOS 17, macOS 14, tvOS 17, and watchOS 10, this
property returns a sentinel value of `0` when you test your app using StoreKit
Testing in Xcode or if there’s an unexpected server error.

## See Also

### Identifying the subscription group

`let subscriptionGroupID: String`

The subscription group identifier for this subscription.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var
groupDisplayName: String`

The localized name of the subscription group, suitable for display.

Instance Property

# subscriptionPeriod

The duration of time between subscription renewals.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let subscriptionPeriod: Product.SubscriptionPeriod

## See Also

### Getting the subscription period

`struct Product.SubscriptionPeriod`

Values that represent the duration of time between subscription renewals.

Instance Property

# isEligibleForIntroOffer

A Boolean value that indicates whether the customer is eligible for an
introductory offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var isEligibleForIntroOffer: Bool { get async }

## Discussion

This value is `true` if the customer is eligible for an introductory offer on
this auto-renewable subscription, or any auto-renewable subscription in the
same subscription group; this value is `false` otherwise. This value may be
`true` even if you haven’t set up an introductory offer in App Store Connect.
The following example illustrates checking the `subscription` property of a
product to determine whether the user is eligible for an introductory offer.

## See Also

### Getting subscription offer details

`static func isEligibleForIntroOffer(for: String) -> Bool`

Returns a Boolean value that determines the customer's eligibility for an
introductory offer within the provided subscription group.

`let introductoryOffer: Product.SubscriptionOffer?`

Information about the introductory offer available for the auto-renewable
subscription.

`let promotionalOffers: [Product.SubscriptionOffer]`

An array of promotional offers available for the auto-renewable subscription.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

Type Method

# isEligibleForIntroOffer(for:)

Returns a Boolean value that determines the customer's eligibility for an
introductory offer within the provided subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func isEligibleForIntroOffer(for groupID: String) async -> Bool

##  Parameters

`groupID`

    

The subscription group identifier to check eligibility for an introductory
offer.

## Return Value

`true` if the customer is eligible for an introductory offer on any auto-
renewable subscription within the subscription group; `false `otherwise.

## Discussion

This value may be `true` even if you haven’t set up an introductory offer in
App Store Connect.

## See Also

### Getting subscription offer details

`var isEligibleForIntroOffer: Bool`

A Boolean value that indicates whether the customer is eligible for an
introductory offer.

`let introductoryOffer: Product.SubscriptionOffer?`

Information about the introductory offer available for the auto-renewable
subscription.

`let promotionalOffers: [Product.SubscriptionOffer]`

An array of promotional offers available for the auto-renewable subscription.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

Instance Property

# introductoryOffer

Information about the introductory offer available for the auto-renewable
subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let introductoryOffer: Product.SubscriptionOffer?

## Discussion

This value is `nil` if you don't set up an introductory offer in App Store
Connect. Use `isEligibleForIntroOffer` to determine whether the customer is
eligible for an introductory offer.

## See Also

### Getting subscription offer details

`var isEligibleForIntroOffer: Bool`

A Boolean value that indicates whether the customer is eligible for an
introductory offer.

`static func isEligibleForIntroOffer(for: String) -> Bool`

Returns a Boolean value that determines the customer's eligibility for an
introductory offer within the provided subscription group.

`let promotionalOffers: [Product.SubscriptionOffer]`

An array of promotional offers available for the auto-renewable subscription.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

Instance Property

# promotionalOffers

An array of promotional offers available for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let promotionalOffers: [Product.SubscriptionOffer]

## Discussion

This array is empty if you haven't set up promotional offers in App Store
Connect.

For more information about promotional offers, see Set up promotional offers
for auto-renewable subscriptions.

## See Also

### Getting subscription offer details

`var isEligibleForIntroOffer: Bool`

A Boolean value that indicates whether the customer is eligible for an
introductory offer.

`static func isEligibleForIntroOffer(for: String) -> Bool`

Returns a Boolean value that determines the customer's eligibility for an
introductory offer within the provided subscription group.

`let introductoryOffer: Product.SubscriptionOffer?`

Information about the introductory offer available for the auto-renewable
subscription.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo, rhs: Product.SubscriptionInfo) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing subscription information

`static func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo, b: Product.SubscriptionInfo) -> Bool

## See Also

### Comparing and hashing subscription information

`static func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription information

`static func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription information

`static func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# status

An array that contains status information for a subscription group, including
renewal and transaction information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var status: [Product.SubscriptionInfo.Status] { get async throws }

## Discussion

This array is empty if the customer was never subscribed to a product in this
subscription group.

The array can have more than one subscription status if your subscription
supports Family Sharing. Provide the customer with service for the
subscription based on the highest level of service where the state is
`subscribed`.

## See Also

### Determining the subscription status

`static func status(for: String) -> [Product.SubscriptionInfo.Status]`

Gets the subscription status for a subscription group identifier.

`struct Product.SubscriptionInfo.Status`

The renewal status information for an auto-renewable subscription.

Type Method

# status(for:)

Gets the subscription status for a subscription group identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func status(for groupID: String) async throws -> [Product.SubscriptionInfo.Status]

##  Parameters

`groupID`

    

The subscription group identifier of the subscription to get status for.

## Return Value

An array of `Product.SubscriptionInfo.Status`. This array is empty if the
customer has never subscribed to a product in this subscription group.

## Discussion

To get the subscription group identifier of a subscription, see
`subscriptionGroupID` in `Product.SubscriptionInfo`, or `subscriptionGroupID`
in `Transaction`. You originally create subscription group identifiers when
you set up in-app purchases in App Store Connect. For more information, see
Offer auto-renewable subscriptions.

Users can only buy one auto-renewable subscription within a group at a time.
However, the returned array may contain multiple status values if your
subscription supports Family Sharing, and the person has access to other
subscriptions in the group through Family Sharing. For more information about
Family Sharing, see Enable Family Sharing for your subscriptions.

## See Also

### Determining the subscription status

`var status: [Product.SubscriptionInfo.Status]`

An array that contains status information for a subscription group, including
renewal and transaction information.

`struct Product.SubscriptionInfo.Status`

The renewal status information for an auto-renewable subscription.

Instance Property

# subscriptionGroupID

The subscription group identifier for this subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let subscriptionGroupID: String

## Discussion

Auto-renewable subscriptions always belong to a subscription group. You create
the subscription group identifiers in App Store Connect before you create and
add an auto-renewable subscription. For more information about subscription
groups, see Offer auto-renewable subscriptions.

## See Also

### Identifying the subscription group

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var
groupDisplayName: String`

The localized name of the subscription group, suitable for display.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var
groupLevel: Int`

The rank of the subscription relative to other subscriptions in the same
subscription group.

Instance Property

# groupDisplayName

The localized name of the subscription group, suitable for display.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 17.0+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0)
    var groupDisplayName: String { get }

## Discussion

You provide a group display name in App Store Connect when you set up a
subscription group. For more information, see Offer auto-renewable
subscriptions.

The `SubscriptionStoreView` uses this value as part of the automatic marketing
content if you don’t provide a marketing content view.

Note

When you create a new product in App Store Connect or in a StoreKit
configuration file, you can test it before you add a product localization. The
`groupDisplayName` value is an empty string until you add a localization. For
more information on localizations, see Add localizations.

## See Also

### Identifying the subscription group

`let subscriptionGroupID: String`

The subscription group identifier for this subscription.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var
groupLevel: Int`

The rank of the subscription relative to other subscriptions in the same
subscription group.

Instance Property

# groupLevel

The rank of the subscription relative to other subscriptions in the same
subscription group.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 17.0+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0)
    var groupLevel: Int { get }

## Discussion

If you offer multiple auto-renewable subscriptions with different price tiers,
you can assign each to a level in App Store Connect. Ranking your
subscriptions determines the upgrade, downgrade, and crossgrade paths
available.

Subscriptions with the highest level of service within a subscription group
have a `groupLevel` value of `1`. Subscriptions with lower levels of service
or content have `groupLevel` values of `2` or greater. For example, when
comparing two subscriptions, moving from a subscription with a `groupLevel` of
`2` to a subscription with a `groupLevel` of `1` represents an upgrade.

For more information on ranking, see Ranking subscriptions within the group.
For information on assigning subscription levels in App Store Connect, see
Assign subscription levels.

Note

On systems earlier than iOS 17, macOS 14, tvOS 17, and watchOS 10, this
property returns a sentinel value of `0` when you test your app using StoreKit
Testing in Xcode or if there’s an unexpected server error.

## See Also

### Identifying the subscription group

`let subscriptionGroupID: String`

The subscription group identifier for this subscription.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var
groupDisplayName: String`

The localized name of the subscription group, suitable for display.

Instance Property

# subscriptionPeriod

The duration of time between subscription renewals.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let subscriptionPeriod: Product.SubscriptionPeriod

## See Also

### Getting the subscription period

`struct Product.SubscriptionPeriod`

Values that represent the duration of time between subscription renewals.

Instance Property

# isEligibleForIntroOffer

A Boolean value that indicates whether the customer is eligible for an
introductory offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var isEligibleForIntroOffer: Bool { get async }

## Discussion

This value is `true` if the customer is eligible for an introductory offer on
this auto-renewable subscription, or any auto-renewable subscription in the
same subscription group; this value is `false` otherwise. This value may be
`true` even if you haven’t set up an introductory offer in App Store Connect.
The following example illustrates checking the `subscription` property of a
product to determine whether the user is eligible for an introductory offer.

    
    
    func eligibleForIntro(product: Product) async throws -> Bool {
        guard let renewableSubscription = product.subscription else {
            // No renewable subscription is available for this product.
            return false
        }
        if await renewableSubscription.isEligibleForIntroOffer {
            // The product is eligible for an introductory offer.
            return true
        }
        return false
    }
    

## See Also

### Getting subscription offer details

`static func isEligibleForIntroOffer(for: String) -> Bool`

Returns a Boolean value that determines the customer's eligibility for an
introductory offer within the provided subscription group.

`let introductoryOffer: Product.SubscriptionOffer?`

Information about the introductory offer available for the auto-renewable
subscription.

`let promotionalOffers: [Product.SubscriptionOffer]`

An array of promotional offers available for the auto-renewable subscription.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

Type Method

# isEligibleForIntroOffer(for:)

Returns a Boolean value that determines the customer's eligibility for an
introductory offer within the provided subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func isEligibleForIntroOffer(for groupID: String) async -> Bool

##  Parameters

`groupID`

    

The subscription group identifier to check eligibility for an introductory
offer.

## Return Value

`true` if the customer is eligible for an introductory offer on any auto-
renewable subscription within the subscription group; `false `otherwise.

## Discussion

This value may be `true` even if you haven’t set up an introductory offer in
App Store Connect.

## See Also

### Getting subscription offer details

`var isEligibleForIntroOffer: Bool`

A Boolean value that indicates whether the customer is eligible for an
introductory offer.

`let introductoryOffer: Product.SubscriptionOffer?`

Information about the introductory offer available for the auto-renewable
subscription.

`let promotionalOffers: [Product.SubscriptionOffer]`

An array of promotional offers available for the auto-renewable subscription.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

Instance Property

# introductoryOffer

Information about the introductory offer available for the auto-renewable
subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let introductoryOffer: Product.SubscriptionOffer?

## Discussion

This value is `nil` if you don't set up an introductory offer in App Store
Connect. Use `isEligibleForIntroOffer` to determine whether the customer is
eligible for an introductory offer.

## See Also

### Getting subscription offer details

`var isEligibleForIntroOffer: Bool`

A Boolean value that indicates whether the customer is eligible for an
introductory offer.

`static func isEligibleForIntroOffer(for: String) -> Bool`

Returns a Boolean value that determines the customer's eligibility for an
introductory offer within the provided subscription group.

`let promotionalOffers: [Product.SubscriptionOffer]`

An array of promotional offers available for the auto-renewable subscription.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

Instance Property

# promotionalOffers

An array of promotional offers available for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let promotionalOffers: [Product.SubscriptionOffer]

## Discussion

This array is empty if you haven't set up promotional offers in App Store
Connect.

For more information about promotional offers, see Set up promotional offers
for auto-renewable subscriptions.

## See Also

### Getting subscription offer details

`var isEligibleForIntroOffer: Bool`

A Boolean value that indicates whether the customer is eligible for an
introductory offer.

`static func isEligibleForIntroOffer(for: String) -> Bool`

Returns a Boolean value that determines the customer's eligibility for an
introductory offer within the provided subscription group.

`let introductoryOffer: Product.SubscriptionOffer?`

Information about the introductory offer available for the auto-renewable
subscription.

`struct Product.SubscriptionOffer`

Information about a subscription offer that you configure in App Store
Connect.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo, rhs: Product.SubscriptionInfo) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing subscription information

`static func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo, b: Product.SubscriptionInfo) -> Bool

## See Also

### Comparing and hashing subscription information

`static func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription information

`static func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription information

`static func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# Generating the signature to validate StoreKit-rendered ads

Article

# Combining parameters to generate signatures for SKAdNetwork 2.2 and 3

Generate signatures to sign your ad with versions 2.2 and 3.

## Overview

To generate the signature, combine the required values of Ad network install-
validation keys for version 2, and include a `fidelity-type` value of `1` for
StoreKit-rendered ads.

Important

Lowercase the string representation of the nonce:
`SKStoreProductParameterAdNetworkNonce`. Failing to do so results in an
invalid signature. Only ads with valid signatures can get ad attributions.

For versions 2.2 and 3, combine the values into a UTF-8 string with an
invisible separator (`‘\u2063’`) between them, in the exact order the code
below shows:

## See Also

### Signatures for SKAdNetwork 1, 2, and 2.2–3

Combining parameters to generate a signature for SKAdNetwork 2

Generate signatures to sign your ad with version 2.

Combining parameters to generate a signature for SKAdNetwork 1

Generate signatures for apps compiled with earlier SDKs.

Article

# Combining parameters to generate a signature for SKAdNetwork 2

Generate signatures to sign your ad with version 2.

## Overview

To generate the signature, first combine the values of Ad network install-
validation keys for the version 2.

Important

Lowercase the string representation of the nonce:
`SKStoreProductParameterAdNetworkNonce`. Failing to do so results in an
invalid signature. Only ads with valid signatures can get ad attributions.

Strings for version 2 and earlier don’t include a `fidelity-type` parameter.
For version 2, combine the values into a UTF-8 string with an invisible
separator (`‘\u2063’`) between them, in the exact order shown:

**Listing 1**  Parameter values combined, in order, for version 2.

## See Also

### Signatures for SKAdNetwork 1, 2, and 2.2–3

Combining parameters to generate signatures for SKAdNetwork 2.2 and 3

Generate signatures to sign your ad with versions 2.2 and 3.

Combining parameters to generate a signature for SKAdNetwork 1

Generate signatures for apps compiled with earlier SDKs.

Article

# Combining parameters to generate a signature for SKAdNetwork 1

Generate signatures for apps compiled with earlier SDKs.

## Overview

Generate a signature using the parameters for version 1.0 if you compile your
app with an iOS SDK version from 11.3 through 13.7.

To generate the signature, first combine the values of Ad network install-
validation keys for the version 1.0.

The parameters required for a version 1.0 signature are:

`SKStoreProductParameterAdNetworkIdentifier`

    

Your ad network identifier that you registered with Apple. Shown as `ad-
network-id` in Listing 1.

`SKStoreProductParameterAdNetworkCampaignIdentifier`

    

A campaign number you provide. Shown as `campaign-id` in Listing 1.

`SKStoreProductParameterITunesItemIdentifier`

    

The App Store ID of the product to advertise. Shown as `itunes-item-id` in
Listing 1.

`SKStoreProductParameterAdNetworkNonce`

    

A unique `UUID` value that you provide for each ad impression. You must
lowercase the string representation of the nonce in the signature. Shown as
`nonce` in Listing 1.

`SKStoreProductParameterAdNetworkTimestamp`

    

A timestamp you generate near the time of the ad impression. Shown as
`timestamp` in Listing 1.

### Combine the parameters for version 1.0

Create the UTF-8 string for version 1.0 if you compile your app with an SDK
prior to iOS 14.

Important

You must use lowercase for the string representation of the nonce:
`SKStoreProductParameterAdNetworkNonce`.

Combine the values into a UTF-8 string with an invisible separator
(`‘\u2063’`) between them, in the exact order shown:

**Listing 1**  Parameter values combined, in order, for version 1.0.

Next, follow the instructions to sign the combined string, encode the
signature, and use the generated signature string as described in Generating
the signature to validate StoreKit-rendered ads.

## See Also

### Signatures for SKAdNetwork 1, 2, and 2.2–3

Combining parameters to generate signatures for SKAdNetwork 2.2 and 3

Generate signatures to sign your ad with versions 2.2 and 3.

Combining parameters to generate a signature for SKAdNetwork 2

Generate signatures to sign your ad with version 2.



# Product.PromotionInfo

Instance Property

# productID

The product identifier of the promoted in-app purchase.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    let productID: Product.ID

Type Method

# updateProductOrder(byID:)

Sets the display order of promoted in-app purchases in the App Store, using
product identifiers.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func updateProductOrder(byID order: some Collection<String>) async throws

##  Parameters

`order`

    

A collection of product identifiers (`Product.ID`) in the order that you want
the promoted in-app purchases to appear, from first to last. Use an empty list
to cancel previous changes.

## Discussion

Call this static method to override the default order of promoted in-app
purchases on the current device. You provide the product identifiers of the
promoted in-app purchases to set their order.

To hide a promoted in-app purchase so it doesn't display in the App Store for
the user, don't include its product identifier when calling this method. You
may want to do this, for example, if the user has already purchased the
product, or if it isn't relevant to them for some other reason.

To set the order using `Product.PromotionInfo` objects instead of product
identifiers, see `updateAll(_:)`.

### Cancel overrides

To cancel the order and visibility changes you make, send an empty collection
in the `order` parameter. All in-app purchases then display in the default
order.

Type Property

# currentOrder

Gets the customized order of the promotion info objects the represent promoted
products.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static var currentOrder: [Product.PromotionInfo] { get async throws }

## Discussion

This asynchronous array returns a list of `Product.PromotionInfo` objects in
the custom order they appear in on the device.

Note

This list is empty if you don’t override the order, and the App Store displays
the products in their default order.

For information about setting the default order using App Store Connect, see
Promote in-app purchases.

Instance Property

# visibility

A value that indicates whether the promoted in-app purchase is visible or
hidden on the user’s device.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    var visibility: Product.PromotionInfo.Visibility

## Discussion

To override the visibility of a promoted in-app purchase, set the `visibility`
value and then call `update()` to save the change. You can also call
`updateProductVisibility(_:for:)` to set the visibility.

The default value is
`Product.PromotionInfo.Visibility.appStoreConnectDefault`.

## See Also

### Managing promotion visibility

`enum Product.PromotionInfo.Visibility`

The visibility states for product promotion information.

`static func updateProductVisibility(Product.PromotionInfo.Visibility, for:
Product.ID)`

Updates a value that indicates whether a promoted in-app purchase appears in
the App Store on the user's device.

Type Method

# updateProductVisibility(_:for:)

Updates a value that indicates whether a promoted in-app purchase appears in
the App Store on the user's device.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func updateProductVisibility(
        _ visibility: Product.PromotionInfo.Visibility,
        for productID: Product.ID
    ) async throws

##  Parameters

`visibility`

    

A visibility value of `Product.PromotionInfo.Visibility` that determines
whether a promoted in-app purchase appears in the App Store on the user's
device.

`productID`

    

The product identifier of the promoted in-app purchase.

## Discussion

Call this method to change the visibility setting for a promoted in-app
purchase. Changes take effect after you call this method.

The following code example updates a promoted product's visibility after the
user purchases it. The purchased product is hidden to avoid showing it again
on the device.

## See Also

### Managing promotion visibility

`var visibility: Product.PromotionInfo.Visibility`

A value that indicates whether the promoted in-app purchase is visible or
hidden on the user’s device.

`enum Product.PromotionInfo.Visibility`

The visibility states for product promotion information.

Instance Method

# update()

Saves your changes to the promoted product’s visibility.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    func update() async throws

## Discussion

If you change the `visibility` value by setting it directly, call `update()`
to save your changes to the App Store server. Changes take effect after you
call `update()` or `updateAll(_:)`.

## See Also

### Updating order and visibility

`static func updateAll(some Collection<Product.PromotionInfo>)`

Sets the order and visibility of all the promoted products and saves your
changes.

Type Method

# updateAll(_:)

Sets the order and visibility of all the promoted products and saves your
changes.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func updateAll(_ promotions: some Collection<Product.PromotionInfo>) async throws

##  Parameters

`promotions`

    

A collection of `Product.PromotionInfo` objects that you list in the order
they are to appear in the App Store on the user’s device. Use an empty
collection to cancel previous changes.

## Discussion

Call this static method to set the order of promoted in-app purchases for the
user. Calling this method overrides any previous order and visibility that you
set for this user.

To remove a promoted in-app purchase so it doesn’t display for a user, there
are two options:

  * Don’t include it in the `promotions` collection.

  * Change its `visibility` value to `Product.PromotionInfo.Visibility.hidden`.

To set the order of promoted in-app purchases using product identifiers
instead of `Product.PromotionInfo` objects, see `updateProductOrder(byID:)`.

### Cancel overrides

To cancel the order and visibility changes you make, send an empty collection
in `promotions`. All in-app purchases then display in the default order.

## See Also

### Updating order and visibility

`func update()`

Saves your changes to the promoted product’s visibility.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func != (lhs: Product.PromotionInfo, rhs: Product.PromotionInfo) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing promotion info

`static func == (Product.PromotionInfo, Product.PromotionInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func == (a: Product.PromotionInfo, b: Product.PromotionInfo) -> Bool

## See Also

### Comparing promotion info

`static func != (Product.PromotionInfo, Product.PromotionInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

Instance Property

# productID

The product identifier of the promoted in-app purchase.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    let productID: Product.ID

Type Method

# updateProductOrder(byID:)

Sets the display order of promoted in-app purchases in the App Store, using
product identifiers.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func updateProductOrder(byID order: some Collection<String>) async throws

##  Parameters

`order`

    

A collection of product identifiers (`Product.ID`) in the order that you want
the promoted in-app purchases to appear, from first to last. Use an empty list
to cancel previous changes.

## Discussion

Call this static method to override the default order of promoted in-app
purchases on the current device. You provide the product identifiers of the
promoted in-app purchases to set their order.

To hide a promoted in-app purchase so it doesn't display in the App Store for
the user, don't include its product identifier when calling this method. You
may want to do this, for example, if the user has already purchased the
product, or if it isn't relevant to them for some other reason.

To set the order using `Product.PromotionInfo` objects instead of product
identifiers, see `updateAll(_:)`.

### Cancel overrides

To cancel the order and visibility changes you make, send an empty collection
in the `order` parameter. All in-app purchases then display in the default
order.

Type Property

# currentOrder

Gets the customized order of the promotion info objects the represent promoted
products.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static var currentOrder: [Product.PromotionInfo] { get async throws }

## Discussion

This asynchronous array returns a list of `Product.PromotionInfo` objects in
the custom order they appear in on the device.

Note

This list is empty if you don’t override the order, and the App Store displays
the products in their default order.

For information about setting the default order using App Store Connect, see
Promote in-app purchases.

Instance Property

# visibility

A value that indicates whether the promoted in-app purchase is visible or
hidden on the user’s device.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    var visibility: Product.PromotionInfo.Visibility

## Discussion

To override the visibility of a promoted in-app purchase, set the `visibility`
value and then call `update()` to save the change. You can also call
`updateProductVisibility(_:for:)` to set the visibility.

The default value is
`Product.PromotionInfo.Visibility.appStoreConnectDefault`.

## See Also

### Managing promotion visibility

`enum Product.PromotionInfo.Visibility`

The visibility states for product promotion information.

`static func updateProductVisibility(Product.PromotionInfo.Visibility, for:
Product.ID)`

Updates a value that indicates whether a promoted in-app purchase appears in
the App Store on the user's device.

Type Method

# updateProductVisibility(_:for:)

Updates a value that indicates whether a promoted in-app purchase appears in
the App Store on the user's device.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func updateProductVisibility(
        _ visibility: Product.PromotionInfo.Visibility,
        for productID: Product.ID
    ) async throws

##  Parameters

`visibility`

    

A visibility value of `Product.PromotionInfo.Visibility` that determines
whether a promoted in-app purchase appears in the App Store on the user's
device.

`productID`

    

The product identifier of the promoted in-app purchase.

## Discussion

Call this method to change the visibility setting for a promoted in-app
purchase. Changes take effect after you call this method.

The following code example updates a promoted product's visibility after the
user purchases it. The purchased product is hidden to avoid showing it again
on the device.

## See Also

### Managing promotion visibility

`var visibility: Product.PromotionInfo.Visibility`

A value that indicates whether the promoted in-app purchase is visible or
hidden on the user’s device.

`enum Product.PromotionInfo.Visibility`

The visibility states for product promotion information.

Instance Method

# update()

Saves your changes to the promoted product’s visibility.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    func update() async throws

## Discussion

If you change the `visibility` value by setting it directly, call `update()`
to save your changes to the App Store server. Changes take effect after you
call `update()` or `updateAll(_:)`.

## See Also

### Updating order and visibility

`static func updateAll(some Collection<Product.PromotionInfo>)`

Sets the order and visibility of all the promoted products and saves your
changes.

Type Method

# updateAll(_:)

Sets the order and visibility of all the promoted products and saves your
changes.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func updateAll(_ promotions: some Collection<Product.PromotionInfo>) async throws

##  Parameters

`promotions`

    

A collection of `Product.PromotionInfo` objects that you list in the order
they are to appear in the App Store on the user’s device. Use an empty
collection to cancel previous changes.

## Discussion

Call this static method to set the order of promoted in-app purchases for the
user. Calling this method overrides any previous order and visibility that you
set for this user.

To remove a promoted in-app purchase so it doesn’t display for a user, there
are two options:

  * Don’t include it in the `promotions` collection.

  * Change its `visibility` value to `Product.PromotionInfo.Visibility.hidden`.

To set the order of promoted in-app purchases using product identifiers
instead of `Product.PromotionInfo` objects, see `updateProductOrder(byID:)`.

### Cancel overrides

To cancel the order and visibility changes you make, send an empty collection
in `promotions`. All in-app purchases then display in the default order.

## See Also

### Updating order and visibility

`func update()`

Saves your changes to the promoted product’s visibility.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func != (lhs: Product.PromotionInfo, rhs: Product.PromotionInfo) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing promotion info

`static func == (Product.PromotionInfo, Product.PromotionInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func == (a: Product.PromotionInfo, b: Product.PromotionInfo) -> Bool

## See Also

### Comparing promotion info

`static func != (Product.PromotionInfo, Product.PromotionInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.



# Message.Messages

Instance Method

# makeAsyncIterator()

Creates the asynchronous iterator that produces elements of this asynchronous
sequence.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func makeAsyncIterator() -> Message.Messages.AsyncIterator

## Relationships

### From Protocol

  * `AsyncSequence`

## See Also

### Creating an iterator

`struct Message.Messages.AsyncIterator`

The asynchronous iterator that produces elements of the asynchronous sequence.

`typealias Message.Messages.Element`

The type of element traversed by the iterator.

Type Alias

# Message.Messages.Element

The type of element traversed by the iterator.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Message.Messages.Element = Message

## See Also

### Creating an iterator

`func makeAsyncIterator() -> Message.Messages.AsyncIterator`

Creates the asynchronous iterator that produces elements of this asynchronous
sequence.

`struct Message.Messages.AsyncIterator`

The asynchronous iterator that produces elements of the asynchronous sequence.

Instance Method

# allSatisfy(_:)

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    func allSatisfy(_ predicate: (Message) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
satisfies a condition.

## Return Value

`true` if the sequence contains only elements that satisfy `predicate`;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether all
elements produced by the sequence are less than `10`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate returns `false` or the sequence ends.

If the asynchronous sequence is empty, this method returns `true`.

## See Also

### Finding messages

`func contains(Message) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Message) -> Bool) -> Message?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Message, Message) -> Bool) -> Message?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Message, Message) -> Bool) -> Message?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(_:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    func contains(_ search: Message) async rethrows -> Bool

##  Parameters

`search`

    

The element to find in the asynchronous sequence.

## Return Value

`true` if the method found the element in the asynchronous sequence;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(_:)` method checks to see whether the
sequence produces the value `5`:

## See Also

### Finding messages

`func allSatisfy((Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Message) -> Bool) -> Message?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Message, Message) -> Bool) -> Message?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Message, Message) -> Bool) -> Message?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(where:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    func contains(where predicate: (Message) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
represents a match.

## Return Value

`true` if the sequence contains an element that satisfies predicate;
otherwise, `false`.

## Discussion

You can use the predicate to check for an element of a type that doesn’t
conform to the `Equatable` protocol, or to find an element that satisfies a
general condition.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(where:)` method checks to see whether
the sequence produces a value divisible by `3`:

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Finding messages

`func allSatisfy((Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Message) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func first(where: (Message) -> Bool) -> Message?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Message, Message) -> Bool) -> Message?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Message, Message) -> Bool) -> Message?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# first(where:)

Returns the first element of the sequence that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    func first(where predicate: (Message) async throws -> Bool) async rethrows -> Message?

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the element is a match.

## Return Value

The first element of the sequence that satisfies `predicate`, or `nil` if
there is no element that satisfies `predicate`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `first(where:)` method returns the first member
of the sequence that’s evenly divisible by both `2` and `3`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Finding messages

`func allSatisfy((Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Message) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func max(by: (Message, Message) -> Bool) -> Message?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Message, Message) -> Bool) -> Message?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# max(by:)

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @warn_unqualified_access
    func max(by areInIncreasingOrder: (Message, Message) async throws -> Bool) async rethrows -> Message?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `max(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Finding messages

`func allSatisfy((Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Message) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Message) -> Bool) -> Message?`

Returns the first element of the sequence that satisfies the given predicate.

`func min(by: (Message, Message) -> Bool) -> Message?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# min(by:)

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @warn_unqualified_access
    func min(by areInIncreasingOrder: (Message, Message) async throws -> Bool) async rethrows -> Message?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `min(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Finding messages

`func allSatisfy((Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Message) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Message) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Message) -> Bool) -> Message?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Message, Message) -> Bool) -> Message?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# prefix(_:)

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    func prefix(_ count: Int) -> AsyncPrefixSequence<Message.Messages>

##  Parameters

`count`

    

The maximum number of elements to return. The value of `count` must be greater
than or equal to zero.

## Return Value

An asynchronous sequence starting at the beginning of the base sequence with
at most `count` elements.

## Discussion

Use `prefix(_:)` to reduce the number of elements produced by the asynchronous
sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(_:)` method causes the modified sequence
to pass through the first six values, then end.

If the count passed to `prefix(_:)` exceeds the number of elements in the base
sequence, the result contains all of the elements in the sequence.

## See Also

### Selecting messages

`func prefix(while: (Message) -> Bool) ->
AsyncPrefixWhileSequence<Message.Messages>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

Instance Method

# prefix(while:)

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func prefix(while predicate: @escaping @Sendable (Message) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Message.Messages>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether the element should be included in the modified sequence.

## Return Value

An asynchronous sequence of the initial, consecutive elements that satisfy
`predicate`.

## Discussion

Use `prefix(while:)` to produce values while elements from the base sequence
meet a condition you specify. The modified sequence ends when the predicate
closure returns `false`.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(while:)` method causes the modified
sequence to pass along values so long as they aren’t divisible by `2` and `3`.
Upon reaching `6`, the sequence ends:

## See Also

### Selecting messages

`func prefix(Int) -> AsyncPrefixSequence<Message.Messages>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

Instance Method

# drop(while:)

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func drop(while predicate: @escaping @Sendable (Message) async -> Bool) -> AsyncDropWhileSequence<Message.Messages>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether to drop the element from the modified sequence.

## Return Value

An asynchronous sequence that skips over values from the base sequence until
the provided closure returns `false`.

## Discussion

Use `drop(while:)` to omit elements from an asynchronous sequence until the
element received meets a condition you specify.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `drop(while:)` method causes the modified
sequence to ignore received values until it encounters one that is divisible
by `3`:

After the predicate returns `false`, the sequence never executes it again, and
from then on the sequence passes through elements from its underlying sequence
as-is.

## See Also

### Excluding messages

`func dropFirst(Int) -> AsyncDropFirstSequence<Message.Messages>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

`func filter((Message) -> Bool) -> AsyncFilterSequence<Message.Messages>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

Instance Method

# dropFirst(_:)

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Message.Messages>

##  Parameters

`count`

    

The number of elements to drop from the beginning of the sequence. `count`
must be greater than or equal to zero.

## Return Value

An asynchronous sequence that drops the first `count` elements from the base
sequence.

## Discussion

Use `dropFirst(_:)` when you want to drop the first _n_ elements from the base
sequence and pass through the remaining elements.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `dropFirst(_:)` method causes the modified
sequence to ignore the values `1` through `3`, and instead emit `4` through
`10`:

If the number of elements to drop exceeds the number of elements in the
sequence, the result is an empty sequence.

## See Also

### Excluding messages

`func drop(while: (Message) -> Bool) ->
AsyncDropWhileSequence<Message.Messages>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

`func filter((Message) -> Bool) -> AsyncFilterSequence<Message.Messages>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

Instance Method

# filter(_:)

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func filter(_ isIncluded: @escaping @Sendable (Message) async -> Bool) -> AsyncFilterSequence<Message.Messages>

##  Parameters

`isIncluded`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether to include the element in
the filtered sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements of the base
sequence that satisfy the given predicate.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `filter(_:)` method returns `true` for even
values and `false` for odd values, thereby filtering out the odd values:

## See Also

### Excluding messages

`func drop(while: (Message) -> Bool) ->
AsyncDropWhileSequence<Message.Messages>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

`func dropFirst(Int) -> AsyncDropFirstSequence<Message.Messages>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Message) async -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Because there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func map<Transformed>((Message) -> Transformed) ->
AsyncMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((Message) -> Transformed) ->
AsyncThrowingMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func reduce<Result>(Result, (Result, Message) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Message) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns a transformed value of the same or of a
different type. If `transform` throws an error, the sequence ends.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure. The sequence ends either when the base
sequence ends or when `transform` throws an error.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Since there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence. When the value is `5`, the closure throws `MyError`,
terminating the sequence.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func map<Transformed>((Message) -> Transformed) ->
AsyncMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((Message) -> Transformed) ->
AsyncThrowingMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func reduce<Result>(Result, (Result, Message) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Message) async -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces:

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func map<Transformed>((Message) -> Transformed) ->
AsyncThrowingMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func reduce<Result>(Result, (Result, Message) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Message) async throws -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.
`transform` can also throw an error, which ends the transformed sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces.
Also, the dictionary doesn’t provide a key for `4`, and the closure throws an
error for any key it can’t look up, so receiving this value from `Counter`
ends the modified sequence with an error.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func map<Transformed>((Message) -> Transformed) ->
AsyncMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func reduce<Result>(Result, (Result, Message) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Message) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns an `AsyncSequence`. If `transform`
throws an error, the sequence ends.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`. The sequence ends either
when the last sequence created from the last element from base sequence ends,
or when `transform` throws an error.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`. However, when
the closure receives `4`, it throws an error, terminating the sequence.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func map<Transformed>((Message) -> Transformed) ->
AsyncMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((Message) -> Transformed) ->
AsyncThrowingMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func reduce<Result>(Result, (Result, Message) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Message) async -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns an `AsyncSequence`.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func map<Transformed>((Message) -> Transformed) ->
AsyncMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((Message) -> Transformed) ->
AsyncThrowingMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func reduce<Result>(Result, (Result, Message) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(_:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    func reduce<Result>(
        _ initialResult: Result,
        _ nextPartialResult: (Result, Message) async throws -> Result
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure runs.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(_:_:)` method to produce a single value from the elements of
an entire sequence. For example, you can use this method on an sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `4`. The `reduce(_:_:)` method sums the values received
from the asynchronous sequence.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func map<Transformed>((Message) -> Transformed) ->
AsyncMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((Message) -> Transformed) ->
AsyncThrowingMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(into:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 11.0+

    
    
    func reduce<Result>(
        into initialResult: Result,
        _ updateAccumulatingResult: (inout Result, Message) async throws -> Void
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure executes.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(into:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on a sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

Prefer this method over `reduce(_:_:)` for efficiency when the result is a
copy-on-write type, for example an `Array` or `Dictionary`.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Message) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func map<Transformed>((Message) -> Transformed) ->
AsyncMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func map<Transformed>((Message) -> Transformed) ->
AsyncThrowingMapSequence<Message.Messages, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Message) -> SegmentOfResult) ->
AsyncFlatMapSequence<Message.Messages, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func reduce<Result>(Result, (Result, Message) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.



# SKError.Code

Enumeration Case

# SKError.Code.unknown

Error code indicating that an unknown or unexpected error occurred.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case unknown = 0

## Discussion

For more information about the underlying cause of the error, see the
`localizedDescription` property of the error object.

Retrying may resolve this error in some instances.

Enumeration Case

# SKError.Code.clientInvalid

Error code indicating that the client is not allowed to perform the attempted
action.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case clientInvalid = 1

Enumeration Case

# SKError.Code.paymentCancelled

Error code indicating that the user canceled a payment request.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case paymentCancelled = 2

Enumeration Case

# SKError.Code.paymentInvalid

Error code indicating that one of the payment parameters wasn’t recognized by
the App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case paymentInvalid = 3

Enumeration Case

# SKError.Code.paymentNotAllowed

Error code indicating that the user is not allowed to authorize payments.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case paymentNotAllowed = 4

Enumeration Case

# SKError.Code.storeProductNotAvailable

Error code indicating that the requested product is not available in the
store.

iOS 3.0+  iPadOS 3.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case storeProductNotAvailable = 5

## Discussion

See `SKStorefront` for more information.

Enumeration Case

# SKError.Code.cloudServicePermissionDenied

Error code indicating that the user has not allowed access to Cloud service
information.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.1+  tvOS 9.3+  watchOS
6.2+  visionOS 1.0+

    
    
    case cloudServicePermissionDenied = 6

Enumeration Case

# SKError.Code.cloudServiceNetworkConnectionFailed

Error code indicating that the device could not connect to the network.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.1+  tvOS 9.3+  watchOS
6.2+  visionOS 1.0+

    
    
    case cloudServiceNetworkConnectionFailed = 7

Enumeration Case

# SKError.Code.cloudServiceRevoked

Error code indicating that the user has revoked permission to use this cloud
service.

iOS 10.3+  iPadOS 10.3+  macOS 11.0+  Mac Catalyst 13.1+  tvOS 10.3+  watchOS
6.2+  visionOS 1.0+

    
    
    case cloudServiceRevoked = 8

Enumeration Case

# SKError.Code.privacyAcknowledgementRequired

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case privacyAcknowledgementRequired = 9

Enumeration Case

# SKError.Code.unauthorizedRequestData

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case unauthorizedRequestData = 10

## Discussion

To use `requestData`, an app must have a required entitlement.

Enumeration Case

# SKError.Code.invalidOfferIdentifier

Error code indicating that the offer identifier is invalid.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case invalidOfferIdentifier = 11

## Discussion

The offer `identifier` is not valid. For example, you have not set up an offer
with that identifier in the App Store, or you have revoked the offer.

Enumeration Case

# SKError.Code.invalidOfferPrice

Error code indicating that the price you specified in App Store Connect is no
longer valid.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case invalidOfferPrice = 14

## Discussion

An offer price can become invalid if you change the price of the base
subscription such that it is lower than the offer price. Offers must always
represent a discounted price.

Enumeration Case

# SKError.Code.invalidSignature

Error code indicating that the signature in a payment discount isn’t valid.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case invalidSignature = 12

## Discussion

The `signature` is not valid.

Enumeration Case

# SKError.Code.missingOfferParams

Error code indicating that parameters are missing in a payment discount.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case missingOfferParams = 13

## Discussion

This error appears if all parameters of `SKPaymentDiscount` are not present.

Enumeration Case

# SKError.Code.ineligibleForOffer

An error code that indicates the user is ineligible for the subscription
offer.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 14.0+  watchOS
7.0+  visionOS 1.0+

    
    
    case ineligibleForOffer = 18

Enumeration Case

# SKError.Code.overlayCancelled

An error code that indicates the cancellation of an overlay.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case overlayCancelled = 15

Enumeration Case

# SKError.Code.overlayInvalidConfiguration

An error code that indicates the overlay’s configuration is invalid.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    case overlayInvalidConfiguration = 16

Enumeration Case

# SKError.Code.overlayPresentedInBackgroundScene

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+  visionOS 1.0+

    
    
    case overlayPresentedInBackgroundScene = 20

Enumeration Case

# SKError.Code.overlayTimeout

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    case overlayTimeout = 17

Enumeration Case

# SKError.Code.unsupportedPlatform

An error code that indicates the current platform doesn’t support overlays.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  watchOS 7.0+
visionOS 1.0+

    
    
    case unsupportedPlatform = 19

Enumeration Case

# SKError.Code.unknown

Error code indicating that an unknown or unexpected error occurred.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case unknown = 0

## Discussion

For more information about the underlying cause of the error, see the
`localizedDescription` property of the error object.

Retrying may resolve this error in some instances.

Enumeration Case

# SKError.Code.clientInvalid

Error code indicating that the client is not allowed to perform the attempted
action.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case clientInvalid = 1

Enumeration Case

# SKError.Code.paymentCancelled

Error code indicating that the user canceled a payment request.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case paymentCancelled = 2

Enumeration Case

# SKError.Code.paymentInvalid

Error code indicating that one of the payment parameters wasn’t recognized by
the App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case paymentInvalid = 3

Enumeration Case

# SKError.Code.paymentNotAllowed

Error code indicating that the user is not allowed to authorize payments.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case paymentNotAllowed = 4

Enumeration Case

# SKError.Code.storeProductNotAvailable

Error code indicating that the requested product is not available in the
store.

iOS 3.0+  iPadOS 3.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case storeProductNotAvailable = 5

## Discussion

See `SKStorefront` for more information.

Enumeration Case

# SKError.Code.cloudServicePermissionDenied

Error code indicating that the user has not allowed access to Cloud service
information.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.1+  tvOS 9.3+  watchOS
6.2+  visionOS 1.0+

    
    
    case cloudServicePermissionDenied = 6

Enumeration Case

# SKError.Code.cloudServiceNetworkConnectionFailed

Error code indicating that the device could not connect to the network.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.1+  tvOS 9.3+  watchOS
6.2+  visionOS 1.0+

    
    
    case cloudServiceNetworkConnectionFailed = 7

Enumeration Case

# SKError.Code.cloudServiceRevoked

Error code indicating that the user has revoked permission to use this cloud
service.

iOS 10.3+  iPadOS 10.3+  macOS 11.0+  Mac Catalyst 13.1+  tvOS 10.3+  watchOS
6.2+  visionOS 1.0+

    
    
    case cloudServiceRevoked = 8

Enumeration Case

# SKError.Code.privacyAcknowledgementRequired

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case privacyAcknowledgementRequired = 9

Enumeration Case

# SKError.Code.unauthorizedRequestData

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case unauthorizedRequestData = 10

## Discussion

To use `requestData`, an app must have a required entitlement.

Enumeration Case

# SKError.Code.invalidOfferIdentifier

Error code indicating that the offer identifier is invalid.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case invalidOfferIdentifier = 11

## Discussion

The offer `identifier` is not valid. For example, you have not set up an offer
with that identifier in the App Store, or you have revoked the offer.

Enumeration Case

# SKError.Code.invalidOfferPrice

Error code indicating that the price you specified in App Store Connect is no
longer valid.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case invalidOfferPrice = 14

## Discussion

An offer price can become invalid if you change the price of the base
subscription such that it is lower than the offer price. Offers must always
represent a discounted price.

Enumeration Case

# SKError.Code.invalidSignature

Error code indicating that the signature in a payment discount isn’t valid.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case invalidSignature = 12

## Discussion

The `signature` is not valid.

Enumeration Case

# SKError.Code.missingOfferParams

Error code indicating that parameters are missing in a payment discount.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case missingOfferParams = 13

## Discussion

This error appears if all parameters of `SKPaymentDiscount` are not present.

Enumeration Case

# SKError.Code.ineligibleForOffer

An error code that indicates the user is ineligible for the subscription
offer.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 14.0+  watchOS
7.0+  visionOS 1.0+

    
    
    case ineligibleForOffer = 18

Enumeration Case

# SKError.Code.overlayCancelled

An error code that indicates the cancellation of an overlay.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case overlayCancelled = 15

Enumeration Case

# SKError.Code.overlayInvalidConfiguration

An error code that indicates the overlay’s configuration is invalid.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    case overlayInvalidConfiguration = 16

Enumeration Case

# SKError.Code.overlayPresentedInBackgroundScene

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+  visionOS 1.0+

    
    
    case overlayPresentedInBackgroundScene = 20

Enumeration Case

# SKError.Code.overlayTimeout

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    case overlayTimeout = 17

Enumeration Case

# SKError.Code.unsupportedPlatform

An error code that indicates the current platform doesn’t support overlays.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  watchOS 7.0+
visionOS 1.0+

    
    
    case unsupportedPlatform = 19



# SubscriptionStorePolicyKind

Type Property

# privacyPolicy

The privacy policy type.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var privacyPolicy: SubscriptionStorePolicyKind { get }

## See Also

### Getting policy types

`static var termsOfService: SubscriptionStorePolicyKind`

The terms of service policy type.

Type Property

# termsOfService

The terms of service policy type.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var termsOfService: SubscriptionStorePolicyKind { get }

## See Also

### Getting policy types

`static var privacyPolicy: SubscriptionStorePolicyKind`

The privacy policy type.

Instance Property

# hashValue

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing policy types

`func hash(into: inout Hasher)`

`static func != (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) ->
Bool`

Instance Method

# hash(into:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing policy types

`var hashValue: Int`

`static func != (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) ->
Bool`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func != (lhs: SubscriptionStorePolicyKind, rhs: SubscriptionStorePolicyKind) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing policy types

`var hashValue: Int`

`func hash(into: inout Hasher)`

`static func == (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) ->
Bool`

Operator

# ==(_:_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func == (a: SubscriptionStorePolicyKind, b: SubscriptionStorePolicyKind) -> Bool

## See Also

### Comparing and hashing policy types

`var hashValue: Int`

`func hash(into: inout Hasher)`

`static func != (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.



# ExternalPurchase.NoticeResult

Enumeration Case

# ExternalPurchase.NoticeResult.cancelled

Describes when people chose to cancel and not view external purchases.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 13.3+

    
    
    case cancelled

## Discussion

If your app’s call to `presentNoticeSheet()` results in this value, you must
not show external purchases.

## See Also

### Getting notice sheet results

`case continuedWithExternalPurchaseToken(token: String)`

Describes when people chose to continue to view external purchases, and
provides the external purchase token.

Enumeration Case

# ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:)

Describes when people chose to continue to view external purchases, and
provides the external purchase token.

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    case continuedWithExternalPurchaseToken(token: String)

##  Parameters

`token`

    

The external purchase token.

## Discussion

When your app calls `presentNoticeSheet()` and it results in this value:
`ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:)`,
your app can proceed to present external purchases.

Important

Record and use the token to report the customer’s external purchases to Apple.
For more information, see External Purchase Server API.

``

## See Also

### Getting notice sheet results

`case cancelled`

Describes when people chose to cancel and not view external purchases.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 15.4+  watchOS
10.4+  visionOS 1.0+  Xcode 13.3+

    
    
    static func != (lhs: ExternalPurchase.NoticeResult, rhs: ExternalPurchase.NoticeResult) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing results

`static func == (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult)
-> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 13.3+

    
    
    static func == (a: ExternalPurchase.NoticeResult, b: ExternalPurchase.NoticeResult) -> Bool

## See Also

### Comparing and hashing results

`static func != (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 13.3+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing results

`static func != (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult)
-> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 13.3+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing results

`static func != (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult)
-> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# Product.SubscriptionInfo.Status

Type Property

# updates

The asynchronous sequence that emits status information when a subscription’s
status changes.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var updates: Product.SubscriptionInfo.Status.Statuses { get }

## See Also

### Monitoring subscription status changes

`static var all: AsyncStream<(groupID: String, statuses:
[Product.SubscriptionInfo.Status])>`

`struct Product.SubscriptionInfo.Status.Statuses`

An asynchronous sequence that listens for new subscription status information.

Type Property

# all

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var all: AsyncStream<(groupID: String, statuses: [Product.SubscriptionInfo.Status])> { get }

## See Also

### Monitoring subscription status changes

`static var updates: Product.SubscriptionInfo.Status.Statuses`

The asynchronous sequence that emits status information when a subscription’s
status changes.

`struct Product.SubscriptionInfo.Status.Statuses`

An asynchronous sequence that listens for new subscription status information.

Instance Property

# state

The renewal state of the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let state: Product.SubscriptionInfo.RenewalState

## See Also

### Getting subscription status information

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# renewalInfo

The signed renewal information for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>

## See Also

### Getting subscription status information

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# transaction

The latest transaction for the subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let transaction: VerificationResult<Transaction>

## See Also

### Getting subscription status information

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.Status, rhs: Product.SubscriptionInfo.Status) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing status

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo.Status, b: Product.SubscriptionInfo.Status) -> Bool

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# updates

The asynchronous sequence that emits status information when a subscription’s
status changes.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var updates: Product.SubscriptionInfo.Status.Statuses { get }

## See Also

### Monitoring subscription status changes

`static var all: AsyncStream<(groupID: String, statuses:
[Product.SubscriptionInfo.Status])>`

`struct Product.SubscriptionInfo.Status.Statuses`

An asynchronous sequence that listens for new subscription status information.

Type Property

# all

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var all: AsyncStream<(groupID: String, statuses: [Product.SubscriptionInfo.Status])> { get }

## See Also

### Monitoring subscription status changes

`static var updates: Product.SubscriptionInfo.Status.Statuses`

The asynchronous sequence that emits status information when a subscription’s
status changes.

`struct Product.SubscriptionInfo.Status.Statuses`

An asynchronous sequence that listens for new subscription status information.

Instance Property

# state

The renewal state of the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let state: Product.SubscriptionInfo.RenewalState

## See Also

### Getting subscription status information

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# renewalInfo

The signed renewal information for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>

## See Also

### Getting subscription status information

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# transaction

The latest transaction for the subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let transaction: VerificationResult<Transaction>

## See Also

### Getting subscription status information

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.Status, rhs: Product.SubscriptionInfo.Status) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing status

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo.Status, b: Product.SubscriptionInfo.Status) -> Bool

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# updates

The asynchronous sequence that emits status information when a subscription’s
status changes.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var updates: Product.SubscriptionInfo.Status.Statuses { get }

## See Also

### Monitoring subscription status changes

`static var all: AsyncStream<(groupID: String, statuses:
[Product.SubscriptionInfo.Status])>`

`struct Product.SubscriptionInfo.Status.Statuses`

An asynchronous sequence that listens for new subscription status information.

Type Property

# all

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var all: AsyncStream<(groupID: String, statuses: [Product.SubscriptionInfo.Status])> { get }

## See Also

### Monitoring subscription status changes

`static var updates: Product.SubscriptionInfo.Status.Statuses`

The asynchronous sequence that emits status information when a subscription’s
status changes.

`struct Product.SubscriptionInfo.Status.Statuses`

An asynchronous sequence that listens for new subscription status information.

Instance Property

# state

The renewal state of the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let state: Product.SubscriptionInfo.RenewalState

## See Also

### Getting subscription status information

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# renewalInfo

The signed renewal information for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>

## See Also

### Getting subscription status information

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# transaction

The latest transaction for the subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let transaction: VerificationResult<Transaction>

## See Also

### Getting subscription status information

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.Status, rhs: Product.SubscriptionInfo.Status) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing status

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo.Status, b: Product.SubscriptionInfo.Status) -> Bool

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# updates

The asynchronous sequence that emits status information when a subscription’s
status changes.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var updates: Product.SubscriptionInfo.Status.Statuses { get }

## See Also

### Monitoring subscription status changes

`static var all: AsyncStream<(groupID: String, statuses:
[Product.SubscriptionInfo.Status])>`

`struct Product.SubscriptionInfo.Status.Statuses`

An asynchronous sequence that listens for new subscription status information.

Type Property

# all

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var all: AsyncStream<(groupID: String, statuses: [Product.SubscriptionInfo.Status])> { get }

## See Also

### Monitoring subscription status changes

`static var updates: Product.SubscriptionInfo.Status.Statuses`

The asynchronous sequence that emits status information when a subscription’s
status changes.

`struct Product.SubscriptionInfo.Status.Statuses`

An asynchronous sequence that listens for new subscription status information.

Instance Property

# state

The renewal state of the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let state: Product.SubscriptionInfo.RenewalState

## See Also

### Getting subscription status information

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# renewalInfo

The signed renewal information for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>

## See Also

### Getting subscription status information

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# transaction

The latest transaction for the subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let transaction: VerificationResult<Transaction>

## See Also

### Getting subscription status information

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.Status, rhs: Product.SubscriptionInfo.Status) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing status

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo.Status, b: Product.SubscriptionInfo.Status) -> Bool

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing status

`static func != (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# SKCloudServiceSetupOptionsKey

Initializer

# init(rawValue:)

Initializes a cloud service setup options key based on the provided raw value.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.0+  tvOS 9.0+  visionOS
1.0+  Xcode 7.1+

    
    
    init(rawValue: String)

Type Property

# action

A key that specifies the action for a setup entry point.

iOS 10.1+  iPadOS 10.1+  Mac Catalyst 13.1+  tvOS 10.0+

    
    
    static let action: SKCloudServiceSetupOptionsKey

## See Also

### Indicating Setup Options

`struct SKCloudServiceSetupAction`

A string used to specify the type of setup action to offer for a cloud
service.

`static let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store item that the user is trying to access
through the service.

`static let affiliateToken: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store affiliate token.

`static let campaignToken: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store affiliate campaign token.

`static let messageIdentifier: SKCloudServiceSetupOptionsKey`

A key that is used to select the main message presented to the user for this
setup view.

`struct SKCloudServiceSetupMessageIdentifier`

Identifiers for the available messages the setup view can present to the user.

Type Property

# iTunesItemIdentifier

A key that specifies the iTunes Store item that the user is trying to access
through the service.

iOS 10.1+  iPadOS 10.1+  Mac Catalyst 13.1+  tvOS 10.0+

    
    
    static let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey

## Discussion

The only iTunes Store items that are supported are song, video, playlist, and
album.

## See Also

### Indicating Setup Options

`static let action: SKCloudServiceSetupOptionsKey`

A key that specifies the action for a setup entry point.

`struct SKCloudServiceSetupAction`

A string used to specify the type of setup action to offer for a cloud
service.

`static let affiliateToken: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store affiliate token.

`static let campaignToken: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store affiliate campaign token.

`static let messageIdentifier: SKCloudServiceSetupOptionsKey`

A key that is used to select the main message presented to the user for this
setup view.

`struct SKCloudServiceSetupMessageIdentifier`

Identifiers for the available messages the setup view can present to the user.

Type Property

# affiliateToken

A key that specifies the iTunes Store affiliate token.

iOS 10.3+  iPadOS 10.3+  Mac Catalyst 13.1+  tvOS 10.2+

    
    
    static let affiliateToken: SKCloudServiceSetupOptionsKey

## See Also

### Indicating Setup Options

`static let action: SKCloudServiceSetupOptionsKey`

A key that specifies the action for a setup entry point.

`struct SKCloudServiceSetupAction`

A string used to specify the type of setup action to offer for a cloud
service.

`static let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store item that the user is trying to access
through the service.

`static let campaignToken: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store affiliate campaign token.

`static let messageIdentifier: SKCloudServiceSetupOptionsKey`

A key that is used to select the main message presented to the user for this
setup view.

`struct SKCloudServiceSetupMessageIdentifier`

Identifiers for the available messages the setup view can present to the user.

Type Property

# campaignToken

A key that specifies the iTunes Store affiliate campaign token.

iOS 10.3+  iPadOS 10.3+  Mac Catalyst 13.1+  tvOS 10.2+

    
    
    static let campaignToken: SKCloudServiceSetupOptionsKey

## See Also

### Indicating Setup Options

`static let action: SKCloudServiceSetupOptionsKey`

A key that specifies the action for a setup entry point.

`struct SKCloudServiceSetupAction`

A string used to specify the type of setup action to offer for a cloud
service.

`static let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store item that the user is trying to access
through the service.

`static let affiliateToken: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store affiliate token.

`static let messageIdentifier: SKCloudServiceSetupOptionsKey`

A key that is used to select the main message presented to the user for this
setup view.

`struct SKCloudServiceSetupMessageIdentifier`

Identifiers for the available messages the setup view can present to the user.

Type Property

# messageIdentifier

A key that is used to select the main message presented to the user for this
setup view.

iOS 11.0+  iPadOS 11.0+  Mac Catalyst 13.1+  tvOS 11.0+

    
    
    static let messageIdentifier: SKCloudServiceSetupOptionsKey

## Discussion

If this key is missing, the setup view is configured as if it is using the
`join` key by default.

## See Also

### Indicating Setup Options

`static let action: SKCloudServiceSetupOptionsKey`

A key that specifies the action for a setup entry point.

`struct SKCloudServiceSetupAction`

A string used to specify the type of setup action to offer for a cloud
service.

`static let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store item that the user is trying to access
through the service.

`static let affiliateToken: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store affiliate token.

`static let campaignToken: SKCloudServiceSetupOptionsKey`

A key that specifies the iTunes Store affiliate campaign token.

`struct SKCloudServiceSetupMessageIdentifier`

Identifiers for the available messages the setup view can present to the user.



# External Purchase

Property List Key

# com.apple.developer.storekit.external-purchase

A Boolean value that indicates whether your app can offer external purchases.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+

##  Details

Type

    

boolean

## Discussion

Qualifying apps may offer external purchases within the app. To offer external
purchases in your app, complete a request for this entitlement. For more
information about qualifying apps and to request this entitlement, see:

  * Distributing apps using alternative payment providers in the European Union

  * Distributing dating apps in the Netherlands

  * Distributing apps using a third-party payment provider in South Korea

If your account receives this entitlement, which is also known as the StoreKit
External Purchase entitlement, add it to your app by opening the project’s
.`entitlements` file in Xcode. Then add the following key and set the
corresponding value to `true`:

    
    
    <plist>
    <dict>
        <key>com.apple.developer.storekit.external-purchase</key>
        <true/>
    </dict>
    </plist>
    

For more information, see External Purchase.

## See Also

### StoreKit

`com.apple.developer.storekit.external-link.account`

A Boolean value that indicates whether your app can link to an external
website for account creation or management.

`com.apple.developer.storekit.external-purchase-link`

A Boolean value that indicates whether your app can include a link that
directs people to a website to make an external purchase.

Property List Key

# SKExternalPurchase

A string array of country codes that indicates your app supports external
purchases.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.0+

##  Details

Type

    

array of strings

## Discussion

Use this information property list key if your app has the
`com.apple.developer.storekit.external-purchase` entitlement.

To the array, add a string containing the lowercased ISO 3166-1 alpha-2
country code for each country where your app supports external purchases. The
following code example shows a property list entry with two strings, for the
Netherlands (`nl`) and Italy (`it`):

    
    
    <plist>
    <dict>
        <key>SKExternalPurchase</key>
        <array>
            <string>nl</string>
            <string>it</string>
        </array>
    </dict>
    </plist>
    

Use valid country codes for the following allowed countries or regions:

  * In the European Union: Austria (`at`), Belgium (`be`), Bulgaria (`bg`), Croatia (`hr`), Cyprus (`cy`), Czechia (`cz`), Denmark (`dk`), Estonia (`ee`), Finland (`fi`), France (`fr`), Germany (`de`), Greece (`gr`), Hungary (`hu`), Ireland (`ie`), Italy (`it`), Latvia (`lv`), Lithuania (`lt`), Luxembourg (`lu`), Malta (`mt`), Netherlands (`nl`), Poland (`pl`), Portugal (`pt`), Romania (`ro`), Slovakia (`sk`), Slovenia (`si`), Spain (`es`), Sweden (`se`) 

  * South Korea (`kr`)

For more information, see External Purchase.

## See Also

### Offering external purchases

`enum ExternalPurchase`

Enables qualifying apps to offer external purchases within the app.

`com.apple.developer.storekit.external-purchase`

A Boolean value that indicates whether your app can offer external purchases.

Property List Key

# com.apple.developer.storekit.external-purchase-link

A Boolean value that indicates whether your app can include a link that
directs people to a website to make an external purchase.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+

##  Details

Type

    

boolean

## Discussion

The `com.apple.developer.storekit.external-purchase-link` entitlement enables
qualifying apps to include a link that directs people using the app to a
website to make an external purchase. For more information about qualifying
apps and to request this entitlement, see:

  * Distributing apps using alternative payment providers in the European Union

  * Distributing dating apps in the Netherlands

  * Distributing apps in Russia that provide an external purchase link

  * Distributing apps in the U.S. that provide an external purchase link

  * Distributing music streaming apps in the EEA that provide an external purchase link

If your account receives this entitlement, which is also known as the StoreKit
External Purchase Link entitlement, you can add it to your app by opening the
project’s `.entitlements` file in Xcode. Then add the following key and set
the corresponding value to `true`:

    
    
    <plist>
    <dict>
        <key>com.apple.developer.storekit.external-purchase-link</key>
        <true/>
    </dict>
    </plist>
    

For more information, see External Purchase.

## See Also

### StoreKit

`com.apple.developer.storekit.external-link.account`

A Boolean value that indicates whether your app can link to an external
website for account creation or management.

`com.apple.developer.storekit.external-purchase`

A Boolean value that indicates whether your app can offer external purchases.

Property List Key

# SKExternalPurchaseMultiLink

A dictionary that contains an array of URLs to websites where people using
your app can make external purchases.

iOS 17.5+ Beta iPadOS 17.5+ Beta macOS 14.5+ Beta Mac Catalyst 17.5+ Beta tvOS
17.5+ Beta watchOS 10.5+ Beta visionOS 1.2+ Beta

##  Details

Type

    

dictionary

## Properties

`Any Key`

`[string]`

A dictionary with a key that is the lowercased ISO 3166-1 alpha-2 country
code, and an array of strings that represent valid destination URLs.

Valid country codes include those for the European Union: Austria (`at`),
Belgium (`be`), Bulgaria (`bg`), Croatia (`hr`), Cyprus (`cy`), Czechia
(`cz`), Denmark (`dk`), Estonia (`ee`), Finland (`fi`), France (`fr`), Germany
(`de`), Greece (`gr`), Hungary (`hu`), Ireland (`ie`), Italy (`it`), Latvia
(`lv`), Lithuania (`lt`), Luxembourg (`lu`), Malta (`mt`), Netherlands (`nl`),
Poland (`pl`), Portugal (`pt`), Romania (`ro`), Slovakia (`sk`), Slovenia
(`si`), Spain (`es`), Sweden (`se`); and Iceland (`is`), Norway (`no`), Russia
(`ru`), and United States (`us`).

## Discussion

Use this information property list key if your app has the
`com.apple.developer.storekit.external-purchase-link` entitlement.

Include a key entry for each country code where your app supports an external
purchase link. Provide from one to five destination URLs (links to your
website) for your app to choose from for each country code.

Note

You can provide up to five links if your app qualifies for the StoreKit
External Purchase Link entitlement as described in Distributing music
streaming apps in the EEA that provide an external purchase link.  Otherwise,
provide one link for each country code.

Your app accesses these URLs through the `eligibleURLs` array in the
`ExternalPurchaseLink` object, and uses the link you select with the
`open(url:)` method in the `ExternalPurchaseLink` object.

Important

At all times, the destination URLs that you provide in the property list key
must match the values in your app binary that you submit to App Review.

Make sure each destination URL meets all of the following conditions:

  * Uses the HTTPS scheme

  * Forms a valid, absolute URL

  * Contains no query parameters

  * Contains 1,000 or fewer ASCII characters

The following code example shows a property list entry with keys for several
country codes, and links for each entry:

    
    
    <key>SKExternalPurchaseMultiLink</key>
    <dict>
        <key>es</key>
        <array>
            <string>https://www.example.com/es1</string>
            <string>https://www.example.com/new-user-es</string>
            <string>https://www.example.com/seasonal-sale-es</string>
            <string>https://www.example.com/es2</string>
            <string>https://www.example.com/es3</string>
        </array>
        <key>fr</key>
        <array>
            <string>https://www.example.com/fr</string>
            <string>https://www.example.com/global-sale</string>
            <string>https://www.example.com/new-user-fr</string>
        </array>
        <key>it</key>
        <array>
            <string>https://www.example.com/global-sale</string>
        </array>
    </dict>
    

The order of the links is not significant.

For more information, see External Purchase and `ExternalPurchaseLink`.

### Provide up to the maximum number of links

The following country codes have a maximum of five links for apps that qualify
for the StoreKit External Purchase Link entitlement as described in
Distributing music streaming apps in the EEA that provide an external purchase
link: Austria (`at`), Belgium (`be`), Bulgaria (`bg`), Croatia (`hr`), Cyprus
(`cy`), Czechia (`cz`), Denmark (`dk`), Estonia (`ee`), Finland (`fi`), France
(`fr`), Germany (`de`), Greece (`gr`), Hungary (`hu`), Ireland (`ie`), Italy
(`it`), Latvia (`lv`), Lithuania (`lt`), Luxembourg (`lu`), Malta (`mt`),
Netherlands (`nl`), Poland (`pl`), Portugal (`pt`), Romania (`ro`), Slovakia
(`sk`), Slovenia (`si`), Spain (`es`), Sweden (`se`), Iceland (`is`), Norway
(`no`). Otherwise, the maximum is one link, for valid country codes.

Count the total number of unique links you provide for each country code by
adding together the number of links you provide in the
`SKExternalPurchaseMultiLink` and `SKExternalPurchaseLink` property list keys.

For example, if a country code has a maximum of five links and you provide
five unique links in the `SKExternalPurchaseMultiLink` key, then specify one
of the same five links in the `SKExternalPurchaseLink` key to avoid exceeding
the maximum allowed links. If a country code has a maximum of one link, the
`SKExternalPurchaseMultiLink` and `SKExternalPurchaseLink` keys need to
specify the same link.

Beta Software

This documentation contains preliminary information about an API or technology
in development. This information is subject to change, and software
implemented according to this documentation should be tested with final
operating system software.

Learn more about using Apple's beta software

Property List Key

# SKExternalPurchaseLink

A dictionary that contains URLs to websites where people using your app can
make external purchases, for supported regions.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.0+

##  Details

Type

    

dictionary

## Properties

`Any Key`

`string`

A dictionary with a key that is the lowercased ISO 3166-1 alpha-2 country
code, and a string that contains a valid destination URL.

Valid country codes include those for the European Union: Austria (`at`),
Belgium (`be`), Bulgaria (`bg`), Croatia (`hr`), Cyprus (`cy`), Czechia
(`cz`), Denmark (`dk`), Estonia (`ee`), Finland (`fi`), France (`fr`), Germany
(`de`), Greece (`gr`), Hungary (`hu`), Ireland (`ie`), Italy (`it`), Latvia
(`lv`), Lithuania (`lt`), Luxembourg (`lu`), Malta (`mt`), Netherlands (`nl`),
Poland (`pl`), Portugal (`pt`), Romania (`ro`), Slovakia (`sk`), Slovenia
(`si`), Spain (`es`), Sweden (`se`); and Iceland (`is`), Norway (`no`), Russia
(`ru`), and United States (`us`).

## Discussion

Use this information property list key if your app has the
`com.apple.developer.storekit.external-purchase-link` entitlement and your app
has a minimum OS version prior to iOS 17.5, macOS 14.5, watchOS 10.5, tvOS
17.5, or visionOS 1.2. Otherwise, use the `SKExternalPurchaseMultiLink`
property list key to provide multiple URLs for country codes that allow
multiple links.

Include one key entry for each country code where your app supports an
external purchase link. Provide a destination URL (link to your website) for
your app to open when the country code in the key matches the device’s App
Store storefront. If you support multiple country codes, you may provide the
same or different destination URLs for each country code.

Important

At all times, the destination URLs that you provide in the property list key
must match the values in your app binary that you submit to App Review.

Make sure the destination URL meets all of the following conditions:

  * Uses the HTTPS scheme

  * Forms a valid, absolute URL

  * Contains no query parameters

  * Contains 1,000 or fewer ASCII characters.

The following code example shows a property list entry with a single country
code key, for the Netherlands (`nl`). Replace the string
"`https://example.com`" below with your link:

    
    
    <plist>
    <dict>
        <key>SKExternalPurchaseLink</key>
        <dict>
            <key>nl</key>
            <string>https://example.com</string>
        </dict>
    </dict>
    </plist>
    

The following code example shows a property list entry with keys for more than
one country code. Replace the “`https://example.com`“ strings with your links:

    
    
    <plist>
    <dict>
        <key>SKExternalPurchaseLink</key>
        <dict>
            <key>at</key>
            <string>https://ex1.example.com</string>
            <key>nl</key>
            <string>https://ex2.example.com</string>
            <key>it</key>
            <string>https://ex2.example.com</string>
        </dict>
    </dict>
    </plist>
    

For more information, see External Purchase.

## See Also

### Offering external purchase links

`enum ExternalPurchaseLink`

Enables qualifying apps to offer external purchase links.

`com.apple.developer.storekit.external-purchase-link`

A Boolean value that indicates whether your app can include a link that
directs people to a website to make an external purchase.

`property list key SKExternalPurchaseMultiLink`

A dictionary that contains an array of URLs to websites where people using
your app can make external purchases.

Beta

Article

# Receiving and decoding external purchase tokens

Receive tokens for external purchases that you use to report transactions to
Apple.

## Overview

An _external purchase token_ is a unique string that your app or website
receives when your app’s customer chooses to view your external purchase
offerings. You receive external purchase tokens in two ways: within your app,
or appended to your website URL for link out, as follows:

  * In your app, the API returns the token when your app calls `presentNoticeSheet()` and the response is `ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:)`.

  * For link out, when your app calls `open()`, the API appends the token to the current storefront’s destination URL that you configure in the `SKExternalPurchaseLink` property list key.

Decode the token to obtain its `externalPurchaseId`, which you use to report
the tokens and associated transactions to Apple using the Send External
Purchase Report endpoint of the External Purchase Server API.

### Decode external purchase tokens

The token your app or website’s server receives is a string that is Base64URL-
encoded JSON. Decode the token using Base64URL decoding to read the JSON,
which contains the following fields:

  * The `appAppleId` and `bundleId`, which uniquely identify the app to which the token applies

  * The `tokenCreationDate`, which is the UNIX time, in milliseconds, when the system created the token

  * The `externalPurchaseId`, which is a unique value the system created to identify the token

The `externalPurchaseId` field is required by the Send External Purchase
Report endpoint when you report tokens and transactions. To get the
`externalPurchaseId`, follow these steps:

  * Decode the token string using Base64URL decoding. For example, if the token string is:

`ewoJImFwcEFwcGxlSWQiOjEyMzQ1Njc4OTAsCgkiYnVuZGxlSWQiOiJjb20uZXhhbXBsZSIsCgkidG9rZW5DcmVhdGlvbkRhdGUiOjE3MDYxNjk2MDAwMDAsCgkiZXh0ZXJuYWxQdXJjaGFzZUlkIjoiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwIgp9`

Then, the token’s value after Base64URL decoding is the following JSON:

    
    
    {  
      "appAppleId":1234567890,  
      "bundleId":"com.example",  
      "tokenCreationDate":1706169600000,
      "externalPurchaseId":"00000000-0000-0000-0000-000000000000"
    }
    

  * Use the value of the `externalPurchaseId` property to identify the token when you call the Send External Purchase Report endpoint.

### Recognize tokens from the testing environment

The External Purchase API returns external purchase tokens that are specific
to the app’s environment: production or sandbox. You can recognize a token for
the sandbox environment by its `externalPurchaseId` property, which always
begins with "`SANDBOX`".

The following example is an external purchase token that the system created in
the sandbox environment. The sandbox token string is:

`ewoJImFwcEFwcGxlSWQiOjEyMzQ1Njc4OTAsCgkiYnVuZGxlSWQiOiJjb20uZXhhbXBsZSIsCgkidG9rZW5DcmVhdGlvbkRhdGUiOjE3MDYxNjk2MDAwMDAsCgkiZXh0ZXJuYWxQdXJjaGFzZUlkIjoiU0FOREJPWF8wMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAiCn0K`

The token’s JSON content after Base64URL decoding is:

    
    
    {
        "appAppleId":1234567890,
        "bundleId":"com.example",
        "tokenCreationDate":1706169600000,
        "externalPurchaseId":"SANDBOX_00000000-0000-0000-0000-000000000000"
    }
    

The `externalPurchaseId` includes the "`SANDBOX`" prefix in the testing
environment.



# SKProduct

Instance Property

# productIdentifier

The string that identifies the product to the Apple App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var productIdentifier: String { get }

Instance Property

# localizedDescription

A description of the product.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var localizedDescription: String { get }

## Discussion

The description's language is determined by the storefront that the user's
device is connected to, not the preferred language set on the device.

## See Also

### Getting Product Attributes

`var localizedTitle: String`

The name of the product.

`var contentVersion: String`

A string that identifies the version of the content.

`var isFamilyShareable: Bool`

A Boolean value that indicates whether the product is available for Family
Sharing in App Store Connect.

`var contentLengths: [NSNumber]`

The total size of the content, in bytes.

Deprecated

### Related Documentation

`class SKStorefront`

An object containing the location and unique identifier of an Apple App Store
storefront.

Instance Property

# localizedTitle

The name of the product.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var localizedTitle: String { get }

## Discussion

The title's language is determined by the storefront that the user's device is
connected to, not the preferred language set on the device.

## See Also

### Getting Product Attributes

`var localizedDescription: String`

A description of the product.

`var contentVersion: String`

A string that identifies the version of the content.

`var isFamilyShareable: Bool`

A Boolean value that indicates whether the product is available for Family
Sharing in App Store Connect.

`var contentLengths: [NSNumber]`

The total size of the content, in bytes.

Deprecated

### Related Documentation

`class SKStorefront`

An object containing the location and unique identifier of an Apple App Store
storefront.

Instance Property

# contentVersion

A string that identifies the version of the content.

iOS 13.0+  iPadOS 13.0+  macOS 10.8–10.14  Deprecated  Mac Catalyst 13.1–13.1
Deprecated  tvOS 13.0+  watchOS 6.2+

    
    
    var contentVersion: String { get }

## See Also

### Getting Product Attributes

`var localizedDescription: String`

A description of the product.

`var localizedTitle: String`

The name of the product.

`var isFamilyShareable: Bool`

A Boolean value that indicates whether the product is available for Family
Sharing in App Store Connect.

`var contentLengths: [NSNumber]`

The total size of the content, in bytes.

Deprecated

Instance Property

# isFamilyShareable

A Boolean value that indicates whether the product is available for Family
Sharing in App Store Connect.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 14.0+  watchOS
7.0+  visionOS 1.0+

    
    
    var isFamilyShareable: Bool { get }

## Discussion

Check the value of `isFamilyShareable` to learn whether an in-app purchase is
sharable with the family group.

    
    
    // Determine whether an in-app purchase supports Family Sharing.
    let myProduct: SKProduct = getProductWithId(id: "com.example.product_identifier")
    if myProduct.isFamilyShareable {
        print("Product can be shared with family group.")
    }
    

When displaying in-app purchases in your app, indicate whether the product
includes Family Sharing to help customers make a selection that best fits
their needs.

Configure your in-app purchases to allow Family Sharing in App Store Connect.
For more information about setting up Family Sharing, see Turn-on Family
Sharing for in-app purchases.

## See Also

### Getting Product Attributes

`var localizedDescription: String`

A description of the product.

`var localizedTitle: String`

The name of the product.

`var contentVersion: String`

A string that identifies the version of the content.

`var contentLengths: [NSNumber]`

The total size of the content, in bytes.

Deprecated

Instance Property

# contentLengths

The total size of the content, in bytes.

macOS 10.8–10.14  Deprecated

    
    
    var contentLengths: [NSNumber] { get }

## See Also

### Getting Product Attributes

`var localizedDescription: String`

A description of the product.

`var localizedTitle: String`

The name of the product.

`var contentVersion: String`

A string that identifies the version of the content.

`var isFamilyShareable: Bool`

A Boolean value that indicates whether the product is available for Family
Sharing in App Store Connect.

Instance Property

# price

The cost of the product in the local currency.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var price: NSDecimalNumber { get }

## Discussion

Your app can format the price using a number formatter, as shown in the
following sample code:

## See Also

### Getting Pricing Information

`var priceLocale: Locale`

The locale used to format the price of the product.

`var introductoryPrice: SKProductDiscount?`

The object containing introductory price information for the product.

`var discounts: [SKProductDiscount]`

An array of subscription offers available for the auto-renewable subscription.

`class SKProductDiscount`

The details of an introductory offer or a promotional offer for an auto-
renewable subscription.

Instance Property

# priceLocale

The locale used to format the price of the product.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var priceLocale: Locale { get }

## Discussion

Use the locale to format the `price`.

## See Also

### Getting Pricing Information

`var price: NSDecimalNumber`

The cost of the product in the local currency.

`var introductoryPrice: SKProductDiscount?`

The object containing introductory price information for the product.

`var discounts: [SKProductDiscount]`

An array of subscription offers available for the auto-renewable subscription.

`class SKProductDiscount`

The details of an introductory offer or a promotional offer for an auto-
renewable subscription.

Instance Property

# introductoryPrice

The object containing introductory price information for the product.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var introductoryPrice: SKProductDiscount? { get }

## Discussion

If you've set up introductory prices in App Store Connect, the introductory
price property will be populated. This property is `nil` if the product has no
introductory price.

Before displaying UI that offers the introductory price, you must first
determine if the user is eligible to receive it. See Implementing introductory
offers in your app for information on determining eligibility and displaying
introductory prices.

## See Also

### Getting Pricing Information

`var price: NSDecimalNumber`

The cost of the product in the local currency.

`var priceLocale: Locale`

The locale used to format the price of the product.

`var discounts: [SKProductDiscount]`

An array of subscription offers available for the auto-renewable subscription.

`class SKProductDiscount`

The details of an introductory offer or a promotional offer for an auto-
renewable subscription.

Instance Property

# discounts

An array of subscription offers available for the auto-renewable subscription.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var discounts: [SKProductDiscount] { get }

## Discussion

The `discounts` array contains all of the introductory offers and promotional
offers that you set up in App Store Connect for this subscription
(`productIdentifier`). It's up to the logic in your app to decide which offer
to present to the user.

For more information about offers, see Implementing promotional offers in your
app, and Implementing introductory offers in your app.

## See Also

### Getting Pricing Information

`var price: NSDecimalNumber`

The cost of the product in the local currency.

`var priceLocale: Locale`

The locale used to format the price of the product.

`var introductoryPrice: SKProductDiscount?`

The object containing introductory price information for the product.

`class SKProductDiscount`

The details of an introductory offer or a promotional offer for an auto-
renewable subscription.

Instance Property

# subscriptionGroupIdentifier

The identifier of the subscription group to which the subscription belongs.

iOS 12.0+  iPadOS 12.0+  macOS 10.14+  Mac Catalyst 13.1+  tvOS 12.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var subscriptionGroupIdentifier: String? { get }

## Discussion

Auto-renewable subscriptions always belong to a subscription group. You create
the subscription group identifiers in App Store Connect before you create and
add an auto-renewable subscription. For more information about subscription
groups, see Offer auto-renewable subscriptions.

This property is `nil` if the `SKProduct` isn’t an auto-renewable
subscription.

## See Also

### Getting Subscription Information

`var subscriptionPeriod: SKProductSubscriptionPeriod?`

The period details for products that are subscriptions.

`class SKProductSubscriptionPeriod`

An object containing the subscription period duration information.

`enum SKProduct.PeriodUnit`

Values representing the duration of an interval, from a day up to a year.

Instance Property

# subscriptionPeriod

The period details for products that are subscriptions.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var subscriptionPeriod: SKProductSubscriptionPeriod? { get }

## Discussion

This read-only property is `nil` if the product is not a subscription.

A subscription period is described in terms of a unit and the number of units
that make up a single period.

## See Also

### Getting Subscription Information

`var subscriptionGroupIdentifier: String?`

The identifier of the subscription group to which the subscription belongs.

`class SKProductSubscriptionPeriod`

An object containing the subscription period duration information.

`enum SKProduct.PeriodUnit`

Values representing the duration of an interval, from a day up to a year.

Instance Property

# isDownloadable

A Boolean value that indicates whether the App Store has downloadable content
for this product.

iOS 6.0+  iPadOS 6.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var isDownloadable: Bool { get }

## Discussion

You can associate a set of data files with the App Store Connect record you
created for a product. The value of this property is `true` if at least one
file has been associated with the product.

## See Also

### Getting Downloadable Content Information

`var downloadContentLengths: [NSNumber]`

The lengths of the downloadable files available for this product.

`var downloadContentVersion: String`

A string that identifies which version of the content is available for
download.

`var downloadable: Bool`

A Boolean value that indicates whether the App Store has downloadable content
for this product.

Deprecated

Instance Property

# downloadContentLengths

The lengths of the downloadable files available for this product.

iOS 6.0+  iPadOS 6.0+  macOS 10.14+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var downloadContentLengths: [NSNumber] { get }

## Discussion

The array holds `NSNumber` objects, each of which holds a `long long` value
that is the size of one of the downloadable files (in bytes).

## See Also

### Getting Downloadable Content Information

`var isDownloadable: Bool`

A Boolean value that indicates whether the App Store has downloadable content
for this product.

`var downloadContentVersion: String`

A string that identifies which version of the content is available for
download.

`var downloadable: Bool`

A Boolean value that indicates whether the App Store has downloadable content
for this product.

Deprecated

Instance Property

# downloadContentVersion

A string that identifies which version of the content is available for
download.

iOS 6.0+  iPadOS 6.0+  macOS 10.14+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var downloadContentVersion: String { get }

## Discussion

The version string is formatted as a series of integers separated by periods.

## See Also

### Getting Downloadable Content Information

`var isDownloadable: Bool`

A Boolean value that indicates whether the App Store has downloadable content
for this product.

`var downloadContentLengths: [NSNumber]`

The lengths of the downloadable files available for this product.

`var downloadable: Bool`

A Boolean value that indicates whether the App Store has downloadable content
for this product.

Deprecated

Instance Property

# downloadable

A Boolean value that indicates whether the App Store has downloadable content
for this product.

macOS 10.8–10.15  Deprecated

    
    
    var downloadable: Bool { get }

Deprecated

Use `isDownloadable` instead.

## Discussion

You can associate a set of data files with the App Store Connect record you
created for a product. The value of this property is `true` if at least one
file has been associated with the product.

## See Also

### Getting Downloadable Content Information

`var isDownloadable: Bool`

A Boolean value that indicates whether the App Store has downloadable content
for this product.

`var downloadContentLengths: [NSNumber]`

The lengths of the downloadable files available for this product.

`var downloadContentVersion: String`

A string that identifies which version of the content is available for
download.



# PurchaseIntent.PurchaseIntents.AsyncIterator

Instance Method

# next()

Advances to and returns the next element, if it exists.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    mutating func next() async -> PurchaseIntent.PurchaseIntents.Element?

## Return Value

The next element in the underlying sequence, if a next element exists;
otherwise, `nil`.

## Relationships

### From Protocol

  * `AsyncIteratorProtocol`

## See Also

### Getting the next element

`typealias PurchaseIntent.PurchaseIntents.AsyncIterator.Element`

The type of element the iterator produces.

Type Alias

# PurchaseIntent.PurchaseIntents.AsyncIterator.Element

The type of element the iterator produces.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    typealias PurchaseIntent.PurchaseIntents.AsyncIterator.Element = PurchaseIntent.PurchaseIntents.Element

## See Also

### Getting the next element

`func next() -> PurchaseIntent.PurchaseIntents.Element?`

Advances to and returns the next element, if it exists.



# Testing in-app purchases with sandbox

Article

# Testing fetching product identifiers

Verify that your app receives the correct product identifiers by inspecting or
replicating your app’s process for retrieving the identifiers.

## Overview

If you embed your product identifiers in your app, set a breakpoint in your
code after the code loads the identifiers. Verify that the instance of
`NSArray` contains your expected list of product identifiers.

Note

Changes that you make to product metadata in App Store Connect can take up to
one hour to appear in the sandbox environment.

If your app fetches your product identifiers from a server, manually fetch the
JSON file using a web browser such as Safari, or a command-line utility such
as `curl`. Verify that the data your server returns contains the expected list
of product identifiers and that your server correctly implements standard HTTP
caching mechanisms.

For more information on fetching product identifiers, see Loading in-app
product identifiers.

## See Also

### Product identifiers and requests

Testing invalid product identifier handling

Verify that your app correctly handles invalid product identifiers.

Testing a product request

Verify that requests for products function properly in the sandbox environment
by inspecting the App Store response.

Article

# Testing invalid product identifier handling

Verify that your app correctly handles invalid product identifiers.

## Overview

Intentionally include an invalid identifier in your app’s list of product
identifiers. Then do one of the following:

  * In a production build, verify that the app displays the rest of its store UI and that users can purchase the valid products.

  * In a development build, verify that the app brings the issue to your attention.

Check the console log and verify that you can correctly identify the invalid
product identifier. Make sure you remove it after testing.

For more information on fetching product identifiers, see Loading in-app
product identifiers.

## See Also

### Product identifiers and requests

Testing fetching product identifiers

Verify that your app receives the correct product identifiers by inspecting or
replicating your app’s process for retrieving the identifiers.

Testing a product request

Verify that requests for products function properly in the sandbox environment
by inspecting the App Store response.

Article

# Testing a product request

Verify that requests for products function properly in the sandbox environment
by inspecting the App Store response.

## Overview

After setting a breakpoint in your code, use the list of product identifiers
that you tested in Testing fetching product identifiers to create and submit
an instance of `SKProductsRequest`. Then inspect the lists of valid and
invalid product identifiers. If there are invalid product identifiers, review
your products in App Store Connect and correct your JSON file or property
list.

Note

Changes that you make to product metadata in App Store Connect can take up to
one hour to appear in the sandbox environment.

See Testing invalid product identifier handling for more information.

## See Also

### Product identifiers and requests

Testing fetching product identifiers

Verify that your app receives the correct product identifiers by inspecting or
replicating your app’s process for retrieving the identifiers.

Testing invalid product identifier handling

Verify that your app correctly handles invalid product identifiers.

Article

# Testing purchases made outside your app

Verify that your app receives and handles transactions that occur outside of
your app, such as subscription purchases, renewals, and offer and promo code
redemptions.

## Overview

When your app offers in-app purchases, customers typically buy the products
from within your app. However, purchase transactions can also occur on another
device or even outside your app. Your app needs to handle these transactions
when it launches. Use the Test Transactions feature in Account Settings in iOS
to simulate and test such transactions in the sandbox environment.

### Simulate a variety of purchase events

Several types of events result in a purchase transaction that occurs outside
your app, including the following:

Redeeming offer codes

    

People can redeem offer codes on the Redeem Gift Card or Code page in their
App Store account settings, by using a redemption URL, and when your app calls
`presentCodeRedemptionSheet()`. For more information, see Set up offer codes.

Redeeming a promo code for an in-app purchase

    

People can redeem a promo codes in the App Store. For more information, see
Request and manage promo codes.

Renewing an auto-renewable subscription

    

Apple bills customers when an auto-renewable subscription renews, and the
renewal transaction occurs outside your app.

Resubscribing from the Apple Subscriptions page

    

People can resubscribe to expired subscriptions from their Account >
Subscriptions page in the App Store.

All of these events result in StoreKit sending a transaction to your app
through the `updates` asynchronous sequence in `Transaction`. Test your app to
be sure it handles the transaction.

### Set up and perform a test

To create a transaction outside your app for the testing environment, first
open Account Settings on the iOS device, as follows:

  1. Open Settings and select App Store.

  2. Select the Sandbox Apple ID. 

  3. Select Manage on the popup sheet. The Account Settings page appears.

Next, you need the product ID for a product you set up in App Store Connect,
and your app’s bundle ID.

Note

Changes that you make to product metadata in App Store Connect can take up to
one hour to appear in the sandbox environment.

To simulate a purchase outside your app, follow these steps:

  1. On the Account Settings page, select Test Transactions.

  2. Enter your product ID and the bundle ID in the text boxes labeled Product ID and Bundle ID, respectively.

  3. Click Next.

  4. The system brings up the payment sheet for the sandbox environment, which is labeled with "App Store [Sandbox]". Confirm the purchase. Note: The sandbox environment doesn’t process actual payments. Instead, it returns transactions as if payments were processed successfully.

After you confirm the purchase, use the following steps to test your app:

  1. Open your app. The system delivers the new transaction to your app through the `updates` asynchronous sequence in `Transaction`.

  2. Confirm that your app receives and processes the transaction to provide access to the purchased product.

### Conclude or restart a test

You can repeat the test by purchasing the product again through the Test
Transactions feature in Account Settings. To repurchase some products you
might first need to clear the transactions for the Sandbox Apple ID, following
these steps:

  1. Open Settings and select App Store.

  2. Select the Sandbox Apple ID.

  3. Select Manage on the popup sheet.

  4. On the Account Settings page, select Clear Purchase History.

Restart your app. The purchase history for the Sandbox Apple ID will be empty
and ready for testing. Clearing the purchase history for Sandbox Apple IDs
with a high number of purchases may take longer.

## See Also

### Payment transactions

Testing an interrupted purchase

Verify that your app handles an interrupted purchase by inspecting and
invoking payment transactions.

Testing failing subscription renewals and in-app purchases

Verify that your app handles failed subscription renewals that are in the
billing retry or billing grace period states, as well as failed in-app
purchases.

Testing a payment request

Verify that requests for payment function properly in the sandbox environment
by inspecting the calls to the payment transaction observer.

Article

# Testing an interrupted purchase

Verify that your app handles an interrupted purchase by inspecting and
invoking payment transactions.

## Overview

An interrupted purchase is a transaction that requires the user to perform
some action outside of your app before completing their transaction. For
example, the user may need to update their payment method or accept new terms
and conditions before continuing with their transaction.

In sandbox testing, you can simulate an interrupted purchase by turning on the
interrupted purchase feature in App Store Connect for a tester Sandbox Apple
ID. This interrupts all purchase attempts by that Sandbox Apple ID until you
agree to the updated terms and conditions on the iOS device, or until you turn
off the feature in App Store Connect. To learn how to set up interrupted
purchase testing, see Enable interrupted purchases for a Sandbox Apple ID.

### Set up testing

To enable interrupted purchases for the Sandbox Apple ID, log in to App Store
Connect, and do the following:

  1. From Users and Access, open the Users and Access Panel in the sidebar, under the Sandbox header, select Testers. On the right, you can view your Sandbox Apple IDs.

  2. Select a Sandbox Apple ID to use for testing interrupted purchases. If it’s already enabled, you’ll see a checkmark under the Interrupted Purchases column.

  3. In the dialog that appears, select Interrupt Purchases for This Tester.

### Begin testing

After setting up interrupted purchase testing in App Store Connect, use the
following steps to test your app:

  1. On the test device, sign in with the Sandbox Apple ID that has interrupted purchases enabled.

  2. In your app, select Buy or Subscribe to make an in-app purchase. 

  3. Observe that the system displays a payment sheet.

  4. In Xcode, verify that the payment queue receives a new transaction in the state `SKPaymentTransactionState.purchasing`.

  5. On the device, authenticate the payment sheet.

  6. In Xcode, observe that the payment fails. The payment queue receives an updated transaction in the state `SKPaymentTransactionState.failed`.

  7. Check that your code calls `finishTransaction(_:)` to remove it from the queue.

  8. On the device, observe that the system displays Terms & Conditions, interrupting the purchase (because you configured the sandbox environment to do so).

  9. On the device, tap to agree to the Terms & Conditions.

  10. In Xcode, verify that the payment queue receives a new transaction in the `SKPaymentTransactionState.purchased` state for the same `productIdentifier` and in the same quantity as the failed transaction.

  11. In Xcode, validate the receipt. Check that your app provides the service or the product, and calls `finishTransaction(_:)`.

  12. On the device, the user should observe a successful purchase.

### Conclude testing

The Sandbox Apple ID continues to experience interrupted purchases until you
disable it in App Store Connect, or until the user agrees to the terms and
conditions on the device. To disable interrupted purchases in App Store
Connect, deselect Interrupt Purchases for This Tester. For more information,
see Enable interrupted purchases for a Sandbox Apple ID.

## See Also

### Payment transactions

Testing purchases made outside your app

Verify that your app receives and handles transactions that occur outside of
your app, such as subscription purchases, renewals, and offer and promo code
redemptions.

Testing failing subscription renewals and in-app purchases

Verify that your app handles failed subscription renewals that are in the
billing retry or billing grace period states, as well as failed in-app
purchases.

Testing a payment request

Verify that requests for payment function properly in the sandbox environment
by inspecting the calls to the payment transaction observer.

Article

# Testing failing subscription renewals and in-app purchases

Verify that your app handles failed subscription renewals that are in the
billing retry or billing grace period states, as well as failed in-app
purchases.

## Overview

Payments can fail unexpectedly at any stage of the billing cycle, such as when
a payment card expires. Test your app’s user experience to ensure it handles
these unexpected events, and provides appropriate levels of service when
billing issues occur.

In sandbox testing, you can simulate billing issues that cause in-app
purchases to fail, and auto-renewable subscriptions not to renew. You can also
enable Billing Grace Period for the sandbox environment. Use these sandbox
features to test how your app handles auto-renewable subscriptions with
billing issues that do or don’t recover.

The sandbox environment sends App Store Server Notifications as you perform
tests. For more information, see Enabling App Store Server Notifications.

The sandbox environment renews auto-renewable subscriptions up to 12 times.
For more information about renewal rates in the sandbox environment, see Edit
subscription renewal speed.

For more information about subscription state changes when billing issues
occur, see Reducing Involuntary Subscriber Churn. For information about how
apps determine access to subscription content, see Handling Subscriptions
Billing.

### Configure the sandbox environment to simulate billing issues

Follow these steps on a test device running iOS 16 or iPadOS 16, or later:

  1. Sign in to the App Store using a Sandbox Apple ID.

  2. Choose Settings > App Store > Sandbox Account > Manage > Account Settings.

  3. Disable the Allow Purchases & Renewals setting. 

Disabling this setting causes in-app purchases to fail, and auto-renewable
subscriptions to not renew in the sandbox environment.

Note

This setting applies to all devices that the Sandbox Apple ID signs in to, and
to all active auto-renewable subscriptions belonging to that account.

This setting stays in a disabled state until you reenable it. Reenable it to
simulate a customer resolving a billing issue.

### Enable Billing Grace Period in the sandbox environment

To enable Billing Grace Period in the sandbox environment, log in to App Store
Connect, and do the following:

  1. From My Apps, select your app.

  2. In the sidebar under Features, click Subscriptions.

  3. In the Billing Grace Period section, click Set Up Billing Grace Period.

  4. Select a duration from the drop-down menu.

  5. Select whether to apply the grace period to all renewals or to only paid-to-paid renewals. For more information about the configurable settings, see Enable Billing Grace Period for auto-renewable subscriptions.

  6. Select Only Sandbox Environment to enable Billing Grace Period for testing only.

  7. Click Next.

  8. Click Confirm.

To test billing issues for subscriptions with Billing Grace Period, first,
purchase an auto-renewable subscription, and then configure the setting to
simulate billing issues (as described above in Configure the sandbox
environment to simulate billing issues).

### Test subscriptions that enter a billing retry state

Auto-renewable subscriptions expire and enter a billing retry state when a
subscription fails to auto-renew.

This test case assumes that Billing Grace Period is in a disabled state for
the sandbox enviroment. To test subscriptions entering a billing retry state:

  1. Successfully purchase an auto-renewable subscription in your app.

  2. Set the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues. 

  3. Wait for the subscription period to renew. The renewal fails, and it enters a billing retry state.

  4. Check that your app recognizes the state. Subscriptions in a billing retry state that aren't in a billing grace period are not entitled to service. StoreKit provides the `isInBillingRetry` value in the `Product.SubscriptionInfo.RenewalState` object.

### Test subscriptions that enter a billing grace period

Auto-renewable subscriptions enter a billing grace period when both of the
following occur:

  * Billing Grace Period is enabled for your app

  * The subscription fails to auto-renew

To test subscriptions entering a billing grace period:

  1. Follow the steps as described above in Enable Billing Grace Period in the sandbox environment.

  2. Successfully purchase an auto-renewable subscription in your app.

  3. Set the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues. 

  4. Wait for the subscription period to renew. The subscription enters the billing grace period.

  5. Check that your app recognizes the state and provides service for the subscription during the billing grace period. StoreKit provides the grace period expiration date in the `gracePeriodExpirationDate` property of the `Product.SubscriptionInfo.RenewalInfo` object.

  6. Wait for the billing grace period to expire. The subscription remains in the billing retry state. 

  7. Check that your app recognizes the billing retry state. Subscriptions aren’t entitled to service after the billing grace period expires.

Note

Auto-renewable subscriptions in a billing grace period state are entitled to
service.

### Test billing problem messaging after a subscription enters a billing retry
state

Auto-renewable subscriptions expire and enter a billing retry state when a
subscription fails to auto-renew. The system displays a Billing Problem
message when your app launches, unless your app chooses to delay the
`billingIssue` message. Use these steps to trigger the message and test how
your app responds to the message in various views. For more information about
managing these system messages, see `Message`.

To test when the system presents the Billing Problem sheet after subscriptions
enter the billing retry state:

  1. Successfully purchase an auto-renewable subscription in your app.

  2. Set the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues. 

  3. Wait for the subscription period to renew. The renewal fails, and enters a billing retry state.

  4. The App Store sends the `billingIssue` message. Launch the app or bring it to the foreground. 

  5. If your app doesn't implement `messages`, the system presents the Billing Problem sheet.

  6. If your app implements `messages` and delays the message, perform the steps your app requires for it to call `display(in:)`. As long as the billing issue is still active, the system presents the Billing Problem sheet. If you resolve the billing issue before the app calls `display(in:)`, the system doesn't present the sheet.

You may perform this test with or without Billing Grace Period enabled.

### Test subscriptions that recover from billing issues

A subscription is _recovered_ when a billing retry succeeds. It exits a
billing retry or billing grace period state, and is active again.

To test recovered auto-renewable subscriptions, follow these steps:

  1. Start with a subscription in the billing retry state, as described above in Test subscriptions that enter a billing retry state.

  2. Choose Settings > App Store > Sandbox Account > Manage > Account Settings, and enable the Allow Purchases & Renewals setting, which causes the next subscription renewal attempt to succeed.

  3. Check that your app recognizes the active subscription state, which is entitled to service.

Repeat the test starting with a subscription in the billing grace period, as
described above in Test subscriptions that enter a billing grace period.

The subscription billing cycle for a subscription that recovers from a billing
retry state starts on the recovery date. The billing cycle for a subscription
that recovers during a billing grace period doesn't change.

### Test subscriptions that don't recover from billing issues

Subscriptions exit a billing retry state when any of the following happens:

  * The billing retry period expires without recovering the subscription.

  * The customer cancels the subscription.

  * The subscription is recovered because billing succeeds.

To test subscriptions that expire and don't recover, follow these steps:

  1. Start with a subscription in a billing retry state, as described above in Test subscriptions that enter a billing retry state.

  2. Wait for the billing retry period to expire — don’t enable the Allow Purchases & Renewals setting. 

  3. Check that your app recognizes the subscription state. The subscription is inactive and not entitled to service.

To test a subscription that a customer cancels, follow these steps:

  1. Start with a subscription in a billing grace period, as described above in Test subscriptions that enter a billing grace period.

  2. Cancel the subscription by managing subscriptions in Settings, or by using your app’s implementation of `showManageSubscriptions(in:)`. For more information about managing subscriptions in Settings, see If you want to cancel a subscription from Apple.

  3. The system immediately cancels the subscription. 

  4. Check that your app recognizes the subscription state. The subscription is inactive and not entitled to service.

Repeat the test starting with a subscription in the billing retry state, as
described above in Test subscriptions that enter a billing retry state.

### Test a failed in-app purchase

To test a failed purchase attempt, follow these steps:

  1. Set the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues. 

  2. In your app, attempt to buy an in-app purchase product. The system displays an error message for the sandbox environment that shows the purchase failed. 

  3. To continue testing billing issues, select OK. Alternatively, to simulate a user resolving a billing issue, select Settings to return to Account Settings, where you can enable Allow Purchases & Renewals.

## See Also

### Payment transactions

Testing purchases made outside your app

Verify that your app receives and handles transactions that occur outside of
your app, such as subscription purchases, renewals, and offer and promo code
redemptions.

Testing an interrupted purchase

Verify that your app handles an interrupted purchase by inspecting and
invoking payment transactions.

Testing a payment request

Verify that requests for payment function properly in the sandbox environment
by inspecting the calls to the payment transaction observer.

Article

# Testing a payment request

Verify that requests for payment function properly in the sandbox environment
by inspecting the calls to the payment transaction observer.

## Overview

Create an instance of `SKPayment` using a valid product identifier that you’ve
already tested, as described in Testing fetching product identifiers. Set a
breakpoint and inspect the payment request. Add the payment request to the
transaction queue, and set a breakpoint to confirm that the system calls your
observer’s `paymentQueue(_:updatedTransactions:)` method.

Though you can finish the transaction immediately without providing the
content of the purchase during testing, failing to finish the transaction can
cause problems. Unfinished transactions remain in the queue indefinitely,
which could interfere with later testing. Complete the transaction as
described in Finishing a transaction at the end of each test.

## See Also

### Payment transactions

Testing purchases made outside your app

Verify that your app receives and handles transactions that occur outside of
your app, such as subscription purchases, renewals, and offer and promo code
redemptions.

Testing an interrupted purchase

Verify that your app handles an interrupted purchase by inspecting and
invoking payment transactions.

Testing failing subscription renewals and in-app purchases

Verify that your app handles failed subscription renewals that are in the
billing retry or billing grace period states, as well as failed in-app
purchases.

Article

# Testing an auto-renewable subscription

Verify that your app handles a subscription lapse properly using the
accelerated time rates within the sandbox environment.

## Overview

Auto-renewable subscriptions behave differently in the sandbox environment and
the production environment.

In the sandbox environment, subscription renewals happen at an accelerated
rate, and auto-renewable subscriptions renew up to 12 times after the initial
purchase. This enables you to test how your app handles a subscription
renewal, a subscription lapse, and a subscription history that includes gaps.

You can choose a subscription renewal speed for each Sandbox Apple ID account
in App Store Connect. For a complete list of subscription durations within the
sandbox environment and more information, see Manage Sandbox Apple ID
settings.

The accelerated expiration and renewal rates in the sandbox environment make
it possible for subscriptions to expire before the system tries to renew them.
When a subscription expires before the system tries to renew it, it results in
a short lapse in the subscription period. These lapses are possible in
production; verify that your app handles them appropriately.

## See Also

### Subscriptions

Testing resubscribing from the subscriptions page

Verify that your app can reactivate an expired subscription by receiving a
transaction callback or inspecting an updated receipt.

Testing disabling auto-renew

Verify that your app receives subscription updates when a user cancels a
subscription by verifying the receipt or receiving a notification.

Article

# Testing resubscribing from the subscriptions page

Verify that your app can reactivate an expired subscription by receiving a
transaction callback or inspecting an updated receipt.

## Overview

Customers can manage their active subscriptions, as well as their expired
subscriptions for up to a year after expiry, on the Subscriptions page in iOS,
tvOS, iPadOS, and macOS. From this page, customers can upgrade, downgrade,
cancel, or change the type of their subscriptions.

In this test scenario, the customer resubscribes to an expired subscription
from the Subscriptions page in the App Store.

### Set up testing

This test case requires one or more subscriptions configured in App Store
Connect and an expired subscription for your Sandbox Apple ID. If you don’t
already have an expired subscription, purchase an auto-renewable subscription
and let it expire.

### Begin testing

To test resubscribing from the Subscriptions page:

  1. On the test iOS device, open Settings > App Store. 

  2. In the Sandbox Account section, tap your highlighted Sandbox Apple ID, and tap Manage.

  3. On devices running iOS 16 or later, tap Subscriptions on the Account Settings sheet.

  4. In the sandbox Subscriptions page, select the expired subscription you want to reactivate. The subscription products that appear are those you configured in App Store Connect under the same subscription group.

  5. Select a subscription product to resubscribe to. 

  6. To complete the purchase, authenticate the payment sheet that appears.

  7. Open your app.

  8. In Xcode, verify that your `SKPaymentTransactionObserver` gets a callback on `paymentQueue(_:updatedTransactions:)` with a transaction in the `SKPaymentTransactionState.purchased` state.

  9. Check that your app retrieves and verifies the app receipt. Verify that the successful transaction is in the receipt.

  10. Check that your app makes the in-app purchase available and updates the subscriber’s status.

  11. In Xcode, check that your app calls `finishTransaction(_:)`. For more information, see Finishing a transaction.

### Conclude testing

This test case requires no cleanup. For auto-renewable subscriptions, you can
perform the test again when the subscription expires.

## See Also

### Subscriptions

Testing an auto-renewable subscription

Verify that your app handles a subscription lapse properly using the
accelerated time rates within the sandbox environment.

Testing disabling auto-renew

Verify that your app receives subscription updates when a user cancels a
subscription by verifying the receipt or receiving a notification.

Article

# Testing disabling auto-renew

Verify that your app receives subscription updates when a user cancels a
subscription by verifying the receipt or receiving a notification.

## Overview

Customers can manage their active subscriptions, as well as their expired
subscriptions for up to a year after expiry, in the Subscriptions page on iOS,
tvOS, iPadOS, and macOS. In this test scenario, the customer cancels a
subscription, which disables auto-renew.

To set up for this test, purchase an auto-renewable subscription for the
Sandbox Apple ID account.

### Begin testing

To test disabling auto-renew:

  1. On the test iOS device, open Settings > App Store. 

  2. In the Sandbox Account section, tap your highlighted Sandbox Apple ID, and tap Manage. 

  3. In the sandbox Subscriptions page, select the subscription product that you want to cancel. 

  4. Tap the Cancel Subscription button. 

Verify the change in the subscription status using either of these two
methods:

  * If you’ve configured App Store Connect settings to receive App Store server notifications, your server receives the `notification_type` `DID_CHANGE_RENEWAL_STATUS` each time the subscription’s auto-renew status changes. For more information, see Enabling App Store Server Notifications.

  * Verify the receipt by calling verifyReceipt with the latest receipt. Check that the `auto_renew_status` property of the `responseBody.Pending_renewal_info` object changes to `0`. The `auto_renew_status_change_date_ms` property of `responseBody` contains the timestamp of the change.

### Test reenabling the subscription renewal

After disabling auto-renew, reenable the subscription on the same Manage
Subscriptions page by tapping the subscription and confirming payment.

Verify the change in the subscription status using either of these two
methods:

  * If you’ve configured App Store Connect settings to receive App Store server notifications, your server receives the `notification_type` `DID_CHANGE_RENEWAL_STATUS` each time the subscription’s auto-renew status changes. For more information, see Enabling App Store Server Notifications.

  * Verify the receipt by calling verifyReceipt with the latest receipt. Check that the `auto_renew_status` property of the `responseBody.Pending_renewal_info` object changes to `1`. The `auto_renew_status_change_date_ms` property of `responseBody` contains the timestamp of the change.

## See Also

### Subscriptions

Testing an auto-renewable subscription

Verify that your app handles a subscription lapse properly using the
accelerated time rates within the sandbox environment.

Testing resubscribing from the subscriptions page

Verify that your app can reactivate an expired subscription by receiving a
transaction callback or inspecting an updated receipt.

Article

# Testing Family Sharing

Verify that your app handles auto-renewable subscriptions and non-consumable
in-app purchases that family members share with Family Sharing.

## Overview

Family Sharing lets people share access to auto-renewable subscriptions or
non-consumables that have Family Sharing enabled with up to five family
members. You can use Sandbox Test Families to test whether your app works with
Family Sharing as expected.

Note

Changes that you make to product metadata in App Store Connect can take up to
one hour to appear in the sandbox environment.

To test Family Sharing in your app:

  * Ensure your in-app purchases are set up to support Family Sharing. For more information, see Turn on Family Sharing for in-app purchases.

  * Create two or more Sandbox Apple IDs to add to a Sandbox Test Family, or use existing accounts. A family group can have up to six members. For more information, see Create Sandbox Apple IDs.

  * Create the Sandbox Test Family in App Store Connect. For more information, see Create a Sandbox Test Family.

  * To make testing easier, have a separate device to use for each test family member. You can also use a single device and sign in using each family member’s Sandbox Apple ID in turn.

### Manage sharing for the Sandbox Test Family

You can set the sharing status for each member of the Sandbox Test Family
individually, as follows:

  * _Sharing_ indicates the family member shares their in-app purchases with the Sandbox Test Family, and gets access to in-app purchases shared by family members.

  * _Not Sharing_ indicates the family member isn’t sharing, and doesn’t get access to family-shared purchases. Changing the setting to Not Sharing revokes any family-shared purchases they have access to. In the test environment, turning off sharing is the equivalent of a family member leaving the group.

Modify the sharing status on the Family Sharing page in iOS by following these
steps:

  1. Open Settings and select App Store.

  2. Select the Sandbox Apple ID.

  3. On the popup sheet, select Manage.

  4. On the Account Settings page, select Family Sharing.

  5. Select a family member.

  6. Select Stop Sharing Purchases or Start Sharing Purchases, as appropriate.

You can also change these settings in App Store Connect. For more information,
see Manage a Sandbox Test Family.

### Test sharing an in-app purchase in a family group

The two main test cases for Family Sharing are a family member gaining and
losing access to family-shared purchases. You can simulate these situations as
follows.

To test family members gaining access to a shared purchase:

  1. Start with a Sandbox Test Family where members are sharing.

  2. In your app, purchase a shareable product.

  3. Open your app on a device signed in with the Sandbox Apple ID of another test family member.

  4. Verify that your app receives a transaction for the shared purchase and unlocks the content for the family member. Note that the transaction has a `familyShared` ownership type.

  5. When sharing auto-renewable subscriptions, if you have App Store Server Notifications V2 enabled in the sandbox environment, your server receives a notification for each test family member that has sharing enabled. For more information, see the `SUBSCRIBED` `notificationType`.

### Test revoked access to shared in-app purchases

To test a family member losing access to shared purchases:

  1. Start with a Sandbox Test Family with two or more members, and at least one shared purchase.

  2. In Account Settings > Family Sharing, select a test family member that is receiving access to a shared in-app purchase.

  3. Select Stop Sharing Purchases, and Stop Sharing to confirm.

  4. The test family member loses accesses to shared purchases. Open your app using their Sandbox Apple ID and confirm that your app receives an updated transaction that includes a `revocationDate` and `revocationReason`.

  5. If you have App Store Server Notifications V2 enabled in the sandbox environment, your server receives a `REVOKE` `notificationType` for the test family member that has sharing disabled.

Note that you can also change the sharing status using App Store Connect
instead of Account Settings in iOS.

Article

# Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

## Overview

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests, which enable your customers to request a refund from within
your app. Your app displays the refund request sheet by calling any of these
methods: `beginRefundRequest(for:in:)` , `beginRefundRequest(in:)`,
`beginRefundRequest(for:in:)`, `beginRefundRequest(in:)`, or
`refundRequestSheet(for:isPresented:onDismiss:)`. Customers fill out the sheet
to submit the request.

Depending on your testing setup, the App Store automatically approves or
declines the refund request in the testing environment. Note that the App
Store doesn’t send emails for refund requests in testing environments.

### Test approved refunds

To set up a test for approved refunds, select any refund reason on the refund
request sheet, and submit the sheet. The App Store automatically approves the
refund request in the testing environment.

Your app receives a `Transaction` with refund information in the
`revocationDate` and `revocationReason` properties. If you’re testing in the
sandbox environment and your server receives App Store Server Notifications V2
for the sandbox, it gets a notification with a `REFUND` `notificationType`.

### Test declined refunds

To set up a test for declined refunds, follow these steps on the refund
request sheet with your app running in the sandbox environment:

  1. Under Issue, select Other.

  2. In the text box, type REJECT.

  3. Tap Request Refund.

The App Store automatically rejects the refund request in the testing
environment.

If your server receives App Store Server Notifications V2 for the sandbox
environment, it gets a notification with a `REFUND_DECLINED`
`notificationType`.

For more information on receiving server notifications for the sandbox
environment, see Enabling App Store Server Notifications. For more information
on testing, see Testing at all stages of development with Xcode and the
sandbox and Setting up StoreKit Testing in Xcode.

## See Also

### Testing in-app purchases

Testing at all stages of development with Xcode and the sandbox

Verify your implementation of in-app purchases by testing your code throughout
its development.

Testing in-app purchases with sandbox

Test your implementation of in-app purchases using real product information
and server-to-server transactions in the sandbox environment.

Article

# Testing App Store server notifications

Confirm that App Store Server Notifications service responds properly in the
sandbox environment.

## Overview

If you enabled notifications from the App Store for your app, test your logic
for transactions in the sandbox environment. To determine if a notification
for a subscription event occurred in the test environment, check whether the
value of the `environment` field equals `Sandbox` in the `data` object of the
App Store Server Notifications `responseBodyV2DecodedPayload` object.

For more information about the App Store Server Notifications service, see App
Store Server Notifications. To ask the App Store to send test notifications,
and to get a history of notifications sent to your server, see Request a Test
Notification and Get Notification History in the App Store Server API.

Article

# Testing transaction observer code

Verify that your app activates its payment transaction observer by using
breakpoints.

## Overview

Review the transaction observer’s implementation of the
`SKPaymentTransactionObserver` protocol. Verify that the
`SKPaymentTransactionObserver` listens for transactions when:

  * Your app isn’t displaying its store UI

  * If you didn’t recently initiate a purchase

Locate the call to the `add(_:)` method of `SKPaymentQueue` in your code.
Verify that your app calls this method at app launch. For more information,
see Setting up the transaction observer for the payment queue.

## See Also

### Transaction observer

Testing a successful transaction

Confirm that your app can make a successful transaction in the sandbox
environment by inspecting the transaction.

Testing complete transactions

Verify that your app completes transactions properly by confirming that any
downloadable purchases are present on your test device.

Article

# Testing a successful transaction

Confirm that your app can make a successful transaction in the sandbox
environment by inspecting the transaction.

## Overview

Set a breakpoint in your implementation of the transaction queue observer’s
`paymentQueue(_:updatedTransactions:)` method. Then sign in to the App Store
with a Sandbox Apple ID, and make a purchase in your app. Inspect the
transaction to verify that its status is
`SKPaymentTransactionState.purchased`.

Set a breakpoint at the point in your code where your app stores the purchase,
and confirm that your code saves the data in response to a successful
purchase. Inspect the user default or iCloud key-value store, to verify that
your code correctly records the information. For more information on saving
data in response to a successful purchase, see Persisting a purchase.

## See Also

### Transaction observer

Testing transaction observer code

Verify that your app activates its payment transaction observer by using
breakpoints.

Testing complete transactions

Verify that your app completes transactions properly by confirming that any
downloadable purchases are present on your test device.

Article

# Testing complete transactions

Verify that your app completes transactions properly by confirming that any
downloadable purchases are present on your test device.

## Overview

Locate where your app calls the `finishTransaction(_:)` method, and verify
that your app completes all work related to the transaction before calling the
method. For example, if the purchase includes downloadable content, verify
your app downloaded the content to your test device as described in Persisting
a purchase. Verify that you call `finishTransaction(_:)` for every
transaction, whether it succeeded or failed. For more information, see
Finishing a transaction.

## See Also

### Transaction observer

Testing transaction observer code

Verify that your app activates its payment transaction observer by using
breakpoints.

Testing a successful transaction

Confirm that your app can make a successful transaction in the sandbox
environment by inspecting the transaction.

Article

# Testing fetching product identifiers

Verify that your app receives the correct product identifiers by inspecting or
replicating your app’s process for retrieving the identifiers.

## Overview

If you embed your product identifiers in your app, set a breakpoint in your
code after the code loads the identifiers. Verify that the instance of
`NSArray` contains your expected list of product identifiers.

Note

Changes that you make to product metadata in App Store Connect can take up to
one hour to appear in the sandbox environment.

If your app fetches your product identifiers from a server, manually fetch the
JSON file using a web browser such as Safari, or a command-line utility such
as `curl`. Verify that the data your server returns contains the expected list
of product identifiers and that your server correctly implements standard HTTP
caching mechanisms.

For more information on fetching product identifiers, see Loading in-app
product identifiers.

## See Also

### Product identifiers and requests

Testing invalid product identifier handling

Verify that your app correctly handles invalid product identifiers.

Testing a product request

Verify that requests for products function properly in the sandbox environment
by inspecting the App Store response.

Article

# Testing invalid product identifier handling

Verify that your app correctly handles invalid product identifiers.

## Overview

Intentionally include an invalid identifier in your app’s list of product
identifiers. Then do one of the following:

  * In a production build, verify that the app displays the rest of its store UI and that users can purchase the valid products.

  * In a development build, verify that the app brings the issue to your attention.

Check the console log and verify that you can correctly identify the invalid
product identifier. Make sure you remove it after testing.

For more information on fetching product identifiers, see Loading in-app
product identifiers.

## See Also

### Product identifiers and requests

Testing fetching product identifiers

Verify that your app receives the correct product identifiers by inspecting or
replicating your app’s process for retrieving the identifiers.

Testing a product request

Verify that requests for products function properly in the sandbox environment
by inspecting the App Store response.

Article

# Testing a product request

Verify that requests for products function properly in the sandbox environment
by inspecting the App Store response.

## Overview

After setting a breakpoint in your code, use the list of product identifiers
that you tested in Testing fetching product identifiers to create and submit
an instance of `SKProductsRequest`. Then inspect the lists of valid and
invalid product identifiers. If there are invalid product identifiers, review
your products in App Store Connect and correct your JSON file or property
list.

Note

Changes that you make to product metadata in App Store Connect can take up to
one hour to appear in the sandbox environment.

See Testing invalid product identifier handling for more information.

## See Also

### Product identifiers and requests

Testing fetching product identifiers

Verify that your app receives the correct product identifiers by inspecting or
replicating your app’s process for retrieving the identifiers.

Testing invalid product identifier handling

Verify that your app correctly handles invalid product identifiers.

Article

# Testing purchases made outside your app

Verify that your app receives and handles transactions that occur outside of
your app, such as subscription purchases, renewals, and offer and promo code
redemptions.

## Overview

When your app offers in-app purchases, customers typically buy the products
from within your app. However, purchase transactions can also occur on another
device or even outside your app. Your app needs to handle these transactions
when it launches. Use the Test Transactions feature in Account Settings in iOS
to simulate and test such transactions in the sandbox environment.

### Simulate a variety of purchase events

Several types of events result in a purchase transaction that occurs outside
your app, including the following:

Redeeming offer codes

    

People can redeem offer codes on the Redeem Gift Card or Code page in their
App Store account settings, by using a redemption URL, and when your app calls
`presentCodeRedemptionSheet()`. For more information, see Set up offer codes.

Redeeming a promo code for an in-app purchase

    

People can redeem a promo codes in the App Store. For more information, see
Request and manage promo codes.

Renewing an auto-renewable subscription

    

Apple bills customers when an auto-renewable subscription renews, and the
renewal transaction occurs outside your app.

Resubscribing from the Apple Subscriptions page

    

People can resubscribe to expired subscriptions from their Account >
Subscriptions page in the App Store.

All of these events result in StoreKit sending a transaction to your app
through the `updates` asynchronous sequence in `Transaction`. Test your app to
be sure it handles the transaction.

### Set up and perform a test

To create a transaction outside your app for the testing environment, first
open Account Settings on the iOS device, as follows:

  1. Open Settings and select App Store.

  2. Select the Sandbox Apple ID. 

  3. Select Manage on the popup sheet. The Account Settings page appears.

Next, you need the product ID for a product you set up in App Store Connect,
and your app’s bundle ID.

Note

Changes that you make to product metadata in App Store Connect can take up to
one hour to appear in the sandbox environment.

To simulate a purchase outside your app, follow these steps:

  1. On the Account Settings page, select Test Transactions.

  2. Enter your product ID and the bundle ID in the text boxes labeled Product ID and Bundle ID, respectively.

  3. Click Next.

  4. The system brings up the payment sheet for the sandbox environment, which is labeled with "App Store [Sandbox]". Confirm the purchase. Note: The sandbox environment doesn’t process actual payments. Instead, it returns transactions as if payments were processed successfully.

After you confirm the purchase, use the following steps to test your app:

  1. Open your app. The system delivers the new transaction to your app through the `updates` asynchronous sequence in `Transaction`.

  2. Confirm that your app receives and processes the transaction to provide access to the purchased product.

### Conclude or restart a test

You can repeat the test by purchasing the product again through the Test
Transactions feature in Account Settings. To repurchase some products you
might first need to clear the transactions for the Sandbox Apple ID, following
these steps:

  1. Open Settings and select App Store.

  2. Select the Sandbox Apple ID.

  3. Select Manage on the popup sheet.

  4. On the Account Settings page, select Clear Purchase History.

Restart your app. The purchase history for the Sandbox Apple ID will be empty
and ready for testing. Clearing the purchase history for Sandbox Apple IDs
with a high number of purchases may take longer.

## See Also

### Payment transactions

Testing an interrupted purchase

Verify that your app handles an interrupted purchase by inspecting and
invoking payment transactions.

Testing failing subscription renewals and in-app purchases

Verify that your app handles failed subscription renewals that are in the
billing retry or billing grace period states, as well as failed in-app
purchases.

Testing a payment request

Verify that requests for payment function properly in the sandbox environment
by inspecting the calls to the payment transaction observer.

Article

# Testing an interrupted purchase

Verify that your app handles an interrupted purchase by inspecting and
invoking payment transactions.

## Overview

An interrupted purchase is a transaction that requires the user to perform
some action outside of your app before completing their transaction. For
example, the user may need to update their payment method or accept new terms
and conditions before continuing with their transaction.

In sandbox testing, you can simulate an interrupted purchase by turning on the
interrupted purchase feature in App Store Connect for a tester Sandbox Apple
ID. This interrupts all purchase attempts by that Sandbox Apple ID until you
agree to the updated terms and conditions on the iOS device, or until you turn
off the feature in App Store Connect. To learn how to set up interrupted
purchase testing, see Enable interrupted purchases for a Sandbox Apple ID.

### Set up testing

To enable interrupted purchases for the Sandbox Apple ID, log in to App Store
Connect, and do the following:

  1. From Users and Access, open the Users and Access Panel in the sidebar, under the Sandbox header, select Testers. On the right, you can view your Sandbox Apple IDs.

  2. Select a Sandbox Apple ID to use for testing interrupted purchases. If it’s already enabled, you’ll see a checkmark under the Interrupted Purchases column.

  3. In the dialog that appears, select Interrupt Purchases for This Tester.

### Begin testing

After setting up interrupted purchase testing in App Store Connect, use the
following steps to test your app:

  1. On the test device, sign in with the Sandbox Apple ID that has interrupted purchases enabled.

  2. In your app, select Buy or Subscribe to make an in-app purchase. 

  3. Observe that the system displays a payment sheet.

  4. In Xcode, verify that the payment queue receives a new transaction in the state `SKPaymentTransactionState.purchasing`.

  5. On the device, authenticate the payment sheet.

  6. In Xcode, observe that the payment fails. The payment queue receives an updated transaction in the state `SKPaymentTransactionState.failed`.

  7. Check that your code calls `finishTransaction(_:)` to remove it from the queue.

  8. On the device, observe that the system displays Terms & Conditions, interrupting the purchase (because you configured the sandbox environment to do so).

  9. On the device, tap to agree to the Terms & Conditions.

  10. In Xcode, verify that the payment queue receives a new transaction in the `SKPaymentTransactionState.purchased` state for the same `productIdentifier` and in the same quantity as the failed transaction.

  11. In Xcode, validate the receipt. Check that your app provides the service or the product, and calls `finishTransaction(_:)`.

  12. On the device, the user should observe a successful purchase.

### Conclude testing

The Sandbox Apple ID continues to experience interrupted purchases until you
disable it in App Store Connect, or until the user agrees to the terms and
conditions on the device. To disable interrupted purchases in App Store
Connect, deselect Interrupt Purchases for This Tester. For more information,
see Enable interrupted purchases for a Sandbox Apple ID.

## See Also

### Payment transactions

Testing purchases made outside your app

Verify that your app receives and handles transactions that occur outside of
your app, such as subscription purchases, renewals, and offer and promo code
redemptions.

Testing failing subscription renewals and in-app purchases

Verify that your app handles failed subscription renewals that are in the
billing retry or billing grace period states, as well as failed in-app
purchases.

Testing a payment request

Verify that requests for payment function properly in the sandbox environment
by inspecting the calls to the payment transaction observer.

Article

# Testing failing subscription renewals and in-app purchases

Verify that your app handles failed subscription renewals that are in the
billing retry or billing grace period states, as well as failed in-app
purchases.

## Overview

Payments can fail unexpectedly at any stage of the billing cycle, such as when
a payment card expires. Test your app’s user experience to ensure it handles
these unexpected events, and provides appropriate levels of service when
billing issues occur.

In sandbox testing, you can simulate billing issues that cause in-app
purchases to fail, and auto-renewable subscriptions not to renew. You can also
enable Billing Grace Period for the sandbox environment. Use these sandbox
features to test how your app handles auto-renewable subscriptions with
billing issues that do or don’t recover.

The sandbox environment sends App Store Server Notifications as you perform
tests. For more information, see Enabling App Store Server Notifications.

The sandbox environment renews auto-renewable subscriptions up to 12 times.
For more information about renewal rates in the sandbox environment, see Edit
subscription renewal speed.

For more information about subscription state changes when billing issues
occur, see Reducing Involuntary Subscriber Churn. For information about how
apps determine access to subscription content, see Handling Subscriptions
Billing.

### Configure the sandbox environment to simulate billing issues

Follow these steps on a test device running iOS 16 or iPadOS 16, or later:

  1. Sign in to the App Store using a Sandbox Apple ID.

  2. Choose Settings > App Store > Sandbox Account > Manage > Account Settings.

  3. Disable the Allow Purchases & Renewals setting. 

Disabling this setting causes in-app purchases to fail, and auto-renewable
subscriptions to not renew in the sandbox environment.

Note

This setting applies to all devices that the Sandbox Apple ID signs in to, and
to all active auto-renewable subscriptions belonging to that account.

This setting stays in a disabled state until you reenable it. Reenable it to
simulate a customer resolving a billing issue.

### Enable Billing Grace Period in the sandbox environment

To enable Billing Grace Period in the sandbox environment, log in to App Store
Connect, and do the following:

  1. From My Apps, select your app.

  2. In the sidebar under Features, click Subscriptions.

  3. In the Billing Grace Period section, click Set Up Billing Grace Period.

  4. Select a duration from the drop-down menu.

  5. Select whether to apply the grace period to all renewals or to only paid-to-paid renewals. For more information about the configurable settings, see Enable Billing Grace Period for auto-renewable subscriptions.

  6. Select Only Sandbox Environment to enable Billing Grace Period for testing only.

  7. Click Next.

  8. Click Confirm.

To test billing issues for subscriptions with Billing Grace Period, first,
purchase an auto-renewable subscription, and then configure the setting to
simulate billing issues (as described above in Configure the sandbox
environment to simulate billing issues).

### Test subscriptions that enter a billing retry state

Auto-renewable subscriptions expire and enter a billing retry state when a
subscription fails to auto-renew.

This test case assumes that Billing Grace Period is in a disabled state for
the sandbox enviroment. To test subscriptions entering a billing retry state:

  1. Successfully purchase an auto-renewable subscription in your app.

  2. Set the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues. 

  3. Wait for the subscription period to renew. The renewal fails, and it enters a billing retry state.

  4. Check that your app recognizes the state. Subscriptions in a billing retry state that aren't in a billing grace period are not entitled to service. StoreKit provides the `isInBillingRetry` value in the `Product.SubscriptionInfo.RenewalState` object.

### Test subscriptions that enter a billing grace period

Auto-renewable subscriptions enter a billing grace period when both of the
following occur:

  * Billing Grace Period is enabled for your app

  * The subscription fails to auto-renew

To test subscriptions entering a billing grace period:

  1. Follow the steps as described above in Enable Billing Grace Period in the sandbox environment.

  2. Successfully purchase an auto-renewable subscription in your app.

  3. Set the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues. 

  4. Wait for the subscription period to renew. The subscription enters the billing grace period.

  5. Check that your app recognizes the state and provides service for the subscription during the billing grace period. StoreKit provides the grace period expiration date in the `gracePeriodExpirationDate` property of the `Product.SubscriptionInfo.RenewalInfo` object.

  6. Wait for the billing grace period to expire. The subscription remains in the billing retry state. 

  7. Check that your app recognizes the billing retry state. Subscriptions aren’t entitled to service after the billing grace period expires.

Note

Auto-renewable subscriptions in a billing grace period state are entitled to
service.

### Test billing problem messaging after a subscription enters a billing retry
state

Auto-renewable subscriptions expire and enter a billing retry state when a
subscription fails to auto-renew. The system displays a Billing Problem
message when your app launches, unless your app chooses to delay the
`billingIssue` message. Use these steps to trigger the message and test how
your app responds to the message in various views. For more information about
managing these system messages, see `Message`.

To test when the system presents the Billing Problem sheet after subscriptions
enter the billing retry state:

  1. Successfully purchase an auto-renewable subscription in your app.

  2. Set the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues. 

  3. Wait for the subscription period to renew. The renewal fails, and enters a billing retry state.

  4. The App Store sends the `billingIssue` message. Launch the app or bring it to the foreground. 

  5. If your app doesn't implement `messages`, the system presents the Billing Problem sheet.

  6. If your app implements `messages` and delays the message, perform the steps your app requires for it to call `display(in:)`. As long as the billing issue is still active, the system presents the Billing Problem sheet. If you resolve the billing issue before the app calls `display(in:)`, the system doesn't present the sheet.

You may perform this test with or without Billing Grace Period enabled.

### Test subscriptions that recover from billing issues

A subscription is _recovered_ when a billing retry succeeds. It exits a
billing retry or billing grace period state, and is active again.

To test recovered auto-renewable subscriptions, follow these steps:

  1. Start with a subscription in the billing retry state, as described above in Test subscriptions that enter a billing retry state.

  2. Choose Settings > App Store > Sandbox Account > Manage > Account Settings, and enable the Allow Purchases & Renewals setting, which causes the next subscription renewal attempt to succeed.

  3. Check that your app recognizes the active subscription state, which is entitled to service.

Repeat the test starting with a subscription in the billing grace period, as
described above in Test subscriptions that enter a billing grace period.

The subscription billing cycle for a subscription that recovers from a billing
retry state starts on the recovery date. The billing cycle for a subscription
that recovers during a billing grace period doesn't change.

### Test subscriptions that don't recover from billing issues

Subscriptions exit a billing retry state when any of the following happens:

  * The billing retry period expires without recovering the subscription.

  * The customer cancels the subscription.

  * The subscription is recovered because billing succeeds.

To test subscriptions that expire and don't recover, follow these steps:

  1. Start with a subscription in a billing retry state, as described above in Test subscriptions that enter a billing retry state.

  2. Wait for the billing retry period to expire — don’t enable the Allow Purchases & Renewals setting. 

  3. Check that your app recognizes the subscription state. The subscription is inactive and not entitled to service.

To test a subscription that a customer cancels, follow these steps:

  1. Start with a subscription in a billing grace period, as described above in Test subscriptions that enter a billing grace period.

  2. Cancel the subscription by managing subscriptions in Settings, or by using your app’s implementation of `showManageSubscriptions(in:)`. For more information about managing subscriptions in Settings, see If you want to cancel a subscription from Apple.

  3. The system immediately cancels the subscription. 

  4. Check that your app recognizes the subscription state. The subscription is inactive and not entitled to service.

Repeat the test starting with a subscription in the billing retry state, as
described above in Test subscriptions that enter a billing retry state.

### Test a failed in-app purchase

To test a failed purchase attempt, follow these steps:

  1. Set the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues. 

  2. In your app, attempt to buy an in-app purchase product. The system displays an error message for the sandbox environment that shows the purchase failed. 

  3. To continue testing billing issues, select OK. Alternatively, to simulate a user resolving a billing issue, select Settings to return to Account Settings, where you can enable Allow Purchases & Renewals.

## See Also

### Payment transactions

Testing purchases made outside your app

Verify that your app receives and handles transactions that occur outside of
your app, such as subscription purchases, renewals, and offer and promo code
redemptions.

Testing an interrupted purchase

Verify that your app handles an interrupted purchase by inspecting and
invoking payment transactions.

Testing a payment request

Verify that requests for payment function properly in the sandbox environment
by inspecting the calls to the payment transaction observer.

Article

# Testing a payment request

Verify that requests for payment function properly in the sandbox environment
by inspecting the calls to the payment transaction observer.

## Overview

Create an instance of `SKPayment` using a valid product identifier that you’ve
already tested, as described in Testing fetching product identifiers. Set a
breakpoint and inspect the payment request. Add the payment request to the
transaction queue, and set a breakpoint to confirm that the system calls your
observer’s `paymentQueue(_:updatedTransactions:)` method.

Though you can finish the transaction immediately without providing the
content of the purchase during testing, failing to finish the transaction can
cause problems. Unfinished transactions remain in the queue indefinitely,
which could interfere with later testing. Complete the transaction as
described in Finishing a transaction at the end of each test.

## See Also

### Payment transactions

Testing purchases made outside your app

Verify that your app receives and handles transactions that occur outside of
your app, such as subscription purchases, renewals, and offer and promo code
redemptions.

Testing an interrupted purchase

Verify that your app handles an interrupted purchase by inspecting and
invoking payment transactions.

Testing failing subscription renewals and in-app purchases

Verify that your app handles failed subscription renewals that are in the
billing retry or billing grace period states, as well as failed in-app
purchases.

Article

# Testing an auto-renewable subscription

Verify that your app handles a subscription lapse properly using the
accelerated time rates within the sandbox environment.

## Overview

Auto-renewable subscriptions behave differently in the sandbox environment and
the production environment.

In the sandbox environment, subscription renewals happen at an accelerated
rate, and auto-renewable subscriptions renew up to 12 times after the initial
purchase. This enables you to test how your app handles a subscription
renewal, a subscription lapse, and a subscription history that includes gaps.

You can choose a subscription renewal speed for each Sandbox Apple ID account
in App Store Connect. For a complete list of subscription durations within the
sandbox environment and more information, see Manage Sandbox Apple ID
settings.

The accelerated expiration and renewal rates in the sandbox environment make
it possible for subscriptions to expire before the system tries to renew them.
When a subscription expires before the system tries to renew it, it results in
a short lapse in the subscription period. These lapses are possible in
production; verify that your app handles them appropriately.

## See Also

### Subscriptions

Testing resubscribing from the subscriptions page

Verify that your app can reactivate an expired subscription by receiving a
transaction callback or inspecting an updated receipt.

Testing disabling auto-renew

Verify that your app receives subscription updates when a user cancels a
subscription by verifying the receipt or receiving a notification.

Article

# Testing resubscribing from the subscriptions page

Verify that your app can reactivate an expired subscription by receiving a
transaction callback or inspecting an updated receipt.

## Overview

Customers can manage their active subscriptions, as well as their expired
subscriptions for up to a year after expiry, on the Subscriptions page in iOS,
tvOS, iPadOS, and macOS. From this page, customers can upgrade, downgrade,
cancel, or change the type of their subscriptions.

In this test scenario, the customer resubscribes to an expired subscription
from the Subscriptions page in the App Store.

### Set up testing

This test case requires one or more subscriptions configured in App Store
Connect and an expired subscription for your Sandbox Apple ID. If you don’t
already have an expired subscription, purchase an auto-renewable subscription
and let it expire.

### Begin testing

To test resubscribing from the Subscriptions page:

  1. On the test iOS device, open Settings > App Store. 

  2. In the Sandbox Account section, tap your highlighted Sandbox Apple ID, and tap Manage.

  3. On devices running iOS 16 or later, tap Subscriptions on the Account Settings sheet.

  4. In the sandbox Subscriptions page, select the expired subscription you want to reactivate. The subscription products that appear are those you configured in App Store Connect under the same subscription group.

  5. Select a subscription product to resubscribe to. 

  6. To complete the purchase, authenticate the payment sheet that appears.

  7. Open your app.

  8. In Xcode, verify that your `SKPaymentTransactionObserver` gets a callback on `paymentQueue(_:updatedTransactions:)` with a transaction in the `SKPaymentTransactionState.purchased` state.

  9. Check that your app retrieves and verifies the app receipt. Verify that the successful transaction is in the receipt.

  10. Check that your app makes the in-app purchase available and updates the subscriber’s status.

  11. In Xcode, check that your app calls `finishTransaction(_:)`. For more information, see Finishing a transaction.

### Conclude testing

This test case requires no cleanup. For auto-renewable subscriptions, you can
perform the test again when the subscription expires.

## See Also

### Subscriptions

Testing an auto-renewable subscription

Verify that your app handles a subscription lapse properly using the
accelerated time rates within the sandbox environment.

Testing disabling auto-renew

Verify that your app receives subscription updates when a user cancels a
subscription by verifying the receipt or receiving a notification.

Article

# Testing disabling auto-renew

Verify that your app receives subscription updates when a user cancels a
subscription by verifying the receipt or receiving a notification.

## Overview

Customers can manage their active subscriptions, as well as their expired
subscriptions for up to a year after expiry, in the Subscriptions page on iOS,
tvOS, iPadOS, and macOS. In this test scenario, the customer cancels a
subscription, which disables auto-renew.

To set up for this test, purchase an auto-renewable subscription for the
Sandbox Apple ID account.

### Begin testing

To test disabling auto-renew:

  1. On the test iOS device, open Settings > App Store. 

  2. In the Sandbox Account section, tap your highlighted Sandbox Apple ID, and tap Manage. 

  3. In the sandbox Subscriptions page, select the subscription product that you want to cancel. 

  4. Tap the Cancel Subscription button. 

Verify the change in the subscription status using either of these two
methods:

  * If you’ve configured App Store Connect settings to receive App Store server notifications, your server receives the `notification_type` `DID_CHANGE_RENEWAL_STATUS` each time the subscription’s auto-renew status changes. For more information, see Enabling App Store Server Notifications.

  * Verify the receipt by calling verifyReceipt with the latest receipt. Check that the `auto_renew_status` property of the `responseBody.Pending_renewal_info` object changes to `0`. The `auto_renew_status_change_date_ms` property of `responseBody` contains the timestamp of the change.

### Test reenabling the subscription renewal

After disabling auto-renew, reenable the subscription on the same Manage
Subscriptions page by tapping the subscription and confirming payment.

Verify the change in the subscription status using either of these two
methods:

  * If you’ve configured App Store Connect settings to receive App Store server notifications, your server receives the `notification_type` `DID_CHANGE_RENEWAL_STATUS` each time the subscription’s auto-renew status changes. For more information, see Enabling App Store Server Notifications.

  * Verify the receipt by calling verifyReceipt with the latest receipt. Check that the `auto_renew_status` property of the `responseBody.Pending_renewal_info` object changes to `1`. The `auto_renew_status_change_date_ms` property of `responseBody` contains the timestamp of the change.

## See Also

### Subscriptions

Testing an auto-renewable subscription

Verify that your app handles a subscription lapse properly using the
accelerated time rates within the sandbox environment.

Testing resubscribing from the subscriptions page

Verify that your app can reactivate an expired subscription by receiving a
transaction callback or inspecting an updated receipt.

Article

# Testing Family Sharing

Verify that your app handles auto-renewable subscriptions and non-consumable
in-app purchases that family members share with Family Sharing.

## Overview

Family Sharing lets people share access to auto-renewable subscriptions or
non-consumables that have Family Sharing enabled with up to five family
members. You can use Sandbox Test Families to test whether your app works with
Family Sharing as expected.

Note

Changes that you make to product metadata in App Store Connect can take up to
one hour to appear in the sandbox environment.

To test Family Sharing in your app:

  * Ensure your in-app purchases are set up to support Family Sharing. For more information, see Turn on Family Sharing for in-app purchases.

  * Create two or more Sandbox Apple IDs to add to a Sandbox Test Family, or use existing accounts. A family group can have up to six members. For more information, see Create Sandbox Apple IDs.

  * Create the Sandbox Test Family in App Store Connect. For more information, see Create a Sandbox Test Family.

  * To make testing easier, have a separate device to use for each test family member. You can also use a single device and sign in using each family member’s Sandbox Apple ID in turn.

### Manage sharing for the Sandbox Test Family

You can set the sharing status for each member of the Sandbox Test Family
individually, as follows:

  * _Sharing_ indicates the family member shares their in-app purchases with the Sandbox Test Family, and gets access to in-app purchases shared by family members.

  * _Not Sharing_ indicates the family member isn’t sharing, and doesn’t get access to family-shared purchases. Changing the setting to Not Sharing revokes any family-shared purchases they have access to. In the test environment, turning off sharing is the equivalent of a family member leaving the group.

Modify the sharing status on the Family Sharing page in iOS by following these
steps:

  1. Open Settings and select App Store.

  2. Select the Sandbox Apple ID.

  3. On the popup sheet, select Manage.

  4. On the Account Settings page, select Family Sharing.

  5. Select a family member.

  6. Select Stop Sharing Purchases or Start Sharing Purchases, as appropriate.

You can also change these settings in App Store Connect. For more information,
see Manage a Sandbox Test Family.

### Test sharing an in-app purchase in a family group

The two main test cases for Family Sharing are a family member gaining and
losing access to family-shared purchases. You can simulate these situations as
follows.

To test family members gaining access to a shared purchase:

  1. Start with a Sandbox Test Family where members are sharing.

  2. In your app, purchase a shareable product.

  3. Open your app on a device signed in with the Sandbox Apple ID of another test family member.

  4. Verify that your app receives a transaction for the shared purchase and unlocks the content for the family member. Note that the transaction has a `familyShared` ownership type.

  5. When sharing auto-renewable subscriptions, if you have App Store Server Notifications V2 enabled in the sandbox environment, your server receives a notification for each test family member that has sharing enabled. For more information, see the `SUBSCRIBED` `notificationType`.

### Test revoked access to shared in-app purchases

To test a family member losing access to shared purchases:

  1. Start with a Sandbox Test Family with two or more members, and at least one shared purchase.

  2. In Account Settings > Family Sharing, select a test family member that is receiving access to a shared in-app purchase.

  3. Select Stop Sharing Purchases, and Stop Sharing to confirm.

  4. The test family member loses accesses to shared purchases. Open your app using their Sandbox Apple ID and confirm that your app receives an updated transaction that includes a `revocationDate` and `revocationReason`.

  5. If you have App Store Server Notifications V2 enabled in the sandbox environment, your server receives a `REVOKE` `notificationType` for the test family member that has sharing disabled.

Note that you can also change the sharing status using App Store Connect
instead of Account Settings in iOS.

Article

# Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

## Overview

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests, which enable your customers to request a refund from within
your app. Your app displays the refund request sheet by calling any of these
methods: `beginRefundRequest(for:in:)` , `beginRefundRequest(in:)`,
`beginRefundRequest(for:in:)`, `beginRefundRequest(in:)`, or
`refundRequestSheet(for:isPresented:onDismiss:)`. Customers fill out the sheet
to submit the request.

Depending on your testing setup, the App Store automatically approves or
declines the refund request in the testing environment. Note that the App
Store doesn’t send emails for refund requests in testing environments.

### Test approved refunds

To set up a test for approved refunds, select any refund reason on the refund
request sheet, and submit the sheet. The App Store automatically approves the
refund request in the testing environment.

Your app receives a `Transaction` with refund information in the
`revocationDate` and `revocationReason` properties. If you’re testing in the
sandbox environment and your server receives App Store Server Notifications V2
for the sandbox, it gets a notification with a `REFUND` `notificationType`.

### Test declined refunds

To set up a test for declined refunds, follow these steps on the refund
request sheet with your app running in the sandbox environment:

  1. Under Issue, select Other.

  2. In the text box, type REJECT.

  3. Tap Request Refund.

The App Store automatically rejects the refund request in the testing
environment.

If your server receives App Store Server Notifications V2 for the sandbox
environment, it gets a notification with a `REFUND_DECLINED`
`notificationType`.

For more information on receiving server notifications for the sandbox
environment, see Enabling App Store Server Notifications. For more information
on testing, see Testing at all stages of development with Xcode and the
sandbox and Setting up StoreKit Testing in Xcode.

## See Also

### Testing in-app purchases

Testing at all stages of development with Xcode and the sandbox

Verify your implementation of in-app purchases by testing your code throughout
its development.

Testing in-app purchases with sandbox

Test your implementation of in-app purchases using real product information
and server-to-server transactions in the sandbox environment.

Article

# Testing App Store server notifications

Confirm that App Store Server Notifications service responds properly in the
sandbox environment.

## Overview

If you enabled notifications from the App Store for your app, test your logic
for transactions in the sandbox environment. To determine if a notification
for a subscription event occurred in the test environment, check whether the
value of the `environment` field equals `Sandbox` in the `data` object of the
App Store Server Notifications `responseBodyV2DecodedPayload` object.

For more information about the App Store Server Notifications service, see App
Store Server Notifications. To ask the App Store to send test notifications,
and to get a history of notifications sent to your server, see Request a Test
Notification and Get Notification History in the App Store Server API.

Article

# Testing transaction observer code

Verify that your app activates its payment transaction observer by using
breakpoints.

## Overview

Review the transaction observer’s implementation of the
`SKPaymentTransactionObserver` protocol. Verify that the
`SKPaymentTransactionObserver` listens for transactions when:

  * Your app isn’t displaying its store UI

  * If you didn’t recently initiate a purchase

Locate the call to the `add(_:)` method of `SKPaymentQueue` in your code.
Verify that your app calls this method at app launch. For more information,
see Setting up the transaction observer for the payment queue.

## See Also

### Transaction observer

Testing a successful transaction

Confirm that your app can make a successful transaction in the sandbox
environment by inspecting the transaction.

Testing complete transactions

Verify that your app completes transactions properly by confirming that any
downloadable purchases are present on your test device.

Article

# Testing a successful transaction

Confirm that your app can make a successful transaction in the sandbox
environment by inspecting the transaction.

## Overview

Set a breakpoint in your implementation of the transaction queue observer’s
`paymentQueue(_:updatedTransactions:)` method. Then sign in to the App Store
with a Sandbox Apple ID, and make a purchase in your app. Inspect the
transaction to verify that its status is
`SKPaymentTransactionState.purchased`.

Set a breakpoint at the point in your code where your app stores the purchase,
and confirm that your code saves the data in response to a successful
purchase. Inspect the user default or iCloud key-value store, to verify that
your code correctly records the information. For more information on saving
data in response to a successful purchase, see Persisting a purchase.

## See Also

### Transaction observer

Testing transaction observer code

Verify that your app activates its payment transaction observer by using
breakpoints.

Testing complete transactions

Verify that your app completes transactions properly by confirming that any
downloadable purchases are present on your test device.

Article

# Testing complete transactions

Verify that your app completes transactions properly by confirming that any
downloadable purchases are present on your test device.

## Overview

Locate where your app calls the `finishTransaction(_:)` method, and verify
that your app completes all work related to the transaction before calling the
method. For example, if the purchase includes downloadable content, verify
your app downloaded the content to your test device as described in Persisting
a purchase. Verify that you call `finishTransaction(_:)` for every
transaction, whether it succeeded or failed. For more information, see
Finishing a transaction.

## See Also

### Transaction observer

Testing transaction observer code

Verify that your app activates its payment transaction observer by using
breakpoints.

Testing a successful transaction

Confirm that your app can make a successful transaction in the sandbox
environment by inspecting the transaction.



# Operators 

Operator

# ...(_:)

Returns a partial range extending upward from a lower bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    postfix static func ... (minimum: Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

## Discussion

Use the postfix range operator (postfix `...`) to create a partial range of
any type that conforms to the `Comparable` protocol. This example creates a
`PartialRangeFrom<Double>` instance that includes any value greater than or
equal to `5.0`.

You can use this type of partial range of a collection’s indices to represent
the range from the partial range’s lower bound up to the end of the
collection.

Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ...(_:)

Returns a partial range up to, and including, its upper bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    prefix static func ... (maximum: Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>

##  Parameters

`maximum`

    

The upper bound for the range.

## Discussion

Use the prefix closed range operator (prefix `...`) to create a partial range
of any type that conforms to the `Comparable` protocol. This example creates a
`PartialRangeThrough<Double>` instance that includes any value less than or
equal to `5.0`.

You can use this type of partial range of a collection’s indices to represent
the range from the start of the collection up to, and including, the partial
range’s upper bound.

Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ...(_:_:)

Returns a closed range that contains both of its bounds.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func ... (minimum: Product.SubscriptionPeriod.Unit, maximum: Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

`maximum`

    

The upper bound for the range.

## Discussion

Use the closed range operator (`...`) to create a closed range of any type
that conforms to the `Comparable` protocol. This example creates a
`ClosedRange<Character>` from “a” up to, and including, “z”.

Precondition: `minimum <= maximum`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ..<(_:)

Returns a partial range up to, but not including, its upper bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    prefix static func ..< (maximum: Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>

##  Parameters

`maximum`

    

The upper bound for the range.

## Discussion

Use the prefix half-open range operator (prefix `..<`) to create a partial
range of any type that conforms to the `Comparable` protocol. This example
creates a `PartialRangeUpTo<Double>` instance that includes any value less
than `5.0`.

You can use this type of partial range of a collection’s indices to represent
the range from the start of the collection up to, but not including, the
partial range’s upper bound.

Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ..<(_:_:)

Returns a half-open range that contains its lower bound but not its upper
bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func ..< (minimum: Product.SubscriptionPeriod.Unit, maximum: Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

`maximum`

    

The upper bound for the range.

## Discussion

Use the half-open range operator (`..<`) to create a range of any type that
conforms to the `Comparable` protocol. This example creates a `Range<Double>`
from zero up to, but not including, 5.0.

Precondition: `minimum <= maximum`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# <(_:_:)

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func < (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

## Relationships

### From Protocol

  * `Comparable`

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# <=(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func <= (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

This is the default implementation of the less-than-or-equal-to operator
(`<=`) for any type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# >(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func > (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

This is the default implementation of the greater-than operator (`>`) for any
type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# >=(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func >= (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Return Value

`true` if `lhs` is greater than or equal to `rhs`; otherwise, `false`.

## Discussion

This is the default implementation of the greater-than-or-equal-to operator
(`>=`) for any type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

Operator

# ...(_:)

Returns a partial range extending upward from a lower bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    postfix static func ... (minimum: Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

## Discussion

Use the postfix range operator (postfix `...`) to create a partial range of
any type that conforms to the `Comparable` protocol. This example creates a
`PartialRangeFrom<Double>` instance that includes any value greater than or
equal to `5.0`.

You can use this type of partial range of a collection’s indices to represent
the range from the partial range’s lower bound up to the end of the
collection.

Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ...(_:)

Returns a partial range up to, and including, its upper bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    prefix static func ... (maximum: Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>

##  Parameters

`maximum`

    

The upper bound for the range.

## Discussion

Use the prefix closed range operator (prefix `...`) to create a partial range
of any type that conforms to the `Comparable` protocol. This example creates a
`PartialRangeThrough<Double>` instance that includes any value less than or
equal to `5.0`.

You can use this type of partial range of a collection’s indices to represent
the range from the start of the collection up to, and including, the partial
range’s upper bound.

Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ...(_:_:)

Returns a closed range that contains both of its bounds.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func ... (minimum: Product.SubscriptionPeriod.Unit, maximum: Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

`maximum`

    

The upper bound for the range.

## Discussion

Use the closed range operator (`...`) to create a closed range of any type
that conforms to the `Comparable` protocol. This example creates a
`ClosedRange<Character>` from “a” up to, and including, “z”.

    
    
    let lowercase = "a"..."z"
    print(lowercase.contains("z"))
    // Prints "true"
    

Precondition: `minimum <= maximum`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ..<(_:)

Returns a partial range up to, but not including, its upper bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    prefix static func ..< (maximum: Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>

##  Parameters

`maximum`

    

The upper bound for the range.

## Discussion

Use the prefix half-open range operator (prefix `..<`) to create a partial
range of any type that conforms to the `Comparable` protocol. This example
creates a `PartialRangeUpTo<Double>` instance that includes any value less
than `5.0`.

You can use this type of partial range of a collection’s indices to represent
the range from the start of the collection up to, but not including, the
partial range’s upper bound.

Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ..<(_:_:)

Returns a half-open range that contains its lower bound but not its upper
bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func ..< (minimum: Product.SubscriptionPeriod.Unit, maximum: Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

`maximum`

    

The upper bound for the range.

## Discussion

Use the half-open range operator (`..<`) to create a range of any type that
conforms to the `Comparable` protocol. This example creates a `Range<Double>`
from zero up to, but not including, 5.0.

Precondition: `minimum <= maximum`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# <(_:_:)

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func < (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

## Relationships

### From Protocol

  * `Comparable`

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# <=(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func <= (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

This is the default implementation of the less-than-or-equal-to operator
(`<=`) for any type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# >(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func > (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

This is the default implementation of the greater-than operator (`>`) for any
type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# >=(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func >= (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Return Value

`true` if `lhs` is greater than or equal to `rhs`; otherwise, `false`.

## Discussion

This is the default implementation of the greater-than-or-equal-to operator
(`>=`) for any type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

Operator

# ...(_:)

Returns a partial range extending upward from a lower bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    postfix static func ... (minimum: Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

## Discussion

Use the postfix range operator (postfix `...`) to create a partial range of
any type that conforms to the `Comparable` protocol. This example creates a
`PartialRangeFrom<Double>` instance that includes any value greater than or
equal to `5.0`.

    
    
    let atLeastFive = 5.0...
    
    
    atLeastFive.contains(4.0)     // false
    atLeastFive.contains(5.0)     // true
    atLeastFive.contains(6.0)     // true
    

You can use this type of partial range of a collection’s indices to represent
the range from the partial range’s lower bound up to the end of the
collection.

    
    
    let numbers = [10, 20, 30, 40, 50, 60, 70]
    print(numbers[3...])
    // Prints "[40, 50, 60, 70]"
    

Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ...(_:)

Returns a partial range up to, and including, its upper bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    prefix static func ... (maximum: Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>

##  Parameters

`maximum`

    

The upper bound for the range.

## Discussion

Use the prefix closed range operator (prefix `...`) to create a partial range
of any type that conforms to the `Comparable` protocol. This example creates a
`PartialRangeThrough<Double>` instance that includes any value less than or
equal to `5.0`.

    
    
    let throughFive = ...5.0
    
    
    throughFive.contains(4.0)     // true
    throughFive.contains(5.0)     // true
    throughFive.contains(6.0)     // false
    

You can use this type of partial range of a collection’s indices to represent
the range from the start of the collection up to, and including, the partial
range’s upper bound.

    
    
    let numbers = [10, 20, 30, 40, 50, 60, 70]
    print(numbers[...3])
    // Prints "[10, 20, 30, 40]"
    

Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ...(_:_:)

Returns a closed range that contains both of its bounds.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func ... (minimum: Product.SubscriptionPeriod.Unit, maximum: Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

`maximum`

    

The upper bound for the range.

## Discussion

Use the closed range operator (`...`) to create a closed range of any type
that conforms to the `Comparable` protocol. This example creates a
`ClosedRange<Character>` from “a” up to, and including, “z”.

    
    
    let lowercase = "a"..."z"
    print(lowercase.contains("z"))
    // Prints "true"
    

Precondition: `minimum <= maximum`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ..<(_:)

Returns a partial range up to, but not including, its upper bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    prefix static func ..< (maximum: Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>

##  Parameters

`maximum`

    

The upper bound for the range.

## Discussion

Use the prefix half-open range operator (prefix `..<`) to create a partial
range of any type that conforms to the `Comparable` protocol. This example
creates a `PartialRangeUpTo<Double>` instance that includes any value less
than `5.0`.

    
    
    let upToFive = ..<5.0
    
    
    upToFive.contains(3.14)       // true
    upToFive.contains(6.28)       // false
    upToFive.contains(5.0)        // false
    

You can use this type of partial range of a collection’s indices to represent
the range from the start of the collection up to, but not including, the
partial range’s upper bound.

    
    
    let numbers = [10, 20, 30, 40, 50, 60, 70]
    print(numbers[..<3])
    // Prints "[10, 20, 30]"
    

Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# ..<(_:_:)

Returns a half-open range that contains its lower bound but not its upper
bound.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func ..< (minimum: Product.SubscriptionPeriod.Unit, maximum: Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>

##  Parameters

`minimum`

    

The lower bound for the range.

`maximum`

    

The upper bound for the range.

## Discussion

Use the half-open range operator (`..<`) to create a range of any type that
conforms to the `Comparable` protocol. This example creates a `Range<Double>`
from zero up to, but not including, 5.0.

    
    
    let lessThanFive = 0.0..<5.0
    print(lessThanFive.contains(3.14))  // Prints "true"
    print(lessThanFive.contains(5.0))   // Prints "false"
    

Precondition: `minimum <= maximum`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# <(_:_:)

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func < (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

## Relationships

### From Protocol

  * `Comparable`

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# <=(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func <= (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

This is the default implementation of the less-than-or-equal-to operator
(`<=`) for any type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# >(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func > (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

This is the default implementation of the greater-than operator (`>`) for any
type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func >= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

Operator

# >=(_:_:)

Returns a Boolean value indicating whether the value of the first argument is
greater than or equal to that of the second argument.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func >= (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Return Value

`true` if `lhs` is greater than or equal to `rhs`; otherwise, `false`.

## Discussion

This is the default implementation of the greater-than-or-equal-to operator
(`>=`) for any type that conforms to `Comparable`.

## See Also

### Inherited operators

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeFrom<Product.SubscriptionPeriod.Unit>`

Returns a partial range extending upward from a lower bound.

`static func ... (Product.SubscriptionPeriod.Unit) ->
PartialRangeThrough<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, and including, its upper bound.

`static func ... (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) ->
ClosedRange<Product.SubscriptionPeriod.Unit>`

Returns a closed range that contains both of its bounds.

`static func ..< (Product.SubscriptionPeriod.Unit) ->
PartialRangeUpTo<Product.SubscriptionPeriod.Unit>`

Returns a partial range up to, but not including, its upper bound.

`static func ..< (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>`

Returns a half-open range that contains its lower bound but not its upper
bound.

`static func < (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

`static func <= (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
less than or equal to that of the second argument.

`static func > (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether the value of the first argument is
greater than that of the second argument.



# SKRequestDelegate

Instance Method

# requestDidFinish(_:)

Tells the delegate that the request has completed.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func requestDidFinish(_ request: SKRequest)

##  Parameters

`request`

    

The request that completed.

## Discussion

This method is called after all processing of the request has been completed.
Typically, subclasses of `SKRequest` require the delegate to implement
additional methods to receive the response. When this method is called, your
delegate receives no further communication from the request and can release
it.

## See Also

### Related Documentation

In-App Purchase Programming Guide

Instance Method

# request(_:didFailWithError:)

Tells the delegate that the request failed to execute.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func request(
        _ request: SKRequest,
        didFailWithError error: any Error
    )

##  Parameters

`request`

    

The request that failed.

`error`

    

The error that caused the request to fail.

## Discussion

When the request fails, your application should release the request. The
`requestDidFinish(_:)` method is not called after this method is called.

Instance Method

# requestDidFinish(_:)

Tells the delegate that the request has completed.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func requestDidFinish(_ request: SKRequest)

##  Parameters

`request`

    

The request that completed.

## Discussion

This method is called after all processing of the request has been completed.
Typically, subclasses of `SKRequest` require the delegate to implement
additional methods to receive the response. When this method is called, your
delegate receives no further communication from the request and can release
it.

## See Also

### Related Documentation

In-App Purchase Programming Guide

Instance Method

# request(_:didFailWithError:)

Tells the delegate that the request failed to execute.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func request(
        _ request: SKRequest,
        didFailWithError error: any Error
    )

##  Parameters

`request`

    

The request that failed.

`error`

    

The error that caused the request to fail.

## Discussion

When the request fails, your application should release the request. The
`requestDidFinish(_:)` method is not called after this method is called.



# AutomaticSubscriptionStoreMarketingContent

Instance Property

# body

The content and behavior of the view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @MainActor
    var body: some View { get }

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing automatic marketing content

`typealias AutomaticSubscriptionStoreMarketingContent.Body`

A type that represents the body of automatic subscription store marketing
content.

Type Alias

# AutomaticSubscriptionStoreMarketingContent.Body

A type that represents the body of automatic subscription store marketing
content.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias AutomaticSubscriptionStoreMarketingContent.Body = some View

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing automatic marketing content

`var body: View`

The content and behavior of the view.

Instance Method

# productDescription(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.4+
tvOS 17.0+  watchOS 10.0+  visionOS 1.1+  Xcode 15.0+

    
    
    func productDescription(_ visibility: Visibility) -> some View

Instance Method

# searchPresentationToolbarBehavior(_:)

StoreKit  SwiftUI  iOS 17.1+  iPadOS 17.1+  macOS 14.1+  Mac Catalyst 17.2+
tvOS 17.1+  watchOS 10.1+  visionOS 1.0+  Xcode 14.4+

    
    
    func searchPresentationToolbarBehavior(_ behavior: SearchPresentationToolbarBehavior) -> some View

Instance Method

# subscriptionPromotionalOffer(offer:signature:)

StoreKit  SwiftUI  iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+
tvOS 17.4+  watchOS 10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func subscriptionPromotionalOffer(
        offer: @escaping (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?,
        signature: @escaping (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) async throws -> Product.SubscriptionOffer.Signature
    ) -> some View



# RequestReviewAction

Instance Method

# callAsFunction()

Tells StoreKit to ask the user to rate or review your app, if appropriate.

StoreKit  SwiftUI  iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+
visionOS 1.0+  Xcode 14.0+

    
    
    @MainActor
    func callAsFunction()

## Discussion

Don’t call this method directly. SwiftUI calls it when you call the
`RequestReviewAction` instance that you get from the `requestReview`
environment value.

For information about how Swift uses the `callAsFunction()`method to simplify
call site syntax, see Methods with Special Names in _The Swift Programming
Language_.

Instance Property

# requestReview

StoreKit  SwiftUI  iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+
visionOS 1.0+

    
    
    @MainActor
    var requestReview: RequestReviewAction { get }

## See Also

### StoreKit configuration

`var displayStoreKitMessage: DisplayMessageAction`

Instance Method

# callAsFunction()

Tells StoreKit to ask the user to rate or review your app, if appropriate.

StoreKit  SwiftUI  iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+
visionOS 1.0+  Xcode 14.0+

    
    
    @MainActor
    func callAsFunction()

## Discussion

Don’t call this method directly. SwiftUI calls it when you call the
`RequestReviewAction` instance that you get from the `requestReview`
environment value.

For information about how Swift uses the `callAsFunction()`method to simplify
call site syntax, see Methods with Special Names in _The Swift Programming
Language_.

Instance Property

# requestReview

StoreKit  SwiftUI  iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+
visionOS 1.0+

    
    
    @MainActor
    var requestReview: RequestReviewAction { get }

## See Also

### StoreKit configuration

`var displayStoreKitMessage: DisplayMessageAction`



# Transaction.Offer.PaymentMode

Type Property

# freeTrial

A payment mode of a product discount that indicates a free trial.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    static let freeTrial: Transaction.Offer.PaymentMode

## Discussion

With a Free trial payment mode, customers pay nothing during the discount
period.

## See Also

### Getting payment modes

`static let payAsYouGo: Transaction.Offer.PaymentMode`

A payment mode of a product discount that’s billed over a single or multiple
billing periods.

`static let payUpFront: Transaction.Offer.PaymentMode`

A payment mode of a product discount that’s paid up front.

Type Property

# payAsYouGo

A payment mode of a product discount that’s billed over a single or multiple
billing periods.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    static let payAsYouGo: Transaction.Offer.PaymentMode

## Discussion

With a Pay As You Go payment mode, subscribers pay a discounted price for each
billing period for the duration of the discount.

## See Also

### Getting payment modes

`static let freeTrial: Transaction.Offer.PaymentMode`

A payment mode of a product discount that indicates a free trial.

`static let payUpFront: Transaction.Offer.PaymentMode`

A payment mode of a product discount that’s paid up front.

Type Property

# payUpFront

A payment mode of a product discount that’s paid up front.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    static let payUpFront: Transaction.Offer.PaymentMode

## Discussion

With a Pay Up Front payment mode, subscribers pay a one-time discounted price
for a specific duration.

## See Also

### Getting payment modes

`static let freeTrial: Transaction.Offer.PaymentMode`

A payment mode of a product discount that indicates a free trial.

`static let payAsYouGo: Transaction.Offer.PaymentMode`

A payment mode of a product discount that’s billed over a single or multiple
billing periods.

Type Alias

# Transaction.Offer.PaymentMode.RawValue

A type that represents the subscription offer payment mode of a transaction.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    typealias Transaction.Offer.PaymentMode.RawValue = String

Initializer

# init(rawValue:)

Creates a payment mode.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    init(rawValue: String)

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Initializing payment modes

`let rawValue: String`

A string that represents a payment mode.

Instance Property

# rawValue

A string that represents a payment mode.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Initializing payment modes

`init(rawValue: String)`

Creates a payment mode.

Instance Property

# hashValue

The hash value.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    var hashValue: Int { get }

## See Also

### Comparing payment modes

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`static func != (Transaction.Offer.PaymentMode, Transaction.Offer.PaymentMode)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    func hash(into hasher: inout Hasher)

## See Also

### Comparing payment modes

`var hashValue: Int`

The hash value.

`static func != (Transaction.Offer.PaymentMode, Transaction.Offer.PaymentMode)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    static func != (lhs: Transaction.Offer.PaymentMode, rhs: Transaction.Offer.PaymentMode) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing payment modes

`var hashValue: Int`

The hash value.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# Transaction.RevocationReason

Type Property

# developerIssue

The value that indicates a customer canceled the transaction due to an actual
or perceived issue within your app.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let developerIssue: Transaction.RevocationReason

## See Also

### Revocation reasons

`static let other: Transaction.RevocationReason`

The value that indicates a customer canceled the transaction for other
reasons.

`typealias Transaction.RevocationReason.RawValue`

The type that represents the raw value of a transaction revocation reason.

Type Property

# other

The value that indicates a customer canceled the transaction for other
reasons.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let other: Transaction.RevocationReason

## Discussion

Other reasons may include, for example, an accidental purchase.

## See Also

### Revocation reasons

`static let developerIssue: Transaction.RevocationReason`

The value that indicates a customer canceled the transaction due to an actual
or perceived issue within your app.

`typealias Transaction.RevocationReason.RawValue`

The type that represents the raw value of a transaction revocation reason.

Type Alias

# Transaction.RevocationReason.RawValue

The type that represents the raw value of a transaction revocation reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Transaction.RevocationReason.RawValue = Int

## See Also

### Revocation reasons

`static let developerIssue: Transaction.RevocationReason`

The value that indicates a customer canceled the transaction due to an actual
or perceived issue within your app.

`static let other: Transaction.RevocationReason`

The value that indicates a customer canceled the transaction for other
reasons.

Instance Property

# localizedDescription

The localized text that describes the revocation reason.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Transaction.RevocationReason, rhs: Transaction.RevocationReason) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing reasons

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

`let rawValue: Int`

The raw value of a transaction revocation reason.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing reasons

`static func != (Transaction.RevocationReason, Transaction.RevocationReason)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

`let rawValue: Int`

The raw value of a transaction revocation reason.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing reasons

`static func != (Transaction.RevocationReason, Transaction.RevocationReason)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`let rawValue: Int`

The raw value of a transaction revocation reason.

Instance Property

# rawValue

The raw value of a transaction revocation reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Comparing and hashing reasons

`static func != (Transaction.RevocationReason, Transaction.RevocationReason)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Initializer

# init(rawValue:)

Creates a revocation reason from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

## Relationships

### From Protocol

  * `RawRepresentable`



# Product.PurchaseOption.SubscriptionRenewalBehavior

Enumeration Case

# Product.PurchaseOption.SubscriptionRenewalBehavior.cancelImmediately

A subscription-renewal behavior in the testing environment that cancels the
subscription, resulting in only one subscription period.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    case cancelImmediately

## Discussion

Choose this option for test cases that require an auto-renewable subscription
that won't renew.

## See Also

### Renewal behaviors in the testing environment

`case renewUntilNow`

A subscription-renewal behavior in the testing environment that allows the
subscription to renew continuously, up to the current date.

Enumeration Case

# Product.PurchaseOption.SubscriptionRenewalBehavior.renewUntilNow

A subscription-renewal behavior in the testing environment that allows the
subscription to renew continuously, up to the current date.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    case renewUntilNow

## Discussion

Choose this option to create test cases that require an auto-renewable
subscription that continues to renew. If you set the purchase date in
`purchaseDate(_:renewalBehavior:)`to the past, the testing environment
generates transactions for all the subscription renewals up to the current
date.

## See Also

### Renewal behaviors in the testing environment

`case cancelImmediately`

A subscription-renewal behavior in the testing environment that cancels the
subscription, resulting in only one subscription period.

Initializer

# init(from:)

Creates a subscription renewal behavior.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    init(from decoder: any Decoder) throws

## Relationships

### From Protocol

  * `Decodable`

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Default implementations

`var hashValue: Int`

The hash value.

`static func == (Product.PurchaseOption.SubscriptionRenewalBehavior,
Product.PurchaseOption.SubscriptionRenewalBehavior) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func encode(to: any Encoder)`

Encodes this value into the given encoder.

Instance Property

# hashValue

The hash value.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Default implementations

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`static func == (Product.PurchaseOption.SubscriptionRenewalBehavior,
Product.PurchaseOption.SubscriptionRenewalBehavior) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func encode(to: any Encoder)`

Encodes this value into the given encoder.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    static func == (a: Product.PurchaseOption.SubscriptionRenewalBehavior, b: Product.PurchaseOption.SubscriptionRenewalBehavior) -> Bool

##  Parameters

`a`

    

A value to compare.

`b`

    

Another value to compare.

## See Also

### Default implementations

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

`func encode(to: any Encoder)`

Encodes this value into the given encoder.

Instance Method

# encode(to:)

Encodes this value into the given encoder.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    func encode(to encoder: any Encoder) throws

##  Parameters

`encoder`

    

The encoder to write data to.

## Relationships

### From Protocol

  * `Encodable`

## See Also

### Default implementations

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

`static func == (Product.PurchaseOption.SubscriptionRenewalBehavior,
Product.PurchaseOption.SubscriptionRenewalBehavior) -> Bool`

Returns a Boolean value indicating whether two values are equal.



# Storefront.Storefronts

Instance Method

# makeAsyncIterator()

Creates the asynchronous iterator that produces elements of this asynchronous
sequence.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func makeAsyncIterator() -> Storefront.Storefronts.AsyncIterator

## Relationships

### From Protocol

  * `AsyncSequence`

## See Also

### Creating an iterator

`struct Storefront.Storefronts.AsyncIterator`

The iterator that produces elements of the asynchronous sequence.

Instance Method

# allSatisfy(_:)

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func allSatisfy(_ predicate: (Storefront) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
satisfies a condition.

## Return Value

`true` if the sequence contains only elements that satisfy `predicate`;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether all
elements produced by the sequence are less than `10`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate returns `false` or the sequence ends.

If the asynchronous sequence is empty, this method returns `true`.

## See Also

### Finding elements

`func contains(where: (Storefront) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Storefront) -> Bool) -> Storefront?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Storefront, Storefront) -> Bool) -> Storefront?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Storefront, Storefront) -> Bool) -> Storefront?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(where:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(where predicate: (Storefront) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
represents a match.

## Return Value

`true` if the sequence contains an element that satisfies predicate;
otherwise, `false`.

## Discussion

You can use the predicate to check for an element of a type that doesn’t
conform to the `Equatable` protocol, or to find an element that satisfies a
general condition.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(where:)` method checks to see whether
the sequence produces a value divisible by `3`:

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Finding elements

`func allSatisfy((Storefront) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func first(where: (Storefront) -> Bool) -> Storefront?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Storefront, Storefront) -> Bool) -> Storefront?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Storefront, Storefront) -> Bool) -> Storefront?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# first(where:)

Returns the first element of the sequence that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func first(where predicate: (Storefront) async throws -> Bool) async rethrows -> Storefront?

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the element is a match.

## Return Value

The first element of the sequence that satisfies `predicate`, or `nil` if
there is no element that satisfies `predicate`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `first(where:)` method returns the first member
of the sequence that’s evenly divisible by both `2` and `3`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Finding elements

`func allSatisfy((Storefront) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (Storefront) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func max(by: (Storefront, Storefront) -> Bool) -> Storefront?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Storefront, Storefront) -> Bool) -> Storefront?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# max(by:)

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func max(by areInIncreasingOrder: (Storefront, Storefront) async throws -> Bool) async rethrows -> Storefront?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `max(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Finding elements

`func allSatisfy((Storefront) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (Storefront) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Storefront) -> Bool) -> Storefront?`

Returns the first element of the sequence that satisfies the given predicate.

`func min(by: (Storefront, Storefront) -> Bool) -> Storefront?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# min(by:)

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func min(by areInIncreasingOrder: (Storefront, Storefront) async throws -> Bool) async rethrows -> Storefront?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `min(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Finding elements

`func allSatisfy((Storefront) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (Storefront) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Storefront) -> Bool) -> Storefront?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Storefront, Storefront) -> Bool) -> Storefront?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# prefix(_:)

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func prefix(_ count: Int) -> AsyncPrefixSequence<Storefront.Storefronts>

##  Parameters

`count`

    

The maximum number of elements to return. The value of `count` must be greater
than or equal to zero.

## Return Value

An asynchronous sequence starting at the beginning of the base sequence with
at most `count` elements.

## Discussion

Use `prefix(_:)` to reduce the number of elements produced by the asynchronous
sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(_:)` method causes the modified sequence
to pass through the first six values, then end.

If the count passed to `prefix(_:)` exceeds the number of elements in the base
sequence, the result contains all of the elements in the sequence.

## See Also

### Selecting elements

`func prefix(while: (Storefront) -> Bool) ->
AsyncPrefixWhileSequence<Storefront.Storefronts>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

Instance Method

# prefix(while:)

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func prefix(while predicate: @escaping @Sendable (Storefront) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Storefront.Storefronts>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether the element should be included in the modified sequence.

## Return Value

An asynchronous sequence of the initial, consecutive elements that satisfy
`predicate`.

## Discussion

Use `prefix(while:)` to produce values while elements from the base sequence
meet a condition you specify. The modified sequence ends when the predicate
closure returns `false`.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(while:)` method causes the modified
sequence to pass along values so long as they aren’t divisible by `2` and `3`.
Upon reaching `6`, the sequence ends:

## See Also

### Selecting elements

`func prefix(Int) -> AsyncPrefixSequence<Storefront.Storefronts>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

Instance Method

# drop(while:)

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func drop(while predicate: @escaping @Sendable (Storefront) async -> Bool) -> AsyncDropWhileSequence<Storefront.Storefronts>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether to drop the element from the modified sequence.

## Return Value

An asynchronous sequence that skips over values from the base sequence until
the provided closure returns `false`.

## Discussion

Use `drop(while:)` to omit elements from an asynchronous sequence until the
element received meets a condition you specify.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `drop(while:)` method causes the modified
sequence to ignore received values until it encounters one that is divisible
by `3`:

After the predicate returns `false`, the sequence never executes it again, and
from then on the sequence passes through elements from its underlying sequence
as-is.

## See Also

### Excluding elements

`func dropFirst(Int) -> AsyncDropFirstSequence<Storefront.Storefronts>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

`func filter((Storefront) -> Bool) ->
AsyncFilterSequence<Storefront.Storefronts>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

Instance Method

# dropFirst(_:)

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Storefront.Storefronts>

##  Parameters

`count`

    

The number of elements to drop from the beginning of the sequence. `count`
must be greater than or equal to zero.

## Return Value

An asynchronous sequence that drops the first `count` elements from the base
sequence.

## Discussion

Use `dropFirst(_:)` when you want to drop the first _n_ elements from the base
sequence and pass through the remaining elements.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `dropFirst(_:)` method causes the modified
sequence to ignore the values `1` through `3`, and instead emit `4` through
`10`:

If the number of elements to drop exceeds the number of elements in the
sequence, the result is an empty sequence.

## See Also

### Excluding elements

`func drop(while: (Storefront) -> Bool) ->
AsyncDropWhileSequence<Storefront.Storefronts>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

`func filter((Storefront) -> Bool) ->
AsyncFilterSequence<Storefront.Storefronts>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

Instance Method

# filter(_:)

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func filter(_ isIncluded: @escaping @Sendable (Storefront) async -> Bool) -> AsyncFilterSequence<Storefront.Storefronts>

##  Parameters

`isIncluded`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether to include the element in
the filtered sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements of the base
sequence that satisfy the given predicate.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `filter(_:)` method returns `true` for even
values and `false` for odd values, thereby filtering out the odd values:

## See Also

### Excluding elements

`func drop(while: (Storefront) -> Bool) ->
AsyncDropWhileSequence<Storefront.Storefronts>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

`func dropFirst(Int) -> AsyncDropFirstSequence<Storefront.Storefronts>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Storefront) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns a transformed value of the same or of a
different type. If `transform` throws an error, the sequence ends.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure. The sequence ends either when the base
sequence ends or when `transform` throws an error.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Since there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence. When the value is `5`, the closure throws `MyError`,
terminating the sequence.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, Storefront) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Storefront) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Storefront) async -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Because there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, Storefront) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Storefront) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Storefront) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns an `AsyncSequence`. If `transform`
throws an error, the sequence ends.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`. The sequence ends either
when the last sequence created from the last element from base sequence ends,
or when `transform` throws an error.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`. However, when
the closure receives `4`, it throws an error, terminating the sequence.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, Storefront) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Storefront) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Storefront) async -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns an `AsyncSequence`.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, Storefront) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Storefront) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Storefront) async throws -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.
`transform` can also throw an error, which ends the transformed sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces.
Also, the dictionary doesn’t provide a key for `4`, and the closure throws an
error for any key it can’t look up, so receiving this value from `Counter`
ends the modified sequence with an error.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, Storefront) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Storefront) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Storefront) async -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces:

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, Storefront) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result, Storefront) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(_:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        _ initialResult: Result,
        _ nextPartialResult: (Result, Storefront) async throws -> Result
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure runs.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(_:_:)` method to produce a single value from the elements of
an entire sequence. For example, you can use this method on an sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `4`. The `reduce(_:_:)` method sums the values received
from the asynchronous sequence.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(into: Result, (inout Result, Storefront) -> Void) ->
Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(into:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        into initialResult: Result,
        _ updateAccumulatingResult: (inout Result, Storefront) async throws -> Void
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure executes.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(into:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on a sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

Prefer this method over `reduce(_:_:)` for efficiency when the result is a
copy-on-write type, for example an `Array` or `Dictionary`.

## See Also

### Transforming a sequence

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) ->
AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) ->
AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Storefront) -> Transformed) ->
AsyncMapSequence<Storefront.Storefronts, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, Storefront) -> Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.



# Transaction.Reason

Type Property

# purchase

A transaction reason that indicates a purchase is initiated by a customer.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static let purchase: Transaction.Reason

## Discussion

The customer initiated the purchase, which may be for any in-app purchase
type: consumable, non-consumable, non-renewing subscription, or auto-renewable
subscription.

## See Also

### Transaction reasons

`static let renewal: Transaction.Reason`

A transaction reason that indicates the App Store server initiated a purchase
transaction to renew an auto-renewable subscription.

Type Property

# renewal

A transaction reason that indicates the App Store server initiated a purchase
transaction to renew an auto-renewable subscription.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static let renewal: Transaction.Reason

## See Also

### Transaction reasons

`static let purchase: Transaction.Reason`

A transaction reason that indicates a purchase is initiated by a customer.

Initializer

# init(rawValue:)

Returns a new transaction reason with the specified raw value.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(rawValue: String)

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating transaction reasons

`let rawValue: String`

The corresponding value of the raw type.

`typealias Transaction.Reason.RawValue`

A type that represents the raw value of a transaction reason.

Instance Property

# rawValue

The corresponding value of the raw type.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating transaction reasons

`init(rawValue: String)`

Returns a new transaction reason with the specified raw value.

`typealias Transaction.Reason.RawValue`

A type that represents the raw value of a transaction reason.

Type Alias

# Transaction.Reason.RawValue

A type that represents the raw value of a transaction reason.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias Transaction.Reason.RawValue = String

## See Also

### Creating transaction reasons

`init(rawValue: String)`

Returns a new transaction reason with the specified raw value.

`let rawValue: String`

The corresponding value of the raw type.

Instance Property

# hashValue

The hash value.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`static func != (Transaction.Reason, Transaction.Reason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func hash(into hasher: inout Hasher)

## See Also

### Comparing and hashing

`var hashValue: Int`

The hash value.

`static func != (Transaction.Reason, Transaction.Reason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func != (lhs: Transaction.Reason, rhs: Transaction.Reason) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing

`var hashValue: Int`

The hash value.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# Product.SubscriptionInfo.RenewalInfo.ExpirationReason

Type Property

# autoRenewDisabled

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# billingError

The auto-renewable subscription expired because of a billing error.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## Discussion

Check the value of `isInBillingRetry` to determine whether an auto-renewable
subscription is in a billing retry state.

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# didNotConsentToPriceIncrease

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# productUnavailable

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# unknown

The auto-renewable subscription expired for an unknown reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

Instance Property

# localizedDescription

The localized text that describes the expiration reason.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Instance Property

# rawValue

The raw value that represents an expiration reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Discussion

Use raw values to help parse the `jsonRepresentation` property of the
`Product.SubscriptionInfo.RenewalInfo`.

When subscription renewal information has an `expirationReason` value, its
`jsonRepresentation` contains an integer that represents the expiration
reason, which is its raw value. Compare the JSON data directly to the
expiration reason’s `rawValue`.

You can also use the `rawValue` to create an expiration reason instance by
calling `init(rawValue:)`.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue`

A type that represents the raw value of a subscription expiration reason.

Type Alias

# Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue

A type that represents the raw value of a subscription expiration reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue = Int

## See Also

### Accessing the raw value

`let rawValue: Int`

The raw value that represents an expiration reason.

Initializer

# init(rawValue:)

Creates an expiration reason instance from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

##  Parameters

`rawValue`

    

An integer that represents an expiration reason.

## Discussion

Typically, you get an expiration reason from the `expirationReason` property
of `Product.SubscriptionInfo.RenewalInfo` and you don’t need to instantiate it
yourself.

However, if you use the `jsonRepresentation` property of
`Product.SubscriptionInfo.RenewalInfo`, you can use raw values and the
initializer to help parse the JSON data. The data contains the integer
representation of the ownership type, which is its raw value. Call
`init(rawValue:)` to create your own instance from that raw value.
Alternatively, you can compare the JSON data directly to the expiration
reason’s `rawValue`.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo.ExpirationReason, rhs: Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing expiration reasons

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing expiration reasons

`static func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason,
Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing expiration reasons

`static func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason,
Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# autoRenewDisabled

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# billingError

The auto-renewable subscription expired because of a billing error.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## Discussion

Check the value of `isInBillingRetry` to determine whether an auto-renewable
subscription is in a billing retry state.

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# didNotConsentToPriceIncrease

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# productUnavailable

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# unknown

The auto-renewable subscription expired for an unknown reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

Instance Property

# localizedDescription

The localized text that describes the expiration reason.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Instance Property

# rawValue

The raw value that represents an expiration reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Discussion

Use raw values to help parse the `jsonRepresentation` property of the
`Product.SubscriptionInfo.RenewalInfo`.

When subscription renewal information has an `expirationReason` value, its
`jsonRepresentation` contains an integer that represents the expiration
reason, which is its raw value. Compare the JSON data directly to the
expiration reason’s `rawValue`.

You can also use the `rawValue` to create an expiration reason instance by
calling `init(rawValue:)`.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue`

A type that represents the raw value of a subscription expiration reason.

Type Alias

# Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue

A type that represents the raw value of a subscription expiration reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue = Int

## See Also

### Accessing the raw value

`let rawValue: Int`

The raw value that represents an expiration reason.

Initializer

# init(rawValue:)

Creates an expiration reason instance from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

##  Parameters

`rawValue`

    

An integer that represents an expiration reason.

## Discussion

Typically, you get an expiration reason from the `expirationReason` property
of `Product.SubscriptionInfo.RenewalInfo` and you don’t need to instantiate it
yourself.

However, if you use the `jsonRepresentation` property of
`Product.SubscriptionInfo.RenewalInfo`, you can use raw values and the
initializer to help parse the JSON data. The data contains the integer
representation of the ownership type, which is its raw value. Call
`init(rawValue:)` to create your own instance from that raw value.
Alternatively, you can compare the JSON data directly to the expiration
reason’s `rawValue`.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo.ExpirationReason, rhs: Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing expiration reasons

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing expiration reasons

`static func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason,
Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing expiration reasons

`static func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason,
Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# autoRenewDisabled

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# billingError

The auto-renewable subscription expired because of a billing error.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## Discussion

Check the value of `isInBillingRetry` to determine whether an auto-renewable
subscription is in a billing retry state.

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# didNotConsentToPriceIncrease

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# productUnavailable

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# unknown

The auto-renewable subscription expired for an unknown reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

Instance Property

# localizedDescription

The localized text that describes the expiration reason.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Instance Property

# rawValue

The raw value that represents an expiration reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Discussion

Use raw values to help parse the `jsonRepresentation` property of the
`Product.SubscriptionInfo.RenewalInfo`.

When subscription renewal information has an `expirationReason` value, its
`jsonRepresentation` contains an integer that represents the expiration
reason, which is its raw value. Compare the JSON data directly to the
expiration reason’s `rawValue`.

You can also use the `rawValue` to create an expiration reason instance by
calling `init(rawValue:)`.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue`

A type that represents the raw value of a subscription expiration reason.

Type Alias

# Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue

A type that represents the raw value of a subscription expiration reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue = Int

## See Also

### Accessing the raw value

`let rawValue: Int`

The raw value that represents an expiration reason.

Initializer

# init(rawValue:)

Creates an expiration reason instance from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

##  Parameters

`rawValue`

    

An integer that represents an expiration reason.

## Discussion

Typically, you get an expiration reason from the `expirationReason` property
of `Product.SubscriptionInfo.RenewalInfo` and you don’t need to instantiate it
yourself.

However, if you use the `jsonRepresentation` property of
`Product.SubscriptionInfo.RenewalInfo`, you can use raw values and the
initializer to help parse the JSON data. The data contains the integer
representation of the ownership type, which is its raw value. Call
`init(rawValue:)` to create your own instance from that raw value.
Alternatively, you can compare the JSON data directly to the expiration
reason’s `rawValue`.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo.ExpirationReason, rhs: Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing expiration reasons

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing expiration reasons

`static func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason,
Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing expiration reasons

`static func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason,
Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# autoRenewDisabled

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# billingError

The auto-renewable subscription expired because of a billing error.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## Discussion

Check the value of `isInBillingRetry` to determine whether an auto-renewable
subscription is in a billing retry state.

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# didNotConsentToPriceIncrease

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# productUnavailable

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired for an unknown reason.

Type Property

# unknown

The auto-renewable subscription expired for an unknown reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason

## See Also

### Getting the expiration reason

`static let autoRenewDisabled:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the customer voluntarily
canceled their subscription.

`static let billingError:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because of a billing error.

`static let didNotConsentToPriceIncrease:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The subscription expired because the customer didn’t consent to an auto-
renewable subscription price increase that requires customer consent.

`static let productUnavailable:
Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The auto-renewable subscription expired because the product was unavailable
for purchase at the time of the renewal.

Instance Property

# localizedDescription

The localized text that describes the expiration reason.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Instance Property

# rawValue

The raw value that represents an expiration reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Discussion

Use raw values to help parse the `jsonRepresentation` property of the
`Product.SubscriptionInfo.RenewalInfo`.

When subscription renewal information has an `expirationReason` value, its
`jsonRepresentation` contains an integer that represents the expiration
reason, which is its raw value. Compare the JSON data directly to the
expiration reason’s `rawValue`.

You can also use the `rawValue` to create an expiration reason instance by
calling `init(rawValue:)`.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue`

A type that represents the raw value of a subscription expiration reason.

Type Alias

# Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue

A type that represents the raw value of a subscription expiration reason.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue = Int

## See Also

### Accessing the raw value

`let rawValue: Int`

The raw value that represents an expiration reason.

Initializer

# init(rawValue:)

Creates an expiration reason instance from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

##  Parameters

`rawValue`

    

An integer that represents an expiration reason.

## Discussion

Typically, you get an expiration reason from the `expirationReason` property
of `Product.SubscriptionInfo.RenewalInfo` and you don’t need to instantiate it
yourself.

However, if you use the `jsonRepresentation` property of
`Product.SubscriptionInfo.RenewalInfo`, you can use raw values and the
initializer to help parse the JSON data. The data contains the integer
representation of the ownership type, which is its raw value. Call
`init(rawValue:)` to create your own instance from that raw value.
Alternatively, you can compare the JSON data directly to the expiration
reason’s `rawValue`.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo.ExpirationReason, rhs: Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing expiration reasons

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing expiration reasons

`static func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason,
Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing expiration reasons

`static func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason,
Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# Product.PurchaseOption

Type Method

# appAccountToken(_:)

Sets a UUID to associate the purchase with an account in your system.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func appAccountToken(_ token: UUID) -> Product.PurchaseOption

##  Parameters

`token`

    

A UUID you provide to associate with the purchase.

## Return Value

An instance of `Product.PurchaseOption` to use in `purchase(options:)`.

## Discussion

When you set the app account token in the purchase options, the App Store
returns the same app account token value in the resulting transaction, in
`appAccountToken`.

## See Also

### Setting the purchase options

`static func onStorefrontChange(shouldContinuePurchase: (Storefront) -> Bool)
-> Product.PurchaseOption`

Indicates whether a transaction needs to continue if the App Store storefront
changes on the device during the transaction.

`static func promotionalOffer(offerID: String, keyID: String, nonce: UUID,
signature: Data, timestamp: Int) -> Product.PurchaseOption`

Applies a promotional offer for an auto-renewable subscription.

`static func quantity(Int) -> Product.PurchaseOption`

Indicates the quantity of items the customer is purchasing.

Type Method

# onStorefrontChange(shouldContinuePurchase:)

Indicates whether a transaction needs to continue if the App Store storefront
changes on the device during the transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    static func onStorefrontChange(shouldContinuePurchase: @escaping @Sendable (Storefront) -> Bool) -> Product.PurchaseOption

##  Parameters

`shouldContinuePurchase`

    

A closure that returns a Boolean value to indicate whether the purchase needs
to continue when the App Store storefront changes to the `storefront` value
during a transaction.

## Return Value

`Product.PurchaseOption`

## Discussion

The default value is `true` if this option isn’t added to the purchase.

## See Also

### Setting the purchase options

`static func appAccountToken(UUID) -> Product.PurchaseOption`

Sets a UUID to associate the purchase with an account in your system.

`static func promotionalOffer(offerID: String, keyID: String, nonce: UUID,
signature: Data, timestamp: Int) -> Product.PurchaseOption`

Applies a promotional offer for an auto-renewable subscription.

`static func quantity(Int) -> Product.PurchaseOption`

Indicates the quantity of items the customer is purchasing.

Type Method

# promotionalOffer(offerID:keyID:nonce:signature:timestamp:)

Applies a promotional offer for an auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func promotionalOffer(
        offerID: String,
        keyID: String,
        nonce: UUID,
        signature: Data,
        timestamp: Int
    ) -> Product.PurchaseOption

##  Parameters

`offerID`

    

The subscription-offer identifier, `id`.

`keyID`

    

The key ID of the subscription key.

`nonce`

    

The anti-replay value used in the signature. Use lowercase.

`signature`

    

The cryptographic signature of the offer parameters, which you generate on
your server.

`timestamp`

    

The UNIX time, in milliseconds, when you generate the signature.

## Return Value

An instance of `Product.PurchaseOption` to use in `purchase(options:)`.

## Discussion

For information about `keyID`, `nonce`, `signature`, and `timestamp`, see
Generating a signature for promotional offers. If you’re providing an
`appAccountToken(_:)` in the purchase options, you must include that value
when you generate the `signature`. Use lowercase for the UUID string
representations of the app account token and the `nonce` in the signature.

You can offer a discounted or free period of service for auto-renewable
subscriptions on iOS, iPadOS, macOS, and tvOS using promotional offers. Before
you can provide promotional offers in your app, you must set up the offers in
your App Store Connect account. To configure your offer, see Set up
promotional offers for auto-renewable subscriptions.

## See Also

### Setting the purchase options

`static func appAccountToken(UUID) -> Product.PurchaseOption`

Sets a UUID to associate the purchase with an account in your system.

`static func onStorefrontChange(shouldContinuePurchase: (Storefront) -> Bool)
-> Product.PurchaseOption`

Indicates whether a transaction needs to continue if the App Store storefront
changes on the device during the transaction.

`static func quantity(Int) -> Product.PurchaseOption`

Indicates the quantity of items the customer is purchasing.

Type Method

# quantity(_:)

Indicates the quantity of items the customer is purchasing.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func quantity(_ quantity: Int) -> Product.PurchaseOption

##  Parameters

`quantity`

    

The number of items the customer is purchasing.

The default value is 1. The maximum value is 10.

## Return Value

An instance of `Product.PurchaseOption` to use in `purchase(options:)`.

## Discussion

The quantity applies to consumable in-app purchases and non-renewing
subscriptions.

## See Also

### Setting the purchase options

`static func appAccountToken(UUID) -> Product.PurchaseOption`

Sets a UUID to associate the purchase with an account in your system.

`static func onStorefrontChange(shouldContinuePurchase: (Storefront) -> Bool)
-> Product.PurchaseOption`

Indicates whether a transaction needs to continue if the App Store storefront
changes on the device during the transaction.

`static func promotionalOffer(offerID: String, keyID: String, nonce: UUID,
signature: Data, timestamp: Int) -> Product.PurchaseOption`

Applies a promotional offer for an auto-renewable subscription.

Type Method

# purchaseDate(_:renewalBehavior:)

Sets the purchase date for the transaction in the testing environment, and
indicates the renewal behavior for an auto-renewable subscription.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    static func purchaseDate(
        _ date: Date,
        renewalBehavior: Product.PurchaseOption.SubscriptionRenewalBehavior = .renewUntilNow
    ) -> Product.PurchaseOption

##  Parameters

`date`

    

The purchase date for the transaction. Specify a date in the past or the
current moment. Dates in the future aren’t valid.

`renewalBehavior`

    

The renewal behavior for the auto-renewable subscription in this transaction,
whether it renews continuously from the purchase date, or it cancels after the
first period. By default, the subscription renews.

## Discussion

Use this purchase option when you test your app in Xcode using StoreKit Test
and call `buyProduct(identifier:options:)`.

Use this purchase option to create useful transactions for your test cases.
For example, use a date in the past with the default `renewalBehavior` to
generate a full history of subscription renewals to test. Or, use a date in
the past with the
`Product.PurchaseOption.SubscriptionRenewalBehavior.cancelImmediately`
behavior to simulate an account of a customer who canceled their subscription.

## See Also

### Setting options for StoreKit Testing in Xcode

`enum Product.PurchaseOption.SubscriptionRenewalBehavior`

Renewal options for auto-renewable subscriptions that you purchase in the
testing environment.

`static func codeOffer(referenceName: String) -> Product.PurchaseOption`

Sets an offer code for the transaction in the testing environment.

`static func promotionalOffer(id: String) -> Product.PurchaseOption`

Sets a promotional offer for the transaction in the testing environment.

Type Method

# codeOffer(referenceName:)

Sets an offer code for the transaction in the testing environment.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    static func codeOffer(referenceName: String) -> Product.PurchaseOption

##  Parameters

`referenceName`

    

The reference name of the offer code to apply to the transaction. You need to
set up offer codes in your StoreKit configuration file.

## Discussion

Use this purchase option when you test your app in Xcode using StoreKit Test
and call `buyProduct(identifier:options:)`.

Set up the offer codes to use in this call in your StoreKit configuration
file. For more information, see Setting up StoreKit Testing in Xcode.

When you apply this option, the purchase transaction simulates a customer
redeeming an offer code and includes the offer code you specify.

## See Also

### Setting options for StoreKit Testing in Xcode

`static func purchaseDate(Date, renewalBehavior:
Product.PurchaseOption.SubscriptionRenewalBehavior) -> Product.PurchaseOption`

Sets the purchase date for the transaction in the testing environment, and
indicates the renewal behavior for an auto-renewable subscription.

`enum Product.PurchaseOption.SubscriptionRenewalBehavior`

Renewal options for auto-renewable subscriptions that you purchase in the
testing environment.

`static func promotionalOffer(id: String) -> Product.PurchaseOption`

Sets a promotional offer for the transaction in the testing environment.

Type Method

# promotionalOffer(id:)

Sets a promotional offer for the transaction in the testing environment.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  tvOS 17.0+  watchOS 10.0+  visionOS 1.0+
Xcode 15.0+

    
    
    static func promotionalOffer(id identifier: String) -> Product.PurchaseOption

##  Parameters

`identifier`

    

The identifier of the promotional offer to apply to the transaction. You need
to set up identifiers in your StoreKit configuration file.

## Discussion

Use this purchase option when you test your app in Xcode using StoreKit Test
and call `buyProduct(identifier:options:)`.

Set up the promotional offer identifiers you use in this call in your StoreKit
configuration file. For more information, see Setting up StoreKit Testing in
Xcode.

When you apply this option, the purchase transaction simulates a customer
redeeming a promotional offer and includes the promotional offer you specify.

## See Also

### Setting options for StoreKit Testing in Xcode

`static func purchaseDate(Date, renewalBehavior:
Product.PurchaseOption.SubscriptionRenewalBehavior) -> Product.PurchaseOption`

Sets the purchase date for the transaction in the testing environment, and
indicates the renewal behavior for an auto-renewable subscription.

`enum Product.PurchaseOption.SubscriptionRenewalBehavior`

Renewal options for auto-renewable subscriptions that you purchase in the
testing environment.

`static func codeOffer(referenceName: String) -> Product.PurchaseOption`

Sets an offer code for the transaction in the testing environment.

Type Method

# simulatesAskToBuyInSandbox(_:)

Simulates an Ask to Buy scenario when testing your app in the sandbox
environment.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func simulatesAskToBuyInSandbox(_ simulateAskToBuy: Bool) -> Product.PurchaseOption

##  Parameters

`simulateAskToBuy`

    

Set to `true` to simulate a child’s account asking permission to make a
purchase.

## Return Value

An instance of `Product.PurchaseOption` to use in `purchase(options:)`.

## Discussion

For information about testing Ask to Buy scenarios, see Testing at all stages
of development with Xcode and the sandbox.

For information about purchases made using Ask to Buy, see Approve what kids
buy with Ask to Buy.

Type Method

# custom(key:value:)

Adds data for a custom key to a purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func custom(
        key: String,
        value: Data
    ) -> Product.PurchaseOption

##  Parameters

`key`

    

The key for this custom option.

`value`

    

The data value you assign to this custom option.

## Discussion

Custom purchase options don’t have any effect and are reserved for future use.

## See Also

### Setting custom purchase options

`static func custom(key: String, value: String) -> Product.PurchaseOption`

Adds a string for a custom key to a purchase.

`static func custom(key: String, value: Bool) -> Product.PurchaseOption`

Adds a Boolean value for a custom key to a purchase.

`static func custom(key: String, value: Double) -> Product.PurchaseOption`

Adds a number for a custom key to a purchase.

Type Method

# custom(key:value:)

Adds a string for a custom key to a purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func custom(
        key: String,
        value: String
    ) -> Product.PurchaseOption

##  Parameters

`key`

    

The key for this custom option.

`value`

    

The string value you assign to this custom option.

## Discussion

Custom purchase options don’t have any effect and are reserved for future use.

## See Also

### Setting custom purchase options

`static func custom(key: String, value: Data) -> Product.PurchaseOption`

Adds data for a custom key to a purchase.

`static func custom(key: String, value: Bool) -> Product.PurchaseOption`

Adds a Boolean value for a custom key to a purchase.

`static func custom(key: String, value: Double) -> Product.PurchaseOption`

Adds a number for a custom key to a purchase.

Type Method

# custom(key:value:)

Adds a Boolean value for a custom key to a purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func custom(
        key: String,
        value: Bool
    ) -> Product.PurchaseOption

##  Parameters

`key`

    

The key for this custom option.

`value`

    

The Boolean value you assign to this custom option.

## Discussion

Custom purchase options don’t have any effect and are reserved for future use.

## See Also

### Setting custom purchase options

`static func custom(key: String, value: Data) -> Product.PurchaseOption`

Adds data for a custom key to a purchase.

`static func custom(key: String, value: String) -> Product.PurchaseOption`

Adds a string for a custom key to a purchase.

`static func custom(key: String, value: Double) -> Product.PurchaseOption`

Adds a number for a custom key to a purchase.

Type Method

# custom(key:value:)

Adds a number for a custom key to a purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func custom(
        key: String,
        value: Double
    ) -> Product.PurchaseOption

##  Parameters

`key`

    

The key for this custom option.

`value`

    

The numerical value you assign to this custom option.

## Discussion

Custom purchase options don’t have any effect and are reserved for future use.

## See Also

### Setting custom purchase options

`static func custom(key: String, value: Data) -> Product.PurchaseOption`

Adds data for a custom key to a purchase.

`static func custom(key: String, value: String) -> Product.PurchaseOption`

Adds a string for a custom key to a purchase.

`static func custom(key: String, value: Bool) -> Product.PurchaseOption`

Adds a Boolean value for a custom key to a purchase.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.PurchaseOption, rhs: Product.PurchaseOption) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing purchase options

`static func == (Product.PurchaseOption, Product.PurchaseOption) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.PurchaseOption, b: Product.PurchaseOption) -> Bool

## See Also

### Comparing and hashing purchase options

`static func != (Product.PurchaseOption, Product.PurchaseOption) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing purchase options

`static func != (Product.PurchaseOption, Product.PurchaseOption) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.PurchaseOption, Product.PurchaseOption) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing purchase options

`static func != (Product.PurchaseOption, Product.PurchaseOption) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.PurchaseOption, Product.PurchaseOption) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# debugDescription

A debug description of the purchase option.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Type Method

# promotionalOffer(offerID:signature:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    static func promotionalOffer(
        offerID: String,
        signature: Product.SubscriptionOffer.Signature
    ) -> Product.PurchaseOption



# AppStore.Environment

Type Property

# production

A value that indicates the production server environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let production: AppStore.Environment

## See Also

### Getting the environment value

`static let sandbox: AppStore.Environment`

A value that indicates the sandbox server environment.

`static let xcode: AppStore.Environment`

A value that indicates the StoreKit Testing in Xcode environment.

Type Property

# sandbox

A value that indicates the sandbox server environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let sandbox: AppStore.Environment

## See Also

### Getting the environment value

`static let production: AppStore.Environment`

A value that indicates the production server environment.

`static let xcode: AppStore.Environment`

A value that indicates the StoreKit Testing in Xcode environment.

Type Property

# xcode

A value that indicates the StoreKit Testing in Xcode environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let xcode: AppStore.Environment

## See Also

### Getting the environment value

`static let production: AppStore.Environment`

A value that indicates the production server environment.

`static let sandbox: AppStore.Environment`

A value that indicates the sandbox server environment.

Instance Property

# rawValue

The underlying string value that describes the environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Getting the raw value

`typealias AppStore.Environment.RawValue`

A string type that represents the raw value of an App Store environment.

Type Alias

# AppStore.Environment.RawValue

A string type that represents the raw value of an App Store environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias AppStore.Environment.RawValue = String

## See Also

### Getting the raw value

`let rawValue: String`

The underlying string value that describes the environment.

Initializer

# init(rawValue:)

Creates a new instance with the specified raw value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

The raw value to use for the new instance.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: AppStore.Environment, rhs: AppStore.Environment) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing the environment value

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

## See Also

### Comparing and hashing the environment value

`static func != (AppStore.Environment, AppStore.Environment) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing the environment value

`static func != (AppStore.Environment, AppStore.Environment) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# production

A value that indicates the production server environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let production: AppStore.Environment

## See Also

### Getting the environment value

`static let sandbox: AppStore.Environment`

A value that indicates the sandbox server environment.

`static let xcode: AppStore.Environment`

A value that indicates the StoreKit Testing in Xcode environment.

Type Property

# sandbox

A value that indicates the sandbox server environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let sandbox: AppStore.Environment

## See Also

### Getting the environment value

`static let production: AppStore.Environment`

A value that indicates the production server environment.

`static let xcode: AppStore.Environment`

A value that indicates the StoreKit Testing in Xcode environment.

Type Property

# xcode

A value that indicates the StoreKit Testing in Xcode environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let xcode: AppStore.Environment

## See Also

### Getting the environment value

`static let production: AppStore.Environment`

A value that indicates the production server environment.

`static let sandbox: AppStore.Environment`

A value that indicates the sandbox server environment.

Instance Property

# rawValue

The underlying string value that describes the environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Getting the raw value

`typealias AppStore.Environment.RawValue`

A string type that represents the raw value of an App Store environment.

Type Alias

# AppStore.Environment.RawValue

A string type that represents the raw value of an App Store environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias AppStore.Environment.RawValue = String

## See Also

### Getting the raw value

`let rawValue: String`

The underlying string value that describes the environment.

Initializer

# init(rawValue:)

Creates a new instance with the specified raw value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

The raw value to use for the new instance.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: AppStore.Environment, rhs: AppStore.Environment) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing the environment value

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

## See Also

### Comparing and hashing the environment value

`static func != (AppStore.Environment, AppStore.Environment) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing the environment value

`static func != (AppStore.Environment, AppStore.Environment) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# production

A value that indicates the production server environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let production: AppStore.Environment

## See Also

### Getting the environment value

`static let sandbox: AppStore.Environment`

A value that indicates the sandbox server environment.

`static let xcode: AppStore.Environment`

A value that indicates the StoreKit Testing in Xcode environment.

Type Property

# sandbox

A value that indicates the sandbox server environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let sandbox: AppStore.Environment

## See Also

### Getting the environment value

`static let production: AppStore.Environment`

A value that indicates the production server environment.

`static let xcode: AppStore.Environment`

A value that indicates the StoreKit Testing in Xcode environment.

Type Property

# xcode

A value that indicates the StoreKit Testing in Xcode environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let xcode: AppStore.Environment

## See Also

### Getting the environment value

`static let production: AppStore.Environment`

A value that indicates the production server environment.

`static let sandbox: AppStore.Environment`

A value that indicates the sandbox server environment.

Instance Property

# rawValue

The underlying string value that describes the environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Getting the raw value

`typealias AppStore.Environment.RawValue`

A string type that represents the raw value of an App Store environment.

Type Alias

# AppStore.Environment.RawValue

A string type that represents the raw value of an App Store environment.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias AppStore.Environment.RawValue = String

## See Also

### Getting the raw value

`let rawValue: String`

The underlying string value that describes the environment.

Initializer

# init(rawValue:)

Creates a new instance with the specified raw value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

The raw value to use for the new instance.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: AppStore.Environment, rhs: AppStore.Environment) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing the environment value

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

## See Also

### Comparing and hashing the environment value

`static func != (AppStore.Environment, AppStore.Environment) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing the environment value

`static func != (AppStore.Environment, AppStore.Environment) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# Product.PurchaseError

Enumeration Case

# Product.PurchaseError.invalidOfferIdentifier

The promotional offer identifier provided in the purchase options is invalid.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidOfferIdentifier

## See Also

### Getting Purchase Error Codes

`case productUnavailable`

The product isn’t available.

`case purchaseNotAllowed`

The user isn’t allowed to make purchases.

`case ineligibleForOffer`

The user isn't eligible for the offer.

`case invalidOfferPrice`

The price of the offer isn't valid.

`case invalidOfferSignature`

The offer signature isn't valid.

`case invalidQuantity`

The quantity to purchase is invalid.

`case missingOfferParameters`

The offer parameters are missing.

Enumeration Case

# Product.PurchaseError.productUnavailable

The product isn’t available.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case productUnavailable

## See Also

### Getting Purchase Error Codes

`case invalidOfferIdentifier`

The promotional offer identifier provided in the purchase options is invalid.

`case purchaseNotAllowed`

The user isn’t allowed to make purchases.

`case ineligibleForOffer`

The user isn't eligible for the offer.

`case invalidOfferPrice`

The price of the offer isn't valid.

`case invalidOfferSignature`

The offer signature isn't valid.

`case invalidQuantity`

The quantity to purchase is invalid.

`case missingOfferParameters`

The offer parameters are missing.

Enumeration Case

# Product.PurchaseError.purchaseNotAllowed

The user isn’t allowed to make purchases.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case purchaseNotAllowed

## See Also

### Getting Purchase Error Codes

`case invalidOfferIdentifier`

The promotional offer identifier provided in the purchase options is invalid.

`case productUnavailable`

The product isn’t available.

`case ineligibleForOffer`

The user isn't eligible for the offer.

`case invalidOfferPrice`

The price of the offer isn't valid.

`case invalidOfferSignature`

The offer signature isn't valid.

`case invalidQuantity`

The quantity to purchase is invalid.

`case missingOfferParameters`

The offer parameters are missing.

Enumeration Case

# Product.PurchaseError.ineligibleForOffer

The user isn't eligible for the offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case ineligibleForOffer

## See Also

### Getting Purchase Error Codes

`case invalidOfferIdentifier`

The promotional offer identifier provided in the purchase options is invalid.

`case productUnavailable`

The product isn’t available.

`case purchaseNotAllowed`

The user isn’t allowed to make purchases.

`case invalidOfferPrice`

The price of the offer isn't valid.

`case invalidOfferSignature`

The offer signature isn't valid.

`case invalidQuantity`

The quantity to purchase is invalid.

`case missingOfferParameters`

The offer parameters are missing.

Enumeration Case

# Product.PurchaseError.invalidOfferPrice

The price of the offer isn't valid.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidOfferPrice

## See Also

### Getting Purchase Error Codes

`case invalidOfferIdentifier`

The promotional offer identifier provided in the purchase options is invalid.

`case productUnavailable`

The product isn’t available.

`case purchaseNotAllowed`

The user isn’t allowed to make purchases.

`case ineligibleForOffer`

The user isn't eligible for the offer.

`case invalidOfferSignature`

The offer signature isn't valid.

`case invalidQuantity`

The quantity to purchase is invalid.

`case missingOfferParameters`

The offer parameters are missing.

Enumeration Case

# Product.PurchaseError.invalidOfferSignature

The offer signature isn't valid.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidOfferSignature

## See Also

### Getting Purchase Error Codes

`case invalidOfferIdentifier`

The promotional offer identifier provided in the purchase options is invalid.

`case productUnavailable`

The product isn’t available.

`case purchaseNotAllowed`

The user isn’t allowed to make purchases.

`case ineligibleForOffer`

The user isn't eligible for the offer.

`case invalidOfferPrice`

The price of the offer isn't valid.

`case invalidQuantity`

The quantity to purchase is invalid.

`case missingOfferParameters`

The offer parameters are missing.

Enumeration Case

# Product.PurchaseError.invalidQuantity

The quantity to purchase is invalid.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidQuantity

## See Also

### Getting Purchase Error Codes

`case invalidOfferIdentifier`

The promotional offer identifier provided in the purchase options is invalid.

`case productUnavailable`

The product isn’t available.

`case purchaseNotAllowed`

The user isn’t allowed to make purchases.

`case ineligibleForOffer`

The user isn't eligible for the offer.

`case invalidOfferPrice`

The price of the offer isn't valid.

`case invalidOfferSignature`

The offer signature isn't valid.

`case missingOfferParameters`

The offer parameters are missing.

Enumeration Case

# Product.PurchaseError.missingOfferParameters

The offer parameters are missing.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case missingOfferParameters

## See Also

### Getting Purchase Error Codes

`case invalidOfferIdentifier`

The promotional offer identifier provided in the purchase options is invalid.

`case productUnavailable`

The product isn’t available.

`case purchaseNotAllowed`

The user isn’t allowed to make purchases.

`case ineligibleForOffer`

The user isn't eligible for the offer.

`case invalidOfferPrice`

The price of the offer isn't valid.

`case invalidOfferSignature`

The offer signature isn't valid.

`case invalidQuantity`

The quantity to purchase is invalid.

Instance Property

# localizedDescription

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var localizedDescription: String { get }

## See Also

### Getting Error Properties

`var errorDescription: String?`

`var failureReason: String?`

`var helpAnchor: String?`

`var recoverySuggestion: String?`

Instance Property

# errorDescription

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var errorDescription: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Getting Error Properties

`var localizedDescription: String`

`var failureReason: String?`

`var helpAnchor: String?`

`var recoverySuggestion: String?`

Instance Property

# failureReason

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var failureReason: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Getting Error Properties

`var localizedDescription: String`

`var errorDescription: String?`

`var helpAnchor: String?`

`var recoverySuggestion: String?`

Instance Property

# helpAnchor

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.4+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var helpAnchor: String? { get }

## See Also

### Getting Error Properties

`var localizedDescription: String`

`var errorDescription: String?`

`var failureReason: String?`

`var recoverySuggestion: String?`

Instance Property

# recoverySuggestion

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var recoverySuggestion: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Getting Error Properties

`var localizedDescription: String`

`var errorDescription: String?`

`var failureReason: String?`

`var helpAnchor: String?`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.PurchaseError, rhs: Product.PurchaseError) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing Errors

`static func == (Product.PurchaseError, Product.PurchaseError) -> Bool`

`var hashValue: Int`

`func hash(into: inout Hasher)`

Operator

# ==(_:_:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.PurchaseError, b: Product.PurchaseError) -> Bool

## See Also

### Comparing Errors

`static func != (Product.PurchaseError, Product.PurchaseError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

`func hash(into: inout Hasher)`

Instance Property

# hashValue

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing Errors

`static func != (Product.PurchaseError, Product.PurchaseError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.PurchaseError, Product.PurchaseError) -> Bool`

`func hash(into: inout Hasher)`

Instance Method

# hash(into:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing Errors

`static func != (Product.PurchaseError, Product.PurchaseError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.PurchaseError, Product.PurchaseError) -> Bool`

`var hashValue: Int`



# Ad network install-validation keys

Global Variable

# SKStoreProductParameterAdNetworkSourceIdentifier

A four-digit integer that ad networks define to represent the ad campaign.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+  tvOS 16.1+

    
    
    let SKStoreProductParameterAdNetworkSourceIdentifier: String

## Discussion

This key is available for ad impressions that use SKAdNetwork 4 and later. The
`SKStoreProductParameterAdNetworkSourceIdentifier`, also known as the
_hierarchical source identifier_ , replaces and extends the campaign
identifier value, `SKStoreProductParameterAdNetworkCampaignIdentifier`.

Ad networks and developers define the meaning of the hierarchical source
identifier. This string represents an integer of up to four digits. You can
encode information about your advertisement in each set of digits; you may
receive two, three, or all four digits of the `sourceIdentifier` in the first
winning postback, depending on the ad impression’s postback data tier. For
more information about the value you may get in the postback, see Receiving
postbacks in multiple conversion windows.

Global Variable

# SKStoreProductParameterAdNetworkVersion

The key that represents the version of the ad network API.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  tvOS 14.0+

    
    
    let SKStoreProductParameterAdNetworkVersion: String

## Discussion

The value for this key is an `NSString`. Set this key to version number
"`4.0`", "`3.0`", "`2.2"`, `“2.1"`, or `"2.0"`. Use the highest available
version whenever possible. For version availability, see SKAdNetwork release
notes.

Ad networks use this key and the other Ad network install-validation keys when
signing ads. For more information, see Generating the signature to validate
StoreKit-rendered ads.

## See Also

### Required keys for SKAdNetwork 2 and later

`let SKStoreProductParameterAdNetworkSourceAppStoreIdentifier: String`

The key that represents the App Store ID of the app that displays the ad.

Global Variable

# SKStoreProductParameterAdNetworkSourceAppStoreIdentifier

The key that represents the App Store ID of the app that displays the ad.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  tvOS 14.0+

    
    
    let SKStoreProductParameterAdNetworkSourceAppStoreIdentifier: String

## Discussion

The value for this key is an `NSNumber`. Provide the App Store item identifier
of the app that’s displaying the ad.

During testing, if you’re using a development-signed build to display the ads
and not an app from App Store, use `0` as the item identifier.

## See Also

### Required keys for SKAdNetwork 2 and later

`let SKStoreProductParameterAdNetworkVersion: String`

The key that represents the version of the ad network API.

Global Variable

# SKStoreProductParameterAdNetworkIdentifier

The key that represents the advertising network’s unique identifier.

iOS 11.3+  iPadOS 11.3+  Mac Catalyst 13.1+  tvOS 11.3+

    
    
    let SKStoreProductParameterAdNetworkIdentifier: String

## Discussion

The value for this key is an `NSString`.

Ad networks obtain an ad network identifier during registration. Ad networks
are responsible for sharing their ad network IDs with participating app
developers. Apps that display ads and need to initiate the app install
validation process must include the ad network ID in their `Info.plist`. For
more information see Registering an ad network and `Configuring Apps`.

## See Also

### Required keys

`let SKStoreProductParameterAdNetworkCampaignIdentifier: String`

The key that represents the advertising network’s campaign.

`let SKStoreProductParameterAdNetworkTimestamp: String`

The key that represents the UNIX time, in milliseconds, of the ad impression.

`let SKStoreProductParameterAdNetworkNonce: String`

The key that represents a random value to use for added security.

`let SKStoreProductParameterAdNetworkAttributionSignature: String`

The key that represents the advertising network’s cryptographic signature to
use for install validation.

Global Variable

# SKStoreProductParameterAdNetworkCampaignIdentifier

The key that represents the advertising network’s campaign.

iOS 11.3+  iPadOS 11.3+  Mac Catalyst 13.1+  tvOS 11.3+

    
    
    let SKStoreProductParameterAdNetworkCampaignIdentifier: String

## Discussion

The value for this key is an `NSNumber`. Ad networks determine their own
campaign identifiers, which must be an integer `>=1` and `<=100`.

Use `SKStoreProductParameterAdNetworkSourceIdentifier` instead of this value
to generate version 4 and later signatures.

## See Also

### Required keys

`let SKStoreProductParameterAdNetworkIdentifier: String`

The key that represents the advertising network’s unique identifier.

`let SKStoreProductParameterAdNetworkTimestamp: String`

The key that represents the UNIX time, in milliseconds, of the ad impression.

`let SKStoreProductParameterAdNetworkNonce: String`

The key that represents a random value to use for added security.

`let SKStoreProductParameterAdNetworkAttributionSignature: String`

The key that represents the advertising network’s cryptographic signature to
use for install validation.

Global Variable

# SKStoreProductParameterAdNetworkTimestamp

The key that represents the UNIX time, in milliseconds, of the ad impression.

iOS 11.3+  iPadOS 11.3+  Mac Catalyst 13.1+  tvOS 11.3+

    
    
    let SKStoreProductParameterAdNetworkTimestamp: String

## Discussion

The value for this key is an `NSNumber`. Ad networks generate the timestamp,
represented as UNIX time in milliseconds, at the time you’re preparing to
serve the ad.

## See Also

### Required keys

`let SKStoreProductParameterAdNetworkIdentifier: String`

The key that represents the advertising network’s unique identifier.

`let SKStoreProductParameterAdNetworkCampaignIdentifier: String`

The key that represents the advertising network’s campaign.

`let SKStoreProductParameterAdNetworkNonce: String`

The key that represents a random value to use for added security.

`let SKStoreProductParameterAdNetworkAttributionSignature: String`

The key that represents the advertising network’s cryptographic signature to
use for install validation.

Global Variable

# SKStoreProductParameterAdNetworkNonce

The key that represents a random value to use for added security.

iOS 11.3+  iPadOS 11.3+  Mac Catalyst 13.1+  tvOS 11.3+

    
    
    let SKStoreProductParameterAdNetworkNonce: String

## Discussion

The value for this key is an `NSUUID`. Ad networks generate a random value for
this key at the time of the ad impression.

Important

When you generate the signature value
(`SKStoreProductParameterAdNetworkAttributionSignature`), you must sign the
nonce as an all-lowercase UUID string representation.

## See Also

### Required keys

`let SKStoreProductParameterAdNetworkIdentifier: String`

The key that represents the advertising network’s unique identifier.

`let SKStoreProductParameterAdNetworkCampaignIdentifier: String`

The key that represents the advertising network’s campaign.

`let SKStoreProductParameterAdNetworkTimestamp: String`

The key that represents the UNIX time, in milliseconds, of the ad impression.

`let SKStoreProductParameterAdNetworkAttributionSignature: String`

The key that represents the advertising network’s cryptographic signature to
use for install validation.

Global Variable

# SKStoreProductParameterAdNetworkAttributionSignature

The key that represents the advertising network’s cryptographic signature to
use for install validation.

iOS 11.3+  iPadOS 11.3+  Mac Catalyst 13.1+  tvOS 11.3+

    
    
    let SKStoreProductParameterAdNetworkAttributionSignature: String

## Discussion

The value for this key is an `NSString`. The ad network creates the
cryptographic signature, used to sign ads. For instructions on generating this
value, see Generating the signature to validate StoreKit-rendered ads.

## See Also

### Required keys

`let SKStoreProductParameterAdNetworkIdentifier: String`

The key that represents the advertising network’s unique identifier.

`let SKStoreProductParameterAdNetworkCampaignIdentifier: String`

The key that represents the advertising network’s campaign.

`let SKStoreProductParameterAdNetworkTimestamp: String`

The key that represents the UNIX time, in milliseconds, of the ad impression.

`let SKStoreProductParameterAdNetworkNonce: String`

The key that represents a random value to use for added security.



# Transaction.Transactions

Instance Method

# makeAsyncIterator()

Creates the asynchronous iterator that produces elements of this asynchronous
sequence.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func makeAsyncIterator() -> Transaction.Transactions.AsyncIterator

## Relationships

### From Protocol

  * `AsyncSequence`

## See Also

### Creating an Iterator

`struct Transaction.Transactions.AsyncIterator`

The asynchronous iterator that produces elements of the asynchronous sequence.

`typealias Transaction.Transactions.Element`

The type of element traversed by the iterator.

Type Alias

# Transaction.Transactions.Element

The type of element traversed by the iterator.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Transaction.Transactions.Element = VerificationResult<Transaction>

## See Also

### Creating an Iterator

`func makeAsyncIterator() -> Transaction.Transactions.AsyncIterator`

Creates the asynchronous iterator that produces elements of this asynchronous
sequence.

`struct Transaction.Transactions.AsyncIterator`

The asynchronous iterator that produces elements of the asynchronous sequence.

Instance Method

# allSatisfy(_:)

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func allSatisfy(_ predicate: (VerificationResult<Transaction>) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
satisfies a condition.

## Return Value

`true` if the sequence contains only elements that satisfy `predicate`;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether all
elements produced by the sequence are less than `10`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate returns `false` or the sequence ends.

If the asynchronous sequence is empty, this method returns `true`.

## See Also

### Finding Transactions

`func contains(VerificationResult<Transaction>) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (VerificationResult<Transaction>) -> Bool) ->
VerificationResult<Transaction>?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(_:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(_ search: VerificationResult<Transaction>) async rethrows -> Bool

##  Parameters

`search`

    

The element to find in the asynchronous sequence.

## Return Value

`true` if the method found the element in the asynchronous sequence;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(_:)` method checks to see whether the
sequence produces the value `5`:

## See Also

### Finding Transactions

`func allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (VerificationResult<Transaction>) -> Bool) ->
VerificationResult<Transaction>?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(where:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(where predicate: (VerificationResult<Transaction>) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
represents a match.

## Return Value

`true` if the sequence contains an element that satisfies predicate;
otherwise, `false`.

## Discussion

You can use the predicate to check for an element of a type that doesn’t
conform to the `Equatable` protocol, or to find an element that satisfies a
general condition.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(where:)` method checks to see whether
the sequence produces a value divisible by `3`:

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Finding Transactions

`func allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(VerificationResult<Transaction>) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func first(where: (VerificationResult<Transaction>) -> Bool) ->
VerificationResult<Transaction>?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# first(where:)

Returns the first element of the sequence that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func first(where predicate: (VerificationResult<Transaction>) async throws -> Bool) async rethrows -> VerificationResult<Transaction>?

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the element is a match.

## Return Value

The first element of the sequence that satisfies `predicate`, or `nil` if
there is no element that satisfies `predicate`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `first(where:)` method returns the first member
of the sequence that’s evenly divisible by both `2` and `3`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Finding Transactions

`func allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(VerificationResult<Transaction>) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func max(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# max(by:)

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func max(by areInIncreasingOrder: (VerificationResult<Transaction>, VerificationResult<Transaction>) async throws -> Bool) async rethrows -> VerificationResult<Transaction>?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `max(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Finding Transactions

`func allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(VerificationResult<Transaction>) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (VerificationResult<Transaction>) -> Bool) ->
VerificationResult<Transaction>?`

Returns the first element of the sequence that satisfies the given predicate.

`func min(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# min(by:)

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func min(by areInIncreasingOrder: (VerificationResult<Transaction>, VerificationResult<Transaction>) async throws -> Bool) async rethrows -> VerificationResult<Transaction>?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `min(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Finding Transactions

`func allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(VerificationResult<Transaction>) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (VerificationResult<Transaction>) -> Bool) ->
VerificationResult<Transaction>?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (VerificationResult<Transaction>,
VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# prefix(_:)

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func prefix(_ count: Int) -> AsyncPrefixSequence<Transaction.Transactions>

##  Parameters

`count`

    

The maximum number of elements to return. The value of `count` must be greater
than or equal to zero.

## Return Value

An asynchronous sequence starting at the beginning of the base sequence with
at most `count` elements.

## Discussion

Use `prefix(_:)` to reduce the number of elements produced by the asynchronous
sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(_:)` method causes the modified sequence
to pass through the first six values, then end.

If the count passed to `prefix(_:)` exceeds the number of elements in the base
sequence, the result contains all of the elements in the sequence.

## See Also

### Selecting Transactions

`func prefix(while: (VerificationResult<Transaction>) -> Bool) ->
AsyncPrefixWhileSequence<Transaction.Transactions>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

Instance Method

# prefix(while:)

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func prefix(while predicate: @escaping @Sendable (VerificationResult<Transaction>) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Transaction.Transactions>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether the element should be included in the modified sequence.

## Return Value

An asynchronous sequence of the initial, consecutive elements that satisfy
`predicate`.

## Discussion

Use `prefix(while:)` to produce values while elements from the base sequence
meet a condition you specify. The modified sequence ends when the predicate
closure returns `false`.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(while:)` method causes the modified
sequence to pass along values so long as they aren’t divisible by `2` and `3`.
Upon reaching `6`, the sequence ends:

## See Also

### Selecting Transactions

`func prefix(Int) -> AsyncPrefixSequence<Transaction.Transactions>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

Instance Method

# drop(while:)

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func drop(while predicate: @escaping @Sendable (VerificationResult<Transaction>) async -> Bool) -> AsyncDropWhileSequence<Transaction.Transactions>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether to drop the element from the modified sequence.

## Return Value

An asynchronous sequence that skips over values from the base sequence until
the provided closure returns `false`.

## Discussion

Use `drop(while:)` to omit elements from an asynchronous sequence until the
element received meets a condition you specify.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `drop(while:)` method causes the modified
sequence to ignore received values until it encounters one that is divisible
by `3`:

After the predicate returns `false`, the sequence never executes it again, and
from then on the sequence passes through elements from its underlying sequence
as-is.

## See Also

### Excluding Transactions

`func dropFirst(Int) -> AsyncDropFirstSequence<Transaction.Transactions>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

`func filter((VerificationResult<Transaction>) -> Bool) ->
AsyncFilterSequence<Transaction.Transactions>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

Instance Method

# dropFirst(_:)

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Transaction.Transactions>

##  Parameters

`count`

    

The number of elements to drop from the beginning of the sequence. `count`
must be greater than or equal to zero.

## Return Value

An asynchronous sequence that drops the first `count` elements from the base
sequence.

## Discussion

Use `dropFirst(_:)` when you want to drop the first _n_ elements from the base
sequence and pass through the remaining elements.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `dropFirst(_:)` method causes the modified
sequence to ignore the values `1` through `3`, and instead emit `4` through
`10`:

If the number of elements to drop exceeds the number of elements in the
sequence, the result is an empty sequence.

## See Also

### Excluding Transactions

`func drop(while: (VerificationResult<Transaction>) -> Bool) ->
AsyncDropWhileSequence<Transaction.Transactions>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

`func filter((VerificationResult<Transaction>) -> Bool) ->
AsyncFilterSequence<Transaction.Transactions>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

Instance Method

# filter(_:)

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func filter(_ isIncluded: @escaping @Sendable (VerificationResult<Transaction>) async -> Bool) -> AsyncFilterSequence<Transaction.Transactions>

##  Parameters

`isIncluded`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether to include the element in
the filtered sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements of the base
sequence that satisfy the given predicate.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `filter(_:)` method returns `true` for even
values and `false` for odd values, thereby filtering out the odd values:

## See Also

### Excluding Transactions

`func drop(while: (VerificationResult<Transaction>) -> Bool) ->
AsyncDropWhileSequence<Transaction.Transactions>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

`func dropFirst(Int) -> AsyncDropFirstSequence<Transaction.Transactions>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (VerificationResult<Transaction>) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns a transformed value of the same or of a
different type. If `transform` throws an error, the sequence ends.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure. The sequence ends either when the base
sequence ends or when `transform` throws an error.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Since there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence. When the value is `5`, the closure throws `MyError`,
terminating the sequence.

## See Also

### Transforming a Sequence

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncThrowingMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, VerificationResult<Transaction>) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
VerificationResult<Transaction>) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (VerificationResult<Transaction>) async -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Because there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence.

## See Also

### Transforming a Sequence

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncThrowingMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, VerificationResult<Transaction>) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
VerificationResult<Transaction>) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (VerificationResult<Transaction>) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns an `AsyncSequence`. If `transform`
throws an error, the sequence ends.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`. The sequence ends either
when the last sequence created from the last element from base sequence ends,
or when `transform` throws an error.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`. However, when
the closure receives `4`, it throws an error, terminating the sequence.

## See Also

### Transforming a Sequence

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncThrowingMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, VerificationResult<Transaction>) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
VerificationResult<Transaction>) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (VerificationResult<Transaction>) async -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns an `AsyncSequence`.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`.

## See Also

### Transforming a Sequence

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncThrowingMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, VerificationResult<Transaction>) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
VerificationResult<Transaction>) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (VerificationResult<Transaction>) async throws -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.
`transform` can also throw an error, which ends the transformed sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces.
Also, the dictionary doesn’t provide a key for `4`, and the closure throws an
error for any key it can’t look up, so receiving this value from `Counter`
ends the modified sequence with an error.

## See Also

### Transforming a Sequence

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, VerificationResult<Transaction>) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
VerificationResult<Transaction>) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (VerificationResult<Transaction>) async -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces:

## See Also

### Transforming a Sequence

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncThrowingMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, VerificationResult<Transaction>) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
VerificationResult<Transaction>) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(_:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        _ initialResult: Result,
        _ nextPartialResult: (Result, VerificationResult<Transaction>) async throws -> Result
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure runs.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(_:_:)` method to produce a single value from the elements of
an entire sequence. For example, you can use this method on an sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `4`. The `reduce(_:_:)` method sums the values received
from the asynchronous sequence.

## See Also

### Transforming a Sequence

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncThrowingMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(into: Result, (inout Result,
VerificationResult<Transaction>) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(into:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        into initialResult: Result,
        _ updateAccumulatingResult: (inout Result, VerificationResult<Transaction>) async throws -> Void
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure executes.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(into:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on a sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

Prefer this method over `reduce(_:_:)` for efficiency when the result is a
copy-on-write type, for example an `Array` or `Dictionary`.

## See Also

### Transforming a Sequence

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((VerificationResult<Transaction>) ->
ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((VerificationResult<Transaction>) ->
SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncThrowingMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((VerificationResult<Transaction>) -> Transformed) ->
AsyncMapSequence<Transaction.Transactions, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func reduce<Result>(Result, (Result, VerificationResult<Transaction>) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.



# SKOverlay.TransitionContext

Instance Method

# addAnimation(_:)

Adds a closure you can use to animate view properties.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+

    
    
    func addAnimation(_ block: @escaping () -> Void)

##  Parameters

`block`

    

A closure that sets animatable view properties and runs on the main thread.

## See Also

### Adding an Animation

`var startFrame: CGRect`

The size and location of the overlay before the transition.

`var endFrame: CGRect`

The size and location of the overlay at the end of the transition.

Instance Property

# startFrame

The size and location of the overlay before the transition.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+

    
    
    var startFrame: CGRect { get }

## See Also

### Adding an Animation

`func addAnimation(() -> Void)`

Adds a closure you can use to animate view properties.

`var endFrame: CGRect`

The size and location of the overlay at the end of the transition.

Instance Property

# endFrame

The size and location of the overlay at the end of the transition.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+

    
    
    var endFrame: CGRect { get }

## See Also

### Adding an Animation

`func addAnimation(() -> Void)`

Adds a closure you can use to animate view properties.

`var startFrame: CGRect`

The size and location of the overlay before the transition.



# SubscriptionStoreControlStyle

Type Property

# automatic

A subscription store control style that resolves its appearance automatically,
based on the current context.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var automatic: AutomaticSubscriptionStoreControlStyle { get }

Available when `Self` is `AutomaticSubscriptionStoreControlStyle`.

## Discussion

You can also use `subscriptionStoreControlStyle(_:)`with `automatic` as the
parameter to construct this style.

## See Also

### Getting built-in subscription store view styles

`static var buttons: ButtonsSubscriptionStoreControlStyle`

A subscription store control style that displays a subscribe button for each
subscription plan.

Available when `Self` is `ButtonsSubscriptionStoreControlStyle`.

`static var picker: PickerSubscriptionStoreControlStyle`

A subscription store control style that displays subscription plans as a
picker control, with a single button to subscribe.

Available when `Self` is `PickerSubscriptionStoreControlStyle`.

`static var prominentPicker: ProminentPickerSubscriptionStoreControlStyle`

A subscription store control style that displays subscription plans as a
prominent picker control, with a single button to subscribe.

Available when `Self` is `ProminentPickerSubscriptionStoreControlStyle`.

Type Property

# buttons

A subscription store control style that displays a subscribe button for each
subscription plan.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var buttons: ButtonsSubscriptionStoreControlStyle { get }

Available when `Self` is `ButtonsSubscriptionStoreControlStyle`.

## Discussion

You can also use `subscriptionStoreControlStyle(_:)`with `buttons` as the
parameter to construct this style.

## See Also

### Getting built-in subscription store view styles

`static var automatic: AutomaticSubscriptionStoreControlStyle`

A subscription store control style that resolves its appearance automatically,
based on the current context.

Available when `Self` is `AutomaticSubscriptionStoreControlStyle`.

`static var picker: PickerSubscriptionStoreControlStyle`

A subscription store control style that displays subscription plans as a
picker control, with a single button to subscribe.

Available when `Self` is `PickerSubscriptionStoreControlStyle`.

`static var prominentPicker: ProminentPickerSubscriptionStoreControlStyle`

A subscription store control style that displays subscription plans as a
prominent picker control, with a single button to subscribe.

Available when `Self` is `ProminentPickerSubscriptionStoreControlStyle`.

Type Property

# picker

A subscription store control style that displays subscription plans as a
picker control, with a single button to subscribe.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var picker: PickerSubscriptionStoreControlStyle { get }

Available when `Self` is `PickerSubscriptionStoreControlStyle`.

## Discussion

You can also use `subscriptionStoreControlStyle(_:)`with `picker` as the
parameter to construct this style.

## See Also

### Getting built-in subscription store view styles

`static var automatic: AutomaticSubscriptionStoreControlStyle`

A subscription store control style that resolves its appearance automatically,
based on the current context.

Available when `Self` is `AutomaticSubscriptionStoreControlStyle`.

`static var buttons: ButtonsSubscriptionStoreControlStyle`

A subscription store control style that displays a subscribe button for each
subscription plan.

Available when `Self` is `ButtonsSubscriptionStoreControlStyle`.

`static var prominentPicker: ProminentPickerSubscriptionStoreControlStyle`

A subscription store control style that displays subscription plans as a
prominent picker control, with a single button to subscribe.

Available when `Self` is `ProminentPickerSubscriptionStoreControlStyle`.

Type Property

# prominentPicker

A subscription store control style that displays subscription plans as a
prominent picker control, with a single button to subscribe.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
Xcode 15.0+

    
    
    static var prominentPicker: ProminentPickerSubscriptionStoreControlStyle { get }

Available when `Self` is `ProminentPickerSubscriptionStoreControlStyle`.

## Discussion

You can also use `subscriptionStoreControlStyle(_:)`with `prominentPicker` as
the parameter to construct this style.

## See Also

### Getting built-in subscription store view styles

`static var automatic: AutomaticSubscriptionStoreControlStyle`

A subscription store control style that resolves its appearance automatically,
based on the current context.

Available when `Self` is `AutomaticSubscriptionStoreControlStyle`.

`static var buttons: ButtonsSubscriptionStoreControlStyle`

A subscription store control style that displays a subscribe button for each
subscription plan.

Available when `Self` is `ButtonsSubscriptionStoreControlStyle`.

`static var picker: PickerSubscriptionStoreControlStyle`

A subscription store control style that displays subscription plans as a
picker control, with a single button to subscribe.

Available when `Self` is `PickerSubscriptionStoreControlStyle`.

Instance Method

# makeBody(configuration:)

Creates a view that represents the body of a subscription store control.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @ViewBuilder
    func makeBody(configuration: Self.Configuration) -> Self.Body

**Required**

##  Parameters

`configuration`

    

The properties of a subscription store control.

## See Also

### Creating custom subscription store views

`typealias SubscriptionStoreControlStyle.Configuration`

A type that represents the properties of a subscription store control.

`struct SubscriptionStoreControlStyleConfiguration`

The properties of a subscription store view control.

`associatedtype Body`

A view that represents the body of a subscription store control.

**Required**

Type Alias

# SubscriptionStoreControlStyle.Configuration

A type that represents the properties of a subscription store control.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias SubscriptionStoreControlStyle.Configuration = SubscriptionStoreControlStyleConfiguration

## See Also

### Creating custom subscription store views

`func makeBody(configuration: Self.Configuration) -> Self.Body`

Creates a view that represents the body of a subscription store control.

**Required**

` struct SubscriptionStoreControlStyleConfiguration`

The properties of a subscription store view control.

`associatedtype Body`

A view that represents the body of a subscription store control.

**Required**

Structure

# SubscriptionStoreControlStyleConfiguration

The properties of a subscription store view control.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    struct SubscriptionStoreControlStyleConfiguration

## See Also

### Creating custom subscription store views

`func makeBody(configuration: Self.Configuration) -> Self.Body`

Creates a view that represents the body of a subscription store control.

**Required**

` typealias SubscriptionStoreControlStyle.Configuration`

A type that represents the properties of a subscription store control.

`associatedtype Body`

A view that represents the body of a subscription store control.

**Required**

# Body

A view that represents the body of a subscription store control.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    associatedtype Body : View

**Required**

## See Also

### Creating custom subscription store views

`func makeBody(configuration: Self.Configuration) -> Self.Body`

Creates a view that represents the body of a subscription store control.

**Required**

` typealias SubscriptionStoreControlStyle.Configuration`

A type that represents the properties of a subscription store control.

`struct SubscriptionStoreControlStyleConfiguration`

The properties of a subscription store view control.



# Product.SubscriptionPeriod

Instance Property

# value

The number of period units.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let value: Int

## Discussion

Use the value and the unit together to determine the subscription period. For
example, if the `unit` is `Product.SubscriptionPeriod.Unit.month`, and the
`value` is `3`, the subscription period is three months.

## See Also

### Getting the subscription period

`let unit: Product.SubscriptionPeriod.Unit`

The increment of time for the subscription period.

`enum Product.SubscriptionPeriod.Unit`

Units of time that describe subscription periods.

Instance Property

# unit

The increment of time for the subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let unit: Product.SubscriptionPeriod.Unit

## Discussion

The units used to specify a subscription period include day, week, month, and
year, as defined in `Product.SubscriptionPeriod.Unit`.

To calculate the duration of one subscription period, multiply the `unit` by
the number of units (`value`).

## See Also

### Getting the subscription period

`let value: Int`

The number of period units.

`enum Product.SubscriptionPeriod.Unit`

Units of time that describe subscription periods.

Instance Method

# dateRange(referenceDate:)

The calculated date range of a subscription period, starting at the reference
date.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    func dateRange(referenceDate: Date = .now) -> Range<Date>

##  Parameters

`referenceDate`

    

A date you provide that indicates the lower bound of the returned date range.
The default value is `now`.

## Return Value

The subscription period represented by two dates that are the lower bound and
upper bound of the subscription period.

## Discussion

The date range calculates a single subscription period starting from the date
you provide in `referenceDate`.

For example, if a subscription period is one month, and the `referenceDate` is
February 1, the date range contains February 1 and March 1. If the
`referenceDate` is Feb 15, the date range contains February 15 and March 15.

Use the `dateRange(referenceDate:)` with a `Date.ComponentsFormatStyle` to get
a human-readable string representation of the subscription period.

Get the format style (`Date.ComponentsFormatStyle`) corresponding to product’s
storefront using the `subscriptionPeriodFormatStyle`.

Generic Instance Method

# formatted(_:referenceDate:)

Formats the subscription period using a format style that takes a date range
as an input.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    func formatted<S>(
        _ format: S,
        referenceDate: Date = .now
    ) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Range<Date>

##  Parameters

`format`

    

A format style that has a date range input. The format style for a product is
`subscriptionPeriodFormatStyle`.

`referenceDate`

    

The lower bound date for a date range representing the subscription period.
The default value is `now`.

## Discussion

## See Also

### Formatting the subscription period

`func formatted<S>(S, referenceDate: Date) -> S.FormatOutput`

Formats the subscription period using a format style that takes a duration as
an input.

Generic Instance Method

# formatted(_:referenceDate:)

Formats the subscription period using a format style that takes a duration as
an input.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func formatted<S>(
        _ format: S,
        referenceDate: Date = .now
    ) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Duration

##  Parameters

`format`

    

A format style that has a duration as an input.

`referenceDate`

    

The starting date of the subscription period. The default value is `now`.

## See Also

### Formatting the subscription period

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) func formatted<S>(S, referenceDate: Date) -> S.FormatOutput`

Formats the subscription period using a format style that takes a date range
as an input.

Instance Property

# debugDescription

A string representation of the subscription period, suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod, rhs: Product.SubscriptionPeriod) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing subscription periods

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionPeriod, b: Product.SubscriptionPeriod) -> Bool

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Instance Property

# value

The number of period units.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let value: Int

## Discussion

Use the value and the unit together to determine the subscription period. For
example, if the `unit` is `Product.SubscriptionPeriod.Unit.month`, and the
`value` is `3`, the subscription period is three months.

## See Also

### Getting the subscription period

`let unit: Product.SubscriptionPeriod.Unit`

The increment of time for the subscription period.

`enum Product.SubscriptionPeriod.Unit`

Units of time that describe subscription periods.

Instance Property

# unit

The increment of time for the subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let unit: Product.SubscriptionPeriod.Unit

## Discussion

The units used to specify a subscription period include day, week, month, and
year, as defined in `Product.SubscriptionPeriod.Unit`.

To calculate the duration of one subscription period, multiply the `unit` by
the number of units (`value`).

## See Also

### Getting the subscription period

`let value: Int`

The number of period units.

`enum Product.SubscriptionPeriod.Unit`

Units of time that describe subscription periods.

Instance Method

# dateRange(referenceDate:)

The calculated date range of a subscription period, starting at the reference
date.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    func dateRange(referenceDate: Date = .now) -> Range<Date>

##  Parameters

`referenceDate`

    

A date you provide that indicates the lower bound of the returned date range.
The default value is `now`.

## Return Value

The subscription period represented by two dates that are the lower bound and
upper bound of the subscription period.

## Discussion

The date range calculates a single subscription period starting from the date
you provide in `referenceDate`.

For example, if a subscription period is one month, and the `referenceDate` is
February 1, the date range contains February 1 and March 1. If the
`referenceDate` is Feb 15, the date range contains February 15 and March 15.

Use the `dateRange(referenceDate:)` with a `Date.ComponentsFormatStyle` to get
a human-readable string representation of the subscription period.

Get the format style (`Date.ComponentsFormatStyle`) corresponding to product’s
storefront using the `subscriptionPeriodFormatStyle`.

Generic Instance Method

# formatted(_:referenceDate:)

Formats the subscription period using a format style that takes a date range
as an input.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    func formatted<S>(
        _ format: S,
        referenceDate: Date = .now
    ) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Range<Date>

##  Parameters

`format`

    

A format style that has a date range input. The format style for a product is
`subscriptionPeriodFormatStyle`.

`referenceDate`

    

The lower bound date for a date range representing the subscription period.
The default value is `now`.

## Discussion

    
    
    // Get a human-readable representation of a subscription period.
    subscriptionPeriod.formatted(product.subscriptionPeriodFormatStyle, referenceDate: /* some date */)
    
    
    

## See Also

### Formatting the subscription period

`func formatted<S>(S, referenceDate: Date) -> S.FormatOutput`

Formats the subscription period using a format style that takes a duration as
an input.

Generic Instance Method

# formatted(_:referenceDate:)

Formats the subscription period using a format style that takes a duration as
an input.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func formatted<S>(
        _ format: S,
        referenceDate: Date = .now
    ) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Duration

##  Parameters

`format`

    

A format style that has a duration as an input.

`referenceDate`

    

The starting date of the subscription period. The default value is `now`.

## See Also

### Formatting the subscription period

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) func formatted<S>(S, referenceDate: Date) -> S.FormatOutput`

Formats the subscription period using a format style that takes a date range
as an input.

Instance Property

# debugDescription

A string representation of the subscription period, suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod, rhs: Product.SubscriptionPeriod) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing subscription periods

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionPeriod, b: Product.SubscriptionPeriod) -> Bool

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Instance Property

# value

The number of period units.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let value: Int

## Discussion

Use the value and the unit together to determine the subscription period. For
example, if the `unit` is `Product.SubscriptionPeriod.Unit.month`, and the
`value` is `3`, the subscription period is three months.

## See Also

### Getting the subscription period

`let unit: Product.SubscriptionPeriod.Unit`

The increment of time for the subscription period.

`enum Product.SubscriptionPeriod.Unit`

Units of time that describe subscription periods.

Instance Property

# unit

The increment of time for the subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let unit: Product.SubscriptionPeriod.Unit

## Discussion

The units used to specify a subscription period include day, week, month, and
year, as defined in `Product.SubscriptionPeriod.Unit`.

To calculate the duration of one subscription period, multiply the `unit` by
the number of units (`value`).

## See Also

### Getting the subscription period

`let value: Int`

The number of period units.

`enum Product.SubscriptionPeriod.Unit`

Units of time that describe subscription periods.

Instance Method

# dateRange(referenceDate:)

The calculated date range of a subscription period, starting at the reference
date.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    func dateRange(referenceDate: Date = .now) -> Range<Date>

##  Parameters

`referenceDate`

    

A date you provide that indicates the lower bound of the returned date range.
The default value is `now`.

## Return Value

The subscription period represented by two dates that are the lower bound and
upper bound of the subscription period.

## Discussion

The date range calculates a single subscription period starting from the date
you provide in `referenceDate`.

For example, if a subscription period is one month, and the `referenceDate` is
February 1, the date range contains February 1 and March 1. If the
`referenceDate` is Feb 15, the date range contains February 15 and March 15.

Use the `dateRange(referenceDate:)` with a `Date.ComponentsFormatStyle` to get
a human-readable string representation of the subscription period.

Get the format style (`Date.ComponentsFormatStyle`) corresponding to product’s
storefront using the `subscriptionPeriodFormatStyle`.

Generic Instance Method

# formatted(_:referenceDate:)

Formats the subscription period using a format style that takes a date range
as an input.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    func formatted<S>(
        _ format: S,
        referenceDate: Date = .now
    ) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Range<Date>

##  Parameters

`format`

    

A format style that has a date range input. The format style for a product is
`subscriptionPeriodFormatStyle`.

`referenceDate`

    

The lower bound date for a date range representing the subscription period.
The default value is `now`.

## Discussion

    
    
    // Get a human-readable representation of a subscription period.
    subscriptionPeriod.formatted(product.subscriptionPeriodFormatStyle, referenceDate: /* some date */)
    
    
    

## See Also

### Formatting the subscription period

`func formatted<S>(S, referenceDate: Date) -> S.FormatOutput`

Formats the subscription period using a format style that takes a duration as
an input.

Generic Instance Method

# formatted(_:referenceDate:)

Formats the subscription period using a format style that takes a duration as
an input.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func formatted<S>(
        _ format: S,
        referenceDate: Date = .now
    ) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Duration

##  Parameters

`format`

    

A format style that has a duration as an input.

`referenceDate`

    

The starting date of the subscription period. The default value is `now`.

## See Also

### Formatting the subscription period

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) func formatted<S>(S, referenceDate: Date) -> S.FormatOutput`

Formats the subscription period using a format style that takes a date range
as an input.

Instance Property

# debugDescription

A string representation of the subscription period, suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod, rhs: Product.SubscriptionPeriod) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing subscription periods

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionPeriod, b: Product.SubscriptionPeriod) -> Bool

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription periods

`static func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) ->
Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# AppTransaction

Type Property

# shared

Gets the App Store-signed app transaction information for the app.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static var shared: VerificationResult<AppTransaction> { get async throws }

## Discussion

Use this property to get a `VerificationResult` that contains the App Store-
signed app transaction information for your app, including the first time the
app launches. StoreKit automatically keeps the app transaction up-to-date.

This property throws an error if the `AppTransaction` isn't available or if
the user isn't authenticated with the App Store. Getting an `AppTransaction`
may require network connectivity.

The following example shows how to get the `AppTransaction`.

If your app fails to get an `AppTransaction` by accessing the `shared`
property, see `refresh()`.

Instance Property

# environment

The server environment that signs the app transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let environment: AppStore.Environment

## See Also

### Getting the environment

`struct AppStore.Environment`

Constants that represent the App Store server environment.

Instance Property

# bundleID

The bundle identifier that the app transaction applies to.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let bundleID: String

## Discussion

The `bundleID` is the bundle identifier string that you entered in Xcode. For
more information, see What is a bundle ID?

## See Also

### Getting app and version info

`let appVersion: String`

The app version that the app transaction applies to.

`let originalAppVersion: String`

The app version that the user originally purchased from the App Store.

`let appID: UInt64?`

The unique identifier the App Store uses to identify the app.

`let appVersionID: UInt64?`

The number that the App Store uses to uniquely identify the version of the
app.

Instance Property

# appVersion

The app version that the app transaction applies to.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let appVersion: String

## Discussion

This value is the version string you entered in Xcode. This value is a
machine-readable string composed of one to three period-separated integers,
such as `10.4.1`.

## See Also

### Getting app and version info

`let bundleID: String`

The bundle identifier that the app transaction applies to.

`let originalAppVersion: String`

The app version that the user originally purchased from the App Store.

`let appID: UInt64?`

The unique identifier the App Store uses to identify the app.

`let appVersionID: UInt64?`

The number that the App Store uses to uniquely identify the version of the
app.

Instance Property

# originalAppVersion

The app version that the user originally purchased from the App Store.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let originalAppVersion: String

## Discussion

Use this value to determine which app version the user first purchased or
downloaded. This value is comparable to the `appVersion` value.

The `originalAppVersion` remains constant and doesn't change when the user
upgrades the app. The string value contains the original value of the
`CFBundleShortVersionString` for apps running in macOS, and the original value
of the `CFBundleVersion` for apps running on all other platforms.

For more information about using the `originalAppVersion`, see Supporting
business model changes by using the app transaction.

## See Also

### Getting app and version info

`let bundleID: String`

The bundle identifier that the app transaction applies to.

`let appVersion: String`

The app version that the app transaction applies to.

`let appID: UInt64?`

The unique identifier the App Store uses to identify the app.

`let appVersionID: UInt64?`

The number that the App Store uses to uniquely identify the version of the
app.

Instance Property

# appID

The unique identifier the App Store uses to identify the app.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let appID: UInt64?

## Discussion

The App Store assigns this value. This value is the app's Apple ID in App
Store Connect. In the `sandbox` and `xcode` environments, this value is `nil`.

## See Also

### Getting app and version info

`let bundleID: String`

The bundle identifier that the app transaction applies to.

`let appVersion: String`

The app version that the app transaction applies to.

`let originalAppVersion: String`

The app version that the user originally purchased from the App Store.

`let appVersionID: UInt64?`

The number that the App Store uses to uniquely identify the version of the
app.

Instance Property

# appVersionID

The number that the App Store uses to uniquely identify the version of the
app.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let appVersionID: UInt64?

## Discussion

The App Store assigns this value. In the `sandbox` and `xcode` environments,
this value is `nil`.

## See Also

### Getting app and version info

`let bundleID: String`

The bundle identifier that the app transaction applies to.

`let appVersion: String`

The app version that the app transaction applies to.

`let originalAppVersion: String`

The app version that the user originally purchased from the App Store.

`let appID: UInt64?`

The unique identifier the App Store uses to identify the app.

Instance Property

# originalPurchaseDate

The date the user originally purchased the app from the App Store.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let originalPurchaseDate: Date

## Discussion

The original purchase date remains the same, even if the user deletes and
reinstalls the app.

## See Also

### Getting purchase dates

`let preorderDate: Date?`

The date the customer placed an order for the app before it’s available in the
App Store.

Instance Property

# preorderDate

The date the customer placed an order for the app before it’s available in the
App Store.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let preorderDate: Date?

## Discussion

This date is present if your app is available for preorder and the customer
places an order before your app is available in the App Store. When your app
becomes available, the App Store fulfills the customer’s order. The
`preorderDate` remains the same.

Use this date to recognize customers who place preorders.

For more infomation about preorders, see Offering Your Apps for Pre-Order.

## See Also

### Getting purchase dates

`let originalPurchaseDate: Date`

The date the user originally purchased the app from the App Store.

Instance Property

# deviceVerification

The device verification value to use to verify whether the app transaction
belongs to the device.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let deviceVerification: Data

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying the app transaction

`let deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

`let signedDate: Date`

The date that the App Store signed the JWS app transaction.

Instance Property

# deviceVerificationNonce

The UUID used to compute the device verification value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let deviceVerificationNonce: UUID

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying the app transaction

`let deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

`let signedDate: Date`

The date that the App Store signed the JWS app transaction.

Instance Property

# signedDate

The date that the App Store signed the JWS app transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let signedDate: Date

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the app
transaction was valid when the App Store signed the transaction.

## See Also

### Verifying the app transaction

`let deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

`let deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Instance Property

# jsonRepresentation

The raw JSON representation of the app transaction information.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var jsonRepresentation: Data { get }

## Discussion

The information contained in the `jsonRepresentation` is the same information
as contained in the properties of the same instance of an `AppTransaction`.

Type Method

# refresh()

Gets the App Store-signed app transaction information from the App Store
server.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func refresh() async throws -> VerificationResult<AppTransaction>

## Return Value

Returns a `VerificationResult` with a single `AppTransaction`.

## Discussion

This method queries the App Store server to refresh the app transaction
information. This method returns a `VerificationResult` that contains the App
Store-signed app transaction information for your app.

Important

Calling `refresh()` displays a system prompt that asks users to authenticate
with their App Store credentials. Call this function only in response to an
explicit user action, like tapping or clicking a button.

Use this method to get an `AppTransaction` in the following cases:

  * The `shared` property throws an error.

  * The `shared` property returns an unverified (`VerificationResult.unverified(_:_:)` ) result.

This method throws an error if the user cancels the authentication prompt, if
there’s no network connectivity, or if the call fails to update the app
transaction.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: AppTransaction, rhs: AppTransaction) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing app transactions

`static func == (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func == (lhs: AppTransaction, rhs: AppTransaction) -> Bool

## See Also

### Comparing and hashing app transactions

`static func != (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing app transactions

`static func != (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing app transactions

`static func != (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Instance Property

# debugDescription

A string represenation of the instance, suitable for debugging.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Type Property

# shared

Gets the App Store-signed app transaction information for the app.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static var shared: VerificationResult<AppTransaction> { get async throws }

## Discussion

Use this property to get a `VerificationResult` that contains the App Store-
signed app transaction information for your app, including the first time the
app launches. StoreKit automatically keeps the app transaction up-to-date.

This property throws an error if the `AppTransaction` isn't available or if
the user isn't authenticated with the App Store. Getting an `AppTransaction`
may require network connectivity.

The following example shows how to get the `AppTransaction`.

    
    
    do {
        let verificationResult = try await AppTransaction.shared
    
    
        switch verificationResult {
        case .verified(let appTransaction):
            // StoreKit verified that the user purchased this app and
            // the properties in the AppTransaction instance.
            // Add your code here.
        case .unverified(let appTransaction, let verificationError):
            // The app transaction didn't pass StoreKit's verification.        
            // Handle unverified app transaction information according
            // to your business model.
            // Add your code here.
        }
    }
    catch {
      // Handle errors.
    }
    
    
    

If your app fails to get an `AppTransaction` by accessing the `shared`
property, see `refresh()`.

Instance Property

# environment

The server environment that signs the app transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let environment: AppStore.Environment

## See Also

### Getting the environment

`struct AppStore.Environment`

Constants that represent the App Store server environment.

Instance Property

# bundleID

The bundle identifier that the app transaction applies to.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let bundleID: String

## Discussion

The `bundleID` is the bundle identifier string that you entered in Xcode. For
more information, see What is a bundle ID?

## See Also

### Getting app and version info

`let appVersion: String`

The app version that the app transaction applies to.

`let originalAppVersion: String`

The app version that the user originally purchased from the App Store.

`let appID: UInt64?`

The unique identifier the App Store uses to identify the app.

`let appVersionID: UInt64?`

The number that the App Store uses to uniquely identify the version of the
app.

Instance Property

# appVersion

The app version that the app transaction applies to.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let appVersion: String

## Discussion

This value is the version string you entered in Xcode. This value is a
machine-readable string composed of one to three period-separated integers,
such as `10.4.1`.

## See Also

### Getting app and version info

`let bundleID: String`

The bundle identifier that the app transaction applies to.

`let originalAppVersion: String`

The app version that the user originally purchased from the App Store.

`let appID: UInt64?`

The unique identifier the App Store uses to identify the app.

`let appVersionID: UInt64?`

The number that the App Store uses to uniquely identify the version of the
app.

Instance Property

# originalAppVersion

The app version that the user originally purchased from the App Store.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let originalAppVersion: String

## Discussion

Use this value to determine which app version the user first purchased or
downloaded. This value is comparable to the `appVersion` value.

The `originalAppVersion` remains constant and doesn't change when the user
upgrades the app. The string value contains the original value of the
`CFBundleShortVersionString` for apps running in macOS, and the original value
of the `CFBundleVersion` for apps running on all other platforms.

For more information about using the `originalAppVersion`, see Supporting
business model changes by using the app transaction.

## See Also

### Getting app and version info

`let bundleID: String`

The bundle identifier that the app transaction applies to.

`let appVersion: String`

The app version that the app transaction applies to.

`let appID: UInt64?`

The unique identifier the App Store uses to identify the app.

`let appVersionID: UInt64?`

The number that the App Store uses to uniquely identify the version of the
app.

Instance Property

# appID

The unique identifier the App Store uses to identify the app.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let appID: UInt64?

## Discussion

The App Store assigns this value. This value is the app's Apple ID in App
Store Connect. In the `sandbox` and `xcode` environments, this value is `nil`.

## See Also

### Getting app and version info

`let bundleID: String`

The bundle identifier that the app transaction applies to.

`let appVersion: String`

The app version that the app transaction applies to.

`let originalAppVersion: String`

The app version that the user originally purchased from the App Store.

`let appVersionID: UInt64?`

The number that the App Store uses to uniquely identify the version of the
app.

Instance Property

# appVersionID

The number that the App Store uses to uniquely identify the version of the
app.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let appVersionID: UInt64?

## Discussion

The App Store assigns this value. In the `sandbox` and `xcode` environments,
this value is `nil`.

## See Also

### Getting app and version info

`let bundleID: String`

The bundle identifier that the app transaction applies to.

`let appVersion: String`

The app version that the app transaction applies to.

`let originalAppVersion: String`

The app version that the user originally purchased from the App Store.

`let appID: UInt64?`

The unique identifier the App Store uses to identify the app.

Instance Property

# originalPurchaseDate

The date the user originally purchased the app from the App Store.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let originalPurchaseDate: Date

## Discussion

The original purchase date remains the same, even if the user deletes and
reinstalls the app.

## See Also

### Getting purchase dates

`let preorderDate: Date?`

The date the customer placed an order for the app before it’s available in the
App Store.

Instance Property

# preorderDate

The date the customer placed an order for the app before it’s available in the
App Store.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let preorderDate: Date?

## Discussion

This date is present if your app is available for preorder and the customer
places an order before your app is available in the App Store. When your app
becomes available, the App Store fulfills the customer’s order. The
`preorderDate` remains the same.

Use this date to recognize customers who place preorders.

For more infomation about preorders, see Offering Your Apps for Pre-Order.

## See Also

### Getting purchase dates

`let originalPurchaseDate: Date`

The date the user originally purchased the app from the App Store.

Instance Property

# deviceVerification

The device verification value to use to verify whether the app transaction
belongs to the device.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let deviceVerification: Data

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying the app transaction

`let deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

`let signedDate: Date`

The date that the App Store signed the JWS app transaction.

Instance Property

# deviceVerificationNonce

The UUID used to compute the device verification value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let deviceVerificationNonce: UUID

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying the app transaction

`let deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

`let signedDate: Date`

The date that the App Store signed the JWS app transaction.

Instance Property

# signedDate

The date that the App Store signed the JWS app transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let signedDate: Date

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the app
transaction was valid when the App Store signed the transaction.

## See Also

### Verifying the app transaction

`let deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

`let deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Instance Property

# jsonRepresentation

The raw JSON representation of the app transaction information.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var jsonRepresentation: Data { get }

## Discussion

The information contained in the `jsonRepresentation` is the same information
as contained in the properties of the same instance of an `AppTransaction`.

Type Method

# refresh()

Gets the App Store-signed app transaction information from the App Store
server.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func refresh() async throws -> VerificationResult<AppTransaction>

## Return Value

Returns a `VerificationResult` with a single `AppTransaction`.

## Discussion

This method queries the App Store server to refresh the app transaction
information. This method returns a `VerificationResult` that contains the App
Store-signed app transaction information for your app.

Important

Calling `refresh()` displays a system prompt that asks users to authenticate
with their App Store credentials. Call this function only in response to an
explicit user action, like tapping or clicking a button.

Use this method to get an `AppTransaction` in the following cases:

  * The `shared` property throws an error.

  * The `shared` property returns an unverified (`VerificationResult.unverified(_:_:)` ) result.

This method throws an error if the user cancels the authentication prompt, if
there’s no network connectivity, or if the call fails to update the app
transaction.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: AppTransaction, rhs: AppTransaction) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing app transactions

`static func == (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func == (lhs: AppTransaction, rhs: AppTransaction) -> Bool

## See Also

### Comparing and hashing app transactions

`static func != (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing app transactions

`static func != (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing app transactions

`static func != (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (AppTransaction, AppTransaction) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Instance Property

# debugDescription

A string represenation of the instance, suitable for debugging.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`



# PickerSubscriptionStoreControlStyle

Type Property

# picker

A subscription store control style that displays subscription plans as a
picker control, with a single button to subscribe.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var picker: PickerSubscriptionStoreControlStyle { get }

Instance Method

# makeBody(configuration:)

Creates a view that represents the body of a picker subscription store.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func makeBody(configuration: PickerSubscriptionStoreControlStyle.Configuration) -> some View

##  Parameters

`configuration`

    

The properties of a picker subscription store control.

## Relationships

### From Protocol

  * `SubscriptionStoreControlStyle`

## See Also

### Creating the style

`typealias PickerSubscriptionStoreControlStyle.Body`

A type that represents the body of a picker subscription store control style.

`init()`

Creates a picker subscription store control style.

Type Alias

# PickerSubscriptionStoreControlStyle.Body

A type that represents the body of a picker subscription store control style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias PickerSubscriptionStoreControlStyle.Body = some View

## Relationships

### From Protocol

  * `SubscriptionStoreControlStyle`

## See Also

### Creating the style

`func makeBody(configuration:
PickerSubscriptionStoreControlStyle.Configuration) -> View`

Creates a view that represents the body of a picker subscription store.

`init()`

Creates a picker subscription store control style.

Initializer

# init()

Creates a picker subscription store control style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init()

## See Also

### Creating the style

`func makeBody(configuration:
PickerSubscriptionStoreControlStyle.Configuration) -> View`

Creates a view that represents the body of a picker subscription store.

`typealias PickerSubscriptionStoreControlStyle.Body`

A type that represents the body of a picker subscription store control style.



# AutomaticProductPlaceholderIcon

Instance Property

# body

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @MainActor
    var body: some View { get }

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing an automatic product placeholder icon

`typealias AutomaticProductPlaceholderIcon.Body`

Type Alias

# AutomaticProductPlaceholderIcon.Body

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias AutomaticProductPlaceholderIcon.Body = some View

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing an automatic product placeholder icon

`var body: View`

Instance Method

# productDescription(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.4+
tvOS 17.0+  watchOS 10.0+  visionOS 1.1+  Xcode 15.0+

    
    
    func productDescription(_ visibility: Visibility) -> some View

Instance Method

# searchPresentationToolbarBehavior(_:)

StoreKit  SwiftUI  iOS 17.1+  iPadOS 17.1+  macOS 14.1+  Mac Catalyst 17.2+
tvOS 17.1+  watchOS 10.1+  visionOS 1.0+  Xcode 14.4+

    
    
    func searchPresentationToolbarBehavior(_ behavior: SearchPresentationToolbarBehavior) -> some View

Instance Method

# subscriptionPromotionalOffer(offer:signature:)

StoreKit  SwiftUI  iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+
tvOS 17.4+  watchOS 10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func subscriptionPromotionalOffer(
        offer: @escaping (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?,
        signature: @escaping (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) async throws -> Product.SubscriptionOffer.Signature
    ) -> some View



# Product.SubscriptionRelationship

Type Property

# all

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static let all: Product.SubscriptionRelationship

## See Also

### Getting subscription relationships

`static let crossgrade: Product.SubscriptionRelationship`

`static let current: Product.SubscriptionRelationship`

`static let downgrade: Product.SubscriptionRelationship`

`static let upgrade: Product.SubscriptionRelationship`

Type Property

# crossgrade

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static let crossgrade: Product.SubscriptionRelationship

## See Also

### Getting subscription relationships

`static let all: Product.SubscriptionRelationship`

`static let current: Product.SubscriptionRelationship`

`static let downgrade: Product.SubscriptionRelationship`

`static let upgrade: Product.SubscriptionRelationship`

Type Property

# current

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static let current: Product.SubscriptionRelationship

## See Also

### Getting subscription relationships

`static let all: Product.SubscriptionRelationship`

`static let crossgrade: Product.SubscriptionRelationship`

`static let downgrade: Product.SubscriptionRelationship`

`static let upgrade: Product.SubscriptionRelationship`

Type Property

# downgrade

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static let downgrade: Product.SubscriptionRelationship

## See Also

### Getting subscription relationships

`static let all: Product.SubscriptionRelationship`

`static let crossgrade: Product.SubscriptionRelationship`

`static let current: Product.SubscriptionRelationship`

`static let upgrade: Product.SubscriptionRelationship`

Type Property

# upgrade

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static let upgrade: Product.SubscriptionRelationship

## See Also

### Getting subscription relationships

`static let all: Product.SubscriptionRelationship`

`static let crossgrade: Product.SubscriptionRelationship`

`static let current: Product.SubscriptionRelationship`

`static let downgrade: Product.SubscriptionRelationship`

Initializer

# init(rawValue:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(rawValue: Int)

## Relationships

### From Protocol

  * `OptionSet`
  * `RawRepresentable`

## See Also

### Creating a subscription relationship

`var rawValue: Int`

Instance Property

# rawValue

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var rawValue: Int

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating a subscription relationship

`init(rawValue: Int)`

Type Alias

# Product.SubscriptionRelationship.ArrayLiteralElement

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias Product.SubscriptionRelationship.ArrayLiteralElement = Product.SubscriptionRelationship

## See Also

### Using type aliases

`typealias Product.SubscriptionRelationship.Element`

`typealias Product.SubscriptionRelationship.RawValue`

Type Alias

# Product.SubscriptionRelationship.Element

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias Product.SubscriptionRelationship.Element = Product.SubscriptionRelationship

## See Also

### Using type aliases

`typealias Product.SubscriptionRelationship.ArrayLiteralElement`

`typealias Product.SubscriptionRelationship.RawValue`

Type Alias

# Product.SubscriptionRelationship.RawValue

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias Product.SubscriptionRelationship.RawValue = Int

## See Also

### Using type aliases

`typealias Product.SubscriptionRelationship.ArrayLiteralElement`

`typealias Product.SubscriptionRelationship.Element`



# ProductViewStyle

Type Property

# automatic

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var automatic: AutomaticProductViewStyle { get }

Available when `Self` is `AutomaticProductViewStyle`.

## See Also

### Getting built-in product view styles

`static var compact: CompactProductViewStyle`

An product view style suitable for layouts where less space is available, or
for displaying more items in a small amount of space.

Available when `Self` is `CompactProductViewStyle`.

`static var large: LargeProductViewStyle`

A product view style suitable for layouts where the in-app purchase content is
prominent.

Available when `Self` is `LargeProductViewStyle`.

`static var regular: RegularProductViewStyle`

A product view style that uses a standard, platform-appropriate layout.

Available when `Self` is `RegularProductViewStyle`.

Type Property

# compact

An product view style suitable for layouts where less space is available, or
for displaying more items in a small amount of space.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  Xcode 15.0+

    
    
    static var compact: CompactProductViewStyle { get }

Available when `Self` is `CompactProductViewStyle`.

## See Also

### Getting built-in product view styles

`static var automatic: AutomaticProductViewStyle`

Available when `Self` is `AutomaticProductViewStyle`.

`static var large: LargeProductViewStyle`

A product view style suitable for layouts where the in-app purchase content is
prominent.

Available when `Self` is `LargeProductViewStyle`.

`static var regular: RegularProductViewStyle`

A product view style that uses a standard, platform-appropriate layout.

Available when `Self` is `RegularProductViewStyle`.

Type Property

# large

A product view style suitable for layouts where the in-app purchase content is
prominent.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
visionOS 1.0+  Xcode 15.0+

    
    
    static var large: LargeProductViewStyle { get }

Available when `Self` is `LargeProductViewStyle`.

## See Also

### Getting built-in product view styles

`static var automatic: AutomaticProductViewStyle`

Available when `Self` is `AutomaticProductViewStyle`.

`static var compact: CompactProductViewStyle`

An product view style suitable for layouts where less space is available, or
for displaying more items in a small amount of space.

Available when `Self` is `CompactProductViewStyle`.

`static var regular: RegularProductViewStyle`

A product view style that uses a standard, platform-appropriate layout.

Available when `Self` is `RegularProductViewStyle`.

Type Property

# regular

A product view style that uses a standard, platform-appropriate layout.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var regular: RegularProductViewStyle { get }

Available when `Self` is `RegularProductViewStyle`.

## See Also

### Getting built-in product view styles

`static var automatic: AutomaticProductViewStyle`

Available when `Self` is `AutomaticProductViewStyle`.

`static var compact: CompactProductViewStyle`

An product view style suitable for layouts where less space is available, or
for displaying more items in a small amount of space.

Available when `Self` is `CompactProductViewStyle`.

`static var large: LargeProductViewStyle`

A product view style suitable for layouts where the in-app purchase content is
prominent.

Available when `Self` is `LargeProductViewStyle`.

Instance Method

# makeBody(configuration:)

Creates a view that represents the body of a product view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @ViewBuilder
    func makeBody(configuration: Self.Configuration) -> Self.Body

**Required**

##  Parameters

`configuration`

    

The properties of a product view style.

## See Also

### Creating custom product views

`typealias ProductViewStyle.Configuration`

A type that represents the properties of a product view style.

`associatedtype Body`

A view that represents the body of a product view.

**Required**

Type Alias

# ProductViewStyle.Configuration

A type that represents the properties of a product view style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias ProductViewStyle.Configuration = ProductViewStyleConfiguration

## See Also

### Creating custom product views

`func makeBody(configuration: Self.Configuration) -> Self.Body`

Creates a view that represents the body of a product view.

**Required**

` associatedtype Body`

A view that represents the body of a product view.

**Required**

# Body

A view that represents the body of a product view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    associatedtype Body : View

**Required**

## See Also

### Creating custom product views

`func makeBody(configuration: Self.Configuration) -> Self.Body`

Creates a view that represents the body of a product view.

**Required**

` typealias ProductViewStyle.Configuration`

A type that represents the properties of a product view style.



# SKOverlayDelegate

Instance Method

# storeOverlayWillStartPresentation(_:transitionContext:)

Indicates that the platform presents an overlay.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    optional func storeOverlayWillStartPresentation(
        _ overlay: SKOverlay,
        transitionContext: SKOverlay.TransitionContext
    )

##  Parameters

`overlay`

    

An overlay object that’s about to appear.

`transitionContext`

    

A context you can use to animate changes to UI components as the overlay
appears.

## Discussion

Use the `transitionContext` parameter to animate updates to the UI on the main
thread. For example, make a `UIImageView` disappear by animating the change of
its opacity to 0% as shown in the following code:

## See Also

### Responding to the Overlay’s Appearance and Disappearance

`func storeOverlayDidFinishPresentation(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform finished presenting an overlay.

`func storeOverlayWillStartDismissal(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform dismisses an overlay.

`func storeOverlayDidFinishDismissal(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that platform finished dismissing an overlay.

`class SKOverlay.TransitionContext`

A context object you can use to animate UI changes while the platform presents
or dismisses an overlay.

Instance Method

# storeOverlayDidFinishPresentation(_:transitionContext:)

Indicates that the platform finished presenting an overlay.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    optional func storeOverlayDidFinishPresentation(
        _ overlay: SKOverlay,
        transitionContext: SKOverlay.TransitionContext
    )

##  Parameters

`overlay`

    

The overlay object that appears.

`transitionContext`

    

A context you can use to animate changes to UI components after the overlay
appears.

## See Also

### Responding to the Overlay’s Appearance and Disappearance

`func storeOverlayWillStartPresentation(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform presents an overlay.

`func storeOverlayWillStartDismissal(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform dismisses an overlay.

`func storeOverlayDidFinishDismissal(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that platform finished dismissing an overlay.

`class SKOverlay.TransitionContext`

A context object you can use to animate UI changes while the platform presents
or dismisses an overlay.

Instance Method

# storeOverlayWillStartDismissal(_:transitionContext:)

Indicates that the platform dismisses an overlay.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    optional func storeOverlayWillStartDismissal(
        _ overlay: SKOverlay,
        transitionContext: SKOverlay.TransitionContext
    )

##  Parameters

`overlay`

    

An overlay object that’s about to disappear.

`transitionContext`

    

The context you can use to animate changes to UI components when the overlay
disappears.

## Discussion

Use the `transitionContext` parameter to animate updates to the UI on the main
thread. For example, make a `UIImageView` appear by animating the change of
its opacity to 100%`,` as shown in the following code:

## See Also

### Responding to the Overlay’s Appearance and Disappearance

`func storeOverlayWillStartPresentation(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform presents an overlay.

`func storeOverlayDidFinishPresentation(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform finished presenting an overlay.

`func storeOverlayDidFinishDismissal(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that platform finished dismissing an overlay.

`class SKOverlay.TransitionContext`

A context object you can use to animate UI changes while the platform presents
or dismisses an overlay.

Instance Method

# storeOverlayDidFinishDismissal(_:transitionContext:)

Indicates that platform finished dismissing an overlay.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    optional func storeOverlayDidFinishDismissal(
        _ overlay: SKOverlay,
        transitionContext: SKOverlay.TransitionContext
    )

##  Parameters

`overlay`

    

An app banner object that disappeared.

`transitionContext`

    

The context you can use to animate changes to UI components when the overlay
disappears.

## See Also

### Responding to the Overlay’s Appearance and Disappearance

`func storeOverlayWillStartPresentation(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform presents an overlay.

`func storeOverlayDidFinishPresentation(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform finished presenting an overlay.

`func storeOverlayWillStartDismissal(SKOverlay, transitionContext:
SKOverlay.TransitionContext)`

Indicates that the platform dismisses an overlay.

`class SKOverlay.TransitionContext`

A context object you can use to animate UI changes while the platform presents
or dismisses an overlay.

Instance Method

# storeOverlayDidFailToLoad(_:error:)

Indicates that an overlay failed to load.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    optional func storeOverlayDidFailToLoad(
        _ overlay: SKOverlay,
        error: any Error
    )

##  Parameters

`overlay`

    

An overlay object that failed to load.

`error`

    

An indication of why the overlay failed to load.

## Discussion

Common cases for a failure when loading an overlay are:

  * Using invalid iTunes identifiers.

  * Trying to present an overlay for media that’s not an app.

  * Trying to present an overlay from an app extension or the simulator.



# Product.SubscriptionInfo.RenewalState

Type Property

# subscribed

The user is currently subscribed.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let subscribed: Product.SubscriptionInfo.RenewalState

## Discussion

An auto-renewable subscription in this state is entitled to service.

## See Also

### Getting the renewal state

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# expired

The subscription expired.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let expired: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# inBillingRetryPeriod

The subscription is in a billing retry period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# inGracePeriod

The subscription is in a billing grace period state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let inGracePeriod: Product.SubscriptionInfo.RenewalState

## Discussion

An auto-renewable subscription in this state is entitled to service.

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# revoked

The App Store has revoked the user’s access to the subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let revoked: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

Instance Property

# localizedDescription

A string containing the localized description of the renewal state.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

Creates a new instance with the specified raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

##  Parameters

`rawValue`

    

The raw value of the renewal state to create.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalState, rhs: Product.SubscriptionInfo.RenewalState) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing renewal states

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing renewal states

`static func != (Product.SubscriptionInfo.RenewalState,
Product.SubscriptionInfo.RenewalState) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing renewal states

`static func != (Product.SubscriptionInfo.RenewalState,
Product.SubscriptionInfo.RenewalState) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# rawValue

The raw value of a renewal state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionInfo.RenewalState.RawValue`

A type that represents the raw value of a renewal state.

Type Alias

# Product.SubscriptionInfo.RenewalState.RawValue

A type that represents the raw value of a renewal state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.RenewalState.RawValue = Int

## See Also

### Accessing the raw value

`let rawValue: Int`

The raw value of a renewal state.

Type Property

# subscribed

The user is currently subscribed.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let subscribed: Product.SubscriptionInfo.RenewalState

## Discussion

An auto-renewable subscription in this state is entitled to service.

## See Also

### Getting the renewal state

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# expired

The subscription expired.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let expired: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# inBillingRetryPeriod

The subscription is in a billing retry period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# inGracePeriod

The subscription is in a billing grace period state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let inGracePeriod: Product.SubscriptionInfo.RenewalState

## Discussion

An auto-renewable subscription in this state is entitled to service.

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# revoked

The App Store has revoked the user’s access to the subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let revoked: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

Instance Property

# localizedDescription

A string containing the localized description of the renewal state.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

Creates a new instance with the specified raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

##  Parameters

`rawValue`

    

The raw value of the renewal state to create.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalState, rhs: Product.SubscriptionInfo.RenewalState) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing renewal states

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing renewal states

`static func != (Product.SubscriptionInfo.RenewalState,
Product.SubscriptionInfo.RenewalState) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing renewal states

`static func != (Product.SubscriptionInfo.RenewalState,
Product.SubscriptionInfo.RenewalState) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# rawValue

The raw value of a renewal state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionInfo.RenewalState.RawValue`

A type that represents the raw value of a renewal state.

Type Alias

# Product.SubscriptionInfo.RenewalState.RawValue

A type that represents the raw value of a renewal state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.RenewalState.RawValue = Int

## See Also

### Accessing the raw value

`let rawValue: Int`

The raw value of a renewal state.

Type Property

# subscribed

The user is currently subscribed.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let subscribed: Product.SubscriptionInfo.RenewalState

## Discussion

An auto-renewable subscription in this state is entitled to service.

## See Also

### Getting the renewal state

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# expired

The subscription expired.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let expired: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# inBillingRetryPeriod

The subscription is in a billing retry period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# inGracePeriod

The subscription is in a billing grace period state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let inGracePeriod: Product.SubscriptionInfo.RenewalState

## Discussion

An auto-renewable subscription in this state is entitled to service.

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# revoked

The App Store has revoked the user’s access to the subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let revoked: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

Instance Property

# localizedDescription

A string containing the localized description of the renewal state.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

Creates a new instance with the specified raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

##  Parameters

`rawValue`

    

The raw value of the renewal state to create.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalState, rhs: Product.SubscriptionInfo.RenewalState) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing renewal states

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing renewal states

`static func != (Product.SubscriptionInfo.RenewalState,
Product.SubscriptionInfo.RenewalState) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing renewal states

`static func != (Product.SubscriptionInfo.RenewalState,
Product.SubscriptionInfo.RenewalState) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# rawValue

The raw value of a renewal state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionInfo.RenewalState.RawValue`

A type that represents the raw value of a renewal state.

Type Alias

# Product.SubscriptionInfo.RenewalState.RawValue

A type that represents the raw value of a renewal state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.RenewalState.RawValue = Int

## See Also

### Accessing the raw value

`let rawValue: Int`

The raw value of a renewal state.

Type Property

# subscribed

The user is currently subscribed.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let subscribed: Product.SubscriptionInfo.RenewalState

## Discussion

An auto-renewable subscription in this state is entitled to service.

## See Also

### Getting the renewal state

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# expired

The subscription expired.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let expired: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# inBillingRetryPeriod

The subscription is in a billing retry period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# inGracePeriod

The subscription is in a billing grace period state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let inGracePeriod: Product.SubscriptionInfo.RenewalState

## Discussion

An auto-renewable subscription in this state is entitled to service.

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let revoked: Product.SubscriptionInfo.RenewalState`

The App Store has revoked the user’s access to the subscription group.

Type Property

# revoked

The App Store has revoked the user’s access to the subscription group.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let revoked: Product.SubscriptionInfo.RenewalState

## See Also

### Getting the renewal state

`static let subscribed: Product.SubscriptionInfo.RenewalState`

The user is currently subscribed.

`static let expired: Product.SubscriptionInfo.RenewalState`

The subscription expired.

`static let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing retry period.

`static let inGracePeriod: Product.SubscriptionInfo.RenewalState`

The subscription is in a billing grace period state.

Instance Property

# localizedDescription

A string containing the localized description of the renewal state.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

Creates a new instance with the specified raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

##  Parameters

`rawValue`

    

The raw value of the renewal state to create.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalState, rhs: Product.SubscriptionInfo.RenewalState) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing renewal states

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing renewal states

`static func != (Product.SubscriptionInfo.RenewalState,
Product.SubscriptionInfo.RenewalState) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing renewal states

`static func != (Product.SubscriptionInfo.RenewalState,
Product.SubscriptionInfo.RenewalState) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# rawValue

The raw value of a renewal state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionInfo.RenewalState.RawValue`

A type that represents the raw value of a renewal state.

Type Alias

# Product.SubscriptionInfo.RenewalState.RawValue

A type that represents the raw value of a renewal state.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.RenewalState.RawValue = Int

## See Also

### Accessing the raw value

`let rawValue: Int`

The raw value of a renewal state.



# Original API for in-app purchase

Article

# Setting up the transaction observer for the payment queue

Enable your app to receive and handle transactions by adding an observer.

## Overview

To process transactions in your app, you need to create and add an observer to
the payment queue. The observer object responds to new transactions and
synchronizes the queue of pending transactions with the App Store, and the
payment queue prompts users to authorize payment. It’s important to add the
transaction observer at app launch to ensure you don't miss payment queue
notifications that the system may send when the app launches.

### Create an observer

Create and build a custom observer class to handle changes to the payment
queue.

Create an instance of this observer class to act as the observer of changes to
the payment queue.

Tip

Consider creating your observer as a shared instance of the class for global
reference in any other class. A shared instance also ensures the lifetime of
the object, so that the same instance handles callbacks for the
`SKPaymentTransactionObserver` protocol.

After you create the transaction observer, you can add it to the payment
queue.

### Add an observer

StoreKit attaches your observer to the queue when your app calls.

StoreKit can notify your `SKPaymentTransactionObserver` instance automatically
when the content of the payment queue changes upon resuming or while running
your app.

Implement the transaction observer.

It’s important to add the observer at launch, in
`application(_:didFinishLaunchingWithOptions:)`, to ensure that it persists
during all launches of your app, receives all payment queue notifications, and
continues transactions that may initiate outside the app, such as:

  * Promoted in-app purchases. For more information, see Promoting in-app purchases.

  * Background subscription renewals

  * Interrupted purchases

The observer needs to be persistent so the system doesn't deallocate it when
it sends the app to the background. Only a persistent observer can receive
transactions that may occur while your app is in the background, such as a
renewal transaction for an auto-renewable subscription.

## See Also

### Essentials

Offering, completing, and restoring in-app purchases

Fetch, display, purchase, validate, and finish transactions in your app.

`class SKPaymentQueue`

A queue of payment transactions for the App Store to process.

`protocol SKPaymentTransactionObserver`

A set of methods that process transactions, unlock purchased functionality,
and continue promoted in-app purchases.

`protocol SKPaymentQueueDelegate`

The protocol that provides information needed to complete transactions.

`class SKRequest`

An abstract class that represents a request to the App Store.

### Related Documentation

`func add(any SKPaymentTransactionObserver)`

Adds an observer to the payment queue.

Article

# Loading in-app product identifiers

Load the unique identifiers for your in-app products to retrieve product
information from the App Store.

## Overview

Implementing an in-app purchase flow consists of three stages. In the first
stage, your app retrieves product information. Then your app requests payment
when the user selects a product in your app’s store. Finally, your app
delivers the product.

To begin the purchase process, your app needs the product identifiers so it
can retrieve information about the products from the App Store and present its
store UI to the user. Every product you sell in your app has a unique product
identifier. You provide this value in App Store Connect when you create a new
in-app purchase product (see Create in-app purchases for more information).
Your app uses these product identifiers to fetch information about products
available for sale in the App Store, such as pricing, and to submit payment
requests when users purchase those products.

There are several strategies for storing a list of product identifiers in your
app, such as embedding them in the app bundle or storing them on your server.
You can then retrieve the product identifiers by reading them locally in the
app bundle or fetching them from your server. Choose the method that best
serves your app’s needs.

Note

There’s no runtime mechanism to fetch a list of the configured products in App
Store Connect for a particular app. You’re responsible for managing your app’s
list of products and providing that information to your app.

### Retrieve product IDs from the app bundle

Embed the product identifiers in your app bundle if:

  * Your app has a fixed list of in-app purchase products. For example, apps with an in-app purchase to remove ads or unlock functionality can embed the product identifier list in the app bundle.

  * You expect users to update the app to see new in-app purchase products.

  * The app or product doesn’t require a server.

Include a property list file in your app bundle containing an array of product
identifiers, such as the following:

    
    
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
     "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <array>
        <string>com.example.level1</string>
        <string>com.example.level2</string>
        <string>com.example.rocket_car</string>
    </array>
    </plist>
    

To get product identifiers from the property list, locate the file in the app
bundle and read it.

### Retrieve product IDs from your server

Store the product identifiers on your server if:

  * You update the list of in-app products frequently, without updating your app. For example, games that support additional levels or characters can fetch the product identifiers list from your server.

  * The products consist of delivered content.

  * Your app or product requires a server.

Host a JSON file on your server with the product identifiers. For example, the
following JSON file contains three product IDs:

    
    
    [
        "com.example.level1",
        "com.example.level2",
        "com.example.rocket_car"
    ]
    

To get product identifiers from your server, fetch and read the JSON file.

Consider versioning the JSON file so future versions of your app can change
its structure without breaking older versions of your app. For example, you
might name the file that uses the old structure `products_v1.json` and the
file that uses a new structure `products_v2.json`. This is especially useful
if your JSON file is more complex than the simple array in the example.

To ensure that your app remains responsive, use a background thread to
download the JSON file and extract the list of product identifiers. To
minimize the data that transfers, use standard HTTP caching mechanisms, such
as the `Last-Modified` and `If-Modified-Since` headers.

After loading all in-app product identifiers, pass them into the product
information request to the App Store. For details on obtaining product
information, see Fetching product information from the App Store.

## See Also

### Product information

Fetching product information from the App Store

Retrieve up-to-date information about the products for sale in your app to
display to your customers.

`class SKProductsRequest`

An object that can retrieve localized information from the App Store about a
specified list of products.

`class SKProductsResponse`

An App Store response to a request for information about a list of products.

`class SKProduct`

Information about a registered product in App Store Connect.

Article

# Fetching product information from the App Store

Retrieve up-to-date information about the products for sale in your app to
display to your customers.

## Overview

To ensure your customers see only products that are available for them to
purchase, query the App Store before displaying your app’s store UI. Compare
the App Store’s list of product identifiers to your local product identifiers.
To retrieve a list of your app’s product identifiers, see Loading in-app
product identifiers.

### Request product information

To query the App Store, create an `SKProductsRequest` and initialize it with a
list of your product identifiers. Keep a strong reference to the request
object; otherwise, the system might deallocate the request before it can
complete.

The products request retrieves information about valid products, along with a
list of invalid product identifiers, and then calls its delegate to process
the result. The delegate needs to implement the `SKProductsRequestDelegate`
protocol to handle the response from the App Store. Here’s a simple
implementation of both pieces of code:

Keep a reference to the array of `SKProduct` objects that the delegate
receives. Use these same product objects to create a payment request when a
user purchases a product.

If the list of products you sell in your app is subject to change, such as
when you add or remove a product from sale, consider creating a custom class
that encapsulates a reference to the product object along with other
information, such as pictures or descriptions that you fetch from your server.
For more information on payment requests, see Requesting a payment from the
App Store.

### Troubleshoot invalid product IDs

Invalid product identifiers in the App Store response to your products request
usually indicate an error in your app’s list of product identifiers. Invalid
product identifiers may also indicate an incorrectly configured product in App
Store Connect. Actionable UI and insightful logging can help you resolve this
type of issue, as follows:

  * In production builds, display your app’s store UI and omit the invalid product.

  * In development builds, display an error to call attention to the issue. 

  * In both production and development builds, use `NSLog` to write a message to the console to record the invalid identifier.

  * If your app fetches the list from your server, you can define a logging mechanism to let your app send the list of invalid identifiers back to your server.

  * Verify that you have a signed Paid Applications Agreement for your developer account. For more information about this agreement, see Sign and update agreements.

For more information about troubleshooting invalid product identifiers, see
`invalidProductIdentifiers`.

## See Also

### Product information

Loading in-app product identifiers

Load the unique identifiers for your in-app products to retrieve product
information from the App Store.

`class SKProductsRequest`

An object that can retrieve localized information from the App Store about a
specified list of products.

`class SKProductsResponse`

An App Store response to a request for information about a list of products.

`class SKProduct`

Information about a registered product in App Store Connect.

Article

# Requesting a payment from the App Store

Submit a payment request to the App Store when a user selects a product to
buy.

## Overview

After you present your app’s store UI, users can make purchases from within
your app. When the user chooses a product, your app creates and submits a
payment request to the App Store.

Implementing an in-app purchase flow consists of three stages. In the first
stage, your app retrieves product information. Then your app requests payment
when the user selects a product in your app’s store. Finally, your app
delivers the products.

### Create a payment request

When the user selects a product to buy, create a payment request using the
corresponding `SKProduct` object and set the quantity if needed, as the code
below shows. The product object comes from the array of products that your
app’s products request returns, as described in Fetching product information
from the App Store.

### Submit a payment request

Submit your payment request to the App Store by adding it to the payment
queue. If you add a payment object to the queue more than once, the system
submits it to the App Store multiple times, charging the user and requiring
your app to deliver the product each time.

For each payment request your app submits, it receives a corresponding
transaction to process. For more information about transactions and the
payment queue, see Processing a transaction.

For auto-renewable subscriptions, you may submit a payment request with a
subscription offer for users you determine eligible to receive an offer. For
more information, see Implementing promotional offers in your app.

## See Also

### Purchases

Processing a transaction

Register a transaction queue observer to get and handle transaction updates
from the App Store.

`class SKPayment`

A request to the App Store to process payment for additional functionality
that your app offers.

`class SKMutablePayment`

A mutable request to the App Store to process payment for additional
functionality that your app offers.

`class SKPaymentTransaction`

An object in the payment queue.

Article

# Processing a transaction

Register a transaction queue observer to get and handle transaction updates
from the App Store.

## Overview

Implementing an in-app purchase flow consists of three stages. In the first
stage, your app retrieves product information. Then your app requests payment
when the user selects a product in your app’s store. Finally, your app
delivers the product.

The App Store calls the transaction queue observer after it processes the
payment request. Your app then records information about the purchase for
future launches, downloads the purchased content, and marks the transaction as
finished.

### Monitor transactions in the queue

The transaction queue plays a central role in letting your app communicate
with the App Store through the StoreKit framework. You add work to the queue
that the App Store needs to act on, such as a payment request for processing.
When the transaction’s state changes, such as when a payment request succeeds,
StoreKit calls the app’s transaction queue observer. You decide which class
acts as the observer. In very small apps, you might handle all the StoreKit
logic in the app delegate, including observing the transaction queue. In most
apps, however, you create a separate class that handles this observer logic,
along with the rest of your app’s store logic. The observer needs to conform
to the `SKPaymentTransactionObserver` protocol.

By adding an observer, your app doesn’t need to constantly poll the status of
its active transactions. Your app uses the transaction queue for payment
requests, to download Apple-hosted content, and to determine when
subscriptions renew.

It’s important to register a transaction queue observer as soon as your app
launches, as the code shows below. For more guidance, see Setting up the
transaction observer for the payment queue.

Make sure that the observer is ready to handle a transaction at any time, not
only after you add a transaction to the queue. For example, if a user buys
something in your app just before entering a tunnel, your app may not be able
to deliver the purchased content if there isn't a network connection. The next
time your app launches, StoreKit calls your transaction queue observer again
so your app can handle the transaction and deliver the purchased content.
Similarly, if your app fails to mark a transaction as finished, StoreKit calls
the observer every time your app launches until the transaction finishes.

Implement the `paymentQueue(_:updatedTransactions:)` method on your
transaction queue observer. StoreKit calls this method when the status of a
transaction changes, such as when a payment request has been processed. The
transaction status tells you what action your app needs to perform, as
described in the table below:

Status| Action to take in your app  
---|---  
`SKPaymentTransactionState.purchasing`| Update your UI to reflect the in-
progress status, and wait for StoreKit to call the method again.  
`SKPaymentTransactionState.deferred`| Update your UI to reflect the deferred
status, and wait for StoreKit to call the method again.  
`SKPaymentTransactionState.failed`| Use the value of the `error` property to
present a message to the user. For a list of error constants, see
`SKErrorDomain`.  
`SKPaymentTransactionState.purchased`| Provide the purchased functionality,
typically by unlocking features or delivering content.  
`SKPaymentTransactionState.restored`| Restore the previously purchased
functionality.  
  
Transactions in the queue can change state in any order. Your app needs to be
ready to work on any active transaction at any time. Act on every transaction
according to its transaction state, as in this example:

### Update the app's UI to reflect transaction changes

To keep your user interface up to date while waiting, the transaction queue
observer can implement optional methods from the
`SKPaymentTransactionObserver` protocol as follows:

  * StoreKit calls the `paymentQueue(_:removedTransactions:)` method when it removes transactions from the queue. In your implementation of this method, remove the corresponding items from your app’s UI. 

  * StoreKit calls the `paymentQueueRestoreCompletedTransactionsFinished(_:)` or `paymentQueue(_:restoreCompletedTransactionsFailedWithError:)` methods when it finishes restoring transactions, depending on whether there is an error. In your implementation of these methods, update your app’s UI to reflect the success or failure.

For successfully processed transactions, validate the receipt associated with
the transaction to verify the items the user purchased, and unlock content
accordingly. For more information on validating receipts serverside, see
Validating receipts with the App Store.

## See Also

### Purchases

Requesting a payment from the App Store

Submit a payment request to the App Store when a user selects a product to
buy.

`class SKPayment`

A request to the App Store to process payment for additional functionality
that your app offers.

`class SKMutablePayment`

A mutable request to the App Store to process payment for additional
functionality that your app offers.

`class SKPaymentTransaction`

An object in the payment queue.

Article

# Choosing a receipt validation technique

Select the type of receipt validation, on the device or on your server, that
works for your app.

## Overview

Note

The receipt isn’t necessary if you use `AppTransaction` to validate the app
download, or `Transaction` to validate in-app purchases. Only use the receipt
if your app uses the Original API for in-app purchase, or needs the receipt to
validate the app download because it can’t use `AppTransaction`.

An App Store receipt provides a record of the sale of an app and any purchases
the person makes within the app. You can authenticate purchased content by
adding receipt validation code to your app or server. Receipt validation
requires an understanding of secure coding techniques to employ a solution
that’s secure and unique to your app.

### Choose a validation technique

There are two ways to verify a receipt’s authenticity:

  * Locally, on the device. Validating receipts locally requires code that reads and validates a binary file that Apple encodes and signs as a PKCS #7 container. For more information, see Validating receipts on the device. 

  * On your server with the App Store. Validating receipts with the App Store requires secure connections between your app and your server, and between your server and the App Store. For more information, see Validating receipts with the App Store.

Compare the approaches and determine the method that best fits your app and
your infrastructure. You can also choose to implement both approaches. For
managing auto-renewable subscriptions, see the following table for the key
advantages that server-side receipt validation provides over on-device receipt
validation:

Capability| On-device validation| Server-side validation  
---|---|---  
Validates authenticity of receipt| Yes| Yes  
Includes subscription renewal transactions| Yes| Yes  
Includes additional subscription information| No| Yes  
Resistant to device clock change| No| Yes  
  
Receipts contain non-consumable in-app purchases, auto-renewable
subscriptions, and non-renewing subscriptions indefinitely. Consumable in-app
purchases remain in the receipt until you call `finishTransaction(_:)`. You
may choose to maintain and manage records of consumable in-app purchases on
your server.

### Get the latest receipt

The App Store updates receipts immediately after completed purchases. When you
call verifyReceipt from your server, the App Store returns the latest
transaction information, regardless of the contents of the receipt you send in
the request.

On the device, the system updates the receipt immediately when it has an
internet connection, and any of the following occur:

  * The customer completes an in-app purchase.

  * The app launches its transaction observer (`SKPaymentTransactionObserver`) and has unfinished transactions or subscription renewals.

  * The app calls `restoreCompletedTransactions()` or `restoreCompletedTransactions(withApplicationUsername:)` to restore transactions.

  * The app sends a request to `SKReceiptRefreshRequest` to get a receipt if the receipt is invalid or missing.

Transactions can also occur at times when the app isn’t running. When
necessary, call `restoreCompletedTransactions()` to ensure the receipt you’re
working with is up-to-date. For example, if a customer purchases an auto-
renewable subscription on another device, call this method to get those
transactions and update the receipt.

To ensure that your app receives all transactions, add the transaction
observer, `add(_:)`, at app launch time. For more information, see Setting up
the transaction observer for the payment queue.

Related Sessions from WWDC 2018

Session 705: Engineering Subscriptions

## See Also

### Purchase validation

Validating receipts with the App Store

Verify transactions with the App Store on a secure server.

`var appStoreReceiptURL: URL?`

The file URL for the bundle’s App Store receipt.

`class SKReceiptRefreshRequest`

A request to the App Store to get the app receipt, which represents the user’s
transactions with your app.

Article

# Validating receipts with the App Store

Verify transactions with the App Store on a secure server.

## Overview

Important

The verifyReceipt endpoint is deprecated. To validate receipts on your server,
follow the steps in Validating receipts on the device on your server. To
validate in-app purchases on your server without using receipts, call the App
Store Server API to get Apple-signed transaction and subscription information
for your customers, or verify the `AppTransaction` and `Transaction` signed
data that your app obtains. You can also get the same signed transaction and
subscription information from the App Store Server Notifications V2.

An App Store receipt is a binary encrypted file signed with an Apple
certificate. To read the contents of the encrypted file, you need to pass it
through the verifyReceipt endpoint. The endpoint’s response includes a
readable JSON body. Communication with the App Store is structured as JSON
dictionaries, as defined in RFC 4627. Binary data is Base64-encoded, as
defined in RFC 4648. Validate receipts with the App Store through a secure
server. For information on establishing a secure network connection with the
App Store, see Preventing Insecure Network Connections.

Warning

Don’t call the App Store server verifyReceipt endpoint from your app. You
can’t build a trusted connection between a user’s device and the App Store
directly because you don’t control either end of that connection, which makes
it susceptible to a machine-in-the-middle attack.

### Fetch the receipt data

The app receipt is always present in the production environment on devices
running macOS, iOS, and iPadOS. The app receipt is also always present in
TestFlight on devices running macOS. In the sandbox environment and in
StoreKit Testing in Xcode, the app receipt is present only after the tester
makes the first in-app purchase. If the app calls `SKReceiptRefreshRequest` or
`restoreCompletedTransactions()`, the app receipt is present only if the app
has at least one in-app purchase.

To retrieve the receipt data from the app on the device, use the
`appStoreReceiptURL` method of `Bundle` to locate the app’s receipt, and
encode the data in Base64. Send this Base64-encoded data to your server.

### Send the receipt data to the App Store

On your server, create a JSON object with the `receipt-data`, `password`, and
`exclude-old-transactions` keys detailed in `requestBody`.

Submit this JSON object as the payload of an HTTP POST request. Use the test
environment URL `https://sandbox.itunes.apple.com/verifyReceipt` when testing
your app in the sandbox and while your app is in review. Use the production
URL `https://buy.itunes.apple.com/verifyReceipt` when your app is live in the
App Store. For more information, see verifyReceipt.

Important

Verify your receipt first with the production URL; then verify with the
sandbox URL if you receive a `21007` status code. This approach ensures you
don’t have to switch between URLs while your app is in testing, in review by
App Review, or live in the App Store.

### Parse the response

The App Store’s response payload is a JSON object that contains the keys and
values detailed in `responseBody`.

The `in_app` array contains the non-consumable, non-renewing subscription, and
auto-renewable subscription items that the user previously purchased. Check
the values in the response for these in-app purchase types to verify
transactions as needed.

For auto-renewable subscription items, parse the response to get information
about the currently active subscription period. When you validate the receipt
for a subscription, `latest_receipt` contains the latest encoded receipt,
which is the same as the value for `receipt-data` in the request, and
`latest_receipt_info` contains all the transactions for the subscription,
including the initial purchase and subsequent renewals, but not including any
restores.

You can use these values to check whether an auto-renewable subscription has
expired. Use these values along with the `expiration_intent` subscription
field to get the reason for expiration.

## See Also

### Purchase validation

Choosing a receipt validation technique

Select the type of receipt validation, on the device or on your server, that
works for your app.

`var appStoreReceiptURL: URL?`

The file URL for the bundle’s App Store receipt.

`class SKReceiptRefreshRequest`

A request to the App Store to get the app receipt, which represents the user’s
transactions with your app.

### Related Documentation

App Store Receipts

Validate app and in-app purchase receipts with the App Store.

Instance Property

# appStoreReceiptURL

The file URL for the bundle’s App Store receipt.

iOS 7.0+  iPadOS 7.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+

    
    
    var appStoreReceiptURL: URL? { get }

## Discussion

Note

The receipt isn’t necessary if you use `AppTransaction` to validate the app
download, or `Transaction` to validate in-app purchases. Only use the receipt
if your app uses the Original API for in-app purchase, or needs the receipt to
validate the app download because it can’t use `AppTransaction`.

Use this app bundle property to locate the app receipt if it's present; this
property is `nil` if the receipt isn’t present. In the rare case a receipt is
invalid or missing in an app that a user downloads from the App Store, use
`SKReceiptRefreshRequest` to request a new receipt. For information about
validating receipts, see Choosing a receipt validation technique.

You can’t use the general best practice of weak linking using the
`responds(to:)` method here; the method’s implementation uses the
`doesNotRecognizeSelector(_:)` method.

### Get the receipt in testing environments

Receipts aren't initially present in iOS and iPadOS apps in the sandbox
environment and in Xcode. Apps get a receipt after the tester completes the
first in-app purchase. When your app checks `appStoreReceiptURL` and finds
that it’s `nil`, assume the tester is a new customer and has no access to
premium content. For Mac apps running in TestFlight, the receipt is always
present.

## See Also

### Getting the Standard Bundle Directories

`var resourceURL: URL?`

The file URL of the bundle’s subdirectory containing resource files.

`var executableURL: URL?`

The file URL of the receiver's executable file.

`var privateFrameworksURL: URL?`

The file URL of the bundle’s subdirectory containing private frameworks.

`var sharedFrameworksURL: URL?`

The file URL of the receiver's subdirectory containing shared frameworks.

`var builtInPlugInsURL: URL?`

The file URL of the receiver's subdirectory containing plug-ins.

`func url(forAuxiliaryExecutable: String) -> URL?`

Returns the file URL of the executable with the specified name in the
receiver’s bundle.

`var sharedSupportURL: URL?`

The file URL of the bundle’s subdirectory containing shared support files.

`var resourcePath: String?`

The full pathname of the bundle’s subdirectory containing resources.

`var executablePath: String?`

The full pathname of the receiver's executable file.

`var privateFrameworksPath: String?`

The full pathname of the bundle’s subdirectory containing private frameworks.

`var sharedFrameworksPath: String?`

The full pathname of the bundle’s subdirectory containing shared frameworks.

`var builtInPlugInsPath: String?`

The full pathname of the receiver's subdirectory containing plug-ins.

`func path(forAuxiliaryExecutable: String) -> String?`

Returns the full pathname of the executable with the specified name in the
receiver’s bundle.

`var sharedSupportPath: String?`

The full pathname of the bundle’s subdirectory containing shared support
files.

Article

# Unlocking purchased content

Deliver content to the user after validating the purchase.

## Overview

After a purchase is complete, it’s your responsibility to make sure that you
programmatically make the content available to the user.

### Identify the purchased content

For an in-app purchase product that enables app functionality, such as a
premium subscription, set a Boolean value to enable the code path and update
your user interface as needed. Consult your app's persistent transaction
record to determine the functionality to unlock. Your app needs to update this
Boolean value whenever the user completes a purchase and at app launch. For
information on making a persistent record, see Persisting a purchase.

For example, using the app receipt, your code might look like the following:

Or, using the user defaults system.

After you define the Boolean variable that represents the in-app purchase
content, use the purchase information to enable the appropriate code paths in
your app.

### Deliver associated content

Your app needs to deliver any content associated with the purchased product to
the user. For example, purchasing instruments in a music app requires
delivering the sound files needed to let the user play those instruments. You
can embed that content in your app bundle or download it as necessary. Each
approach has its advantages and disadvantages.

Embed smaller files (up to a few megabytes) in your app, especially if you
expect most users to buy that product. You can make the content in your app
bundle available immediately after the user purchases it. However, to add or
update content in your app bundle, you need to submit an updated version of
your app.

Download larger files only when needed. Separating content from your app
bundle keeps your app’s initial download small. For example, a game can
include the first level in its app bundle and let users download additional
levels as they purchase them. Assuming your app fetches its list of product
identifiers from your server and the information isn’t hard-coded in the app
bundle, you don’t need to resubmit your app to add or update content that your
app downloads.

Note

You can’t patch your app binary or download executable code. Your app needs to
contain all executable code necessary to support all of its functionality when
you submit it. If a new product requires code changes, submit an updated
version of your app.

### Load local content

Load local content using the `NSBundle` class as you load other resources from
your app bundle.

### Download content from your own server

As with all interactions between your app and your server, the details and
process of downloading content from your own server are your responsibility.
The communication consists of, at a minimum, the following steps:

  1. Your app sends the receipt to your server and requests the content.

  2. Your server validates the receipt to establish that the user purchased the content, as described in Validating receipts with the App Store.

  3. Assuming the receipt is valid, your server responds to your app with the content.

Ensure that your app handles errors gracefully. For example, if the device
runs out of disk space during a download, give the user the option to discard
the partial download or to resume the download later when space becomes
available.

Consider the security implications of how you host your content and how your
app communicates with your server. For more information, see Security
Overview.

### Download content using on-demand resources

You can use On-Demand Resources (ODR) for flexibility in downloading data in
your app. ODR is an Apple-hosted service you use to store in-app purchase data
that your app downloads after you verify the user’s purchase using the app
receipt. ODR doesn’t require a call to restore transactions and authenticate
the user to download content hosted on Apple’s server.

### Download hosted content from Apple’s server

Important

`SKDownload` and its related functionality are deprecated. The following
information is for apps that already host content on Apple’s servers and use
`SKDownload`.

Apps can use Apple-hosted content for downloaded files. You create an Apple-
hosted content bundle using the In-App Purchase Content target in Xcode and
submit it to App Store Connect. Apple’s servers store your app’s content using
the same infrastructure that supports other large-scale operations, such as
the App Store. Apple-hosted content automatically downloads in the background
even if your app isn’t running.

If you need to support older versions of iOS or share your server
infrastructure across multiple platforms, you may choose to host your own
content using your own server infrastructure.

When the user purchases a product that has associated Apple-hosted content,
the transaction that passes to your transaction queue observer also includes
an instance of `SKDownload` that lets you download the associated content.

To download the content, add the download objects from the transaction’s
`downloads` property to the transaction queue by calling the `start(_:)`
method of `SKPaymentQueue`. If the value of the `downloads` property is `nil`,
there’s no Apple-hosted content for that transaction. Unlike downloading apps,
downloading content doesn’t automatically require a Wi-Fi connection for
content larger than a certain size. Avoid using cellular networks to download
large files without an explicit action from the user.

Implement the `paymentQueue(_:updatedDownloads:)` method on the transaction
queue observer to respond to changes in a download’s state, such as by
updating progress in your UI. If a download fails, use the information in its
`error` property to present the error to the user.

Ensure that your app handles errors gracefully. For example, if the device
runs out of disk space during a download, give the user the option to discard
the partial download or to resume the download later when space becomes
available.

While the content is downloading, update your user interface using the values
of the `progress` and `timeRemaining` properties. You can use the `pause(_:)`,
`resume(_:)`, and `cancel(_:)` methods of `SKPaymentQueue` from your UI to let
the user control in-progress downloads. Use the `downloadState` property to
determine whether the download completes. Don’t use the `progress` or
`timeRemaining` property of the download object to check its status; these
properties are for updating your UI.

Note

Download all Apple-hosted content before finishing the transaction. After a
transaction is complete, its download objects become unusable.

In iOS, your app can manage the downloaded files. The StoreKit framework saves
these files for you in the `Caches` directory with the backup flag unset.
After the download completes, your app is responsible for moving these files
to the appropriate location. For content that can be deleted if the device
runs out of disk space (and downloaded again later by your app), keep the
files in the `Caches` directory. Otherwise, move the files to the `Documents`
folder and set the flag to exclude them from user backups.

In macOS, the system manages the downloaded files; your app can’t move or
delete them directly. To locate the content after downloading it, use the
`contentURL` property of the download object. To locate the file on subsequent
launches, use the `contentURL(forProductID:)` class method of `SKDownload`. To
delete a file, use the `deleteContent(forProductID:)` class method. For
information about reading the app receipt, see Validating receipts with the
App Store.

## See Also

### Content delivery

Persisting a purchase

Keep a persistent record of a purchase to continue making the product
available as needed.

Finishing a transaction

Finish the transaction to complete the purchase process.

`class SKDownload`

Downloadable content associated with a product.

Deprecated

Article

# Persisting a purchase

Keep a persistent record of a purchase to continue making the product
available as needed.

## Overview

After making a product available, your app needs to make a persistent record
of the purchase. Your app uses that persistent record to continue making the
product available on launch and to restore purchases. Your app’s persistence
strategy depends on the type of products you sell:

  * For non-consumable products and auto-renewable subscriptions, use the app receipt as your persistent record. If the app receipt isn’t available, use the user defaults system or iCloud to keep a persistent record.

  * For non-renewing subscriptions, use iCloud or your own server to keep a persistent record.

  * For consumable products, your app updates its internal state to reflect the purchase. Ensure that the updated state is part of an object that supports state preservation (in iOS) or that you manually preserve the state across app launches (in iOS or macOS). 

When using the user defaults system or iCloud, your app can store a value,
such as a number or Boolean value, or a copy of the transaction receipt. In
macOS, users can edit the user defaults system using the `defaults` command.
Storing a receipt requires more application logic, but protects the persistent
record from tampering.

Note

When persisting with iCloud, your app’s persistent record syncs across
devices, but your app is responsible for downloading any associated content on
other devices.

### Persist purchases using the app receipt

The app receipt contains a record of the user’s purchases, cryptographically
signed by Apple. For more information, see Choosing a receipt validation
technique.

The system adds information about consumable products to the receipt when the
user purchases them, and it remains in the receipt until you finish the
transaction. After you finish the transaction, the system removes this
information the next time it updates the receipt, such as the next time the
user makes a purchase.

The system adds information about all other kinds of purchases to the receipt
when the user purchases the products, and it remains in the receipt
indefinitely.

### Persist a value in user defaults or iCloud

To store information in user defaults or iCloud, set the value for a key.

### Persist purchases using your own server

Send a copy of the receipt to your server, along with credentials or an
identifier, so you can keep track of which receipts belong to a particular
user. For example, let users identify themselves to your server with a user
name and password. Don’t use the `identifierForVendor` property of `UIDevice`.
Different devices have different values for this property, so you can’t use it
to identify and restore purchases that the same user makes on a different
device.

## See Also

### Content delivery

Unlocking purchased content

Deliver content to the user after validating the purchase.

Finishing a transaction

Finish the transaction to complete the purchase process.

`class SKDownload`

Downloadable content associated with a product.

Deprecated

Article

# Finishing a transaction

Finish the transaction to complete the purchase process.

## Overview

Finishing a transaction tells StoreKit that your app completed its workflow to
make a purchase complete. Unfinished transactions remain in the queue until
they’re finished, so be sure to add the transaction queue observer every time
your app launches, to enable your app to finish the transactions. Your app
needs to finish each transaction, whether it succeeds or fails.

Do all of the following before you finish a transaction:

  * Persist the purchase.

  * Deliver, download, or unlock the purchased content.

  * Update your app’s UI so the user can access the product.

To finish the transaction, call the `finishTransaction(_:)` method on the
payment queue.

After you finish a transaction, don’t take any actions on it or do any work to
deliver the product. If any work remains, your app isn’t ready to finish the
transaction.

Important

Don’t call the `finishTransaction(_:)` method before the transaction is
actually complete and attempt to use some other mechanism in your app to track
the transaction as unfinished. StoreKit doesn’t function that way, and doing
that prevents your app from downloading Apple-hosted content and can lead to
other issues.

## See Also

### Content delivery

Unlocking purchased content

Deliver content to the user after validating the purchase.

Persisting a purchase

Keep a persistent record of a purchase to continue making the product
available as needed.

`class SKDownload`

Downloadable content associated with a product.

Deprecated

Article

# Handling refund notifications

Respond to notifications about customer refunds for consumable, non-
consumable, and non-renewing subscription products.

## Overview

The App Store server sends near real-time notifications when customers receive
refunds for in-app purchases. If you offer content across multiple platforms,
for example gems or coins for games, and you update player account balances on
your server, receiving refund notifications is important. Respond to refund
notifications by interpreting and handling the refund information, and
informing customers in the app of any actions you take as a result of the
refund.

To enable notifications, see Enabling App Store Server Notifications and App
Store Server Notifications.

### Receive notifications of customer refunds for one-time purchases

Customers request refunds in several ways, such as:

  * Contacting Apple Customer Support and asking for a refund

  * Logging in and using Apple’s self-service tool, reportaproblem.apple.com, to request a refund

  * Asking their payment method issuer for a refund

When the App Store processes a refund, the App Store server sends a `REFUND`
notification to your server, at the URL you configure. Your server must
respond to the post with a 200 response code. The `REFUND` notification
applies to consumable, non-consumable, and non-renewing subscriptions only. To
detect refunds for auto-renewable subscriptions, see Detect a Refund.

### Interpret and handle the refund notification

Your server is responsible for parsing and interpreting all notifications from
the App Store server. For the `REFUND` notification, identify the specific
transaction, product ID, and relevant dates from the response:

  * Find the most recent transaction for the `product_id i`n the `unified_receipt.latest_receipt_info` by checking the `purchase_date` to select the most recent transaction.

  * The date when App Store issued the refund is in the `cancellation_date_ms` field for the transaction.

For more information about the response, see App Store Server Notifications.

You’re responsible to store, monitor, and take appropriate action for each
refunded transaction when you receive a `REFUND` notification. For example,
you might build your own in-game currency-rebalancing logic that handles
refunded transactions by linking a notification to a player account or
session.

Inform customers by presenting contextual messaging in the app for any actions
you take as a result of the refund.

### Identify refund abuse

Reduce refund abuse and identify repeated refunded purchases by mapping
`REFUND` notifications to the player accounts on your server. Monitor and
analyze your data to identify suspicious refund activity.

If you offer content across multiple platforms, keep the balances for user
accounts up to date on your server. Use App Store Server Notifications to get
near real-time status updates for the transactions that affect your customers.

## See Also

### Refunds

Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

Article

# Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

## Overview

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests, which enable your customers to request a refund from within
your app. Your app displays the refund request sheet by calling any of these
methods: `beginRefundRequest(for:in:)` , `beginRefundRequest(in:)`,
`beginRefundRequest(for:in:)`, `beginRefundRequest(in:)`, or
`refundRequestSheet(for:isPresented:onDismiss:)`. Customers fill out the sheet
to submit the request.

Depending on your testing setup, the App Store automatically approves or
declines the refund request in the testing environment. Note that the App
Store doesn’t send emails for refund requests in testing environments.

### Test approved refunds

To set up a test for approved refunds, select any refund reason on the refund
request sheet, and submit the sheet. The App Store automatically approves the
refund request in the testing environment.

Your app receives a `Transaction` with refund information in the
`revocationDate` and `revocationReason` properties. If you’re testing in the
sandbox environment and your server receives App Store Server Notifications V2
for the sandbox, it gets a notification with a `REFUND` `notificationType`.

### Test declined refunds

To set up a test for declined refunds, follow these steps on the refund
request sheet with your app running in the sandbox environment:

  1. Under Issue, select Other.

  2. In the text box, type REJECT.

  3. Tap Request Refund.

The App Store automatically rejects the refund request in the testing
environment.

If your server receives App Store Server Notifications V2 for the sandbox
environment, it gets a notification with a `REFUND_DECLINED`
`notificationType`.

For more information on receiving server notifications for the sandbox
environment, see Enabling App Store Server Notifications. For more information
on testing, see Testing at all stages of development with Xcode and the
sandbox and Setting up StoreKit Testing in Xcode.

## See Also

### Testing in-app purchases

Testing at all stages of development with Xcode and the sandbox

Verify your implementation of in-app purchases by testing your code throughout
its development.

Testing in-app purchases with sandbox

Test your implementation of in-app purchases using real product information
and server-to-server transactions in the sandbox environment.

Article

# Restoring purchased products

Give users functionality that restores their purchases in your app to maintain
access to purchased content.

## Overview

Users sometimes need to restore purchased content, such as when they upgrade
to a new phone. Include some mechanism in your app, such as a Restore
Purchases button, to let them restore their purchases.

Important

Don’t automatically restore purchases, especially when your app launches.
Restoring purchases prompts for the user’s App Store credentials, which
interrupts the flow of your app.

In most cases, you only need to refresh the app receipt and deliver the
products on the receipt. The refreshed receipt contains a record of the user’s
purchases in the app, from any device the user’s App Store account is logged
into. However, an app might require an alternative approach under the given
circumstances:

  * You use Apple-hosted content — Restore completed transactions to give your app the transaction objects it uses to download the content.

  * You need to support your app on devices where the app receipt isn’t available — Restore completed transactions instead.

  * Your app uses non-renewing subscriptions — Your app is responsible for the restoration process.

Refreshing a receipt doesn’t create new transactions; it requests the latest
copy of the receipt from the App Store. Refresh the receipt only once;
refreshing it multiple times in a row has the same result.

Restoring completed transactions creates a new transaction for each previously
completed transaction, essentially replaying history for your transaction
queue observer. Your app maintains its own state to keep track of why it’s
restoring completed transactions and how to handle them. Restoring multiple
times creates multiple restored transactions for each completed transaction.

Note

If the user attempts to purchase a product that they’ve already purchased, the
App Store creates a regular transaction instead of a restore transaction, but
the user isn’t charged again for the product. Unlock the content for these
transactions the same way you do for original transactions.

Give the user an appropriate level of control over the content that’s
downloaded again. For example, don’t automatically download three years of
daily newspapers or hundreds of megabytes of game levels at the same time.

### Refresh the app receipt

Create a receipt refresh request, set a delegate, and start the request. The
request supports optional properties for obtaining receipts in various states,
such as expired receipts, during testing. For details, see the
`init(receiptProperties:)` method of `SKReceiptRefreshRequest`.

After the app receipt refreshes, examine it and deliver any additional
products, as necessary.

### Restore completed transactions

Your app starts restoring completed transactions by calling the
`restoreCompletedTransactions()` method of `SKPaymentQueue`. This call sends a
request to the App Store to restore all of your app’s completed transactions.
If your app sets a value for the `applicationUsername` property of its payment
requests, use the `restoreCompletedTransactions(withApplicationUsername:)`
method to provide the same information when restoring the transactions.

The App Store generates a new transaction to restore each previously completed
transaction. The restored transaction refers to the original transaction.
Instances of `SKPaymentTransaction` have an `original` property, and the
entries in the receipt have an `original_transaction_id` field value.

Note

The date fields have slightly different meanings for restored purchases. For
details, see the `purchase_date` and `original_purchase_date` fields in the
`responseBody.Receipt.In_app`.

StoreKit calls the transaction queue observer with a status of
`SKPaymentTransactionState.restored` for each restored transaction, as
described in Processing a transaction. The action you take depends on your
app’s design.

If your app uses the app receipt and doesn’t have Apple-hosted content, this
code isn’t needed because your app doesn’t restore completed transactions.
Finish any restored transactions immediately.

If your app uses the app receipt and has Apple-hosted content, let the user
select which products to restore before starting the restoration process.
During restoration, download the user-selected content before finishing those
transactions, and finish any other transactions immediately.

If your app doesn’t use the app receipt, it examines all completed
transactions as it restores them. It uses a similar code path to the original
purchase logic to make the product available and then finishes the
transaction. Apps with more than a few products, especially products with
associated content, let the user select which products to restore instead of
restoring everything. These apps keep track of which completed transactions to
process as they restore them, and which transactions to ignore by finishing
them immediately without restoring them.

## See Also

### Providing access to previously purchased products

`class SKReceiptRefreshRequest`

A request to the App Store to get the app receipt, which represents the user’s
transactions with your app.

`class SKRequest`

An abstract class that represents a request to the App Store.

`class SKPaymentTransaction`

An object in the payment queue.

`func SKTerminateForInvalidReceipt()`

Terminates an app if the license to use the app has expired.

Function

# SKTerminateForInvalidReceipt()

Terminates an app if the license to use the app has expired.

iOS 7.1+  iPadOS 7.1+  macOS 10.14+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func SKTerminateForInvalidReceipt()

## See Also

### Providing access to previously purchased products

Restoring purchased products

Give users functionality that restores their purchases in your app to maintain
access to purchased content.

`class SKReceiptRefreshRequest`

A request to the App Store to get the app receipt, which represents the user’s
transactions with your app.

`class SKRequest`

An abstract class that represents a request to the App Store.

`class SKPaymentTransaction`

An object in the payment queue.

Article

# Supporting Family Sharing in your app

Provide service to share subscriptions and non-consumable products to family
members.

## Overview

Family Sharing allows a user to share access to auto-renewable subscriptions
or non-consumables with up to five family members on all of their Apple
devices. Enabling Family Sharing for a subscription can make your content or
service more appealing to subscribers, and may encourage conversion to a paid
subscription, increase user engagement, and improve retention. Developers can
choose to turn on Family Sharing for in-app purchases and non-consumables in
App Store Connect. Users can also choose whether to share their purchases with
family.

When users share a purchase through Family Sharing, each family member gets
their own unique receipts and transactions. Process the transactions in the
same way you already handle purchases — you don’t need any special logic for
shared products. However, you do need to implement a new method in your
transaction observer, and listen for a new notification type in server
notifications. Specifically, to support Family Sharing, you need to:

  * Enable Family Sharing for your in-app purchases in App Store Connect. For more information, see Turn on Family Sharing for in-app purchases. 

  * During runtime, check whether in-app purchases support Family Sharing using either `isFamilyShareable` in `Product` or `isFamilyShareable` in `SKProduct`. Then inform users when merchandising your subscriptions.

  * Process purchased and restored transactions in your app. This is standard processing you already do for any purchases.

  * Implement `paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:)` in your transaction observer to handle conditions in which products are no longer shared.

  * Listen for the `REVOKE` `notification_type` from App Store Server Notifications on your server.

Related Sessions from WWDC20

Session 10661: What's new with in-app purchase

### Enable Family Sharing for in-app purchases

To make Family Sharing available for an in-app purchase, developers need to
turn on Family Sharing in App Store Connect. After you enable Family Sharing
for an in-app purchase, you can’t turn it off. For more information, see Turn
on Family Sharing for in-app purchases.

Users can choose whether to share their purchases with family. As users join
or leave family groups and enable or disable sharing, your app needs to update
the family’s access to your products. For information about how users manage
their Family Sharing choices, see Set Up Family Sharing on iPhone.

### Provide access to shared purchases

Your app receives a unique receipt for each family member entitled to a shared
purchase, on each of their devices. For subscriptions, your app unlocks access
through the normal purchase flow. For non-consumable products, unlocking
access may require users to initiate a restored purchase, depending on the
Family Sharing settings at the time of purchase.

To provide access for family members to a subscription or non-consumable, your
app needs to handle purchased and restored transactions as usual.
Specifically, follow these steps:

  1. Set up a transaction observer at app launch so your app receives transactions that occur outside of your app, such as receiving a Family Sharing purchase. For more information on this best practice, see Setting up the transaction observer for the payment queue.

  2. Verify the receipt. Look for a transaction in the latest receipt info array (`responseBody.Latest_receipt_info`) with the new Family Sharing purchase.

  3. Handle purchased (`SKPaymentTransactionState.purchased`) transactions. This is a standard state apps need to handle, and you don’t need anything special for Family Sharing. For shared subscriptions, the transaction always has a purchased state. For shared non-consumable products, the transaction has a purchased state if Family Sharing was enabled for the product at the time of the purchase. For more information about handling transactions, see Processing a transaction.

  4. Handle restored (`SKPaymentTransactionState.restored`) transactions, which is also a standard state apps need to handle. For shared non-consumable products, your app gets a restored transaction if developers enable Family Sharing after the user purchases the product. To gain access to the shared product, family members use your app’s restore functionality. For more information about restoring, see Restoring purchased products.

  5. Unlock access to the shared subscription or non-consumable product.

  6. Call `finishTransaction(_:)`.

### Revoke access if Family Sharing is disabled

With Family Sharing products, users have access to products only while Family
Sharing is enabled. If the purchaser leaves the group, gets a refund, or stops
sharing, the expectation is that the family’s access to the product stops
immediately.

When a condition occurs that disables sharing, StoreKit informs your app by
updating the receipt, and then calling the
`paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:)` method of the
`SKPaymentTransactionObserver` protocol. Implement this method on your
transaction observer, and do the following:

  1. Verify the receipt. Revoked products appear in the receipt with a `cancellation_date` field present.

  2. Provide the app with access to all the products to which the user is entitled.

For more information, including a list of conditions that trigger this call,
see `paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:)`.

### Listen for the revoke notification

If you set up your server to receive App Store Server Notifications, your
server gets a `REVOKE` `notification_type` as soon as a shared purchase is no
longer shared. This notification serves the same purpose as the
`paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:)`call. Listen for
and process this notification by:

  1. Checking the latest receipt (`unified_receipt.Latest_receipt_info`) in the response body. Revoked products appear in the receipt with a `cancellation_date` field present. 

  2. Providing the app with access to all products to which the user is entitled.

  3. Updating your records, if you keep server-based records to manage your customers' subscriptions.

### Indicate to users when products support Family Sharing

When your app displays in-app purchases, indicate in your UI whether users can
share the product with family. Call `isFamilyShareable` to determine at
runtime whether the in-app purchase supports Family Sharing. Knowing whether a
product is shareable helps users make a selection that best fits their needs.

## See Also

### Family Sharing

`var isFamilyShareable: Bool`

A Boolean value that indicates whether the product is available for Family
Sharing in App Store Connect.

`func paymentQueue(SKPaymentQueue, didRevokeEntitlementsForProductIdentifiers:
[String])`

Tells an observer that the user is no longer entitled to one or more Family
Sharing purchases.

Instance Property

# isFamilyShareable

A Boolean value that indicates whether the product is available for Family
Sharing in App Store Connect.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 14.0+  watchOS
7.0+  visionOS 1.0+

    
    
    var isFamilyShareable: Bool { get }

## Discussion

Check the value of `isFamilyShareable` to learn whether an in-app purchase is
sharable with the family group.

When displaying in-app purchases in your app, indicate whether the product
includes Family Sharing to help customers make a selection that best fits
their needs.

Configure your in-app purchases to allow Family Sharing in App Store Connect.
For more information about setting up Family Sharing, see Turn-on Family
Sharing for in-app purchases.

## See Also

### Getting Product Attributes

`var localizedDescription: String`

A description of the product.

`var localizedTitle: String`

The name of the product.

`var contentVersion: String`

A string that identifies the version of the content.

`var contentLengths: [NSNumber]`

The total size of the content, in bytes.

Deprecated

Instance Method

# paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:)

Tells an observer that the user is no longer entitled to one or more Family
Sharing purchases.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 14.0+  watchOS
7.0+  visionOS 1.0+

    
    
    optional func paymentQueue(
        _ queue: SKPaymentQueue,
        didRevokeEntitlementsForProductIdentifiers productIdentifiers: [String]
    )

##  Parameters

`queue`

    

The payment queue that calls the delegate method.

`productIdentifiers`

    

The list of product identifiers with revoked entitlements.

## Discussion

The system calls this delegate method whenever App Store revokes in-app
purchases for a family member based on changes in Family Sharing, or when the
purchaser gets a refund for an in-app purchase. Implement this method in your
payment queue observer to reestablish a user’s access to products. Revoked
transactions have the `cancellation_date` populated in the receipt.

For products with Family Sharing enabled, the following conditions may trigger
this method in the family member’s app:

  * The purchaser receives a refund for a non-consumable or an auto-renewable subscription they shared.

  * The purchaser leaves the family group in which they were sharing subscriptions or non-consumables.

  * The purchaser disables Family Sharing for a non-consumable or stops sharing a subscription.

  * The purchaser hides an app, which makes their non-consumable purchase unavailable for sharing.

  * The family member leaves the group and no longer gets access to shared purchases.

  * The family organizer stops sharing payment in iCloud family settings. This change affects non-consumables.

By leaving a family group, or disabling sharing in any of the ways listed
above, family members are no longer entitled to family-shared purchases. The
`productIdentifiers` parameter contains the revoked product IDs. Your app
needs to check the receipt on the device, which the system automatically
updates prior to calling this method, and provide the correct level of access
for the in-app purchases.

If you receive App Store Server Notifications, your server receives a
`notificationType` `REVOKE` for the family member when the conditions listed
above occur.

Important

Always check the receipt to determine the users’s correct level of access for
the product. A user may lose access through Family Sharing, but may have
purchased the product directly.

StoreKit also calls this method in the purchaser’s app when the purchaser
receives a refund for a non-consumable or an auto-renewable subscription,
regardless if the product is shared with the family. If you receive App Store
Server Notifications, your server receives a `notificationType` `REFUND` for
the purchaser.

If you use server-side receipt validation with the App Store, call your server
to reprocess the receipt and update your purchase records.

Article

# Promoting in-app purchases

Show promoted in-app purchases on your product page and handle purchases that
users initiate on the App Store.

## Overview

Starting in iOS 11, you can promote in-app purchases on the App Store.

Note

To support promoted in-app purchases in apps with a minimum version of iOS
16.4 and later, use `PurchaseIntent`. For more information, see Supporting
promoted in-app purchases in your app.

Promoted in-app purchases appear on your product page, can appear in search
results, and can appear as featured items on an appropriate tab on the App
Store. Users can start an in-app purchase on the App Store and then transition
to your app to continue the transaction. If your app isn’t installed, they
receive a prompt to download it.

Promoting in-app purchases requires two steps:

  1. In App Store Connect, set up promotions by uploading promotional images. Use the App Store Promotions feature in App Store Connect to manage their order and visibility. For more information about the setup, see Promote in-app purchases.

  2. In your app, implement the delegate method `paymentQueue(_:shouldAddStorePayment:for:)` from the `SKPaymentTransactionObserver` protocol to handle the purchase. 

Important

To enable promoted in-app purchases, your app needs to use either
`PurchaseIntent` (starting in iOS 16.4) or
`paymentQueue(_:shouldAddStorePayment:for:)` (starting in iOS 11). Don’t use
both at the same time. If necessary, use conditional compilation to identify
the OS version the app is running in. For more information, see Running code
on a specific platform or OS version.

To customize the list of promoted in-app purchases for users, you can override
their default order and visibility using `SKProductStorePromotionController`.
Use overrides to show promotions that are relevant to the user. Overrides are
specific to a device, and take effect after the user launches the app at least
once. Using `SKProductStorePromotionController` is optional and isn’t required
for your in-app purchases to appear on the App Store.

For marketing guidance on this feature, see Promoting Your In-App Purchases.

Note

Promoted in-app purchases aren’t available to compatible iPad or iPhone apps
running in visionOS.

### Complete the purchase in the app

When a user selects an in-app product to purchase on the App Store, StoreKit
automatically opens your app and sends the transaction information to the
delegate in the `SKPaymentTransactionObserver` protocol. Your app needs to
complete the purchase transaction and any related actions that are specific to
it.

In the delegate method, return `true` to continue the transaction, or `false`
to defer or cancel it.

If your app isn’t installed when the user selects to purchase the in-app
product, the App Store automatically downloads the app or prompts the user to
purchase it. If the installed version of your app is an older version that
doesn’t support in-app purchase promotions, the App Store prompts the user to
upgrade the app.

### Continue the transaction

To continue an in-app purchase transaction, implement the delegate method in
the `SKPaymentTransactionObserver` protocol and return `true`. StoreKit then
displays the payment sheet, and the user can complete the transaction.

### Defer or cancel the transaction

If your app needs to defer or cancel a transaction, return `false`. For
example, you may need to defer a transaction if the user is in the middle of
onboarding, and continue it after they complete the onboarding. Or, you may
need to cancel a transaction if the user has already unlocked the product
they’re trying to buy.

To defer a transaction:

  1. Save the `payment` to use when the app is ready. The payment already contains information about the product. Don’t create a new `SKPayment` with the same product.

  2. Return `false`.

  3. After the user finishes the onboarding or other actions that require a deferral, send the saved payment to the payment queue as you do with a typical in-app purchase.

To cancel a transaction:

  1. Return `false`.

  2. Provide feedback to the user. Although this step is optional, if you don’t provide feedback, the app’s lack of action after the user selects to purchase an in-app product in the App Store may seem like a bug.

### Get visibility settings

To get the visibility settings for a promoted product, call
`fetchStorePromotionVisibility(for:completionHandler:)`, providing the product
information.

### Override visibility settings

For each device, you can decide whether to make in-app purchases visible or
hidden. For example, you may want to hide products the customer already
purchased, and show only the products they can buy.

For example, to hide the Pro Subscription product after a user purchases it,
fetch the product information and update the store promotion controller with
the `.hide` setting, as the following code example shows. The Pro Subscription
promoted in-app purchase no longer appears in the App Store on the device.

### Override the order of promoted products

You can customize the promoted in-app purchases on each device by overriding
their default order. Use overrides to show promotions that are relevant to the
user. For example, you can override the order to promote an in-app purchase
that unlocks a level in your game when a user reaches the preceding level.

To override the promotion order, add the product information to an array in
the order they are to appear. Pass the array to the
`update(storePromotionOrder:completionHandler:)` method. The App Store
displays the products in the array, followed by the remaining promoted
products, which appear in the same relative order that you set in App Store
Connect.

### Cancel order overrides

To remove overrides and use the default promotion order, send an empty product
array to the `update(storePromotionOrder:completionHandler:)` method. The App
Store then displays the promoted in-app purchase products in the default order
that you set in App Store Connect.

### Fetch order overrides

To get the product promotion order for the device, call
`fetchStorePromotionOrder(completionHandler:)`. This method returns an array
of products that have an overridden order. If you get an empty array, there
aren’t any overrides and the products are in the default order.

## See Also

### Promotions

Testing promoted in-app purchases

Test your in-app purchases before making your app available in the App Store.

`class SKProductStorePromotionController`

A product promotion controller for customizing the order and visibility of in-
app purchases per device.

Article

# Testing promoted in-app purchases

Test your in-app purchases before making your app available in the App Store.

## Overview

Users can buy promoted in-app purchases from the App Store, but you need to
test this flow before making your product publicly available. Apple provides a
system URL that triggers your app using the `itms-services://` protocol, so
you can test in-app purchases before they’re available in the App Store.

**Protocol**| `itms-services://`  
---|---  
**Parameter** `action`| `purchaseIntent`  
**Parameter** `bundleId`| The bundle ID for your app; for
example:`com.example.app`  
**Parameter** `productIdentifier`| The in-app purchase product name you want
to test; for example:`product_name`  
  
The resulting URL looks like this:

`itms-
services://?action=purchaseIntent&bundleId=com.example.app&productIdentifier=product_name`

Send this URL to yourself in an email or iMessage, and open it from your
device. You’ll know the test is running when your app opens automatically. You
can then test how your app handles the promoted in-app purchase.

## See Also

### Promoted in-app purchases

Supporting promoted in-app purchases in your app

Display promoted in-app purchases on your product page and handle purchases
that users initiate on the App Store.

`struct PurchaseIntent`

An instance that emits purchase intents, which indicates that the customer
initiated a promoted in-app purchase on the App Store for your app to
complete.

`struct Product.PromotionInfo`

Information about a promoted in-app purchase that customizes its order and
visibility on the device.

Article

# Testing at all stages of development with Xcode and the sandbox

Verify your implementation of in-app purchases by testing your code throughout
its development.

## Overview

Use the Apple sandbox and Xcode test environments to test your implementation
of in-app purchases using the StoreKit framework. Comprehensive testing can
help you:

  * Ensure a seamless purchase flow to provide a positive customer experience in your app.

  * Implement sound logic that covers all scenarios, such as purchases, restores, and subscription offers.

  * Validate that purchases behave correctly in production after your app is available in the App Store.

The tools you need to test in-app purchases, non-renewing subscriptions, and
auto-renewable subscriptions from early development through beta testing are:

StoreKit Testing in Xcode

    

For early development, continuous integration, and debugging. For more
information, see StoreKit Test.

Sandbox

    

For testing scenarios using in-app purchase data you set up in App Store
Connect. For more information, see Testing in-app purchases with sandbox.

TestFlight

    

For managing beta testing with internal and external testers. TestFlight uses
a beta build of your app or App Clip that you upload to App Store Connect. For
more information, see Beta Testing Made Simple with TestFlight.

Choose the tools that support the test scenarios you need. Make sure you’re
able to perform the setup required for the tools you choose.

During the early stages of development, you may not be ready to configure in-
app purchases in App Store Connect. StoreKit Testing in Xcode lets you
configure the information locally. You can test StoreKit transactions before
you create Sandbox Apple IDs, without a network connection. You can test your
app in Simulator or on real devices.

After you set up in-app purchases in App Store Connect, start using the
sandbox environment to test the product information your app will use in
production. Testing in the sandbox lets you test transactions from end-to-end
and from your app to your server. You can also test any server-to-server
functionalities your app depends on, such as transaction validation and App
Store Server Notifications.

TestFlight lets you get feedback from members of your team or from external
testers. TestFlight uses the sandbox environment for in-app purchases.
Transactions and purchases that occur in the sandbox don’t incur charges. The
following table compares the test environments and features:

Test environment| Requires App Store Connect setup| Provides receipts and JSON
Web Signature (JWS) transactions signed by the App Store| Provides
subscription renewal information signed by the App Store  
---|---|---|---  
StoreKit Testing in Xcode| No| No (signed by Xcode)| No (signed by Xcode)  
Sandbox| Yes| Yes| Yes  
TestFlight (uses the sandbox)| Yes| Yes| Yes  
  
None of the test environments charge users when they test buying a product.
The App Store doesn’t send emails for purchases or refunds made in the test
environments.

### Control the test environment

To set up and run test scenarios, you often need to control the test
environment. For example, you may want to reset a test account to rerun the
same test multiple times, or mimic actions users take outside your app that
affect the test conditions. The following table shows the capabilities each
tool has to control the test environment:

Test scenario| Sandbox| StoreKit Testing in Xcode  
---|---|---  
Test different storefronts to affect price tiers and locale| Yes| Limited (no
price tiers)  
Clear the purchase history| Yes| Yes  
Test subscription upgrades, downgrades, cross-grades, and auto-renew
cancellations| Yes| Yes  
Reset eligibility for introductory offers| Yes| Yes  
Introduce forced StoreKit errors for testing| No| Yes  
Speed up or slow down the rate of time for testing subscription renewals| Yes|
Yes  
  
For more information about speeding up renewal periods for testing, see Test
in-app purchases.

### Test common StoreKit scenarios

All apps that offer in-app purchases need to support restoring purchases,
displaying in-app purchases to the customer, and handling basic transactions.
The following table lists common test scenarios and whether they’re testable
in the sandbox or Xcode:

Test scenario| Sandbox| StoreKit Testing in Xcode  
---|---|---  
Restore purchases| Yes| Yes  
Finish a transaction with `finish()` or `finishTransaction(_:)`| Yes| Yes  
Buy a consumable or non-consumable in-app purchase| Yes| Yes  
Repurchase a non-consumable purchase for repeated testing| Yes| Yes  
Purchase an auto-renewable subscription| Yes| Yes  
Purchase a non-renewing subscription| Yes| Yes  
Refund an in-app purchase| Yes| Yes  
Test an interrupted purchase, where the user must complete actions outside the
app| Yes| Yes  
Test a failed purchase attempt when payment authorization fails| No| Yes  
Retrieve configured in-app purchases from App Store Connect| Yes| Yes
(optionally); can also retrieve data from a StoreKit configuration file  
Manage subscriptions within your app with `showManageSubscriptions(in:)` and
`manageSubscriptionsSheet(isPresented:)`| Yes| Yes  
Initiate a refund request. For more information, see Testing refund requests.|
Yes| Yes  
  
### Test subscriptions and Ask to Buy

Depending on the in-app purchases your app offers, you may need to test
scenarios that involve auto-renewing subscriptions, introductory offers,
promotional offers, and Ask to Buy. The following table lists test scenarios
and whether they’re testable in the sandbox or Xcode:

Test scenario| Sandbox| StoreKit Testing in Xcode  
---|---|---  
Initiate an Ask to Buy transaction that results in a deferred state| Yes| Yes  
Resolve an Ask to Buy transaction by approving or rejecting it| No| Yes  
Redeem an introductory offer for an auto-renewable subscription| Yes| Yes  
Redeem a promotional offer for an auto-renewable subscription| Yes| Yes  
Redeem an offer code for an auto-renewable subscription| No| Yes  
Process a subscription renewal| Yes| Yes  
Process a revoked or refunded subscription| Yes| Yes  
Respond to a customer canceling a subscription and disabling auto-renew| Yes|
Yes  
Respond to an expired subscription| Yes| Yes  
Process a subscription upgrade or downgrade| Yes| Yes  
Process a subscription cross-grade with the same or different duration| Yes|
Yes  
Test a price increase for an auto-renewable subscription| No| Yes  
Test billing retry and billing grace period| No| Yes  
  
For more information, see Approve what kids buy with Ask to Buy and Testing
introductory offers.

## See Also

### Testing in-app purchases

Testing in-app purchases with sandbox

Test your implementation of in-app purchases using real product information
and server-to-server transactions in the sandbox environment.

Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

Article

# Setting up StoreKit Testing in Xcode

Prepare your test environment to test in-app purchases with data you configure
locally.

## Overview

StoreKit Testing in Xcode is a local test environment for testing in-app
purchases without requiring a connection to App Store servers. Set up in-app
purchases in a local StoreKit configuration file in your Xcode project, or
create a synced StoreKit configuration file in Xcode from your in-app purchase
settings in App Store Connect. After you enable the configuration file, the
test environment uses this local data when your app calls StoreKit APIs.

Note

Enable Developer Mode to test your app on devices running iOS 16 and later,
visionOS, or watchOS 9 and later. For more information about how to enable
Developer Mode, see Enabling Developer Mode on a device.

As you test transactions, the test environment displays a payment sheet with
localized values, and produces receipts for you to verify.

Testing in-app purchase scenarios with StoreKit in Xcode is useful for:

  * Developing features that use in-app purchases before configuring them in App Store Connect.

  * Testing locally when a network connection isn’t available.

  * Debugging in-app purchase use cases that are harder to set up in the sandbox environment, such as eligibility for promotional offers.

  * Viewing localized product information in the payment sheet.

  * Testing transactions end-to-end, including failed transactions.

The full functionality of StoreKit Testing in Xcode is available for
automation. See StoreKit Test for information about automating in-app purchase
testing. For more information about testing StoreKit at different stages of
development, see Testing at all stages of development with Xcode and the
sandbox.

### Create a StoreKit configuration file

A StoreKit configuration file contains descriptions of in-app purchases,
subscription groups, auto-renewable subscriptions, and non-renewing
subscriptions. When the configuration file is active, StoreKit uses this data
when your app calls StoreKit APIs in the test environment. There are two types
of StoreKit configuration files: local and, in Xcode 14 and later, synced.

  * Set up a local configuration file if you haven’t set up your app in App Store Connect, or you want to try out new types of in-app purchases or subscriptions before you set them up in App Store Connect. The local data is convenient to edit in Xcode, and stands in for the data that otherwise comes from App Store Connect.

  * Set up a synced configuration file if you have in-app purchases or subscriptions already set up in App Store Connect that you want to test in Xcode.

To create a StoreKit configuration file:

  1. Launch Xcode, then choose File > New > File.

  2. In the sheet that appears, enter _storekit_ in the Filter search field.

  3. Select StoreKit Configuration File, then click Next.

  4. In the dialog, enter a name for the file. For a synced configuration file, select the checkbox, specify your team and app in the drop-down menus that appear, then click Next. For a local configuration, leave the checkbox unselected, then click Next.

  5. Select a location, and click Create.

  6. Save the file to your project.

If you rename the configuration file, be sure to keep its file extension
.`storekit`.

Note

You can convert a synced configuration file to a local configuration file. If
you want to sync again, create a new synced configuration file.

### Set up a StoreKit configuration

To edit the settings in a local StoreKit configuration file, select the file
in the Project navigator to open the custom editor. Click the Add button (+)
in the editor to add product details to the configuration file.

Note

You can’t edit a synced configuration file unless you convert it to be a local
configuration file. To convert a synced configuration file, select the file,
then choose Editor > Convert to Local StoreKit Configuration from the Xcode
menu. Click Convert File in the confirmation dialog. When you’re viewing a
synced configuration file, click the Sync button in the bottom left corner to
pull the latest updates from App Store Connect.

Enter the information in your local StoreKit configuration file manually. The
product names, IDs, prices, localizations, and any other data you provide in
the StoreKit configuration file don’t upload to App Store Connect, and don’t
appear in App Store-signed apps. App Store Connect data transfers only to a
synced StoreKit configuration file, which you can’t edit in Xcode.

Tip

If you have a synced configuration file with items you want to test in a local
configuration file, you may copy an item from your synced configuration file
to your local configuration file. To do this, Control-click an item in your
synced configuration file, and choose Copy. In your local configuration file,
select where you want to place the item, and choose Edit > Paste from the
Xcode menu.

Each in-app purchase and non-renewing subscription has a reference name,
product ID, and price. In-app purchases and non-renewing subscriptions
optionally have localizations. This metadata shows up in the payment sheet
after you click to buy a product in your app. Note that the price is a
placeholder value that’s not connected to price tiers or real pricing
information. However, it appears using the correct currency symbols for the
storefront you’re testing.

For non-consumable in-app purchases and auto-renewable subscriptions, select
Family Sharing to mark the product for sharing as the following image shows:

When you set up the first auto-renewable subscription, Xcode prompts you to
create the first subscription group. After adding subscriptions to a group,
the level you assign to each subscription determines their upgrade and
downgrade options. For more information, see Offer auto-renewable
subscriptions.

For auto-renewable subscriptions, set up introductory offers and promotional
offers with the options available in App Store Connect. To begin testing,
configure at least one in-app purchase product.

### Enable StoreKit Testing in Xcode

To enable StoreKit Testing in Xcode, your project must have an active StoreKit
configuration file. By default, StoreKit Testing in Xcode is disabled. To
select a configuration file and make it active:

  1. Click the scheme to open the Scheme menu and choose Edit Scheme.

  2. In the scheme editor, select the Run action.

  3. Click the Options tab.

  4. For the StoreKit Configuration option, select a configuration file and click Close.

You can also add an existing StoreKit configuration file to the project from
this menu. Choose a configuration file with a .`storekit` file extension.

An Xcode project can contain multiple StoreKit configuration files, but only
one can be active at a time. When it’s active, build and run your app as
usual. Instead of accessing App Store Connect or the sandbox server, your app
gets StoreKit data from the test environment.

### Disable StoreKit Testing in Xcode

To disable StoreKit Testing in Xcode, remove the StoreKit configuration file
from the scheme’s run options:

  1. Click the scheme to open the Scheme menu and choose Edit Scheme.

  2. In the scheme editor, select the Run action.

  3. Click the Options tab.

  4. For the StoreKit Configuration option, select None.

Your app stops using the local data from the configuration file and starts
using the data from App Store Connect. For more information, see Overview for
configuring in-app purchases.

### Prepare to validate receipts in the test environment

StoreKit Testing in Xcode generates locally signed receipts that your app
validates locally. Obtain the certificate you need for local validation and
add it to your project as follows:

  1. In Xcode’s Project navigator, click the StoreKit configuration file.

  2. From the Xcode menu, choose Editor > Save Public Certificate.

  3. Select a location in your project to save the file.

Note

The test environment’s certificate is a root certificate. There’s no
certificate chain to validate when you validate the receipt signature.

Be sure your code uses the correct certificate in all environments. Add the
following conditional compilation block to your receipt validation code to
select the test certificate for testing, and the Apple root certificate,
otherwise:

Your code is ready to validate receipts by selecting the appropriate
certificate in the test environment and in the production environment.

Important

Receipts you produce in the test environment aren’t signed by the App Store
and aren’t valid for apps in production.

## See Also

### StoreKit

Testing in-app purchases with StoreKit transaction manager in Xcode

Use the transaction manager within Xcode to test in-app purchases without
requiring a connection to App Store servers.

Article

# Testing in-app purchases in Xcode

Use locally configured product data to test and debug your in-app purchases
implementation.

## Overview

Testing your StoreKit implementation in Xcode ensures that your app behaves
correctly when your users perform various tasks associated with subscriptions
and in-app purchase transactions. Be sure to test a variety of in-app purchase
scenarios, such as receipt validation, promotional offers, interrupted
purchases, introductory offers, subscription renewals, and purchase
restoration.

### Perform basic setup

Before you begin StoreKit testing in Xcode, complete the steps in Setting up
StoreKit Testing in Xcode, including creating a StoreKit configuration file,
enabling StoreKit testing in Xcode, and preparing to validate receipts in the
test environment. The test scenarios in this article require this basic setup.

Select the relevant test scenarios to build a test plan for your app. Each
test scenario provides additional setup steps, if necessary, along with
instructions about how to minimally reset the environment to repeat the test.

### Validate a receipt in the test environment

Validating receipts is an integral part of handling and testing in-app
purchases. As you test in-app purchases, StoreKit in Xcode generates receipts
that are valid only in the test environment. Your app can validate the
receipts locally using a certificate that Xcode provides.

Important

You can’t validate receipts from the test environment with verifyReceipt
because the App Store doesn’t sign these receipts, and the verification fails.

The test environment’s certificate is a root certificate. There’s no
certificate chain to validate when you verify the receipt signature. The
following code example retrieves the local receipt:

For more information, see Validating receipts on the device.

### Test a promotional offer

For this test scenario, let’s assume the app determines that customers are
eligible for the promotional offer when the subscription expires. Use the test
environment to speed up the time rate so the subscription expires. Then,
you’re ready to test the offer eligibility logic in your app.

Additional setup steps for this test scenario are:

  * Add a subscription offer to your StoreKit configuration file.

  * In the app, purchase a subscription within the same subscription group to be eligible for a promotional offer.

Ensure your test user is eligible for the offer according to your app’s
requirements, then purchase the subscription with the offer. Test users can
redeem subscription offers if:

  * They have an existing or expired subscription, including free, discount, or discounted with a subscription offers.

  * They qualify for the offer according to criteria that you define.

See Implementing promotional offers in your app for more information.

  1. In Xcode, select the StoreKit configuration file in the Project navigator, and then choose Editor > Subscription Renewal Rate > Monthly Renewal Every 30 Seconds.

  2. Wait until the subscription expires.

  3. Reset the Subscription Renewal rate to Monthly Renewal Every 30 Minutes.

  4. In the app, select the option to buy the subscription with the offer.

  5. In your code, verify that the payment request includes the discount, `paymentDiscount`.

  6. Observe that the system displays the payment sheet with the promotional offer.

  7. In your code, verify that `paymentQueue(_:updatedTransactions:)` receives the transaction in the `SKPaymentTransactionState.purchasing` state.

  8. In the app, tap Confirm on the payment sheet.

  9. In your code, verify that `paymentQueue(_:updatedTransactions:)` receives the transaction in the `SKPaymentTransactionState.purchased` state.

To test the same promotional offer purchase again, delete the transaction. In
Xcode, choose Debug > StoreKit > Manage Transactions. Select the transaction
for the promotional offer purchase, and click Delete.

### Test an interrupted purchase

An interrupted purchase is a transaction that requires the user to perform
some action outside your app before the transaction can complete successfully.
For example, the user may need to update a payment method or approve new terms
and conditions. In Xcode, you can simulate a purchase interruption and its
resolution to test how your code handles this scenario end-to-end. You can
test this scenario for all in-app purchase product types.

  1. In the Xcode Project navigator, select the StoreKit configuration file. Choose Editor > Enable Interrupted Purchases. Run the app in the simulator or on a device.

  2. In the app, buy an in-app purchase.

  3. Observe that the system displays the payment sheet in the app.

  4. In your code, verify that your `SKPaymentTransactionObserver` gets a callback on `paymentQueue(_:updatedTransactions:)` with a transaction in the `SKPaymentTransactionState.purchasing` state.

  5. In the app, tap Confirm on the payment sheet.

  6. In your code, observe that the payment fails (because you enabled interrupted purchases in the test environment). The payment queue receives a transaction in the `SKPaymentTransactionState.failed` state.

  7. Check that your code calls `finishTransaction(_:)` to remove it from the queue.

  8. In Xcode, choose Debug > StoreKit > Manage Transactions.

  9. Select the transaction and click Resolve. The test environment resumes a successful purchase.

  10. In your code, verify that the payment queue receives a transaction in the `SKPaymentTransactionState.purchased` state for the same `productIdentifier` in the same quantity as the failed transaction.

  11. In your code, validate the receipt. 

  12. Check that your app provides the service or product, and then calls `finishTransaction(_:)`.

To perform the test again for non-consumable products and subscriptions,
delete the transaction to run the test again. To delete the transaction,
choose Debug > StoreKit > Manage Transactions. Select the transaction and
click Delete.

For consumable in-app purchases, you can test again without additional setup.
To reset the test environment to its default behavior, select the StoreKit
configuration file in Xcode, then choose Editor > Disable Interrupted
Purchases.

### Test an introductory offer

Customers are eligible to redeem an introductory offer one time. Configure an
introductory offer for a subscription in your StoreKit configuration file. For
more information, see Implementing introductory offers in your app.

Ensure that your app is eligible for an introductory offer by verifying
there’s no subscription purchase for the product ID that includes the offer.
Either verify the receipt in your code or check the transactions in Xcode by
choosing Debug > StoreKit > Manage Transactions.

  1. In the app, buy the subscription that has an introductory offer.

  2. Observe that the system displays the payment sheet with the introductory offer in the app.

  3. In your code, verify your `SKPaymentTransactionObserver` receives a callback on `paymentQueue(_:updatedTransactions:)` with the transaction in the `SKPaymentTransactionState.purchasing` state.

  4. In the app, tap Confirm on the payment sheet.

  5. In your code, verify your `SKPaymentTransactionObserver` receives a callback on `paymentQueue(_:updatedTransactions:)` with the transaction in the `SKPaymentTransactionState.purchased` state.

  6. In your code, validate the receipt.

  7. Check that your app provides the service or product, and then calls `finishTransaction(_:)`.

To retry the same test scenario, delete the transaction that contains the
introductory offer purchase. In Xcode, choose Debug > StoreKit > Manage
Transactions. Select the transaction and click Delete. This resets the
eligibility for the test user.

### Test restoring purchases without existing purchases

All apps need to provide a way for customers to restore purchases, such as by
providing a Restore Purchases button. Test how your app handles this request
when the customer has no existing purchases. For more information, see
Restoring purchased products.

Include at least one non-consumable product, auto-renewable subscription, or
non-renewable subscription in the StoreKit configuration file. To simulate a
user account with no in-app purchases, delete all the transactions before
starting the test. In Xcode, choose Debug > StoreKit > Manage Transactions,
select all the transactions, and click Delete.

  1. In the app, select the option your app provides to restore purchases.

  2. In your code, verify that it calls `restoreCompletedTransactions()` or `restoreCompletedTransactions(withApplicationUsername:)`.

  3. In your code, verify that StoreKit notifies your observer that the restore is complete by calling `paymentQueueRestoreCompletedTransactionsFinished(_:)`. Note that StoreKit doesn’t notify the queue of any restored transactions.

You can repeat this test scenario without additional steps.

### Test presenting the App Store sheet for managing subscriptions

Your app can present an App Store sheet that customers can use to manage their
subscriptions.

Additional setup steps for this test scenario are:

  * Include two auto-renewable subscriptions that belong to the same subscription group in the StoreKit configuration file.

  * Subscribe the sandbox user to the subscription with the lowest level of service in that subscription group.

  * In the app, implement a Manage Subscriptions button that invokes the `showManageSubscriptions(in:)` or `manageSubscriptionsSheet(isPresented:)` method.

See `showManageSubscriptions(in:)` and
`manageSubscriptionsSheet(isPresented:)` for more information.

  1. In the app, tap the Manage Subscriptions button.

  2. Observe that the system displays the App Store sheet for managing subscriptions.

  3. Verify that the test user is a subscriber of the lower-grade subscription.

  4. Upgrade the test user to the higher-grade subscription in that group.

  5. Verify that the user is a subscriber of the higher-grade subscription.

  6. Cancel the subscription and confirm it in the Confirm Cancellation dialog.

  7. Verify that the user is no longer a subscriber of any subscription.

You can repeat this test scenario without additional steps.

### Test an offer code

Your app can present a sheet to redeem preconfigured subscription offer codes.

Additional setup steps for this test scenario are:

  * Include one auto-renewable subscription in the StoreKit configuration file.

  * Configure an offer code for the above subscription in your StoreKit configuration file under the Offer Codes heading.

  * In the app, implement a Redeem Offer Code button that invokes the `presentCodeRedemptionSheet()` method.

See `presentCodeRedemptionSheet()` for more information.

  1. In the app, tap the Redeem Offer Code button.

  2. Observe that the system displays the Redeem Offer Code sheet.

  3. Select the offer code that you configured and redeem it.

  4. Observe that the system displays the payment sheet with the applied offer.

  5. In the app, tap Confirm on the payment sheet.

  6. In your code, verify your `SKPaymentTransactionObserver` receives a callback on `paymentQueue(_:updatedTransactions:)` with the transaction in the `SKPaymentTransactionState.purchased` state.

  7. Check that your app provides the service or product, and then calls `finishTransaction(_:)`.

To retry the same test scenario, delete the transaction that contains the
offer code purchase. In Xcode, choose Debug > StoreKit > Manage Transactions.
Select the transaction and click Delete.

### Test billing retry and grace period for auto-renewable subscriptions

When billing for a subscription renewal fails, such as due to an expired card,
the App Store retries billing and attempts to recover the subscription. You
can enable a billing grace period for your app in App Store Connect so your
subscribers can continue accessing paid content while the App Store retries
billing. For more information about the billing grace period, see Reducing
Involuntary Subscriber Churn.

Test these scenarios in Xcode to ensure your app detects subscriptions that
are in billing retry or billing grace period states. In your code, look at the
`renewalInfo` for the subscription to inspect its
`Product.SubscriptionInfo.RenewalState`. For subscriptions in a billing grace
period state, ensure your app continues to provide uninterrupted subscription
features.

Additional setup steps for this scenario are:

  * Choose Editor > Enable Billing Grace Period. This step simulates enabling the billing grace period for your app in App Store Connect. To test billing retry without a billing grace period, leave this setting disabled.

  * Choose Editor > Enable Billing Retry on Renewal. This step causes all subscription renewals to go into a billing retry state.

  * Select your StoreKit configuration file in the Project navigator.

  * Create an auto-renewable subscription in-app purchase in your StoreKit configuration file.

  * Purchase the auto-renewable subscription in your app.

  * Adjust the time rate of subscription renewals in the testing environment by choosing Editor > Subscription Renewal Rate, and select an option. For more information about the time rates available in the testing environment, see `timeRate`.

Test your app’s handling of a billing grace period:

  1. In the testing environment, wait for the subscription period to elapse. The subscription goes into a billing retry state and a billing grace period.

  2. Run your app, then choose Debug > StoreKit > Manage Transactions.

  3. Find and select the subscription transaction.

  4. Verify the subscription transaction is in the billing grace period state.

  5. Test your app to verify that it supports the billing grace period by continuing to provide uninterrupted access to the features the subscription provides.

Test your app’s handling of a billing grace period expiration:

  1. In the testing environment, wait until the billing grace period elapses for the subscription.

  2. Run your app, then choose Debug > StoreKit > Manage Transactions.

  3. Find and select the subscription transaction.

  4. Verify the subscription transaction is in the billing retry state, and is no longer in the billing grace period state.

  5. Test your app to verify that it works consistently with a subscription expiration.

Test resolving a billing issue for billing retry, either with a billing grace
period or without:

  1. In the testing environment, wait for the subscription period to elapse. Verify your app works consistently with a subscription expiration if you’re not testing a billing grace period.

  2. Run your app, then choose Debug > StoreKit > Manage Transactions.

  3. Find and select the subscription transaction.

  4. Verify the subscription transaction is in either the billing grace period state or the billing retry state.

  5. Click the Resolve Issues button to resolve the billing issue.

  6. Test your app to verify that it provides access to the subscription features as you expect.

### Test price increase consent

When you increase the price of an auto-renewable subscription by an amount
that requires user consent, the App Store gives the user an opportunity to
consent to the price increase by presenting a sheet in your app. Your app may
defer presentation of the sheet to prevent it from appearing at an
inconvenient time in the user interface. Users may also consent to a price
increase outside your app. Test these scenarios in Xcode to verify that your
app handles deferring or displaying the sheet.

Additional setup steps for this scenario are:

  * Create an auto-renewable subscription purchase in your StoreKit configuration file.

  * Purchase the subscription in your app.

  * Optionally, increase the price for your subscription in your StoreKit configuration file. You can still test this scenario without increasing the price.

Test for the deferred price increase consent sheet presentation:

  1. Navigate to a place in your app where you defer presentation of the price increase consent sheet.

  2. Run your app, then choose Debug > StoreKit > Manage Transactions.

  3. Find and select the subscription transaction.

  4. Click Request Price Increase Consent.

  5. Verify that the price increase consent sheet doesn’t display in your app.

  6. Navigate away from the view where you defer presentation.

  7. Verify that the price increase consent sheet displays in your app.

  8. On the price increase consent sheet in the app, select the Agree to New Price button to test a user consenting to the price increase, or select Close to test the user not giving consent for the price increase.

Test for the price increase consent sheet presentation:

  1. Navigate to a place in your app where you don’t defer presenting the price increase consent sheet.

  2. In the StoreKit transaction manager, select the subscription purchase, then click Request Price Increase Consent.

  3. Verify that the price increase consent sheet displays in your app.

  4. On the price increase consent sheet in the app, select the Agree to New Price button to test a user consenting to the price increase, or select Close to test the user not giving consent for the price increase.

For information about testing price increase consent in an automated test
suite, see `requestPriceIncreaseConsentForTransaction(identifier:)`,
`consentToPriceIncreaseForTransaction(identifier:)`, and
`declinePriceIncreaseForTransaction(identifier:)`.

## See Also

### Testing in-app purchases

Testing at all stages of development with Xcode and the sandbox

Verify your implementation of in-app purchases by testing your code throughout
its development.

Setting up StoreKit Testing in Xcode

Prepare your test environment to test in-app purchases with data you configure
locally.

Testing in-app purchases with sandbox

Test your implementation of in-app purchases using real product information
and server-to-server transactions in the sandbox environment.

Article

# Handling errors

Determine the underlying cause of errors that result from StoreKit requests.

## Overview

A StoreKit request may fail for one of many possible reasons, including
invalid product information, invalid payment details, problems with your App
Store Connect account, or networking issues. When an error occurs, check the
error code to find out what went wrong.

### Determine the cause of the error

When handling errors, such as with the `request(_:didFailWithError:)` delegate
method, it’s important to use the `domain` and `code` of the resulting error
to determine the underlying cause of failure.

StoreKit uses `SKErrorDomain` for errors related to payments, store products,
and cloud services, as described in `SKError.Code`. For additional information
on troubleshooting StoreKit framework issues, see the In-App Purchase FAQ.

Errors related to networking use `NSURLErrorDomain`. The following table
describes some of the most common networking errors that may occur when using
StoreKit:

Error code| Description  
---|---  
`NSURLErrorTimedOut` (`-1001`)| The connection timed out.  
`NSURLErrorCannotFindHost` (`-1003`)| The connection failed because it can't
find the host.  
`NSURLErrorCannotConnectToHost` (`-1004`)| The connection failed because it
can't connect to the host.  
`NSURLErrorNetworkConnectionLost` (`-1005`)| The connection failed because it
lost the network connection.  
`NSURLErrorNotConnectedToInternet` (`-1009`)| The connection failed because
the device isn't connected to the internet.  
`NSURLErrorUserCancelledAuthentication` (`-1012`)| The connection failed
because the user canceled required authentication.  
`NSURLErrorSecureConnectionFailed` (`-1200`)| The secure connection failed for
an unknown reason.  
  
## See Also

### Errors

`enum SKError.Code`

Error codes for StoreKit errors.

`struct SKError`

StoreKit error descriptions, codes, and domains.

`let SKErrorDomain: String`

The error domain name for StoreKit errors.

Global Variable

# SKErrorDomain

The error domain name for StoreKit errors.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    let SKErrorDomain: String

## See Also

### Errors

Handling errors

Determine the underlying cause of errors that result from StoreKit requests.

`enum SKError.Code`

Error codes for StoreKit errors.

`struct SKError`

StoreKit error descriptions, codes, and domains.



# SKOverlay.Position

Enumeration Case

# SKOverlay.Position.bottom

Specifies that the overlay is at the bottom of the screen.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    case bottom = 0

## See Also

### Describing the Overlay’s Position

`case bottomRaised`

Specifies that the overlay is at a raised position at the bottom of the
screen.

Enumeration Case

# SKOverlay.Position.bottomRaised

Specifies that the overlay is at a raised position at the bottom of the
screen.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    case bottomRaised = 1

## Discussion

Use this position in case your app uses a `UITabBar`.

## See Also

### Describing the Overlay’s Position

`case bottom`

Specifies that the overlay is at the bottom of the screen.

Enumeration Case

# SKOverlay.Position.bottom

Specifies that the overlay is at the bottom of the screen.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    case bottom = 0

## See Also

### Describing the Overlay’s Position

`case bottomRaised`

Specifies that the overlay is at a raised position at the bottom of the
screen.

Enumeration Case

# SKOverlay.Position.bottomRaised

Specifies that the overlay is at a raised position at the bottom of the
screen.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    case bottomRaised = 1

## Discussion

Use this position in case your app uses a `UITabBar`.

## See Also

### Describing the Overlay’s Position

`case bottom`

Specifies that the overlay is at the bottom of the screen.



# SubscriptionStoreControlBackground

Type Property

# automatic

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
Xcode 15.0+

    
    
    static var automatic: SubscriptionStoreControlBackground { get }

## See Also

### Background types

`static var gradientMaterial: SubscriptionStoreControlBackground`

`static var gradientMaterialOnScroll: SubscriptionStoreControlBackground`

Type Property

# gradientMaterial

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
Xcode 15.0+

    
    
    static var gradientMaterial: SubscriptionStoreControlBackground { get }

## See Also

### Background types

`static var automatic: SubscriptionStoreControlBackground`

`static var gradientMaterialOnScroll: SubscriptionStoreControlBackground`

Type Property

# gradientMaterialOnScroll

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  Mac Catalyst 17.0+  Xcode 15.0+

    
    
    static var gradientMaterialOnScroll: SubscriptionStoreControlBackground { get }

## See Also

### Background types

`static var automatic: SubscriptionStoreControlBackground`

`static var gradientMaterial: SubscriptionStoreControlBackground`



# ProductViewStyleConfiguration.Icon

Instance Property

# body

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @MainActor
    var body: some View { get }

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing product view style configurations

`typealias ProductViewStyleConfiguration.Icon.Body`

Type Alias

# ProductViewStyleConfiguration.Icon.Body

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias ProductViewStyleConfiguration.Icon.Body = some View

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing product view style configurations

`var body: View`

Instance Method

# productDescription(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.4+
tvOS 17.0+  watchOS 10.0+  visionOS 1.1+  Xcode 15.0+

    
    
    func productDescription(_ visibility: Visibility) -> some View

Instance Method

# searchPresentationToolbarBehavior(_:)

StoreKit  SwiftUI  iOS 17.1+  iPadOS 17.1+  macOS 14.1+  Mac Catalyst 17.2+
tvOS 17.1+  watchOS 10.1+  visionOS 1.0+  Xcode 14.4+

    
    
    func searchPresentationToolbarBehavior(_ behavior: SearchPresentationToolbarBehavior) -> some View

Instance Method

# subscriptionPromotionalOffer(offer:signature:)

StoreKit  SwiftUI  iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+
tvOS 17.4+  watchOS 10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func subscriptionPromotionalOffer(
        offer: @escaping (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?,
        signature: @escaping (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) async throws -> Product.SubscriptionOffer.Signature
    ) -> some View



# ProminentPickerSubscriptionStoreControlStyle

Type Property

# prominentPicker

A subscription store control style that displays subscription plans as a
prominent picker control, with a single button to subscribe.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
Xcode 15.0+

    
    
    static var prominentPicker: ProminentPickerSubscriptionStoreControlStyle { get }

Instance Method

# makeBody(configuration:)

Creates a view that represents the body of a prominent picker subscription
store.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
Xcode 15.0+

    
    
    func makeBody(configuration: ProminentPickerSubscriptionStoreControlStyle.Configuration) -> some View

##  Parameters

`configuration`

    

The properties of a prominent picker subscription store control.

## Relationships

### From Protocol

  * `SubscriptionStoreControlStyle`

## See Also

### Creating the style

`typealias ProminentPickerSubscriptionStoreControlStyle.Body`

A type that represents the body of a prominent picker subscription store
control style.

`init()`

Creates a prominent picker subscription store control style.

Type Alias

# ProminentPickerSubscriptionStoreControlStyle.Body

A type that represents the body of a prominent picker subscription store
control style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
Xcode 15.0+

    
    
    typealias ProminentPickerSubscriptionStoreControlStyle.Body = some View

## Relationships

### From Protocol

  * `SubscriptionStoreControlStyle`

## See Also

### Creating the style

`func makeBody(configuration:
ProminentPickerSubscriptionStoreControlStyle.Configuration) -> View`

Creates a view that represents the body of a prominent picker subscription
store.

`init()`

Creates a prominent picker subscription store control style.

Initializer

# init()

Creates a prominent picker subscription store control style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
Xcode 15.0+

    
    
    init()

## See Also

### Creating the style

`func makeBody(configuration:
ProminentPickerSubscriptionStoreControlStyle.Configuration) -> View`

Creates a view that represents the body of a prominent picker subscription
store.

`typealias ProminentPickerSubscriptionStoreControlStyle.Body`

A type that represents the body of a prominent picker subscription store
control style.



# SKOverlay.AppClipConfiguration

Initializer

# init(position:)

Creates an object that represents the attributes of an overlay you use to
recommend an App Clip’s corresponding app.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    init(position: SKOverlay.Position)

##  Parameters

`position`

    

The position of the overlay on the screen.

## See Also

### Creating an App Clip Configuration

`var position: SKOverlay.Position`

The position of the overlay on the screen.

`enum SKOverlay.Position`

Constants that identify the position of an overlay on the screen.

Instance Property

# position

The position of the overlay on the screen.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    var position: SKOverlay.Position { get set }

## See Also

### Creating an App Clip Configuration

`init(position: SKOverlay.Position)`

Creates an object that represents the attributes of an overlay you use to
recommend an App Clip’s corresponding app.

`enum SKOverlay.Position`

Constants that identify the position of an overlay on the screen.

Instance Property

# campaignToken

A token you use to represent an ad campaign and measure its effectiveness.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    var campaignToken: String? { get set }

## Discussion

A campaign token is a 40-byte string that represents an ad campaign. By
setting the `campaignToken`, you can measure the effectiveness of an Apple
Services Performance Partners Program link or an App Store Connect Analytics
campaign.

For more information, see Apple Services Performance Partners Program and App
Store Connect.

## See Also

### Verifying Advertising Campaigns

`var providerToken: String?`

A token that represents the provider of an app promotion campaign, and that
you use to measure the campaign’s effectiveness.

`func setAdditionalValue(Any?, forKey: String)`

Sets an additional value for a key, such as a value for measuring the
effectiveness of an ad campaign.

`func additionalValue(forKey: String) -> Any?`

Returns the object associated with the key.

Instance Property

# providerToken

A token that represents the provider of an app promotion campaign, and that
you use to measure the campaign’s effectiveness.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    var providerToken: String? { get set }

## Discussion

When you set a provider token, you must also set the `campaignToken`.

When promoting your own apps, set your own provider token using
`providerToken`. This allows you to track a promotion’s effectiveness
independently from any affiliate campaign that shares the same campaign token.

When promoting apps by other developers, set `providerToken` using their
provider token. This allows those developers to track the effectiveness of
your App Store Connect Analytics campaign.

## See Also

### Verifying Advertising Campaigns

`var campaignToken: String?`

A token you use to represent an ad campaign and measure its effectiveness.

`func setAdditionalValue(Any?, forKey: String)`

Sets an additional value for a key, such as a value for measuring the
effectiveness of an ad campaign.

`func additionalValue(forKey: String) -> Any?`

Returns the object associated with the key.

Instance Method

# setAdditionalValue(_:forKey:)

Sets an additional value for a key, such as a value for measuring the
effectiveness of an ad campaign.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    func setAdditionalValue(
        _ value: Any?,
        forKey key: String
    )

##  Parameters

`value`

    

The value to associate with the `key`.

`key`

    

The string that identifies an additional value.

## Discussion

Set additional values to verify and associate an app installation with an ad
campaign. For more information, see `SKAdNetwork`.

## See Also

### Verifying Advertising Campaigns

`var campaignToken: String?`

A token you use to represent an ad campaign and measure its effectiveness.

`var providerToken: String?`

A token that represents the provider of an app promotion campaign, and that
you use to measure the campaign’s effectiveness.

`func additionalValue(forKey: String) -> Any?`

Returns the object associated with the key.

Instance Method

# additionalValue(forKey:)

Returns the object associated with the key.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    func additionalValue(forKey key: String) -> Any?

##  Parameters

`key`

    

The string that identifies an additional value.

## Return Value

The associated value of the key.

## Discussion

Additional values are values you use to verify and associate an app
installation with an ad campaign. For more information, see `SKAdNetwork`.

## See Also

### Verifying Advertising Campaigns

`var campaignToken: String?`

A token you use to represent an ad campaign and measure its effectiveness.

`var providerToken: String?`

A token that represents the provider of an app promotion campaign, and that
you use to measure the campaign’s effectiveness.

`func setAdditionalValue(Any?, forKey: String)`

Sets an additional value for a key, such as a value for measuring the
effectiveness of an ad campaign.

Instance Property

# latestReleaseID

The release ID of the latest version of your parent app as displayed in App
Store Connect.

iOS 15.0+  iPadOS 15.0+  Mac Catalyst 15.0+  visionOS 1.0+

    
    
    var latestReleaseID: String? { get set }

Instance Property

# customProductPageIdentifier

An identifier for a parent app’s custom product page.

iOS 15.0+  iPadOS 15.0+  Mac Catalyst 15.0+  visionOS 1.0+

    
    
    var customProductPageIdentifier: String? { get set }

## Discussion

The identifier, referred to as the product variant identifier, identifies
specific variant product pages from App Store Connect for your app.



# SKProductStorePromotionController

Instance Method

# fetchStorePromotionOrder(completionHandler:)

Reads the product order override that determines the promoted product order on
this device.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+

    
    
    func fetchStorePromotionOrder(completionHandler: (([SKProduct], (any Error)?) -> Void)? = nil)

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

This function returns an array of promoted products whose order is overridden
on the given device.

If all the products appear in the default order, this method returns an empty
array.

## See Also

### Managing promoted product order

`func update(storePromotionOrder: [SKProduct], completionHandler: (((any
Error)?) -> Void)?)`

Overrides the promoted product order on this device.

Instance Method

# update(storePromotionOrder:completionHandler:)

Overrides the promoted product order on this device.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+

    
    
    func update(
        storePromotionOrder promotionOrder: [SKProduct],
        completionHandler: (((any Error)?) -> Void)? = nil
    )

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

The default order of promoted in-app purchase products is set in App Store
Connect. You can override this order per device. For example, you can promote
an in-app purchase product that unlocks a specific level in your game when a
user reaches the level immediately before the specified level.

To override the default product order, put the product information for the
subset of products you want to reorder into an array, in the order you want
them to appear in. Pass the array to the
`update(storePromotionOrder:completionHandler:)` method. The products in the
array are shown at the beginning of the list, followed by the remaining in-app
purchase products, which are listed in the same relative order that you set in
App Store Connect.

To cancel order overrides, send an empty product array to the
`update(storePromotionOrder:completionHandler:)` method. The in-app purchase
products will be displayed in the default order.

## See Also

### Managing promoted product order

`func fetchStorePromotionOrder(completionHandler: (([SKProduct], (any Error)?)
-> Void)?)`

Reads the product order override that determines the promoted product order on
this device.

Instance Method

# fetchStorePromotionVisibility(for:completionHandler:)

Reads the visibility setting of a promoted product in the App Store for this
device.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+

    
    
    func fetchStorePromotionVisibility(
        for product: SKProduct,
        completionHandler: ((SKProductStorePromotionVisibility, (any Error)?) -> Void)? = nil
    )

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

The default visibility for a promoted product is set in App Store Connect.
Call `fetchStorePromotionVisibility(for:completionHandler:)` to determine if a
product's visibility is set to the default value or if it has been overridden
to be hidden or shown.

## See Also

### Managing promoted product visibility

`func update(storePromotionVisibility: SKProductStorePromotionVisibility, for:
SKProduct, completionHandler: (((any Error)?) -> Void)?)`

Updates the visibility of the product on the App Store, per device.

`enum SKProductStorePromotionVisibility`

The visibility settings that determine if an in-app purchase is visible on a
device.

Instance Method

# update(storePromotionVisibility:for:completionHandler:)

Updates the visibility of the product on the App Store, per device.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+

    
    
    func update(
        storePromotionVisibility promotionVisibility: SKProductStorePromotionVisibility,
        for product: SKProduct,
        completionHandler: (((any Error)?) -> Void)? = nil
    )

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

An in-app purchase product's default visibility setting is set up in App Store
Connect. You can override the default setting, or return it to the default set
in App Store Connect using the values in `SKProductStorePromotionVisibility`.

Visibility settings apply per device.

## See Also

### Managing promoted product visibility

`func fetchStorePromotionVisibility(for: SKProduct, completionHandler:
((SKProductStorePromotionVisibility, (any Error)?) -> Void)?)`

Reads the visibility setting of a promoted product in the App Store for this
device.

`enum SKProductStorePromotionVisibility`

The visibility settings that determine if an in-app purchase is visible on a
device.

Type Method

# default()

Returns the default product store promotion controller.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+

    
    
    class func `default`() -> Self



# Transaction.OfferType

Type Property

# introductory

An introductory offer for an auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let introductory: Transaction.OfferType

## Discussion

For more information about introductory offers, see Set up introductory offers
for auto-renewable subscriptions.

## See Also

### Getting offer types

`static let promotional: Transaction.OfferType`

A promotional offer for an auto-renewable subscription.

`static let code: Transaction.OfferType`

An offer with a subscription offer code, for an auto-renewable subscription.

Type Property

# promotional

A promotional offer for an auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let promotional: Transaction.OfferType

## Discussion

For more information about promotional offers, see Set up promotional offers
for auto-renewable subscriptions.

## See Also

### Getting offer types

`static let introductory: Transaction.OfferType`

An introductory offer for an auto-renewable subscription.

`static let code: Transaction.OfferType`

An offer with a subscription offer code, for an auto-renewable subscription.

Type Property

# code

An offer with a subscription offer code, for an auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let code: Transaction.OfferType

## Discussion

For more information about offer codes, see Set up offer codes.

## See Also

### Getting offer types

`static let introductory: Transaction.OfferType`

An introductory offer for an auto-renewable subscription.

`static let promotional: Transaction.OfferType`

A promotional offer for an auto-renewable subscription.

Instance Property

# localizedDescription

The localized text that describes the offer type.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

Create an offer type from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: Int)

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating an offer type

`let rawValue: Int`

The offer type as a raw value.

`typealias Transaction.OfferType.RawValue`

A type representing the raw value of an offer type.

Instance Property

# rawValue

The offer type as a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: Int

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating an offer type

`init(rawValue: Int)`

Create an offer type from a raw value.

`typealias Transaction.OfferType.RawValue`

A type representing the raw value of an offer type.

Type Alias

# Transaction.OfferType.RawValue

A type representing the raw value of an offer type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Transaction.OfferType.RawValue = Int

## See Also

### Creating an offer type

`init(rawValue: Int)`

Create an offer type from a raw value.

`let rawValue: Int`

The offer type as a raw value.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Transaction.OfferType, rhs: Transaction.OfferType) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing offer types

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing offer types

`static func != (Transaction.OfferType, Transaction.OfferType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing offer types

`static func != (Transaction.OfferType, Transaction.OfferType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# SKPaymentTransaction

Instance Property

# payment

The payment for the transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var payment: SKPayment { get }

## Discussion

Each payment transaction is created in response to a payment that your
application added to the payment queue.

## See Also

### Getting Transaction Information

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

Instance Property

# transactionIdentifier

A string that uniquely identifies a successful payment transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var transactionIdentifier: String? { get }

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.purchased` or
`SKPaymentTransactionState.restored`. The `transactionIdentifier` is a string
that uniquely identifies an interaction between the user's device and the App
Store, such as a purchase or restore.

This value has the same format as the transaction’s `transaction_id` in the
receipt; however, the values may not be the same.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

Instance Property

# transactionDate

The date the transaction was added to the App Store’s payment queue.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var transactionDate: Date? { get }

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.purchased` or
`SKPaymentTransactionState.restored`.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

Instance Property

# original

The transaction that was restored by the App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var original: SKPaymentTransaction? { get }

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.restored`. When a transaction is restored,
the current transaction holds a new transaction identifier, receipt, and so
on. Your application will read this property to retrieve the restored
transaction.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

Instance Property

# error

An object describing the error that occurred while processing the transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var error: (any Error)? { get }

## Discussion

The `error` property is undefined except when `transactionState` is set to
`SKPaymentTransactionState.failed`. Your application can read the `error`
property to determine why the transaction failed. For a list of error
constants, see SKErrorDomain in `StoreKit Constants`.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

### Related Documentation

In-App Purchase Programming Guide

Instance Property

# transactionReceipt

A signed receipt that records all information about a successful payment
transaction.

iOS 3.0–7.0  Deprecated  iPadOS 3.0–7.0  Deprecated  Mac Catalyst 13.0–13.0
Deprecated  tvOS 9.0+

    
    
    var transactionReceipt: Data? { get }

Deprecated

Use the app receipt instead, as described in Receipt Validation Programming
Guide.

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.purchased`.

The receipt is a signed chunk of data that can be sent to the App Store to
verify that the payment was successfully processed. This is most useful when
designing a store that uses a server separate from the iPhone to verify that
payment was processed. For more information on verifying receipts, see Receipt
Validation Programming Guide.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

Instance Property

# downloads

An array of download objects representing the downloadable content associated
with the transaction.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var downloads: [SKDownload] { get }

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.purchased`. The `SKDownload` objects stored
in this property must be used to download the transaction’s content before the
transaction is finished. After the transaction is finished, the download
objects are no longer queueable.

Instance Property

# transactionState

The current state of the transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var transactionState: SKPaymentTransactionState { get }

## See Also

### Getting Transaction State

`enum SKPaymentTransactionState`

Values representing the state of a transaction.

Instance Property

# payment

The payment for the transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var payment: SKPayment { get }

## Discussion

Each payment transaction is created in response to a payment that your
application added to the payment queue.

## See Also

### Getting Transaction Information

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

Instance Property

# transactionIdentifier

A string that uniquely identifies a successful payment transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var transactionIdentifier: String? { get }

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.purchased` or
`SKPaymentTransactionState.restored`. The `transactionIdentifier` is a string
that uniquely identifies an interaction between the user's device and the App
Store, such as a purchase or restore.

This value has the same format as the transaction’s `transaction_id` in the
receipt; however, the values may not be the same.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

Instance Property

# transactionDate

The date the transaction was added to the App Store’s payment queue.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var transactionDate: Date? { get }

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.purchased` or
`SKPaymentTransactionState.restored`.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

Instance Property

# original

The transaction that was restored by the App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var original: SKPaymentTransaction? { get }

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.restored`. When a transaction is restored,
the current transaction holds a new transaction identifier, receipt, and so
on. Your application will read this property to retrieve the restored
transaction.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

Instance Property

# error

An object describing the error that occurred while processing the transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var error: (any Error)? { get }

## Discussion

The `error` property is undefined except when `transactionState` is set to
`SKPaymentTransactionState.failed`. Your application can read the `error`
property to determine why the transaction failed. For a list of error
constants, see SKErrorDomain in `StoreKit Constants`.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var transactionReceipt: Data?`

A signed receipt that records all information about a successful payment
transaction.

### Related Documentation

In-App Purchase Programming Guide

Instance Property

# transactionReceipt

A signed receipt that records all information about a successful payment
transaction.

iOS 3.0–7.0  Deprecated  iPadOS 3.0–7.0  Deprecated  Mac Catalyst 13.0–13.0
Deprecated  tvOS 9.0+

    
    
    var transactionReceipt: Data? { get }

Deprecated

Use the app receipt instead, as described in Receipt Validation Programming
Guide.

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.purchased`.

The receipt is a signed chunk of data that can be sent to the App Store to
verify that the payment was successfully processed. This is most useful when
designing a store that uses a server separate from the iPhone to verify that
payment was processed. For more information on verifying receipts, see Receipt
Validation Programming Guide.

## See Also

### Getting Transaction Information

`var payment: SKPayment`

The payment for the transaction.

`var transactionIdentifier: String?`

A string that uniquely identifies a successful payment transaction.

`var transactionDate: Date?`

The date the transaction was added to the App Store’s payment queue.

`var original: SKPaymentTransaction?`

The transaction that was restored by the App Store.

`var error: (any Error)?`

An object describing the error that occurred while processing the transaction.

Instance Property

# downloads

An array of download objects representing the downloadable content associated
with the transaction.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    var downloads: [SKDownload] { get }

## Discussion

The contents of this property are undefined except when `transactionState` is
set to `SKPaymentTransactionState.purchased`. The `SKDownload` objects stored
in this property must be used to download the transaction’s content before the
transaction is finished. After the transaction is finished, the download
objects are no longer queueable.

Instance Property

# transactionState

The current state of the transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var transactionState: SKPaymentTransactionState { get }

## See Also

### Getting Transaction State

`enum SKPaymentTransactionState`

Values representing the state of a transaction.



# SKCloudServiceSetupMessageIdentifier

Initializer

# init(rawValue:)

Initializes a cloud service setup message identifier based on the provided raw
value.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.0+  tvOS 9.0+  visionOS
1.0+  Xcode 7.1+

    
    
    init(rawValue: String)

Type Property

# addMusic

Message identifier for adding music.

iOS 11.0+  iPadOS 11.0+  Mac Catalyst 13.1+  tvOS 11.0+

    
    
    static let addMusic: SKCloudServiceSetupMessageIdentifier

## See Also

### Message Identifiers

`static let connect: SKCloudServiceSetupMessageIdentifier`

Message identifier for connecting.

`static let join: SKCloudServiceSetupMessageIdentifier`

Message identifier for joining.

`static let playMusic: SKCloudServiceSetupMessageIdentifier`

Message identifier for playing music.

Type Property

# connect

Message identifier for connecting.

iOS 11.0+  iPadOS 11.0+  Mac Catalyst 13.1+  tvOS 11.0+

    
    
    static let connect: SKCloudServiceSetupMessageIdentifier

## See Also

### Message Identifiers

`static let addMusic: SKCloudServiceSetupMessageIdentifier`

Message identifier for adding music.

`static let join: SKCloudServiceSetupMessageIdentifier`

Message identifier for joining.

`static let playMusic: SKCloudServiceSetupMessageIdentifier`

Message identifier for playing music.

Type Property

# join

Message identifier for joining.

iOS 11.0+  iPadOS 11.0+  Mac Catalyst 13.1+  tvOS 11.0+

    
    
    static let join: SKCloudServiceSetupMessageIdentifier

## See Also

### Message Identifiers

`static let addMusic: SKCloudServiceSetupMessageIdentifier`

Message identifier for adding music.

`static let connect: SKCloudServiceSetupMessageIdentifier`

Message identifier for connecting.

`static let playMusic: SKCloudServiceSetupMessageIdentifier`

Message identifier for playing music.

Type Property

# playMusic

Message identifier for playing music.

iOS 11.0+  iPadOS 11.0+  Mac Catalyst 13.1+  tvOS 11.0+

    
    
    static let playMusic: SKCloudServiceSetupMessageIdentifier

## See Also

### Message Identifiers

`static let addMusic: SKCloudServiceSetupMessageIdentifier`

Message identifier for adding music.

`static let connect: SKCloudServiceSetupMessageIdentifier`

Message identifier for connecting.

`static let join: SKCloudServiceSetupMessageIdentifier`

Message identifier for joining.



# VerificationResult

Enumeration Case

# VerificationResult.verified(_:)

The associated value passed StoreKit automatic verification checks.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case verified(SignedType)

## Discussion

The associated value in this case is the App Store-signed value.

## See Also

### Getting the verification results

`case unverified(SignedType,
VerificationResult<SignedType>.VerificationError)`

The associated value failed StoreKit automatic verification checks.

`var payloadValue: SignedType`

The verified value of the signed type that StoreKit confirms as verified.

`var unsafePayloadValue: SignedType`

The associated value of the verification result that StoreKit doesn’t confirm
as verified.

`enum VerificationResult.VerificationError`

Error cases for StoreKit JWS verification.

Enumeration Case

# VerificationResult.unverified(_:_:)

The associated value failed StoreKit automatic verification checks.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case unverified(SignedType, VerificationResult<SignedType>.VerificationError)

## Discussion

The first associated value in this case is the App Store-signed value. The
second associated value provides the reason why the verification failed.

## See Also

### Getting the verification results

`case verified(SignedType)`

The associated value passed StoreKit automatic verification checks.

`var payloadValue: SignedType`

The verified value of the signed type that StoreKit confirms as verified.

`var unsafePayloadValue: SignedType`

The associated value of the verification result that StoreKit doesn’t confirm
as verified.

`enum VerificationResult.VerificationError`

Error cases for StoreKit JWS verification.

Instance Property

# payloadValue

The verified value of the signed type that StoreKit confirms as verified.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var payloadValue: SignedType { get throws }

## Discussion

This property represents the value of a payload in a JSON Web Signature (JWS)
value that passed StoreKit verification.

This property throws an error if the JWS value containing the payload doesn’t
pass StoreKit’s verification and is therefore _unverified_. To access the
payload of an unverified JWS value, get the associated value of the
verification result, or use the `unsafePayloadValue` property.

## See Also

### Getting the verification results

`case verified(SignedType)`

The associated value passed StoreKit automatic verification checks.

`case unverified(SignedType,
VerificationResult<SignedType>.VerificationError)`

The associated value failed StoreKit automatic verification checks.

`var unsafePayloadValue: SignedType`

The associated value of the verification result that StoreKit doesn’t confirm
as verified.

`enum VerificationResult.VerificationError`

Error cases for StoreKit JWS verification.

Instance Property

# unsafePayloadValue

The associated value of the verification result that StoreKit doesn’t confirm
as verified.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var unsafePayloadValue: SignedType { get }

## Discussion

This property represents the value of a payload in a JSON Web Signature (JWS)
value that’s not confirmed to have passed StoreKit verification.

Use the `unsafePayloadValue` for debugging purposes or other situations where
the integrity of the data is unimportant. This property ignores any
verification errors. To get a payload that passed verification, or to check
for verification errors, use the `payloadValue` property instead.

Important

Don’t trust the integrity of the values you receive from the
`unsafePayloadValue` property. This property contains data regardless of the
verification result, and contains data even if StoreKit’s verification fails.

To determine if the JWS value fails verification, perform a verification on
the `jwsRepresentation` property for subscription renewal information, the
`jwsRepresentation` property for transactions, or the `jwsRepresentation`
property for app transactions.

## See Also

### Getting the verification results

`case verified(SignedType)`

The associated value passed StoreKit automatic verification checks.

`case unverified(SignedType,
VerificationResult<SignedType>.VerificationError)`

The associated value failed StoreKit automatic verification checks.

`var payloadValue: SignedType`

The verified value of the signed type that StoreKit confirms as verified.

`enum VerificationResult.VerificationError`

Error cases for StoreKit JWS verification.

Instance Property

# jwsRepresentation

The transaction signed by the App Store, in JWS compact serialization format.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var jwsRepresentation: String { get }

Available when `SignedType` is `Transaction`.

## Discussion

Use this value to perform your own JWS verification on your server, or on the
device.

## See Also

### Getting properties for transactions

`var deviceVerification: Data`

The device verification value to use to verify whether the transaction belongs
to the device.

Available when `SignedType` is `Transaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Transaction`.

`var signedDate: Date`

The date that the App Store signed the JWS transaction.

Available when `SignedType` is `Transaction`.

`var headerData: Data`

The header component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var payloadData: Data`

The payload component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signedData: Data`

The transaction data covered by the signature.

Available when `SignedType` is `Transaction`.

`var signatureData: Data`

The signature component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Transaction`.

Instance Property

# deviceVerification

The device verification value to use to verify whether the transaction belongs
to the device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var deviceVerification: Data { get }

Available when `SignedType` is `Transaction`.

## Discussion

For more information about using the `deviceVerification` value, see
`deviceVerification`.

This value is identical to the `deviceVerification` value in `Transaction`.

## See Also

### Getting properties for transactions

`var jwsRepresentation: String`

The transaction signed by the App Store, in JWS compact serialization format.

Available when `SignedType` is `Transaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Transaction`.

`var signedDate: Date`

The date that the App Store signed the JWS transaction.

Available when `SignedType` is `Transaction`.

`var headerData: Data`

The header component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var payloadData: Data`

The payload component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signedData: Data`

The transaction data covered by the signature.

Available when `SignedType` is `Transaction`.

`var signatureData: Data`

The signature component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Transaction`.

Instance Property

# deviceVerificationNonce

The UUID used to compute the device verification value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var deviceVerificationNonce: UUID { get }

Available when `SignedType` is `Transaction`.

## Discussion

Use the lowercased nonce when computing the `deviceVerification` value.

This value is identical to the `deviceVerificationNonce` value in
`Transaction`.

## See Also

### Getting properties for transactions

`var jwsRepresentation: String`

The transaction signed by the App Store, in JWS compact serialization format.

Available when `SignedType` is `Transaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the transaction belongs
to the device.

Available when `SignedType` is `Transaction`.

`var signedDate: Date`

The date that the App Store signed the JWS transaction.

Available when `SignedType` is `Transaction`.

`var headerData: Data`

The header component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var payloadData: Data`

The payload component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signedData: Data`

The transaction data covered by the signature.

Available when `SignedType` is `Transaction`.

`var signatureData: Data`

The signature component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Transaction`.

Instance Property

# signedDate

The date that the App Store signed the JWS transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var signedDate: Date { get }

Available when `SignedType` is `Transaction`.

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the
transaction was valid when the App Store signed the transaction.

## See Also

### Getting properties for transactions

`var jwsRepresentation: String`

The transaction signed by the App Store, in JWS compact serialization format.

Available when `SignedType` is `Transaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the transaction belongs
to the device.

Available when `SignedType` is `Transaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Transaction`.

`var headerData: Data`

The header component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var payloadData: Data`

The payload component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signedData: Data`

The transaction data covered by the signature.

Available when `SignedType` is `Transaction`.

`var signatureData: Data`

The signature component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Transaction`.

Instance Property

# headerData

The header component of the JWS transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var headerData: Data { get }

Available when `SignedType` is `Transaction`.

## See Also

### Getting properties for transactions

`var jwsRepresentation: String`

The transaction signed by the App Store, in JWS compact serialization format.

Available when `SignedType` is `Transaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the transaction belongs
to the device.

Available when `SignedType` is `Transaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Transaction`.

`var signedDate: Date`

The date that the App Store signed the JWS transaction.

Available when `SignedType` is `Transaction`.

`var payloadData: Data`

The payload component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signedData: Data`

The transaction data covered by the signature.

Available when `SignedType` is `Transaction`.

`var signatureData: Data`

The signature component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Transaction`.

Instance Property

# payloadData

The payload component of the JWS transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var payloadData: Data { get }

Available when `SignedType` is `Transaction`.

## Discussion

This value is the same as the `jsonRepresentation` in `Transaction`.

## See Also

### Getting properties for transactions

`var jwsRepresentation: String`

The transaction signed by the App Store, in JWS compact serialization format.

Available when `SignedType` is `Transaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the transaction belongs
to the device.

Available when `SignedType` is `Transaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Transaction`.

`var signedDate: Date`

The date that the App Store signed the JWS transaction.

Available when `SignedType` is `Transaction`.

`var headerData: Data`

The header component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signedData: Data`

The transaction data covered by the signature.

Available when `SignedType` is `Transaction`.

`var signatureData: Data`

The signature component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Transaction`.

Instance Property

# signedData

The transaction data covered by the signature.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var signedData: Data { get }

Available when `SignedType` is `Transaction`.

## See Also

### Getting properties for transactions

`var jwsRepresentation: String`

The transaction signed by the App Store, in JWS compact serialization format.

Available when `SignedType` is `Transaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the transaction belongs
to the device.

Available when `SignedType` is `Transaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Transaction`.

`var signedDate: Date`

The date that the App Store signed the JWS transaction.

Available when `SignedType` is `Transaction`.

`var headerData: Data`

The header component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var payloadData: Data`

The payload component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signatureData: Data`

The signature component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Transaction`.

Instance Property

# signatureData

The signature component of the JWS transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var signatureData: Data { get }

Available when `SignedType` is `Transaction`.

## See Also

### Getting properties for transactions

`var jwsRepresentation: String`

The transaction signed by the App Store, in JWS compact serialization format.

Available when `SignedType` is `Transaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the transaction belongs
to the device.

Available when `SignedType` is `Transaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Transaction`.

`var signedDate: Date`

The date that the App Store signed the JWS transaction.

Available when `SignedType` is `Transaction`.

`var headerData: Data`

The header component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var payloadData: Data`

The payload component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signedData: Data`

The transaction data covered by the signature.

Available when `SignedType` is `Transaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Transaction`.

Instance Property

# signature

The signature component of the JSON web signature.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var signature: P256.Signing.ECDSASignature { get }

Available when `SignedType` is `Transaction`.

## Discussion

Use this `signature` with Apple CryptoKit if you verify the signature on the
device.

## See Also

### Getting properties for transactions

`var jwsRepresentation: String`

The transaction signed by the App Store, in JWS compact serialization format.

Available when `SignedType` is `Transaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the transaction belongs
to the device.

Available when `SignedType` is `Transaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Transaction`.

`var signedDate: Date`

The date that the App Store signed the JWS transaction.

Available when `SignedType` is `Transaction`.

`var headerData: Data`

The header component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var payloadData: Data`

The payload component of the JWS transaction.

Available when `SignedType` is `Transaction`.

`var signedData: Data`

The transaction data covered by the signature.

Available when `SignedType` is `Transaction`.

`var signatureData: Data`

The signature component of the JWS transaction.

Available when `SignedType` is `Transaction`.

Instance Property

# jwsRepresentation

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var jwsRepresentation: String { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## Discussion

Use this value to perform your own JWS verification on your server, or on the
device.

## See Also

### Getting properties for subscription renewal info

`var deviceVerification: Data`

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedDate: Date`

The date that the App Store signed the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var headerData: Data`

The header component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var payloadData: Data`

The payload component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedData: Data`

The subscription renewal info data covered by the signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signatureData: Data`

The signature component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# deviceVerification

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var deviceVerification: Data { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## Discussion

For more information about using the device verification value, see
`deviceVerification`.

This value is identical to the `deviceVerification` value in
`Product.SubscriptionInfo.RenewalInfo`.

## See Also

### Getting properties for subscription renewal info

`var jwsRepresentation: String`

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedDate: Date`

The date that the App Store signed the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var headerData: Data`

The header component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var payloadData: Data`

The payload component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedData: Data`

The subscription renewal info data covered by the signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signatureData: Data`

The signature component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# deviceVerificationNonce

The UUID used to compute the device verification value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var deviceVerificationNonce: UUID { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## Discussion

Use the lowercased nonce when computing the `deviceVerification` value.

This value is identical to the `deviceVerificationNonce` value in
`Product.SubscriptionInfo.RenewalInfo`.

## See Also

### Getting properties for subscription renewal info

`var jwsRepresentation: String`

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerification: Data`

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedDate: Date`

The date that the App Store signed the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var headerData: Data`

The header component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var payloadData: Data`

The payload component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedData: Data`

The subscription renewal info data covered by the signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signatureData: Data`

The signature component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# signedDate

The date that the App Store signed the JWS subscription renewal info.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var signedDate: Date { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the
transaction was valid when the App Store signed the transaction.

## See Also

### Getting properties for subscription renewal info

`var jwsRepresentation: String`

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerification: Data`

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var headerData: Data`

The header component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var payloadData: Data`

The payload component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedData: Data`

The subscription renewal info data covered by the signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signatureData: Data`

The signature component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# headerData

The header component of the JWS subscription renewal info.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var headerData: Data { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## See Also

### Getting properties for subscription renewal info

`var jwsRepresentation: String`

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerification: Data`

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedDate: Date`

The date that the App Store signed the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var payloadData: Data`

The payload component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedData: Data`

The subscription renewal info data covered by the signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signatureData: Data`

The signature component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# payloadData

The payload component of the JWS subscription renewal info.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var payloadData: Data { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## Discussion

This value is the same as the `jsonRepresentation` in
`Product.SubscriptionInfo.RenewalInfo`.

## See Also

### Getting properties for subscription renewal info

`var jwsRepresentation: String`

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerification: Data`

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedDate: Date`

The date that the App Store signed the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var headerData: Data`

The header component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedData: Data`

The subscription renewal info data covered by the signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signatureData: Data`

The signature component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# signedData

The subscription renewal info data covered by the signature.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var signedData: Data { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## See Also

### Getting properties for subscription renewal info

`var jwsRepresentation: String`

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerification: Data`

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedDate: Date`

The date that the App Store signed the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var headerData: Data`

The header component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var payloadData: Data`

The payload component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signatureData: Data`

The signature component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# signatureData

The signature component of the JWS subscription renewal info.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var signatureData: Data { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## See Also

### Getting properties for subscription renewal info

`var jwsRepresentation: String`

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerification: Data`

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedDate: Date`

The date that the App Store signed the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var headerData: Data`

The header component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var payloadData: Data`

The payload component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedData: Data`

The subscription renewal info data covered by the signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# signature

The signature component of the JSON web signature.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var signature: P256.Signing.ECDSASignature { get }

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

## Discussion

Use this `signature` with Apple CryptoKit if you verify the signature on the
device.

## See Also

### Getting properties for subscription renewal info

`var jwsRepresentation: String`

The subscription renewal information signed by the App Store, in JWS compact
serialization format.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerification: Data`

The device verification value to use to verify whether the subscription
renewal info belongs to the device.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedDate: Date`

The date that the App Store signed the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var headerData: Data`

The header component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var payloadData: Data`

The payload component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signedData: Data`

The subscription renewal info data covered by the signature.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

`var signatureData: Data`

The signature component of the JWS subscription renewal info.

Available when `SignedType` is `Product``.``SubscriptionInfo``.``RenewalInfo`.

Instance Property

# jwsRepresentation

The app transaction signed by the App Store, in JWS compact serialization
format.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var jwsRepresentation: String { get }

Available when `SignedType` is `AppTransaction`.

## Discussion

Use this value to perform your own JWS verification on your server or on the
device.

## See Also

### Getting properties for app transactions

`var deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

Available when `SignedType` is `AppTransaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `AppTransaction`.

`var signedDate: Date`

The date that the App Store signed the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var headerData: Data`

The header component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var payloadData: Data`

The payload component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signedData: Data`

The app transaction data covered by the signature.

Available when `SignedType` is `AppTransaction`.

`var signatureData: Data`

The signature component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `AppTransaction`.

Instance Property

# deviceVerification

The device verification value to use to verify whether the app transaction
belongs to the device.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var deviceVerification: Data { get }

Available when `SignedType` is `AppTransaction`.

## Discussion

For more information about using the device verification value, see
`deviceVerification`.

This value is identical to the `deviceVerification` value in `AppTransaction`.

## See Also

### Getting properties for app transactions

`var jwsRepresentation: String`

The app transaction signed by the App Store, in JWS compact serialization
format.

Available when `SignedType` is `AppTransaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `AppTransaction`.

`var signedDate: Date`

The date that the App Store signed the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var headerData: Data`

The header component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var payloadData: Data`

The payload component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signedData: Data`

The app transaction data covered by the signature.

Available when `SignedType` is `AppTransaction`.

`var signatureData: Data`

The signature component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `AppTransaction`.

Instance Property

# deviceVerificationNonce

The UUID used to compute the device verification value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var deviceVerificationNonce: UUID { get }

Available when `SignedType` is `AppTransaction`.

## Discussion

Use the lowercased nonce when computing the `deviceVerification` value.

This value is identical to the `deviceVerificationNonce` value in
`AppTransaction`.

## See Also

### Getting properties for app transactions

`var jwsRepresentation: String`

The app transaction signed by the App Store, in JWS compact serialization
format.

Available when `SignedType` is `AppTransaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

Available when `SignedType` is `AppTransaction`.

`var signedDate: Date`

The date that the App Store signed the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var headerData: Data`

The header component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var payloadData: Data`

The payload component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signedData: Data`

The app transaction data covered by the signature.

Available when `SignedType` is `AppTransaction`.

`var signatureData: Data`

The signature component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `AppTransaction`.

Instance Property

# signedDate

The date that the App Store signed the JWS app transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var signedDate: Date { get }

Available when `SignedType` is `AppTransaction`.

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the
transaction was valid when the App Store signed the transaction.

## See Also

### Getting properties for app transactions

`var jwsRepresentation: String`

The app transaction signed by the App Store, in JWS compact serialization
format.

Available when `SignedType` is `AppTransaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

Available when `SignedType` is `AppTransaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `AppTransaction`.

`var headerData: Data`

The header component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var payloadData: Data`

The payload component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signedData: Data`

The app transaction data covered by the signature.

Available when `SignedType` is `AppTransaction`.

`var signatureData: Data`

The signature component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `AppTransaction`.

Instance Property

# headerData

The header component of the JWS app transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var headerData: Data { get }

Available when `SignedType` is `AppTransaction`.

## See Also

### Getting properties for app transactions

`var jwsRepresentation: String`

The app transaction signed by the App Store, in JWS compact serialization
format.

Available when `SignedType` is `AppTransaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

Available when `SignedType` is `AppTransaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `AppTransaction`.

`var signedDate: Date`

The date that the App Store signed the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var payloadData: Data`

The payload component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signedData: Data`

The app transaction data covered by the signature.

Available when `SignedType` is `AppTransaction`.

`var signatureData: Data`

The signature component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `AppTransaction`.

Instance Property

# payloadData

The payload component of the JWS app transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var payloadData: Data { get }

Available when `SignedType` is `AppTransaction`.

## Discussion

This value is the same as the `jsonRepresentation` in `AppTransaction`.

## See Also

### Getting properties for app transactions

`var jwsRepresentation: String`

The app transaction signed by the App Store, in JWS compact serialization
format.

Available when `SignedType` is `AppTransaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

Available when `SignedType` is `AppTransaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `AppTransaction`.

`var signedDate: Date`

The date that the App Store signed the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var headerData: Data`

The header component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signedData: Data`

The app transaction data covered by the signature.

Available when `SignedType` is `AppTransaction`.

`var signatureData: Data`

The signature component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `AppTransaction`.

Instance Property

# signedData

The app transaction data covered by the signature.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var signedData: Data { get }

Available when `SignedType` is `AppTransaction`.

## See Also

### Getting properties for app transactions

`var jwsRepresentation: String`

The app transaction signed by the App Store, in JWS compact serialization
format.

Available when `SignedType` is `AppTransaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

Available when `SignedType` is `AppTransaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `AppTransaction`.

`var signedDate: Date`

The date that the App Store signed the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var headerData: Data`

The header component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var payloadData: Data`

The payload component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signatureData: Data`

The signature component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `AppTransaction`.

Instance Property

# signatureData

The signature component of the JWS app transaction.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var signatureData: Data { get }

Available when `SignedType` is `AppTransaction`.

## See Also

### Getting properties for app transactions

`var jwsRepresentation: String`

The app transaction signed by the App Store, in JWS compact serialization
format.

Available when `SignedType` is `AppTransaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

Available when `SignedType` is `AppTransaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `AppTransaction`.

`var signedDate: Date`

The date that the App Store signed the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var headerData: Data`

The header component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var payloadData: Data`

The payload component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signedData: Data`

The app transaction data covered by the signature.

Available when `SignedType` is `AppTransaction`.

`var signature: P256.Signing.ECDSASignature`

The signature component of the JSON web signature.

Available when `SignedType` is `AppTransaction`.

Instance Property

# signature

The signature component of the JSON web signature.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var signature: P256.Signing.ECDSASignature { get }

Available when `SignedType` is `AppTransaction`.

## Discussion

Use this `signature` with Apple CryptoKit if you verify the signature on the
device.

## See Also

### Getting properties for app transactions

`var jwsRepresentation: String`

The app transaction signed by the App Store, in JWS compact serialization
format.

Available when `SignedType` is `AppTransaction`.

`var deviceVerification: Data`

The device verification value to use to verify whether the app transaction
belongs to the device.

Available when `SignedType` is `AppTransaction`.

`var deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Available when `SignedType` is `AppTransaction`.

`var signedDate: Date`

The date that the App Store signed the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var headerData: Data`

The header component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var payloadData: Data`

The payload component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

`var signedData: Data`

The app transaction data covered by the signature.

Available when `SignedType` is `AppTransaction`.

`var signatureData: Data`

The signature component of the JWS app transaction.

Available when `SignedType` is `AppTransaction`.

Instance Property

# debugDescription

A description of the verification result that’s suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

Available when `SignedType` conforms to `CustomDebugStringConvertible`.

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: VerificationResult<SignedType>, rhs: VerificationResult<SignedType>) -> Bool

Available when `SignedType` conforms to `Equatable`.

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing verification results

`static func == (VerificationResult<SignedType>,
VerificationResult<SignedType>) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

Available when `SignedType` conforms to `Equatable`.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Available when `SignedType` conforms to `Hashable`.

`var hashValue: Int`

The hash value.

Available when `SignedType` conforms to `Hashable`.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: VerificationResult<SignedType>, b: VerificationResult<SignedType>) -> Bool

Available when `SignedType` conforms to `Equatable`.

## See Also

### Comparing and hashing verification results

`static func != (VerificationResult<SignedType>,
VerificationResult<SignedType>) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

Available when `SignedType` conforms to `Equatable`.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Available when `SignedType` conforms to `Hashable`.

`var hashValue: Int`

The hash value.

Available when `SignedType` conforms to `Hashable`.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

Available when `SignedType` conforms to `Hashable`.

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing verification results

`static func != (VerificationResult<SignedType>,
VerificationResult<SignedType>) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

Available when `SignedType` conforms to `Equatable`.

`static func == (VerificationResult<SignedType>,
VerificationResult<SignedType>) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

Available when `SignedType` conforms to `Equatable`.

`var hashValue: Int`

The hash value.

Available when `SignedType` conforms to `Hashable`.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

Available when `SignedType` conforms to `Hashable`.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing verification results

`static func != (VerificationResult<SignedType>,
VerificationResult<SignedType>) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

Available when `SignedType` conforms to `Equatable`.

`static func == (VerificationResult<SignedType>,
VerificationResult<SignedType>) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

Available when `SignedType` conforms to `Equatable`.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Available when `SignedType` conforms to `Hashable`.



# ProductIconPhase

Enumeration Case

# ProductIconPhase.loading

The promotional image is in the process of loading.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case loading

## See Also

### Getting the promotional image's load phases

`case success(Image)`

The promotional image successfully loaded.

`case unavailable`

The promotional image isn’t available for download.

`case failure(any Error)`

The promotional image failed to load, with an error.

Enumeration Case

# ProductIconPhase.success(_:)

The promotional image successfully loaded.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case success(Image)

## See Also

### Getting the promotional image's load phases

`case loading`

The promotional image is in the process of loading.

`case unavailable`

The promotional image isn’t available for download.

`case failure(any Error)`

The promotional image failed to load, with an error.

Enumeration Case

# ProductIconPhase.unavailable

The promotional image isn’t available for download.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case unavailable

## Discussion

You set up promotional images for in-app purchases in App Store Connect.

## See Also

### Getting the promotional image's load phases

`case loading`

The promotional image is in the process of loading.

`case success(Image)`

The promotional image successfully loaded.

`case failure(any Error)`

The promotional image failed to load, with an error.

Enumeration Case

# ProductIconPhase.failure(_:)

The promotional image failed to load, with an error.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case failure(any Error)

##  Parameters

`Error`

    

The reason that the promotional image failed to load.

## See Also

### Getting the promotional image's load phases

`case loading`

The promotional image is in the process of loading.

`case success(Image)`

The promotional image successfully loaded.

`case unavailable`

The promotional image isn’t available for download.

Instance Property

# promotionalIcon

The promotional image, if the loading task is successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var promotionalIcon: Image? { get }

## Discussion

This value is `nil` while the image is loading, or if the system can’t access
the promotional image for any reason. Use this value as a convenience to
access the image in code that doesn’t depend on the reason an image may not be
accessible.

For information about setting up promotional images, see Promote in-app
purchases.

Instance Property

# error

The error value that indicates the reason a promotional image failed to load.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var error: (any Error)? { get }

## Discussion

The `error` value is `nil` while the icon is loading, if the icon successfully
loads, or if you haven’t set up a promotional image for the in-app purchase in
App Store Connect. Use this value as a convenience to access the error value
in code that assumes you’ve set up a promotional image.

Enumeration Case

# ProductIconPhase.loading

The promotional image is in the process of loading.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case loading

## See Also

### Getting the promotional image's load phases

`case success(Image)`

The promotional image successfully loaded.

`case unavailable`

The promotional image isn’t available for download.

`case failure(any Error)`

The promotional image failed to load, with an error.

Enumeration Case

# ProductIconPhase.success(_:)

The promotional image successfully loaded.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case success(Image)

## See Also

### Getting the promotional image's load phases

`case loading`

The promotional image is in the process of loading.

`case unavailable`

The promotional image isn’t available for download.

`case failure(any Error)`

The promotional image failed to load, with an error.

Enumeration Case

# ProductIconPhase.unavailable

The promotional image isn’t available for download.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case unavailable

## Discussion

You set up promotional images for in-app purchases in App Store Connect.

## See Also

### Getting the promotional image's load phases

`case loading`

The promotional image is in the process of loading.

`case success(Image)`

The promotional image successfully loaded.

`case failure(any Error)`

The promotional image failed to load, with an error.

Enumeration Case

# ProductIconPhase.failure(_:)

The promotional image failed to load, with an error.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case failure(any Error)

##  Parameters

`Error`

    

The reason that the promotional image failed to load.

## See Also

### Getting the promotional image's load phases

`case loading`

The promotional image is in the process of loading.

`case success(Image)`

The promotional image successfully loaded.

`case unavailable`

The promotional image isn’t available for download.

Instance Property

# promotionalIcon

The promotional image, if the loading task is successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var promotionalIcon: Image? { get }

## Discussion

This value is `nil` while the image is loading, or if the system can’t access
the promotional image for any reason. Use this value as a convenience to
access the image in code that doesn’t depend on the reason an image may not be
accessible.

For information about setting up promotional images, see Promote in-app
purchases.

Instance Property

# error

The error value that indicates the reason a promotional image failed to load.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var error: (any Error)? { get }

## Discussion

The `error` value is `nil` while the icon is loading, if the icon successfully
loads, or if you haven’t set up a promotional image for the in-app purchase in
App Store Connect. Use this value as a convenience to access the error value
in code that assumes you’ve set up a promotional image.



# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending

There’s no pending price increase for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case noIncreasePending

## Discussion

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case agreed`

The auto-renewable subscription is subject to a price increase.

`case pending`

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed

The auto-renewable subscription is subject to a price increase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case agreed

## Discussion

There are two types of price increases for auto-renewable subscriptions: those
that require customer consent, and those that don’t require customer consent.
For a price increase that requires customer consent, this value indicates that
the customer consented to the price increase. For a price increase that
doesn’t require customer consent, this value indicates that the App Store
informed the customer of the price increase and the subscription is subject to
the price increase.

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case noIncreasePending`

There’s no pending price increase for the auto-renewable subscription.

`case pending`

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case pending

## Discussion

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case noIncreasePending`

There’s no pending price increase for the auto-renewable subscription.

`case agreed`

The auto-renewable subscription is subject to a price increase.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, rhs: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Status

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, b: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# localizedDescription

A string containing the localized description of the price increase status.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending

There’s no pending price increase for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case noIncreasePending

## Discussion

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case agreed`

The auto-renewable subscription is subject to a price increase.

`case pending`

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed

The auto-renewable subscription is subject to a price increase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case agreed

## Discussion

There are two types of price increases for auto-renewable subscriptions: those
that require customer consent, and those that don’t require customer consent.
For a price increase that requires customer consent, this value indicates that
the customer consented to the price increase. For a price increase that
doesn’t require customer consent, this value indicates that the App Store
informed the customer of the price increase and the subscription is subject to
the price increase.

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case noIncreasePending`

There’s no pending price increase for the auto-renewable subscription.

`case pending`

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case pending

## Discussion

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case noIncreasePending`

There’s no pending price increase for the auto-renewable subscription.

`case agreed`

The auto-renewable subscription is subject to a price increase.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, rhs: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Status

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, b: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# localizedDescription

A string containing the localized description of the price increase status.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending

There’s no pending price increase for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case noIncreasePending

## Discussion

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case agreed`

The auto-renewable subscription is subject to a price increase.

`case pending`

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed

The auto-renewable subscription is subject to a price increase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case agreed

## Discussion

There are two types of price increases for auto-renewable subscriptions: those
that require customer consent, and those that don’t require customer consent.
For a price increase that requires customer consent, this value indicates that
the customer consented to the price increase. For a price increase that
doesn’t require customer consent, this value indicates that the App Store
informed the customer of the price increase and the subscription is subject to
the price increase.

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case noIncreasePending`

There’s no pending price increase for the auto-renewable subscription.

`case pending`

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case pending

## Discussion

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case noIncreasePending`

There’s no pending price increase for the auto-renewable subscription.

`case agreed`

The auto-renewable subscription is subject to a price increase.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, rhs: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Status

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, b: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# localizedDescription

A string containing the localized description of the price increase status.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending

There’s no pending price increase for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case noIncreasePending

## Discussion

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case agreed`

The auto-renewable subscription is subject to a price increase.

`case pending`

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed

The auto-renewable subscription is subject to a price increase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case agreed

## Discussion

There are two types of price increases for auto-renewable subscriptions: those
that require customer consent, and those that don’t require customer consent.
For a price increase that requires customer consent, this value indicates that
the customer consented to the price increase. For a price increase that
doesn’t require customer consent, this value indicates that the App Store
informed the customer of the price increase and the subscription is subject to
the price increase.

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case noIncreasePending`

There’s no pending price increase for the auto-renewable subscription.

`case pending`

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

Enumeration Case

# Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending

The customer hasn’t yet responded to an auto-renewable subscription price
increase that requires customer consent.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case pending

## Discussion

For more information about this value, see Managing Price Increases for Auto-
Renewable Subscriptions.

## See Also

### Getting Price Increase Status

`case noIncreasePending`

There’s no pending price increase for the auto-renewable subscription.

`case agreed`

The auto-renewable subscription is subject to a price increase.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, rhs: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Status

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, b: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Status

`static func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus,
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# localizedDescription

A string containing the localized description of the price increase status.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }



# Product.SubscriptionInfo.Status.Statuses.AsyncIterator

Instance Method

# next()

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    mutating func next() async -> Product.SubscriptionInfo.Status.Statuses.Element?

## Relationships

### From Protocol

  * `AsyncIteratorProtocol`

## See Also

### Getting the Next Element

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

Type Alias

# Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element

The type of element the iterator produces.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element = Product.SubscriptionInfo.Status.Statuses.Element

## Discussion

This iterator produces `Product.SubscriptionInfo.Status` elements.

## See Also

### Getting the Next Element

`func next() -> Product.SubscriptionInfo.Status.Statuses.Element?`

Instance Method

# next()

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    mutating func next() async -> Product.SubscriptionInfo.Status.Statuses.Element?

## Relationships

### From Protocol

  * `AsyncIteratorProtocol`

## See Also

### Getting the Next Element

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

Type Alias

# Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element

The type of element the iterator produces.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element = Product.SubscriptionInfo.Status.Statuses.Element

## Discussion

This iterator produces `Product.SubscriptionInfo.Status` elements.

## See Also

### Getting the Next Element

`func next() -> Product.SubscriptionInfo.Status.Statuses.Element?`

Instance Method

# next()

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    mutating func next() async -> Product.SubscriptionInfo.Status.Statuses.Element?

## Relationships

### From Protocol

  * `AsyncIteratorProtocol`

## See Also

### Getting the Next Element

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

Type Alias

# Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element

The type of element the iterator produces.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element = Product.SubscriptionInfo.Status.Statuses.Element

## Discussion

This iterator produces `Product.SubscriptionInfo.Status` elements.

## See Also

### Getting the Next Element

`func next() -> Product.SubscriptionInfo.Status.Statuses.Element?`

Instance Method

# next()

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    mutating func next() async -> Product.SubscriptionInfo.Status.Statuses.Element?

## Relationships

### From Protocol

  * `AsyncIteratorProtocol`

## See Also

### Getting the Next Element

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

Type Alias

# Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element

The type of element the iterator produces.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element = Product.SubscriptionInfo.Status.Statuses.Element

## Discussion

This iterator produces `Product.SubscriptionInfo.Status` elements.

## See Also

### Getting the Next Element

`func next() -> Product.SubscriptionInfo.Status.Statuses.Element?`



# Transaction.RefundRequestError

Enumeration Case

# Transaction.RefundRequestError.duplicateRequest

The App Store has already received a refund request for this in-app purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case duplicateRequest

## Discussion

StoreKit returns this error if the App Store has previously received a refund
request for this transaction and the refund decision is still pending, has
been previously denied, or has been previously approved.

Consider checking the transaction’s `revocationDate` or `revocationReason`
before calling `beginRefundRequest(for:in:)` to identify whether the App Store
has already refunded the transaction.

## See Also

### Error Enumeration

`case failed`

The refund request submission failed.

Enumeration Case

# Transaction.RefundRequestError.failed

The refund request submission failed.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case failed

## Discussion

A refund request submission can fail for many reasons, such as having an
invalid transaction identifier, or if the App Store can’t process the request
for some other reason.

## See Also

### Error Enumeration

`case duplicateRequest`

The App Store has already received a refund request for this in-app purchase.

Instance Property

# errorDescription

A description of the error, suitable for debugging.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var errorDescription: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Descriptions

`var localizedDescription: String`

A localized error description.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# localizedDescription

A localized error description.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 7.1+

    
    
    var localizedDescription: String { get }

## See Also

### Error Descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# failureReason

A localized message describing the reason for the failure.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var failureReason: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var localizedDescription: String`

A localized error description.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# helpAnchor

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.4+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 7.1+

    
    
    var helpAnchor: String? { get }

## See Also

### Error Descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var localizedDescription: String`

A localized error description.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# recoverySuggestion

A message containing a suggestion for recovering from the error.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var recoverySuggestion: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var localizedDescription: String`

A localized error description.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Transaction.RefundRequestError, rhs: Transaction.RefundRequestError) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Error Comparisons

`static func == (Transaction.RefundRequestError,
Transaction.RefundRequestError) -> Bool`

`var hashValue: Int`

`func hash(into: inout Hasher)`

Operator

# ==(_:_:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Transaction.RefundRequestError, b: Transaction.RefundRequestError) -> Bool

## See Also

### Error Comparisons

`static func != (Transaction.RefundRequestError,
Transaction.RefundRequestError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

`func hash(into: inout Hasher)`

Instance Property

# hashValue

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Error Comparisons

`static func != (Transaction.RefundRequestError,
Transaction.RefundRequestError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Transaction.RefundRequestError,
Transaction.RefundRequestError) -> Bool`

`func hash(into: inout Hasher)`

Instance Method

# hash(into:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Error Comparisons

`static func != (Transaction.RefundRequestError,
Transaction.RefundRequestError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Transaction.RefundRequestError,
Transaction.RefundRequestError) -> Bool`

`var hashValue: Int`



# SKPaymentTransactionObserver

Instance Method

# paymentQueue(_:updatedTransactions:)

Tells an observer that one or more transactions have been updated.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func paymentQueue(
        _ queue: SKPaymentQueue,
        updatedTransactions transactions: [SKPaymentTransaction]
    )

**Required**

##  Parameters

`queue`

    

The payment queue that updated the transactions.

`transactions`

    

An array of the transactions that were updated.

## Discussion

The application should process each transaction by examining the transaction’s
`transactionState` property. If `transactionState` is
`SKPaymentTransactionState.purchased`, payment was successfully received for
the desired functionality. The application should make the functionality
available to the user. If `transactionState` is
`SKPaymentTransactionState.failed`, the application can read the transaction’s
error property to return a meaningful error to the user.

Once a transaction is processed, it should be removed from the payment queue
by calling the payment queue’s `finishTransaction(_:)` method, passing the
transaction as a parameter.

Important

Once the transaction is finished, StoreKit can’t tell you that this item is
already purchased. It is important that applications process the transaction
completely before calling `finishTransaction(_:)`.

## See Also

### Handling transactions

`func paymentQueue(SKPaymentQueue, removedTransactions:
[SKPaymentTransaction])`

Tells an observer that one or more transactions have been removed from the
queue.

### Related Documentation

In-App Purchase Programming Guide

Instance Method

# paymentQueue(_:removedTransactions:)

Tells an observer that one or more transactions have been removed from the
queue.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func paymentQueue(
        _ queue: SKPaymentQueue,
        removedTransactions transactions: [SKPaymentTransaction]
    )

##  Parameters

`queue`

    

The payment queue that updated the transactions.

`transactions`

    

An array of the transactions that were removed.

## Discussion

Your application does not typically need to implement this method but might
implement it to update its own user interface to reflect that a transaction
has been completed.

## See Also

### Handling transactions

`func paymentQueue(SKPaymentQueue, updatedTransactions:
[SKPaymentTransaction])`

Tells an observer that one or more transactions have been updated.

**Required**

Instance Method

# paymentQueue(_:restoreCompletedTransactionsFailedWithError:)

Tells the observer that an error occurred while restoring transactions.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func paymentQueue(
        _ queue: SKPaymentQueue,
        restoreCompletedTransactionsFailedWithError error: any Error
    )

##  Parameters

`queue`

    

The payment queue that was restoring transactions.

`error`

    

The error that occurred.

## See Also

### Restoring transactions

`func paymentQueueRestoreCompletedTransactionsFinished(SKPaymentQueue)`

Tells the observer that the payment queue has finished sending restored
transactions.

Instance Method

# paymentQueueRestoreCompletedTransactionsFinished(_:)

Tells the observer that the payment queue has finished sending restored
transactions.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func paymentQueueRestoreCompletedTransactionsFinished(_ queue: SKPaymentQueue)

##  Parameters

`queue`

    

The payment queue that restored the transactions.

## Discussion

This method is called after all restorable transactions have been processed by
the payment queue. Your application is not required to do anything in this
method.

## See Also

### Restoring transactions

`func paymentQueue(SKPaymentQueue,
restoreCompletedTransactionsFailedWithError: any Error)`

Tells the observer that an error occurred while restoring transactions.

Article

# Promoting in-app purchases

Show promoted in-app purchases on your product page and handle purchases that
users initiate on the App Store.

## Overview

Starting in iOS 11, you can promote in-app purchases on the App Store.

Note

To support promoted in-app purchases in apps with a minimum version of iOS
16.4 and later, use `PurchaseIntent`. For more information, see Supporting
promoted in-app purchases in your app.

Promoted in-app purchases appear on your product page, can appear in search
results, and can appear as featured items on an appropriate tab on the App
Store. Users can start an in-app purchase on the App Store and then transition
to your app to continue the transaction. If your app isn’t installed, they
receive a prompt to download it.

Promoting in-app purchases requires two steps:

  1. In App Store Connect, set up promotions by uploading promotional images. Use the App Store Promotions feature in App Store Connect to manage their order and visibility. For more information about the setup, see Promote in-app purchases.

  2. In your app, implement the delegate method `paymentQueue(_:shouldAddStorePayment:for:)` from the `SKPaymentTransactionObserver` protocol to handle the purchase. 

Important

To enable promoted in-app purchases, your app needs to use either
`PurchaseIntent` (starting in iOS 16.4) or
`paymentQueue(_:shouldAddStorePayment:for:)` (starting in iOS 11). Don’t use
both at the same time. If necessary, use conditional compilation to identify
the OS version the app is running in. For more information, see Running code
on a specific platform or OS version.

To customize the list of promoted in-app purchases for users, you can override
their default order and visibility using `SKProductStorePromotionController`.
Use overrides to show promotions that are relevant to the user. Overrides are
specific to a device, and take effect after the user launches the app at least
once. Using `SKProductStorePromotionController` is optional and isn’t required
for your in-app purchases to appear on the App Store.

For marketing guidance on this feature, see Promoting Your In-App Purchases.

Note

Promoted in-app purchases aren’t available to compatible iPad or iPhone apps
running in visionOS.

### Complete the purchase in the app

When a user selects an in-app product to purchase on the App Store, StoreKit
automatically opens your app and sends the transaction information to the
delegate in the `SKPaymentTransactionObserver` protocol. Your app needs to
complete the purchase transaction and any related actions that are specific to
it.

In the delegate method, return `true` to continue the transaction, or `false`
to defer or cancel it.

If your app isn’t installed when the user selects to purchase the in-app
product, the App Store automatically downloads the app or prompts the user to
purchase it. If the installed version of your app is an older version that
doesn’t support in-app purchase promotions, the App Store prompts the user to
upgrade the app.

### Continue the transaction

To continue an in-app purchase transaction, implement the delegate method in
the `SKPaymentTransactionObserver` protocol and return `true`. StoreKit then
displays the payment sheet, and the user can complete the transaction.

    
    
    //Continuing a transaction from the App Store.
    
    
    //MARK: - SKPaymentTransactionObserver
    
    
    func paymentQueue(_ queue: SKPaymentQueue, shouldAddStorePayment payment: SKPayment,
            for product: SKProduct) -> Bool {
        // Check to see if you can complete the transaction.
        // Return true if you can.
        return true
    }
    

### Defer or cancel the transaction

If your app needs to defer or cancel a transaction, return `false`. For
example, you may need to defer a transaction if the user is in the middle of
onboarding, and continue it after they complete the onboarding. Or, you may
need to cancel a transaction if the user has already unlocked the product
they’re trying to buy.

To defer a transaction:

  1. Save the `payment` to use when the app is ready. The payment already contains information about the product. Don’t create a new `SKPayment` with the same product.

  2. Return `false`.

  3. After the user finishes the onboarding or other actions that require a deferral, send the saved payment to the payment queue as you do with a typical in-app purchase.

To cancel a transaction:

  1. Return `false`.

  2. Provide feedback to the user. Although this step is optional, if you don’t provide feedback, the app’s lack of action after the user selects to purchase an in-app product in the App Store may seem like a bug.

    
    
    //Handling a transaction from the App Store.
    
    
    //MARK: - SKPaymentTransactionObserver
    
    
    func paymentQueue(_ queue: SKPaymentQueue, shouldAddStorePayment payment: SKPayment,
            for product: SKProduct) -> Bool {
    
    
        // Add code here to check if your app needs to defer the transaction.
        let shouldDeferPayment = ...
        // If you need to defer until onboarding is complete, save the payment and return false.
        if shouldDeferPayment {
            self.savedPayment = payment
            return false
        }
    
    
        // Add code here to check if your app needs to cancel the transaction.
        let shouldCancelPayment = ...
        // If you need to cancel the transaction, then return false:
        if shouldCancelPayment {
            return false
        }
    }
    
    
    // If you cancel the transaction, provide feedback to the user.
    
    
    // Continuing a previously deferred payment.
    SKPaymentQueue.default().add(savedPayment)
    

### Get visibility settings

To get the visibility settings for a promoted product, call
`fetchStorePromotionVisibility(for:completionHandler:)`, providing the product
information.

    
    
    // Reading visibility override of a promoted in-app purchase.
    
    
    // Fetch product info for "Hidden Beaches pack."
    
    
    let storePromotionController = SKProductStorePromotionController.default()
    storePromotionController.fetchStorePromotionVisibility(forProduct: hiddenBeaches,
        completionHandler: { visibility: SKProductSTorePromotionVisiblity, error: Error?) in
            // visibility == .default
    })
    

### Override visibility settings

For each device, you can decide whether to make in-app purchases visible or
hidden. For example, you may want to hide products the customer already
purchased, and show only the products they can buy.

For example, to hide the Pro Subscription product after a user purchases it,
fetch the product information and update the store promotion controller with
the `.hide` setting, as the following code example shows. The Pro Subscription
promoted in-app purchase no longer appears in the App Store on the device.

    
    
    // Hide the promoted product Pro Subscription after the user purchases it.
    
    
    let storePromotionController = SKProductStorePromotionController.default()
    storePromotionController.update(storePromotionVisibility: .hide, for: proSubscription,
        completionHandler: { (error: Error?) in
            // Completion.
        })
    

### Override the order of promoted products

You can customize the promoted in-app purchases on each device by overriding
their default order. Use overrides to show promotions that are relevant to the
user. For example, you can override the order to promote an in-app purchase
that unlocks a level in your game when a user reaches the preceding level.

To override the promotion order, add the product information to an array in
the order they are to appear. Pass the array to the
`update(storePromotionOrder:completionHandler:)` method. The App Store
displays the products in the array, followed by the remaining promoted
products, which appear in the same relative order that you set in App Store
Connect.

    
    
    // Overriding the order of promoted in-app purchases.
    
    
    // Fetch product information for three products: Pro Subscription, Fishing Hot Spots, and Hidden Beaches.
    let storePromotionController = SKProductStorePromotionController.default()
    
    
    // Update the order.
    let newProductsOrder = [hiddenBeaches, proSubscription, fishingHotSpots]
    storePromotionController.updateStorePromotionOrder(newProductsOrder,
        completionHandler: { (error: Error?) in
            // Complete.
        })
    

### Cancel order overrides

To remove overrides and use the default promotion order, send an empty product
array to the `update(storePromotionOrder:completionHandler:)` method. The App
Store then displays the promoted in-app purchase products in the default order
that you set in App Store Connect.

### Fetch order overrides

To get the product promotion order for the device, call
`fetchStorePromotionOrder(completionHandler:)`. This method returns an array
of products that have an overridden order. If you get an empty array, there
aren’t any overrides and the products are in the default order.

    
    
    // Getting the order override of promoted in-app purchases.
    
    
    let storePromotionController = SKProductStorePromotionController.default()
    storePromotionController.fetchStorePromotionOrder(completionHandler: {
        (products: [SKProduct], error: Error?) in
            // products == [hiddenBeaches, proSubscription, fishingHotSpots]
        })
    

## See Also

### Promotions

Testing promoted in-app purchases

Test your in-app purchases before making your app available in the App Store.

`class SKProductStorePromotionController`

A product promotion controller for customizing the order and visibility of in-
app purchases per device.

Instance Method

# paymentQueue(_:shouldAddStorePayment:for:)

Tells the observer when a user initiates an in-app purchase from the App
Store.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+  visionOS
1.0+

    
    
    optional func paymentQueue(
        _ queue: SKPaymentQueue,
        shouldAddStorePayment payment: SKPayment,
        for product: SKProduct
    ) -> Bool

##  Parameters

`queue`

    

The payment queue the app uses to make the payment request.

`payment`

    

The payment request.

`product`

    

The in-app purchase product.

## Return Value

Return `true` to continue the transaction in your app.

Return `false` to defer or cancel the transaction.

If you return `false`, you can continue the transaction later by manually
adding the `SKPayment` `payment` to the `SKPaymentQueue` `queue`.

## Discussion

The system calls this delegate method when the user starts an in-app purchase
in the App Store, and the transaction continues in your app. Specifically, if
your app is already installed, StoreKit calls this method automatically.

If your app isn’t installed when the user starts the in-app purchase in the
App Store, the user receives a notification when the app installation is
complete. StoreKit calls this method when the user taps the notification.
Otherwise, if the user opens the app manually, StoreKit calls this method only
if they open the app soon after they initiate the purchase.

Important

To enable promoted in-app purchases, your app needs to use either
`PurchaseIntent` (starting in iOS 16.4) or
`paymentQueue(_:shouldAddStorePayment:for:)` (starting in iOS 11). Don’t use
both at the same time. If necessary, use conditional compilation to identify
the OS version the app is running in. For more information, see Running code
on a specific platform or OS version.

For more information, see Promoting in-app purchases.

## See Also

### Handling promoted in-app purchases

Promoting in-app purchases

Show promoted in-app purchases on your product page and handle purchases that
users initiate on the App Store.

Instance Method

# paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:)

Tells an observer that the user is no longer entitled to one or more Family
Sharing purchases.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 14.0+  watchOS
7.0+  visionOS 1.0+

    
    
    optional func paymentQueue(
        _ queue: SKPaymentQueue,
        didRevokeEntitlementsForProductIdentifiers productIdentifiers: [String]
    )

##  Parameters

`queue`

    

The payment queue that calls the delegate method.

`productIdentifiers`

    

The list of product identifiers with revoked entitlements.

## Discussion

The system calls this delegate method whenever App Store revokes in-app
purchases for a family member based on changes in Family Sharing, or when the
purchaser gets a refund for an in-app purchase. Implement this method in your
payment queue observer to reestablish a user’s access to products. Revoked
transactions have the `cancellation_date` populated in the receipt.

For products with Family Sharing enabled, the following conditions may trigger
this method in the family member’s app:

  * The purchaser receives a refund for a non-consumable or an auto-renewable subscription they shared.

  * The purchaser leaves the family group in which they were sharing subscriptions or non-consumables.

  * The purchaser disables Family Sharing for a non-consumable or stops sharing a subscription.

  * The purchaser hides an app, which makes their non-consumable purchase unavailable for sharing.

  * The family member leaves the group and no longer gets access to shared purchases.

  * The family organizer stops sharing payment in iCloud family settings. This change affects non-consumables.

By leaving a family group, or disabling sharing in any of the ways listed
above, family members are no longer entitled to family-shared purchases. The
`productIdentifiers` parameter contains the revoked product IDs. Your app
needs to check the receipt on the device, which the system automatically
updates prior to calling this method, and provide the correct level of access
for the in-app purchases.

If you receive App Store Server Notifications, your server receives a
`notificationType` `REVOKE` for the family member when the conditions listed
above occur.

Important

Always check the receipt to determine the users’s correct level of access for
the product. A user may lose access through Family Sharing, but may have
purchased the product directly.

StoreKit also calls this method in the purchaser’s app when the purchaser
receives a refund for a non-consumable or an auto-renewable subscription,
regardless if the product is shared with the family. If you receive App Store
Server Notifications, your server receives a `notificationType` `REFUND` for
the purchaser.

If you use server-side receipt validation with the App Store, call your server
to reprocess the receipt and update your purchase records.

Instance Method

# paymentQueueDidChangeStorefront(_:)

Tells the observer that the storefront for the payment queue has changed.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 13.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func paymentQueueDidChangeStorefront(_ queue: SKPaymentQueue)

## Discussion

See `SKStorefront` for more information.

Instance Method

# paymentQueue(_:updatedDownloads:)

Tells the observer that the payment queue has updated one or more download
objects.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    optional func paymentQueue(
        _ queue: SKPaymentQueue,
        updatedDownloads downloads: [SKDownload]
    )

##  Parameters

`queue`

    

The payment queue that updated the downloads.

`downloads`

    

The download objects that were updated.

## Discussion

When a download object is updated, its `downloadState` property describes how
it changed.



# PurchaseAction

Instance Method

# callAsFunction(_:options:)

Starts an in-app purchase for the indicated product and purchase options.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func callAsFunction(
        _ product: Product,
        options: Set<Product.PurchaseOption> = []
    ) async throws -> Product.PurchaseResult

##  Parameters

`product`

    

The in-app purchase `Product` the customer is purchasing.

`options`

    

A set of options you may associate with the purchase
(`Product.PurchaseOption`).

## Return Value

The result of the purchase, `Product.PurchaseResult`.

## Discussion

Don’t call this method directly. SwiftUI calls it when you call the
`PurchaseAction` structure with the `product` and `options` as arguments.

This method may throw a `Product.PurchaseError` or `StoreKitError`.

For information about how Swift uses the `callAsFunction(_:options:)` method
to simplify call site syntax, see Methods with Special Names in _The Swift
Programming Language_.



# SKStoreProductViewControllerDelegate

Instance Method

# productViewControllerDidFinish(_:)

Called when the user dismisses the store screen.

iOS 6.0+  iPadOS 6.0+  macOS 11.0+  Mac Catalyst 13.0+

    
    
    optional func productViewControllerDidFinish(_ viewController: SKStoreProductViewController)

##  Parameters

`viewController`

    

The store view controller whose interface was dismissed by the user.

## Discussion

Your delegate should call the `dismissModalViewController(animated:)` method
on the view controller that originally presented the store screen. If your app
paused any other activities before presenting the store, it can restart those
services in this method.

## See Also

### Related Documentation

In-App Purchase Programming Guide



# SKRequest

Instance Method

# start()

Sends the request to the Apple App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func start()

## Discussion

The results for a request are sent to the request’s delegate.

## See Also

### Controlling the Request

`func cancel()`

Cancels a previously started request.

### Related Documentation

In-App Purchase Programming Guide

Instance Method

# cancel()

Cancels a previously started request.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func cancel()

## Discussion

When you cancel a request, the delegate is not called with an error.

## See Also

### Controlling the Request

`func start()`

Sends the request to the Apple App Store.

Instance Property

# delegate

The delegate of the request object.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    weak var delegate: (any SKRequestDelegate)? { get set }

## Discussion

The delegate must adopt the `SKRequestDelegate` protocol, although most
subclasses of `SKRequest` provide a more specific protocol to implement.

## See Also

### Accessing the Delegate

`protocol SKRequestDelegate`

Common methods that are implemented by delegates for any subclass of the
`SKRequest` abstract class.

Instance Method

# start()

Sends the request to the Apple App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func start()

## Discussion

The results for a request are sent to the request’s delegate.

## See Also

### Controlling the Request

`func cancel()`

Cancels a previously started request.

### Related Documentation

In-App Purchase Programming Guide

Instance Method

# cancel()

Cancels a previously started request.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func cancel()

## Discussion

When you cancel a request, the delegate is not called with an error.

## See Also

### Controlling the Request

`func start()`

Sends the request to the Apple App Store.

Instance Property

# delegate

The delegate of the request object.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    weak var delegate: (any SKRequestDelegate)? { get set }

## Discussion

The delegate must adopt the `SKRequestDelegate` protocol, although most
subclasses of `SKRequest` provide a more specific protocol to implement.

## See Also

### Accessing the Delegate

`protocol SKRequestDelegate`

Common methods that are implemented by delegates for any subclass of the
`SKRequest` abstract class.



# Product.CollectionTaskState

Enumeration Case

# Product.CollectionTaskState.loading

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case loading

## See Also

### Collection task states

`case success([Product], unavailable: [Product.ID])`

`case failure(any Error)`

Enumeration Case

# Product.CollectionTaskState.success(_:unavailable:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case success(
        [Product],
        unavailable: [Product.ID]
    )

## See Also

### Collection task states

`case loading`

`case failure(any Error)`

Enumeration Case

# Product.CollectionTaskState.failure(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case failure(any Error)

## See Also

### Collection task states

`case loading`

`case success([Product], unavailable: [Product.ID])`



# SKProductSubscriptionPeriod

Instance Property

# numberOfUnits

The number of units per subscription period.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var numberOfUnits: Int { get }

## Discussion

A subscription period duration is calculated by multiplying the number of
units by the `unit`.

For example, if the number of units is `3`, and the unit is
`SKProduct.PeriodUnit.month`, the subscription period is 3 months.

## See Also

### Getting Subscription Period Details

`var unit: SKProduct.PeriodUnit`

The increment of time that a subscription period is specified in.

`enum SKProduct.PeriodUnit`

Values representing the duration of an interval, from a day up to a year.

Instance Property

# unit

The increment of time that a subscription period is specified in.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var unit: SKProduct.PeriodUnit { get }

## Discussion

The units used to specify a subscription period include day, week, month, and
year, as defined in `SKProduct.PeriodUnit`.

To calculate the duration of one subscription period, multiply the `unit` by
the number of units (`numberOfUnits`).

## See Also

### Getting Subscription Period Details

`var numberOfUnits: Int`

The number of units per subscription period.

`enum SKProduct.PeriodUnit`

Values representing the duration of an interval, from a day up to a year.



# SKProductDiscount

Instance Property

# identifier

A string used to uniquely identify a discount offer for a product.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var identifier: String? { get }

## Discussion

You set up offers and their identifiers in App Store Connect.

## See Also

### Identifying the Discount

`var type: SKProductDiscount.`Type``

The type of discount offer.

`enum SKProductDiscount.Type`

Values representing the types of discount offers an app can present.

Instance Property

# type

The type of discount offer.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var type: SKProductDiscount.`Type` { get }

## See Also

### Identifying the Discount

`var identifier: String?`

A string used to uniquely identify a discount offer for a product.

`enum SKProductDiscount.Type`

Values representing the types of discount offers an app can present.

Instance Property

# price

The discount price of the product in the local currency.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var price: NSDecimalNumber { get }

## Discussion

Use the `priceLocale` to format the price.

## See Also

### Getting Price and Payment Mode

`var priceLocale: Locale`

The locale used to format the discount price of the product.

`var paymentMode: SKProductDiscount.PaymentMode`

The payment mode for this product discount.

`enum SKProductDiscount.PaymentMode`

Values representing the payment modes for a product discount.

Instance Property

# priceLocale

The locale used to format the discount price of the product.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var priceLocale: Locale { get }

## Discussion

Use the locale to format the `price`.

## See Also

### Getting Price and Payment Mode

`var price: NSDecimalNumber`

The discount price of the product in the local currency.

`var paymentMode: SKProductDiscount.PaymentMode`

The payment mode for this product discount.

`enum SKProductDiscount.PaymentMode`

Values representing the payment modes for a product discount.

Instance Property

# paymentMode

The payment mode for this product discount.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var paymentMode: SKProductDiscount.PaymentMode { get }

## Discussion

The payment mode indicates how the product discount `price` is charged:

  * One or more times, for `SKProductDiscount.PaymentMode.payAsYouGo` mode

  * Once in advance, for `SKProductDiscount.PaymentMode.payUpFront` mode

  * No initial charge, for `SKProductDiscount.PaymentMode.freeTrial` mode.

Use the payment mode to display an accurate description of the product
discount in your UI. For design guidance, see Human Interface Guidelines > In-
App Purchase.

## See Also

### Getting Price and Payment Mode

`var price: NSDecimalNumber`

The discount price of the product in the local currency.

`var priceLocale: Locale`

The locale used to format the discount price of the product.

`enum SKProductDiscount.PaymentMode`

Values representing the payment modes for a product discount.

Instance Property

# numberOfPeriods

An integer that indicates the number of periods the product discount is
available.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var numberOfPeriods: Int { get }

## Discussion

A product discount may be available for one or more periods. The period,
defined in `subscriptionPeriod`, is a set number of days, weeks, months, or
years.

The total length of time that a product discount is available is calculated by
multiplying the `numberOfPeriods` by the period.

Note that the discount period is independent of the product subscription
period.

## See Also

### Getting the Discount Duration

`var subscriptionPeriod: SKProductSubscriptionPeriod`

An object that defines the period for the product discount.

Instance Property

# subscriptionPeriod

An object that defines the period for the product discount.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var subscriptionPeriod: SKProductSubscriptionPeriod { get }

## Discussion

This object represents the duration of a single subscription period. A period
is described as a number of units, where a unit can be a
`SKProduct.PeriodUnit.day`, `SKProduct.PeriodUnit.month`,
`SKProduct.PeriodUnit.week`, or `SKProduct.PeriodUnit.year`.

To calculate the total amount of time that the discount price is available to
the user, multiply the `subscriptionPeriod` by `numberOfPeriods`.

Note

The subscription period for the discount is independent of the product's
regular subscription period, and does not have to match in units or duration.

## See Also

### Getting the Discount Duration

`var numberOfPeriods: Int`

An integer that indicates the number of periods the product discount is
available.

Instance Property

# identifier

A string used to uniquely identify a discount offer for a product.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var identifier: String? { get }

## Discussion

You set up offers and their identifiers in App Store Connect.

## See Also

### Identifying the Discount

`var type: SKProductDiscount.`Type``

The type of discount offer.

`enum SKProductDiscount.Type`

Values representing the types of discount offers an app can present.

Instance Property

# type

The type of discount offer.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var type: SKProductDiscount.`Type` { get }

## See Also

### Identifying the Discount

`var identifier: String?`

A string used to uniquely identify a discount offer for a product.

`enum SKProductDiscount.Type`

Values representing the types of discount offers an app can present.

Instance Property

# price

The discount price of the product in the local currency.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var price: NSDecimalNumber { get }

## Discussion

Use the `priceLocale` to format the price.

## See Also

### Getting Price and Payment Mode

`var priceLocale: Locale`

The locale used to format the discount price of the product.

`var paymentMode: SKProductDiscount.PaymentMode`

The payment mode for this product discount.

`enum SKProductDiscount.PaymentMode`

Values representing the payment modes for a product discount.

Instance Property

# priceLocale

The locale used to format the discount price of the product.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var priceLocale: Locale { get }

## Discussion

Use the locale to format the `price`.

## See Also

### Getting Price and Payment Mode

`var price: NSDecimalNumber`

The discount price of the product in the local currency.

`var paymentMode: SKProductDiscount.PaymentMode`

The payment mode for this product discount.

`enum SKProductDiscount.PaymentMode`

Values representing the payment modes for a product discount.

Instance Property

# paymentMode

The payment mode for this product discount.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var paymentMode: SKProductDiscount.PaymentMode { get }

## Discussion

The payment mode indicates how the product discount `price` is charged:

  * One or more times, for `SKProductDiscount.PaymentMode.payAsYouGo` mode

  * Once in advance, for `SKProductDiscount.PaymentMode.payUpFront` mode

  * No initial charge, for `SKProductDiscount.PaymentMode.freeTrial` mode.

Use the payment mode to display an accurate description of the product
discount in your UI. For design guidance, see Human Interface Guidelines > In-
App Purchase.

## See Also

### Getting Price and Payment Mode

`var price: NSDecimalNumber`

The discount price of the product in the local currency.

`var priceLocale: Locale`

The locale used to format the discount price of the product.

`enum SKProductDiscount.PaymentMode`

Values representing the payment modes for a product discount.

Instance Property

# numberOfPeriods

An integer that indicates the number of periods the product discount is
available.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var numberOfPeriods: Int { get }

## Discussion

A product discount may be available for one or more periods. The period,
defined in `subscriptionPeriod`, is a set number of days, weeks, months, or
years.

The total length of time that a product discount is available is calculated by
multiplying the `numberOfPeriods` by the period.

Note that the discount period is independent of the product subscription
period.

## See Also

### Getting the Discount Duration

`var subscriptionPeriod: SKProductSubscriptionPeriod`

An object that defines the period for the product discount.

Instance Property

# subscriptionPeriod

An object that defines the period for the product discount.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    var subscriptionPeriod: SKProductSubscriptionPeriod { get }

## Discussion

This object represents the duration of a single subscription period. A period
is described as a number of units, where a unit can be a
`SKProduct.PeriodUnit.day`, `SKProduct.PeriodUnit.month`,
`SKProduct.PeriodUnit.week`, or `SKProduct.PeriodUnit.year`.

To calculate the total amount of time that the discount price is available to
the user, multiply the `subscriptionPeriod` by `numberOfPeriods`.

Note

The subscription period for the discount is independent of the product's
regular subscription period, and does not have to match in units or duration.

## See Also

### Getting the Discount Duration

`var numberOfPeriods: Int`

An integer that indicates the number of periods the product discount is
available.



# SKProduct.PeriodUnit

Enumeration Case

# SKProduct.PeriodUnit.day

An interval lasting one day.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case day = 0

## See Also

### Period Units

`case month`

An interval lasting one month.

`case week`

An interval lasting one week.

`case year`

An interval lasting one year.

Enumeration Case

# SKProduct.PeriodUnit.month

An interval lasting one month.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case month = 2

## See Also

### Period Units

`case day`

An interval lasting one day.

`case week`

An interval lasting one week.

`case year`

An interval lasting one year.

Enumeration Case

# SKProduct.PeriodUnit.week

An interval lasting one week.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case week = 1

## See Also

### Period Units

`case day`

An interval lasting one day.

`case month`

An interval lasting one month.

`case year`

An interval lasting one year.

Enumeration Case

# SKProduct.PeriodUnit.year

An interval lasting one year.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case year = 3

## See Also

### Period Units

`case day`

An interval lasting one day.

`case month`

An interval lasting one month.

`case week`

An interval lasting one week.

Enumeration Case

# SKProduct.PeriodUnit.day

An interval lasting one day.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case day = 0

## See Also

### Period Units

`case month`

An interval lasting one month.

`case week`

An interval lasting one week.

`case year`

An interval lasting one year.

Enumeration Case

# SKProduct.PeriodUnit.month

An interval lasting one month.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case month = 2

## See Also

### Period Units

`case day`

An interval lasting one day.

`case week`

An interval lasting one week.

`case year`

An interval lasting one year.

Enumeration Case

# SKProduct.PeriodUnit.week

An interval lasting one week.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case week = 1

## See Also

### Period Units

`case day`

An interval lasting one day.

`case month`

An interval lasting one month.

`case year`

An interval lasting one year.

Enumeration Case

# SKProduct.PeriodUnit.year

An interval lasting one year.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case year = 3

## See Also

### Period Units

`case day`

An interval lasting one day.

`case month`

An interval lasting one month.

`case week`

An interval lasting one week.



# SKPaymentQueue

Type Method

# canMakePayments()

A method that indicates whether the person can make purchases.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    class func canMakePayments() -> Bool

## Discussion

The Boolean value that this method returns is identical to the value of the
type property `canMakePayments` in the `AppStore` object. For more information
about using and interpreting this value, see the type property page
`canMakePayments`.

Instance Property

# storefront

The App Store storefront of the device.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 13.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var storefront: SKStorefront? { get }

## Discussion

The storefront information tells you the device's App Store region. You can
use this information to display products that your app makes available in
specific regions. You maintain your own list of product identifiers and the
storefronts in which you make them available.

If the storefront changes during a transaction, StoreKit notifies your app by
calling the `paymentQueueDidChangeStorefront(_:)` method of the
`SKPaymentTransactionObserver` protocol. Implement
`paymentQueue(_:shouldContinue:in:)` to indicate whether the transaction
should continue with the new storefront.

Important

`storefront` is a synchronous API that may take significant time to return.
Don't use `storefront` in a time-sensitive thread, such as during app launch.
To get asynchronous behavior, dispatch it to a separate queue, or use the
asynchronous `current` property of `Storefront` instead.

Type Method

# default()

Returns the default payment queue instance.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    class func `default`() -> Self

## Return Value

The default payment queue.

## Discussion

Apps do not create a payment queue. Instead, they retrieve the queue by
calling this class method.

### Special Considerations

The payment queue is not available in Simulator. Attempting to retrieve the
payment queue logs a warning.

Instance Method

# add(_:)

Adds an observer to the payment queue.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func add(_ observer: any SKPaymentTransactionObserver)

##  Parameters

`observer`

    

The observer to add to the queue.

## Discussion

Your application should add an observer to the payment queue during
application initialization. If there are no observers attached to the queue,
the payment queue does not synchronize its list of pending transactions with
the Apple App Store, because there is no observer to respond to updated
transactions.

If an application quits when transactions are still being processed, those
transactions are not lost. The next time the application launches, the payment
queue resumes processing the transactions. Your application should always
expect to be notified of completed transactions.

If more than one transaction observer is attached to the payment queue, no
guarantees are made as to the order which they will be called. It is safe for
multiple observers to call `finishTransaction(_:)`, but not recommended. It is
recommended that you use a single observer to process and finish the
transaction.

## See Also

### Adding, Getting, and Removing Observers

`var transactionObservers: [any SKPaymentTransactionObserver]`

An array of all active payment queue observers.

`func remove(any SKPaymentTransactionObserver)`

Removes an observer from the payment queue.

### Related Documentation

`var transactions: [SKPaymentTransaction]`

Returns an array of pending transactions.

Instance Property

# transactionObservers

An array of all active payment queue observers.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 14.0+  watchOS
7.0+  visionOS 1.0+

    
    
    var transactionObservers: [any SKPaymentTransactionObserver] { get }

## See Also

### Adding, Getting, and Removing Observers

`func add(any SKPaymentTransactionObserver)`

Adds an observer to the payment queue.

`func remove(any SKPaymentTransactionObserver)`

Removes an observer from the payment queue.

Instance Method

# remove(_:)

Removes an observer from the payment queue.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func remove(_ observer: any SKPaymentTransactionObserver)

##  Parameters

`observer`

    

The observer to remove.

## Discussion

If there are no observers attached to the queue, the payment queue does not
synchronize its list of pending transactions with the Apple App Store, because
there is no observer to respond to updated transactions.

## See Also

### Adding, Getting, and Removing Observers

`func add(any SKPaymentTransactionObserver)`

Adds an observer to the payment queue.

`var transactionObservers: [any SKPaymentTransactionObserver]`

An array of all active payment queue observers.

### Related Documentation

`var transactions: [SKPaymentTransaction]`

Returns an array of pending transactions.

Instance Property

# delegate

A delegate that provides information needed to complete transactions.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 13.0+  watchOS
6.2+  visionOS 1.0+

    
    
    weak var delegate: (any SKPaymentQueueDelegate)? { get set }

## Discussion

This delegate implements the `SKPaymentQueueDelegate` protocol.

## See Also

### Managing Transactions

`var transactions: [SKPaymentTransaction]`

Returns an array of pending transactions.

`func add(SKPayment)`

Adds a payment request to the queue.

`func finishTransaction(SKPaymentTransaction)`

Notifies the App Store that the app finished processing the transaction.

Instance Property

# transactions

Returns an array of pending transactions.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var transactions: [SKPaymentTransaction] { get }

## Discussion

The value of this property is undefined when there are no observers attached
to the payment queue.

## See Also

### Managing Transactions

`var delegate: (any SKPaymentQueueDelegate)?`

A delegate that provides information needed to complete transactions.

`func add(SKPayment)`

Adds a payment request to the queue.

`func finishTransaction(SKPaymentTransaction)`

Notifies the App Store that the app finished processing the transaction.

### Related Documentation

`func add(any SKPaymentTransactionObserver)`

Adds an observer to the payment queue.

Instance Method

# add(_:)

Adds a payment request to the queue.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func add(_ payment: SKPayment)

##  Parameters

`payment`

    

A payment request.

## Discussion

An application should always have at least one observer of the payment queue
before adding payment requests.

The payment request must have a product identifier registered with the Apple
App Store and a quantity greater than `0`. If either property is invalid,
`add(_:)` throws an exception.

When a payment request is added to the queue, the payment queue processes that
request with the Apple App Store and arranges for payment from the user. When
that transaction is complete or if a failure occurs, the payment queue sends
the `SKPaymentTransaction` object that encapsulates the request to all
transaction observers.

## See Also

### Managing Transactions

`var delegate: (any SKPaymentQueueDelegate)?`

A delegate that provides information needed to complete transactions.

`var transactions: [SKPaymentTransaction]`

Returns an array of pending transactions.

`func finishTransaction(SKPaymentTransaction)`

Notifies the App Store that the app finished processing the transaction.

Instance Method

# finishTransaction(_:)

Notifies the App Store that the app finished processing the transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func finishTransaction(_ transaction: SKPaymentTransaction)

##  Parameters

`transaction`

    

The transaction to finish.

## Discussion

Transactions on the payment queue are persistent until they are completed.
StoreKit calls your observer’s `paymentQueue(_:updatedTransactions:)` method
every time your app launches or resumes from background to tell you about
transactions in the queue. After you've finished processing a transaction in
your app, always call the `finishTransaction(_:)` method to finish the
transaction and remove it from the queue.

Call `finishTransaction(_:)` only after the app has finished all work it
performs to complete the transaction. The transaction's state determines which
steps you might take:

  * For a failed transaction (`SKPaymentTransactionState.failed`), update your user interface, track information in analytics, and perform other similar tasks.

  * For a successful transaction (`SKPaymentTransactionState.purchased` or `SKPaymentTransactionState.restored`), perform all necessary actions to unlock the functionality the user has purchased before finishing the transaction. For example, if you are downloading content, finish the transaction only after the downloads are complete.

If you validate receipts, validate them before completing the transaction, and
take one of the paths described above.

In rare circumstances, this call might fail, and you'll receive updates for
that transaction again. For this reason, you should record information in your
app about the transactions it has processed and which steps the app has
already completed. That way, you don't repeat steps that shouldn't be
performed multiple times. For example, if you are processing a consumable
transaction, you only want to add the consumable benefit once.

If you call `finishTransaction(_:)` on a transaction that is in the
`SKPaymentTransactionState.purchasing` state, StoreKit raises an exception.

## See Also

### Managing Transactions

`var delegate: (any SKPaymentQueueDelegate)?`

A delegate that provides information needed to complete transactions.

`var transactions: [SKPaymentTransaction]`

Returns an array of pending transactions.

`func add(SKPayment)`

Adds a payment request to the queue.

### Related Documentation

`func paymentQueue(SKPaymentQueue, updatedTransactions:
[SKPaymentTransaction])`

Tells an observer that one or more transactions have been updated.

Instance Method

# restoreCompletedTransactions()

Asks the payment queue to restore previously completed purchases.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func restoreCompletedTransactions()

## Discussion

Use this method to restore finished transactions—that is, transactions for
which you have already called `finishTransaction(_:)`. You call this method in
one of the following situations:

  * To install purchases on additional devices

  * To restore purchases for an application that the user deleted and reinstalled

When you create a new product to be sold in your store, you choose whether
that product can be restored or not. See the In-App Purchase Programming Guide
for more information.

The payment queue delivers a new transaction for each previously completed
transaction that can be restored. Each transaction includes a copy of the
original transaction.

After the transactions are delivered, the payment queue calls the observer’s
`paymentQueueRestoreCompletedTransactionsFinished(_:)` method. If an error
occurred while restoring transactions, the observer will be notified through
its `paymentQueue(_:restoreCompletedTransactionsFailedWithError:)` method.

This method has no effect in the following situations:

  * All transactions are unfinished.

  * The user did not purchase anything that is restorable.

  * You tried to restore items that are not restorable, such as a non-renewing subscription or a consumable product.

  * Your app's build version does not meet the guidelines for the `CFBundleVersion` key.

Important

If you are using the In-App Purchase API and managing transactions using the
`Transaction` API, use `currentEntitlements` to determine which in-app
purchases the customer is currently entitled to. The
`restoreCompletedTransactions()` function doesn't affect transactions in the
`Transaction` API. In rare cases when a user suspects the app isn’t showing
all the transactions, call `sync()` in response to an explicit user action,
like tapping a button.

## See Also

### Restoring Purchases

`func restoreCompletedTransactions(withApplicationUsername: String?)`

Asks the payment queue to restore previously completed purchases, providing an
opaque identifier for the user’s account.

Instance Method

# restoreCompletedTransactions(withApplicationUsername:)

Asks the payment queue to restore previously completed purchases, providing an
opaque identifier for the user’s account.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func restoreCompletedTransactions(withApplicationUsername username: String?)

##  Parameters

`username`

    

An opaque identifier for the user’s account on your system.

## See Also

### Restoring Purchases

`func restoreCompletedTransactions()`

Asks the payment queue to restore previously completed purchases.

### Related Documentation

`var applicationUsername: String?`

A string that associates the transaction with a user account on your service.

Instance Method

# showPriceConsentIfNeeded()

Asks the system to display the price consent sheet if the user hasn’t yet
responded to a subscription price increase.

iOS 13.4+  iPadOS 13.4+  Mac Catalyst 13.4+  visionOS 1.0+

    
    
    func showPriceConsentIfNeeded()

## Discussion

Call this method if the system called your delegate’s
`paymentQueueShouldShowPriceConsent(_:)` method, and you chose to delay
showing the price consent sheet.

This function displays the price consent sheet if both of the following are
true:

  * You’ve increased the price of the subscription in App Store Connect.

  * The subscriber hasn’t yet responded to a price consent query.

Otherwise, this function has no effect.

Note

When you increase the price of a subscription, Apple informs affected
subscribers through an email, push notification, and in-app price consent
sheet and asks them to agree to the new price. If they don’t agree or take no
action, their subscription expires at the end of their current billing cycle.
For more information, see Managing Prices and Manage pricing for auto-
renewable subscriptions.

In Mac apps built with Mac Catalyst, this function has no effect.

## See Also

### Related Documentation

`func paymentQueueShouldShowPriceConsent(SKPaymentQueue) -> Bool`

Asks the delegate whether to immediately display a price consent sheet.

Instance Method

# presentCodeRedemptionSheet()

Displays a sheet that enables users to redeem subscription offer codes that
you configure in App Store Connect.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    func presentCodeRedemptionSheet()

## Discussion

The `presentCodeRedemptionSheet()` function displays a system sheet where
customers can enter and redeem subscription offer codes. If you generate
subscription offer codes in App Store Connect, call this function to enable
users to redeem the offer.

Note

For apps with more than one scene, and on iOS 16 or later and iPadOS 16 or
later, use `offerCodeRedemption(isPresented:onCompletion:)` or
`presentOfferCodeRedeemSheet(in:)` instead.

When your app calls `presentCodeRedemptionSheet()`, the system determines
where to display the screen. Use `presentCodeRedemptionSheet()` to support
devices running iOS 14 through iOS 15, and iPadOS 14 through iPadOS 15.

For information on implementing subscription offer codes, see Implementing
offer codes in your app.

Important

Set up subscription offer codes in App Store Connect before calling this API.
Customers can only redeem these offers in your app through the redemption
sheet; don’t use a custom UI. For information on configuring and generating
subscription offer codes, see Set up offer codes.

This method applies to subscription offer codes only; it doesn’t apply to
promo codes for apps or in-app purchases. For more information on promo codes,
see Request and manage promo codes.

This function doesn’t affect Mac apps built with Mac Catalyst.

Instance Method

# start(_:)

Adds a set of downloads to the download list.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    func start(_ downloads: [SKDownload])

##  Parameters

`downloads`

    

An array of `SKDownload` objects to begin downloading.

## Discussion

In order for a download object to be queued, it must be associated with a
transaction that has been successfully purchased, but not yet finished.

## See Also

### Downloading Content

`func cancel([SKDownload])`

Removes a set of downloads from the download list.

Deprecated

`func pause([SKDownload])`

Pauses a set of downloads.

Deprecated

`func resume([SKDownload])`

Resumes a set of downloads.

Deprecated

Instance Method

# cancel(_:)

Removes a set of downloads from the download list.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    func cancel(_ downloads: [SKDownload])

##  Parameters

`downloads`

    

An array of `SKDownload` objects to cancel.

## See Also

### Downloading Content

`func start([SKDownload])`

Adds a set of downloads to the download list.

Deprecated

`func pause([SKDownload])`

Pauses a set of downloads.

Deprecated

`func resume([SKDownload])`

Resumes a set of downloads.

Deprecated

Instance Method

# pause(_:)

Pauses a set of downloads.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    func pause(_ downloads: [SKDownload])

##  Parameters

`downloads`

    

An array of `SKDownload` objects to pause.

## See Also

### Downloading Content

`func start([SKDownload])`

Adds a set of downloads to the download list.

Deprecated

`func cancel([SKDownload])`

Removes a set of downloads from the download list.

Deprecated

`func resume([SKDownload])`

Resumes a set of downloads.

Deprecated

Instance Method

# resume(_:)

Resumes a set of downloads.

iOS 6.0–16.0  Deprecated  iPadOS 6.0–16.0  Deprecated  macOS 10.8–13.0
Deprecated  Mac Catalyst 13.1–16.0  Deprecated  tvOS 9.0–16.0  Deprecated
watchOS 6.2–9.0  Deprecated

    
    
    func resume(_ downloads: [SKDownload])

##  Parameters

`downloads`

    

An array of `SKDownload` objects to resume.

## See Also

### Downloading Content

`func start([SKDownload])`

Adds a set of downloads to the download list.

Deprecated

`func cancel([SKDownload])`

Removes a set of downloads from the download list.

Deprecated

`func pause([SKDownload])`

Pauses a set of downloads.

Deprecated



# Verifying an install-validation postback

Article

# Combining parameters for SKAdNetwork 3 postbacks

Recreate the byte array for version 3 postbacks that win and don’t win
attribution.

## Overview

Check your postback’s version, and use the version-specific instructions to
combine the parameters to validate the postback. The order of the parameters
depends on the version of the postback you receive.

To verify the signature, combine the postback parameter values in this order
for a version 3 postback:

  * `version`

  * `ad-network-id`

  * `campaign-id `

  * `app-id `

  * `transaction-id `

  * `redownload` (Use the strings `“true”` or `“false”` to represent the Boolean value of the redownload parameter.)

  * `source-app-id`

  * `fidelity-type`

  * `did-win`

Include `source-app-id` only if you receive it in the postback. Note that the
signature doesn’t include a conversion value, even if it’s present in the
postback. Postbacks that win the attribution have a `did-win` value of `true`.
Postbacks that don't win the attribution have a `did-win` value of `false`,
and don’t include `source-app-id`.

The following example of the UTF-8 string includes `source-app-id:`

The following example of the UTF-8 string doesn’t include `source-app-id:`

### Receive the winning postback with attribution

The following JSON example shows a version 3 install-validation postback the
device sends to an ad network that wins the attribution. This example contains
all possible parameters and a valid signature:

### Receive a nonwinning postback, without attribution

In iOS 14.6 and later, ad networks that sign ads with version 3 may receive a
postback for their qualifying ad impression that don't win the attribution.
Such postbacks have a `did-win` value of `false`, and don’t include `source-
app-id` or `conversion-value`.

The following example shows a version 3 postback for an ad that doesn't win
the attribution. This example contains all the parameters the system includes
in a nonwinning postback:

Up to five ad networks may receive a nonwinning postback. A single ad network
can receive at most one postback per advertised app, per conversion. For
example, if the device registers three qualifying ad impressions from your ad
network, you receive only one postback.

If your ad network wins the attribution, you only receive the winning
postback, even if the device registers other qualifying impressions for your
ad.

For more information about ad impressions qualifying for attribution, and
receiving winning or nonwinning postbacks, see Receiving ad attributions and
postbacks.

## See Also

### SKAdNetworks 3 and earlier postbacks

Combining parameters for previous SKAdNetwork postback versions

Recreate the byte array for versions 2.2 or earlier.

Article

# Combining parameters for previous SKAdNetwork postback versions

Recreate the byte array for versions 2.2 or earlier.

## Overview

Combine postback parameters to recreate a byte array that you use to verify
Apple’s signature. To recreate the byte array, create a UTF-8 string by
combining the parameter values in an exact order, with an invisible separator
(`‘\u2063’`) between them. You must combine the parameters in the exact orders
as show in the examples. For more information about the parameters and
verifying the signature, and an example using newer versions, see Verifying an
install-validation postback.

### Combine postback parameters for version 2.2

The following JSON shows an example of a version 2.2 install-validation
postback that contains all possible parameters and a valid signature:

To verify the signature, combine version 2.2 postback parameters in this
order:

  * `version`

  * `ad-network-id`

  * `campaign-id `

  * `app-id `

  * `transaction-id `

  * `redownload` Note: use the strings `“true”` or `“false”` to represent the Boolean value of the redownload parameter.

  * `source-app-id`

  * `fidelity-type`

Include `source-app-id` only if you received it in the postback. Note that the
signature never includes a conversion value, even if it’s present in the
postback.

The following is an example of the UTF-8 string for a postback with `source-
app-id `present in the postback:

The following is an example of the UTF-8 string for a postback without
`source-app-id`:

### Combine postback parameters for versions 2 and 2.1

Version 2 and 2.1 postbacks contain the following parameters. Combine their
values in this order:

  * `version`

  * `ad-network-id`

  * `campaign-id `

  * `app-id `

  * `transaction-id `

  * `redownload` Note: use the strings `“true”` or `“false”` to represent the Boolean value of the redownload parameter.

  * `source-app-id`

Include `source-app-id` only if you receive it in the postback. Note that the
signature never includes a conversion value, even if it’s present in the
postback.

The following is an example of the UTF-8 string for a postback with `source-
app-id `present in the postback:

The following is an example of the UTF-8 string for a postback without
`source-app-id`:

### Combine postback parameters for version 1

Version 1 postbacks contain the following parameters. Combine their values in
this order:

  * `ad-network-id`

  * `campaign-id`

  * `app-id`

  * `transaction-id`

The following is an example of the UTF-8 string for a version 1.0 postback:

## See Also

### SKAdNetworks 3 and earlier postbacks

Combining parameters for SKAdNetwork 3 postbacks

Recreate the byte array for version 3 postbacks that win and don’t win
attribution.



# Product.SubscriptionPeriod.Unit

Enumeration Case

# Product.SubscriptionPeriod.Unit.day

A subscription period unit of a day.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case day

## See Also

### Getting the subscription period units

`case month`

A subscription period unit of a month.

`case week`

A subscription period unit of a week.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.month

A subscription period unit of a month.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case month

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case week`

A subscription period unit of a week.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.week

A subscription period unit of a week.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case week

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case month`

A subscription period unit of a month.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.year

A subscription period unit of a year.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case year

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case month`

A subscription period unit of a month.

`case week`

A subscription period unit of a week.

Instance Property

# localizedDescription

The localized text that describes the subscription period unit.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

## See Also

### Getting localized and debug descriptions

`var debugDescription: String`

A string that contains the name of the subscription period unit, suitable for
debugging.

Instance Property

# debugDescription

A string that contains the name of the subscription period unit, suitable for
debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

## See Also

### Getting localized and debug descriptions

`var localizedDescription: String`

The localized text that describes the subscription period unit.

Generic Instance Method

# formatted(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Product.SubscriptionPeriod.Unit

## See Also

### Getting the formatted description

`struct Product.SubscriptionPeriod.Unit.FormatStyle`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing units

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionPeriod.Unit, b: Product.SubscriptionPeriod.Unit) -> Bool

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Enumeration Case

# Product.SubscriptionPeriod.Unit.day

A subscription period unit of a day.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case day

## See Also

### Getting the subscription period units

`case month`

A subscription period unit of a month.

`case week`

A subscription period unit of a week.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.month

A subscription period unit of a month.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case month

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case week`

A subscription period unit of a week.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.week

A subscription period unit of a week.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case week

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case month`

A subscription period unit of a month.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.year

A subscription period unit of a year.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case year

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case month`

A subscription period unit of a month.

`case week`

A subscription period unit of a week.

Instance Property

# localizedDescription

The localized text that describes the subscription period unit.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

## See Also

### Getting localized and debug descriptions

`var debugDescription: String`

A string that contains the name of the subscription period unit, suitable for
debugging.

Instance Property

# debugDescription

A string that contains the name of the subscription period unit, suitable for
debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

## See Also

### Getting localized and debug descriptions

`var localizedDescription: String`

The localized text that describes the subscription period unit.

Generic Instance Method

# formatted(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Product.SubscriptionPeriod.Unit

## See Also

### Getting the formatted description

`struct Product.SubscriptionPeriod.Unit.FormatStyle`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing units

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionPeriod.Unit, b: Product.SubscriptionPeriod.Unit) -> Bool

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Enumeration Case

# Product.SubscriptionPeriod.Unit.day

A subscription period unit of a day.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case day

## See Also

### Getting the subscription period units

`case month`

A subscription period unit of a month.

`case week`

A subscription period unit of a week.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.month

A subscription period unit of a month.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case month

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case week`

A subscription period unit of a week.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.week

A subscription period unit of a week.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case week

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case month`

A subscription period unit of a month.

`case year`

A subscription period unit of a year.

Enumeration Case

# Product.SubscriptionPeriod.Unit.year

A subscription period unit of a year.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case year

## See Also

### Getting the subscription period units

`case day`

A subscription period unit of a day.

`case month`

A subscription period unit of a month.

`case week`

A subscription period unit of a week.

Instance Property

# localizedDescription

The localized text that describes the subscription period unit.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

## See Also

### Getting localized and debug descriptions

`var debugDescription: String`

A string that contains the name of the subscription period unit, suitable for
debugging.

Instance Property

# debugDescription

A string that contains the name of the subscription period unit, suitable for
debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

## See Also

### Getting localized and debug descriptions

`var localizedDescription: String`

The localized text that describes the subscription period unit.

Generic Instance Method

# formatted(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Product.SubscriptionPeriod.Unit

## See Also

### Getting the formatted description

`struct Product.SubscriptionPeriod.Unit.FormatStyle`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod.Unit, rhs: Product.SubscriptionPeriod.Unit) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing units

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionPeriod.Unit, b: Product.SubscriptionPeriod.Unit) -> Bool

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing units

`static func != (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit,
Product.SubscriptionPeriod.Unit) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# Transaction.OwnershipType

Type Property

# familyShared

The transaction belongs to a family member who benefits from the service.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let familyShared: Transaction.OwnershipType

## Discussion

For more information about Family Sharing, see Turn on Family Sharing for in-
app purchases.

## See Also

### Getting ownership types

`static let purchased: Transaction.OwnershipType`

The transaction belongs to the purchaser.

Type Property

# purchased

The transaction belongs to the purchaser.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let purchased: Transaction.OwnershipType

## See Also

### Getting ownership types

`static let familyShared: Transaction.OwnershipType`

The transaction belongs to a family member who benefits from the service.

Instance Property

# localizedDescription

The localized text that describes the ownership type.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Instance Property

# rawValue

The raw string value that represents a transaction ownership type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: String

## Discussion

Use the raw value to help parse the `jsonRepresentation` property of
`Transaction`. The JSON data contains a string representation of the
transaction ownership type, which is its raw value. You can compare the JSON
data directly to the ownership type’s `rawValue`.

You can also use the `rawValue` to create a transaction ownership type
instance by calling `init(rawValue:)`.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Transaction.OwnershipType.RawValue`

The type that represents the raw value of a transaction’s ownership type.

Type Alias

# Transaction.OwnershipType.RawValue

The type that represents the raw value of a transaction’s ownership type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Transaction.OwnershipType.RawValue = String

## See Also

### Accessing the raw value

`let rawValue: String`

The raw string value that represents a transaction ownership type.

Initializer

# init(rawValue:)

Creates a transaction ownership type instance from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

A string that represents a transaction ownership type.

## Discussion

Typically, you get a transaction ownership type from the `ownershipType`
property in a `Transaction`, and you don’t need to instantiate it yourself.

However, if you use the `jsonRepresentation` property of `Transaction`, you
can use raw values and the initializer to help parse the JSON. The JSON
contains the string representation of the ownership type, which is its raw
value. Call `init(rawValue:)` to create your own instance from that raw value.
Alternatively, you can compare the JSON data directly to the ownership type’s
`rawValue`.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Transaction.OwnershipType, rhs: Transaction.OwnershipType) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing types

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing types

`static func != (Transaction.OwnershipType, Transaction.OwnershipType) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing types

`static func != (Transaction.OwnershipType, Transaction.OwnershipType) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# SKCloudServiceController

Article

# Requesting Access to Apple Music Library

Prompt the user to authorize access to Apple Music library.

StoreKit  Bundle Resources

## Overview

Your app must obtain permission from the user before accessing Apple Music
Library.

### Provide a Purpose String in Info.plist

Provide a purpose string or usage description that describes how your app
intends to use the user’s iCloud Music library or Apple Music catalog. Add the
`NSAppleMusicUsageDescription` key to your app’s Info.plist. Set its value to
a string that explains why your app needs access to Apple Music library. The
system displays the string to the user when prompting them for authorization.

Important

This key is required for apps that access the user’s music library. Apps crash
when the key is absent.

See Requesting access to protected resources for more details.

### Request Authorization

The user determines whether apps can play items from the Apple Music catalog
or add tracks to their iCloud Music library. They can grant or deny access
when your app requests authorization. Because the user can change your app’s
authorization status in Settings > Privacy > Media and Apple Music, be sure to
call `SKCloudServiceController`’s `authorizationStatus()` before attempting to
access their Apple Music library.

If the authorization status i`s
``SKCloudServiceAuthorizationStatus.notDetermined`, call
`SKCloudServiceController`’s `requestAuthorization(_:)` to prompt the user for
access.

The system remembers the user’s answer so that subsequent calls to
`requestAuthorization(_:)` don’t prompt them again.

## See Also

### Getting Authorization to Access the Music Library

`class func authorizationStatus() -> SKCloudServiceAuthorizationStatus`

Returns the type of authorization the user has set for accessing the music
library on the device.

`class func requestAuthorization((SKCloudServiceAuthorizationStatus) -> Void)`

Asks the user for permission to access the music library on the device.

`enum SKCloudServiceAuthorizationStatus`

Constants that indicate the type of authorization the user has set for
accessing the music library.

Type Method

# authorizationStatus()

Returns the type of authorization the user has set for accessing the music
library on the device.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    class func authorizationStatus() -> SKCloudServiceAuthorizationStatus

## Return Value

The type of authorization for music library access. See
`SKCloudServiceAuthorizationStatus` for a list of possible values.

## Discussion

Use the authorization status to determine in what ways you can access the
user’s music library.

## See Also

### Getting Authorization to Access the Music Library

Requesting Access to Apple Music Library

Prompt the user to authorize access to Apple Music library.

`class func requestAuthorization((SKCloudServiceAuthorizationStatus) -> Void)`

Asks the user for permission to access the music library on the device.

`enum SKCloudServiceAuthorizationStatus`

Constants that indicate the type of authorization the user has set for
accessing the music library.

### Related Documentation

In-App Purchase Programming Guide

Type Method

# requestAuthorization(_:)

Asks the user for permission to access the music library on the device.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    class func requestAuthorization(_ completionHandler: @escaping (SKCloudServiceAuthorizationStatus) -> Void)

##  Parameters

`handler`

    

A block that is called when authorization is granted or denied by the user.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For example:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

You can use this method to ask the user for permission to play Apple Music
tracks or to add tracks to the music library.

## See Also

### Getting Authorization to Access the Music Library

Requesting Access to Apple Music Library

Prompt the user to authorize access to Apple Music library.

`class func authorizationStatus() -> SKCloudServiceAuthorizationStatus`

Returns the type of authorization the user has set for accessing the music
library on the device.

`enum SKCloudServiceAuthorizationStatus`

Constants that indicate the type of authorization the user has set for
accessing the music library.

Article

# Determining a User’s Apple Music Capabilities

Determine which Apple Music capabilities are available on a user’s device.

## Overview

After you request the user’s permission to access their Apple Music library
(see Requesting Access to Apple Music Library), you confirm that authorization
and then identify Apple Music capabilities on the user’s device.

### Confirm Whether the User Authorized Access to Apple Music Library

Use `SKCloudServiceController`’s `authorizationStatus()` to check whether the
user has authorized access to Apple Music Library. If the authorization status
is `SKCloudServiceAuthorizationStatus.notDetermined`, call
`SKCloudServiceController`’s `requestAuthorization(_:)` to prompt the user for
access.

If the authorization status is `SKCloudServiceAuthorizationStatus.authorized`,
your app can proceed to determine which Apple Music capabilities
(`musicCatalogPlayback`, `musicCatalogSubscriptionEligible`, or
`addToCloudMusicLibrary`) are available on the user’s device.

### Create a Cloud Service Controller and Its Handler to Fetch Capabilities

First, create an `SKCloudServiceController` object:

Then call its `requestCapabilities(completionHandler:)` method to fetch the
current Apple Music capabilities, as described in the sections that follow.

### Check for the Capability to Play Apple Music Content

If you want your app to play Apple Music content, check whether `capabilities
`includes `musicCatalogPlayback`:

### Check for the Subscription-Eligible Capability

A user is eligible for an Apple Music subscription offer when `capabilities`
doesn’t include `musicCatalogPlayback` but contains
`musicCatalogSubscriptionEligible`. If you want your app to present the user
with an offer to subscribe to Apple Music, check `capabilities` for these
features:

You can present the offer using `SKCloudServiceSetupViewController`.

### Check for the Capability to Add Songs to the User’s iCloud Music Library

If you want your app to add tracks to the user’s iCloud music library, check
whether `capabilities `includes `addToCloudMusicLibrary`:

## See Also

### Determining Capabilities

`func requestUserToken(forDeveloperToken: String, completionHandler: (String?,
(any Error)?) -> Void)`

Returns a user token that you use to access personalized Apple Music content.

`func requestStorefrontCountryCode(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the country code for the storefront associated with a user's iTunes
account.

`func requestCapabilities(completionHandler: (SKCloudServiceCapability, (any
Error)?) -> Void)`

Gets the current capabilities associated with the music library on the device.

`struct SKCloudServiceCapability`

Constants that specify the current capabilities of the user’s music library on
the device.

`func requestStorefrontIdentifier(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the device’s storefront identifier.

`func requestPersonalizationToken(forClientToken: String,
withCompletionHandler: (String?, (any Error)?) -> Void)`Deprecated

Instance Method

# requestUserToken(forDeveloperToken:completionHandler:)

Returns a user token that you use to access personalized Apple Music content.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 11.0+  watchOS
7.0+

    
    
    func requestUserToken(
        forDeveloperToken developerToken: String,
        completionHandler: @escaping (String?, (any Error)?) -> Void
    )

##  Parameters

`developerToken`

    

A signed and encrypted JWT token used to authenticate the developer in Apple
Music API requests.

`completionHandler`

    

A completion block that includes the following parameters:

userToken

    

A token that identifies the user.

error

    

The error that occurred, if any.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

Use this method with your developer token to get a token that authenticates
the user in personalized Apple Music API requests. Note that personalized
requests return user-specific data. Errors 401 and 403 only occur when
requesting a music user token. They do not occur for any of the other Apple
Music API requests.

## See Also

### Determining Capabilities

Determining a User’s Apple Music Capabilities

Determine which Apple Music capabilities are available on a user’s device.

`func requestStorefrontCountryCode(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the country code for the storefront associated with a user's iTunes
account.

`func requestCapabilities(completionHandler: (SKCloudServiceCapability, (any
Error)?) -> Void)`

Gets the current capabilities associated with the music library on the device.

`struct SKCloudServiceCapability`

Constants that specify the current capabilities of the user’s music library on
the device.

`func requestStorefrontIdentifier(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the device’s storefront identifier.

`func requestPersonalizationToken(forClientToken: String,
withCompletionHandler: (String?, (any Error)?) -> Void)`Deprecated

Instance Method

# requestStorefrontCountryCode(completionHandler:)

Gets the country code for the storefront associated with a user's iTunes
account.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 13.1+  tvOS 11.0+  watchOS
4.0+

    
    
    func requestStorefrontCountryCode(completionHandler: @escaping (String?, (any Error)?) -> Void)

##  Parameters

`completionHandler`

    

A block that is called when the storefront country code is returned. The block
takes the following parameters:

storefrontCountryCode

    

The country code of a specific storefront.

error

    

An error value that indicates the reason for failure. See `SKError.Code` for
possible error values.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

You need to get the appropriate storefront country code before you specify a
product as each country or region contains different products.

## See Also

### Determining Capabilities

Determining a User’s Apple Music Capabilities

Determine which Apple Music capabilities are available on a user’s device.

`func requestUserToken(forDeveloperToken: String, completionHandler: (String?,
(any Error)?) -> Void)`

Returns a user token that you use to access personalized Apple Music content.

`func requestCapabilities(completionHandler: (SKCloudServiceCapability, (any
Error)?) -> Void)`

Gets the current capabilities associated with the music library on the device.

`struct SKCloudServiceCapability`

Constants that specify the current capabilities of the user’s music library on
the device.

`func requestStorefrontIdentifier(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the device’s storefront identifier.

`func requestPersonalizationToken(forClientToken: String,
withCompletionHandler: (String?, (any Error)?) -> Void)`Deprecated

Instance Method

# requestCapabilities(completionHandler:)

Gets the current capabilities associated with the music library on the device.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    func requestCapabilities(completionHandler: @escaping (SKCloudServiceCapability, (any Error)?) -> Void)

##  Parameters

`completionHandler`

    

A block that is called when the device’s current capabilities are determined.
The block takes the following parameters:

capabilities

    

Flags that indicate the device’s capabilities. For possible values, see
`SKCloudServiceCapability`.

error

    

An error value that indicates the reason for failure. Possible values are
`SKError.Code.unknown`, `SKError.Code.cloudServicePermissionDenied`, and
`SKError.Code.cloudServiceNetworkConnectionFailed`.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

## See Also

### Determining Capabilities

Determining a User’s Apple Music Capabilities

Determine which Apple Music capabilities are available on a user’s device.

`func requestUserToken(forDeveloperToken: String, completionHandler: (String?,
(any Error)?) -> Void)`

Returns a user token that you use to access personalized Apple Music content.

`func requestStorefrontCountryCode(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the country code for the storefront associated with a user's iTunes
account.

`struct SKCloudServiceCapability`

Constants that specify the current capabilities of the user’s music library on
the device.

`func requestStorefrontIdentifier(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the device’s storefront identifier.

`func requestPersonalizationToken(forClientToken: String,
withCompletionHandler: (String?, (any Error)?) -> Void)`Deprecated

Instance Method

# requestStorefrontIdentifier(completionHandler:)

Gets the device’s storefront identifier.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    func requestStorefrontIdentifier(completionHandler: @escaping (String?, (any Error)?) -> Void)

##  Parameters

`completionHandler`

    

A block that is called when the storefront ID is returned. The block takes the
following parameters:

storefrontIdentifier

    

The identifier of a specific storefront.

error

    

An error value that indicates the reason for failure. Possible values are
`SKError.Code.unknown`, `SKError.Code.cloudServicePermissionDenied`, and
`SKError.Code.cloudServiceNetworkConnectionFailed`.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

You need to get the appropriate storefront before you specify a product,
because product identifiers are meaningful within the context of a store.

## See Also

### Determining Capabilities

Determining a User’s Apple Music Capabilities

Determine which Apple Music capabilities are available on a user’s device.

`func requestUserToken(forDeveloperToken: String, completionHandler: (String?,
(any Error)?) -> Void)`

Returns a user token that you use to access personalized Apple Music content.

`func requestStorefrontCountryCode(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the country code for the storefront associated with a user's iTunes
account.

`func requestCapabilities(completionHandler: (SKCloudServiceCapability, (any
Error)?) -> Void)`

Gets the current capabilities associated with the music library on the device.

`struct SKCloudServiceCapability`

Constants that specify the current capabilities of the user’s music library on
the device.

`func requestPersonalizationToken(forClientToken: String,
withCompletionHandler: (String?, (any Error)?) -> Void)`Deprecated

Instance Method

# requestPersonalizationToken(forClientToken:withCompletionHandler:)

iOS 10.3–11.0  Deprecated  iPadOS 10.3–11.0  Deprecated  tvOS 10.3–11.0
Deprecated

    
    
    func requestPersonalizationToken(
        forClientToken clientToken: String,
        withCompletionHandler completionHandler: @escaping (String?, (any Error)?) -> Void
    )

## See Also

### Determining Capabilities

Determining a User’s Apple Music Capabilities

Determine which Apple Music capabilities are available on a user’s device.

`func requestUserToken(forDeveloperToken: String, completionHandler: (String?,
(any Error)?) -> Void)`

Returns a user token that you use to access personalized Apple Music content.

`func requestStorefrontCountryCode(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the country code for the storefront associated with a user's iTunes
account.

`func requestCapabilities(completionHandler: (SKCloudServiceCapability, (any
Error)?) -> Void)`

Gets the current capabilities associated with the music library on the device.

`struct SKCloudServiceCapability`

Constants that specify the current capabilities of the user’s music library on
the device.

`func requestStorefrontIdentifier(completionHandler: (String?, (any Error)?)
-> Void)`

Gets the device’s storefront identifier.

Type Property

# SKStorefrontIdentifierDidChange

A notification name for indicating a change in the storefront identifier
associated with the device.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    static let SKStorefrontIdentifierDidChange: NSNotification.Name

## See Also

### StoreKit

`static let SKCloudServiceCapabilitiesDidChange: NSNotification.Name`

A notification name for indicating a change in the capabilities associated
with the music library on the device.

`static let SKStorefrontCountryCodeDidChange: NSNotification.Name`

A notification name for indicating a change in the storefront country or
region code associated with the device.

Type Property

# SKCloudServiceCapabilitiesDidChange

A notification name for indicating a change in the capabilities associated
with the music library on the device.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    static let SKCloudServiceCapabilitiesDidChange: NSNotification.Name

## See Also

### StoreKit

`static let SKStorefrontIdentifierDidChange: NSNotification.Name`

A notification name for indicating a change in the storefront identifier
associated with the device.

`static let SKStorefrontCountryCodeDidChange: NSNotification.Name`

A notification name for indicating a change in the storefront country or
region code associated with the device.

Type Property

# SKStorefrontCountryCodeDidChange

A notification name for indicating a change in the storefront country or
region code associated with the device.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 11.0+  watchOS
7.0+

    
    
    static let SKStorefrontCountryCodeDidChange: NSNotification.Name

## See Also

### StoreKit

`static let SKCloudServiceCapabilitiesDidChange: NSNotification.Name`

A notification name for indicating a change in the capabilities associated
with the music library on the device.

`static let SKStorefrontIdentifierDidChange: NSNotification.Name`

A notification name for indicating a change in the storefront identifier
associated with the device.



# VerificationResult.VerificationError

Instance Property

# localizedDescription

A string containing the localized description of the error.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var localizedDescription: String { get }

## See Also

### Error Description

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# errorDescription

A description of the error, suitable for debugging.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var errorDescription: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Description

`var localizedDescription: String`

A string containing the localized description of the error.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# failureReason

A localized message describing the reason for the failure.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var failureReason: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Description

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# helpAnchor

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.4+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var helpAnchor: String? { get }

## See Also

### Error Description

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# recoverySuggestion

A message containing a suggestion for recovering from the error.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var recoverySuggestion: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Description

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

Enumeration Case

# VerificationResult.VerificationError.invalidCertificateChain

An error indicating that the certificate chain is invalid.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidCertificateChain

## Discussion

This error may occur if one or more certificates in the certiificate chain are
expired or from an untrusted source.

## See Also

### Error Codes

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.invalidDeviceVerification

An error that indicates the signed value wasn’t generated for the current
device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidDeviceVerification

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.invalidEncoding

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidEncoding

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.invalidSignature

An error that indicates that the signature didn’t match the header and
payload.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidSignature

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.missingRequiredProperties

An error that indicates the header or payload are missing information that’s
required to verify the signature.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case missingRequiredProperties

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.revokedCertificate

An error that indicates the certificate chain includes a revoked certificate.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case revokedCertificate

## Discussion

In some cases, this error may resolve if you try again later.

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: VerificationResult<SignedType>.VerificationError, rhs: VerificationResult<SignedType>.VerificationError) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Error Comparisons

`static func == (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: VerificationResult<SignedType>.VerificationError, b: VerificationResult<SignedType>.VerificationError) -> Bool

## See Also

### Error Comparisons

`static func != (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Error Comparisons

`static func != (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Error Comparisons

`static func != (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# localizedDescription

A string containing the localized description of the error.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var localizedDescription: String { get }

## See Also

### Error Description

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# errorDescription

A description of the error, suitable for debugging.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var errorDescription: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Description

`var localizedDescription: String`

A string containing the localized description of the error.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# failureReason

A localized message describing the reason for the failure.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var failureReason: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Description

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# helpAnchor

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.4+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 13.3+

    
    
    var helpAnchor: String? { get }

## See Also

### Error Description

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# recoverySuggestion

A message containing a suggestion for recovering from the error.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var recoverySuggestion: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Description

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A localized message describing the reason for the failure.

`var helpAnchor: String?`

A message providing “help” text if the user requests help by pressing an alert
panel help anchor button.

Enumeration Case

# VerificationResult.VerificationError.invalidCertificateChain

An error indicating that the certificate chain is invalid.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidCertificateChain

## Discussion

This error may occur if one or more certificates in the certiificate chain are
expired or from an untrusted source.

## See Also

### Error Codes

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.invalidDeviceVerification

An error that indicates the signed value wasn’t generated for the current
device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidDeviceVerification

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.invalidEncoding

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidEncoding

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.invalidSignature

An error that indicates that the signature didn’t match the header and
payload.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case invalidSignature

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.missingRequiredProperties

An error that indicates the header or payload are missing information that’s
required to verify the signature.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case missingRequiredProperties

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case revokedCertificate`

An error that indicates the certificate chain includes a revoked certificate.

Enumeration Case

# VerificationResult.VerificationError.revokedCertificate

An error that indicates the certificate chain includes a revoked certificate.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case revokedCertificate

## Discussion

In some cases, this error may resolve if you try again later.

## See Also

### Error Codes

`case invalidCertificateChain`

An error indicating that the certificate chain is invalid.

`case invalidDeviceVerification`

An error that indicates the signed value wasn’t generated for the current
device.

`case invalidEncoding`

An error that indicates the signature, certificate chain, or other part of
value uses invalid encoding.

`case invalidSignature`

An error that indicates that the signature didn’t match the header and
payload.

`case missingRequiredProperties`

An error that indicates the header or payload are missing information that’s
required to verify the signature.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: VerificationResult<SignedType>.VerificationError, rhs: VerificationResult<SignedType>.VerificationError) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Error Comparisons

`static func == (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: VerificationResult<SignedType>.VerificationError, b: VerificationResult<SignedType>.VerificationError) -> Bool

## See Also

### Error Comparisons

`static func != (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Error Comparisons

`static func != (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Error Comparisons

`static func != (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (VerificationResult<SignedType>.VerificationError,
VerificationResult<SignedType>.VerificationError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# SKANError.Code

Enumeration Case

# SKANError.Code.adNetworkIdMissing

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case adNetworkIdMissing = 2

## Discussion

The value you specify for your ad network identifier in your ad impresion must
match the value in the `Info.plist`. ``An app that participates in ad
campaigns by displaying ads must include the ad network identifiers in its
`Info.plist`. For more information, see Configuring a source app.

## See Also

### Error Codes

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.impressionMissingRequiredValue

A required value is missing from a view-through ad impression.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case impressionMissingRequiredValue = 0

## Discussion

Check that your instance of `SKAdImpression` provides all of the required
values.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.impressionNotFound

The system can’t find the ad impression.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case impressionNotFound = 4

## Discussion

This error may occur if an app calls `endImpression(_:completionHandler:)`
before calling `startImpression(_:completionHandler:)`.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.impressionTooShort

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case impressionTooShort = 11

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidAdvertisedAppId

The App Store ID of the advertised app is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidAdvertisedAppId = 8

## Discussion

Ad networks provide an advertised app identifier when signing an ad
impression. If you’re providing a StoreKit-rendered ad, check that the value
you set for `SKStoreProductParameterITunesItemIdentifier` in
`loadProduct(withParameters:completionBlock:)` is a valid app identifer. If
you’re providing a view-through ad, check the value of
`advertisedAppStoreItemIdentifier`.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidCampaignId

The campaign identifier that you provided is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidCampaignId = 5

## Discussion

Check that the campaign identifier is a valid value. For more information, see
`SKStoreProductParameterAdNetworkCampaignIdentifier` for StoreKit-rendered
ads, and `adCampaignIdentifier` for view-through ads.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidConversionValue

The conversion value is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidConversionValue = 6

## Discussion

Apps provide a conversion value when calling
`updatePostbackConversionValue(_:completionHandler:)` or
`updateConversionValue(_:)`. Check that the conversion value you provide is
within the allowed range.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidSourceAppId

The App Store ID of the app displaying the ad is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidSourceAppId = 7

## Discussion

Check that the value you provide for
`SKStoreProductParameterAdNetworkSourceAppStoreIdentifier` or
`sourceAppStoreItemIdentifier` is correct and matches the App Store ID of the
app that’s displaying the ad.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidVersion

The SKAdNetwork version number is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidVersion = 9

## Discussion

Ad networks provide an SKAdNetwork version number when preparing an ad
impression, in `SKStoreProductParameterAdNetworkVersion` or `version`. Check
that the version number is valid and that you follow the version-specific
instructions to generate a signature. For more information about versions, see
SKAdNetwork release notes.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.mismatchedSourceAppId

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case mismatchedSourceAppId = 3

## Discussion

Check that the `sourceAppStoreItemIdentifier` you provide in the
`SKAdImpression` object matches the app identifier of the app displaying the
ad.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.unknown

An unknown error occurred.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case unknown = 10

## Discussion

If this error appears, continue processing the ad; an ad impression may
succeed despite this error.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.unsupported

Your app attempted to use functionality that isn’t supported in the specified
version.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case unsupported = 1

## Discussion

For information about supported features by version number, see SKAdNetwork
release notes. For example, to provide view-through ads, use SKAdNetwork
version 2.2 or later.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

Enumeration Case

# SKANError.Code.adNetworkIdMissing

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case adNetworkIdMissing = 2

## Discussion

The value you specify for your ad network identifier in your ad impresion must
match the value in the `Info.plist`. ``An app that participates in ad
campaigns by displaying ads must include the ad network identifiers in its
`Info.plist`. For more information, see Configuring a source app.

## See Also

### Error Codes

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.impressionMissingRequiredValue

A required value is missing from a view-through ad impression.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case impressionMissingRequiredValue = 0

## Discussion

Check that your instance of `SKAdImpression` provides all of the required
values.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.impressionNotFound

The system can’t find the ad impression.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case impressionNotFound = 4

## Discussion

This error may occur if an app calls `endImpression(_:completionHandler:)`
before calling `startImpression(_:completionHandler:)`.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.impressionTooShort

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case impressionTooShort = 11

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidAdvertisedAppId

The App Store ID of the advertised app is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidAdvertisedAppId = 8

## Discussion

Ad networks provide an advertised app identifier when signing an ad
impression. If you’re providing a StoreKit-rendered ad, check that the value
you set for `SKStoreProductParameterITunesItemIdentifier` in
`loadProduct(withParameters:completionBlock:)` is a valid app identifer. If
you’re providing a view-through ad, check the value of
`advertisedAppStoreItemIdentifier`.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidCampaignId

The campaign identifier that you provided is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidCampaignId = 5

## Discussion

Check that the campaign identifier is a valid value. For more information, see
`SKStoreProductParameterAdNetworkCampaignIdentifier` for StoreKit-rendered
ads, and `adCampaignIdentifier` for view-through ads.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidConversionValue

The conversion value is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidConversionValue = 6

## Discussion

Apps provide a conversion value when calling
`updatePostbackConversionValue(_:completionHandler:)` or
`updateConversionValue(_:)`. Check that the conversion value you provide is
within the allowed range.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidSourceAppId

The App Store ID of the app displaying the ad is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidSourceAppId = 7

## Discussion

Check that the value you provide for
`SKStoreProductParameterAdNetworkSourceAppStoreIdentifier` or
`sourceAppStoreItemIdentifier` is correct and matches the App Store ID of the
app that’s displaying the ad.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.invalidVersion

The SKAdNetwork version number is invalid.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case invalidVersion = 9

## Discussion

Ad networks provide an SKAdNetwork version number when preparing an ad
impression, in `SKStoreProductParameterAdNetworkVersion` or `version`. Check
that the version number is valid and that you follow the version-specific
instructions to generate a signature. For more information about versions, see
SKAdNetwork release notes.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.mismatchedSourceAppId

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case mismatchedSourceAppId = 3

## Discussion

Check that the `sourceAppStoreItemIdentifier` you provide in the
`SKAdImpression` object matches the app identifier of the app displaying the
ad.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case unknown`

An unknown error occurred.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.unknown

An unknown error occurred.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case unknown = 10

## Discussion

If this error appears, continue processing the ad; an ad impression may
succeed despite this error.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unsupported`

Your app attempted to use functionality that isn’t supported in the specified
version.

Enumeration Case

# SKANError.Code.unsupported

Your app attempted to use functionality that isn’t supported in the specified
version.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+  visionOS 1.0+

    
    
    case unsupported = 1

## Discussion

For information about supported features by version number, see SKAdNetwork
release notes. For example, to provide view-through ads, use SKAdNetwork
version 2.2 or later.

## See Also

### Error Codes

`case adNetworkIdMissing`

The ad network identifier in the ad impression doesn’t match the value in the
information property list.

`case impressionMissingRequiredValue`

A required value is missing from a view-through ad impression.

`case impressionNotFound`

The system can’t find the ad impression.

`case impressionTooShort`

`case invalidAdvertisedAppId`

The App Store ID of the advertised app is invalid.

`case invalidCampaignId`

The campaign identifier that you provided is invalid.

`case invalidConversionValue`

The conversion value is invalid.

`case invalidSourceAppId`

The App Store ID of the app displaying the ad is invalid.

`case invalidVersion`

The SKAdNetwork version number is invalid.

`case mismatchedSourceAppId`

The source app identifier in the ad impression doesn’t match the app
identifier in the source app.

`case unknown`

An unknown error occurred.



# Product.SubscriptionOffer

Instance Property

# displayPrice

The localized string representation of the discounted price of the
subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let displayPrice: String

## See Also

### Getting price information

`let price: Decimal`

The decimal representation of the discounted price of the subscription offer.

`let paymentMode: Product.SubscriptionOffer.PaymentMode`

The offer's payment mode.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# price

The decimal representation of the discounted price of the subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let price: Decimal

## See Also

### Getting price information

`let displayPrice: String`

The localized string representation of the discounted price of the
subscription offer.

`let paymentMode: Product.SubscriptionOffer.PaymentMode`

The offer's payment mode.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# paymentMode

The offer's payment mode.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let paymentMode: Product.SubscriptionOffer.PaymentMode

## See Also

### Getting price information

`let displayPrice: String`

The localized string representation of the discounted price of the
subscription offer.

`let price: Decimal`

The decimal representation of the discounted price of the subscription offer.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# period

The subscription period for the subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let period: Product.SubscriptionPeriod

## See Also

### Getting the subscription duration

`let periodCount: Int`

The number of periods that the subscription offer renews for.

Instance Property

# periodCount

The number of periods that the subscription offer renews for.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let periodCount: Int

## Discussion

If the payment mode is `payAsYouGo`, the period count represents the number of
periods the subscription renews at the discounted `price`.

The period count is 1 for offers with payment modes `freeTrial` and
`payUpFront`.

## See Also

### Getting the subscription duration

`let period: Product.SubscriptionPeriod`

The subscription period for the subscription offer.

Instance Property

# type

The type of subscription offer, either introductory or promotional.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let type: Product.SubscriptionOffer.OfferType

## See Also

### Getting the subscription offer type

`struct Product.SubscriptionOffer.OfferType`

The types of subscription offers.

Instance Property

# id

The promotional offer identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let id: String?

## Discussion

This value is `nil` if the subscription offer is an `introductory` offer.

Pass `id` to `promotionalOffer(offerID:keyID:nonce:signature:timestamp:)` to
apply this promotion to a purchase, in `purchase(options:)`.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer, rhs: Product.SubscriptionOffer) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing subscription offers

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionOffer, b: Product.SubscriptionOffer) -> Bool

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# displayPrice

The localized string representation of the discounted price of the
subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let displayPrice: String

## See Also

### Getting price information

`let price: Decimal`

The decimal representation of the discounted price of the subscription offer.

`let paymentMode: Product.SubscriptionOffer.PaymentMode`

The offer's payment mode.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# price

The decimal representation of the discounted price of the subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let price: Decimal

## See Also

### Getting price information

`let displayPrice: String`

The localized string representation of the discounted price of the
subscription offer.

`let paymentMode: Product.SubscriptionOffer.PaymentMode`

The offer's payment mode.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# paymentMode

The offer's payment mode.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let paymentMode: Product.SubscriptionOffer.PaymentMode

## See Also

### Getting price information

`let displayPrice: String`

The localized string representation of the discounted price of the
subscription offer.

`let price: Decimal`

The decimal representation of the discounted price of the subscription offer.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# period

The subscription period for the subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let period: Product.SubscriptionPeriod

## See Also

### Getting the subscription duration

`let periodCount: Int`

The number of periods that the subscription offer renews for.

Instance Property

# periodCount

The number of periods that the subscription offer renews for.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let periodCount: Int

## Discussion

If the payment mode is `payAsYouGo`, the period count represents the number of
periods the subscription renews at the discounted `price`.

The period count is 1 for offers with payment modes `freeTrial` and
`payUpFront`.

## See Also

### Getting the subscription duration

`let period: Product.SubscriptionPeriod`

The subscription period for the subscription offer.

Instance Property

# type

The type of subscription offer, either introductory or promotional.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let type: Product.SubscriptionOffer.OfferType

## See Also

### Getting the subscription offer type

`struct Product.SubscriptionOffer.OfferType`

The types of subscription offers.

Instance Property

# id

The promotional offer identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let id: String?

## Discussion

This value is `nil` if the subscription offer is an `introductory` offer.

Pass `id` to `promotionalOffer(offerID:keyID:nonce:signature:timestamp:)` to
apply this promotion to a purchase, in `purchase(options:)`.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer, rhs: Product.SubscriptionOffer) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing subscription offers

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionOffer, b: Product.SubscriptionOffer) -> Bool

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# displayPrice

The localized string representation of the discounted price of the
subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let displayPrice: String

## See Also

### Getting price information

`let price: Decimal`

The decimal representation of the discounted price of the subscription offer.

`let paymentMode: Product.SubscriptionOffer.PaymentMode`

The offer's payment mode.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# price

The decimal representation of the discounted price of the subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let price: Decimal

## See Also

### Getting price information

`let displayPrice: String`

The localized string representation of the discounted price of the
subscription offer.

`let paymentMode: Product.SubscriptionOffer.PaymentMode`

The offer's payment mode.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# paymentMode

The offer's payment mode.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let paymentMode: Product.SubscriptionOffer.PaymentMode

## See Also

### Getting price information

`let displayPrice: String`

The localized string representation of the discounted price of the
subscription offer.

`let price: Decimal`

The decimal representation of the discounted price of the subscription offer.

`struct Product.SubscriptionOffer.PaymentMode`

The payment modes for subscription offers.

Instance Property

# period

The subscription period for the subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let period: Product.SubscriptionPeriod

## See Also

### Getting the subscription duration

`let periodCount: Int`

The number of periods that the subscription offer renews for.

Instance Property

# periodCount

The number of periods that the subscription offer renews for.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let periodCount: Int

## Discussion

If the payment mode is `payAsYouGo`, the period count represents the number of
periods the subscription renews at the discounted `price`.

The period count is 1 for offers with payment modes `freeTrial` and
`payUpFront`.

## See Also

### Getting the subscription duration

`let period: Product.SubscriptionPeriod`

The subscription period for the subscription offer.

Instance Property

# type

The type of subscription offer, either introductory or promotional.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let type: Product.SubscriptionOffer.OfferType

## See Also

### Getting the subscription offer type

`struct Product.SubscriptionOffer.OfferType`

The types of subscription offers.

Instance Property

# id

The promotional offer identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let id: String?

## Discussion

This value is `nil` if the subscription offer is an `introductory` offer.

Pass `id` to `promotionalOffer(offerID:keyID:nonce:signature:timestamp:)` to
apply this promotion to a purchase, in `purchase(options:)`.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer, rhs: Product.SubscriptionOffer) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing subscription offers

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Product.SubscriptionOffer, b: Product.SubscriptionOffer) -> Bool

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing subscription offers

`static func != (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionOffer, Product.SubscriptionOffer) ->
Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# SKReceiptRefreshRequest

Initializer

# init(receiptProperties:)

Creates a receipt refresh request with optional properties.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    init(receiptProperties properties: [String : Any]?)

##  Parameters

`properties`

    

In the test environment, the properties that the new receipt is to have. For
keys, see Receipt Properties and Keys.

In the production environment, set this parameter to `nil`.

## Return Value

The initialized request.

## Discussion

In the sandbox environment, you can initialize a receipt with any combination
of properties to test the state transitions related to Volume Purchase Plan
receipts. Set the `properties` when you call this initializer.

Instance Property

# receiptProperties

The properties of the receipt.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var receiptProperties: [String : Any]? { get }

## Discussion

Receipt properties include `SKReceiptPropertyIsExpired`,
`SKReceiptPropertyIsRevoked`, and `SKReceiptPropertyIsVolumePurchase`.

## See Also

### Receipt Properties and Keys

`let SKReceiptPropertyIsExpired: String`

A key with a value that indicates whether the receipt is in an expired state.

`let SKReceiptPropertyIsRevoked: String`

A key with a value that indicates whether the receipt is in a revoked state.

`let SKReceiptPropertyIsVolumePurchase: String`

A key with a value that indicates whether the receipt is a Volume Purchase
Plan receipt.

Global Variable

# SKReceiptPropertyIsExpired

A key with a value that indicates whether the receipt is in an expired state.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    let SKReceiptPropertyIsExpired: String

## Discussion

This key’s value is an instance of `NSNumber` that the system interprets as a
Boolean value that indicates whether the receipt is in an expired state.

## See Also

### Receipt Properties and Keys

`var receiptProperties: [String : Any]?`

The properties of the receipt.

`let SKReceiptPropertyIsRevoked: String`

A key with a value that indicates whether the receipt is in a revoked state.

`let SKReceiptPropertyIsVolumePurchase: String`

A key with a value that indicates whether the receipt is a Volume Purchase
Plan receipt.

Global Variable

# SKReceiptPropertyIsRevoked

A key with a value that indicates whether the receipt is in a revoked state.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    let SKReceiptPropertyIsRevoked: String

## Discussion

This key’s value is an instance of `NSNumber` that the system interprets as a
Boolean value that indicates whether the receipt is in a revoked state.

## See Also

### Receipt Properties and Keys

`var receiptProperties: [String : Any]?`

The properties of the receipt.

`let SKReceiptPropertyIsExpired: String`

A key with a value that indicates whether the receipt is in an expired state.

`let SKReceiptPropertyIsVolumePurchase: String`

A key with a value that indicates whether the receipt is a Volume Purchase
Plan receipt.

Global Variable

# SKReceiptPropertyIsVolumePurchase

A key with a value that indicates whether the receipt is a Volume Purchase
Plan receipt.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    let SKReceiptPropertyIsVolumePurchase: String

## Discussion

This key’s value is an instance of `NSNumber` that the system interprets as a
Boolean value that indicates whether the receipt is a Volume Purchase Plan
receipt.

## See Also

### Receipt Properties and Keys

`var receiptProperties: [String : Any]?`

The properties of the receipt.

`let SKReceiptPropertyIsExpired: String`

A key with a value that indicates whether the receipt is in an expired state.

`let SKReceiptPropertyIsRevoked: String`

A key with a value that indicates whether the receipt is in a revoked state.

Initializer

# init(receiptProperties:)

Creates a receipt refresh request with optional properties.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    init(receiptProperties properties: [String : Any]?)

##  Parameters

`properties`

    

In the test environment, the properties that the new receipt is to have. For
keys, see Receipt Properties and Keys.

In the production environment, set this parameter to `nil`.

## Return Value

The initialized request.

## Discussion

In the sandbox environment, you can initialize a receipt with any combination
of properties to test the state transitions related to Volume Purchase Plan
receipts. Set the `properties` when you call this initializer.

Instance Property

# receiptProperties

The properties of the receipt.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var receiptProperties: [String : Any]? { get }

## Discussion

Receipt properties include `SKReceiptPropertyIsExpired`,
`SKReceiptPropertyIsRevoked`, and `SKReceiptPropertyIsVolumePurchase`.

## See Also

### Receipt Properties and Keys

`let SKReceiptPropertyIsExpired: String`

A key with a value that indicates whether the receipt is in an expired state.

`let SKReceiptPropertyIsRevoked: String`

A key with a value that indicates whether the receipt is in a revoked state.

`let SKReceiptPropertyIsVolumePurchase: String`

A key with a value that indicates whether the receipt is a Volume Purchase
Plan receipt.

Global Variable

# SKReceiptPropertyIsExpired

A key with a value that indicates whether the receipt is in an expired state.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    let SKReceiptPropertyIsExpired: String

## Discussion

This key’s value is an instance of `NSNumber` that the system interprets as a
Boolean value that indicates whether the receipt is in an expired state.

## See Also

### Receipt Properties and Keys

`var receiptProperties: [String : Any]?`

The properties of the receipt.

`let SKReceiptPropertyIsRevoked: String`

A key with a value that indicates whether the receipt is in a revoked state.

`let SKReceiptPropertyIsVolumePurchase: String`

A key with a value that indicates whether the receipt is a Volume Purchase
Plan receipt.

Global Variable

# SKReceiptPropertyIsRevoked

A key with a value that indicates whether the receipt is in a revoked state.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    let SKReceiptPropertyIsRevoked: String

## Discussion

This key’s value is an instance of `NSNumber` that the system interprets as a
Boolean value that indicates whether the receipt is in a revoked state.

## See Also

### Receipt Properties and Keys

`var receiptProperties: [String : Any]?`

The properties of the receipt.

`let SKReceiptPropertyIsExpired: String`

A key with a value that indicates whether the receipt is in an expired state.

`let SKReceiptPropertyIsVolumePurchase: String`

A key with a value that indicates whether the receipt is a Volume Purchase
Plan receipt.

Global Variable

# SKReceiptPropertyIsVolumePurchase

A key with a value that indicates whether the receipt is a Volume Purchase
Plan receipt.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    let SKReceiptPropertyIsVolumePurchase: String

## Discussion

This key’s value is an instance of `NSNumber` that the system interprets as a
Boolean value that indicates whether the receipt is a Volume Purchase Plan
receipt.

## See Also

### Receipt Properties and Keys

`var receiptProperties: [String : Any]?`

The properties of the receipt.

`let SKReceiptPropertyIsExpired: String`

A key with a value that indicates whether the receipt is in an expired state.

`let SKReceiptPropertyIsRevoked: String`

A key with a value that indicates whether the receipt is in a revoked state.



# Message.Reason

Type Property

# billingIssue

A message the App Store sends that informs people of a billing problem and
enables them to update billing information.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    static let billingIssue: Message.Reason

## Discussion

If an auto-renewable subscription fails to renew due to a billing issue, the
subscription enters a billing retry state, and the App Store sends a message
with the `billingIssue` reason.

When a billing issue is in effect, StoreKit displays a Billing Problem message
sheet when your app launches, or when your app asks to display it.

The sheet informs people of the billing issue, and displays an in-app sheet to
enable them to correct the issue without leaving your app. Note that people
can also resolve billing issues outside of your app by navigating to the
manage payments section in Apple ID settings. For more information, see
support.apple.com.

Apple attempts to renew the subscription during the billing retry period, up
to 60 days. During this period, the App Store sends the `billingIssue` message
in the following intervals:

Billing retry interval| Message frequency  
---|---  
Days 1–3| Every 24 hours  
Days 4–16| Every 72 hours  
Days 17–30| Every 96 hours  
Days 31–60| Every 120 hours  
  
The App Store stops sending further messages when the user resolves the
billing issue, cancels the subscription, or when the billing retry period
ends. StoreKit ensures that the sheet appears only if the message is
applicable when your app calls `display(in:)` or `DisplayMessageAction`.

For more information about the billing retry state, see `isInBillingRetry` in
`Product.SubscriptionInfo.RenewalInfo`.

### Test the message in the sandbox environment

You can simulate billing issues in the sandbox environment to test how the
system presents the `billingIssue` message in your app, and how your app
handles it if you choose to delay or suppress its presentation. For more
information, including step-by-step test cases, see Testing failing
subscription renewals and in-app purchases.

## See Also

### Getting the message reasons

`static let generic: Message.Reason`

A message the App Store sends for a generic reason.

`static let priceIncreaseConsent: Message.Reason`

A message the App Store sends when you increase the price of an auto-renewable
subscription and the price increase requires the user’s consent.

Type Property

# generic

A message the App Store sends for a generic reason.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let generic: Message.Reason

## See Also

### Getting the message reasons

`static let billingIssue: Message.Reason`

A message the App Store sends that informs people of a billing problem and
enables them to update billing information.

`static let priceIncreaseConsent: Message.Reason`

A message the App Store sends when you increase the price of an auto-renewable
subscription and the price increase requires the user’s consent.

Type Property

# priceIncreaseConsent

A message the App Store sends when you increase the price of an auto-renewable
subscription and the price increase requires the user’s consent.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static let priceIncreaseConsent: Message.Reason

## Discussion

For more information about managing prices, see Managing Prices and Manage
pricing for auto-renewable subscriptions.

## See Also

### Getting the message reasons

`static let billingIssue: Message.Reason`

A message the App Store sends that informs people of a billing problem and
enables them to update billing information.

`static let generic: Message.Reason`

A message the App Store sends for a generic reason.

Instance Property

# localizedDescription

A localized description of the App Store message.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

Creates a message reason using the raw value.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    init(rawValue: Int)

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating a message reason

`typealias Message.Reason.RawValue`

A type representing the raw value of a message reason.

`let rawValue: Int`

The raw value of a message reason.

Type Alias

# Message.Reason.RawValue

A type representing the raw value of a message reason.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Message.Reason.RawValue = Int

## See Also

### Creating a message reason

`init(rawValue: Int)`

Creates a message reason using the raw value.

`let rawValue: Int`

The raw value of a message reason.

Instance Property

# rawValue

The raw value of a message reason.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let rawValue: Int

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating a message reason

`init(rawValue: Int)`

Creates a message reason using the raw value.

`typealias Message.Reason.RawValue`

A type representing the raw value of a message reason.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: Message.Reason, rhs: Message.Reason) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing message reasons

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

## See Also

### Comparing and hashing message reasons

`static func != (Message.Reason, Message.Reason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing message reasons

`static func != (Message.Reason, Message.Reason) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# Product.SubscriptionOffer.Signature

Initializer

# init(keyID:nonce:timestamp:signature:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    init(
        keyID: String,
        nonce: UUID,
        timestamp: Int,
        signature: Data
    )

Instance Property

# hashValue

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

Instance Property

# keyID

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var keyID: String

Instance Property

# nonce

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var nonce: UUID

Instance Property

# signature

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var signature: Data

Instance Property

# timestamp

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var timestamp: Int

Instance Method

# hash(into:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    static func != (lhs: Product.SubscriptionOffer.Signature, rhs: Product.SubscriptionOffer.Signature) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

Operator

# ==(_:_:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    static func == (a: Product.SubscriptionOffer.Signature, b: Product.SubscriptionOffer.Signature) -> Bool

Initializer

# init(keyID:nonce:timestamp:signature:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    init(
        keyID: String,
        nonce: UUID,
        timestamp: Int,
        signature: Data
    )

Instance Property

# hashValue

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

Instance Property

# keyID

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var keyID: String

Instance Property

# nonce

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var nonce: UUID

Instance Property

# signature

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var signature: Data

Instance Property

# timestamp

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var timestamp: Int

Instance Method

# hash(into:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    static func != (lhs: Product.SubscriptionOffer.Signature, rhs: Product.SubscriptionOffer.Signature) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

Operator

# ==(_:_:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    static func == (a: Product.SubscriptionOffer.Signature, b: Product.SubscriptionOffer.Signature) -> Bool

Initializer

# init(keyID:nonce:timestamp:signature:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    init(
        keyID: String,
        nonce: UUID,
        timestamp: Int,
        signature: Data
    )

Instance Property

# hashValue

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

Instance Property

# keyID

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var keyID: String

Instance Property

# nonce

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var nonce: UUID

Instance Property

# signature

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var signature: Data

Instance Property

# timestamp

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    var timestamp: Int

Instance Method

# hash(into:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    static func != (lhs: Product.SubscriptionOffer.Signature, rhs: Product.SubscriptionOffer.Signature) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

Operator

# ==(_:_:)

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    static func == (a: Product.SubscriptionOffer.Signature, b: Product.SubscriptionOffer.Signature) -> Bool



# ButtonsSubscriptionStoreControlStyle

Type Property

# buttons

A subscription store control style that displays a subscribe button for each
subscription plan.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var buttons: ButtonsSubscriptionStoreControlStyle { get }

Instance Method

# makeBody(configuration:)

Creates a view that represents the body of a button subscription store.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func makeBody(configuration: ButtonsSubscriptionStoreControlStyle.Configuration) -> some View

##  Parameters

`configuration`

    

The properties of a button subscription store control.

## Relationships

### From Protocol

  * `SubscriptionStoreControlStyle`

## See Also

### Creating the style

`typealias ButtonsSubscriptionStoreControlStyle.Body`

A type that represents the body of a button subscription store control style.

`init()`

Creates a button subscription store control style.

Type Alias

# ButtonsSubscriptionStoreControlStyle.Body

A type that represents the body of a button subscription store control style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias ButtonsSubscriptionStoreControlStyle.Body = some View

## Relationships

### From Protocol

  * `SubscriptionStoreControlStyle`

## See Also

### Creating the style

`func makeBody(configuration:
ButtonsSubscriptionStoreControlStyle.Configuration) -> View`

Creates a view that represents the body of a button subscription store.

`init()`

Creates a button subscription store control style.

Initializer

# init()

Creates a button subscription store control style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init()

## See Also

### Creating the style

`func makeBody(configuration:
ButtonsSubscriptionStoreControlStyle.Configuration) -> View`

Creates a view that represents the body of a button subscription store.

`typealias ButtonsSubscriptionStoreControlStyle.Body`

A type that represents the body of a button subscription store control style.



# Product.PromotionInfo.Visibility

Enumeration Case

# Product.PromotionInfo.Visibility.appStoreConnectDefault

A visibility value for a promoted in-app purchase that uses the visibility
setting from App Store Connect.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    case appStoreConnectDefault

## Discussion

When a promoted in-app purchase has a visibility value of
`Product.PromotionInfo.Visibility.appStoreConnectDefault`, the in-app purchase
is:

  * Visible if the setting in App Store Connect makes it visible

  * Hidden if the setting in App Store Connect makes it hidden

Use this value to control the visibility for promoted in-app purchases in App
Store Connect, globally, for all users. For example, if you have a product to
promote on a holiday, start by manually setting it as hidden using App Store
Connect. On the holiday, change the setting to make the promotion visible. If
the promotion visibility in the app is the default
(`Product.PromotionInfo.Visibility.appStoreConnectDefault`), it becomes
visible for all users automatically.

For more information about the visibility settings in App Store Connect, see
Promote in-app purchases.

## See Also

### Getting visibility states

`case hidden`

A visibility value that hides a promoted in-app purchase on the App Store on a
user’s device.

`case visible`

A visibility value that makes a promoted in-app purchase visible on the App
Store on a user’s device.

Enumeration Case

# Product.PromotionInfo.Visibility.hidden

A visibility value that hides a promoted in-app purchase on the App Store on a
user’s device.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    case hidden

## Discussion

A promoted in-app purchase with this visibility setting isn’t visible on the
App Store on a user’s device.

## See Also

### Getting visibility states

`case appStoreConnectDefault`

A visibility value for a promoted in-app purchase that uses the visibility
setting from App Store Connect.

`case visible`

A visibility value that makes a promoted in-app purchase visible on the App
Store on a user’s device.

Enumeration Case

# Product.PromotionInfo.Visibility.visible

A visibility value that makes a promoted in-app purchase visible on the App
Store on a user’s device.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    case visible

## Discussion

A promoted in-app purchase with this visibility setting is visible on the App
Store on a user’s device.

## See Also

### Getting visibility states

`case appStoreConnectDefault`

A visibility value for a promoted in-app purchase that uses the visibility
setting from App Store Connect.

`case hidden`

A visibility value that hides a promoted in-app purchase on the App Store on a
user’s device.

Initializer

# init(rawValue:)

Creates a visibility state.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    init?(rawValue: Int)

##  Parameters

`rawValue`

    

The raw value that represents the visibility of a promoted in-app purchase.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating visibility states

`typealias Product.PromotionInfo.Visibility.RawValue`

A type that represents the raw value of the visibility state of a promoted in-
app purchase.

`var rawValue: Int`

The raw value that represents the visiblity state of a promoted in-app
purchase.

Type Alias

# Product.PromotionInfo.Visibility.RawValue

A type that represents the raw value of the visibility state of a promoted in-
app purchase.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    typealias Product.PromotionInfo.Visibility.RawValue = Int

## See Also

### Creating visibility states

`init?(rawValue: Int)`

Creates a visibility state.

`var rawValue: Int`

The raw value that represents the visiblity state of a promoted in-app
purchase.

Instance Property

# rawValue

The raw value that represents the visiblity state of a promoted in-app
purchase.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    var rawValue: Int { get }

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating visibility states

`init?(rawValue: Int)`

Creates a visibility state.

`typealias Product.PromotionInfo.Visibility.RawValue`

A type that represents the raw value of the visibility state of a promoted in-
app purchase.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 16.4+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    static func != (lhs: Product.PromotionInfo.Visibility, rhs: Product.PromotionInfo.Visibility) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing visibility

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 16.4+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    func hash(into hasher: inout Hasher)

## See Also

### Comparing and hashing visibility

`static func != (Product.PromotionInfo.Visibility,
Product.PromotionInfo.Visibility) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 16.4+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing visibility

`static func != (Product.PromotionInfo.Visibility,
Product.PromotionInfo.Visibility) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Enumeration Case

# Product.PromotionInfo.Visibility.appStoreConnectDefault

A visibility value for a promoted in-app purchase that uses the visibility
setting from App Store Connect.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    case appStoreConnectDefault

## Discussion

When a promoted in-app purchase has a visibility value of
`Product.PromotionInfo.Visibility.appStoreConnectDefault`, the in-app purchase
is:

  * Visible if the setting in App Store Connect makes it visible

  * Hidden if the setting in App Store Connect makes it hidden

Use this value to control the visibility for promoted in-app purchases in App
Store Connect, globally, for all users. For example, if you have a product to
promote on a holiday, start by manually setting it as hidden using App Store
Connect. On the holiday, change the setting to make the promotion visible. If
the promotion visibility in the app is the default
(`Product.PromotionInfo.Visibility.appStoreConnectDefault`), it becomes
visible for all users automatically.

For more information about the visibility settings in App Store Connect, see
Promote in-app purchases.

## See Also

### Getting visibility states

`case hidden`

A visibility value that hides a promoted in-app purchase on the App Store on a
user’s device.

`case visible`

A visibility value that makes a promoted in-app purchase visible on the App
Store on a user’s device.

Enumeration Case

# Product.PromotionInfo.Visibility.hidden

A visibility value that hides a promoted in-app purchase on the App Store on a
user’s device.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    case hidden

## Discussion

A promoted in-app purchase with this visibility setting isn’t visible on the
App Store on a user’s device.

## See Also

### Getting visibility states

`case appStoreConnectDefault`

A visibility value for a promoted in-app purchase that uses the visibility
setting from App Store Connect.

`case visible`

A visibility value that makes a promoted in-app purchase visible on the App
Store on a user’s device.

Enumeration Case

# Product.PromotionInfo.Visibility.visible

A visibility value that makes a promoted in-app purchase visible on the App
Store on a user’s device.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    case visible

## Discussion

A promoted in-app purchase with this visibility setting is visible on the App
Store on a user’s device.

## See Also

### Getting visibility states

`case appStoreConnectDefault`

A visibility value for a promoted in-app purchase that uses the visibility
setting from App Store Connect.

`case hidden`

A visibility value that hides a promoted in-app purchase on the App Store on a
user’s device.

Initializer

# init(rawValue:)

Creates a visibility state.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    init?(rawValue: Int)

##  Parameters

`rawValue`

    

The raw value that represents the visibility of a promoted in-app purchase.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating visibility states

`typealias Product.PromotionInfo.Visibility.RawValue`

A type that represents the raw value of the visibility state of a promoted in-
app purchase.

`var rawValue: Int`

The raw value that represents the visiblity state of a promoted in-app
purchase.

Type Alias

# Product.PromotionInfo.Visibility.RawValue

A type that represents the raw value of the visibility state of a promoted in-
app purchase.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    typealias Product.PromotionInfo.Visibility.RawValue = Int

## See Also

### Creating visibility states

`init?(rawValue: Int)`

Creates a visibility state.

`var rawValue: Int`

The raw value that represents the visiblity state of a promoted in-app
purchase.

Instance Property

# rawValue

The raw value that represents the visiblity state of a promoted in-app
purchase.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    var rawValue: Int { get }

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating visibility states

`init?(rawValue: Int)`

Creates a visibility state.

`typealias Product.PromotionInfo.Visibility.RawValue`

A type that represents the raw value of the visibility state of a promoted in-
app purchase.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 16.4+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    static func != (lhs: Product.PromotionInfo.Visibility, rhs: Product.PromotionInfo.Visibility) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing visibility

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 16.4+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    func hash(into hasher: inout Hasher)

## See Also

### Comparing and hashing visibility

`static func != (Product.PromotionInfo.Visibility,
Product.PromotionInfo.Visibility) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.4+  iPadOS 16.4+  macOS 13.3+  Mac Catalyst 16.4+  tvOS 16.4+  watchOS
9.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing visibility

`static func != (Product.PromotionInfo.Visibility,
Product.PromotionInfo.Visibility) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# SKCloudServiceSetupViewControllerDelegate

Instance Method

# cloudServiceSetupViewControllerDidDismiss(_:)

Tells the delegate that the cloud service setup view controller was dismissed.

iOS 10.1+  iPadOS 10.1+  Mac Catalyst 13.1+

    
    
    optional func cloudServiceSetupViewControllerDidDismiss(_ cloudServiceSetupViewController: SKCloudServiceSetupViewController)

##  Parameters

`cloudServiceSetupViewController`

    

The cloud service view controller that was dismissed.



# Product.SubscriptionOffer.PaymentMode

Type Property

# freeTrial

A payment mode of a product discount that indicates a free trial offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let freeTrial: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Free trial payment mode, customers pay nothing during the discount
period.

## See Also

### Getting the payment modes

`static let payAsYouGo: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

`static let payUpFront: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the system applies the
discount up front.

Type Property

# payAsYouGo

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let payAsYouGo: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Pay As You Go payment mode, subscribers pay a discounted price for each
billing period for the duration of the discount.

## See Also

### Getting the payment modes

`static let freeTrial: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates a free trial offer.

`static let payUpFront: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the system applies the
discount up front.

Type Property

# payUpFront

A payment mode of a product discount that indicates the system applies the
discount up front.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let payUpFront: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Pay Up Front payment mode, subscribers pay a one-time discounted price
for a specific duration.

## See Also

### Getting the payment modes

`static let freeTrial: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates a free trial offer.

`static let payAsYouGo: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

Instance Property

# localizedDescription

The localized text that describes the payment mode.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Instance Property

# rawValue

The raw string value that represents a payment mode for a subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: String

## Discussion

Use the raw value to help parse the `jsonRepresentation` property of
`Product`. If a product is a subscription with an offer, the JSON contains a
string representation of the payment mode, which is its raw value. You can
compare the JSON data directly to the payment mode’s `rawValue`.

You can also use the `rawValue` to create a payment mode instance by calling
`init(rawValue:)`.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionOffer.PaymentMode.RawValue`

A type that represents the raw value of a payment mode for a subscription
offer.

Type Alias

# Product.SubscriptionOffer.PaymentMode.RawValue

A type that represents the raw value of a payment mode for a subscription
offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionOffer.PaymentMode.RawValue = String

## See Also

### Accessing the raw value

`let rawValue: String`

The raw string value that represents a payment mode for a subscription offer.

Initializer

# init(rawValue:)

Creates a subscription offer payment mode instance from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

A string that represents a payment mode for a subscription offer.

## Discussion

Typically, you get a payment mode from the `paymentMode` property in
subscription offer information, and you don’t need to instantiate it yourself.

However, if you use the `jsonRepresentation` property of `Product`, you can
use raw values and the initializer to help parse the JSON. If the product is a
subscription with an offer, the JSON contains the string representation of the
payment mode, which is its raw value. Call `init(rawValue:)` to create your
own instance from that raw value. Alternatively, you can compare the JSON data
directly to the payment mode’s `rawValue`.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer.PaymentMode, rhs: Product.SubscriptionOffer.PaymentMode) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing payment modes

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing payment modes

`static func != (Product.SubscriptionOffer.PaymentMode,
Product.SubscriptionOffer.PaymentMode) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing payment modes

`static func != (Product.SubscriptionOffer.PaymentMode,
Product.SubscriptionOffer.PaymentMode) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# freeTrial

A payment mode of a product discount that indicates a free trial offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let freeTrial: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Free trial payment mode, customers pay nothing during the discount
period.

## See Also

### Getting the payment modes

`static let payAsYouGo: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

`static let payUpFront: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the system applies the
discount up front.

Type Property

# payAsYouGo

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let payAsYouGo: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Pay As You Go payment mode, subscribers pay a discounted price for each
billing period for the duration of the discount.

## See Also

### Getting the payment modes

`static let freeTrial: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates a free trial offer.

`static let payUpFront: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the system applies the
discount up front.

Type Property

# payUpFront

A payment mode of a product discount that indicates the system applies the
discount up front.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let payUpFront: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Pay Up Front payment mode, subscribers pay a one-time discounted price
for a specific duration.

## See Also

### Getting the payment modes

`static let freeTrial: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates a free trial offer.

`static let payAsYouGo: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

Instance Property

# localizedDescription

The localized text that describes the payment mode.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Instance Property

# rawValue

The raw string value that represents a payment mode for a subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: String

## Discussion

Use the raw value to help parse the `jsonRepresentation` property of
`Product`. If a product is a subscription with an offer, the JSON contains a
string representation of the payment mode, which is its raw value. You can
compare the JSON data directly to the payment mode’s `rawValue`.

You can also use the `rawValue` to create a payment mode instance by calling
`init(rawValue:)`.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionOffer.PaymentMode.RawValue`

A type that represents the raw value of a payment mode for a subscription
offer.

Type Alias

# Product.SubscriptionOffer.PaymentMode.RawValue

A type that represents the raw value of a payment mode for a subscription
offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionOffer.PaymentMode.RawValue = String

## See Also

### Accessing the raw value

`let rawValue: String`

The raw string value that represents a payment mode for a subscription offer.

Initializer

# init(rawValue:)

Creates a subscription offer payment mode instance from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

A string that represents a payment mode for a subscription offer.

## Discussion

Typically, you get a payment mode from the `paymentMode` property in
subscription offer information, and you don’t need to instantiate it yourself.

However, if you use the `jsonRepresentation` property of `Product`, you can
use raw values and the initializer to help parse the JSON. If the product is a
subscription with an offer, the JSON contains the string representation of the
payment mode, which is its raw value. Call `init(rawValue:)` to create your
own instance from that raw value. Alternatively, you can compare the JSON data
directly to the payment mode’s `rawValue`.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer.PaymentMode, rhs: Product.SubscriptionOffer.PaymentMode) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing payment modes

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing payment modes

`static func != (Product.SubscriptionOffer.PaymentMode,
Product.SubscriptionOffer.PaymentMode) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing payment modes

`static func != (Product.SubscriptionOffer.PaymentMode,
Product.SubscriptionOffer.PaymentMode) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Property

# freeTrial

A payment mode of a product discount that indicates a free trial offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let freeTrial: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Free trial payment mode, customers pay nothing during the discount
period.

## See Also

### Getting the payment modes

`static let payAsYouGo: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

`static let payUpFront: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the system applies the
discount up front.

Type Property

# payAsYouGo

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let payAsYouGo: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Pay As You Go payment mode, subscribers pay a discounted price for each
billing period for the duration of the discount.

## See Also

### Getting the payment modes

`static let freeTrial: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates a free trial offer.

`static let payUpFront: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the system applies the
discount up front.

Type Property

# payUpFront

A payment mode of a product discount that indicates the system applies the
discount up front.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let payUpFront: Product.SubscriptionOffer.PaymentMode

## Discussion

With a Pay Up Front payment mode, subscribers pay a one-time discounted price
for a specific duration.

## See Also

### Getting the payment modes

`static let freeTrial: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates a free trial offer.

`static let payAsYouGo: Product.SubscriptionOffer.PaymentMode`

A payment mode of a product discount that indicates the discount applies over
a single billing period or multiple billing periods.

Instance Property

# localizedDescription

The localized text that describes the payment mode.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Instance Property

# rawValue

The raw string value that represents a payment mode for a subscription offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: String

## Discussion

Use the raw value to help parse the `jsonRepresentation` property of
`Product`. If a product is a subscription with an offer, the JSON contains a
string representation of the payment mode, which is its raw value. You can
compare the JSON data directly to the payment mode’s `rawValue`.

You can also use the `rawValue` to create a payment mode instance by calling
`init(rawValue:)`.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Accessing the raw value

`typealias Product.SubscriptionOffer.PaymentMode.RawValue`

A type that represents the raw value of a payment mode for a subscription
offer.

Type Alias

# Product.SubscriptionOffer.PaymentMode.RawValue

A type that represents the raw value of a payment mode for a subscription
offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionOffer.PaymentMode.RawValue = String

## See Also

### Accessing the raw value

`let rawValue: String`

The raw string value that represents a payment mode for a subscription offer.

Initializer

# init(rawValue:)

Creates a subscription offer payment mode instance from a raw value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

A string that represents a payment mode for a subscription offer.

## Discussion

Typically, you get a payment mode from the `paymentMode` property in
subscription offer information, and you don’t need to instantiate it yourself.

However, if you use the `jsonRepresentation` property of `Product`, you can
use raw values and the initializer to help parse the JSON. If the product is a
subscription with an offer, the JSON contains the string representation of the
payment mode, which is its raw value. Call `init(rawValue:)` to create your
own instance from that raw value. Alternatively, you can compare the JSON data
directly to the payment mode’s `rawValue`.

## Relationships

### From Protocol

  * `RawRepresentable`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer.PaymentMode, rhs: Product.SubscriptionOffer.PaymentMode) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing payment modes

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and hashing payment modes

`static func != (Product.SubscriptionOffer.PaymentMode,
Product.SubscriptionOffer.PaymentMode) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and hashing payment modes

`static func != (Product.SubscriptionOffer.PaymentMode,
Product.SubscriptionOffer.PaymentMode) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# SubscriptionStoreButtonLabel

Instance Property

# action

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var action: SubscriptionStoreButtonLabel { get }

Instance Property

# displayName

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var displayName: SubscriptionStoreButtonLabel { get }

Instance Property

# hashValue

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

Instance Property

# multiline

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
visionOS 1.0+  Xcode 15.0+

    
    
    var multiline: SubscriptionStoreButtonLabel { get }

Instance Property

# price

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var price: SubscriptionStoreButtonLabel { get }

Instance Property

# singleLine

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var singleLine: SubscriptionStoreButtonLabel { get }

Type Property

# action

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var action: SubscriptionStoreButtonLabel { get }

Type Property

# automatic

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var automatic: SubscriptionStoreButtonLabel { get }

Type Property

# displayName

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var displayName: SubscriptionStoreButtonLabel { get }

Type Property

# multiline

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
visionOS 1.0+  Xcode 15.0+

    
    
    static var multiline: SubscriptionStoreButtonLabel { get }

Type Property

# price

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var price: SubscriptionStoreButtonLabel { get }

Type Property

# singleLine

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var singleLine: SubscriptionStoreButtonLabel { get }

Instance Method

# hash(into:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing button labels

`static func != (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel)
-> Bool`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func != (lhs: SubscriptionStoreButtonLabel, rhs: SubscriptionStoreButtonLabel) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing button labels

`func hash(into: inout Hasher)`

`static func == (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel)
-> Bool`

Operator

# ==(_:_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static func == (a: SubscriptionStoreButtonLabel, b: SubscriptionStoreButtonLabel) -> Bool

## See Also

### Comparing and hashing button labels

`func hash(into: inout Hasher)`

`static func != (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel)
-> Bool`

Returns a Boolean value indicating whether two values are not equal.



# StoreView

Initializer

# init(ids:prefersPromotionalIcon:)

Creates a view to load and merchandise a collection of products from the App
Store using product identifiers.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        ids productIDs: some Collection<String>,
        prefersPromotionalIcon: Bool = false
    ) where Icon == EmptyView, PlaceholderIcon == EmptyView

##  Parameters

`productIDs`

    

The product identifiers to load from the App Store.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use promotional images from the App
Store, if they’re available. If this parameter is `false`, the system ignores
promotional images.

## See Also

### Creating store views that load products

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon:
(Product) -> Icon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using a custom image.

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon:
(Product) -> Icon, placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using an image and a custom
placeholder icon.

`init(ids: some Collection<String>, icon: (Product, ProductIconPhase) -> Icon,
placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using their promotional images and a
custom placeholder icon.

Initializer

# init(ids:prefersPromotionalIcon:icon:)

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using a custom image.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        ids productIDs: some Collection<String>,
        prefersPromotionalIcon: Bool = false,
        @ViewBuilder icon: @escaping (Product) -> Icon
    ) where PlaceholderIcon == AutomaticProductPlaceholderIcon

##  Parameters

`productIDs`

    

The product identifiers to load from the App Store.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use promotional images from the App
Store, if they’re available. If this parameter is `false`, the system ignores
promotional images.

`icon`

    

A closure that returns the image the view displays when the products finish
loading from the App Store.

## Discussion

The store view shows a placeholder icon until all products finish loading.
Then, the view uses the image that you provide in `icon`, by default. If you
set `prefersPromotionalIcon` to `true`, the view uses the promotional image
instead of the `icon` for any products that have promotional images available.

## See Also

### Creating store views that load products

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool)`

Creates a view to load and merchandise a collection of products from the App
Store using product identifiers.

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon:
(Product) -> Icon, placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using an image and a custom
placeholder icon.

`init(ids: some Collection<String>, icon: (Product, ProductIconPhase) -> Icon,
placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using their promotional images and a
custom placeholder icon.

Initializer

# init(ids:prefersPromotionalIcon:icon:placeholderIcon:)

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using an image and a custom
placeholder icon.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        ids productIDs: some Collection<String>,
        prefersPromotionalIcon: Bool = false,
        @ViewBuilder icon: @escaping (Product) -> Icon,
        @ViewBuilder placeholderIcon: () -> PlaceholderIcon
    )

##  Parameters

`productIDs`

    

The product identifiers to load from the App Store.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use a promotional image from the App
Store, if it’s available. If this parameter is `false`, the system ignores
promotional images.

`icon`

    

A closure that returns the image the view displays when the products finish
loading from the App Store.

`placeholderIcon`

    

A closure that returns the image that the view uses while the products are
loading. The view uses the same placeholder image for all the products.

## Discussion

The store view shows the custom placeholder icon until all products finish
loading. After the view finishes loading the products, it uses the image you
provide, by default. If you set `prefersPromotionalIcon `to `true`, any
products that have an available promotional image use the promotional image
instead.

The following example shows how to create a store view using an icon and a
custom placeholder icon:

## See Also

### Creating store views that load products

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool)`

Creates a view to load and merchandise a collection of products from the App
Store using product identifiers.

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon:
(Product) -> Icon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using a custom image.

`init(ids: some Collection<String>, icon: (Product, ProductIconPhase) -> Icon,
placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using their promotional images and a
custom placeholder icon.

Initializer

# init(ids:icon:placeholderIcon:)

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using their promotional images and a
custom placeholder icon.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        ids productIDs: some Collection<String>,
        @ViewBuilder icon: @escaping (Product, ProductIconPhase) -> Icon,
        @ViewBuilder placeholderIcon: () -> PlaceholderIcon
    )

##  Parameters

`productIDs`

    

The product identifiers to load from the App Store.

`icon`

    

A closure that receives a `Product` and a `ProductIconPhase` as input. The
`ProductIconPhase` indicates the state of the loading operation of the
product’s promotional image. The closure returns the view to display for the
given product and phase value.

`placeholderIcon`

    

A closure that returns the view that the store view uses while the products
are loading. The store view uses the same placeholder image for all the
products.

## Discussion

The store view shows the custom `placeholderIcon` until all products finish
loading. After the products finish loading, the view asynchronously loads and
displays each product’s promotional image.

Use the `ProductIconPhase` to monitor the current loading state of a product’s
promotional image, and provide a view for each phase. Consider returning the
view provided in the `placeholderIcon `closure for during the
`ProductIconPhase.loading` phase. For more information, see
`ProductIconPhase`.

If a product is unavailable, the store view uses the view that the
`placeholderIcon` closure provides as a fallback.

## See Also

### Creating store views that load products

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool)`

Creates a view to load and merchandise a collection of products from the App
Store using product identifiers.

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon:
(Product) -> Icon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using a custom image.

`init(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon:
(Product) -> Icon, placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load a collection of products from the App Store using
product identifiers, and merchandise them using an image and a custom
placeholder icon.

Initializer

# init(products:prefersPromotionalIcon:)

Creates a view to load and merchandise a collection of products from the App
Store.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        products: some Collection<Product>,
        prefersPromotionalIcon: Bool = false
    ) where Icon == EmptyView, PlaceholderIcon == EmptyView

##  Parameters

`products`

    

The products to merchandise.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use promotional images from the App
Store, if they’re available. If this parameter is `false`, the system ignores
promotional images.

## Discussion

By default, the store view doesn’t show promotional images. If you set
`prefersPromotionalIcon` to `true`, the store view uses each product’s
promotional image as its icon.

## See Also

### Creating store views with preloaded products

`init(products: some Collection<Product>, prefersPromotionalIcon: Bool, icon:
(Product) -> Icon)`

Creates a view to merchandise a collection of products using a custom icon.

`init(products: some Collection<Product>, icon: (Product, ProductIconPhase) ->
Icon)`

Creates a view to merchandise a collection of products with promotional
images.

Initializer

# init(products:prefersPromotionalIcon:icon:)

Creates a view to merchandise a collection of products using a custom icon.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        products: some Collection<Product>,
        prefersPromotionalIcon: Bool = false,
        @ViewBuilder icon: @escaping (Product) -> Icon
    ) where PlaceholderIcon == EmptyView

##  Parameters

`products`

    

The products to merchandise.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use promotional images from the App
Store, if they’re available. If this parameter is `false`, the system ignores
promotional images.

`icon`

    

A closure that returns the image the view displays when the products finish
loading from the App Store.

## Discussion

If you set `prefersPromotionalIcon` to `true`, the view uses promotional
images for products that have a promotional image available.

The following code example shows how to create a store view using a custom
icon:

## See Also

### Creating store views with preloaded products

`init(products: some Collection<Product>, prefersPromotionalIcon: Bool)`

Creates a view to load and merchandise a collection of products from the App
Store.

`init(products: some Collection<Product>, icon: (Product, ProductIconPhase) ->
Icon)`

Creates a view to merchandise a collection of products with promotional
images.

Initializer

# init(products:icon:)

Creates a view to merchandise a collection of products with promotional
images.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        products: some Collection<Product>,
        @ViewBuilder icon: @escaping (Product, ProductIconPhase) -> Icon
    ) where PlaceholderIcon == EmptyView

##  Parameters

`products`

    

The products to merchandise.

`icon`

    

A closure that receives a `Product` and a `ProductIconPhase` as input. The
`ProductIconPhase` indicates the state of the loading operation of the
product’s promotional image. The closure returns the view to display for the
given product and phase value.

## Discussion

The store view asynchronously loads and displays each product’s promotional
image. Use the `ProductIconPhase` to monitor the current loading phase of the
product’s promotional image, and provide an image for each phase. For more
information about the loading phases, see `ProductIconPhase`.

## See Also

### Creating store views with preloaded products

`init(products: some Collection<Product>, prefersPromotionalIcon: Bool)`

Creates a view to load and merchandise a collection of products from the App
Store.

`init(products: some Collection<Product>, prefersPromotionalIcon: Bool, icon:
(Product) -> Icon)`

Creates a view to merchandise a collection of products using a custom icon.

Instance Method

# inAppPurchaseOptions(_:)

Adds a function the system calls before it processes a purchase from a store
view, which provides a set of purchase options.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func inAppPurchaseOptions(_ options: ((Product) async -> Set<Product.PurchaseOption>)?) -> some View

##  Parameters

`options`

    

A closure you provide for the system to call before it processes a purchase.
The system sends the product the person intends to purchase as a parameter.
Return a set of purchase options (`Product.PurchaseOption`) to add to the
purchase.

## See Also

### Responding to store events

`func onInAppPurchaseCompletion(perform: ((Product,
Result<Product.PurchaseResult, any Error>) -> ())?) -> View`

Adds an action to perform when a purchase the person initiated from within a
product view completes.

`func onInAppPurchaseStart(perform: ((Product) -> ())?) -> View`

Adds an action to perform when a user triggers the purchase button on a
product within this view.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# onInAppPurchaseCompletion(perform:)

Adds an action to perform when a purchase the person initiated from within a
product view completes.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func onInAppPurchaseCompletion(perform action: ((Product, Result<Product.PurchaseResult, any Error>) async -> ())?) -> some View

## See Also

### Responding to store events

`func inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) ->
View`

Adds a function the system calls before it processes a purchase from a store
view, which provides a set of purchase options.

`func onInAppPurchaseStart(perform: ((Product) -> ())?) -> View`

Adds an action to perform when a user triggers the purchase button on a
product within this view.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# onInAppPurchaseStart(perform:)

Adds an action to perform when a user triggers the purchase button on a
product within this view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func onInAppPurchaseStart(perform action: ((Product) async -> ())?) -> some View

## See Also

### Responding to store events

`func inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) ->
View`

Adds a function the system calls before it processes a purchase from a store
view, which provides a set of purchase options.

`func onInAppPurchaseCompletion(perform: ((Product,
Result<Product.PurchaseResult, any Error>) -> ())?) -> View`

Adds an action to perform when a purchase the person initiated from within a
product view completes.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# productViewStyle(_:)

Sets the style for in-app purchase product views within a view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func productViewStyle(_ style: some ProductViewStyle) -> some View

Instance Method

# storeButton(_:for:)

Specifies the visibility of auxilliary buttons that store view and
subscription store view instances may use.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func storeButton(
        _ visibility: Visibility,
        for buttonKinds: StoreButtonKind...
    ) -> some View

##  Parameters

`visibility`

    

The preferred visibility (`Visibility`) of the button.

`buttonKinds`

    

The type of store button (`StoreButtonKind`).

## See Also

### Configuring and styling products

`struct StoreButtonKind`

A button to display in a store view or subscription store view.

Instance Property

# body

The content and behavior of the view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @MainActor
    var body: some View { get }

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing store views

`typealias StoreView.Body`

The type of view that represents the body of the store view.

Type Alias

# StoreView.Body

The type of view that represents the body of the store view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias StoreView<Icon, PlaceholderIcon>.Body = some View

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing store views

`var body: View`

The content and behavior of the view.

Instance Method

# productDescription(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.4+
tvOS 17.0+  watchOS 10.0+  visionOS 1.1+  Xcode 15.0+

    
    
    func productDescription(_ visibility: Visibility) -> some View

Instance Method

# searchPresentationToolbarBehavior(_:)

StoreKit  SwiftUI  iOS 17.1+  iPadOS 17.1+  macOS 14.1+  Mac Catalyst 17.2+
tvOS 17.1+  watchOS 10.1+  visionOS 1.0+  Xcode 14.4+

    
    
    func searchPresentationToolbarBehavior(_ behavior: SearchPresentationToolbarBehavior) -> some View

Instance Method

# subscriptionPromotionalOffer(offer:signature:)

StoreKit  SwiftUI  iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+
tvOS 17.4+  watchOS 10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func subscriptionPromotionalOffer(
        offer: @escaping (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?,
        signature: @escaping (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) async throws -> Product.SubscriptionOffer.Signature
    ) -> some View



# SKPaymentQueueDelegate

Instance Method

# paymentQueue(_:shouldContinue:in:)

Asks the delegate whether to continue the transaction if the device’s App
Store storefront changes during a transaction.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 13.1+  tvOS 13.0+  watchOS
6.2+  visionOS 1.0+

    
    
    optional func paymentQueue(
        _ paymentQueue: SKPaymentQueue,
        shouldContinue transaction: SKPaymentTransaction,
        in newStorefront: SKStorefront
    ) -> Bool

## Discussion

StoreKit calls this delegate method if the storefront changes while processing
a transaction.

  * Return `true` if you wish to continue the transaction within the updated storefront. 

  * Return `false` to stop the transaction. The transaction will fail with the error `SKError.Code.storeProductNotAvailable`. In this case, consider displaying a message to the user indicating that the product isn't available in the current storefront.

If the delegate isn't implemented, `paymentQueue(_:shouldContinue:in:)`
defaults to `true`.

This call times out after approximately one second, defaulting to `false` and
causing the transaction to fail. The delegate should return as quickly as
possible. Don't perform any networking calls in this method. Your app should
cache product availability information locally before starting a transaction.

See `SKStorefront` for more information.

Instance Method

# paymentQueueShouldShowPriceConsent(_:)

Asks the delegate whether to immediately display a price consent sheet.

iOS 13.4+  iPadOS 13.4+  Mac Catalyst 13.4+  visionOS 1.0+

    
    
    optional func paymentQueueShouldShowPriceConsent(_ paymentQueue: SKPaymentQueue) -> Bool

## Discussion

This method applies only to auto-renewable subscription price increases that
require customer consent.

The default return value for this optional method is `true`. By default, the
system displays the price consent sheet when you increase the subscription
price in App Store Connect and the subscriber hasn’t yet taken action.

The system calls your delegate’s method, if appropriate, when you add the
first observer to `SKPaymentQueue`, and any time the app comes to foreground.

If you return `false`, the system won’t show the price consent sheet. You can
choose to display it later by calling `showPriceConsentIfNeeded()`. You may
want to delay showing the sheet if it would interrupt your user’s interaction
in your app.

Note

When you increase the price of an auto-renewable subscription and it requires
customer consent, Apple informs affected subscribers through an email, push
notification, and an in-app price consent sheet and asks them to agree to the
new price. If they don’t agree or take no action, their subscription expires
at the end of their current billing cycle. For more information, see Managing
Prices and Manage pricing for auto-renewable subscriptions.

In Mac apps built with Mac Catalyst, the system doesn’t show the price consent
sheet regardless of the return value.

## See Also

### Related Documentation

`func showPriceConsentIfNeeded()`

Asks the system to display the price consent sheet if the user hasn’t yet
responded to a subscription price increase.



# ExternalPurchaseLink

Property List Key

# SKExternalPurchaseMultiLink

A dictionary that contains an array of URLs to websites where people using
your app can make external purchases.

iOS 17.5+ Beta iPadOS 17.5+ Beta macOS 14.5+ Beta Mac Catalyst 17.5+ Beta tvOS
17.5+ Beta watchOS 10.5+ Beta visionOS 1.2+ Beta

##  Details

Type

    

dictionary

## Properties

`Any Key`

`[string]`

A dictionary with a key that is the lowercased ISO 3166-1 alpha-2 country
code, and an array of strings that represent valid destination URLs.

Valid country codes include those for the European Union: Austria (`at`),
Belgium (`be`), Bulgaria (`bg`), Croatia (`hr`), Cyprus (`cy`), Czechia
(`cz`), Denmark (`dk`), Estonia (`ee`), Finland (`fi`), France (`fr`), Germany
(`de`), Greece (`gr`), Hungary (`hu`), Ireland (`ie`), Italy (`it`), Latvia
(`lv`), Lithuania (`lt`), Luxembourg (`lu`), Malta (`mt`), Netherlands (`nl`),
Poland (`pl`), Portugal (`pt`), Romania (`ro`), Slovakia (`sk`), Slovenia
(`si`), Spain (`es`), Sweden (`se`); and Iceland (`is`), Norway (`no`), Russia
(`ru`), and United States (`us`).

## Discussion

Use this information property list key if your app has the
`com.apple.developer.storekit.external-purchase-link` entitlement.

Include a key entry for each country code where your app supports an external
purchase link. Provide from one to five destination URLs (links to your
website) for your app to choose from for each country code.

Note

You can provide up to five links if your app qualifies for the StoreKit
External Purchase Link entitlement as described in Distributing music
streaming apps in the EEA that provide an external purchase link.  Otherwise,
provide one link for each country code.

Your app accesses these URLs through the `eligibleURLs` array in the
`ExternalPurchaseLink` object, and uses the link you select with the
`open(url:)` method in the `ExternalPurchaseLink` object.

Important

At all times, the destination URLs that you provide in the property list key
must match the values in your app binary that you submit to App Review.

Make sure each destination URL meets all of the following conditions:

  * Uses the HTTPS scheme

  * Forms a valid, absolute URL

  * Contains no query parameters

  * Contains 1,000 or fewer ASCII characters

The following code example shows a property list entry with keys for several
country codes, and links for each entry:

    
    
    <key>SKExternalPurchaseMultiLink</key>
    <dict>
        <key>es</key>
        <array>
            <string>https://www.example.com/es1</string>
            <string>https://www.example.com/new-user-es</string>
            <string>https://www.example.com/seasonal-sale-es</string>
            <string>https://www.example.com/es2</string>
            <string>https://www.example.com/es3</string>
        </array>
        <key>fr</key>
        <array>
            <string>https://www.example.com/fr</string>
            <string>https://www.example.com/global-sale</string>
            <string>https://www.example.com/new-user-fr</string>
        </array>
        <key>it</key>
        <array>
            <string>https://www.example.com/global-sale</string>
        </array>
    </dict>
    

The order of the links is not significant.

For more information, see External Purchase and `ExternalPurchaseLink`.

### Provide up to the maximum number of links

The following country codes have a maximum of five links for apps that qualify
for the StoreKit External Purchase Link entitlement as described in
Distributing music streaming apps in the EEA that provide an external purchase
link: Austria (`at`), Belgium (`be`), Bulgaria (`bg`), Croatia (`hr`), Cyprus
(`cy`), Czechia (`cz`), Denmark (`dk`), Estonia (`ee`), Finland (`fi`), France
(`fr`), Germany (`de`), Greece (`gr`), Hungary (`hu`), Ireland (`ie`), Italy
(`it`), Latvia (`lv`), Lithuania (`lt`), Luxembourg (`lu`), Malta (`mt`),
Netherlands (`nl`), Poland (`pl`), Portugal (`pt`), Romania (`ro`), Slovakia
(`sk`), Slovenia (`si`), Spain (`es`), Sweden (`se`), Iceland (`is`), Norway
(`no`). Otherwise, the maximum is one link, for valid country codes.

Count the total number of unique links you provide for each country code by
adding together the number of links you provide in the
`SKExternalPurchaseMultiLink` and `SKExternalPurchaseLink` property list keys.

For example, if a country code has a maximum of five links and you provide
five unique links in the `SKExternalPurchaseMultiLink` key, then specify one
of the same five links in the `SKExternalPurchaseLink` key to avoid exceeding
the maximum allowed links. If a country code has a maximum of one link, the
`SKExternalPurchaseMultiLink` and `SKExternalPurchaseLink` keys need to
specify the same link.

Beta Software

This documentation contains preliminary information about an API or technology
in development. This information is subject to change, and software
implemented according to this documentation should be tested with final
operating system software.

Learn more about using Apple's beta software

Type Property

# eligibleURLs

An array of external purchase links for the current storefront that the app
configured and from which it chooses.

iOS 17.5+ Beta iPadOS 17.5+ Beta macOS 14.5+ Beta Mac Catalyst 17.5+ Beta tvOS
17.5+ Beta watchOS 10.5+ Beta visionOS 1.2+ Beta Xcode 15.3+

    
    
    static var eligibleURLs: [URL]? { get async }

## Discussion

Use this property if your app configures the `SKExternalPurchaseMultiLink`
property list key.

Use the `eligibleURLs` to get the array of external purchase links for the
current storefront that your app has configured in the
`SKExternalPurchaseMultiLink` property list key. Your app can select from any
of the eligible URLs. Call `open(url:)` with the URL you choose.

The `eligibleURLs` array is `nil` if any of the following is true:

  * The current App Store storefront doesn't allow external purchase or the person isn't eligible to make external purchases.

  * Your app doesn't configure the `com.apple.developer.storekit.external-purchase-link` entitlement.

  * Your app doesn’t configure any links for the current storefront in the `SKExternalPurchaseMultiLink` property list key

If this value is `nil` and your app also configures the
`SKExternalPurchaseLink` property list key, check `canOpen` to determine
whether your app can continue to provide an external purchase link.

Otherwise, if this value is `nil`, check `canMakePayments` to determine
whether your app can offer in-app purchases using the StoreKit In-App Purchase
APIs. For more information, see `canMakePayments`.

## See Also

### Getting multiple external purchase links

`property list key SKExternalPurchaseMultiLink`

A dictionary that contains an array of URLs to websites where people using
your app can make external purchases.

Beta

`static func open(url: URL)`

Presents a continuation sheet that enables people to choose whether your app
shows the indicated URL link for external purchases.

Beta Software

This documentation contains preliminary information about an API or technology
in development. This information is subject to change, and software
implemented according to this documentation should be tested with final
operating system software.

Learn more about using Apple's beta software

Type Method

# open(url:)

Presents a continuation sheet that enables people to choose whether your app
shows the indicated URL link for external purchases.

iOS 17.5+ Beta iPadOS 17.5+ Beta macOS 14.5+ Beta Mac Catalyst 17.5+ Beta tvOS
17.5+ Beta watchOS 10.5+ Beta visionOS 1.2+ Beta Xcode 15.3+

    
    
    static func open(url: URL) async throws

##  Parameters

`url`

    

An eligible external purchase link that you select from the `eligibleURLs`
array.

## Discussion

Call this method if your app configures the `SKExternalPurchaseMultiLink`
property list key to attempt to open the eligible external purchase link,
`url`. Call this asynchronous method as shown below:

To use this method, follow these steps:

  1. Check the `eligibleURLs` array. If the array contains one or more links, your app can display the user-interface controls to enable deliberate user interaction before offering an external purchase link. 

  2. Select one of the eligible links.

  3. In response to deliberate user interaction, such as tapping a button, call `open(url:)` with the link you select. 

The system displays the continuation sheet that enables the user to choose
whether to continue to view the external purchase link. This asynchronous
method returns before the system presents the continuation sheet, and can
throw an error.

If the person chooses to continue, this method opens the link that you provide
in the `url` parameter, and appends an external purchase token and the app’s
bundleID to the URL. For example, StoreKit opens the following link on the
default browser if your destination URL is `https://site.example.com`:

    
    
    https://site.example.com?externalPurchaseToken=ewoJImFwcEFwcGxlSWQiOjEyMzQ1Njc4OTAsCgkiYnVuZGxlSWQiOiJjb20uZXhhbXBsZSIsCgkidG9rZW5DcmVhdGlvbkRhdGUiOjE3MDYxNjk2MDAwMDAsCgkiZXh0ZXJuYWxQdXJjaGFzZUlkIjoiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwIgp9&bundleId=com.example
    

Important

Record and use the external purchase token to report the customer’s external
purchases to Apple. For more information, see External Purchase Server API.

### Handle errors

This method throws a `StoreKitError` if any of the following are true:

  * Your app doesn’t have the `com.apple.developer.storekit.external-purchase-link` entitlement.

  * You haven’t configured external purchase links for the current App Store storefront in the `SKExternalPurchaseMultiLink` property list key.

  * The current App Store storefront doesn’t support external purchases.

  * The person is ineligible to make external purchases.

  * A network or system error occurs.

For more information about App Store storefronts, see `Storefront`.

## See Also

### Getting multiple external purchase links

`property list key SKExternalPurchaseMultiLink`

A dictionary that contains an array of URLs to websites where people using
your app can make external purchases.

Beta

`static var eligibleURLs: [URL]?`

An array of external purchase links for the current storefront that the app
configured and from which it chooses.

Beta Software

This documentation contains preliminary information about an API or technology
in development. This information is subject to change, and software
implemented according to this documentation should be tested with final
operating system software.

Learn more about using Apple's beta software

Property List Key

# SKExternalPurchaseLink

A dictionary that contains URLs to websites where people using your app can
make external purchases, for supported regions.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.0+

##  Details

Type

    

dictionary

## Properties

`Any Key`

`string`

A dictionary with a key that is the lowercased ISO 3166-1 alpha-2 country
code, and a string that contains a valid destination URL.

Valid country codes include those for the European Union: Austria (`at`),
Belgium (`be`), Bulgaria (`bg`), Croatia (`hr`), Cyprus (`cy`), Czechia
(`cz`), Denmark (`dk`), Estonia (`ee`), Finland (`fi`), France (`fr`), Germany
(`de`), Greece (`gr`), Hungary (`hu`), Ireland (`ie`), Italy (`it`), Latvia
(`lv`), Lithuania (`lt`), Luxembourg (`lu`), Malta (`mt`), Netherlands (`nl`),
Poland (`pl`), Portugal (`pt`), Romania (`ro`), Slovakia (`sk`), Slovenia
(`si`), Spain (`es`), Sweden (`se`); and Iceland (`is`), Norway (`no`), Russia
(`ru`), and United States (`us`).

## Discussion

Use this information property list key if your app has the
`com.apple.developer.storekit.external-purchase-link` entitlement and your app
has a minimum OS version prior to iOS 17.5, macOS 14.5, watchOS 10.5, tvOS
17.5, or visionOS 1.2. Otherwise, use the `SKExternalPurchaseMultiLink`
property list key to provide multiple URLs for country codes that allow
multiple links.

Include one key entry for each country code where your app supports an
external purchase link. Provide a destination URL (link to your website) for
your app to open when the country code in the key matches the device’s App
Store storefront. If you support multiple country codes, you may provide the
same or different destination URLs for each country code.

Important

At all times, the destination URLs that you provide in the property list key
must match the values in your app binary that you submit to App Review.

Make sure the destination URL meets all of the following conditions:

  * Uses the HTTPS scheme

  * Forms a valid, absolute URL

  * Contains no query parameters

  * Contains 1,000 or fewer ASCII characters.

The following code example shows a property list entry with a single country
code key, for the Netherlands (`nl`). Replace the string
"`https://example.com`" below with your link:

    
    
    <plist>
    <dict>
        <key>SKExternalPurchaseLink</key>
        <dict>
            <key>nl</key>
            <string>https://example.com</string>
        </dict>
    </dict>
    </plist>
    

The following code example shows a property list entry with keys for more than
one country code. Replace the “`https://example.com`“ strings with your links:

    
    
    <plist>
    <dict>
        <key>SKExternalPurchaseLink</key>
        <dict>
            <key>at</key>
            <string>https://ex1.example.com</string>
            <key>nl</key>
            <string>https://ex2.example.com</string>
            <key>it</key>
            <string>https://ex2.example.com</string>
        </dict>
    </dict>
    </plist>
    

For more information, see External Purchase.

## See Also

### Offering external purchase links

`enum ExternalPurchaseLink`

Enables qualifying apps to offer external purchase links.

`com.apple.developer.storekit.external-purchase-link`

A Boolean value that indicates whether your app can include a link that
directs people to a website to make an external purchase.

`property list key SKExternalPurchaseMultiLink`

A dictionary that contains an array of URLs to websites where people using
your app can make external purchases.

Beta

Type Property

# canOpen

A Boolean value that indicates whether the app can successfully open the
configured external purchase link in the current App Store storefront.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 13.3+

    
    
    static var canOpen: Bool { get async }

## Discussion

Use this method if your app configures the `SKExternalPurchaseLink` property
list key.

Check this property, as shown below, to determine whether your app can
successfully call `open()`.

If the result is `true`, configure any user-interface controls that enable
people to open the external purchase link. You configure that link in the
`SKExternalPurchaseLink` property list key in the `Info.plist` file. There’s
no need to call `canOpen` again, unless the App Store storefront changes. For
more information about the App Store storefront, see `Storefront`.

This property is `true` if all the following conditions are met:

  * The current App Store storefront allows external purchase and the person is eligible to make external purchases.

  * Your app configures the `com.apple.developer.storekit.external-purchase-link` entitlement.

  * Your app configures a link for the current App Store storefront in `SKExternalPurchaseLink`.

Otherwise, this property is `false`.

When this property is `false`, check `canMakePayments` to determine whether
your app can offer in-app purchases using the StoreKit In-App Purchase APIs.
For more information, see `canMakePayments`.

## See Also

### Getting a single external purchase link

`property list key SKExternalPurchaseLink`

A dictionary that contains URLs to websites where people using your app can
make external purchases, for supported regions.

`static func open()`

Presents a continuation sheet that enables people to choose whether your app
shows its link for external purchases.

Type Method

# open()

Presents a continuation sheet that enables people to choose whether your app
shows its link for external purchases.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 13.3+

    
    
    static func open() async throws

## Discussion

Use this method if your app configures the `SKExternalPurchaseLink` property
list key.

Call this asynchronous method to have the system attempt to open the external
purchase link, as shown below:

To use this method, follow these steps:

  1. Call `canOpen` to determine whether to display a button or other user-interface controls that enable you to call `open()`. If it returns `true`, your app can display the user-interface controls to enable deliberate user interaction.

  2. In response to deliberate user interaction, such as tapping a button, call `open()`. The system displays the continuation sheet that enables the user to choose whether to continue to view your app’s external purchase URL. This asynchronous method returns before the system presents the continuation sheet, and throws an error if `canOpen` is `false`.

If the person chooses to continue, this method opens the current storefront’s
destination URL that you configure in the `SKExternalPurchaseLink` property
list key and appends an external purchase token and the app's bundleID to the
URL. For example, StoreKit opens the following URL on the default browser if
your destination URL is `https://site.example.com`:

    
    
    https://site.example.com?externalPurchaseToken=ewoJImFwcEFwcGxlSWQiOjEyMzQ1Njc4OTAsCgkiYnVuZGxlSWQiOiJjb20uZXhhbXBsZSIsCgkidG9rZW5DcmVhdGlvbkRhdGUiOjE3MDYxNjk2MDAwMDAsCgkiZXh0ZXJuYWxQdXJjaGFzZUlkIjoiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwIgp9&bundleId=com.example
    
    
    

Important

Record and use the external purchase token to report the customer’s external
purchases to Apple. For more information, see External Purchase Server API.

### Handle errors

This method throws a `StoreKitError` if any of the following are true:

  * Your app doesn’t have the `com.apple.developer.storekit.external-purchase-link` entitlement.

  * You haven’t configured external purchases for the current App Store storefront in `SKExternalPurchaseLink`.

  * The current App Store storefront doesn’t support external purchases.

  * The person is ineligible to make external purchases.

  * A network or system error occurs.

For more information about App Store storefronts, see `Storefront`.

## See Also

### Getting a single external purchase link

`property list key SKExternalPurchaseLink`

A dictionary that contains URLs to websites where people using your app can
make external purchases, for supported regions.

`static var canOpen: Bool`

A Boolean value that indicates whether the app can successfully open the
configured external purchase link in the current App Store storefront.



# SKStoreProductViewController

Instance Property

# delegate

The store view controller’s delegate.

iOS 6.0+  iPadOS 6.0+  macOS 11.0+  Mac Catalyst 13.0+

    
    
    weak var delegate: (any SKStoreProductViewControllerDelegate)? { get set }

## Discussion

Your application must set the delegate before presenting the store view
controller.

## See Also

### Setting a delegate

`protocol SKStoreProductViewControllerDelegate`

A protocol called when the user dismisses the store screen.

### Related Documentation

In-App Purchase Programming Guide

Instance Method

# loadProduct(withParameters:completionBlock:)

Loads a new product screen to display.

iOS 6.0+  iPadOS 6.0+  macOS 11.0+  Mac Catalyst 13.0+

    
    
    func loadProduct(
        withParameters parameters: [String : Any],
        completionBlock block: ((Bool, (any Error)?) -> Void)? = nil
    )

##  Parameters

`parameters`

    

A dictionary describing the content you want the view controller to display.
See Product Dictionary Keys for keys that describe the product. See Ad network
install-validation keys for keys that describe an impression in an advertising
campaign.

`block`

    

A block to be called when the product information has been loaded from the App
Store. The completion block is called on the main thread and receives the
following parameters:

`result`

    

`true` if the product information was successfully loaded, otherwise `false`.

`error`

    

If an error occurred, this object describes the error. If the product
information was successfully loaded, this value is `nil`.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

For a seamless user experience, load the product information before presenting
the `SKStoreProductViewController` view controller. However, if you load the
product information while presenting the view controller, once loaded, the
product data replaces the contents of the view controller.

## See Also

### Loading a new product screen

Offering media for sale in your app

Allow users to purchase media in the App Store from within your app.

`func loadProduct(withParameters: [String : Any], impression: SKAdImpression,
completionBlock: ((Bool, (any Error)?) -> Void)?)`

API Reference

Product Dictionary Keys

Keys for identifying products and the tokens for affiliates and campaigns.

Instance Method

# loadProduct(withParameters:impression:completionBlock:)

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+

    
    
    func loadProduct(
        withParameters parameters: [String : Any],
        impression: SKAdImpression,
        completionBlock block: ((Bool, (any Error)?) -> Void)? = nil
    )

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

## See Also

### Loading a new product screen

Offering media for sale in your app

Allow users to purchase media in the App Store from within your app.

`func loadProduct(withParameters: [String : Any], completionBlock: ((Bool,
(any Error)?) -> Void)?)`

Loads a new product screen to display.

API Reference

Product Dictionary Keys

Keys for identifying products and the tokens for affiliates and campaigns.

Instance Method

# loadProduct(parameters:impression:)

AdAttributionKit  StoreKit  iOS 17.4+  iPadOS 17.4+  Xcode 15.3+

    
    
    @MainActor
    func loadProduct(
        parameters: [String : Any],
        impression: AppImpression
    ) async throws



# ProductViewStyleConfiguration

Instance Property

# product

The in-app purchase product to merchandise.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var product: Product? { get }

## See Also

### Getting a product's information

`let state: Product.TaskState`

The product task state that indicates the product’s loading phase.

`let hasCurrentEntitlement: Bool`

A Boolean value that indicates whether an in-app purchase transaction exists
for the product.

Instance Property

# state

The product task state that indicates the product’s loading phase.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    let state: Product.TaskState

## See Also

### Getting a product's information

`var product: Product?`

The in-app purchase product to merchandise.

`let hasCurrentEntitlement: Bool`

A Boolean value that indicates whether an in-app purchase transaction exists
for the product.

Instance Property

# hasCurrentEntitlement

A Boolean value that indicates whether an in-app purchase transaction exists
for the product.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    let hasCurrentEntitlement: Bool

## Discussion

Use the `hasCurrentEntitlement` property to determine whether a purchase may
succeed, for a porduct that people can purchase only once. For example, if
hasCurrentEntitlement is false, you may choose not to display a purchase
button for the product, because the person has already purchased it.

Important

Don’t use this value to determine whether to enable access to the product;
check the in-app purchase transaction information instead (`Transaction`).

## See Also

### Getting a product's information

`var product: Product?`

The in-app purchase product to merchandise.

`let state: Product.TaskState`

The product task state that indicates the product’s loading phase.

Instance Property

# icon

A decorative view for merchandising the product.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    let icon: ProductViewStyleConfiguration.Icon

## See Also

### Getting a product view's icon

`struct ProductViewStyleConfiguration.Icon`

A type-erased icon of an in-app purchase product.

Instance Method

# purchase()

Initiates a purchase action for the product.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func purchase()

## Discussion

Use this method instead of calling `purchase(options:)`directly on the
product.

Instance Property

# descriptionVisibility

StoreKit  SwiftUI  iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+
tvOS 17.4+  watchOS 10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    let descriptionVisibility: Visibility



# Message

Type Property

# messages

The asynchronous sequence that sends a message when the App Store creates it.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static var messages: Message.Messages { get }

## Discussion

If your app doesn’t implement this message listener, StoreKit retrieves any
messages from the App Store each time your app launches, and presents them by
default.

For more information about listening for and displaying messages, see
`Message`.

## See Also

### Getting messages and message reasons

`let reason: Message.Reason`

The reason that the App Store sends the message.

`struct Message.Messages`

An asynchronous sequence of messages from the App Store.

`struct Message.Reason`

Reasons for the App Store messages.

Instance Property

# reason

The reason that the App Store sends the message.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let reason: Message.Reason

## See Also

### Getting messages and message reasons

`static var messages: Message.Messages`

The asynchronous sequence that sends a message when the App Store creates it.

`struct Message.Messages`

An asynchronous sequence of messages from the App Store.

`struct Message.Reason`

Reasons for the App Store messages.

Instance Method

# display(in:)

Requests the system to display the App Store message in the window scene.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    @MainActor
    func display(in scene: UIWindowScene) throws

##  Parameters

`scene`

    

The `UIWindowScene` that StoreKit uses to display the App Store message.

## Discussion

The system displays the message if the message is applicable; for example, if
the user has previously seen the same App Store message, the system may
determine whether to display the message again.

Note

If your app uses SwiftUI views, use `DisplayMessageAction` instead of
`display(in:)`.

For more information about using `display(in:)`, see `Message`.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: Message, rhs: Message) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing messages

`static func == (Message, Message) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func == (lhs: Message, rhs: Message) -> Bool

## See Also

### Comparing and hashing messages

`static func != (Message, Message) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing messages

`static func != (Message, Message) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Message, Message) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing messages

`static func != (Message, Message) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Message, Message) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# Product.SubscriptionInfo.RenewalInfo

Instance Property

# environment

The server environment that signs the renewal information for an auto-
renewable subscription.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let environment: AppStore.Environment

## See Also

### Getting the environment

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

The string representation of the server environment that signs the renewal
information for an auto-renewable subscription.

Deprecated

Instance Property

# environmentStringRepresentation

The string representation of the server environment that signs the renewal
information for an auto-renewable subscription.

iOS 15.0–16.0  Deprecated  iPadOS 15.0–16.0  Deprecated  macOS 12.0–13.0
Deprecated  Mac Catalyst 16.0–16.0  Deprecated  tvOS 15.0–16.0  Deprecated
watchOS 8.0–9.0  Deprecated  Xcode 13.0–14.0  Deprecated

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var environmentStringRepresentation: String { get }

## See Also

### Getting the environment

`let environment: AppStore.Environment`

The server environment that signs the renewal information for an auto-
renewable subscription.

Instance Property

# originalTransactionID

The transaction identifier of the original purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let originalTransactionID: UInt64

Instance Property

# currentProductID

The subscription product ID that the customer is subscribed to.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let currentProductID: String

Instance Property

# offerID

A string that identifies an offer applied to the next subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let offerID: String?

## Discussion

This value is `nil` if there isn’t an offer, or if the offer type is
`introductory`.

If the offer type is `promotional`, this value contains the promotional offer
identifier you set up in App Store Connect. For more information about
promotional offers, see Set up promotional offers for auto-renewable
subscriptions.

If the offer type is `code`, this value contains the reference name of the
offer code you set up in App Store Connect. For more information about offer
codes, see Set up offer codes.

## See Also

### Getting subscription offers

`let offerType: Transaction.OfferType?`

The subscription offer type for the next subscription period.

Instance Property

# offerType

The subscription offer type for the next subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let offerType: Transaction.OfferType?

## Discussion

If this value is `nil`, there’s no offer applied.

## See Also

### Getting subscription offers

`let offerID: String?`

A string that identifies an offer applied to the next subscription period.

Instance Property

# recentSubscriptionStartDate

The earliest start date of a subscription in a series of auto-renewable
subscription purchases that ignores all lapses of paid service shorter than 60
days.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 14.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var recentSubscriptionStartDate: Date { get }

## Discussion

Important

Don’t use the `recentSubscriptionStartDate` date to calculate days of paid
service. For more information about paid days of service, see Net revenue
after a year.

Instance Property

# state

The renewal state of the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let state: Product.SubscriptionInfo.RenewalState

## See Also

### Getting subscription status information

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# autoRenewPreference

The product ID of the auto-renewable subscription that will automatically
renew.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let autoRenewPreference: String?

## Discussion

This value is the product ID of the auto-renewable subscription that will
renew after the current period expires. The value may be:

  * The same as `currentProductID` if the subscription will renew with the same product.

  * Another product ID value if the subscription will renew to a different product.

  * `nil` if the subscription won’t renew in the next period. This may occur for several reasons, including when the person disables auto-renew for the subscription, the subscription lapses due to a billing issue, or you increase the subscription price and the person doesn't accept the increase.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# willAutoRenew

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let willAutoRenew: Bool

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# expirationReason

The reason the auto-renewable subscription expired.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?

## Discussion

This optional value is `nil` if the auto-renewable subscription is active and
hasn’t expired.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# renewalDate

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 17.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0)
    var renewalDate: Date? { get }

## Discussion

The `renewalDate` is a value that’s always present for auto-renewable
subscriptions, even for expired subscriptions. This date indicates the
expiration date of the most recent auto-renewable subscription purchase,
including renewals, and may be in the past. For subscriptions that renew
successfully, the `renewalDate` is the date when the subscription renews.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

Instance Property

# isInBillingRetry

A Boolean value that indicates whether an auto-renewable subscription is in
the billing retry period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let isInBillingRetry: Bool

## Discussion

This field indicates whether Apple is attempting to automatically renew an
expired subscription. If a subscription expires due to a billing issue, a
value of `true` indicates that Apple is still trying to renew the
subscription. If the subscription is in a billing grace period, the optional
`gracePeriodExpirationDate` contains a date.

Use the `isInBillingRetry` value along with `expirationReason` for more
insight, as the following table shows:

Values| Description  
---|---  
`isInBillingRetry` is `false,` `expirationReason` is `nil`| The auto-renewable
subscription is active and not in a billing retry period. The subscription is
entitled to service.  
`isInBillingRetry` is `true,``expirationReason` is
`billingError`,`gracePeriodExpirationDate` has a date| The auto-renewable
subscription is in a billing grace period. The subscription is entitled to
service until the date in `gracePeriodExpirationDate`.  
`isInBillingRetry` is `true,``expirationReason` is
`billingError`,`gracePeriodExpirationDate` is `nil`| The auto-renewable
subscription is in a billing retry period. The subscription is not entitled to
service.  
`isInBillingRetry` is `false,` `expirationReason` is `billingError`| The auto-
renewable subscription expired and billing retry wasn’t able to recover the
subscription.The subscription is not entitled to service.  
  
## See Also

### Getting billing status

`let gracePeriodExpirationDate: Date?`

The date the billing grace period expires for the auto-renewable subscription.

Instance Property

# gracePeriodExpirationDate

The date the billing grace period expires for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let gracePeriodExpirationDate: Date?

## Discussion

This value is `nil` if the subscription is not in a billing grace period.

This date is present if you enable Billing Grace Period for your app and the
subscription is in the billing grace period. Ensure that your app provides
full service for the subscription throughout the grace period, which ends on
the `gracePeriodExpirationDate`.

A billing grace period occurs at the start of a billing retry state.
Throughout the billing grace period, the value of `isInBillingRetry` is
`true`, which indicates that Apple is attempting to automatically renew the
subscription.

For information about supporting Billing Grace Period, see Enable Billing
Grace Period for auto-renewable subscriptions and Reducing Involuntary
Subscriber Churn.

## See Also

### Getting billing status

`let isInBillingRetry: Bool`

A Boolean value that indicates whether an auto-renewable subscription is in
the billing retry period.

Article

# Managing Price Increases for Auto-Renewable Subscriptions

Identify the price increase status for auto-renewable subscriptions, in your
app and on your server.

## Overview

If you increase the price of an auto-renewable subscription in App Store
Connect, the `priceIncreaseStatus` in the `renewalInfo` object indicates if
the subscription is subject to the price increase. Auto-renewable
subscriptions have two types of price increases: those that require customer
consent, and those that don’t require customer consent.

For price increases that require customer consent, look for the following
status values in your app:

`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending`|
Indicates there’s no price increase for this auto-renewable subscription.  
---|---  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending`| Indicates
there’s a pending price increase for the auto-renewable subscription that
requires customer consent, and the customer hasn’t yet consented. If the
customer doesn’t consent, the auto-renewable subscription expires at the end
of the billing cycle. When it expires, your app gets a status update in
`updates` with an `expirationReason` of `didNotConsentToPriceIncrease`.  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed`| Indicates
that the customer consented to a price increase for the auto-renewable
subscription.  
  
For price increases that don’t require customer consent, look for the
following status values in your app:

`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending`|
Doesn’t apply.  
---|---  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending`| Doesn’t
apply.  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed`| Indicates
that the App Store informed the customer of the price increase for the auto-
renewable subscription, and the subscription is subject to the price
increase.If the customer cancels the auto-renewable subscription, your app
gets a status update in `updates` with an `expirationReason` of
`autoRenewDisabled`.  
  
For more information about managing subscription prices in App Store Connect,
see Managing Prices.

### Receive Notifications for Price Increase Status Events

If you’ve enabled App Store Server Notifications V2, your server receives
notifications for events related to auto-renewable subscription price
increases.

For auto-renewable subscription price increases that require customer consent,
look for the following notifications:

Notification type| Subtype| Description  
---|---|---  
`PRICE_INCREASE` | `PENDING`| Indicates that the App Store informed the customer of the price increase for the auto-renewable subscription, and the customer hasn’t yet responded.  
`PRICE_INCREASE`| `ACCEPTED`| Indicates that the customer consented to the
price increase for the auto-renewable subscription.  
`EXPIRED`| `PRICE_INCREASE`| Indicates that the auto-renewable subscription
expired because the customer didn’t consent to the price increase, and allowed
the subscription to expire.  
`EXPIRED`| `VOLUNTARY`| Indicates that the customer voluntarily canceled the
auto-renewable subscription. (Note: This notification type and subtype isn’t
specific to price increases.)  
  
For auto-renewable subscription price increases that don’t require customer
consent, look for the following notifications:

Notification type| Subtype| Description  
---|---|---  
`PRICE_INCREASE`| `ACCEPTED`| Indicates that the App Store informed the
customer of the auto-renewable subscription price increase, and the
subscription is subject to the price increase.  
`EXPIRED` | `VOLUNTARY`| Indicates that the customer voluntarily canceled the auto-renewable subscription. (Note: This notification type and subtype isn't specific to price increases.)  
  
For more information about App Store Server Notifications, see Enabling App
Store Server Notifications. For more information about notification types and
subtypes, see `notificationType` and `subtype`.

## See Also

### Getting the price increase status

`let priceIncreaseStatus:
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

The status that indicates whether the auto-renewable subscription is subject
to a price increase.

`enum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

Status values that indicate whether an auto-renewable subscription is subject
to a price increase.

Instance Property

# priceIncreaseStatus

The status that indicates whether the auto-renewable subscription is subject
to a price increase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let priceIncreaseStatus: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus

## Discussion

For more information about price increase status, see Managing Price Increases
for Auto-Renewable Subscriptions.

## See Also

### Getting the price increase status

Managing Price Increases for Auto-Renewable Subscriptions

Identify the price increase status for auto-renewable subscriptions, in your
app and on your server.

`enum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

Status values that indicate whether an auto-renewable subscription is subject
to a price increase.

Instance Property

# deviceVerification

The device verification value to use to verify whether the renewal information
belongs to the device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerification: Data

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying subscription renewal information

`let deviceVerificationNonce: UUID`

The UUID to use to compute the device verification value.

`let signedDate: Date`

The date that the App Store signed the JWS renewal information.

Instance Property

# deviceVerificationNonce

The UUID to use to compute the device verification value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerificationNonce: UUID

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying subscription renewal information

`let deviceVerification: Data`

The device verification value to use to verify whether the renewal information
belongs to the device.

`let signedDate: Date`

The date that the App Store signed the JWS renewal information.

Instance Property

# signedDate

The date that the App Store signed the JWS renewal information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let signedDate: Date

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the
transaction was valid when the App Store signed the transaction.

## See Also

### Verifying subscription renewal information

`let deviceVerification: Data`

The device verification value to use to verify whether the renewal information
belongs to the device.

`let deviceVerificationNonce: UUID`

The UUID to use to compute the device verification value.

Instance Property

# jsonRepresentation

The raw JSON representation of the subscription renewal information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var jsonRepresentation: Data { get }

## Discussion

The information in `jsonRepresentation` is the same information that’s in the
properties of the same instance of `Product.SubscriptionInfo.RenewalInfo`.

Instance Property

# debugDescription

A string representation of the renewal info, suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo, rhs: Product.SubscriptionInfo.RenewalInfo) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing renewal information

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (lhs: Product.SubscriptionInfo.RenewalInfo, rhs: Product.SubscriptionInfo.RenewalInfo) -> Bool

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Instance Property

# environment

The server environment that signs the renewal information for an auto-
renewable subscription.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let environment: AppStore.Environment

## See Also

### Getting the environment

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

The string representation of the server environment that signs the renewal
information for an auto-renewable subscription.

Deprecated

Instance Property

# environmentStringRepresentation

The string representation of the server environment that signs the renewal
information for an auto-renewable subscription.

iOS 15.0–16.0  Deprecated  iPadOS 15.0–16.0  Deprecated  macOS 12.0–13.0
Deprecated  Mac Catalyst 16.0–16.0  Deprecated  tvOS 15.0–16.0  Deprecated
watchOS 8.0–9.0  Deprecated  Xcode 13.0–14.0  Deprecated

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var environmentStringRepresentation: String { get }

## See Also

### Getting the environment

`let environment: AppStore.Environment`

The server environment that signs the renewal information for an auto-
renewable subscription.

Instance Property

# originalTransactionID

The transaction identifier of the original purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let originalTransactionID: UInt64

Instance Property

# currentProductID

The subscription product ID that the customer is subscribed to.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let currentProductID: String

Instance Property

# offerID

A string that identifies an offer applied to the next subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let offerID: String?

## Discussion

This value is `nil` if there isn’t an offer, or if the offer type is
`introductory`.

If the offer type is `promotional`, this value contains the promotional offer
identifier you set up in App Store Connect. For more information about
promotional offers, see Set up promotional offers for auto-renewable
subscriptions.

If the offer type is `code`, this value contains the reference name of the
offer code you set up in App Store Connect. For more information about offer
codes, see Set up offer codes.

## See Also

### Getting subscription offers

`let offerType: Transaction.OfferType?`

The subscription offer type for the next subscription period.

Instance Property

# offerType

The subscription offer type for the next subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let offerType: Transaction.OfferType?

## Discussion

If this value is `nil`, there’s no offer applied.

## See Also

### Getting subscription offers

`let offerID: String?`

A string that identifies an offer applied to the next subscription period.

Instance Property

# recentSubscriptionStartDate

The earliest start date of a subscription in a series of auto-renewable
subscription purchases that ignores all lapses of paid service shorter than 60
days.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 14.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var recentSubscriptionStartDate: Date { get }

## Discussion

Important

Don’t use the `recentSubscriptionStartDate` date to calculate days of paid
service. For more information about paid days of service, see Net revenue
after a year.

Instance Property

# state

The renewal state of the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let state: Product.SubscriptionInfo.RenewalState

## See Also

### Getting subscription status information

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# autoRenewPreference

The product ID of the auto-renewable subscription that will automatically
renew.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let autoRenewPreference: String?

## Discussion

This value is the product ID of the auto-renewable subscription that will
renew after the current period expires. The value may be:

  * The same as `currentProductID` if the subscription will renew with the same product.

  * Another product ID value if the subscription will renew to a different product.

  * `nil` if the subscription won’t renew in the next period. This may occur for several reasons, including when the person disables auto-renew for the subscription, the subscription lapses due to a billing issue, or you increase the subscription price and the person doesn't accept the increase.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# willAutoRenew

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let willAutoRenew: Bool

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# expirationReason

The reason the auto-renewable subscription expired.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?

## Discussion

This optional value is `nil` if the auto-renewable subscription is active and
hasn’t expired.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# renewalDate

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 17.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0)
    var renewalDate: Date? { get }

## Discussion

The `renewalDate` is a value that’s always present for auto-renewable
subscriptions, even for expired subscriptions. This date indicates the
expiration date of the most recent auto-renewable subscription purchase,
including renewals, and may be in the past. For subscriptions that renew
successfully, the `renewalDate` is the date when the subscription renews.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

Instance Property

# isInBillingRetry

A Boolean value that indicates whether an auto-renewable subscription is in
the billing retry period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let isInBillingRetry: Bool

## Discussion

This field indicates whether Apple is attempting to automatically renew an
expired subscription. If a subscription expires due to a billing issue, a
value of `true` indicates that Apple is still trying to renew the
subscription. If the subscription is in a billing grace period, the optional
`gracePeriodExpirationDate` contains a date.

Use the `isInBillingRetry` value along with `expirationReason` for more
insight, as the following table shows:

Values| Description  
---|---  
`isInBillingRetry` is `false,` `expirationReason` is `nil`| The auto-renewable
subscription is active and not in a billing retry period. The subscription is
entitled to service.  
`isInBillingRetry` is `true,``expirationReason` is
`billingError`,`gracePeriodExpirationDate` has a date| The auto-renewable
subscription is in a billing grace period. The subscription is entitled to
service until the date in `gracePeriodExpirationDate`.  
`isInBillingRetry` is `true,``expirationReason` is
`billingError`,`gracePeriodExpirationDate` is `nil`| The auto-renewable
subscription is in a billing retry period. The subscription is not entitled to
service.  
`isInBillingRetry` is `false,` `expirationReason` is `billingError`| The auto-
renewable subscription expired and billing retry wasn’t able to recover the
subscription.The subscription is not entitled to service.  
  
## See Also

### Getting billing status

`let gracePeriodExpirationDate: Date?`

The date the billing grace period expires for the auto-renewable subscription.

Instance Property

# gracePeriodExpirationDate

The date the billing grace period expires for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let gracePeriodExpirationDate: Date?

## Discussion

This value is `nil` if the subscription is not in a billing grace period.

This date is present if you enable Billing Grace Period for your app and the
subscription is in the billing grace period. Ensure that your app provides
full service for the subscription throughout the grace period, which ends on
the `gracePeriodExpirationDate`.

A billing grace period occurs at the start of a billing retry state.
Throughout the billing grace period, the value of `isInBillingRetry` is
`true`, which indicates that Apple is attempting to automatically renew the
subscription.

For information about supporting Billing Grace Period, see Enable Billing
Grace Period for auto-renewable subscriptions and Reducing Involuntary
Subscriber Churn.

## See Also

### Getting billing status

`let isInBillingRetry: Bool`

A Boolean value that indicates whether an auto-renewable subscription is in
the billing retry period.

Article

# Managing Price Increases for Auto-Renewable Subscriptions

Identify the price increase status for auto-renewable subscriptions, in your
app and on your server.

## Overview

If you increase the price of an auto-renewable subscription in App Store
Connect, the `priceIncreaseStatus` in the `renewalInfo` object indicates if
the subscription is subject to the price increase. Auto-renewable
subscriptions have two types of price increases: those that require customer
consent, and those that don’t require customer consent.

For price increases that require customer consent, look for the following
status values in your app:

`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending`|
Indicates there’s no price increase for this auto-renewable subscription.  
---|---  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending`| Indicates
there’s a pending price increase for the auto-renewable subscription that
requires customer consent, and the customer hasn’t yet consented. If the
customer doesn’t consent, the auto-renewable subscription expires at the end
of the billing cycle. When it expires, your app gets a status update in
`updates` with an `expirationReason` of `didNotConsentToPriceIncrease`.  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed`| Indicates
that the customer consented to a price increase for the auto-renewable
subscription.  
  
For price increases that don’t require customer consent, look for the
following status values in your app:

`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending`|
Doesn’t apply.  
---|---  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending`| Doesn’t
apply.  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed`| Indicates
that the App Store informed the customer of the price increase for the auto-
renewable subscription, and the subscription is subject to the price
increase.If the customer cancels the auto-renewable subscription, your app
gets a status update in `updates` with an `expirationReason` of
`autoRenewDisabled`.  
  
For more information about managing subscription prices in App Store Connect,
see Managing Prices.

### Receive Notifications for Price Increase Status Events

If you’ve enabled App Store Server Notifications V2, your server receives
notifications for events related to auto-renewable subscription price
increases.

For auto-renewable subscription price increases that require customer consent,
look for the following notifications:

Notification type| Subtype| Description  
---|---|---  
`PRICE_INCREASE` | `PENDING`| Indicates that the App Store informed the customer of the price increase for the auto-renewable subscription, and the customer hasn’t yet responded.  
`PRICE_INCREASE`| `ACCEPTED`| Indicates that the customer consented to the
price increase for the auto-renewable subscription.  
`EXPIRED`| `PRICE_INCREASE`| Indicates that the auto-renewable subscription
expired because the customer didn’t consent to the price increase, and allowed
the subscription to expire.  
`EXPIRED`| `VOLUNTARY`| Indicates that the customer voluntarily canceled the
auto-renewable subscription. (Note: This notification type and subtype isn’t
specific to price increases.)  
  
For auto-renewable subscription price increases that don’t require customer
consent, look for the following notifications:

Notification type| Subtype| Description  
---|---|---  
`PRICE_INCREASE`| `ACCEPTED`| Indicates that the App Store informed the
customer of the auto-renewable subscription price increase, and the
subscription is subject to the price increase.  
`EXPIRED` | `VOLUNTARY`| Indicates that the customer voluntarily canceled the auto-renewable subscription. (Note: This notification type and subtype isn't specific to price increases.)  
  
For more information about App Store Server Notifications, see Enabling App
Store Server Notifications. For more information about notification types and
subtypes, see `notificationType` and `subtype`.

## See Also

### Getting the price increase status

`let priceIncreaseStatus:
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

The status that indicates whether the auto-renewable subscription is subject
to a price increase.

`enum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

Status values that indicate whether an auto-renewable subscription is subject
to a price increase.

Instance Property

# priceIncreaseStatus

The status that indicates whether the auto-renewable subscription is subject
to a price increase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let priceIncreaseStatus: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus

## Discussion

For more information about price increase status, see Managing Price Increases
for Auto-Renewable Subscriptions.

## See Also

### Getting the price increase status

Managing Price Increases for Auto-Renewable Subscriptions

Identify the price increase status for auto-renewable subscriptions, in your
app and on your server.

`enum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

Status values that indicate whether an auto-renewable subscription is subject
to a price increase.

Instance Property

# deviceVerification

The device verification value to use to verify whether the renewal information
belongs to the device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerification: Data

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying subscription renewal information

`let deviceVerificationNonce: UUID`

The UUID to use to compute the device verification value.

`let signedDate: Date`

The date that the App Store signed the JWS renewal information.

Instance Property

# deviceVerificationNonce

The UUID to use to compute the device verification value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerificationNonce: UUID

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying subscription renewal information

`let deviceVerification: Data`

The device verification value to use to verify whether the renewal information
belongs to the device.

`let signedDate: Date`

The date that the App Store signed the JWS renewal information.

Instance Property

# signedDate

The date that the App Store signed the JWS renewal information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let signedDate: Date

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the
transaction was valid when the App Store signed the transaction.

## See Also

### Verifying subscription renewal information

`let deviceVerification: Data`

The device verification value to use to verify whether the renewal information
belongs to the device.

`let deviceVerificationNonce: UUID`

The UUID to use to compute the device verification value.

Instance Property

# jsonRepresentation

The raw JSON representation of the subscription renewal information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var jsonRepresentation: Data { get }

## Discussion

The information in `jsonRepresentation` is the same information that’s in the
properties of the same instance of `Product.SubscriptionInfo.RenewalInfo`.

Instance Property

# debugDescription

A string representation of the renewal info, suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo, rhs: Product.SubscriptionInfo.RenewalInfo) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing renewal information

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (lhs: Product.SubscriptionInfo.RenewalInfo, rhs: Product.SubscriptionInfo.RenewalInfo) -> Bool

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Instance Property

# environment

The server environment that signs the renewal information for an auto-
renewable subscription.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let environment: AppStore.Environment

## See Also

### Getting the environment

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

The string representation of the server environment that signs the renewal
information for an auto-renewable subscription.

Deprecated

Instance Property

# environmentStringRepresentation

The string representation of the server environment that signs the renewal
information for an auto-renewable subscription.

iOS 15.0–16.0  Deprecated  iPadOS 15.0–16.0  Deprecated  macOS 12.0–13.0
Deprecated  Mac Catalyst 16.0–16.0  Deprecated  tvOS 15.0–16.0  Deprecated
watchOS 8.0–9.0  Deprecated  Xcode 13.0–14.0  Deprecated

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var environmentStringRepresentation: String { get }

## See Also

### Getting the environment

`let environment: AppStore.Environment`

The server environment that signs the renewal information for an auto-
renewable subscription.

Instance Property

# originalTransactionID

The transaction identifier of the original purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let originalTransactionID: UInt64

Instance Property

# currentProductID

The subscription product ID that the customer is subscribed to.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let currentProductID: String

Instance Property

# offerID

A string that identifies an offer applied to the next subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let offerID: String?

## Discussion

This value is `nil` if there isn’t an offer, or if the offer type is
`introductory`.

If the offer type is `promotional`, this value contains the promotional offer
identifier you set up in App Store Connect. For more information about
promotional offers, see Set up promotional offers for auto-renewable
subscriptions.

If the offer type is `code`, this value contains the reference name of the
offer code you set up in App Store Connect. For more information about offer
codes, see Set up offer codes.

## See Also

### Getting subscription offers

`let offerType: Transaction.OfferType?`

The subscription offer type for the next subscription period.

Instance Property

# offerType

The subscription offer type for the next subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let offerType: Transaction.OfferType?

## Discussion

If this value is `nil`, there’s no offer applied.

## See Also

### Getting subscription offers

`let offerID: String?`

A string that identifies an offer applied to the next subscription period.

Instance Property

# recentSubscriptionStartDate

The earliest start date of a subscription in a series of auto-renewable
subscription purchases that ignores all lapses of paid service shorter than 60
days.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 14.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var recentSubscriptionStartDate: Date { get }

## Discussion

Important

Don’t use the `recentSubscriptionStartDate` date to calculate days of paid
service. For more information about paid days of service, see Net revenue
after a year.

Instance Property

# state

The renewal state of the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let state: Product.SubscriptionInfo.RenewalState

## See Also

### Getting subscription status information

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# autoRenewPreference

The product ID of the auto-renewable subscription that will automatically
renew.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let autoRenewPreference: String?

## Discussion

This value is the product ID of the auto-renewable subscription that will
renew after the current period expires. The value may be:

  * The same as `currentProductID` if the subscription will renew with the same product.

  * Another product ID value if the subscription will renew to a different product.

  * `nil` if the subscription won’t renew in the next period. This may occur for several reasons, including when the person disables auto-renew for the subscription, the subscription lapses due to a billing issue, or you increase the subscription price and the person doesn't accept the increase.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# willAutoRenew

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let willAutoRenew: Bool

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# expirationReason

The reason the auto-renewable subscription expired.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?

## Discussion

This optional value is `nil` if the auto-renewable subscription is active and
hasn’t expired.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# renewalDate

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 17.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0)
    var renewalDate: Date? { get }

## Discussion

The `renewalDate` is a value that’s always present for auto-renewable
subscriptions, even for expired subscriptions. This date indicates the
expiration date of the most recent auto-renewable subscription purchase,
including renewals, and may be in the past. For subscriptions that renew
successfully, the `renewalDate` is the date when the subscription renews.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

Instance Property

# isInBillingRetry

A Boolean value that indicates whether an auto-renewable subscription is in
the billing retry period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let isInBillingRetry: Bool

## Discussion

This field indicates whether Apple is attempting to automatically renew an
expired subscription. If a subscription expires due to a billing issue, a
value of `true` indicates that Apple is still trying to renew the
subscription. If the subscription is in a billing grace period, the optional
`gracePeriodExpirationDate` contains a date.

Use the `isInBillingRetry` value along with `expirationReason` for more
insight, as the following table shows:

Values| Description  
---|---  
`isInBillingRetry` is `false,` `expirationReason` is `nil`| The auto-renewable
subscription is active and not in a billing retry period. The subscription is
entitled to service.  
`isInBillingRetry` is `true,``expirationReason` is
`billingError`,`gracePeriodExpirationDate` has a date| The auto-renewable
subscription is in a billing grace period. The subscription is entitled to
service until the date in `gracePeriodExpirationDate`.  
`isInBillingRetry` is `true,``expirationReason` is
`billingError`,`gracePeriodExpirationDate` is `nil`| The auto-renewable
subscription is in a billing retry period. The subscription is not entitled to
service.  
`isInBillingRetry` is `false,` `expirationReason` is `billingError`| The auto-
renewable subscription expired and billing retry wasn’t able to recover the
subscription.The subscription is not entitled to service.  
  
## See Also

### Getting billing status

`let gracePeriodExpirationDate: Date?`

The date the billing grace period expires for the auto-renewable subscription.

Instance Property

# gracePeriodExpirationDate

The date the billing grace period expires for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let gracePeriodExpirationDate: Date?

## Discussion

This value is `nil` if the subscription is not in a billing grace period.

This date is present if you enable Billing Grace Period for your app and the
subscription is in the billing grace period. Ensure that your app provides
full service for the subscription throughout the grace period, which ends on
the `gracePeriodExpirationDate`.

A billing grace period occurs at the start of a billing retry state.
Throughout the billing grace period, the value of `isInBillingRetry` is
`true`, which indicates that Apple is attempting to automatically renew the
subscription.

For information about supporting Billing Grace Period, see Enable Billing
Grace Period for auto-renewable subscriptions and Reducing Involuntary
Subscriber Churn.

## See Also

### Getting billing status

`let isInBillingRetry: Bool`

A Boolean value that indicates whether an auto-renewable subscription is in
the billing retry period.

Article

# Managing Price Increases for Auto-Renewable Subscriptions

Identify the price increase status for auto-renewable subscriptions, in your
app and on your server.

## Overview

If you increase the price of an auto-renewable subscription in App Store
Connect, the `priceIncreaseStatus` in the `renewalInfo` object indicates if
the subscription is subject to the price increase. Auto-renewable
subscriptions have two types of price increases: those that require customer
consent, and those that don’t require customer consent.

For price increases that require customer consent, look for the following
status values in your app:

`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending`|
Indicates there’s no price increase for this auto-renewable subscription.  
---|---  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending`| Indicates
there’s a pending price increase for the auto-renewable subscription that
requires customer consent, and the customer hasn’t yet consented. If the
customer doesn’t consent, the auto-renewable subscription expires at the end
of the billing cycle. When it expires, your app gets a status update in
`updates` with an `expirationReason` of `didNotConsentToPriceIncrease`.  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed`| Indicates
that the customer consented to a price increase for the auto-renewable
subscription.  
  
For price increases that don’t require customer consent, look for the
following status values in your app:

`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending`|
Doesn’t apply.  
---|---  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending`| Doesn’t
apply.  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed`| Indicates
that the App Store informed the customer of the price increase for the auto-
renewable subscription, and the subscription is subject to the price
increase.If the customer cancels the auto-renewable subscription, your app
gets a status update in `updates` with an `expirationReason` of
`autoRenewDisabled`.  
  
For more information about managing subscription prices in App Store Connect,
see Managing Prices.

### Receive Notifications for Price Increase Status Events

If you’ve enabled App Store Server Notifications V2, your server receives
notifications for events related to auto-renewable subscription price
increases.

For auto-renewable subscription price increases that require customer consent,
look for the following notifications:

Notification type| Subtype| Description  
---|---|---  
`PRICE_INCREASE` | `PENDING`| Indicates that the App Store informed the customer of the price increase for the auto-renewable subscription, and the customer hasn’t yet responded.  
`PRICE_INCREASE`| `ACCEPTED`| Indicates that the customer consented to the
price increase for the auto-renewable subscription.  
`EXPIRED`| `PRICE_INCREASE`| Indicates that the auto-renewable subscription
expired because the customer didn’t consent to the price increase, and allowed
the subscription to expire.  
`EXPIRED`| `VOLUNTARY`| Indicates that the customer voluntarily canceled the
auto-renewable subscription. (Note: This notification type and subtype isn’t
specific to price increases.)  
  
For auto-renewable subscription price increases that don’t require customer
consent, look for the following notifications:

Notification type| Subtype| Description  
---|---|---  
`PRICE_INCREASE`| `ACCEPTED`| Indicates that the App Store informed the
customer of the auto-renewable subscription price increase, and the
subscription is subject to the price increase.  
`EXPIRED` | `VOLUNTARY`| Indicates that the customer voluntarily canceled the auto-renewable subscription. (Note: This notification type and subtype isn't specific to price increases.)  
  
For more information about App Store Server Notifications, see Enabling App
Store Server Notifications. For more information about notification types and
subtypes, see `notificationType` and `subtype`.

## See Also

### Getting the price increase status

`let priceIncreaseStatus:
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

The status that indicates whether the auto-renewable subscription is subject
to a price increase.

`enum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

Status values that indicate whether an auto-renewable subscription is subject
to a price increase.

Instance Property

# priceIncreaseStatus

The status that indicates whether the auto-renewable subscription is subject
to a price increase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let priceIncreaseStatus: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus

## Discussion

For more information about price increase status, see Managing Price Increases
for Auto-Renewable Subscriptions.

## See Also

### Getting the price increase status

Managing Price Increases for Auto-Renewable Subscriptions

Identify the price increase status for auto-renewable subscriptions, in your
app and on your server.

`enum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

Status values that indicate whether an auto-renewable subscription is subject
to a price increase.

Instance Property

# deviceVerification

The device verification value to use to verify whether the renewal information
belongs to the device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerification: Data

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying subscription renewal information

`let deviceVerificationNonce: UUID`

The UUID to use to compute the device verification value.

`let signedDate: Date`

The date that the App Store signed the JWS renewal information.

Instance Property

# deviceVerificationNonce

The UUID to use to compute the device verification value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerificationNonce: UUID

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying subscription renewal information

`let deviceVerification: Data`

The device verification value to use to verify whether the renewal information
belongs to the device.

`let signedDate: Date`

The date that the App Store signed the JWS renewal information.

Instance Property

# signedDate

The date that the App Store signed the JWS renewal information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let signedDate: Date

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the
transaction was valid when the App Store signed the transaction.

## See Also

### Verifying subscription renewal information

`let deviceVerification: Data`

The device verification value to use to verify whether the renewal information
belongs to the device.

`let deviceVerificationNonce: UUID`

The UUID to use to compute the device verification value.

Instance Property

# jsonRepresentation

The raw JSON representation of the subscription renewal information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var jsonRepresentation: Data { get }

## Discussion

The information in `jsonRepresentation` is the same information that’s in the
properties of the same instance of `Product.SubscriptionInfo.RenewalInfo`.

Instance Property

# debugDescription

A string representation of the renewal info, suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo, rhs: Product.SubscriptionInfo.RenewalInfo) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing renewal information

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (lhs: Product.SubscriptionInfo.RenewalInfo, rhs: Product.SubscriptionInfo.RenewalInfo) -> Bool

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Instance Property

# environment

The server environment that signs the renewal information for an auto-
renewable subscription.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    let environment: AppStore.Environment

## See Also

### Getting the environment

`@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0,
macCatalyst 16.0) var environmentStringRepresentation: String`

The string representation of the server environment that signs the renewal
information for an auto-renewable subscription.

Deprecated

Instance Property

# environmentStringRepresentation

The string representation of the server environment that signs the renewal
information for an auto-renewable subscription.

iOS 15.0–16.0  Deprecated  iPadOS 15.0–16.0  Deprecated  macOS 12.0–13.0
Deprecated  Mac Catalyst 16.0–16.0  Deprecated  tvOS 15.0–16.0  Deprecated
watchOS 8.0–9.0  Deprecated  Xcode 13.0–14.0  Deprecated

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var environmentStringRepresentation: String { get }

## See Also

### Getting the environment

`let environment: AppStore.Environment`

The server environment that signs the renewal information for an auto-
renewable subscription.

Instance Property

# originalTransactionID

The transaction identifier of the original purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let originalTransactionID: UInt64

Instance Property

# currentProductID

The subscription product ID that the customer is subscribed to.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let currentProductID: String

Instance Property

# offerID

A string that identifies an offer applied to the next subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let offerID: String?

## Discussion

This value is `nil` if there isn’t an offer, or if the offer type is
`introductory`.

If the offer type is `promotional`, this value contains the promotional offer
identifier you set up in App Store Connect. For more information about
promotional offers, see Set up promotional offers for auto-renewable
subscriptions.

If the offer type is `code`, this value contains the reference name of the
offer code you set up in App Store Connect. For more information about offer
codes, see Set up offer codes.

## See Also

### Getting subscription offers

`let offerType: Transaction.OfferType?`

The subscription offer type for the next subscription period.

Instance Property

# offerType

The subscription offer type for the next subscription period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let offerType: Transaction.OfferType?

## Discussion

If this value is `nil`, there’s no offer applied.

## See Also

### Getting subscription offers

`let offerID: String?`

A string that identifies an offer applied to the next subscription period.

Instance Property

# recentSubscriptionStartDate

The earliest start date of a subscription in a series of auto-renewable
subscription purchases that ignores all lapses of paid service shorter than 60
days.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 14.0+

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0)
    var recentSubscriptionStartDate: Date { get }

## Discussion

Important

Don’t use the `recentSubscriptionStartDate` date to calculate days of paid
service. For more information about paid days of service, see Net revenue
after a year.

Instance Property

# state

The renewal state of the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let state: Product.SubscriptionInfo.RenewalState

## See Also

### Getting subscription status information

`let renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>`

The signed renewal information for the auto-renewable subscription.

`let transaction: VerificationResult<Transaction>`

The latest transaction for the subscription group.

`struct Product.SubscriptionInfo.RenewalInfo`

The renewal information for an auto-renewable subscription.

`struct Product.SubscriptionInfo.RenewalState`

The renewal states of auto-renewable subscriptions.

Instance Property

# autoRenewPreference

The product ID of the auto-renewable subscription that will automatically
renew.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let autoRenewPreference: String?

## Discussion

This value is the product ID of the auto-renewable subscription that will
renew after the current period expires. The value may be:

  * The same as `currentProductID` if the subscription will renew with the same product.

  * Another product ID value if the subscription will renew to a different product.

  * `nil` if the subscription won’t renew in the next period. This may occur for several reasons, including when the person disables auto-renew for the subscription, the subscription lapses due to a billing issue, or you increase the subscription price and the person doesn't accept the increase.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# willAutoRenew

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let willAutoRenew: Bool

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# expirationReason

The reason the auto-renewable subscription expired.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?

## Discussion

This optional value is `nil` if the auto-renewable subscription is active and
hasn’t expired.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

`@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0,
macCatalyst 17.0) var renewalDate: Date?`

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

Instance Property

# renewalDate

The UNIX time, in milliseconds, that the most recent auto-renewable
subscription purchase expires.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 17.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0)
    var renewalDate: Date? { get }

## Discussion

The `renewalDate` is a value that’s always present for auto-renewable
subscriptions, even for expired subscriptions. This date indicates the
expiration date of the most recent auto-renewable subscription purchase,
including renewals, and may be in the past. For subscriptions that renew
successfully, the `renewalDate` is the date when the subscription renews.

## See Also

### Getting the renewal or expiration state

`let state: Product.SubscriptionInfo.RenewalState`

The renewal state of the auto-renewable subscription.

`let autoRenewPreference: String?`

The product ID of the auto-renewable subscription that will automatically
renew.

`let willAutoRenew: Bool`

A Boolean value that indicates whether the subscription will automatically
renew in the next period.

`let expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?`

The reason the auto-renewable subscription expired.

`struct Product.SubscriptionInfo.RenewalInfo.ExpirationReason`

The reasons for auto-renewable subscription expirations.

Instance Property

# isInBillingRetry

A Boolean value that indicates whether an auto-renewable subscription is in
the billing retry period.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let isInBillingRetry: Bool

## Discussion

This field indicates whether Apple is attempting to automatically renew an
expired subscription. If a subscription expires due to a billing issue, a
value of `true` indicates that Apple is still trying to renew the
subscription. If the subscription is in a billing grace period, the optional
`gracePeriodExpirationDate` contains a date.

Use the `isInBillingRetry` value along with `expirationReason` for more
insight, as the following table shows:

Values| Description  
---|---  
`isInBillingRetry` is `false,` `expirationReason` is `nil`| The auto-renewable
subscription is active and not in a billing retry period. The subscription is
entitled to service.  
`isInBillingRetry` is `true,``expirationReason` is
`billingError`,`gracePeriodExpirationDate` has a date| The auto-renewable
subscription is in a billing grace period. The subscription is entitled to
service until the date in `gracePeriodExpirationDate`.  
`isInBillingRetry` is `true,``expirationReason` is
`billingError`,`gracePeriodExpirationDate` is `nil`| The auto-renewable
subscription is in a billing retry period. The subscription is not entitled to
service.  
`isInBillingRetry` is `false,` `expirationReason` is `billingError`| The auto-
renewable subscription expired and billing retry wasn’t able to recover the
subscription.The subscription is not entitled to service.  
  
## See Also

### Getting billing status

`let gracePeriodExpirationDate: Date?`

The date the billing grace period expires for the auto-renewable subscription.

Instance Property

# gracePeriodExpirationDate

The date the billing grace period expires for the auto-renewable subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let gracePeriodExpirationDate: Date?

## Discussion

This value is `nil` if the subscription is not in a billing grace period.

This date is present if you enable Billing Grace Period for your app and the
subscription is in the billing grace period. Ensure that your app provides
full service for the subscription throughout the grace period, which ends on
the `gracePeriodExpirationDate`.

A billing grace period occurs at the start of a billing retry state.
Throughout the billing grace period, the value of `isInBillingRetry` is
`true`, which indicates that Apple is attempting to automatically renew the
subscription.

For information about supporting Billing Grace Period, see Enable Billing
Grace Period for auto-renewable subscriptions and Reducing Involuntary
Subscriber Churn.

## See Also

### Getting billing status

`let isInBillingRetry: Bool`

A Boolean value that indicates whether an auto-renewable subscription is in
the billing retry period.

Article

# Managing Price Increases for Auto-Renewable Subscriptions

Identify the price increase status for auto-renewable subscriptions, in your
app and on your server.

## Overview

If you increase the price of an auto-renewable subscription in App Store
Connect, the `priceIncreaseStatus` in the `renewalInfo` object indicates if
the subscription is subject to the price increase. Auto-renewable
subscriptions have two types of price increases: those that require customer
consent, and those that don’t require customer consent.

For price increases that require customer consent, look for the following
status values in your app:

`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending`|
Indicates there’s no price increase for this auto-renewable subscription.  
---|---  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending`| Indicates
there’s a pending price increase for the auto-renewable subscription that
requires customer consent, and the customer hasn’t yet consented. If the
customer doesn’t consent, the auto-renewable subscription expires at the end
of the billing cycle. When it expires, your app gets a status update in
`updates` with an `expirationReason` of `didNotConsentToPriceIncrease`.  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed`| Indicates
that the customer consented to a price increase for the auto-renewable
subscription.  
  
For price increases that don’t require customer consent, look for the
following status values in your app:

`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending`|
Doesn’t apply.  
---|---  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending`| Doesn’t
apply.  
`Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed`| Indicates
that the App Store informed the customer of the price increase for the auto-
renewable subscription, and the subscription is subject to the price
increase.If the customer cancels the auto-renewable subscription, your app
gets a status update in `updates` with an `expirationReason` of
`autoRenewDisabled`.  
  
For more information about managing subscription prices in App Store Connect,
see Managing Prices.

### Receive Notifications for Price Increase Status Events

If you’ve enabled App Store Server Notifications V2, your server receives
notifications for events related to auto-renewable subscription price
increases.

For auto-renewable subscription price increases that require customer consent,
look for the following notifications:

Notification type| Subtype| Description  
---|---|---  
`PRICE_INCREASE` | `PENDING`| Indicates that the App Store informed the customer of the price increase for the auto-renewable subscription, and the customer hasn’t yet responded.  
`PRICE_INCREASE`| `ACCEPTED`| Indicates that the customer consented to the
price increase for the auto-renewable subscription.  
`EXPIRED`| `PRICE_INCREASE`| Indicates that the auto-renewable subscription
expired because the customer didn’t consent to the price increase, and allowed
the subscription to expire.  
`EXPIRED`| `VOLUNTARY`| Indicates that the customer voluntarily canceled the
auto-renewable subscription. (Note: This notification type and subtype isn’t
specific to price increases.)  
  
For auto-renewable subscription price increases that don’t require customer
consent, look for the following notifications:

Notification type| Subtype| Description  
---|---|---  
`PRICE_INCREASE`| `ACCEPTED`| Indicates that the App Store informed the
customer of the auto-renewable subscription price increase, and the
subscription is subject to the price increase.  
`EXPIRED` | `VOLUNTARY`| Indicates that the customer voluntarily canceled the auto-renewable subscription. (Note: This notification type and subtype isn't specific to price increases.)  
  
For more information about App Store Server Notifications, see Enabling App
Store Server Notifications. For more information about notification types and
subtypes, see `notificationType` and `subtype`.

## See Also

### Getting the price increase status

`let priceIncreaseStatus:
Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

The status that indicates whether the auto-renewable subscription is subject
to a price increase.

`enum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

Status values that indicate whether an auto-renewable subscription is subject
to a price increase.

Instance Property

# priceIncreaseStatus

The status that indicates whether the auto-renewable subscription is subject
to a price increase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let priceIncreaseStatus: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus

## Discussion

For more information about price increase status, see Managing Price Increases
for Auto-Renewable Subscriptions.

## See Also

### Getting the price increase status

Managing Price Increases for Auto-Renewable Subscriptions

Identify the price increase status for auto-renewable subscriptions, in your
app and on your server.

`enum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus`

Status values that indicate whether an auto-renewable subscription is subject
to a price increase.

Instance Property

# deviceVerification

The device verification value to use to verify whether the renewal information
belongs to the device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerification: Data

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying subscription renewal information

`let deviceVerificationNonce: UUID`

The UUID to use to compute the device verification value.

`let signedDate: Date`

The date that the App Store signed the JWS renewal information.

Instance Property

# deviceVerificationNonce

The UUID to use to compute the device verification value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerificationNonce: UUID

## Discussion

For more information, see `deviceVerificationID`.

## See Also

### Verifying subscription renewal information

`let deviceVerification: Data`

The device verification value to use to verify whether the renewal information
belongs to the device.

`let signedDate: Date`

The date that the App Store signed the JWS renewal information.

Instance Property

# signedDate

The date that the App Store signed the JWS renewal information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let signedDate: Date

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the
transaction was valid when the App Store signed the transaction.

## See Also

### Verifying subscription renewal information

`let deviceVerification: Data`

The device verification value to use to verify whether the renewal information
belongs to the device.

`let deviceVerificationNonce: UUID`

The UUID to use to compute the device verification value.

Instance Property

# jsonRepresentation

The raw JSON representation of the subscription renewal information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var jsonRepresentation: Data { get }

## Discussion

The information in `jsonRepresentation` is the same information that’s in the
properties of the same instance of `Product.SubscriptionInfo.RenewalInfo`.

Instance Property

# debugDescription

A string representation of the renewal info, suitable for debugging.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionInfo.RenewalInfo, rhs: Product.SubscriptionInfo.RenewalInfo) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing renewal information

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (lhs: Product.SubscriptionInfo.RenewalInfo, rhs: Product.SubscriptionInfo.RenewalInfo) -> Bool

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing renewal information

`static func != (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionInfo.RenewalInfo,
Product.SubscriptionInfo.RenewalInfo) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# SKProductDiscount.PaymentMode

Enumeration Case

# SKProductDiscount.PaymentMode.payAsYouGo

A constant indicating that the payment mode of a product discount is billed
over a single or multiple billing periods.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case payAsYouGo = 0

## Discussion

With a pay as you go payment mode, users pay the discounted price at each
billing period during the discount period.

## See Also

### Discount Price Payment Modes

`case payUpFront`

A constant indicating that the payment mode of a product discount is paid up
front.

`case freeTrial`

A constant that indicates that the payment mode is a free trial.

Enumeration Case

# SKProductDiscount.PaymentMode.payUpFront

A constant indicating that the payment mode of a product discount is paid up
front.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case payUpFront = 1

## Discussion

With a pay up front payment mode, users pay the discounted price one time, and
receive the product for duration of the discount period.

## See Also

### Discount Price Payment Modes

`case payAsYouGo`

A constant indicating that the payment mode of a product discount is billed
over a single or multiple billing periods.

`case freeTrial`

A constant that indicates that the payment mode is a free trial.

Enumeration Case

# SKProductDiscount.PaymentMode.freeTrial

A constant that indicates that the payment mode is a free trial.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case freeTrial = 2

## Discussion

With a free trial payment mode, the price is 0, so users pay nothing during
the discount period.

## See Also

### Discount Price Payment Modes

`case payAsYouGo`

A constant indicating that the payment mode of a product discount is billed
over a single or multiple billing periods.

`case payUpFront`

A constant indicating that the payment mode of a product discount is paid up
front.

Enumeration Case

# SKProductDiscount.PaymentMode.payAsYouGo

A constant indicating that the payment mode of a product discount is billed
over a single or multiple billing periods.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case payAsYouGo = 0

## Discussion

With a pay as you go payment mode, users pay the discounted price at each
billing period during the discount period.

## See Also

### Discount Price Payment Modes

`case payUpFront`

A constant indicating that the payment mode of a product discount is paid up
front.

`case freeTrial`

A constant that indicates that the payment mode is a free trial.

Enumeration Case

# SKProductDiscount.PaymentMode.payUpFront

A constant indicating that the payment mode of a product discount is paid up
front.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case payUpFront = 1

## Discussion

With a pay up front payment mode, users pay the discounted price one time, and
receive the product for duration of the discount period.

## See Also

### Discount Price Payment Modes

`case payAsYouGo`

A constant indicating that the payment mode of a product discount is billed
over a single or multiple billing periods.

`case freeTrial`

A constant that indicates that the payment mode is a free trial.

Enumeration Case

# SKProductDiscount.PaymentMode.freeTrial

A constant that indicates that the payment mode is a free trial.

iOS 11.2+  iPadOS 11.2+  macOS 10.13.2+  Mac Catalyst 13.1+  tvOS 11.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case freeTrial = 2

## Discussion

With a free trial payment mode, the price is 0, so users pay nothing during
the discount period.

## See Also

### Discount Price Payment Modes

`case payAsYouGo`

A constant indicating that the payment mode of a product discount is billed
over a single or multiple billing periods.

`case payUpFront`

A constant indicating that the payment mode of a product discount is paid up
front.



# Transaction.Offer

Instance Property

# id

A string that identifies the subscription offer that applies to the
transaction.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    let id: String?

## Discussion

This value is `nil` if the subscription offer is an `introductory` offer.

If the offer type is `promotional`, this value contains the promotional offer
identifier you set up in App Store Connect. For more information about
promotional offers, see Set up promotional offers for auto-renewable
subscriptions.

If the offer type is `code`, this value contains the reference name of the
offer code you set up in App Store Connect. For more information about offer
codes, see Set up offer codes.

## See Also

### Getting offer details

`let type: Transaction.OfferType`

The type of subscription offer that applies to the transaction.

`struct Transaction.OfferType`

The types of offers for auto-renewable subscriptions.

`struct Transaction.Offer.PaymentMode`

The payment modes for subscription offers that apply to a transaction.

Instance Property

# type

The type of subscription offer that applies to the transaction.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    let type: Transaction.OfferType

## Discussion

The offer types are `introductory`, `promotional`, and `code`.

For more information about introductory offers, see Set an introductory offer
for an auto-renewable subscription.

For more information about promotional offers, see Set up promotional offers
for auto-renewable subscriptions.

For more information about offer codes, see Set up offer codes.

## See Also

### Getting offer details

`let id: String?`

A string that identifies the subscription offer that applies to the
transaction.

`struct Transaction.OfferType`

The types of offers for auto-renewable subscriptions.

`struct Transaction.Offer.PaymentMode`

The payment modes for subscription offers that apply to a transaction.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    static func == (a: Transaction.Offer, b: Transaction.Offer) -> Bool

## See Also

### Comparing offers

`static func != (Transaction.Offer, Transaction.Offer) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    static func != (lhs: Transaction.Offer, rhs: Transaction.Offer) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing offers

`static func == (Transaction.Offer, Transaction.Offer) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing offers

`static func == (Transaction.Offer, Transaction.Offer) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`static func != (Transaction.Offer, Transaction.Offer) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing offers

`static func == (Transaction.Offer, Transaction.Offer) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`static func != (Transaction.Offer, Transaction.Offer) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# paymentMode

iOS 17.2+  iPadOS 17.2+  macOS 14.2+  Mac Catalyst 17.2+  tvOS 17.2+  watchOS
10.2+  visionOS 1.1+  Xcode 15.1+

    
    
    let paymentMode: Transaction.Offer.PaymentMode?



# Product.SubscriptionInfo.Status.Statuses

Instance Method

# makeAsyncIterator()

Creates the iterator that produces elements of the asynchronous sequence.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func makeAsyncIterator() -> Product.SubscriptionInfo.Status.Statuses.AsyncIterator

## Return Value

An instance of `Product.SubscriptionInfo.Status.Statuses.AsyncIterator` used
to produce elements of the asynchronous sequence.

## Relationships

### From Protocol

  * `AsyncSequence`

## See Also

### Iterating over the status

`struct Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

An iterator that produces elements of the asynchronous sequence.

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

`typealias Product.SubscriptionInfo.Status.Statuses.Element`

The type of element the iterator traverses.

Type Alias

# Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element

The type of element the iterator produces.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element = Product.SubscriptionInfo.Status.Statuses.Element

## Discussion

This iterator produces `Product.SubscriptionInfo.Status` elements.

## See Also

### Getting the Next Element

`func next() -> Product.SubscriptionInfo.Status.Statuses.Element?`

Type Alias

# Product.SubscriptionInfo.Status.Statuses.Element

The type of element the iterator traverses.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.Element = Product.SubscriptionInfo.Status

## See Also

### Iterating over the status

`func makeAsyncIterator() ->
Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

Creates the iterator that produces elements of the asynchronous sequence.

`struct Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

An iterator that produces elements of the asynchronous sequence.

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

Instance Method

# allSatisfy(_:)

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func allSatisfy(_ predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
satisfies a condition.

## Return Value

`true` if the sequence contains only elements that satisfy `predicate`;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether all
elements produced by the sequence are less than `10`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate returns `false` or the sequence ends.

If the asynchronous sequence is empty, this method returns `true`.

## See Also

### Filtering and matching elements

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(_:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(_ search: Product.SubscriptionInfo.Status) async rethrows -> Bool

##  Parameters

`search`

    

The element to find in the asynchronous sequence.

## Return Value

`true` if the method found the element in the asynchronous sequence;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(_:)` method checks to see whether the
sequence produces the value `5`:

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(where:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(where predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
represents a match.

## Return Value

`true` if the sequence contains an element that satisfies predicate;
otherwise, `false`.

## Discussion

You can use the predicate to check for an element of a type that doesn’t
conform to the `Equatable` protocol, or to find an element that satisfies a
general condition.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(where:)` method checks to see whether
the sequence produces a value divisible by `3`:

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# first(where:)

Returns the first element of the sequence that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func first(where predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the element is a match.

## Return Value

The first element of the sequence that satisfies `predicate`, or `nil` if
there is no element that satisfies `predicate`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `first(where:)` method returns the first member
of the sequence that’s evenly divisible by both `2` and `3`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# filter(_:)

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func filter(_ isIncluded: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`isIncluded`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether to include the element in
the filtered sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements of the base
sequence that satisfy the given predicate.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `filter(_:)` method returns `true` for even
values and `false` for odd values, thereby filtering out the odd values:

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# max(by:)

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func max(by areInIncreasingOrder: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `max(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# min(by:)

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func min(by areInIncreasingOrder: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `min(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns a transformed value of the same or of a
different type. If `transform` throws an error, the sequence ends.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure. The sequence ends either when the base
sequence ends or when `transform` throws an error.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Since there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence. When the value is `5`, the closure throws `MyError`,
terminating the sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Because there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns an `AsyncSequence`. If `transform`
throws an error, the sequence ends.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`. The sequence ends either
when the last sequence created from the last element from base sequence ends,
or when `transform` throws an error.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`. However, when
the closure receives `4`, it throws an error, terminating the sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns an `AsyncSequence`.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.
`transform` can also throw an error, which ends the transformed sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces.
Also, the dictionary doesn’t provide a key for `4`, and the closure throws an
error for any key it can’t look up, so receiving this value from `Counter`
ends the modified sequence with an error.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces:

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(_:)

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func prefix(_ count: Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`count`

    

The maximum number of elements to return. The value of `count` must be greater
than or equal to zero.

## Return Value

An asynchronous sequence starting at the beginning of the base sequence with
at most `count` elements.

## Discussion

Use `prefix(_:)` to reduce the number of elements produced by the asynchronous
sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(_:)` method causes the modified sequence
to pass through the first six values, then end.

If the count passed to `prefix(_:)` exceeds the number of elements in the base
sequence, the result contains all of the elements in the sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(while:)

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func prefix(while predicate: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether the element should be included in the modified sequence.

## Return Value

An asynchronous sequence of the initial, consecutive elements that satisfy
`predicate`.

## Discussion

Use `prefix(while:)` to produce values while elements from the base sequence
meet a condition you specify. The modified sequence ends when the predicate
closure returns `false`.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(while:)` method causes the modified
sequence to pass along values so long as they aren’t divisible by `2` and `3`.
Upon reaching `6`, the sequence ends:

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(_:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        _ initialResult: Result,
        _ nextPartialResult: (Result, Product.SubscriptionInfo.Status) async throws -> Result
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure runs.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(_:_:)` method to produce a single value from the elements of
an entire sequence. For example, you can use this method on an sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `4`. The `reduce(_:_:)` method sums the values received
from the asynchronous sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(into:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        into initialResult: Result,
        _ updateAccumulatingResult: (inout Result, Product.SubscriptionInfo.Status) async throws -> Void
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure executes.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(into:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on a sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

Prefer this method over `reduce(_:_:)` for efficiency when the result is a
copy-on-write type, for example an `Array` or `Dictionary`.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

Instance Method

# drop(while:)

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func drop(while predicate: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) -> AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether to drop the element from the modified sequence.

## Return Value

An asynchronous sequence that skips over values from the base sequence until
the provided closure returns `false`.

## Discussion

Use `drop(while:)` to omit elements from an asynchronous sequence until the
element received meets a condition you specify.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `drop(while:)` method causes the modified
sequence to ignore received values until it encounters one that is divisible
by `3`:

After the predicate returns `false`, the sequence never executes it again, and
from then on the sequence passes through elements from its underlying sequence
as-is.

## See Also

### Excluding elements

`func dropFirst(Int) ->
AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

Instance Method

# dropFirst(_:)

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`count`

    

The number of elements to drop from the beginning of the sequence. `count`
must be greater than or equal to zero.

## Return Value

An asynchronous sequence that drops the first `count` elements from the base
sequence.

## Discussion

Use `dropFirst(_:)` when you want to drop the first _n_ elements from the base
sequence and pass through the remaining elements.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `dropFirst(_:)` method causes the modified
sequence to ignore the values `1` through `3`, and instead emit `4` through
`10`:

If the number of elements to drop exceeds the number of elements in the
sequence, the result is an empty sequence.

## See Also

### Excluding elements

`func drop(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

Instance Method

# makeAsyncIterator()

Creates the iterator that produces elements of the asynchronous sequence.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func makeAsyncIterator() -> Product.SubscriptionInfo.Status.Statuses.AsyncIterator

## Return Value

An instance of `Product.SubscriptionInfo.Status.Statuses.AsyncIterator` used
to produce elements of the asynchronous sequence.

## Relationships

### From Protocol

  * `AsyncSequence`

## See Also

### Iterating over the status

`struct Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

An iterator that produces elements of the asynchronous sequence.

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

`typealias Product.SubscriptionInfo.Status.Statuses.Element`

The type of element the iterator traverses.

Type Alias

# Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element

The type of element the iterator produces.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element = Product.SubscriptionInfo.Status.Statuses.Element

## Discussion

This iterator produces `Product.SubscriptionInfo.Status` elements.

## See Also

### Getting the Next Element

`func next() -> Product.SubscriptionInfo.Status.Statuses.Element?`

Type Alias

# Product.SubscriptionInfo.Status.Statuses.Element

The type of element the iterator traverses.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.Element = Product.SubscriptionInfo.Status

## See Also

### Iterating over the status

`func makeAsyncIterator() ->
Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

Creates the iterator that produces elements of the asynchronous sequence.

`struct Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

An iterator that produces elements of the asynchronous sequence.

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

Instance Method

# allSatisfy(_:)

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func allSatisfy(_ predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
satisfies a condition.

## Return Value

`true` if the sequence contains only elements that satisfy `predicate`;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether all
elements produced by the sequence are less than `10`.

    
    
    let allLessThanTen = await Counter(howHigh: 10)
        .allSatisfy { $0 < 10 }
    print(allLessThanTen)
    // Prints "false"
    

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate returns `false` or the sequence ends.

If the asynchronous sequence is empty, this method returns `true`.

## See Also

### Filtering and matching elements

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(_:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(_ search: Product.SubscriptionInfo.Status) async rethrows -> Bool

##  Parameters

`search`

    

The element to find in the asynchronous sequence.

## Return Value

`true` if the method found the element in the asynchronous sequence;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(_:)` method checks to see whether the
sequence produces the value `5`:

    
    
    let containsFive = await Counter(howHigh: 10)
        .contains(5)
    print(containsFive)
    // Prints "true"
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(where:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(where predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
represents a match.

## Return Value

`true` if the sequence contains an element that satisfies predicate;
otherwise, `false`.

## Discussion

You can use the predicate to check for an element of a type that doesn’t
conform to the `Equatable` protocol, or to find an element that satisfies a
general condition.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(where:)` method checks to see whether
the sequence produces a value divisible by `3`:

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# first(where:)

Returns the first element of the sequence that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func first(where predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the element is a match.

## Return Value

The first element of the sequence that satisfies `predicate`, or `nil` if
there is no element that satisfies `predicate`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `first(where:)` method returns the first member
of the sequence that’s evenly divisible by both `2` and `3`.

    
    
    let divisibleBy2And3 = await Counter(howHigh: 10)
        .first { $0 % 2 == 0 && $0 % 3 == 0 }
    print(divisibleBy2And3 ?? "none")
    // Prints "6"
    

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# filter(_:)

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func filter(_ isIncluded: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`isIncluded`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether to include the element in
the filtered sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements of the base
sequence that satisfy the given predicate.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `filter(_:)` method returns `true` for even
values and `false` for odd values, thereby filtering out the odd values:

    
    
    let stream = Counter(howHigh: 10)
        .filter { $0 % 2 == 0 }
    for await number in stream {
        print(number, terminator: " ")
    }
    // Prints "2 4 6 8 10 "
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# max(by:)

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func max(by areInIncreasingOrder: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `max(by:)` method sorts ranks based on their `rawValue`:

    
    
    enum Rank: Int {
        case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
    }
    
    
    let max = await RankCounter()
        .max { $0.rawValue < $1.rawValue }
    print(max ?? "none")
    // Prints "king"
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# min(by:)

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func min(by areInIncreasingOrder: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `min(by:)` method sorts ranks based on their `rawValue`:

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns a transformed value of the same or of a
different type. If `transform` throws an error, the sequence ends.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure. The sequence ends either when the base
sequence ends or when `transform` throws an error.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Since there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence. When the value is `5`, the closure throws `MyError`,
terminating the sequence.

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
    
    
    do {
        let stream = Counter(howHigh: 5)
            .compactMap { (value) throws -> String? in
                if value == 5 {
                    throw MyError()
                }
                return romanNumeralDict[value]
            }
        for try await numeral in stream {
            print(numeral, terminator: " ")
        }
    } catch {
        print("Error: \(error)")
    }
    // Prints "I II III Error: MyError() "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Because there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence.

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
        
    let stream = Counter(howHigh: 5)
        .compactMap { romanNumeralDict[$0] }
    for await numeral in stream {
        print(numeral, terminator: " ")
    }
    // Prints "I II III V "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns an `AsyncSequence`. If `transform`
throws an error, the sequence ends.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`. The sequence ends either
when the last sequence created from the last element from base sequence ends,
or when `transform` throws an error.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`. However, when
the closure receives `4`, it throws an error, terminating the sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns an `AsyncSequence`.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.
`transform` can also throw an error, which ends the transformed sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces.
Also, the dictionary doesn’t provide a key for `4`, and the closure throws an
error for any key it can’t look up, so receiving this value from `Counter`
ends the modified sequence with an error.

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
    
    
    do {
        let stream = Counter(howHigh: 5)
            .map { (value) throws -> String in
                guard let roman = romanNumeralDict[value] else {
                    throw MyError()
                }
                return roman
            }
        for try await numeral in stream {
            print(numeral, terminator: " ")
        }
    } catch {
        print("Error: \(error)")
    }
    // Prints "I II III Error: MyError() "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces:

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
    
    
    let stream = Counter(howHigh: 5)
        .map { romanNumeralDict[$0] ?? "(unknown)" }
    for await numeral in stream {
        print(numeral, terminator: " ")
    }
    // Prints "I II III (unknown) V "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(_:)

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func prefix(_ count: Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`count`

    

The maximum number of elements to return. The value of `count` must be greater
than or equal to zero.

## Return Value

An asynchronous sequence starting at the beginning of the base sequence with
at most `count` elements.

## Discussion

Use `prefix(_:)` to reduce the number of elements produced by the asynchronous
sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(_:)` method causes the modified sequence
to pass through the first six values, then end.

    
    
    for await number in Counter(howHigh: 10).prefix(6) {
        print(number, terminator: " ")
    }
    // Prints "1 2 3 4 5 6 "
    

If the count passed to `prefix(_:)` exceeds the number of elements in the base
sequence, the result contains all of the elements in the sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(while:)

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func prefix(while predicate: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether the element should be included in the modified sequence.

## Return Value

An asynchronous sequence of the initial, consecutive elements that satisfy
`predicate`.

## Discussion

Use `prefix(while:)` to produce values while elements from the base sequence
meet a condition you specify. The modified sequence ends when the predicate
closure returns `false`.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(while:)` method causes the modified
sequence to pass along values so long as they aren’t divisible by `2` and `3`.
Upon reaching `6`, the sequence ends:

    
    
    let stream = Counter(howHigh: 10)
        .prefix { $0 % 2 != 0 || $0 % 3 != 0 }
    for try await number in stream {
        print(number, terminator: " ")
    }
    // Prints "1 2 3 4 5 "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(_:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        _ initialResult: Result,
        _ nextPartialResult: (Result, Product.SubscriptionInfo.Status) async throws -> Result
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure runs.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(_:_:)` method to produce a single value from the elements of
an entire sequence. For example, you can use this method on an sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `4`. The `reduce(_:_:)` method sums the values received
from the asynchronous sequence.

    
    
    let sum = await Counter(howHigh: 4)
        .reduce(0) {
            $0 + $1
        }
    print(sum)
    // Prints "10"
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(into:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        into initialResult: Result,
        _ updateAccumulatingResult: (inout Result, Product.SubscriptionInfo.Status) async throws -> Void
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure executes.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(into:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on a sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

Prefer this method over `reduce(_:_:)` for efficiency when the result is a
copy-on-write type, for example an `Array` or `Dictionary`.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

Instance Method

# drop(while:)

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func drop(while predicate: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) -> AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether to drop the element from the modified sequence.

## Return Value

An asynchronous sequence that skips over values from the base sequence until
the provided closure returns `false`.

## Discussion

Use `drop(while:)` to omit elements from an asynchronous sequence until the
element received meets a condition you specify.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `drop(while:)` method causes the modified
sequence to ignore received values until it encounters one that is divisible
by `3`:

    
    
    let stream = Counter(howHigh: 10)
        .drop { $0 % 3 != 0 }
    for await number in stream {
        print(number, terminator: " ")
    }
    // Prints "3 4 5 6 7 8 9 10 "
    

After the predicate returns `false`, the sequence never executes it again, and
from then on the sequence passes through elements from its underlying sequence
as-is.

## See Also

### Excluding elements

`func dropFirst(Int) ->
AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

Instance Method

# dropFirst(_:)

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`count`

    

The number of elements to drop from the beginning of the sequence. `count`
must be greater than or equal to zero.

## Return Value

An asynchronous sequence that drops the first `count` elements from the base
sequence.

## Discussion

Use `dropFirst(_:)` when you want to drop the first _n_ elements from the base
sequence and pass through the remaining elements.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `dropFirst(_:)` method causes the modified
sequence to ignore the values `1` through `3`, and instead emit `4` through
`10`:

    
    
    for await number in Counter(howHigh: 10).dropFirst(3) {
        print(number, terminator: " ")
    }
    // Prints "4 5 6 7 8 9 10 "
    

If the number of elements to drop exceeds the number of elements in the
sequence, the result is an empty sequence.

## See Also

### Excluding elements

`func drop(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

Instance Method

# makeAsyncIterator()

Creates the iterator that produces elements of the asynchronous sequence.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func makeAsyncIterator() -> Product.SubscriptionInfo.Status.Statuses.AsyncIterator

## Return Value

An instance of `Product.SubscriptionInfo.Status.Statuses.AsyncIterator` used
to produce elements of the asynchronous sequence.

## Relationships

### From Protocol

  * `AsyncSequence`

## See Also

### Iterating over the status

`struct Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

An iterator that produces elements of the asynchronous sequence.

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

`typealias Product.SubscriptionInfo.Status.Statuses.Element`

The type of element the iterator traverses.

Type Alias

# Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element

The type of element the iterator produces.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element = Product.SubscriptionInfo.Status.Statuses.Element

## Discussion

This iterator produces `Product.SubscriptionInfo.Status` elements.

## See Also

### Getting the Next Element

`func next() -> Product.SubscriptionInfo.Status.Statuses.Element?`

Type Alias

# Product.SubscriptionInfo.Status.Statuses.Element

The type of element the iterator traverses.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.Element = Product.SubscriptionInfo.Status

## See Also

### Iterating over the status

`func makeAsyncIterator() ->
Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

Creates the iterator that produces elements of the asynchronous sequence.

`struct Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

An iterator that produces elements of the asynchronous sequence.

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

Instance Method

# allSatisfy(_:)

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func allSatisfy(_ predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
satisfies a condition.

## Return Value

`true` if the sequence contains only elements that satisfy `predicate`;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether all
elements produced by the sequence are less than `10`.

    
    
    let allLessThanTen = await Counter(howHigh: 10)
        .allSatisfy { $0 < 10 }
    print(allLessThanTen)
    // Prints "false"
    

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate returns `false` or the sequence ends.

If the asynchronous sequence is empty, this method returns `true`.

## See Also

### Filtering and matching elements

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(_:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(_ search: Product.SubscriptionInfo.Status) async rethrows -> Bool

##  Parameters

`search`

    

The element to find in the asynchronous sequence.

## Return Value

`true` if the method found the element in the asynchronous sequence;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(_:)` method checks to see whether the
sequence produces the value `5`:

    
    
    let containsFive = await Counter(howHigh: 10)
        .contains(5)
    print(containsFive)
    // Prints "true"
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(where:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(where predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
represents a match.

## Return Value

`true` if the sequence contains an element that satisfies predicate;
otherwise, `false`.

## Discussion

You can use the predicate to check for an element of a type that doesn’t
conform to the `Equatable` protocol, or to find an element that satisfies a
general condition.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(where:)` method checks to see whether
the sequence produces a value divisible by `3`:

    
    
    let containsDivisibleByThree = await Counter(howHigh: 10)
        .contains { $0 % 3 == 0 }
    print(containsDivisibleByThree)
    // Prints "true"
    

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# first(where:)

Returns the first element of the sequence that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func first(where predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the element is a match.

## Return Value

The first element of the sequence that satisfies `predicate`, or `nil` if
there is no element that satisfies `predicate`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `first(where:)` method returns the first member
of the sequence that’s evenly divisible by both `2` and `3`.

    
    
    let divisibleBy2And3 = await Counter(howHigh: 10)
        .first { $0 % 2 == 0 && $0 % 3 == 0 }
    print(divisibleBy2And3 ?? "none")
    // Prints "6"
    

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# filter(_:)

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func filter(_ isIncluded: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`isIncluded`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether to include the element in
the filtered sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements of the base
sequence that satisfy the given predicate.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `filter(_:)` method returns `true` for even
values and `false` for odd values, thereby filtering out the odd values:

    
    
    let stream = Counter(howHigh: 10)
        .filter { $0 % 2 == 0 }
    for await number in stream {
        print(number, terminator: " ")
    }
    // Prints "2 4 6 8 10 "
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# max(by:)

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func max(by areInIncreasingOrder: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `max(by:)` method sorts ranks based on their `rawValue`:

    
    
    enum Rank: Int {
        case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
    }
    
    
    let max = await RankCounter()
        .max { $0.rawValue < $1.rawValue }
    print(max ?? "none")
    // Prints "king"
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# min(by:)

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func min(by areInIncreasingOrder: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `min(by:)` method sorts ranks based on their `rawValue`:

    
    
    enum Rank: Int {
        case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
    }
    
    
    let min = await RankCounter()
        .min { $0.rawValue < $1.rawValue }
    print(min ?? "none")
    // Prints "ace"
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns a transformed value of the same or of a
different type. If `transform` throws an error, the sequence ends.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure. The sequence ends either when the base
sequence ends or when `transform` throws an error.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Since there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence. When the value is `5`, the closure throws `MyError`,
terminating the sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Because there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence.

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
        
    let stream = Counter(howHigh: 5)
        .compactMap { romanNumeralDict[$0] }
    for await numeral in stream {
        print(numeral, terminator: " ")
    }
    // Prints "I II III V "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns an `AsyncSequence`. If `transform`
throws an error, the sequence ends.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`. The sequence ends either
when the last sequence created from the last element from base sequence ends,
or when `transform` throws an error.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`. However, when
the closure receives `4`, it throws an error, terminating the sequence.

    
    
    do {
        let stream = Counter(howHigh: 5)
            .flatMap { (value) -> Counter in
                if value == 4 {
                    throw MyError()
                }
                return Counter(howHigh: value)
            }
        for try await number in stream {
            print(number, terminator: " ")
        }
    } catch {
        print(error)
    }
    // Prints "1 1 2 1 2 3 MyError() "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns an `AsyncSequence`.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`.

    
    
    let stream = Counter(howHigh: 5)
        .flatMap { Counter(howHigh: $0) }
    for await number in stream {
        print(number, terminator: " ")
    }
    // Prints "1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.
`transform` can also throw an error, which ends the transformed sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces.
Also, the dictionary doesn’t provide a key for `4`, and the closure throws an
error for any key it can’t look up, so receiving this value from `Counter`
ends the modified sequence with an error.

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
    
    
    do {
        let stream = Counter(howHigh: 5)
            .map { (value) throws -> String in
                guard let roman = romanNumeralDict[value] else {
                    throw MyError()
                }
                return roman
            }
        for try await numeral in stream {
            print(numeral, terminator: " ")
        }
    } catch {
        print("Error: \(error)")
    }
    // Prints "I II III Error: MyError() "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces:

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
    
    
    let stream = Counter(howHigh: 5)
        .map { romanNumeralDict[$0] ?? "(unknown)" }
    for await numeral in stream {
        print(numeral, terminator: " ")
    }
    // Prints "I II III (unknown) V "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(_:)

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func prefix(_ count: Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`count`

    

The maximum number of elements to return. The value of `count` must be greater
than or equal to zero.

## Return Value

An asynchronous sequence starting at the beginning of the base sequence with
at most `count` elements.

## Discussion

Use `prefix(_:)` to reduce the number of elements produced by the asynchronous
sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(_:)` method causes the modified sequence
to pass through the first six values, then end.

    
    
    for await number in Counter(howHigh: 10).prefix(6) {
        print(number, terminator: " ")
    }
    // Prints "1 2 3 4 5 6 "
    

If the count passed to `prefix(_:)` exceeds the number of elements in the base
sequence, the result contains all of the elements in the sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(while:)

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func prefix(while predicate: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether the element should be included in the modified sequence.

## Return Value

An asynchronous sequence of the initial, consecutive elements that satisfy
`predicate`.

## Discussion

Use `prefix(while:)` to produce values while elements from the base sequence
meet a condition you specify. The modified sequence ends when the predicate
closure returns `false`.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(while:)` method causes the modified
sequence to pass along values so long as they aren’t divisible by `2` and `3`.
Upon reaching `6`, the sequence ends:

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(_:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        _ initialResult: Result,
        _ nextPartialResult: (Result, Product.SubscriptionInfo.Status) async throws -> Result
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure runs.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(_:_:)` method to produce a single value from the elements of
an entire sequence. For example, you can use this method on an sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `4`. The `reduce(_:_:)` method sums the values received
from the asynchronous sequence.

    
    
    let sum = await Counter(howHigh: 4)
        .reduce(0) {
            $0 + $1
        }
    print(sum)
    // Prints "10"
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(into:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        into initialResult: Result,
        _ updateAccumulatingResult: (inout Result, Product.SubscriptionInfo.Status) async throws -> Void
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure executes.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(into:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on a sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

Prefer this method over `reduce(_:_:)` for efficiency when the result is a
copy-on-write type, for example an `Array` or `Dictionary`.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

Instance Method

# drop(while:)

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func drop(while predicate: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) -> AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether to drop the element from the modified sequence.

## Return Value

An asynchronous sequence that skips over values from the base sequence until
the provided closure returns `false`.

## Discussion

Use `drop(while:)` to omit elements from an asynchronous sequence until the
element received meets a condition you specify.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `drop(while:)` method causes the modified
sequence to ignore received values until it encounters one that is divisible
by `3`:

    
    
    let stream = Counter(howHigh: 10)
        .drop { $0 % 3 != 0 }
    for await number in stream {
        print(number, terminator: " ")
    }
    // Prints "3 4 5 6 7 8 9 10 "
    

After the predicate returns `false`, the sequence never executes it again, and
from then on the sequence passes through elements from its underlying sequence
as-is.

## See Also

### Excluding elements

`func dropFirst(Int) ->
AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

Instance Method

# dropFirst(_:)

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`count`

    

The number of elements to drop from the beginning of the sequence. `count`
must be greater than or equal to zero.

## Return Value

An asynchronous sequence that drops the first `count` elements from the base
sequence.

## Discussion

Use `dropFirst(_:)` when you want to drop the first _n_ elements from the base
sequence and pass through the remaining elements.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `dropFirst(_:)` method causes the modified
sequence to ignore the values `1` through `3`, and instead emit `4` through
`10`:

    
    
    for await number in Counter(howHigh: 10).dropFirst(3) {
        print(number, terminator: " ")
    }
    // Prints "4 5 6 7 8 9 10 "
    

If the number of elements to drop exceeds the number of elements in the
sequence, the result is an empty sequence.

## See Also

### Excluding elements

`func drop(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

Instance Method

# makeAsyncIterator()

Creates the iterator that produces elements of the asynchronous sequence.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func makeAsyncIterator() -> Product.SubscriptionInfo.Status.Statuses.AsyncIterator

## Return Value

An instance of `Product.SubscriptionInfo.Status.Statuses.AsyncIterator` used
to produce elements of the asynchronous sequence.

## Relationships

### From Protocol

  * `AsyncSequence`

## See Also

### Iterating over the status

`struct Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

An iterator that produces elements of the asynchronous sequence.

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

`typealias Product.SubscriptionInfo.Status.Statuses.Element`

The type of element the iterator traverses.

Type Alias

# Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element

The type of element the iterator produces.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element = Product.SubscriptionInfo.Status.Statuses.Element

## Discussion

This iterator produces `Product.SubscriptionInfo.Status` elements.

## See Also

### Getting the Next Element

`func next() -> Product.SubscriptionInfo.Status.Statuses.Element?`

Type Alias

# Product.SubscriptionInfo.Status.Statuses.Element

The type of element the iterator traverses.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionInfo.Status.Statuses.Element = Product.SubscriptionInfo.Status

## See Also

### Iterating over the status

`func makeAsyncIterator() ->
Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

Creates the iterator that produces elements of the asynchronous sequence.

`struct Product.SubscriptionInfo.Status.Statuses.AsyncIterator`

An iterator that produces elements of the asynchronous sequence.

`typealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element`

The type of element the iterator produces.

Instance Method

# allSatisfy(_:)

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func allSatisfy(_ predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
satisfies a condition.

## Return Value

`true` if the sequence contains only elements that satisfy `predicate`;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether all
elements produced by the sequence are less than `10`.

    
    
    let allLessThanTen = await Counter(howHigh: 10)
        .allSatisfy { $0 < 10 }
    print(allLessThanTen)
    // Prints "false"
    

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate returns `false` or the sequence ends.

If the asynchronous sequence is empty, this method returns `true`.

## See Also

### Filtering and matching elements

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(_:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(_ search: Product.SubscriptionInfo.Status) async rethrows -> Bool

##  Parameters

`search`

    

The element to find in the asynchronous sequence.

## Return Value

`true` if the method found the element in the asynchronous sequence;
otherwise, `false`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(_:)` method checks to see whether the
sequence produces the value `5`:

    
    
    let containsFive = await Counter(howHigh: 10)
        .contains(5)
    print(containsFive)
    // Prints "true"
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# contains(where:)

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func contains(where predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Bool

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the passed element
represents a match.

## Return Value

`true` if the sequence contains an element that satisfies predicate;
otherwise, `false`.

## Discussion

You can use the predicate to check for an element of a type that doesn’t
conform to the `Equatable` protocol, or to find an element that satisfies a
general condition.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `contains(where:)` method checks to see whether
the sequence produces a value divisible by `3`:

    
    
    let containsDivisibleByThree = await Counter(howHigh: 10)
        .contains { $0 % 3 == 0 }
    print(containsDivisibleByThree)
    // Prints "true"
    

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# first(where:)

Returns the first element of the sequence that satisfies the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func first(where predicate: (Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`predicate`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether the element is a match.

## Return Value

The first element of the sequence that satisfies `predicate`, or `nil` if
there is no element that satisfies `predicate`.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `first(where:)` method returns the first member
of the sequence that’s evenly divisible by both `2` and `3`.

The predicate executes each time the asynchronous sequence produces an
element, until either the predicate finds a match or the sequence ends.

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# filter(_:)

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func filter(_ isIncluded: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`isIncluded`

    

A closure that takes an element of the asynchronous sequence as its argument
and returns a Boolean value that indicates whether to include the element in
the filtered sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements of the base
sequence that satisfy the given predicate.

## Discussion

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `filter(_:)` method returns `true` for even
values and `false` for odd values, thereby filtering out the odd values:

    
    
    let stream = Counter(howHigh: 10)
        .filter { $0 % 2 == 0 }
    for await number in stream {
        print(number, terminator: " ")
    }
    // Prints "2 4 6 8 10 "
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# max(by:)

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func max(by areInIncreasingOrder: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `max(by:)` method sorts ranks based on their `rawValue`:

    
    
    enum Rank: Int {
        case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
    }
    
    
    let max = await RankCounter()
        .max { $0.rawValue < $1.rawValue }
    print(max ?? "none")
    // Prints "king"
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func min(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Instance Method

# min(by:)

Returns the minimum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @warn_unqualified_access
    func min(by areInIncreasingOrder: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) async throws -> Bool) async rethrows -> Product.SubscriptionInfo.Status?

##  Parameters

`areInIncreasingOrder`

    

A predicate that returns `true` if its first argument should be ordered before
its second argument; otherwise, `false`.

## Return Value

The sequence’s minimum element, according to `areInIncreasingOrder`. If the
sequence has no elements, returns `nil`.

## Discussion

Use this method when the asynchronous sequence’s values don’t conform to
`Comparable`, or when you want to apply a custom ordering to the sequence.

The predicate must be a _strict weak ordering_ over the elements. That is, for
any elements `a`, `b`, and `c`, the following conditions must hold:

  * `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)

  * If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)

  * Two elements are _incomparable_ if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)

The following example uses an enumeration of playing cards ranks, `Rank`,
which ranges from `ace` (low) to `king` (high). An asynchronous sequence
called `RankCounter` produces all elements of the array. The predicate
provided to the `min(by:)` method sorts ranks based on their `rawValue`:

    
    
    enum Rank: Int {
        case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
    }
    
    
    let min = await RankCounter()
        .min { $0.rawValue < $1.rawValue }
    print(min ?? "none")
    // Prints "ace"
    

## See Also

### Filtering and matching elements

`func allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether all elements produced by the
asynchronous sequence satisfy the given predicate.

`func contains(Product.SubscriptionInfo.Status) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains the given element.

`func contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool`

Returns a Boolean value that indicates whether the asynchronous sequence
contains an element that satisfies the given predicate.

`func first(where: (Product.SubscriptionInfo.Status) -> Bool) ->
Product.SubscriptionInfo.Status?`

Returns the first element of the sequence that satisfies the given predicate.

`func filter((Product.SubscriptionInfo.Status) -> Bool) ->
AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>`

Creates an asynchronous sequence that contains, in order, the elements of the
base sequence that satisfy the given predicate.

`func max(by: (Product.SubscriptionInfo.Status,
Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?`

Returns the maximum element in the asynchronous sequence, using the given
predicate as the comparison between elements.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns a transformed value of the same or of a
different type. If `transform` throws an error, the sequence ends.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure. The sequence ends either when the base
sequence ends or when `transform` throws an error.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Since there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence. When the value is `5`, the closure throws `MyError`,
terminating the sequence.

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
    
    
    do {
        let stream = Counter(howHigh: 5)
            .compactMap { (value) throws -> String? in
                if value == 5 {
                    throw MyError()
                }
                return romanNumeralDict[value]
            }
        for try await numeral in stream {
            print(numeral, terminator: " ")
        }
    } catch {
        print("Error: \(error)")
    }
    // Prints "I II III Error: MyError() "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# compactMap(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the non-`nil` elements
produced by the `transform` closure.

## Discussion

Use the `compactMap(_:)` method to transform every element received from a
base asynchronous sequence, while also discarding any `nil` results from the
closure. Typically, you use this to transform from one type of element to
another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `compactMap(_:)` method
takes each `Int` and looks up a corresponding `String` from a
`romanNumeralDict` dictionary. Because there is no key for `4`, the closure
returns `nil` in this case, which `compactMap(_:)` omits from the transformed
asynchronous sequence.

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
        
    let stream = Counter(howHigh: 5)
        .compactMap { romanNumeralDict[$0] }
    for await numeral in stream {
        print(numeral, terminator: " ")
    }
    // Prints "I II III V "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

An error-throwing mapping closure. `transform` accepts an element of this
sequence as its parameter and returns an `AsyncSequence`. If `transform`
throws an error, the sequence ends.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`. The sequence ends either
when the last sequence created from the last element from base sequence ends,
or when `transform` throws an error.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`. However, when
the closure receives `4`, it throws an error, terminating the sequence.

    
    
    do {
        let stream = Counter(howHigh: 5)
            .flatMap { (value) -> Counter in
                if value == 4 {
                    throw MyError()
                }
                return Counter(howHigh: value)
            }
        for try await number in stream {
            print(number, terminator: " ")
        }
    } catch {
        print(error)
    }
    // Prints "1 1 2 1 2 3 MyError() "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# flatMap(_:)

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult> where SegmentOfResult : AsyncSequence

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns an `AsyncSequence`.

## Return Value

A single, flattened asynchronous sequence that contains all elements in all
the asynchronous sequences produced by `transform`.

## Discussion

Use this method to receive a single-level asynchronous sequence when your
transformation produces an asynchronous sequence for each element.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The transforming closure takes the received `Int` and
returns a new `Counter` that counts that high. For example, when the transform
receives `3` from the base sequence, it creates a new `Counter` that produces
the values `1`, `2`, and `3`. The `flatMap(_:)` method “flattens” the
resulting sequence-of-sequences into a single `AsyncSequence`.

    
    
    let stream = Counter(howHigh: 5)
        .flatMap { Counter(howHigh: $0) }
    for await number in stream {
        print(number, terminator: " ")
    }
    // Prints "1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async throws -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.
`transform` can also throw an error, which ends the transformed sequence.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces.
Also, the dictionary doesn’t provide a key for `4`, and the closure throws an
error for any key it can’t look up, so receiving this value from `Counter`
ends the modified sequence with an error.

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
    
    
    do {
        let stream = Counter(howHigh: 5)
            .map { (value) throws -> String in
                guard let roman = romanNumeralDict[value] else {
                    throw MyError()
                }
                return roman
            }
        for try await numeral in stream {
            print(numeral, terminator: " ")
        }
    } catch {
        print("Error: \(error)")
    }
    // Prints "I II III Error: MyError() "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# map(_:)

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func map<Transformed>(_ transform: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>

##  Parameters

`transform`

    

A mapping closure. `transform` accepts an element of this sequence as its
parameter and returns a transformed value of the same or of a different type.

## Return Value

An asynchronous sequence that contains, in order, the elements produced by the
`transform` closure.

## Discussion

Use the `map(_:)` method to transform every element received from a base
asynchronous sequence. Typically, you use this to transform from one type of
element to another.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `5`. The closure provided to the `map(_:)` method takes
each `Int` and looks up a corresponding `String` from a `romanNumeralDict`
dictionary. This means the outer `for await in` loop iterates over `String`
instances instead of the underlying `Int` values that `Counter` produces:

    
    
    let romanNumeralDict: [Int: String] =
        [1: "I", 2: "II", 3: "III", 5: "V"]
    
    
    let stream = Counter(howHigh: 5)
        .map { romanNumeralDict[$0] ?? "(unknown)" }
    for await numeral in stream {
        print(numeral, terminator: " ")
    }
    // Prints "I II III (unknown) V "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(_:)

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func prefix(_ count: Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`count`

    

The maximum number of elements to return. The value of `count` must be greater
than or equal to zero.

## Return Value

An asynchronous sequence starting at the beginning of the base sequence with
at most `count` elements.

## Discussion

Use `prefix(_:)` to reduce the number of elements produced by the asynchronous
sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(_:)` method causes the modified sequence
to pass through the first six values, then end.

If the count passed to `prefix(_:)` exceeds the number of elements in the base
sequence, the result contains all of the elements in the sequence.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Instance Method

# prefix(while:)

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func prefix(while predicate: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether the element should be included in the modified sequence.

## Return Value

An asynchronous sequence of the initial, consecutive elements that satisfy
`predicate`.

## Discussion

Use `prefix(while:)` to produce values while elements from the base sequence
meet a condition you specify. The modified sequence ends when the predicate
closure returns `false`.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `prefix(while:)` method causes the modified
sequence to pass along values so long as they aren’t divisible by `2` and `3`.
Upon reaching `6`, the sequence ends:

    
    
    let stream = Counter(howHigh: 10)
        .prefix { $0 % 2 != 0 || $0 % 3 != 0 }
    for try await number in stream {
        print(number, terminator: " ")
    }
    // Prints "1 2 3 4 5 "
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(_:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        _ initialResult: Result,
        _ nextPartialResult: (Result, Product.SubscriptionInfo.Status) async throws -> Result
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure runs.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(_:_:)` method to produce a single value from the elements of
an entire sequence. For example, you can use this method on an sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `4`. The `reduce(_:_:)` method sums the values received
from the asynchronous sequence.

    
    
    let sum = await Counter(howHigh: 4)
        .reduce(0) {
            $0 + $1
        }
    print(sum)
    // Prints "10"
    

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(into: Result, (inout Result,
Product.SubscriptionInfo.Status) -> Void) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

Generic Instance Method

# reduce(into:_:)

Returns the result of combining the elements of the asynchronous sequence
using the given closure, given a mutable initial value.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func reduce<Result>(
        into initialResult: Result,
        _ updateAccumulatingResult: (inout Result, Product.SubscriptionInfo.Status) async throws -> Void
    ) async rethrows -> Result

##  Parameters

`initialResult`

    

The value to use as the initial accumulating value. The `nextPartialResult`
closure receives `initialResult` the first time the closure executes.

`nextPartialResult`

    

A closure that combines an accumulating value and an element of the
asynchronous sequence into a new accumulating value, for use in the next call
of the `nextPartialResult` closure or returned to the caller.

## Return Value

The final accumulated value. If the sequence has no elements, the result is
`initialResult`.

## Discussion

Use the `reduce(into:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on a sequence of
numbers to find their sum or product.

The `nextPartialResult` closure executes sequentially with an accumulating
value initialized to `initialResult` and each element of the sequence.

Prefer this method over `reduce(_:_:)` for efficiency when the result is a
copy-on-write type, for example an `Array` or `Dictionary`.

## See Also

### Transforming elements

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps an error-throwing closure over the
base sequence’s elements, omitting results that don’t return a value.

`func compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) ->
ElementOfResult?) ->
AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses,
ElementOfResult>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements, omitting results that don’t return a value.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given error-throwing transformation with each element of this sequence.

`func flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) ->
SegmentOfResult) ->
AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses,
SegmentOfResult>`

Creates an asynchronous sequence that concatenates the results of calling the
given transformation with each element of this sequence.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses,
Transformed>`

Creates an asynchronous sequence that maps the given error-throwing closure
over the asynchronous sequence’s elements.

`func map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) ->
AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>`

Creates an asynchronous sequence that maps the given closure over the
asynchronous sequence’s elements.

`func prefix(Int) ->
AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, up to the specified maximum length,
containing the initial elements of the base asynchronous sequence.

`func prefix(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Returns an asynchronous sequence, containing the initial, consecutive elements
of the base sequence that satisfy the given predicate.

`func reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) ->
Result) -> Result`

Returns the result of combining the elements of the asynchronous sequence
using the given closure.

Instance Method

# drop(while:)

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @preconcurrency
    func drop(while predicate: @escaping @Sendable (Product.SubscriptionInfo.Status) async -> Bool) -> AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`predicate`

    

A closure that takes an element as a parameter and returns a Boolean value
indicating whether to drop the element from the modified sequence.

## Return Value

An asynchronous sequence that skips over values from the base sequence until
the provided closure returns `false`.

## Discussion

Use `drop(while:)` to omit elements from an asynchronous sequence until the
element received meets a condition you specify.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `drop(while:)` method causes the modified
sequence to ignore received values until it encounters one that is divisible
by `3`:

    
    
    let stream = Counter(howHigh: 10)
        .drop { $0 % 3 != 0 }
    for await number in stream {
        print(number, terminator: " ")
    }
    // Prints "3 4 5 6 7 8 9 10 "
    

After the predicate returns `false`, the sequence never executes it again, and
from then on the sequence passes through elements from its underlying sequence
as-is.

## See Also

### Excluding elements

`func dropFirst(Int) ->
AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>`

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

Instance Method

# dropFirst(_:)

Omits a specified number of elements from the base asynchronous sequence, then
passes through all remaining elements.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>

##  Parameters

`count`

    

The number of elements to drop from the beginning of the sequence. `count`
must be greater than or equal to zero.

## Return Value

An asynchronous sequence that drops the first `count` elements from the base
sequence.

## Discussion

Use `dropFirst(_:)` when you want to drop the first _n_ elements from the base
sequence and pass through the remaining elements.

In this example, an asynchronous sequence called `Counter` produces `Int`
values from `1` to `10`. The `dropFirst(_:)` method causes the modified
sequence to ignore the values `1` through `3`, and instead emit `4` through
`10`:

If the number of elements to drop exceeds the number of elements in the
sequence, the result is an empty sequence.

## See Also

### Excluding elements

`func drop(while: (Product.SubscriptionInfo.Status) -> Bool) ->
AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>`

Omits elements from the base asynchronous sequence until a given closure
returns false, after which it passes through all remaining elements.



# SKCloudServiceSetupViewController

Instance Property

# delegate

The cloud service view controller's delegate.

iOS 10.1+  iPadOS 10.1+  Mac Catalyst 13.1+

    
    
    weak var delegate: (any SKCloudServiceSetupViewControllerDelegate)? { get set }

## Discussion

You can identify a delegate to get informed when the cloud service setup view
controller is dismissed.

## See Also

### Setting a Delegate

`protocol SKCloudServiceSetupViewControllerDelegate`

A protocol that defines the methods a cloud service setup view controller can
use to get the status of the view, including when it is dismissed.

Article

# Offering Apple Music Subscription in Your App

Allow eligible users to subscribe to Apple Music library.

## Overview

With an Apple Music membership, users can play songs from the entire Apple
Music catalog or access their iCloud music library across all their devices.
You can offer users the option to sign up for an Apple Music subscription
directly from your app by following these steps:

  1. Request Apple Music Library access from the user.

  2. Determine if the user is eligible for an Apple Music subscription. 

  3. Present the sign-up subscription offer if the user is eligible.

### Request Apple Music Library Access

The user must grant permission before your app can access Apple Music library.
See Requesting Access to Apple Music Library for details. Use
`authorizationStatus()` to determine your app’s authorization status. If the
authorization status is `SKCloudServiceAuthorizationStatus.authorized`, your
app can check if the user is eligible for an Apple Music subscription offer.

Important

When the Music app is absent on the user’s device,
`load(options:completionHandler:)` fails to load.

### Determine if the User is Eligible for an Apple Music Subscription

After getting Apple Music access from the user, call
`requestCapabilities(completionHandler:)` on an instance of
`SKCloudServiceController` to query the user’s capabilities. Then, inspect the
`capabilities` parameter of this method to determine eligibility. See
Determining a User’s Apple Music Capabilities for details. A user has an
active subscription to Apple Music when `capabilities` contains
`musicCatalogPlayback`. A user is eligible for the offer when `capabilities`
doesn’t include `musicCatalogPlayback` but contains
`musicCatalogSubscriptionEligible`.

### Present the Offer to Subscribe for Apple Music

For users who are eligible for an Apple Music subscription, use the following
steps to allow users to sign up for it.

First, create a dictionary with an `action` key to `subscribe`:

If you have an iTunes Store affiliate account, you can add the
`affiliateToken` key to the dictionary to earn commision if the user
subscribes:

By default, the setup view is configured with the `messageIdentifier` key set
to `join`. Add `messageIdentifier` to the dictionary and set it to `addMusic`,
`connect`, or `playMusic` if you wish to change the default message that your
app shows to the user:

Next, create an `SKCloudServiceSetupViewController` object and set the view
controller class as its delegate:

Then, pass the dictionary to the `load(options:completionHandler:)` method of
the `SKCloudServiceSetupViewController` object. Finally, present the
`SKCloudServiceSetupViewController` object modally from your app:

## See Also

### Loading the Setup View

`func load(options: [SKCloudServiceSetupOptionsKey : Any], completionHandler:
((Bool, (any Error)?) -> Void)?)`

Loads the cloud service setup view with the specified options.

`struct SKCloudServiceSetupOptionsKey`

Keys used to specify the types of setup options for a cloud service.

Instance Method

# load(options:completionHandler:)

Loads the cloud service setup view with the specified options.

iOS 10.1+  iPadOS 10.1+  Mac Catalyst 13.1+

    
    
    func load(
        options: [SKCloudServiceSetupOptionsKey : Any] = [:],
        completionHandler: ((Bool, (any Error)?) -> Void)? = nil
    )

##  Parameters

`options`

    

A key that identifies the type of setup the user needs to do. See
`SKCloudServiceSetupOptionsKey` for possible values.

`completionHandler`

    

A block that is called when the setup view has loaded. The block takes the
following parameters:

`result`

A Boolean value that indicates whether the view controller has loaded the view
and can be presented.

`error`

An error value that indicates the reason for failure. Possible values are
`SKError.Code.unknown`, `SKError.Code.cloudServicePermissionDenied`, and
`SKError.Code.cloudServiceNetworkConnectionFailed`.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

## See Also

### Loading the Setup View

Offering Apple Music Subscription in Your App

Allow eligible users to subscribe to Apple Music library.

`struct SKCloudServiceSetupOptionsKey`

Keys used to specify the types of setup options for a cloud service.



# SKStoreReviewController

Type Method

# requestReview(in:)

Tells StoreKit to ask the user to rate or review the app, if appropriate,
using the specified scene.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    @MainActor
    class func requestReview(in windowScene: UIWindowScene)

##  Parameters

`windowScene`

    

The window scene that StoreKit uses to present the rating and review request
interface.

## Discussion

When you call this method in your shipping app and the system displays a
rating and review request view, the system handles the entire process for you.
Although you normally call this method when it makes sense in the user
experience flow of your app, App Store policy governs the actual display of a
rating and review request view. When your app calls this API, StoreKit uses
the following criteria::

  * If the person hasn’t rated or reviewed your app on this device, StoreKit displays the ratings and review request a maximum of three times within a 365-day period.

  * If the person has rated or reviewed your app on this device, StoreKit displays the ratings and review request if the app version is new, and if more than 365 days have passed since the person’s previous review.

Note

Because this method may not present an alert, don’t call `requestReview()` or
`requestReview(in:)` in response to a button tap or other user action.

It’s up to your app to decide on the best timing for requesting reviews. For
design guidance, see Human Interface Guidelines > Ratings and reviews.

### Test review requests

When your app calls this method while it’s in development mode, StoreKit
always displays the rating and review request view, so you can test the user
interface and experience. However, this method has no effect in apps that you
distribute for beta testing using TestFlight.

### Provide a persistent link to your product page (optional)

Your customers can review your app at any time on the App Store. To make it
easier for people to leave reviews, you may include a persistent link to your
App Store product page in your app’s settings or configuration screens. Append
the query parameter `action=write-review` to your product page URL to
automatically open the App Store page where users can write a review.

## See Also

### Indicating an appropriate time for a review

`class func requestReview()`

Tells StoreKit to ask the user to rate or review your app, if appropriate.

Type Method

# requestReview()

Tells StoreKit to ask the user to rate or review your app, if appropriate.

iOS 10.3–14.0  Deprecated  iPadOS 10.3–14.0  Deprecated  macOS 10.14+  Mac
Catalyst 13.1–14.0  Deprecated

    
    
    class func requestReview()

Deprecated

For iOS, iPadOS, and apps built with Mac Catalyst, use `requestReview(in:)`
instead.

## Discussion

Although you normally call this method when it makes sense in the user
experience flow of your app, App Store policy governs the actual display of a
rating and review request view. Because this method may not present an alert,
it isn’t appropriate to call `requestReview()` or `requestReview(in:)` in
response to a button tap or other user action.

Note

When you call this method while your app is in development mode, a rating and
review request view is always displayed so you can test the user interface and
experience. However, this method has no effect when you call it in an app that
you distribute using TestFlight.

When you call this method in your shipping app and the system displays a
rating and review request view, the system handles the entire process for you.
In addition, you can continue to include a persistent link in the settings or
configuration screens of your app that links to your App Store product page.
To automatically open a page on which users can write a review in the App
Store, append the query parameter `action=write-review` to your product URL.

## See Also

### Indicating an appropriate time for a review

`class func requestReview(in: UIWindowScene)`

Tells StoreKit to ask the user to rate or review the app, if appropriate,
using the specified scene.



# SKProductDiscount.Type

Enumeration Case

# SKProductDiscount.Type.introductory

A constant indicating the discount type is an introductory offer.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case introductory = 0

## Discussion

For more information, see Implementing introductory offers in your app.

## See Also

### Types of Offers

`case subscription`

A constant indicating the discount type is a promotional offer.

Enumeration Case

# SKProductDiscount.Type.subscription

A constant indicating the discount type is a promotional offer.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case subscription = 1

## Discussion

For more information about promotional offers, see Implementing promotional
offers in your app.

## See Also

### Types of Offers

`case introductory`

A constant indicating the discount type is an introductory offer.

Enumeration Case

# SKProductDiscount.Type.introductory

A constant indicating the discount type is an introductory offer.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case introductory = 0

## Discussion

For more information, see Implementing introductory offers in your app.

## See Also

### Types of Offers

`case subscription`

A constant indicating the discount type is a promotional offer.

Enumeration Case

# SKProductDiscount.Type.subscription

A constant indicating the discount type is a promotional offer.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.1+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+

    
    
    case subscription = 1

## Discussion

For more information about promotional offers, see Implementing promotional
offers in your app.

## See Also

### Types of Offers

`case introductory`

A constant indicating the discount type is an introductory offer.



# In-App Purchase

Article

# Supporting promoted in-app purchases in your app

Display promoted in-app purchases on your product page and handle purchases
that users initiate on the App Store.

## Overview

With iOS, you can promote in-app purchases so users can browse them directly
on the App Store. Promoted in-app purchases display on your product page,
appear in search results, and may be featured on an appropriate tab on the App
Store. Users can start a purchase on the App Store, which takes them into your
app to continue the transaction.

If your app isn’t installed when the user selects to purchase the in-app
product, the App Store automatically downloads the app or prompts the user to
purchase it. If the installed version of your app is an older version that
doesn’t support in-app purchase promotions, the App Store prompts the user to
upgrade the app.

Promoting in-app purchases requires two steps:

  1. In your app, starting in iOS 16.4, implement `PurchaseIntent` to complete the purchase users initiate on the App Store. To support this feature in apps that run in iOS 11–16.3, see Promoting in-app purchases.

  2. In App Store Connect, configure promoted in-app purchases. For more information, see Promote in-app purchases.

Important

To enable promoted in-app purchases, your app needs to use either
`PurchaseIntent` (starting in iOS 16.4) or
`paymentQueue(_:shouldAddStorePayment:for:)` (starting in iOS 11). Don’t use
both at the same time. If necessary, use conditional compilation to identify
the OS version the app is running in. For more information, see Running code
on a specific platform or OS version.

You can optionally customize which promoted in-app purchases a users sees on a
specific device using the `Product.PromotionInfo` API. Using
`Product.PromotionInfo` isn’t required for your promoted in-app purchases to
appear on the App Store.

For marketing guidance on this feature, see Promoting Your In-App Purchases.

To test promoted in-app purchases, see Testing promoted in-app purchases.

Note

Promoted in-app purchases aren’t available to compatible iPad or iPhone apps
running in visionOS.

### Set up promoted in-app purchases using App Store Connect

In App Store Connect, set up promoted in-app purchases by uploading
promotional images. Use the App Store Promotions feature in App Store Connect
to manage their default order and visibility. For more information about the
setup, see Promote in-app purchases.

### Complete the purchase in your app

When users initiate an in-app purchase on the App Store, StoreKit
automatically opens your app and sends the product information in the
`intents` asynchronous sequence of `PurchaseIntent`. Your app needs to
complete the purchase transaction and perform any related actions that are
specific to it.

To complete the transaction, call the `purchase(options:)` method on the
`product` of the `PurchaseIntent`. Follow the same workflow your app uses for
any in-app purchase, such as unlocking the purchased content and finishing the
transaction (`finish()`).

The following code example listens for purchase intents from the App Store. It
receives a `Product` object when the user taps a promoted in-app purchase on
the App Store, and performs its purchase workflow.

### Defer or cancel the purchase

In some cases, your app may need to defer or cancel the purchase transaction.
For example, you may need to defer the transaction if the user is in the
middle of onboarding, and complete it after they finish. Or, you may need to
cancel the transaction if the user has already unlocked the product they’re
trying to buy.

To defer the transaction, store the purchase intent and process it later after
the user finishes onboarding or other actions that require deferring.

To cancel the transaction, don’t call `purchase(options:)`. Instead, provide
feedback to the user. Although this step is optional, if you don’t provide
feedback, the app’s lack of action after the user initiates the purchase on
the App Store may seem like a bug.

### Customize promoted product order and visibility on a device

To customize promoted in-app purchases on a device, you can override their
default order and visibility using `Product.PromotionInfo`. Use it to show
only promotions that are relevant to your user, based on their experience with
your app, or based on their previous purchases. For example, suppose a game
has in-app purchases to promote for each game level. You can show only the
promoted products for the user’s game level, and hide those they already
purchased.

To control whether a promoted in-app purchase appears in the App Store on the
device, use any of these methods:

  * Add or remove it from the list. Set the product order by calling `updateAll(_:)` or `updateProductOrder(byID:)`. Leave out the products you don’t want to display.

  * Set its visibility. Show or hide the product by setting its `visibility` value and calling `update()` or `updateAll(_:)`, or call `updateProductVisibility(_:for:)`. 

These overrides are specific to the device, and take effect after the user
launches the app at least once.

The following code example uses an array of product identifiers to set their
order. It calls `currentOrder` to get the `Product.PromotionInfo` objects, and
sets their visibility directly. It then calls `updateAll(_:)` to save the
changes.

The following code example hides a promoted product after the user purchases
it:

### Control a promotion's visibility from App Store Connect

To control a promotion’s visibility from App Store Connect, set its
`visibility` value in the app to the default of
`Product.PromotionInfo.Visibility.appStoreConnectDefault`. Products with this
value are visible or hidden based on the setting you configure in App Store
Connect. For more information about using App Store Connect, see Promote in-
app purchases.

For example, to promote a product on a holiday for all users, ensure the app
sets the product’s visibility to
`Product.PromotionInfo.Visibility.appStoreConnectDefault`. In App Store
Connect, start with its visibility set as hidden. On the holiday, use App
Store Connect to manually change the product to be visible. The promoted
product becomes visible in the App Store for all users automatically.

### Cancel overrides

To reset changes your app makes to the promoted products' order and
visibility, call the `updateAll(_:)` or `updateProductOrder(byID:)` methods
with an empty array. This cancels the overrides so the user can see the
promoted in-app purchases in their default order.

Call `currentOrder` to get a list of your overrides. If the list is empty, the
device displays promoted in-app purchases in their default order.

## See Also

### Promoted in-app purchases

`struct PurchaseIntent`

An instance that emits purchase intents, which indicates that the customer
initiated a promoted in-app purchase on the App Store for your app to
complete.

`struct Product.PromotionInfo`

Information about a promoted in-app purchase that customizes its order and
visibility on the device.

Testing promoted in-app purchases

Test your in-app purchases before making your app available in the App Store.

Article

# Testing promoted in-app purchases

Test your in-app purchases before making your app available in the App Store.

## Overview

Users can buy promoted in-app purchases from the App Store, but you need to
test this flow before making your product publicly available. Apple provides a
system URL that triggers your app using the `itms-services://` protocol, so
you can test in-app purchases before they’re available in the App Store.

**Protocol**| `itms-services://`  
---|---  
**Parameter** `action`| `purchaseIntent`  
**Parameter** `bundleId`| The bundle ID for your app; for
example:`com.example.app`  
**Parameter** `productIdentifier`| The in-app purchase product name you want
to test; for example:`product_name`  
  
The resulting URL looks like this:

`itms-
services://?action=purchaseIntent&bundleId=com.example.app&productIdentifier=product_name`

Send this URL to yourself in an email or iMessage, and open it from your
device. You’ll know the test is running when your app opens automatically. You
can then test how your app handles the promoted in-app purchase.

## See Also

### Promoted in-app purchases

Supporting promoted in-app purchases in your app

Display promoted in-app purchases on your product page and handle purchases
that users initiate on the App Store.

`struct PurchaseIntent`

An instance that emits purchase intents, which indicates that the customer
initiated a promoted in-app purchase on the App Store for your app to
complete.

`struct Product.PromotionInfo`

Information about a promoted in-app purchase that customizes its order and
visibility on the device.

Article

# Supporting subscription offer codes in your app

Provide subscription service for customers who redeem offer codes through the
App Store or within your app.

## Overview

To help you acquire, retain, and win back subscribers, you can use offer
codes. Offer codes are alphanumeric codes that provide subscriptions at a
discount or for free for a specific duration. Configure the offers and create
offer codes in App Store Connect, and distribute them to your customers.
Customers can redeem offer codes in the App Store, using offer code redemption
URLs, or in your app if you’ve implemented one of the following APIs:

  * `offerCodeRedemption(isPresented:onCompletion:)` or `presentOfferCodeRedeemSheet(in:)`, which are available in iOS 16 and later and iPadOS 16 and later

  * `presentCodeRedemptionSheet()`, which is available in iOS 14 and later and iPadOS 14 and later

When customers redeem a valid offer code, your app receives a successful
transaction. If customers redeem offer codes in the App Store and don’t have
your app installed, they’re prompted to download it as part of the redemption
flow. Successfully redeeming an offer code entitles the customer to the auto-
renewable subscription, the same as a purchase does. Your app needs to provide
service for the product.

### Set up offer codes in App Store Connect

Configure offers and manage your offer codes in App Store Connect. You can
have up to 10 active offers per subscription, and create codes for a maximum
of 1,000,000 redemptions per app, per quarter. There are two types of offer
codes: one-time use codes, and custom codes. The offer code redemption APIs
support both.

Download the offer codes from App Store Connect to distribute them to your
customers. For more information on creating and distributing offer codes, and
to learn which type of offer code may work for your campaign, see Set up offer
codes.

### Redeem offer codes in your app

To display the system sheet for customers to redeem offer codes within your
app, call one of the redemption APIs, depending on your app’s UI
implementation:

  * Call `offerCodeRedemption(isPresented:onCompletion:)` if your app uses SwiftUI.

  * Call `presentOfferCodeRedeemSheet(in:)` if your app uses UIKit.

  * Call `presentCodeRedemptionSheet()` for apps running on devices prior to iOS 16 and iPadOS 16.

The redemption sheet takes care of the redemption flow, including alerting
users about invalid entries, as appropriate. Invalid entries may include, for
example, expired offer codes, invalid codes, or codes that would result in a
subscription downgrade.

Including the redemption sheet in your app is recommended, but optional. For
more guidance on supporting offer code redemption within your app, see Human
Interface Guidelines > In-app purchase.

### Support offer codes redeemed outside of your app

Customers may redeem offer codes outside your app, by entering the offer code
in the App Store, or by using a redemption URL. To handle offer codes — and
other transactions that can occur outside of your app — your app needs to use
`updates` on `Transaction` to receive new transactions while the app is
running. Create a `Task` to iterate through the transactions from the listener
as soon as your app launches. For more information and sample code, see
`updates`.

When the app launches, it needs to check `all` or `currentEntitlements` on
`Transaction` to get any transactions that may have occurred while the app
wasn’t running. Process the transactions to ensure your app provides service
for all products it’s entitled to.

### Identify subscriptions purchased with offer codes

When customers successfully redeem subscription offer codes, the transaction
or subscription renewal information contain fields that identify the offer and
its offer type. Find the offer code details in the transaction information, in
your app and on your server, as follows.

In your app, use the following StoreKit APIs to locate the offer code
information:

  * See the `Transaction` properties `offerID` and `offerType`. An offer type value of `code` indicates the customer redeemed an offer code.

  * Some offer code redemptions may apply to an auto-renewable subscription’s next renewal period, for example, if the customer is already subscribed. In this case, see the `Product.SubscriptionInfo.RenewalInfo` properties `offerID` and `offerType`. An offer type value of `code` indicates the customer redeemed an offer code.

On your server, use the following server-side APIs to locate offer code
information:

  * In the App Store Server API, when you call endpoints such as Get Transaction History, Get All Subscription Statuses, and others, the response contains the signed transaction, `JWSTransaction`. In its decoded payload, `JWSTransactionDecodedPayload`, look for the fields `offerIdentifier` and `offerType`. An `offerType` value of `3` indicates the customer redeemed an offer code.

  * The App Store Server Notifications V2 sends a notification with an `OFFER_REDEEMED` `notificationType` when someone redeems an offer code. The decoded payloads `JWSTransactionDecodedPayload` and `JWSRenewalInfoDecodedPayload` contain the fields `offerIdentifier` and `offerType`. An `offerType` value of `3` indicates the customer redeemed an offer code.

### Provide subscription service to new and existing customers

When you acquire new customers with an offer code, they already have an auto-
renewable subscription when they open your app for the first time. In addition
to providing subscription service, you may need to update your backend
system’s records. Your app follows these steps:

  1. When the app launches, check `all` or `currentEntitlements` on `Transaction` to get all transactions or current entitlements, respectively. StoreKit automatically validates the transactions, and returns verified results in `VerificationResult.verified(_:)`. To perform your own validation, use the `jwsRepresentation` property.

  2. To determine if a subscription results from an offer code redemption, check the `offerID` and `offerType` properties on the subscription’s `Transaction`. 

  3. Provide the subscription service based on the offer and call `finish()` on `Transaction`. 

  4. Guide new customers through your new-user experience, as needed. Update your backend system’s records.

When an existing customer redeems an offer code within your app, the
transaction comes in through the `updates` sequence on `Transaction`. Process
the transaction as usual, providing service based on the offer, and call
`finish()`.

Article

# Testing at all stages of development with Xcode and the sandbox

Verify your implementation of in-app purchases by testing your code throughout
its development.

## Overview

Use the Apple sandbox and Xcode test environments to test your implementation
of in-app purchases using the StoreKit framework. Comprehensive testing can
help you:

  * Ensure a seamless purchase flow to provide a positive customer experience in your app.

  * Implement sound logic that covers all scenarios, such as purchases, restores, and subscription offers.

  * Validate that purchases behave correctly in production after your app is available in the App Store.

The tools you need to test in-app purchases, non-renewing subscriptions, and
auto-renewable subscriptions from early development through beta testing are:

StoreKit Testing in Xcode

    

For early development, continuous integration, and debugging. For more
information, see StoreKit Test.

Sandbox

    

For testing scenarios using in-app purchase data you set up in App Store
Connect. For more information, see Testing in-app purchases with sandbox.

TestFlight

    

For managing beta testing with internal and external testers. TestFlight uses
a beta build of your app or App Clip that you upload to App Store Connect. For
more information, see Beta Testing Made Simple with TestFlight.

Choose the tools that support the test scenarios you need. Make sure you’re
able to perform the setup required for the tools you choose.

During the early stages of development, you may not be ready to configure in-
app purchases in App Store Connect. StoreKit Testing in Xcode lets you
configure the information locally. You can test StoreKit transactions before
you create Sandbox Apple IDs, without a network connection. You can test your
app in Simulator or on real devices.

After you set up in-app purchases in App Store Connect, start using the
sandbox environment to test the product information your app will use in
production. Testing in the sandbox lets you test transactions from end-to-end
and from your app to your server. You can also test any server-to-server
functionalities your app depends on, such as transaction validation and App
Store Server Notifications.

TestFlight lets you get feedback from members of your team or from external
testers. TestFlight uses the sandbox environment for in-app purchases.
Transactions and purchases that occur in the sandbox don’t incur charges. The
following table compares the test environments and features:

Test environment| Requires App Store Connect setup| Provides receipts and JSON
Web Signature (JWS) transactions signed by the App Store| Provides
subscription renewal information signed by the App Store  
---|---|---|---  
StoreKit Testing in Xcode| No| No (signed by Xcode)| No (signed by Xcode)  
Sandbox| Yes| Yes| Yes  
TestFlight (uses the sandbox)| Yes| Yes| Yes  
  
None of the test environments charge users when they test buying a product.
The App Store doesn’t send emails for purchases or refunds made in the test
environments.

### Control the test environment

To set up and run test scenarios, you often need to control the test
environment. For example, you may want to reset a test account to rerun the
same test multiple times, or mimic actions users take outside your app that
affect the test conditions. The following table shows the capabilities each
tool has to control the test environment:

Test scenario| Sandbox| StoreKit Testing in Xcode  
---|---|---  
Test different storefronts to affect price tiers and locale| Yes| Limited (no
price tiers)  
Clear the purchase history| Yes| Yes  
Test subscription upgrades, downgrades, cross-grades, and auto-renew
cancellations| Yes| Yes  
Reset eligibility for introductory offers| Yes| Yes  
Introduce forced StoreKit errors for testing| No| Yes  
Speed up or slow down the rate of time for testing subscription renewals| Yes|
Yes  
  
For more information about speeding up renewal periods for testing, see Test
in-app purchases.

### Test common StoreKit scenarios

All apps that offer in-app purchases need to support restoring purchases,
displaying in-app purchases to the customer, and handling basic transactions.
The following table lists common test scenarios and whether they’re testable
in the sandbox or Xcode:

Test scenario| Sandbox| StoreKit Testing in Xcode  
---|---|---  
Restore purchases| Yes| Yes  
Finish a transaction with `finish()` or `finishTransaction(_:)`| Yes| Yes  
Buy a consumable or non-consumable in-app purchase| Yes| Yes  
Repurchase a non-consumable purchase for repeated testing| Yes| Yes  
Purchase an auto-renewable subscription| Yes| Yes  
Purchase a non-renewing subscription| Yes| Yes  
Refund an in-app purchase| Yes| Yes  
Test an interrupted purchase, where the user must complete actions outside the
app| Yes| Yes  
Test a failed purchase attempt when payment authorization fails| No| Yes  
Retrieve configured in-app purchases from App Store Connect| Yes| Yes
(optionally); can also retrieve data from a StoreKit configuration file  
Manage subscriptions within your app with `showManageSubscriptions(in:)` and
`manageSubscriptionsSheet(isPresented:)`| Yes| Yes  
Initiate a refund request. For more information, see Testing refund requests.|
Yes| Yes  
  
### Test subscriptions and Ask to Buy

Depending on the in-app purchases your app offers, you may need to test
scenarios that involve auto-renewing subscriptions, introductory offers,
promotional offers, and Ask to Buy. The following table lists test scenarios
and whether they’re testable in the sandbox or Xcode:

Test scenario| Sandbox| StoreKit Testing in Xcode  
---|---|---  
Initiate an Ask to Buy transaction that results in a deferred state| Yes| Yes  
Resolve an Ask to Buy transaction by approving or rejecting it| No| Yes  
Redeem an introductory offer for an auto-renewable subscription| Yes| Yes  
Redeem a promotional offer for an auto-renewable subscription| Yes| Yes  
Redeem an offer code for an auto-renewable subscription| No| Yes  
Process a subscription renewal| Yes| Yes  
Process a revoked or refunded subscription| Yes| Yes  
Respond to a customer canceling a subscription and disabling auto-renew| Yes|
Yes  
Respond to an expired subscription| Yes| Yes  
Process a subscription upgrade or downgrade| Yes| Yes  
Process a subscription cross-grade with the same or different duration| Yes|
Yes  
Test a price increase for an auto-renewable subscription| No| Yes  
Test billing retry and billing grace period| No| Yes  
  
For more information, see Approve what kids buy with Ask to Buy and Testing
introductory offers.

## See Also

### Testing in-app purchases

Testing in-app purchases with sandbox

Test your implementation of in-app purchases using real product information
and server-to-server transactions in the sandbox environment.

Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

Article

# Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

## Overview

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests, which enable your customers to request a refund from within
your app. Your app displays the refund request sheet by calling any of these
methods: `beginRefundRequest(for:in:)` , `beginRefundRequest(in:)`,
`beginRefundRequest(for:in:)`, `beginRefundRequest(in:)`, or
`refundRequestSheet(for:isPresented:onDismiss:)`. Customers fill out the sheet
to submit the request.

Depending on your testing setup, the App Store automatically approves or
declines the refund request in the testing environment. Note that the App
Store doesn’t send emails for refund requests in testing environments.

### Test approved refunds

To set up a test for approved refunds, select any refund reason on the refund
request sheet, and submit the sheet. The App Store automatically approves the
refund request in the testing environment.

Your app receives a `Transaction` with refund information in the
`revocationDate` and `revocationReason` properties. If you’re testing in the
sandbox environment and your server receives App Store Server Notifications V2
for the sandbox, it gets a notification with a `REFUND` `notificationType`.

### Test declined refunds

To set up a test for declined refunds, follow these steps on the refund
request sheet with your app running in the sandbox environment:

  1. Under Issue, select Other.

  2. In the text box, type REJECT.

  3. Tap Request Refund.

The App Store automatically rejects the refund request in the testing
environment.

If your server receives App Store Server Notifications V2 for the sandbox
environment, it gets a notification with a `REFUND_DECLINED`
`notificationType`.

For more information on receiving server notifications for the sandbox
environment, see Enabling App Store Server Notifications. For more information
on testing, see Testing at all stages of development with Xcode and the
sandbox and Setting up StoreKit Testing in Xcode.

## See Also

### Testing in-app purchases

Testing at all stages of development with Xcode and the sandbox

Verify your implementation of in-app purchases by testing your code throughout
its development.

Testing in-app purchases with sandbox

Test your implementation of in-app purchases using real product information
and server-to-server transactions in the sandbox environment.

Article

# Choosing a StoreKit API for in-app purchases

Use the latest API to support in-app purchases in new or existing apps, or the
original API to support in-app purchases in earlier operating systems.

## Overview

The StoreKit framework provides two APIs to implement a store in your app and
offer in-app purchases:

  * In-App Purchase is a Swift-based API that provides App Store-signed transactions in JSON Web Signature (JWS) format, available starting in iOS 15, macOS 12, tvOS 15, watchOS 8, and visionOS 1.

  * Original API for in-app purchase provides transaction information using App Store receipts, available starting in iOS 3, macOS 10.7, tvOS 9, watchOS 6.2, and visionOS 1.

If your app has a minimum required operating system that the In-App Purchase
API supports, use this API to take advantage of Swift concurrency and
simplified in-app purchase workflows. Use this API for visionOS apps that use
multiple scenes.

Use the Original API for in-app purchase to maintain and update app versions
that have a minimum required operating system of the following versions: macOS
11 or earlier, iOS 14 or earlier, iPadOS 14 or earlier, tvOS 14 or earlier, or
watchOS 7 or earlier.

An app can use both the In-App Purchase API and the Original API for in-app
purchase if the app runs in iOS 15, macOS 12, tvOS 15, watchOS 8, and visionOS
1 or later. However, only the In-App Purchase API supports multi-scene apps
for visionOS.

Both APIs provide access to your data in the App Store, such as your
configured in-app purchases and transaction information for your customers.
In-app purchases that users make using either API are fully available to both
APIs.

### Use the In-App Purchase API to access new features

The following features are available only with the Swift-based In-App Purchase
APIs:

  * StoreKit views, which provide the UI to build a store in your app

  * Refund request sheets, such as `beginRefundRequest(for:in:)`, that enable customers to request refunds

  * Information about a subscription's renewal status, such as auto-renew preferences. For more information, see `Product.SubscriptionInfo.Status`.

  * Information about available promotional offers and a subscriber’s eligibility for an introductory offer. For more information, see `Product.SubscriptionInfo`.

  * Deferring or suppressing Billing Issue messages that the system displays. For more information, see `Message`.

  * Presenting the App Store sheet for managing subscriptions. For more information, see `showManageSubscriptions(in:subscriptionGroupID:)`.

  * Transaction information in JSON Web Signature (JWS) format. For more information, see `Transaction`.

### Use the Original API to support certain features

You might need to use the Original API for in-app purchase for the following
features, if your app supports them:

  * Promoting in-app purchases in apps that run in iOS 11 through 16.3. For more informaton, see Promoting in-app purchases. For information about this feature in iOS 16.4, see Supporting promoted in-app purchases in your app.

  * The Volume Purchase Program (VPP). For more information, see Device Management.

## See Also

### Original API for in-app purchase

API Reference

Original API for in-app purchase

Offer users additional content and services using the original In-App Purchase
API.



# CompactProductViewStyle

Type Property

# compact

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  Xcode 15.0+

    
    
    static var compact: CompactProductViewStyle { get }

Instance Method

# makeBody(configuration:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  Xcode 15.0+

    
    
    func makeBody(configuration: CompactProductViewStyle.Configuration) -> some View

## Relationships

### From Protocol

  * `ProductViewStyle`

## See Also

### Creating the style

`typealias CompactProductViewStyle.Body`

`init()`

Type Alias

# CompactProductViewStyle.Body

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  Xcode 15.0+

    
    
    typealias CompactProductViewStyle.Body = some View

## Relationships

### From Protocol

  * `ProductViewStyle`

## See Also

### Creating the style

`func makeBody(configuration: CompactProductViewStyle.Configuration) -> View`

`init()`

Initializer

# init()

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  Xcode 15.0+

    
    
    init()

## See Also

### Creating the style

`func makeBody(configuration: CompactProductViewStyle.Configuration) -> View`

`typealias CompactProductViewStyle.Body`



# SKAdNetwork

Article

# Signing and providing ads

Advertise apps by signing and providing StoreKit-rendered ads, view-through
ads, or attributable web ads.

## Overview

SKAdNetwork supports several ways for ad networks to provide ads:

  * StoreKit-rendered ads, where StoreKit displays an App Store product page as the ad impression

  * View-through ads, where the ad network presents an ad in any format and reports the ad impression using the SKAdNetwork API

  * Attributable web ads, where the ad network presents an ad on a Safari web page using the SKAdNetwork for Web Ads API

To differentiate StoreKit-rendered ads from view-through ads, SKAdNetwork
defines a `fidelity-type` parameter, which you include in the ad signature,
and receive in the install-validation postback. Use a `fidelity-type` value of
`1` for StoreKit-rendered ads and attributable web ads, and `0` for view-
through ads. The following table compares the ad presentation options:

Ad presentation option| Description| Fidelity type| Availability  
---|---|---|---  
StoreKit-rendered ads| App Store product page that StoreKit renders| `1`| All
SKAdNetwork versions  
View-through ads| Custom, from the ad network| `0`| SKAdNetwork 2.2 and later  
Attributable web ads (SKAdNetwork for Web Ads)| Custom, from the ad network|
`1`| SKAdNetwork 4 and later  
  
For more information about availability and versions, see SKAdNetwork release
notes.

The `fidelity-type` can affect which ad receives attribution when the user
experiences multiple ad impressions. For more information about how `fidelity-
type` and the time of the ad impression affect attributions, see Receiving ad
attributions and postbacks.

Ad networks must cryptographically sign the ads. The signature contains
information that includes a campaign identifier. If ads result in conversions,
ad networks receive an install-validation postback that includes the campaign
identifier. For more information about the postback, see Verifying an install-
validation postback.

### Provide a StoreKit-rendered ad

Follow these steps to display a StoreKit-rendered ad in your app:

  1. Set Ad network install-validation keys with values that represent the ad impression.

  2. On the ad network’s server, generate the signature using those key values. Then, set the `SKStoreProductParameterAdNetworkAttributionSignature` key with the signature value. For information about generating the signature, see Generating the signature to validate StoreKit-rendered ads.

  3. Call `loadProduct(withParameters:completionBlock:)` using your ad network install-validation keys to load the ad.

  4. Present the ad in your app according to your app’s design. You can use either an `SKOverlay` or an `SKStoreProductViewController` to display a StoreKit-rendered ad. The `fidelity-type` value of a StoreKit-rendered ad is `1` in either case.

### Provide a view-through ad

Follow these steps to provide a view-through ad:

  1. Create an `SKAdImpression` instance and set its properties to represent the ad impression.

  2. On the ad network’s server, generate the signature based on those properties. Then set the `signature` property in the `SKAdImpression` instance to the generated signature. For more information, see Generating the signature to validate view-through ads.

  3. Call `startImpression(_:completionHandler:)` and then present your custom ad to the user according to your app’s design.

  4. Call `endImpression(_:completionHandler:)` when you finish presenting the ad.

### Provide an attributable web ad

Ad networks can sign attributable ads that websites can display in Safari. For
more information, see SKAdNetwork for Web Ads.

## See Also

### Essentials

Receiving ad attributions and postbacks

Learn about timeframes and priorities for ad impressions that result in ad
attributions, and how additional impressions qualify for postbacks.

Receiving postbacks in multiple conversion windows

Learn about the data that postbacks may contain in each conversion window.

SKAdNetwork release notes

Learn about the features in each SKAdNetwork version.

Article

# Receiving ad attributions and postbacks

Learn about timeframes and priorities for ad impressions that result in ad
attributions, and how additional impressions qualify for postbacks.

## Overview

Ad networks receive attributions in the form of install-validation postbacks.
Before an ad network can receive a postback, the following events need to
occur within limited time-windows:

  * Ad networks sign and present ads in the form of StoreKit-rendered ads, view-through ads, or attributable web ads. StoreKit records the ad impressions.

  * Users install the advertised app.

  * Users launch the app.

  * The app updates the conversion values when the user first launches the app, and continues to update it as needed.

If all these events occur within their respective time-windows, the ad
impression qualifies for an install-validation postback. The following table
shows the time-windows for the events:

Event| Time-window  
---|---  
The ad network presents a StoreKit-rendered ad.| The user has 30 days to
install the app.  
The ad network presents a view-through ad.| The user has 24 hours to install
the app.  
The user taps an attributable web ad.| The user has 30 days to install the
app.  
The user installs the app.| The user has 60 days to launch the app.  
The user launches the app and the app calls any conversion update method, such as `updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`, | The device has 60 days after the user installs the app to send the first conversion value update.  
The user launches the app and the app calls a conversion update method, such
as `updatePostbackConversionValue(_:completionHandler:)` for ads signed with
version 3 or earlier.| For ads signed with version 3 or earlier, the device
sends install-validation postbacks 0–24 hours after a 24-hour timer expires
following the final call to update the conversion value. The total delay from
the final conversion update to receiving the postback is 24–48 hours.  
  
The minimum elapsed time between an ad impression and the time the ad network
receives an install-validation postback is 24 to 48 hours. To reduce that time
to 5 to 10 minutes during testing, see Testing ad attributions with a
downloaded profile.

Devices send one or more postbacks depending on the SKAdNetwork and iOS
versions:

  * For ads signed with SKAdNetwork 1 through 2.2, devices send a single, winning postback.

  * Starting in iOS 14.6 for ads signed with version 3.0 or later, devices send a single winning postback, and up to five nonwinning postbacks.

  * Starting in iOS 15, devices also send a copy of the winning postback to the advertised app’s developer, if the developer opts in to receive it. 

  * Starting in iOS 16.1 for ads signed using SKAdNetwork 4, devices can send up to three postbacks for the winning ad attribution, in three conversion windows.

Time-windows for events apply equally to winning and nonwinning postbacks.

### Receive a winning postback

When multiple ad impressions qualify for install-validation postbacks, a
device sends the winning postback to the ad network based on the following
rules:

  * In versions 1 through 2.1, the attribution goes to the most recent ad impression.

  * Starting in version 2.2, the attribution goes to the most recent ad impression with the highest `fidelity-type` value. 

The ad presentation option defines the `fidelity-type` value:

  * StoreKit-rendered ads have the highest `fidelity-type` value of `1`.

  * View-through ads have a `fidelity-type` value of `0`. 

Indicate the `fidelity-type` when you generate the ad signature. Recorded ad
impressions with a `fidelity-type` of `1` always take precedence over those
with a `fidelity-type` of `0`. For example, if users see a StoreKit-rendered
ad followed by a view-through ad for the same app, the StoreKit-rendered ad
takes precedence over the view-through ad, despite the view-through ad being
more recent. The source app can display StoreKit-rendered ads using an
`SKOverlay` or `SKStoreProductViewController`; the `fidelity-type` value is
`1` in either case. For information about the fidelity of ads that an ad
network presents on a Safari web page using the SKAdNetwork for Web Ads API,
see `signature`.

In version 3 and later, the system indicates winning postbacks with a `did-
win` parameter of value `true`.

### Receive a nonwinning postback

Starting in iOS 14.6, devices can send multiple postbacks to ad networks that
sign ads using version 3 or later. The system indicates nonwinning postbacks
with a `did-win` parameter of value `false`. These postbacks don’t include
`conversion-value` or `source-app-id`.

Each ad network can receive only one install-validation postback, winning or
not winning. If you receive the winning postback, you don’t receive any
nonwinning postbacks even if your ads have multiple qualifying ad impressions.

Up to five ad networks receive one nonwinning postback each. The system orders
the recorded ad impressions using recency and `fidelity-type`, with the most
recent ad views and highest `fidelity-type` taking precedence. Devices send
nonwinning postbacks for the top five ad impressions from different ad
networks that qualify for ad attribution.

### Opt in to receive a copy of the winning postback

Starting in iOS 15, devices can send a copy of the winning install-validation
postback to the developer of the advertised app. Developers opt in to receive
the postback by specifying a server endpoint in their app’s `Info.plist` file.
For more information about opting in and specifying the endpoint, see
Configuring an advertised app.

The postback that developers receive is an exact copy of the winning install-
validation postback that the device sends to the ad network. The device sends
the postback to developers at the same time it sends the winning postback to
the ad network. To verify the postback, see Verifying an install-validation
postback.

### Limit view-through ad impressions

StoreKit records a maximum of 15 view-through ad impressions per source app
before discarding the oldest one. The recorded ad impressions may advertise
various products, and are each eligible to become pending attributions until
they expire (after 24 hours).

### Test ad impressions and postbacks

Use the StoreKit Test framework to validate your ad impressions and test your
postbacks by creating unit tests. For more information, see `SKAdTestSession`
and Testing and validating ad impression signatures and postbacks for
SKAdNetwork.

## See Also

### Essentials

Signing and providing ads

Advertise apps by signing and providing StoreKit-rendered ads, view-through
ads, or attributable web ads.

Receiving postbacks in multiple conversion windows

Learn about the data that postbacks may contain in each conversion window.

SKAdNetwork release notes

Learn about the features in each SKAdNetwork version.

Article

# Receiving postbacks in multiple conversion windows

Learn about the data that postbacks may contain in each conversion window.

## Overview

SKAdNetwork supports three conversion windows that may result in up to three
postbacks for a winning ad attribution. The conversion window begins when the
user first launches the app. The first conversion window spans days 0 to 2;
the second window spans days 3 to 7; and the third window spans days 8 to 35.
Apps can update conversion values during all three time-windows.

To be eligible to receive multiple postbacks, all participants need to meet
the following conditions:

  * The ad network needs to sign the ad using SKAdNetwork 4 or later.

  * The advertised app needs to call `updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)` or `updatePostbackConversionValue(_:coarseValue:completionHandler:)`to update the conversion values during each conversion window.

You may receive a single postback in the following cases:

  * If the app's postback data tier is Tier 0, the system sends only the first postback.

  * Nonwinning ad attributions receive only the first postback.

  * For ads signed using SKAdNetwork 3 or earlier, you receive only one winning postback.

### Lock conversion values to receive postbacks sooner

By default, the system waits until the end of a conversion window to get the
final conversion value. Apps can continue to update the conversion value until
the end of the conversion window. When the conversion window ends, the system
prepares the postback and sends it after a random delay, as the following
diagram shows:

The random delay is 24–48 hours for the first postback, and 24–144 hours for
the second and third postbacks.

The
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
method provides an option for you to lock in and finalize a conversion value
before the conversion window ends. You may choose to lock the conversion value
in any or all conversion windows. The diagram below shows an app that locks
the conversion value during the second conversion window:

After receiving a locked conversion value, the system immediately prepares the
postback and ignores any further conversion value updates in the same
conversion window. The system sends the postbacks after the same random delay
following the locked conversion: a 24–48-hour delay for the first postback,
and a 24–144-hour delay for the second and third postbacks. The system ignores
further updates to the conversion value for the remaining time in the same
conversion window.

Note

The earliest you may receive the first postback is unchanged from version 3 to
version 4: the total delay is 24–48 hours after the app updates its final
conversion value.

  * In version 3, the app finalizes the conversion value when a 24-hour timer expires after the last conversion value update. Then, the device sends the postback after a random 0–24 hour delay, making the earliest postback 24–48 hours after the app sets the final conversion value.

  * In version 4, the app may finalize the conversion value by locking it. Then, the device sends the postback after a random 24–48 hour delay.

As a result, both version 3 and 4 have a total delay of 24–48 hours to receive
the first postback after the app finalizes the conversion value.

### Receive the highest level of data that ensures crowd anonymity

To maintain users’ privacy and ensure crowd anonymity, the device may limit
the data that SKAdNetwork sends in postbacks. Apple determines a postback data
tier that it assigns to each app download. The following diagram depicts the
relationship between the tiers and relative crowd sizes. It's for illustrative
purposes only.

The postback data tier takes into account the crowd size associated with the
app or domain displaying the ad, the advertised app, and the hierarchical
source identifier the ad network provides. The system computes the postback
data tier for the two-, three-, and four-digit hierarchical source
identifiers. It selects the source identifier with the highest postback data
tier. If multiple source identifiers share the highest postback data tier, the
system selects the source identifier with the most digits. If the highest
postback data tier is Tier 1 or Tier 0, the system always selects the two-
digit source identifier.

The postback data tier affects the following fields in the postback, which may
be present or absent, or may contain a limited number of digits:

  * `source-identifier`, the hierarchical source identifier that may include two, three, or four digits

  * `conversion-value`, a fine-grained conversion value available only in the first postback

  * `coarse-conversion-value`, a coarse conversion value, which the system sends instead of the `conversion-value` in lower postback data tiers, and in the second and third postbacks

  * `source-app-id` for ads that display in apps, or `source-domain` for attributable web ads

The remaining postback data fields aren't dependent on the postback date tier
and appear in all postbacks, based on the SKAdNetwork version of the
postback.``

### Receive the first postback

The first conversion window ends two days after the user first launches the
app. The system prepares the postback after the conversion window ends, unless
you use a lock. If you use a lock, the system prepares the first postback when
the app calls
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
with the lock in an enabled state. The system then sends the postback after a
random 24–48-hour delay.

The postback data tier determines the data you receive in the first postback,
as follows:

For ads in Tier 3, the first postback contains:

  * `source-identifier`, the hierarchical source identifer with two, three, or four digits

  * `conversion-value`, the fine-grained conversion value, if the app provides one

  * `source-app-id` for ads that display in apps, or `source-domain` for attributable web ads

For ads in Tier 2, the first postback contains:

  * `source-identifier`, the hierarchical source identifer with two, three, or four digits

  * `conversion-value`, the fine-grained conversion value, if the app provides one

For ads in Tier 1, the first postback contains:

  * `source-identifier`, the hierarchical source identifer with two digits

  * `coarse-conversion-value`, a coarse value, if the app provides one

For ads in Tier 0, the first postback contains the `source-identifier`, the
hierarchical source identifer, with two digits.

### Receive the second and third postbacks

The second conversion window ends seven days after the user first launches the
app, and the third conversion window ends after 35 days. The system prepares
the second and third postbacks after their conversion windows end, and sends
them after a random 24–144-hour delay.

If you use a lock with the second or third conversion value updates, the
system prepares the postback when you call
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
with the lock in an enabled state. The system sends the postback after a
random 24–144-hour delay.

The postback data tier determines the data you receive in the postbacks, as
follows:

For ads in Tier 1, Tier 2, and Tier 3, the second and third postbacks contain:

  * `source-identifier`, the hierarchical source identifer with two digits

  * `coarse-conversion-value`, the coarse conversion value, if the app provides one

For ads in Tier 0, the system doesn’t send a second or third postback.

Ads signed with version 4 and later are eligible for second and third
postbacks after a winning ad impression. Ads signed with version 3 and earlier
are eligible for one winning postback.

## See Also

### Essentials

Signing and providing ads

Advertise apps by signing and providing StoreKit-rendered ads, view-through
ads, or attributable web ads.

Receiving ad attributions and postbacks

Learn about timeframes and priorities for ad impressions that result in ad
attributions, and how additional impressions qualify for postbacks.

SKAdNetwork release notes

Learn about the features in each SKAdNetwork version.

Article

# Registering an ad network

Use the install-validation APIs for your ad campaigns after registering your
ad network with Apple.

## Overview

Ad networks provide and cryptographically sign ads that are eligible for ad
attribution through SKAdNetwork. Ad networks need to register with Apple
before using the SKAdNetwork API.

To register your ad network, go to Ad Network ID Request Form, which prompts
you to sign in to Apple Developer and opens the request form.

When registering, you:

  * Receive your ad network ID.

  * Create an elliptic curve cryptographic key pair and share your public key with Apple for signature verification.

  * Provide a URL for receiving SKAdNetwork install-validation postback requests.

### Share your ad network ID with developers

The ad network ID is a unique lowercased identifier in the format of
“`example123.skadnetwork`”. Share your ad network ID with app developers who
display your ads. Developers need to include your ad network ID in their app’s
information property list to initiate the app install-validation process.

Important

Lowercase the ad network ID string; otherwise, the system doesn’t recognize it
as valid.

### Generate your private key

Ad networks use a private cryptographic key to generate a signature for each
ad that an app displays. During registration, ad networks create a public-
private key pair, and send the public key to Apple. The private key you create
uses an Elliptic Curve Digital Signature Algorithm (ECDSA) with a prime256v1
curve.

To create your private key, open Terminal and enter the following command:

    
    
    openssl ecparam -name prime256v1 -genkey -noout -out companyname_skadnetwork_private_key.pem
    

In the command, replace `companyname` with the name of your company. For
example, the name of the private key file for a company named _Example_ is
`example_skadnetwork_private_key.pem`.

Important

Secure your private keys as you do other credentials, such as passwords. Don’t
share your private keys, store keys in a code repository, or include keys in
client-side code. Share only your public key.

### Generate and share your public key

Next, you create a public key from the private key you created in the previous
section. The public key is a PEM-encoded PKCS#8 EC key that uses the
prime256v1 curve. In Terminal, enter the following command, again replacing
`companyname` with the name of your company:

    
    
    openssl ec -in companyname_skadnetwork_private_key.pem -pubout -out companyname_skadnetwork_public_key.pem
    

This command creates the file `companyname_skadnetwork_public_key.pem`, which
contains your public key. Run this command any time to generate a copy of your
public key file.

Send your public key file to Apple when you register your ad network.

## See Also

### Registering ad networks and configuring apps

Configuring a source app

Set up a source app to participate in ad campaigns.

Configuring an advertised app

Prepare an advertised app to participate in ad campaigns.

`property list key SKAdNetworkItems`

An array of dictionaries containing a list of ad network IDs.

`property list key NSAdvertisingAttributionReportEndpoint`

The URL where Private Click Measurement and SKAdNetwork send attribution
information.

Article

# Configuring a source app

Set up a source app to participate in ad campaigns.

## Overview

A _source app_ is an app that participates in ad campaigns by displaying ads
that an ad network signs. To participate in install validation, the source app
needs to include ad network IDs in its `Info.plist` file. Ad networks are
responsible for publishing or providing their ad network IDs to developers.

Only ads from ad networks that have an entry in the app’s `Info.plist` file
are eligible for install validation. To work with multiple ad networks,
include each of the ad network IDs in the source app’s `Info.plist` file, as
follows:

  1. Select `Info.plist` in the Project navigator in Xcode.

  2. Click the Add button (+) beside a key in the property list editor and press Return.

  3. Type the key name `SKAdNetworkItems`.

  4. Choose Array from the pop-up menu in the Type column.

Create an array that contains one dictionary for each allowed ad network,
using the single key `SKAdNetworkIdentifier`. The string value for the key is
the ad network ID.

Important

Lowercase the ad network ID string; otherwise, the system doesn’t recognize it
as valid.

The following example shows an array with two dictionaries that represent the
example ad network IDs `example100.skadnetwork` and `example200.skadnetwork`:

    
    
    <array>
        <dict>
            <key>SKAdNetworkIdentifier</key>
            <string>example100.skadnetwork</string>
        </dict>
        <dict>   
             <key>SKAdNetworkIdentifier</key>
             <string>example200.skadnetwork</string>
        </dict>
    </array>
    
    
    

For more information about property lists, see Edit property lists.

## See Also

### Registering ad networks and configuring apps

Registering an ad network

Use the install-validation APIs for your ad campaigns after registering your
ad network with Apple.

Configuring an advertised app

Prepare an advertised app to participate in ad campaigns.

`property list key SKAdNetworkItems`

An array of dictionaries containing a list of ad network IDs.

`property list key NSAdvertisingAttributionReportEndpoint`

The URL where Private Click Measurement and SKAdNetwork send attribution
information.

Article

# Configuring an advertised app

Prepare an advertised app to participate in ad campaigns.

## Overview

An _advertised app_ is an app a user installs after viewing an ad that an ad
network signs. The advertised app doesn’t require any configuration to
participate in install validation. However, to register ad attributions, the
app needs to call one of the methods that update conversion values when the
app first launches. Those methods are:
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`,
`updatePostbackConversionValue(_:coarseValue:completionHandler:)`, and
`updatePostbackConversionValue(_:completionHandler:)`.

Developers opt in to get copies of winning install-validation postbacks.

### Configure your app to receive copies of winning install-validation
postbacks

To opt in to receive copies of winning install-validation postbacks for your
advertised app, add the `NSAdvertisingAttributionReportEndpoint` key in your
app’s `Info.plist` file, and configure your server to receive the postbacks.

To add the key in your app’s `Info.plist` file:

  1. Select `Info.plist` in the Project navigator in Xcode.

  2. Click the Add button (+) beside a key in the property list editor and press Return.

  3. Type the key name `NSAdvertisingAttributionReportEndpoint`.

  4. Choose String from the pop-up menu in the Type column.

  5. Type a valid URL in the format of `“https://example.com”` that contains your domain name in place of `example.com`.

For more information about editing property lists, see Edit property lists.

The system uses the registrable part of the domain name you provide in the
key, and ignores any subdomains. Using your domain name, the system generates
a _well-known path_ and sends postbacks to that URL. To receive postbacks,
your domain needs to have a valid SSL certificate. Configure your server to
accept HTTPS POST messages at the following well-known path:

`https://example.com/.well-known/skadnetwork/report-attribution/`

Replace `example.com` with your domain name.

For more information about receiving postbacks, see Receiving ad attributions
and postbacks.

## See Also

### Registering ad networks and configuring apps

Registering an ad network

Use the install-validation APIs for your ad campaigns after registering your
ad network with Apple.

Configuring a source app

Set up a source app to participate in ad campaigns.

`property list key SKAdNetworkItems`

An array of dictionaries containing a list of ad network IDs.

`property list key NSAdvertisingAttributionReportEndpoint`

The URL where Private Click Measurement and SKAdNetwork send attribution
information.

Property List Key

# SKAdNetworkItems

An array of dictionaries containing a list of ad network IDs.

iOS 11.3+  iPadOS 11.3+

##  Details

Type

    

array of dictionaries

## Discussion

Apps that display ads and initiate install-validation information to share
with ad networks need to include the ad network IDs in this key.

Each dictionary contains one `SKAdNetworkIdentifier`. Provide one dictionary
for each ad network that you work with.

Important

Ad network IDs are case-sensitive and are in lowercase.

For more information, see Configuring a source app.

## Topics

### Ad network identifiers

`property list key SKAdNetworkIdentifier`

A string that contains an ad network ID.

## See Also

### Registering ad networks and configuring apps

Registering an ad network

Use the install-validation APIs for your ad campaigns after registering your
ad network with Apple.

Configuring a source app

Set up a source app to participate in ad campaigns.

Configuring an advertised app

Prepare an advertised app to participate in ad campaigns.

`property list key NSAdvertisingAttributionReportEndpoint`

The URL where Private Click Measurement and SKAdNetwork send attribution
information.

Property List Key

# NSAdvertisingAttributionReportEndpoint

The URL where Private Click Measurement and SKAdNetwork send attribution
information.

iOS 14.5+  iPadOS 14.5+  visionOS 1.0+

##  Details

Type

    

string

## Discussion

This key is a string that contains a valid URL containing your domain name.
Provide a string in the format `“https://example.com”`, where you replace
`example` with your domain name. Include this key in your app for the
following two uses:

  * To specify where the system sends event attribution data it receives from launched websites that support Private Click Measurement (PCM). PCM won’t work if your app doesn’t include this key. 

  * To specify where the system sends a copy of the winning install-validation postback to the advertised app’s developer, for apps that are advertised using the `SKAdNetwork` API. Including this key is optional. 

The system sends postbacks to a well-known URL it generates using the domain
name you provide in the key. To receive the postbacks, configure your server
to receive HTTPS POST messages at the following endpoints:

  * To receive PCM event attribution data: `https://example.com/.well-known/private-click-measurement/report-attribution/`

  * To receive SKAdNetwork install-validation postbacks: `https://example.com/.well-known/skadnetwork/report-attribution/`

Replace `example.com` with your domain name. The system uses only the
registrable part of the domain name, and ignores any subdomains.

For more information about PCM and setting up a server to receive event
attribution data, see Introducing Private Click Measurement. For more
information about configuring an advertised app to enable its developer to
receive postbacks, see Configuring an advertised app and `SKAdNetwork`.

Note

Mac apps built with Mac Catalyst don’t support PCM.

## See Also

### Private Click Measurement (PCM)

`class UIEventAttributionView`

An overlay view that verifies user interaction for Web AdAttributionKit.

`class UIEventAttribution`

An object that contains event attribution information for Web
AdAttributionKit.

Article

# Generating the signature to validate view-through ads

Initiate install validation by displaying a view-through ad with signed
parameters.

## Overview

Install validation informs an ad network when users install and launch an app
they purchase after viewing an ad. Ad networks provide an ad with
cryptographically signed information that includes their ad network ID. If the
ad results in a conversion, the customer’s device sends install-validation
postbacks. For information about attribution-winning and nonwinning postbacks,
see Receiving ad attributions and postbacks.

Starting in iOS 14.5 with SKAdNetwork 2.2, ad networks can present view-
through ads to provide custom ads using any media.

Note

These instructions are for signing view-through ads. If you’re presenting a
StoreKit-rendered ad, see Generating the signature to validate StoreKit-
rendered ads.

To provide a view-through ad and initiate a validation, the app calls
`startImpression(_:completionHandler:)`, presents the ad, and then calls
`endImpression(_:completionHandler:)`. The ad network needs to generate the
`signature` in the `SKAdImpression` instance that both methods share.

Ad networks generate the signature on their server using their ad network ID
and the PKCS#8 private key they establish when registering to use the API. For
more information, see Registering an ad network.

### Create an ad impression instance

Create an instance of `SKAdImpression` to set the properties for the ad
impression. These properties contain the same values you use to generate the
signature.

The following table maps the parameters you use in the signature string to
their equivalent `SKAdImpression` properties, as the code example demonstrates
in the Combine parameter values section below:

Signature parameter| Equivalent properties  
---|---  
`version`| `version`. For view-through ads, use version 2.2 and later.  
`ad-network-id`| `adNetworkIdentifier`  
`campaign-id`| `adCampaignIdentifier` for version 3 or earlier. For version 4
and later, the `sourceIdentifier` replaces this parameter.  
`source-identifier`| `sourceIdentifier` for version 4 and later. This
parameter replaces the `adCampaignIdentifier` parameter.  
`itunes-item-id`| `advertisedAppStoreItemIdentifier`  
`nonce`| `adImpressionIdentifier`  
`source-app-id`| `sourceAppStoreItemIdentifier`  
`fidelity-type`| An additional parameter in the signature that isn't part of
`SKAdImpression`. Required for version 2.2 and later signatures. For view-
through ads, use a fidelity type value of `0`.  
`timestamp`| `timestamp`  
  
### Combine parameter values

The order and content of the signature parameters depends on the `version` of
the signature you're creating. Choose one of the parameter combinations below,
based on your `version`.

To generate a signature for version 4 or later, combine the signature
parameter values into a UTF-8 string with an invisible separator (`‘\u2063’`)
between them, in the exact order the code below shows:

    
    
    version + '\u2063' + ad-network-id + '\u2063' + source-identifier + '\u2063' + itunes-item-id + '\u2063' + nonce + '\u2063' + source-app-id + '\u2063' + fidelity-type + '\u2063' + timestamp
    
    
    

To generate a signature for versions 2.2 and 3, combine the signature
parameter values into a UTF-8 string with an invisible separator (`‘\u2063’`)
between them, in the exact order the code below shows:

    
    
    version + '\u2063' + ad-network-id + '\u2063' + campaign-id + '\u2063' + itunes-item-id + '\u2063' + nonce + '\u2063' + source-app-id + '\u2063' + fidelity-type + '\u2063' + timestamp
    
    
    

Use the most recent version available in the SDK whenever possible. For
information about availability, see SKAdNetwork release notes.

### Sign the combined string

Sign the combined UTF-8 string with the following key and algorithm:

  * Your PKCS#8 private key.

  * The Elliptic Curve Digital Signature Algorithm (ECDSA) with a SHA-256 hash. 

The resulting Digital Encoding Rules (DER)-formatted binary value is the
signature.

### Encode the signature

Encode the binary signature you generate into a Base64 string. The result is
your ad network attribution signature, `signature`, to use for view-through
ads. The signature string should resemble the following:

    
    
    MEQCIEQlmZRNfYzKBSE8QnhLTIHZZZWCFgZpRqRxHss65KoFAiAJgJKjdrWdkLUOCCjuEx2RmFS7daRzSVZRVZ8RyMyUXg==
    

For more information about Base64 encoding, see
`base64EncodedString(options:)`.

### Use the generated signature string

After you generate the signature, you have all the required values for your
`SKAdImpression` instance and can use it to call
`startImpression(_:completionHandler:)`. Present your view-through ad, and
then call `endImpression(_:completionHandler:)` using the same
`SKAdImpression` instance.

## See Also

### Signing view-through ads

`class SKAdImpression`

A class that defines an ad impression for a view-through ad.

`class func startImpression(SKAdImpression, completionHandler: (((any Error)?)
-> Void)?)`

Indicates that your app is presenting a view-through ad to the user.

`class func endImpression(SKAdImpression, completionHandler: (((any Error)?)
-> Void)?)`

Indicates that your app is no longer presenting a view-through ad to the user.

Type Method

# startImpression(_:completionHandler:)

Indicates that your app is presenting a view-through ad to the user.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    class func startImpression(
        _ impression: SKAdImpression,
        completionHandler completion: (((any Error)?) -> Void)? = nil
    )

##  Parameters

`impression`

    

An instance of `SKAdImpression` with the properties set for the view-through
ad that you’re presenting.

`completion`

    

The callback handler you provide to handle any tasks relevant to the start of
the ad impression.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

Call this method when you start presenting the view-through ad to the user. If
you call `startImpression(_:completionHandler:)` more than once for the same
advertised app before calling `endImpression(_:completionHandler:)`, the
latest impression overwrites the earlier impression.

Call `endImpression(_:completionHandler:)` when the impression ends and is no
longer visible to the user.

Note

To ensure that SKAdNetwork records the impression, call
`endImpression(_:completionHandler:)` after the impression ends, regardless of
whether `startImpression(_:completionHandler:)` returns an error in the
completion handler.

## See Also

### Signing view-through ads

Generating the signature to validate view-through ads

Initiate install validation by displaying a view-through ad with signed
parameters.

`class SKAdImpression`

A class that defines an ad impression for a view-through ad.

`class func endImpression(SKAdImpression, completionHandler: (((any Error)?)
-> Void)?)`

Indicates that your app is no longer presenting a view-through ad to the user.

Type Method

# endImpression(_:completionHandler:)

Indicates that your app is no longer presenting a view-through ad to the user.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    class func endImpression(
        _ impression: SKAdImpression,
        completionHandler completion: (((any Error)?) -> Void)? = nil
    )

##  Parameters

`impression`

    

An instance of `SKAdImpression` with the properties set for the view-through
ad that you presented. This must be the same instance you provide in
`startImpression(_:completionHandler:)`.

`completion`

    

The callback handler you provide to handle any tasks relevant to concluding
the ad impression.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

Call this method when you end the presentation of a view-through ad and it’s
no longer visible to the user. To help ensure it’s a valid impression,
StoreKit only records the impression if the ad displays for a minimum amount
of time. That minimum is 2 seconds on devices running iOS 15.4 and iPadOS 15.4
and later, and 3 seconds on devices running earlier versions of iOS and
iPadOS. If the app displays the ad for fewer than the minimum number of
seconds, StoreKit doesn’t record the ad impression for attribution.

Note

To ensure that SKAdNetwork records the impression, call
`endImpression(_:completionHandler:)` after the impression ends, regardless of
whether `startImpression(_:completionHandler:)` returns an error in the
completion handler.

StoreKit records a maximum of 15 view-through ad impressions per source app
for various products before discarding the oldest-recorded impression.

For more information about ad impressions and attributions, see Receiving ad
attributions and postbacks.

## See Also

### Signing view-through ads

Generating the signature to validate view-through ads

Initiate install validation by displaying a view-through ad with signed
parameters.

`class SKAdImpression`

A class that defines an ad impression for a view-through ad.

`class func startImpression(SKAdImpression, completionHandler: (((any Error)?)
-> Void)?)`

Indicates that your app is presenting a view-through ad to the user.

Type Method

# updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)

Updates the fine and coarse conversion values and indicates whether to send
the postback before the conversion window ends, and calls a completion handler
if the update fails.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+

    
    
    class func updatePostbackConversionValue(
        _ fineValue: Int,
        coarseValue: SKAdNetwork.CoarseConversionValue,
        lockWindow: Bool,
        completionHandler completion: (((any Error)?) -> Void)? = nil
    )

##  Parameters

`fineValue`

    

An unsigned 6-bit value `≥0` and `≤63`. The app or the ad network defines the
meaning of the fine conversion value.

`coarseValue`

    

An `SKAdNetwork.CoarseConversionValue` value of `low`, `medium`, or `high`.
The app or the ad network defines the meaning of the coarse conversion value.

`lockWindow`

    

A Boolean value that indicates whether to send the postback before the
conversion window ends. Use `true` to tell the system to send the postback
without waiting for the end of the conversion window. The default value is
`false`.

`completion`

    

An optional completion handler you provide to catch and handle any errors this
method encounters when you update a conversion value. Set this value to `nil`
if you don’t provide a handler.

## Return Value

This method returns `SKANError.Code.invalidConversionValue` if the `fineValue`
is outside of the allowed range.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

Call this method when the user first launches an app to register the app
installation, and again to update conversion values as the user engages with
the app. It’s up to your app to decide what the conversion values signify in
your app, both the `fineValue` and the `coarseValue`.

This method supports ads signed with any verison of SKAdNetwork, and you can
use it instead of calling
`updatePostbackConversionValue(_:completionHandler:)` and
`updatePostbackConversionValue(_:coarseValue:completionHandler:)`. The system
automatically determines the method’s behavior based on the ad’s version, as
the following sections describe — the app doesn’t need to know the ad version.
To take advantage of the multiple postbacks available starting in version 4,
use this method or
`updatePostbackConversionValue(_:coarseValue:completionHandler:)`.

Important

The system ignores calls to this method if the `fineValue` is outside of the
valid range. Valid conversion updates your app sends before or after an
invalid conversion remain available.

### Update conversion values for ads signed with SKAdNetwork 4 or later

For ads that ad networks sign using version 4 or later, calling this method
behaves as follows:

  * Both the `fineValue` and `coarseValue` represent conversion values. The method ignores the `fineValue` after the first conversion window.

  * Setting the `lockWindow` parameter to `true` indicates a final update for the conversion value for the current conversion window. The system ignores additional calls to update the conversion value until the end of the conversion window.

  * Setting the `lockWindow` parameter to `false` continues updating the conversion value throughout the conversion window.

For information about the data you may receive in postbacks, see Receiving
postbacks in multiple conversion windows.

### Update conversion values for ads signed with SKAdNetwork 3 or earlier

For ads that ad networks sign using version 3 or earlier, calling this method
behaves as follows:

  * The `fineValue` represents the conversion value. 

  * The method ignores the `coarseValue` and `lockWindow` parameters.

  * There’s a single conversion period that ends after a rolling 24-hour timer expires. The 24-hour timer restarts each time the app calls this method with a valid conversion value greater than the previous value. When the timer expires, the conversion value is final and subsequent calls to this method have no effect.

  * The device sends the postback 0–24 hours after the timer expires. 

  * The postback contains the final conversion value only if the postback data tier contains the value.

For more information about SKAdNetwork versions, see SKAdNetwork release
notes.

## See Also

### Providing conversion information

`class func updatePostbackConversionValue(Int, coarseValue:
SKAdNetwork.CoarseConversionValue, completionHandler: (((any Error)?) ->
Void)?)`

Updates the fine and coarse conversion values, and calls a completion handler
if the update fails.

`struct SKAdNetwork.CoarseConversionValue`

Coarse values to use for updating conversion values.

`class func updatePostbackConversionValue(Int, completionHandler: (((any
Error)?) -> Void)?)`

Verifies the first launch of an advertised app and, on subsequent calls,
updates the conversion value or calls a completion handler if the update
fails.

Type Method

# updatePostbackConversionValue(_:coarseValue:completionHandler:)

Updates the fine and coarse conversion values, and calls a completion handler
if the update fails.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+

    
    
    class func updatePostbackConversionValue(
        _ fineValue: Int,
        coarseValue: SKAdNetwork.CoarseConversionValue,
        completionHandler completion: (((any Error)?) -> Void)? = nil
    )

##  Parameters

`fineValue`

    

An unsigned 6-bit value `≥0` and `≤63`. The app or the ad network defines the
meaning of the conversion value.

`coarseValue`

    

An `SKAdNetwork.CoarseConversionValue` value. The app or the ad network
defines the meaning of this value.

`completion`

    

An optional completion handler you provide to catch and handle any errors this
method encounters when you update a conversion value. Set this value to `nil`
if you don’t provide a handler.

## Return Value

This method returns `SKANError.Code.invalidConversionValue` if the `fineValue`
is outside of the allowed range.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

Call this method when the user first launches an app to register the app
installation, and optionally again, to update conversion values as the user
engages with the app.

This method is identical to calling
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
with the `lockWindow` parameter set to `false`.

Important

The system ignores calls to this method if the `fineValue` is outside of the
valid range. Valid conversion updates your app sends before or after an
invalid conversion remain available.

## See Also

### Providing conversion information

`class func updatePostbackConversionValue(Int, coarseValue:
SKAdNetwork.CoarseConversionValue, lockWindow: Bool, completionHandler: (((any
Error)?) -> Void)?)`

Updates the fine and coarse conversion values and indicates whether to send
the postback before the conversion window ends, and calls a completion handler
if the update fails.

`struct SKAdNetwork.CoarseConversionValue`

Coarse values to use for updating conversion values.

`class func updatePostbackConversionValue(Int, completionHandler: (((any
Error)?) -> Void)?)`

Verifies the first launch of an advertised app and, on subsequent calls,
updates the conversion value or calls a completion handler if the update
fails.

Type Method

# updatePostbackConversionValue(_:completionHandler:)

Verifies the first launch of an advertised app and, on subsequent calls,
updates the conversion value or calls a completion handler if the update
fails.

iOS 15.4+  iPadOS 15.4+  Mac Catalyst 15.4+

    
    
    class func updatePostbackConversionValue(
        _ conversionValue: Int,
        completionHandler completion: (((any Error)?) -> Void)? = nil
    )

##  Parameters

`conversionValue`

    

An unsigned 6-bit value `≥0` and `≤63`. The app or the ad network defines the
meaning of the conversion value. For ad impressions signed with SKAdNetwork 3
or earlier, you need to increase the `conversionValue` each time you call this
method. For ad impressions signed with SKAdNetwork 4 or later, you may use any
valid `conversionValue` each time you call this method.

`completion`

    

An optional completion handler you provide to catch and handle any errors this
method encounters when you update a conversion value. Set this value to `nil`
if you don’t provide a handler.

## Return Value

Invalid conversion values cause the method to fail and return error
`SKANError.Code.invalidConversionValue`.

## Discussion

Concurrency Note

You can call this method from synchronous code using a completion handler, as
shown on this page, or you can call it as an asynchronous method that has the
following declaration:

For information about concurrency and asynchronous code in Swift, see Calling
Objective-C APIs Asynchronously.

Note

Consider using
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
instead of this method for newer implementations.

Apps call this method to update conversion values as people engage with the
app. It’s up to the app or ad network to define the conversion value’s
meaning. Call this method immediately when the user first launches the app to
confirm the app’s launch. Call this method again, as needed, to reflect the
person’s engagement with the app.

The final conversion value appears in the postback if sending the data meets
Apple’s privacy threshold. Only postbacks that win the ad attribution can
contain a conversion value. Nonwinning postbacks don’t contain conversion
values. For more information, see Receiving ad attributions and postbacks.

The way this method behaves depends on the ad’s version, as described in the
following sections. Ad networks determine an ad’s version when they sign the
ad. For more information about signing ads, see Signing and providing ads.

### Update the conversion value for version 3 ads and earlier

If the ad network signs the winning ad with version 3 or earlier, calling this
method behaves as follows:

  * Apps may call this method repeatedly before a rolling 24-hour timer expires.

  * The 24-hour timer restarts each time the app calls this method with a valid `conversionValue` that’s greater than the previous value. 

  * When the timer expires, the conversion value is final and subsequent calls to `updatePostbackConversionValue(_:completionHandler:)` have no effect.

  * The device sends the postback to the ad network’s URL within 0 to 24 hours after the timer expires. The postback contains the final conversion value only if sending the data meets Apple’s privacy threshold.

### Update the conversion value for version 4 ads and later

Note

This method supports ads signed with version 4 and later, however, it doesn’t
provide advanced features, such as multiple postbacks and coarse conversion
values, available starting in version 4. To get those advanced features for
ads signed with version 4 and later, use
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
instead of this method.

If the ad network signs the winning ad with version 4 or later, calling this
method behaves as follows:

  * Apps may call this method repeatedly within the first conversion window.

  * Provide any `conversionValue` within the valid range; the `conversionValue` doesn’t need to increase with each call.

  * This method is available only during the first conversion window. Use `updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)` to update conversion values in the subsequent conversion windows.

  * When the first conversion window closes, the system sends the postback within 0 to 24 hours. The postback contains the final conversion value only if sending the data meets Apple’s privacy threshold.

## See Also

### Providing conversion information

`class func updatePostbackConversionValue(Int, coarseValue:
SKAdNetwork.CoarseConversionValue, lockWindow: Bool, completionHandler: (((any
Error)?) -> Void)?)`

Updates the fine and coarse conversion values and indicates whether to send
the postback before the conversion window ends, and calls a completion handler
if the update fails.

`class func updatePostbackConversionValue(Int, coarseValue:
SKAdNetwork.CoarseConversionValue, completionHandler: (((any Error)?) ->
Void)?)`

Updates the fine and coarse conversion values, and calls a completion handler
if the update fails.

`struct SKAdNetwork.CoarseConversionValue`

Coarse values to use for updating conversion values.

Article

# Identifying the parameters in install-validation postbacks

Learn about the postback parameters in all SKAdNetwork versions.

## Overview

The following list describes all the possible parameters you may get in a
postback, and their version availability. To verify that Apple signed the
postback, see Verifying an install-validation postback.

`version`

    

Version 2 and later. The SKAdNetwork version that matches
`SKStoreProductParameterAdNetworkVersion` or `version`. For more information
about versions, see SKAdNetwork release notes.

`ad-network-id`

    

Version 1 and later. Your ad network ID, which matches the value you provide
for `SKStoreProductParameterAdNetworkIdentifier` or `adNetworkIdentifier`.

`attribution-signature`

    

Version 2 and later. Apple’s attribution signature that you verify.

`app-id`

    

Version 1 and later. The App Store app ID of the advertised app.

`source-identifier`

    

Version 4 and later. The hierarchical source identifier that replaces the
`campaign-id`. This string represents two, three, or four digits of the
original value the ad network supplies in
`SKStoreProductParameterAdNetworkSourceIdentifier` or `sourceIdentifier`.

`campaign-id`

    

Versions 1–3. The campaign identifer you provide when displaying the ad, which
matches `SKStoreProductParameterAdNetworkCampaignIdentifier` or
`adCampaignIdentifier`. Version 4 and later ads use `source-identifer`
instead.

`source-app-id`

    

Version 2 and later. The App Store app ID of the app that displays the ad. The
`source-app-id` value matches
`SKStoreProductParameterAdNetworkSourceAppStoreIdentifier` or
`sourceAppStoreItemIdentifier`.

Note: The `source-app-id` only appears in the postback if providing the
parameter meets Apple’s privacy threshold.

`source-domain`

    

Version 4 and later, for web ads only. For more information, see SKAdNetwork
for Web Ads.

`conversion-value`

    

Version 2 and later. An unsigned 6-bit value that the installed app sets by
calling a method to update the conversion value, such as
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`.
The `conversion-value` only appears in the postback if the installed app
provides it, and if providing the parameter meets Apple’s privacy threshold.

Note: The signature doesn’t include the `conversion-value`. Postbacks may
contain either `conversion-value` or `coarse-conversion-value`, not both.

`coarse-conversion-value`

    

Version 4 and later. Possible values are the strings `"low"`, `"medium"`, and
`"high"`. The installed app sets this value by calling a method to update
conversion values, such as
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`.

Note: The signature doesn’t include the `coarse-conversion-value`. Postbacks
may contain either `conversion-value` or `coarse-conversion-value`, not both.

`did-win`

    

Version 3 and later. A Boolean value that’s `true` if the ad network wins the
attribution, and `false` if the postback represents a qualifying ad impression
that doesn't win the attribution.

`fidelity-type`

    

Version 2.2 and later. A value of `0` indicates a view-through ad
presentation; a value of `1` indicates a StoreKit-rendered ad or an
SKAdNetwork-attributed web ad.

`postback-sequence-index`

    

Version 4 and later. The possible integer values of `0`, `1`, and `2` signify
the order of postbacks that result from the three conversion windows. For more
information, see Receiving postbacks in multiple conversion windows.

`redownload`

    

Version 2 and later. A Boolean value of `true` indicates that a device with
the customer’s Apple ID previously installed the app.

`transaction-id`

    

Version 1 and later. A unique value for this validation; use it to deduplicate
install-validation postbacks.

To ensure crowd anonymity, Apple assigns a postback data tier to app
downloads. The postback data tier determines whether certain parameters appear
in the postback, as well as the number of digits in the hierarchical source
identifer. The following postback parameters are subject to the postback data
tier:

  * `source-identifier` (affects the number of digits the postback returns)

  * `coarse-conversion-value`

  * `conversion-value`

  * `source-app-id`

  * `source-domain`

For more information about receiving postbacks, see Receiving postbacks in
multiple conversion windows.

## See Also

### Verifying postbacks

Verifying an install-validation postback

Ensure the validity of a postback you receive after an ad conversion by
verifying its cryptographic signature.

Article

# Testing ad attributions with a downloaded profile

Reduce the time-window for ad attributions and inspect postbacks using a proxy
during testing.

## Overview

You can reduce the time window for receiving ad attribution postbacks by
installing an SKAdNetwork testing profile on your test device.

Important

To download the latest profile, see the AdAttributionKit article on Testing ad
attributions with a downloaded profile. This profile is compatible with both
AdAttributionKit and SKAdNetwork.

For information about installing profiles, see Install a configuration profile
on your iPhone or iPad. You can install this profile on devices running iOS or
iPadOS 14 or later.

With this profile, the installed app has five minutes to update the conversion
value after initially registering. The device sends the postback within
another five minutes after the rolling five-minute timer for conversion
updates expires. Using this profile reduces the conversion value update and
postback window from 24–48 hours to 5–10 minutes.

This testing profile expires two weeks after you install it on the device. To
continue testing, download the latest profile and reinstall it.

### Log in with an Apple ID to test ad attributions

To test ad attributions, you must log in to the device with a production Apple
ID. SKAdNetwork doesn’t support Sandbox Apple IDs.

### Inspect postbacks using an HTTP proxy

On devices running iOS 14.7 and later with this profile installed, the system
can send SKAdNetwork postbacks through an HTTP proxy that you configure. By
using an HTTP proxy, you can monitor the HTTP traffic between your device and
the network, including SKAdNetwork postbacks.

To configure the HTTP proxy, do the following on a testing device:

  1. Go to Settings > Wi-Fi and select the Wi-Fi network you're connected to. 

  2. Under the HTTP Proxy heading, select Configure Proxy.

  3. Select Manual to configure the Server, Port, and Authentication settings for your proxy, or select Automatic to provide a URL for your proxy.

  4. Tap Save.

With the profile installed, the SKAdNetwork postbacks that the device sends
now go through the proxy you configured.

## See Also

### Testing ad attributions and postbacks

Testing and validating ad impression signatures and postbacks for SKAdNetwork

Validate your ad impressions and test your postbacks by creating unit tests
using the StoreKit Test framework.

Type Method

# registerAppForAdNetworkAttribution()

Verifies the first launch of an app installed as a result of an ad.

iOS 11.3–15.4  Deprecated  iPadOS 11.3–15.4  Deprecated  Mac Catalyst
13.1–15.4  Deprecated

    
    
    class func registerAppForAdNetworkAttribution()

Deprecated

Use
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
instead.

## Discussion

Apps that an ad network campaign advertise call this method or
`updateConversionValue(_:)` when the app first launches. Both methods generate
an install notification, which is the cryptographically signed data that
validates that a user installed and launched this app as a result of an ad.

In iOS 15.4 and earlier, the first call to
`registerAppForAdNetworkAttribution()` generates the notification if the
device has attribution data for that app, and starts a 24-hour timer.
Subsequent calls to this method have no effect, unless the ad already has a
conversion value set, in which case calling
`registerAppForAdNetworkAttribution()` resets the conversion value to `0`. You
may, however, call `updateConversionValue(_:)` to provide an updated
conversion value and restart the timer.

The device sends one or more install notifications to ad network postback URLs
within 0-24 hours after the timer expires. For more information about
attribution-winning and non-winning postbacks, see Receiving ad attributions
and postbacks.

Ad networks must verify the postback after receiving it. For more information,
see Verifying an install-validation postback.

## See Also

### Deprecated

`class func updateConversionValue(Int)`

Updates the conversion value and verifies the first launch of an app installed
as a result of an ad.

Deprecated

Type Method

# updateConversionValue(_:)

Updates the conversion value and verifies the first launch of an app installed
as a result of an ad.

iOS 14.0–15.4  Deprecated  iPadOS 14.0–15.4  Deprecated  Mac Catalyst
14.0–15.4  Deprecated

    
    
    class func updateConversionValue(_ conversionValue: Int)

Deprecated

Use
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
instead.

##  Parameters

`conversionValue`

    

An unsigned 6-bit value (`>=0` and `<=63`). The app or the ad network
determines the meaning of the value. The default value is `0`.

## Discussion

Apps that ad networks advertise call `updateConversionValue(_:)` or
`registerAppForAdNetworkAttribution()` when the app first launches, to
register the attribution.

Important

Provide a valid conversion value within the range of `>=0` and `<=63` when
calling `updateConversionValue(_:)` to register the attribution. Invalid
conversion values cause the method to fail, and the conversion to fail to
register.

Apps may call `updateConversionValue(_:)` again within a rolling 24-hour
period to update the conversion value. Calling this method serves two
purposes:

  * It registers the attribution by generating an install notification — the cryptographically signed data that confirms that a user installed and launched this app as a result of an ad.

  * It enables the app to provide and update a conversion value.

Conversion values are a 6-bit value that the ad network or the app defines.
The app decides when to update the value, which it can do any number of times
before a rolling 24-hour timer expires. The 24-hour timer restarts each time
the app calls this method with a valid conversion value greater than the
previous value. When the timer expires, the conversion value is final and
subsequent calls to `updateConversionValue(_:)` have no effect.

The device sends the install notification postback to the ad network’s URL
within 0-24 hours after the timer expires. The postback only contains the
final conversion value if sending the data meets Apple’s privacy threshold.
Only postbacks with an ad attribution can contain a conversion value; non-
winning postbacks don't include a conversion value. For more information, see
Receiving ad attributions and postbacks.

Ad networks must verify the postback after receiving it. See Verifying an
install-validation postback for more information.

## See Also

### Deprecated

`class func registerAppForAdNetworkAttribution()`

Verifies the first launch of an app installed as a result of an ad.

Deprecated



# ExternalPurchase

Type Property

# canPresent

A Boolean value that indicates whether the app can successfully present the
notice sheet to inform people about external purchases.

iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    static var canPresent: Bool { get async }

## Discussion

Check this property, as shown below, to determine whether your app can
successfully call `presentNoticeSheet()` to inform people before showing
external purchases:

Check the value of this property again whenever the App Store storefront
changes by using the `updates` asynchronous sequence of `Storefront`.

This property is `true` if all the following conditions are met:

  * The current App Store storefront allows external purchase, and the person is eligible to make external purchases.

  * Your app configures the `com.apple.developer.storekit.external-purchase` entitlement.

  * Your app configures the country code for the current App Store storefront in `SKExternalPurchase`.

Otherwise, this property is `false`.

When this property is `false`, check `canMakePayments` to determine whether
your app can offer in-app purchases using the StoreKit In-App Purchase APIs.
For more information, see `canMakePayments`.

## See Also

### Offering an external purchase

`static func presentNoticeSheet() -> ExternalPurchase.NoticeResult`

Presents a notice sheet from Apple that informs people before showing external
purchases and determines whether your app can present external purchases.

`enum ExternalPurchase.NoticeResult`

The options available to people while viewing the external purchase notice
sheet.

`property list key SKExternalPurchase`

A string array of country codes that indicates your app supports external
purchases.

Type Method

# presentNoticeSheet()

Presents a notice sheet from Apple that informs people before showing external
purchases and determines whether your app can present external purchases.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.1+  Xcode 13.3+

    
    
    static func presentNoticeSheet() async throws -> ExternalPurchase.NoticeResult

## Return Value

This returns `ExternalPurchase.NoticeResult`.

## Discussion

This method is only available to apps with the
`com.apple.developer.storekit.external-purchase` entitlement. For more
information, see `ExternalPurchase`.

Call this method each time your app is ready to present an external purchase.
To use this method, follow these steps:

  1. Call `canPresent`. If it’s `false`, don’t call `presentNoticeSheet()` and don’t show external purchases.

  2. If `canPresent` is `true`, display buttons or other user-interface elements to enable deliberate user interaction. Then, in response to a deliberate user interaction such as tapping a button, call `presentNoticeSheet()` as shown below:

3\. If the result is
`ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:)`
your app can show external purchases. Otherwise, you must not show external
purchases.

Important

Record and use the token from the result to report to Apple the customer’s
external purchases. For more information on reporting, see External Purchase
Server API.

This method throws a `StoreKitError` in any of the following conditions:

  * Your app doesn’t have the `com.apple.developer.storekit.external-purchase` entitlement.

  * Your app doesn’t have external purchases configured for the current App Store storefront; see `SKExternalPurchase` and `Storefront`.

  * The current App Store storefront doesn’t support external purchases. 

  * The person is ineligible to make external purchases.

  * A network or system error occurs.

This method also throws a `StoreKitError` if its functionality is unavailable
for the following reasons:

  * Your app is built with Mac Catalyst and you compile with an SDK earlier than iOS 17.4 or iPadOS 17.4.

  * Your app is a compatible iPad or iPhone app running in macOS or visionOS and uses an SDK earlier than iOS 17.4 or iPadOS 17.4.

For apps compiled with SDKs earlier than iOS 17.4 or iPadOS 17.4, your app can
show external purchases if the result is
`ExternalPurchase.NoticeResult.continued`.

## See Also

### Offering an external purchase

`static var canPresent: Bool`

A Boolean value that indicates whether the app can successfully present the
notice sheet to inform people about external purchases.

`enum ExternalPurchase.NoticeResult`

The options available to people while viewing the external purchase notice
sheet.

`property list key SKExternalPurchase`

A string array of country codes that indicates your app supports external
purchases.

Property List Key

# SKExternalPurchase

A string array of country codes that indicates your app supports external
purchases.

iOS 15.4+  iPadOS 15.4+  macOS 14.4+  Mac Catalyst 17.4+  tvOS 17.4+  watchOS
10.4+  visionOS 1.0+

##  Details

Type

    

array of strings

## Discussion

Use this information property list key if your app has the
`com.apple.developer.storekit.external-purchase` entitlement.

To the array, add a string containing the lowercased ISO 3166-1 alpha-2
country code for each country where your app supports external purchases. The
following code example shows a property list entry with two strings, for the
Netherlands (`nl`) and Italy (`it`):

    
    
    <plist>
    <dict>
        <key>SKExternalPurchase</key>
        <array>
            <string>nl</string>
            <string>it</string>
        </array>
    </dict>
    </plist>
    

Use valid country codes for the following allowed countries or regions:

  * In the European Union: Austria (`at`), Belgium (`be`), Bulgaria (`bg`), Croatia (`hr`), Cyprus (`cy`), Czechia (`cz`), Denmark (`dk`), Estonia (`ee`), Finland (`fi`), France (`fr`), Germany (`de`), Greece (`gr`), Hungary (`hu`), Ireland (`ie`), Italy (`it`), Latvia (`lv`), Lithuania (`lt`), Luxembourg (`lu`), Malta (`mt`), Netherlands (`nl`), Poland (`pl`), Portugal (`pt`), Romania (`ro`), Slovakia (`sk`), Slovenia (`si`), Spain (`es`), Sweden (`se`) 

  * South Korea (`kr`)

For more information, see External Purchase.

## See Also

### Offering external purchases

`enum ExternalPurchase`

Enables qualifying apps to offer external purchases within the app.

`com.apple.developer.storekit.external-purchase`

A Boolean value that indicates whether your app can offer external purchases.



# Storefront

Type Property

# current

The current App Store storefront for product purchases.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var current: Storefront? { get async }

## Discussion

Use `current` to determine a customer's current storefront region and offer
in-app products suitable for that region. You maintain your own list of
product identifiers and the storefronts in which you make them available.

## See Also

### Identifying the storefront

`let countryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront.

`let id: String`

An Apple-defined value that uniquely identifies an App Store storefront.

`typealias Storefront.ID`

The type that represents a storefront identifier.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Storefront` conforms to `AnyObject`.

Instance Property

# countryCode

The three-letter code that represents the country or region associated with
the App Store storefront.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let countryCode: String

## Discussion

This property uses the ISO 3166-1 Alpha-3 country code representation.

## See Also

### Identifying the storefront

`static var current: Storefront?`

The current App Store storefront for product purchases.

`let id: String`

An Apple-defined value that uniquely identifies an App Store storefront.

`typealias Storefront.ID`

The type that represents a storefront identifier.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Storefront` conforms to `AnyObject`.

Instance Property

# id

An Apple-defined value that uniquely identifies an App Store storefront.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let id: String

## Relationships

### From Protocol

  * `Identifiable`

## See Also

### Identifying the storefront

`static var current: Storefront?`

The current App Store storefront for product purchases.

`let countryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront.

`typealias Storefront.ID`

The type that represents a storefront identifier.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Storefront` conforms to `AnyObject`.

Type Alias

# Storefront.ID

The type that represents a storefront identifier.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Storefront.ID = String

## See Also

### Identifying the storefront

`static var current: Storefront?`

The current App Store storefront for product purchases.

`let countryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront.

`let id: String`

An Apple-defined value that uniquely identifies an App Store storefront.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `Storefront` conforms to `AnyObject`.

Instance Property

# id

The stable identity of the entity associated with this instance.

iOS 13.0+  iPadOS 13.0+  macOS 10.15+  Mac Catalyst 15.0+  tvOS 13.0+  watchOS
6.0+  visionOS 1.0+  Xcode 11.0+

    
    
    var id: ObjectIdentifier { get }

Available when `Storefront` conforms to `AnyObject`.

## Discussion

Note

This documentation comment was inherited from `Identifiable`.

## See Also

### Identifying the storefront

`static var current: Storefront?`

The current App Store storefront for product purchases.

`let countryCode: String`

The three-letter code that represents the country or region associated with
the App Store storefront.

`let id: String`

An Apple-defined value that uniquely identifies an App Store storefront.

`typealias Storefront.ID`

The type that represents a storefront identifier.

Type Property

# updates

The asynchronous sequence that emits storefront information when the system
updates the storefront.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var updates: Storefront.Storefronts { get }

## Discussion

The storefront value can change at any time. Use `updates` to listen for
changes in this value. Respond to storefront changes by refreshing the list of
your available products.

## See Also

### Listening for storefront changes

`struct Storefront.Storefronts`

An asynchronous sequence that listens for changes to the storefront.



# StoreKitError

Enumeration Case

# StoreKitError.networkError(_:)

A network error occurred.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case networkError(URLError)

## See Also

### StoreKit Error Codes

`case systemError(any Error)`

A system error occurred.

`case userCancelled`

The user canceled.

`case notAvailableInStorefront`

The function isn’t available on devices configured for this storefront.

`case notEntitled`

The app doesn’t have the appropriate entitlements to use the functionality.

`case unknown`

An unknown error occurred.

Enumeration Case

# StoreKitError.systemError(_:)

A system error occurred.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case systemError(any Error)

## See Also

### StoreKit Error Codes

`case networkError(URLError)`

A network error occurred.

`case userCancelled`

The user canceled.

`case notAvailableInStorefront`

The function isn’t available on devices configured for this storefront.

`case notEntitled`

The app doesn’t have the appropriate entitlements to use the functionality.

`case unknown`

An unknown error occurred.

Enumeration Case

# StoreKitError.userCancelled

The user canceled.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case userCancelled

## See Also

### StoreKit Error Codes

`case networkError(URLError)`

A network error occurred.

`case systemError(any Error)`

A system error occurred.

`case notAvailableInStorefront`

The function isn’t available on devices configured for this storefront.

`case notEntitled`

The app doesn’t have the appropriate entitlements to use the functionality.

`case unknown`

An unknown error occurred.

Enumeration Case

# StoreKitError.notAvailableInStorefront

The function isn’t available on devices configured for this storefront.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case notAvailableInStorefront

## See Also

### StoreKit Error Codes

`case networkError(URLError)`

A network error occurred.

`case systemError(any Error)`

A system error occurred.

`case userCancelled`

The user canceled.

`case notEntitled`

The app doesn’t have the appropriate entitlements to use the functionality.

`case unknown`

An unknown error occurred.

Enumeration Case

# StoreKitError.notEntitled

The app doesn’t have the appropriate entitlements to use the functionality.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    case notEntitled

## See Also

### StoreKit Error Codes

`case networkError(URLError)`

A network error occurred.

`case systemError(any Error)`

A system error occurred.

`case userCancelled`

The user canceled.

`case notAvailableInStorefront`

The function isn’t available on devices configured for this storefront.

`case unknown`

An unknown error occurred.

Enumeration Case

# StoreKitError.unknown

An unknown error occurred.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case unknown

## See Also

### StoreKit Error Codes

`case networkError(URLError)`

A network error occurred.

`case systemError(any Error)`

A system error occurred.

`case userCancelled`

The user canceled.

`case notAvailableInStorefront`

The function isn’t available on devices configured for this storefront.

`case notEntitled`

The app doesn’t have the appropriate entitlements to use the functionality.

Instance Property

# localizedDescription

A string containing the localized description of the error.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var localizedDescription: String { get }

## See Also

### Error Descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A message describing the reason for the failure.

`var helpAnchor: String?`

A localized message that provides additional information if the user requests
help.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# errorDescription

A description of the error, suitable for debugging.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var errorDescription: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Descriptions

`var localizedDescription: String`

A string containing the localized description of the error.

`var failureReason: String?`

A message describing the reason for the failure.

`var helpAnchor: String?`

A localized message that provides additional information if the user requests
help.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# failureReason

A message describing the reason for the failure.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var failureReason: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Descriptions

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var helpAnchor: String?`

A localized message that provides additional information if the user requests
help.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# helpAnchor

A localized message that provides additional information if the user requests
help.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 15.4+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var helpAnchor: String? { get }

## See Also

### Error Descriptions

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A message describing the reason for the failure.

`var recoverySuggestion: String?`

A message containing a suggestion for recovering from the error.

Instance Property

# recoverySuggestion

A message containing a suggestion for recovering from the error.

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var recoverySuggestion: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Error Descriptions

`var localizedDescription: String`

A string containing the localized description of the error.

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A message describing the reason for the failure.

`var helpAnchor: String?`

A localized message that provides additional information if the user requests
help.



# Product.SubscriptionOffer.OfferType

Type Property

# introductory

An introductory offer for a subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let introductory: Product.SubscriptionOffer.OfferType

## Discussion

For more information about introductory offers, see Set an introductory offer
for an auto-renewable subscription.

## See Also

### Getting the Offer Types

`static let promotional: Product.SubscriptionOffer.OfferType`

A promotional offer.

Type Property

# promotional

A promotional offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let promotional: Product.SubscriptionOffer.OfferType

## Discussion

For more information about promotional offers, see Set up promotional offers
for auto-renewable subscriptions.

## See Also

### Getting the Offer Types

`static let introductory: Product.SubscriptionOffer.OfferType`

An introductory offer for a subscription.

Instance Property

# localizedDescription

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

A raw value representing a subscription offer type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

A string representing the offer type.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating an Offer Type

`typealias Product.SubscriptionOffer.OfferType.RawValue`

`let rawValue: String`

A string representing the raw value of the subscription offer type.

Type Alias

# Product.SubscriptionOffer.OfferType.RawValue

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionOffer.OfferType.RawValue = String

## See Also

### Creating an Offer Type

`init(rawValue: String)`

A raw value representing a subscription offer type.

`let rawValue: String`

A string representing the raw value of the subscription offer type.

Instance Property

# rawValue

A string representing the raw value of the subscription offer type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating an Offer Type

`init(rawValue: String)`

A raw value representing a subscription offer type.

`typealias Product.SubscriptionOffer.OfferType.RawValue`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer.OfferType, rhs: Product.SubscriptionOffer.OfferType) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Offer Types

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and Hashing Offer Types

`static func != (Product.SubscriptionOffer.OfferType,
Product.SubscriptionOffer.OfferType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and Hashing Offer Types

`static func != (Product.SubscriptionOffer.OfferType,
Product.SubscriptionOffer.OfferType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Type Property

# introductory

An introductory offer for a subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let introductory: Product.SubscriptionOffer.OfferType

## Discussion

For more information about introductory offers, see Set an introductory offer
for an auto-renewable subscription.

## See Also

### Getting the Offer Types

`static let promotional: Product.SubscriptionOffer.OfferType`

A promotional offer.

Type Property

# promotional

A promotional offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let promotional: Product.SubscriptionOffer.OfferType

## Discussion

For more information about promotional offers, see Set up promotional offers
for auto-renewable subscriptions.

## See Also

### Getting the Offer Types

`static let introductory: Product.SubscriptionOffer.OfferType`

An introductory offer for a subscription.

Instance Property

# localizedDescription

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

A raw value representing a subscription offer type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

A string representing the offer type.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating an Offer Type

`typealias Product.SubscriptionOffer.OfferType.RawValue`

`let rawValue: String`

A string representing the raw value of the subscription offer type.

Type Alias

# Product.SubscriptionOffer.OfferType.RawValue

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionOffer.OfferType.RawValue = String

## See Also

### Creating an Offer Type

`init(rawValue: String)`

A raw value representing a subscription offer type.

`let rawValue: String`

A string representing the raw value of the subscription offer type.

Instance Property

# rawValue

A string representing the raw value of the subscription offer type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating an Offer Type

`init(rawValue: String)`

A raw value representing a subscription offer type.

`typealias Product.SubscriptionOffer.OfferType.RawValue`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer.OfferType, rhs: Product.SubscriptionOffer.OfferType) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Offer Types

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and Hashing Offer Types

`static func != (Product.SubscriptionOffer.OfferType,
Product.SubscriptionOffer.OfferType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and Hashing Offer Types

`static func != (Product.SubscriptionOffer.OfferType,
Product.SubscriptionOffer.OfferType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Type Property

# introductory

An introductory offer for a subscription.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let introductory: Product.SubscriptionOffer.OfferType

## Discussion

For more information about introductory offers, see Set an introductory offer
for an auto-renewable subscription.

## See Also

### Getting the Offer Types

`static let promotional: Product.SubscriptionOffer.OfferType`

A promotional offer.

Type Property

# promotional

A promotional offer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static let promotional: Product.SubscriptionOffer.OfferType

## Discussion

For more information about promotional offers, see Set up promotional offers
for auto-renewable subscriptions.

## See Also

### Getting the Offer Types

`static let introductory: Product.SubscriptionOffer.OfferType`

An introductory offer for a subscription.

Instance Property

# localizedDescription

iOS 15.4+  iPadOS 15.4+  macOS 12.3+  Mac Catalyst 15.4+  tvOS 15.4+  watchOS
8.5+  visionOS 1.0+  Xcode 13.3+

    
    
    var localizedDescription: String { get }

Initializer

# init(rawValue:)

A raw value representing a subscription offer type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

A string representing the offer type.

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating an Offer Type

`typealias Product.SubscriptionOffer.OfferType.RawValue`

`let rawValue: String`

A string representing the raw value of the subscription offer type.

Type Alias

# Product.SubscriptionOffer.OfferType.RawValue

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    typealias Product.SubscriptionOffer.OfferType.RawValue = String

## See Also

### Creating an Offer Type

`init(rawValue: String)`

A raw value representing a subscription offer type.

`let rawValue: String`

A string representing the raw value of the subscription offer type.

Instance Property

# rawValue

A string representing the raw value of the subscription offer type.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let rawValue: String

## Relationships

### From Protocol

  * `RawRepresentable`

## See Also

### Creating an Offer Type

`init(rawValue: String)`

A raw value representing a subscription offer type.

`typealias Product.SubscriptionOffer.OfferType.RawValue`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Product.SubscriptionOffer.OfferType, rhs: Product.SubscriptionOffer.OfferType) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Offer Types

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Comparing and Hashing Offer Types

`static func != (Product.SubscriptionOffer.OfferType,
Product.SubscriptionOffer.OfferType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## See Also

### Comparing and Hashing Offer Types

`static func != (Product.SubscriptionOffer.OfferType,
Product.SubscriptionOffer.OfferType) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# SKCloudServiceSetupAction

Initializer

# init(rawValue:)

Initializes a setup action to offer for a cloud service using the specified
value.

iOS 7.0+  iPadOS 7.0+  macOS 10.9+  Mac Catalyst 13.0+  tvOS 9.0+  visionOS
1.0+  Xcode 7.1+

    
    
    init(rawValue: String)

Type Property

# subscribe

A subscribe action in a cloud service setup view, such as an offer to
subscribe to Apple Music.

iOS 10.1+  iPadOS 10.1+  Mac Catalyst 13.1+  tvOS 10.0+

    
    
    static let subscribe: SKCloudServiceSetupAction



# SKProductsRequest

Initializer

# init(productIdentifiers:)

Initializes the request with the set of product identifiers.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    init(productIdentifiers: Set<String>)

##  Parameters

`productIdentifiers`

    

The list of product identifiers for the products you wish to retrieve
descriptions of.

## Return Value

The initialized request object.

## See Also

### Related Documentation

In-App Purchase Programming Guide

Instance Property

# delegate

The delegate that receives the response of the app's products request.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    weak var delegate: (any SKProductsRequestDelegate)? { get set }

## See Also

### Setting the Delegate

`protocol SKProductsRequestDelegate`

A set of methods the delegate implements so it receives the product
information your app requests.



# PaymentMethodBinding

Initializer

# init(id:)

Creates the payment method binding for eligible apps and users.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    init(id: String) async throws

##  Parameters

`id`

    

The in-app binding identifier that your server receives from the Apple server
when your server initiates payment method binding.

## Discussion

This method succeeds if the app is entitled to use this API, the `id` is valid
and unexpired, and the user is eligible. Otherwise, it throws an error. See
`PaymentMethodBinding.PaymentMethodBindingError` and
`StoreKitError.userCancelled` for the error information.

This method determines if the user is eligible, and requires that they're
signed in to the App Store.

Important

This method may display a system prompt that asks users to sign in with their
Apple ID. Call this method only after an explicit user action, like tapping or
clicking a button.

Note that it's possible that the system determines a user isn't eligible after
it prompts for authentication.

Instance Property

# id

The in-app binding identifier.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    let id: String

## Discussion

This identifier is the in-app binding identifier that your server receives
from the Apple server when your server initiates payment method binding.

## Relationships

### From Protocol

  * `Identifiable`

## See Also

### Creating and identifying bindings

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `PaymentMethodBinding` conforms to `AnyObject`.

`typealias PaymentMethodBinding.ID`

A type that represents the identifier of a payment account binding.

Instance Property

# id

The stable identity of the entity associated with this instance.

iOS 13.0+  iPadOS 13.0+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 11.0+

    
    
    var id: ObjectIdentifier { get }

Available when `PaymentMethodBinding` conforms to `AnyObject`.

## Discussion

Note

This documentation comment was inherited from `Identifiable`.

## See Also

### Creating and identifying bindings

`let id: String`

The in-app binding identifier.

`typealias PaymentMethodBinding.ID`

A type that represents the identifier of a payment account binding.

Type Alias

# PaymentMethodBinding.ID

A type that represents the identifier of a payment account binding.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    typealias PaymentMethodBinding.ID = String

## See Also

### Creating and identifying bindings

`let id: String`

The in-app binding identifier.

`var id: ObjectIdentifier`

The stable identity of the entity associated with this instance.

Available when `PaymentMethodBinding` conforms to `AnyObject`.

Instance Method

# bind()

Asks the user to confirm whether to add the payment method to their Apple
payment methods.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    func bind() async throws

## Discussion

Important

This method displays a system prompt that asks users to authenticate with
their Apple ID. Call this method only after an explicit user action, like
tapping or clicking a button.

This method displays an Apple sheet that asks the user to confirm whether to
add the payment method associated with the in-app binding ID (`id`). If the
user confirms adding the payment method, it becomes the user’s primary payment
method for media purchases and subscriptions from Apple.

The binding succeeds if this method doesn’t throw an error.

This method throws an error in any of the following conditions:

  * The user cancels the sheet and doesn’t confirm the payment method update.

  * The in-app binding ID (`id`) is invalid or expired.

  * The user isn’t eligible.

  * The app isn’t entitled to use this API.

For more information about the errors, see
`PaymentMethodBinding.PaymentMethodBindingError` and
`StoreKitError.userCancelled`.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    static func != (lhs: PaymentMethodBinding, rhs: PaymentMethodBinding) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing bindings

`static func == (PaymentMethodBinding, PaymentMethodBinding) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    static func == (a: PaymentMethodBinding, b: PaymentMethodBinding) -> Bool

## See Also

### Comparing and hashing bindings

`static func != (PaymentMethodBinding, PaymentMethodBinding) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing bindings

`static func != (PaymentMethodBinding, PaymentMethodBinding) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (PaymentMethodBinding, PaymentMethodBinding) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing bindings

`static func != (PaymentMethodBinding, PaymentMethodBinding) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (PaymentMethodBinding, PaymentMethodBinding) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# SKError

Instance Property

# errorCode

The error code that this instance represents.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 9.0+

    
    
    var errorCode: Int { get }

## See Also

### Error properties

`var errorUserInfo: [String : Any]`

An info dictionary for providing additional details about an error.

`var localizedDescription: String`

A string containing the localized description of the error.

`var code: Code`

`var userInfo: [String : Any]`

Instance Property

# errorUserInfo

An info dictionary for providing additional details about an error.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 9.0+

    
    
    var errorUserInfo: [String : Any] { get }

## See Also

### Error properties

`var errorCode: Int`

The error code that this instance represents.

`var localizedDescription: String`

A string containing the localized description of the error.

`var code: Code`

`var userInfo: [String : Any]`

Instance Property

# localizedDescription

A string containing the localized description of the error.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 9.0+

    
    
    var localizedDescription: String { get }

## See Also

### Error properties

`var errorCode: Int`

The error code that this instance represents.

`var errorUserInfo: [String : Any]`

An info dictionary for providing additional details about an error.

`var code: Code`

`var userInfo: [String : Any]`

Instance Property

# code

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 14.5+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 12.5+

    
    
    var code: Code { get }

## See Also

### Error properties

`var errorCode: Int`

The error code that this instance represents.

`var errorUserInfo: [String : Any]`

An info dictionary for providing additional details about an error.

`var localizedDescription: String`

A string containing the localized description of the error.

`var userInfo: [String : Any]`

Instance Property

# userInfo

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 14.5+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 12.5+

    
    
    var userInfo: [String : Any] { get }

## See Also

### Error properties

`var errorCode: Int`

The error code that this instance represents.

`var errorUserInfo: [String : Any]`

An info dictionary for providing additional details about an error.

`var localizedDescription: String`

A string containing the localized description of the error.

`var code: Code`

Type Property

# unknown

Error code indicating that an unknown or unexpected error occurred.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+  Xcode 8.0+

    
    
    static var unknown: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# clientInvalid

Error code indicating that the client is not allowed to perform the attempted
action.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+  Xcode 8.0+

    
    
    static var clientInvalid: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# paymentCancelled

Error code indicating that the user canceled a payment request.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+  Xcode 8.0+

    
    
    static var paymentCancelled: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# paymentInvalid

Error code indicating that one of the payment parameters was not recognized by
the App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+  Xcode 8.0+

    
    
    static var paymentInvalid: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# paymentNotAllowed

Error code indicating that the user is not allowed to authorize payments.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+  Xcode 8.0+

    
    
    static var paymentNotAllowed: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# storeProductNotAvailable

Error code indicating that the requested product is not available in the
store.

iOS 3.0+  iPadOS 3.0+  macOS 10.15+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+  Xcode 9.0+

    
    
    static var storeProductNotAvailable: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# cloudServicePermissionDenied

Error code indicating that the user has not allowed access to Cloud service
information.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
6.2+  visionOS 1.0+  Xcode 7.3+

    
    
    static var cloudServicePermissionDenied: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# cloudServiceNetworkConnectionFailed

Error code indicating that the device could not connect to the network.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
6.2+  visionOS 1.0+  Xcode 7.3+

    
    
    static var cloudServiceNetworkConnectionFailed: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# cloudServiceRevoked

Error code indicating that the user has revoked permission to use this cloud
service.

iOS 10.3+  iPadOS 10.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 10.3+  watchOS
6.2+  visionOS 1.0+  Xcode 8.3+

    
    
    static var cloudServiceRevoked: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# privacyAcknowledgementRequired

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.0+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+  Xcode 10.2+

    
    
    static var privacyAcknowledgementRequired: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# unauthorizedRequestData

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.0+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+  Xcode 10.2+

    
    
    static var unauthorizedRequestData: SKError.Code { get }

## Discussion

To use `requestData`, an app must have a required entitlement.

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# invalidOfferIdentifier

Error code indicating that the offer identifier cannot be found or is not
active.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.0+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+  Xcode 10.2+

    
    
    static var invalidOfferIdentifier: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# invalidOfferPrice

Error code indicating that the price you specified in App Store Connect is no
longer valid.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.0+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+  Xcode 10.2+

    
    
    static var invalidOfferPrice: SKError.Code { get }

## Discussion

An offer price can become invalid if you change the price of the base
subscription such that it is lower than the offer price. Offers must always
represent a discounted price.

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# invalidSignature

Error code indicating that the signature in a payment discount is not valid.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.0+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+  Xcode 10.2+

    
    
    static var invalidSignature: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# missingOfferParams

Error code indicating that parameters are missing in a payment discount.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 13.0+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+  Xcode 10.2+

    
    
    static var missingOfferParams: SKError.Code { get }

## Discussion

This error appears if all parameters of `SKPaymentDiscount` are not present.

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# ineligibleForOffer

An error code that indicates the user is ineligible for the subscription
offer.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 14.0+  watchOS
7.0+  visionOS 1.0+  Xcode 12.0+

    
    
    static var ineligibleForOffer: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# overlayCancelled

An error code that indicates the cancellation of an overlay.

iOS 12.2+  iPadOS 12.2+  macOS 10.14.4+  Mac Catalyst 14.0+  tvOS 12.2+
watchOS 6.2+  visionOS 1.0+  Xcode 10.2+

    
    
    static var overlayCancelled: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# overlayInvalidConfiguration

An error code that indicates the overlay’s configuration is invalid.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.2+  visionOS 1.0+  Xcode 12.0+

    
    
    static var overlayInvalidConfiguration: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# overlayPresentedInBackgroundScene

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+  visionOS 1.0+  Xcode 12.5+

    
    
    static var overlayPresentedInBackgroundScene: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# overlayTimeout

An error code that indicates the timing out of an overlay.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.2+  visionOS 1.0+  Xcode 12.0+

    
    
    static var overlayTimeout: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var unsupportedPlatform: SKError.Code`

An error code that indicates the current platform doesn’t support overlays.

Type Property

# unsupportedPlatform

An error code that indicates the current platform doesn’t support overlays.

iOS 14.0+  iPadOS 14.0+  macOS 11.0+  Mac Catalyst 14.2+  watchOS 7.0+
visionOS 1.0+  Xcode 12.0+

    
    
    static var unsupportedPlatform: SKError.Code { get }

## See Also

### Error codes

`enum SKError.Code`

Error codes for StoreKit errors.

`static var unknown: SKError.Code`

Error code indicating that an unknown or unexpected error occurred.

`static var clientInvalid: SKError.Code`

Error code indicating that the client is not allowed to perform the attempted
action.

`static var paymentCancelled: SKError.Code`

Error code indicating that the user canceled a payment request.

`static var paymentInvalid: SKError.Code`

Error code indicating that one of the payment parameters was not recognized by
the App Store.

`static var paymentNotAllowed: SKError.Code`

Error code indicating that the user is not allowed to authorize payments.

`static var storeProductNotAvailable: SKError.Code`

Error code indicating that the requested product is not available in the
store.

`static var cloudServicePermissionDenied: SKError.Code`

Error code indicating that the user has not allowed access to Cloud service
information.

`static var cloudServiceNetworkConnectionFailed: SKError.Code`

Error code indicating that the device could not connect to the network.

`static var cloudServiceRevoked: SKError.Code`

Error code indicating that the user has revoked permission to use this cloud
service.

`static var privacyAcknowledgementRequired: SKError.Code`

Error code indicating that the user has not yet acknowledged Apple’s privacy
policy for Apple Music.

`static var unauthorizedRequestData: SKError.Code`

Error code indicating that the app is attempting to use a property for which
it does not have the required entitlement.

`static var invalidOfferIdentifier: SKError.Code`

Error code indicating that the offer identifier cannot be found or is not
active.

`static var invalidOfferPrice: SKError.Code`

Error code indicating that the price you specified in App Store Connect is no
longer valid.

`static var invalidSignature: SKError.Code`

Error code indicating that the signature in a payment discount is not valid.

`static var missingOfferParams: SKError.Code`

Error code indicating that parameters are missing in a payment discount.

`static var ineligibleForOffer: SKError.Code`

An error code that indicates the user is ineligible for the subscription
offer.

`static var overlayCancelled: SKError.Code`

An error code that indicates the cancellation of an overlay.

`static var overlayInvalidConfiguration: SKError.Code`

An error code that indicates the overlay’s configuration is invalid.

`static var overlayPresentedInBackgroundScene: SKError.Code`

`static var overlayTimeout: SKError.Code`

An error code that indicates the timing out of an overlay.

Type Property

# errorDomain

Gets the error domain that identifies an error as a StoreKit error.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 9.0+

    
    
    static var errorDomain: String { get }

## See Also

### Error domain

`let SKErrorDomain: String`

The error domain name for StoreKit errors.

Global Variable

# SKErrorDomain

The error domain name for StoreKit errors.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    let SKErrorDomain: String

## See Also

### Errors

Handling errors

Determine the underlying cause of errors that result from StoreKit requests.

`enum SKError.Code`

Error codes for StoreKit errors.

`struct SKError`

StoreKit error descriptions, codes, and domains.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.0+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+  Xcode 9.3+

    
    
    static func != (lhs: SKError, rhs: SKError) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Error code comparisons and hash

`static func == (SKError, SKError) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 14.5+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 7.1+

    
    
    static func == (lhs: SKError, rhs: SKError) -> Bool

## See Also

### Error code comparisons and hash

`static func != (SKError, SKError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 14.5+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 12.5+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## See Also

### Error code comparisons and hash

`static func != (SKError, SKError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (SKError, SKError) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 14.5+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 12.5+

    
    
    var hashValue: Int { get }

## See Also

### Error code comparisons and hash

`static func != (SKError, SKError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (SKError, SKError) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Initializer

# init(_:userInfo:)

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 14.5+  tvOS 9.0+  watchOS
2.0+  visionOS 1.0+  Xcode 12.5+

    
    
    init(
        _ code: Code,
        userInfo: [String : Any] = [:]
    )



# EntitlementTaskState

Enumeration Case

# EntitlementTaskState.loading

The task is loading the entitlement in the background.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case loading

## See Also

### Getting the task state

`case success(Value)`

The task successfully loaded the entitlement.

`case failure(any Error)`

The task failed to load the entitlement, with an error.

Enumeration Case

# EntitlementTaskState.success(_:)

The task successfully loaded the entitlement.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case success(Value)

## See Also

### Getting the task state

`case loading`

The task is loading the entitlement in the background.

`case failure(any Error)`

The task failed to load the entitlement, with an error.

Enumeration Case

# EntitlementTaskState.failure(_:)

The task failed to load the entitlement, with an error.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case failure(any Error)

## See Also

### Getting the task state

`case loading`

The task is loading the entitlement in the background.

`case success(Value)`

The task successfully loaded the entitlement.

Instance Property

# transaction

The transaction value if the task is successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var transaction: VerificationResult<Transaction>? { get }

Available when `Value` is `VerificationResult``<``Transaction``>?`.

## Discussion

Use `transaction` as a convenience to access the transaction value in code
that doesn’t depend on the reason a transaction isn’t available. The value is
`nil` while the transaction is loading, if it fails to load for any reason, or
if the customer isn’t entitled to the product.

## See Also

### Getting the transaction with the entitlement

`var value: Value?`

The entitlement value if the task is successful.

Instance Property

# value

The entitlement value if the task is successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var value: Value? { get }

## Discussion

This value is `nil` while the value is loading, or if it fails to load for any
reason.

Use `value` as a convenience to access the entitlement value in code that
doesn’t depend on the reason the value can’t be accessed if it fails to load.

## See Also

### Getting the transaction with the entitlement

`var transaction: VerificationResult<Transaction>?`

The transaction value if the task is successful.

Available when `Value` is `VerificationResult``<``Transaction``>?`.

Generic Instance Method

# flatMap(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func flatMap<NewValue>(_ transform: (Value) throws -> EntitlementTaskState<NewValue>) rethrows -> EntitlementTaskState<NewValue>

##  Parameters

`transform`

    

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# flatMap(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func flatMap<NewValue>(_ transform: (Value) async throws -> EntitlementTaskState<NewValue>) async rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# map(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func map<NewValue>(_ transform: (Value) throws -> NewValue) rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# map(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func map<NewValue>(_ transform: (Value) async throws -> NewValue) async rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Enumeration Case

# EntitlementTaskState.loading

The task is loading the entitlement in the background.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case loading

## See Also

### Getting the task state

`case success(Value)`

The task successfully loaded the entitlement.

`case failure(any Error)`

The task failed to load the entitlement, with an error.

Enumeration Case

# EntitlementTaskState.success(_:)

The task successfully loaded the entitlement.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case success(Value)

## See Also

### Getting the task state

`case loading`

The task is loading the entitlement in the background.

`case failure(any Error)`

The task failed to load the entitlement, with an error.

Enumeration Case

# EntitlementTaskState.failure(_:)

The task failed to load the entitlement, with an error.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case failure(any Error)

## See Also

### Getting the task state

`case loading`

The task is loading the entitlement in the background.

`case success(Value)`

The task successfully loaded the entitlement.

Instance Property

# transaction

The transaction value if the task is successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var transaction: VerificationResult<Transaction>? { get }

Available when `Value` is `VerificationResult``<``Transaction``>?`.

## Discussion

Use `transaction` as a convenience to access the transaction value in code
that doesn’t depend on the reason a transaction isn’t available. The value is
`nil` while the transaction is loading, if it fails to load for any reason, or
if the customer isn’t entitled to the product.

## See Also

### Getting the transaction with the entitlement

`var value: Value?`

The entitlement value if the task is successful.

Instance Property

# value

The entitlement value if the task is successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var value: Value? { get }

## Discussion

This value is `nil` while the value is loading, or if it fails to load for any
reason.

Use `value` as a convenience to access the entitlement value in code that
doesn’t depend on the reason the value can’t be accessed if it fails to load.

## See Also

### Getting the transaction with the entitlement

`var transaction: VerificationResult<Transaction>?`

The transaction value if the task is successful.

Available when `Value` is `VerificationResult``<``Transaction``>?`.

Generic Instance Method

# flatMap(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func flatMap<NewValue>(_ transform: (Value) throws -> EntitlementTaskState<NewValue>) rethrows -> EntitlementTaskState<NewValue>

##  Parameters

`transform`

    

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# flatMap(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func flatMap<NewValue>(_ transform: (Value) async throws -> EntitlementTaskState<NewValue>) async rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# map(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func map<NewValue>(_ transform: (Value) throws -> NewValue) rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# map(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func map<NewValue>(_ transform: (Value) async throws -> NewValue) async rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Enumeration Case

# EntitlementTaskState.loading

The task is loading the entitlement in the background.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case loading

## See Also

### Getting the task state

`case success(Value)`

The task successfully loaded the entitlement.

`case failure(any Error)`

The task failed to load the entitlement, with an error.

Enumeration Case

# EntitlementTaskState.success(_:)

The task successfully loaded the entitlement.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case success(Value)

## See Also

### Getting the task state

`case loading`

The task is loading the entitlement in the background.

`case failure(any Error)`

The task failed to load the entitlement, with an error.

Enumeration Case

# EntitlementTaskState.failure(_:)

The task failed to load the entitlement, with an error.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    case failure(any Error)

## See Also

### Getting the task state

`case loading`

The task is loading the entitlement in the background.

`case success(Value)`

The task successfully loaded the entitlement.

Instance Property

# transaction

The transaction value if the task is successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var transaction: VerificationResult<Transaction>? { get }

Available when `Value` is `VerificationResult``<``Transaction``>?`.

## Discussion

Use `transaction` as a convenience to access the transaction value in code
that doesn’t depend on the reason a transaction isn’t available. The value is
`nil` while the transaction is loading, if it fails to load for any reason, or
if the customer isn’t entitled to the product.

## See Also

### Getting the transaction with the entitlement

`var value: Value?`

The entitlement value if the task is successful.

Instance Property

# value

The entitlement value if the task is successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    var value: Value? { get }

## Discussion

This value is `nil` while the value is loading, or if it fails to load for any
reason.

Use `value` as a convenience to access the entitlement value in code that
doesn’t depend on the reason the value can’t be accessed if it fails to load.

## See Also

### Getting the transaction with the entitlement

`var transaction: VerificationResult<Transaction>?`

The transaction value if the task is successful.

Available when `Value` is `VerificationResult``<``Transaction``>?`.

Generic Instance Method

# flatMap(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func flatMap<NewValue>(_ transform: (Value) throws -> EntitlementTaskState<NewValue>) rethrows -> EntitlementTaskState<NewValue>

##  Parameters

`transform`

    

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# flatMap(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func flatMap<NewValue>(_ transform: (Value) async throws -> EntitlementTaskState<NewValue>) async rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# map(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func map<NewValue>(_ transform: (Value) throws -> NewValue) rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

Generic Instance Method

# map(_:)

Returns a new state, mapping the entitlement value if successful.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func map<NewValue>(_ transform: (Value) async throws -> NewValue) async rethrows -> EntitlementTaskState<NewValue>

## See Also

### Helper methods

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) ->
EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.

`func map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>`

Returns a new state, mapping the entitlement value if successful.



# Transaction

Type Property

# updates

The asynchronous sequence that emits a transaction when the system creates or
updates transactions that occur outside of the app or on other devices.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var updates: Transaction.Transactions { get }

## Discussion

Use `updates` to receive new transactions while the app is running. This
sequence receives transactions that occur outside of the app, such as Ask to
Buy transactions, subscription offer code redemptions, and purchases that
customers make in the App Store. It also emits transactions that customers
complete in your app on another device.

Note that after a successful in-app purchase on the same device, StoreKit
returns the transaction through `Product.PurchaseResult.success(_:)`.

Important

Create a `Task` to iterate through the transactions from the listener as soon
as your app launches. If your app has unfinished transactions, the `updates`
listener receives them once, immediately after the app launches. Without the
`Task` to listen for these transactions, your app may miss them.

The following example shows a class that creates a `Task` when it initializes.
The task retrieves and processes any unfinished transactions.

The `updates` listener receives unfinished transactions just once at app
launch, but you can use the `unfinished` listener to get your app’s unfinished
transactions at any time. For information on finishing transactions, see
`finish()`.

## See Also

### Monitoring transaction-related changes

`struct Transaction.Transactions`

An asynchronous sequence of transactions.

### Related Documentation

Supporting subscription offer codes in your app

Provide subscription service for customers who redeem offer codes through the
App Store or within your app.

Type Method

# latest(for:)

Gets the user’s latest transaction for an in-app purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func latest(for productID: String) async -> VerificationResult<Transaction>?

##  Parameters

`productID`

    

The product identifier that the function uses to look up the latest
transaction.

## Return Value

A `VerificationResult` with a single `Transaction`, or `nil` if the user
hasn't purchased the product.

## Discussion

Call this function for any type of in-app purchase. The following example
illustrates requesting the latest transaction to determine if the user
purchased the product indicated by the string `productIdentifier`.

## See Also

### Getting transaction history

`static var all: Transaction.Transactions`

A sequence that emits all the transactions for the user for your app.

`static var unfinished: Transaction.Transactions`

A sequence that emits unfinished transactions for the user.

Type Property

# all

A sequence that emits all the transactions for the user for your app.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var all: Transaction.Transactions { get }

## Discussion

This sequence returns the user’s transaction history current to the moment you
access it. The sequence emits a finite number of transactions. If the App
Store processes additional transactions for the user while you’re accessing
this sequence, they appear in the transaction listener `updates`.

The transaction history includes consumable in-app purchases that the app
hasn’t finished by calling `finish()`. It doesn’t include finished consumable
products or finished non-renewing subscriptions, repurchased non-consumable
products or subscriptions, or restored purchases.

## See Also

### Getting transaction history

`static func latest(for: String) -> VerificationResult<Transaction>?`

Gets the user’s latest transaction for an in-app purchase.

`static var unfinished: Transaction.Transactions`

A sequence that emits unfinished transactions for the user.

Type Property

# unfinished

A sequence that emits unfinished transactions for the user.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var unfinished: Transaction.Transactions { get }

## Discussion

A transaction is unfinished until you call `finish()`. Use the `unfinished`
sequence to find the transactions your app needs to process to deliver
purchased content or enable service.

## See Also

### Finishing the transaction

`func finish()`

Indicates to the App Store that the app delivered the purchased content or
enabled the service to finish the transaction.

Type Property

# currentEntitlements

A sequence of the latest transactions that entitle a user to in-app purchases
and subscriptions.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var currentEntitlements: Transaction.Transactions { get }

## Discussion

The current entitlements sequence emits the latest transaction for each
product the user has an entitlement to, specifically:

  * A transaction for each non-consumable in-app purchase

  * The latest transaction for each auto-renewable subscription that has a `Product.SubscriptionInfo.RenewalState` state of `subscribed` or `inGracePeriod`

  * The latest transaction for each non-renewing subscription, including finished ones

Products that the App Store has refunded or revoked don’t appear in the
current entitlements. Consumable in-app purchases also don't appear in the
current entitlements. To get transactions for unfinished consumables, use the
`unfinished` or `all` sequences in `Transaction`.

The following example illustrates iterating through the current entitlements:

## See Also

### Getting current entitlements

`static func currentEntitlement(for: String) ->
VerificationResult<Transaction>?`

Gets the latest transactions that entitle the user to a specified product.

Type Method

# currentEntitlement(for:)

Gets the latest transactions that entitle the user to a specified product.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func currentEntitlement(for productID: String) async -> VerificationResult<Transaction>?

##  Parameters

`productID`

    

In-app purchase product identifier.

## Return Value

A `VerificationResult` or `nil` if the user has no current in-app purchases.

## See Also

### Getting current entitlements

`static var currentEntitlements: Transaction.Transactions`

A sequence of the latest transactions that entitle a user to in-app purchases
and subscriptions.

Instance Method

# finish()

Indicates to the App Store that the app delivered the purchased content or
enabled the service to finish the transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func finish() async

## Discussion

Call `finish()` to complete a transaction after you deliver the purchased
content or enable the purchased service. For on-demand resources, don’t finish
the transaction until the app completes downloading the resource or you’ve
otherwise delivered the resource.

## See Also

### Finishing the transaction

`static var unfinished: Transaction.Transactions`

A sequence that emits unfinished transactions for the user.

Type Property

# unfinished

A sequence that emits unfinished transactions for the user.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static var unfinished: Transaction.Transactions { get }

## Discussion

A transaction is unfinished until you call `finish()`. Use the `unfinished`
sequence to find the transactions your app needs to process to deliver
purchased content or enable service.

## See Also

### Finishing the transaction

`func finish()`

Indicates to the App Store that the app delivered the purchased content or
enabled the service to finish the transaction.

Instance Property

# deviceVerification

The device verification value you use to verify whether the transaction
belongs to the device.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerification: Data

## Discussion

Whenever StoreKit returns a verified transaction, the transaction is valid for
the device. To perform your own verification, compute the device verification
hash as follows:

  1. Get the lowercase UUID string representation of `deviceVerificationNonce`.

  2. Append the lowercase UUID string representation of `deviceVerificationID`.

  3. Compute the SHA-384 hash of the ASCII representation of the combined string.

Compare the value you calculated to the transaction’s `deviceVerification`
value. If the values match, the transaction is valid for the device.
Otherwise, the verification fails and the transaction isn’t valid for the
device. The following example illustrates validating a transaction.

## See Also

### Verifying transactions

`let deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

`let signedDate: Date`

The date that the App Store signed the JWS transaction.

Instance Property

# deviceVerificationNonce

The UUID used to compute the device verification value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let deviceVerificationNonce: UUID

## Discussion

Use the lowercased nonce when computing the `deviceVerification` value.

## See Also

### Verifying transactions

`let deviceVerification: Data`

The device verification value you use to verify whether the transaction
belongs to the device.

`let signedDate: Date`

The date that the App Store signed the JWS transaction.

Instance Property

# signedDate

The date that the App Store signed the JWS transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    let signedDate: Date

## Discussion

Use the `signedDate` to verify whether the certificate used to sign the
transaction was valid when the App Store signed the transaction.

## See Also

### Verifying transactions

`let deviceVerification: Data`

The device verification value you use to verify whether the transaction
belongs to the device.

`let deviceVerificationNonce: UUID`

The UUID used to compute the device verification value.

Instance Property

# jsonRepresentation

The raw JSON representation of the transaction information.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var jsonRepresentation: Data { get }

Article

# Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

## Overview

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests, which enable your customers to request a refund from within
your app. Your app displays the refund request sheet by calling any of these
methods: `beginRefundRequest(for:in:)` , `beginRefundRequest(in:)`,
`beginRefundRequest(for:in:)`, `beginRefundRequest(in:)`, or
`refundRequestSheet(for:isPresented:onDismiss:)`. Customers fill out the sheet
to submit the request.

Depending on your testing setup, the App Store automatically approves or
declines the refund request in the testing environment. Note that the App
Store doesn’t send emails for refund requests in testing environments.

### Test approved refunds

To set up a test for approved refunds, select any refund reason on the refund
request sheet, and submit the sheet. The App Store automatically approves the
refund request in the testing environment.

Your app receives a `Transaction` with refund information in the
`revocationDate` and `revocationReason` properties. If you’re testing in the
sandbox environment and your server receives App Store Server Notifications V2
for the sandbox, it gets a notification with a `REFUND` `notificationType`.

### Test declined refunds

To set up a test for declined refunds, follow these steps on the refund
request sheet with your app running in the sandbox environment:

  1. Under Issue, select Other.

  2. In the text box, type REJECT.

  3. Tap Request Refund.

The App Store automatically rejects the refund request in the testing
environment.

If your server receives App Store Server Notifications V2 for the sandbox
environment, it gets a notification with a `REFUND_DECLINED`
`notificationType`.

For more information on receiving server notifications for the sandbox
environment, see Enabling App Store Server Notifications. For more information
on testing, see Testing at all stages of development with Xcode and the
sandbox and Setting up StoreKit Testing in Xcode.

## See Also

### Testing in-app purchases

Testing at all stages of development with Xcode and the sandbox

Verify your implementation of in-app purchases by testing your code throughout
its development.

Testing in-app purchases with sandbox

Test your implementation of in-app purchases using real product information
and server-to-server transactions in the sandbox environment.

Instance Method

# beginRefundRequest(in:)

Presents the refund request sheet for the transaction in a window scene.

iOS 15.0+  iPadOS 15.0+  Mac Catalyst 15.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func beginRefundRequest(in scene: UIWindowScene) async throws -> Transaction.RefundRequestStatus

##  Parameters

`scene`

    

The `UIWindowScene` that the system displays the sheet on.

## Return Value

`Transaction.RefundRequestStatus`

## Discussion

Call this function from account settings or a help menu to enable customers to
request a refund for an in-app purchase within your app. When you call this
function, the system displays a refund sheet with the customer’s purchase
details and a list of reason codes for the customer to choose from. For design
guidance, see Human Interface Guidelines > In-app purchase > Providing help
with in-app purchases.

When a customer requests a refund for consumable in-app purchases through your
app, the App Stores sends a `CONSUMPTION_REQUEST` `notificationType` to your
server. If the customer provided consent, respond by sending consumption data
to the App Store using the Send Consumption Information endpoint. If not,
don’t respond to the `CONSUMPTION_REQUEST` notification.

The App Store takes up to 48 hours to either approve or deny a refund.

For information about setting up your server to receive notifications, see
Enabling App Store Server Notifications.

Note

If your app uses SwiftUI, use `refundRequestSheet(for:isPresented:onDismiss:)`
instead. For example usage, see Food Truck: Building a SwiftUI multiplatform
app.

### Test refund requests

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests. For more information, see Testing refund requests.

## See Also

### Requesting refunds

Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

`func beginRefundRequest(in: NSViewController) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the transaction in a view controller.

`static func beginRefundRequest(for: UInt64, in: UIWindowScene) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the specified transaction in a window
scene.

`static func beginRefundRequest(for: UInt64, in: NSViewController) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the specified transaction in a view
controller.

`enum Transaction.RefundRequestError`

The error codes for refund requests.

`enum Transaction.RefundRequestStatus`

The status codes for refund requests.

Instance Method

# beginRefundRequest(in:)

Presents the refund request sheet for the transaction in a view controller.

macOS 12.0+  Xcode 13.0+

    
    
    func beginRefundRequest(in controller: NSViewController) async throws -> Transaction.RefundRequestStatus

##  Parameters

`controller`

    

The `NSViewController` that the system displays the sheet on.

## Return Value

`Transaction.RefundRequestStatus`

## Discussion

Call this function from account settings or a help menu to enable customers to
request a refund for an in-app purchase within your app. When you call this
function, the system displays a refund sheet with the customer’s purchase
details and a list of reason codes for the customer to choose from. For design
guidance, see Human Interface Guidelines > In-app purchase > Providing help
with in-app purchases.

When a customer requests a refund for consumable in-app purchases through your
app, the App Stores sends a `CONSUMPTION_REQUEST` `notificationType` to your
server. If the customer provided consent, respond by sending consumption data
to the App Store using the Send Consumption Information endpoint. If not,
don’t respond to the `CONSUMPTION_REQUEST` notification.

The App Store takes up to 48 hours to either approve or deny a refund.

For information about setting up your server to receive notifications, see
Enabling App Store Server Notifications.

Note

If your app uses SwiftUI, use `refundRequestSheet(for:isPresented:onDismiss:)`
instead. For example usage, see Food Truck: Building a SwiftUI multiplatform
app.

### Test refund requests

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests. For more information, see Testing refund requests.

## See Also

### Requesting refunds

Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

`func beginRefundRequest(in: UIWindowScene) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the transaction in a window scene.

`static func beginRefundRequest(for: UInt64, in: UIWindowScene) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the specified transaction in a window
scene.

`static func beginRefundRequest(for: UInt64, in: NSViewController) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the specified transaction in a view
controller.

`enum Transaction.RefundRequestError`

The error codes for refund requests.

`enum Transaction.RefundRequestStatus`

The status codes for refund requests.

Type Method

# beginRefundRequest(for:in:)

Presents the refund request sheet for the specified transaction in a window
scene.

iOS 15.0+  iPadOS 15.0+  Mac Catalyst 15.0+  visionOS 1.0+  Xcode 13.0+

    
    
    @MainActor
    static func beginRefundRequest(
        for transactionID: UInt64,
        in scene: UIWindowScene
    ) async throws -> Transaction.RefundRequestStatus

##  Parameters

`transactionID`

    

The identifier of the transaction the user is requesting a refund for.

`scene`

    

The `UIWindowScene` that the system displays the sheet on.

## Return Value

`Transaction.RefundRequestStatus`

## Discussion

Call this function from account settings or a help menu to enable customers to
request a refund for an in-app purchase within your app. When you call this
function, the system displays a refund sheet with the customer’s purchase
details and a list of reason codes for the customer to choose from. For design
guidance, see Human Interface Guidelines > In-app purchase > Providing help
with in-app purchases.

When a customer requests a refund for consumable in-app purchases through your
app, the App Stores sends a `CONSUMPTION_REQUEST` `notificationType` to your
server. If the customer provided consent, respond by sending consumption data
to the App Store using the Send Consumption Information endpoint. If not,
don’t respond to the `CONSUMPTION_REQUEST` notification.

The App Store takes up to 48 hours to either approve or deny a refund.

For information about setting up your server to receive notifications, see
Enabling App Store Server Notifications.

Note

If your app uses SwiftUI, use `refundRequestSheet(for:isPresented:onDismiss:)`
instead. For example usage, see Food Truck: Building a SwiftUI multiplatform
app.

### Test refund requests

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests. For more information, see Testing refund requests.

## See Also

### Requesting refunds

Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

`func beginRefundRequest(in: UIWindowScene) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the transaction in a window scene.

`func beginRefundRequest(in: NSViewController) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the transaction in a view controller.

`static func beginRefundRequest(for: UInt64, in: NSViewController) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the specified transaction in a view
controller.

`enum Transaction.RefundRequestError`

The error codes for refund requests.

`enum Transaction.RefundRequestStatus`

The status codes for refund requests.

Type Method

# beginRefundRequest(for:in:)

Presents the refund request sheet for the specified transaction in a view
controller.

macOS 12.0+  Xcode 13.0+

    
    
    static func beginRefundRequest(
        for transactionID: UInt64,
        in controller: NSViewController
    ) async throws -> Transaction.RefundRequestStatus

##  Parameters

`transactionID`

    

The identifier of the transaction the user is requesting a refund for.

`controller`

    

The `NSViewController` that the system displays the sheet on.

## Return Value

`Transaction.RefundRequestStatus`

## Discussion

Call this function from account settings or a help menu to enable customers to
request a refund for an in-app purchase within your app. When you call this
function, the system displays a refund sheet with the customer’s purchase
details and a list of reason codes for the customer to choose from. For design
guidance, see Human Interface Guidelines > In-app purchase > Providing help
with in-app purchases.

When a customer requests a refund for consumable in-app purchases through your
app, the App Stores sends a `CONSUMPTION_REQUEST` `notificationType` to your
server. If the customer provided consent, respond by sending consumption data
to the App Store using the Send Consumption Information endpoint. If not,
don’t respond to the `CONSUMPTION_REQUEST` notification.

The App Store takes up to 48 hours to either approve or deny a refund.

For information about setting up your server to receive notifications, see
Enabling App Store Server Notifications.

Note

If your app uses SwiftUI, use `refundRequestSheet(for:isPresented:onDismiss:)`
instead. For example usage, see Food Truck: Building a SwiftUI multiplatform
app.

### Test refund requests

The sandbox environment and StoreKit Testing in Xcode both support testing
refund requests. For more information, see Testing refund requests.

## See Also

### Requesting refunds

Testing refund requests

Test your app’s implementation of refund requests, and your app’s and server’s
handling of approved and declined refunds.

`func beginRefundRequest(in: UIWindowScene) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the transaction in a window scene.

`func beginRefundRequest(in: NSViewController) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the transaction in a view controller.

`static func beginRefundRequest(for: UInt64, in: UIWindowScene) ->
Transaction.RefundRequestStatus`

Presents the refund request sheet for the specified transaction in a window
scene.

`enum Transaction.RefundRequestError`

The error codes for refund requests.

`enum Transaction.RefundRequestStatus`

The status codes for refund requests.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Transaction, rhs: Transaction) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing transactions

`static func == (Transaction, Transaction) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (lhs: Transaction, rhs: Transaction) -> Bool

## See Also

### Comparing and hashing transactions

`static func != (Transaction, Transaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing transactions

`static func != (Transaction, Transaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Transaction, Transaction) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing transactions

`static func != (Transaction, Transaction) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Transaction, Transaction) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

Instance Property

# debugDescription

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var debugDescription: String { get }

## Relationships

### From Protocol

  * `CustomDebugStringConvertible`

Instance Property

# currency

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 17.2+  tvOS 16.0+  watchOS
9.0+  visionOS 1.1+  Xcode 14.0+

    
    
    @backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2, visionOS 1.1)
    var currency: Locale.Currency? { get }

Instance Property

# currencyCode

iOS 15.0–16.0  Deprecated  iPadOS 15.0–16.0  Deprecated  macOS 12.0–13.0
Deprecated  Mac Catalyst 17.2–17.2  Deprecated  tvOS 15.0–16.0  Deprecated
watchOS 8.0–9.0  Deprecated  visionOS 1.1–1.1  Deprecated  Xcode 13.0–14.0
Deprecated

    
    
    @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0)
    var currencyCode: String? { get }

Instance Property

# price

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 17.2+  tvOS 15.0+  watchOS
8.0+  visionOS 1.1+  Xcode 13.0+

    
    
    @backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2, visionOS 1.1)
    var price: Decimal? { get }



# Product Dictionary Keys

Global Variable

# SKStoreProductParameterITunesItemIdentifier

The key representing the iTunes identifier for the item you want the store to
display when the view controller is presented.

iOS 6.0+  iPadOS 6.0+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.0+

    
    
    let SKStoreProductParameterITunesItemIdentifier: String

## Discussion

The value for this key, an iTunes item identifier, is an instance of
`NSNumber`.

To find a product’s iTunes identifier, go to linkmaker.itunes.apple.com and
search for the product, then locate the iTunes identifier in the link URL. For
example, the iTunes identifier for the iBooks app is 364709193.

Global Variable

# SKStoreProductParameterProductIdentifier

The key representing the product identifier for the promoted product you want
the store to display at the top of the page.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 11.0+

    
    
    let SKStoreProductParameterProductIdentifier: String

## Discussion

The value for this key is an instance of `NSString`.

When your app uses an `SKStoreProductViewController` to render an app page for
another app, you can optionally choose to highlight an in-app purchase by
displaying it at the top of the store page. Set
`SKStoreProductParameterProductIdentifier` to the identifier of the product
you want displayed at the top of the page.

The product indicated by the identifier must be set up as a promoted product
in the App Store, otherwise the identifier is ignored. See Promoting In-App
Purchases.

Note

Use the same product identifiers as used in the `productIdentifier` variable
in the `SKProduct` class.

## See Also

### Affiliate and Analytics Keys

`let SKStoreProductParameterAdvertisingPartnerToken: String`

The key representing the advertising partner you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterAffiliateToken: String`

The key representing the affiliate identifier you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterCampaignToken: String`

The key representing an App Analytics campaign.

`let SKStoreProductParameterProviderToken: String`

The key representing the provider token for the developer that created the app
specified by the `SKStoreProductParameterITunesItemIdentifier` key.

`let SKStoreProductParameterCustomProductPageIdentifier: String`

Global Variable

# SKStoreProductParameterAdvertisingPartnerToken

The key representing the advertising partner you wish to use for any purchase
made through the view controller.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.2+

    
    
    let SKStoreProductParameterAdvertisingPartnerToken: String

## Discussion

The value for this key is an instance of `NSString`.

## See Also

### Affiliate and Analytics Keys

`let SKStoreProductParameterProductIdentifier: String`

The key representing the product identifier for the promoted product you want
the store to display at the top of the page.

`let SKStoreProductParameterAffiliateToken: String`

The key representing the affiliate identifier you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterCampaignToken: String`

The key representing an App Analytics campaign.

`let SKStoreProductParameterProviderToken: String`

The key representing the provider token for the developer that created the app
specified by the `SKStoreProductParameterITunesItemIdentifier` key.

`let SKStoreProductParameterCustomProductPageIdentifier: String`

Global Variable

# SKStoreProductParameterAffiliateToken

The key representing the affiliate identifier you wish to use for any purchase
made through the view controller.

iOS 8.0+  iPadOS 8.0+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.0+

    
    
    let SKStoreProductParameterAffiliateToken: String

## Discussion

The value for this key is an instance of `NSString`.

You receive an affiliate identifier when you sign up for the Affiliate
Program. The affiliate associated with this view controller is paid a
commission for any items purchased using the controller.

Learn more about the Affiliate Program at https://apple.com/itunes/affiliates.

## See Also

### Affiliate and Analytics Keys

`let SKStoreProductParameterProductIdentifier: String`

The key representing the product identifier for the promoted product you want
the store to display at the top of the page.

`let SKStoreProductParameterAdvertisingPartnerToken: String`

The key representing the advertising partner you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterCampaignToken: String`

The key representing an App Analytics campaign.

`let SKStoreProductParameterProviderToken: String`

The key representing the provider token for the developer that created the app
specified by the `SKStoreProductParameterITunesItemIdentifier` key.

`let SKStoreProductParameterCustomProductPageIdentifier: String`

Global Variable

# SKStoreProductParameterCampaignToken

The key representing an App Analytics campaign.

iOS 8.0+  iPadOS 8.0+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.0+

    
    
    let SKStoreProductParameterCampaignToken: String

## Discussion

The value for this key is an instance of `NSString`, containing any 40-byte
string.

This token allows you to track the effectiveness of your Affiliate Program
link and your App Analytics campaign.

For more information about the Affiliate Program, see the Affiliate Program at
https://apple.com/itunes/affiliates. For more information about App Store
Connect Analytics, see App Store Connect Developer Guide.

## See Also

### Affiliate and Analytics Keys

`let SKStoreProductParameterProductIdentifier: String`

The key representing the product identifier for the promoted product you want
the store to display at the top of the page.

`let SKStoreProductParameterAdvertisingPartnerToken: String`

The key representing the advertising partner you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterAffiliateToken: String`

The key representing the affiliate identifier you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterProviderToken: String`

The key representing the provider token for the developer that created the app
specified by the `SKStoreProductParameterITunesItemIdentifier` key.

`let SKStoreProductParameterCustomProductPageIdentifier: String`

Global Variable

# SKStoreProductParameterProviderToken

The key representing the provider token for the developer that created the app
specified by the `SKStoreProductParameterITunesItemIdentifier` key.

iOS 8.3+  iPadOS 8.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.0+

    
    
    let SKStoreProductParameterProviderToken: String

## Discussion

The value for this key is an instance of `NSString`.

Use your own provider token when cross promoting your own apps. This token
lets you track the effectiveness of the cross promotion effort separate from
any affiliate campaign that shares the same campaign token.

When promoting apps for other developers, use their provider token instead. In
this case, the token lets the developer track the effectiveness of your App
Analytics campaign for their apps.

The key must be used in combination with your campaign token,
`SKStoreProductParameterCampaignToken`. For more information, see App Store
Connect Developer Guide.

## See Also

### Affiliate and Analytics Keys

`let SKStoreProductParameterProductIdentifier: String`

The key representing the product identifier for the promoted product you want
the store to display at the top of the page.

`let SKStoreProductParameterAdvertisingPartnerToken: String`

The key representing the advertising partner you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterAffiliateToken: String`

The key representing the affiliate identifier you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterCampaignToken: String`

The key representing an App Analytics campaign.

`let SKStoreProductParameterCustomProductPageIdentifier: String`

Global Variable

# SKStoreProductParameterCustomProductPageIdentifier

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+

    
    
    let SKStoreProductParameterCustomProductPageIdentifier: String

## See Also

### Affiliate and Analytics Keys

`let SKStoreProductParameterProductIdentifier: String`

The key representing the product identifier for the promoted product you want
the store to display at the top of the page.

`let SKStoreProductParameterAdvertisingPartnerToken: String`

The key representing the advertising partner you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterAffiliateToken: String`

The key representing the affiliate identifier you wish to use for any purchase
made through the view controller.

`let SKStoreProductParameterCampaignToken: String`

The key representing an App Analytics campaign.

`let SKStoreProductParameterProviderToken: String`

The key representing the provider token for the developer that created the app
specified by the `SKStoreProductParameterITunesItemIdentifier` key.



# LargeProductViewStyle

Type Property

# large

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
visionOS 1.0+  Xcode 15.0+

    
    
    static var large: LargeProductViewStyle { get }

Instance Method

# makeBody(configuration:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
visionOS 1.0+  Xcode 15.0+

    
    
    func makeBody(configuration: LargeProductViewStyle.Configuration) -> some View

## Relationships

### From Protocol

  * `ProductViewStyle`

## See Also

### Creating the style

`typealias LargeProductViewStyle.Body`

`init()`

Type Alias

# LargeProductViewStyle.Body

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
visionOS 1.0+  Xcode 15.0+

    
    
    typealias LargeProductViewStyle.Body = some View

## Relationships

### From Protocol

  * `ProductViewStyle`

## See Also

### Creating the style

`func makeBody(configuration: LargeProductViewStyle.Configuration) -> View`

`init()`

Initializer

# init()

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
visionOS 1.0+  Xcode 15.0+

    
    
    init()

## See Also

### Creating the style

`func makeBody(configuration: LargeProductViewStyle.Configuration) -> View`

`typealias LargeProductViewStyle.Body`



# PurchaseIntent

Instance Property

# id

The product identifier of the promoted in-app purchase that the user selects
to purchase on the App Store.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    var id: Product.ID { get }

## See Also

### Identifying the product

`let product: Product`

The product information of the promoted in-app purchase the user selects to
purchase on the App Store.

Instance Property

# product

The product information of the promoted in-app purchase the user selects to
purchase on the App Store.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    let product: Product

## Discussion

To enable users to complete the purchase they start on the App Store, call
`purchase(options:)` on this product instance.

## See Also

### Identifying the product

`var id: Product.ID`

The product identifier of the promoted in-app purchase that the user selects
to purchase on the App Store.

Type Property

# intents

The asynchronous sequence that emits a purchase intent when the user selects a
promoted in-app purchase on the App Store.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static var intents: PurchaseIntent.PurchaseIntents { get }

## Discussion

When a user selects to purchase a promoted product on the App Store, your app
receives a purchase intent. Use the `product` object to complete your app’s
purchase workflow, including finishing the purchase, unlocking the product,
and any other workflow specific to your app.

The following example code receives the purchase intent, and calls a method to
complete the purchase workflow:

## See Also

### Getting purchase intents

`struct PurchaseIntent.PurchaseIntents`

An asynchronous sequence of purchase intents for in-app purchases that users
initiate on the App Store.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func != (lhs: PurchaseIntent, rhs: PurchaseIntent) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing purchase intents

`static func == (PurchaseIntent, PurchaseIntent) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 16.4+  iPadOS 16.4+  macOS 14.4+  Mac Catalyst 16.4+  Xcode 14.3+

    
    
    static func == (a: PurchaseIntent, b: PurchaseIntent) -> Bool

## See Also

### Comparing purchase intents

`static func != (PurchaseIntent, PurchaseIntent) -> Bool`

Returns a Boolean value indicating whether two values are not equal.



# SKAdNetwork release notes

Article

# SKAdNetwork 4 release notes

A version of SKAdNetwork available in iOS 16.1 and later.

## Overview

Use `“4.0”` as the version number when signing ads for this version.

You’re eligible to receive a version 4 postback if all participants meet the
following conditions:

  * The ad network generates an ad signature for version 4.

  * For ads that appear in an app, the app is built with iOS 16.1 SDK or later. For web ads, the ad appears in Safari 16.1 or later. 

  * The advertised app is App Store-signed and is running on a device with iOS 16.1 or later. 

Advertised apps built with iOS 16.1 SDK or later can register up to three
conversions that result in postbacks for the winning ad impression. Apps built
with earlier SDKs can register only one conversion, resulting in one winning
postback.

### New features

  * **Multiple postbacks.** SKAdNetwork now supports multiple conversions in three conversion windows. When you call the new methods `updatePostbackConversionValue(_:coarseValue:completionHandler:)` and `updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`, the app can update conversion values in three separate conversion windows. The app may send up to three postbacks for the winning ad attribution. 

You can lock a conversion during a conversion window to receive the postback
sooner by calling
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
and setting the lock to `true`. Otherwise, the system sends postbacks after
the conversion window closes. For more information about postback timing, see
Receiving ad attributions and postbacks. For more information about multiple
postbacks, see Receiving postbacks in multiple conversion windows.

  * **Coarse conversion values.** The conversion value that you send can include both a fine-grained value and a coarse-grained value. For information about coarse conversion values, see `SKAdNetwork.CoarseConversionValue`. You provide the fine and coarse conversion values in the new methods `updatePostbackConversionValue(_:coarseValue:completionHandler:)` and `updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`.

  * **Hierarchical source identifiers.** Ad networks can now provide hierarchical source identifiers when they sign an ad, which replaces and expands on campaign identifiers. The source identifer is a four-digit integer, which you indicate in `sourceIdentifier` for view-through ads and in `SKStoreProductParameterAdNetworkSourceIdentifier` for StoreKit-rendered ads. Winning postbacks contain two, three, or four digits of the source identifier, depending on the ad impression’s privacy threshold tier. 

  * **Attributed ads on the web.** SKAdNetwork for Web Ads supports attributed ads that you initiate on Safari web pages.

## See Also

### SKAdNetwork versions

SKAdNetwork 3 release notes

A version of SKAdNetwork available in iOS 14.6 and later.

SKAdNetwork 2.2 release notes

A version of SKAdNetwork available in iOS 14.5 and later.

SKAdNetwork 2.1 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 2 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 1 release notes

A version of SKAdNetwork available in iOS 11.3 and later.

Article

# SKAdNetwork 3 release notes

A version of SKAdNetwork available in iOS 14.6 and later.

## Overview

Use `“3.0”` as the version number when signing ads for this version.

You’re eligible to receive a version 3.0 postback if all three of the
following conditions are met:

  * The source app generates a signature for version 3.0.

  * The source app is built with iOS 14.6 SDK or later.

  * The advertised app is App Store-signed and is running on a device with iOS 14.6 or later.

### New features

New features include:

  * Devices can now send install-validation postbacks to multiple ad networks that sign their ads using version 3.0. One ad network receives a postback with a `did-win` parameter value of `true` for the ad impression that wins the ad attribution. Up to five other ad networks receive a postback with a `did-win` parameter value of `false` if their ad impressions qualified for, but didn’t win, the attribution.

For more information about signing ads with version 3.0, see Signing and
providing ads. For more information about your ad’s eligibility to receive an
attribution or a non-winning postback, see Receiving ad attributions and
postbacks. For details about the postback, see Verifying an install-validation
postback.

## See Also

### SKAdNetwork versions

SKAdNetwork 4 release notes

A version of SKAdNetwork available in iOS 16.1 and later.

SKAdNetwork 2.2 release notes

A version of SKAdNetwork available in iOS 14.5 and later.

SKAdNetwork 2.1 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 2 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 1 release notes

A version of SKAdNetwork available in iOS 11.3 and later.

Article

# SKAdNetwork 2.2 release notes

A version of SKAdNetwork available in iOS 14.5 and later.

## Overview

Use `“2.2”` as the version number when signing ads for this version.

Ad networks are eligible to receive a version 2.2 postback if all three of the
following conditions are met:

  * The source app generates a signature for version 2.2.

  * The source app is built with iOS 14.5 SDK or later.

  * The advertised app is App Store-signed and running on a device with iOS 14.5 or later.

### New features

New features include:

  * You can now create view-through ads using the new APIs `SKAdImpression` , `startImpression(_:completionHandler:)`, and `endImpression(_:completionHandler:)`. 

  * You can now indicate whether an ad is a view-through ad or a StoreKit-rendered ad by using the new `fidelity-type` parameter. The `fidelity-type` value is `0` for view-through ads, and `1` for StoreKit-rendered ads. You include this parameter when you sign an ad, and receive it in the postback.

For more information about view-through ads and` fidelity-type`, see Signing
and providing ads and Generating the signature to validate view-through ads.
For more information about the postback, see Verifying an install-validation
postback.

## See Also

### SKAdNetwork versions

SKAdNetwork 4 release notes

A version of SKAdNetwork available in iOS 16.1 and later.

SKAdNetwork 3 release notes

A version of SKAdNetwork available in iOS 14.6 and later.

SKAdNetwork 2.1 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 2 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 1 release notes

A version of SKAdNetwork available in iOS 11.3 and later.

Article

# SKAdNetwork 2.1 release notes

A version of SKAdNetwork available in iOS 14 and later.

## Overview

Use `“2.1”` as the version number when signing ads for this version.

Ad networks are eligible to receive a version 2.1 postback if all three of the
following conditions are met:

  * The source app generates a signature for version 2.1.

  * The source app is built with the iOS 14 SDK or later.

  * The advertised app is App Store-signed and running on a device with iOS 14 or later.

### New features

New features include:

  * SKAdNetwork now signs install-validation postbacks using Apple’s NIST P-256 public key. For more information, see Verifying an install-validation postback.

## See Also

### SKAdNetwork versions

SKAdNetwork 4 release notes

A version of SKAdNetwork available in iOS 16.1 and later.

SKAdNetwork 3 release notes

A version of SKAdNetwork available in iOS 14.6 and later.

SKAdNetwork 2.2 release notes

A version of SKAdNetwork available in iOS 14.5 and later.

SKAdNetwork 2 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 1 release notes

A version of SKAdNetwork available in iOS 11.3 and later.

Article

# SKAdNetwork 2 release notes

A version of SKAdNetwork available in iOS 14 and later.

## Overview

Use `“2.0”` as the version number when signing ads for this version.

Ad networks are eligible to receive a version 2.0 postback if all three of the
following conditions are met:

  * The source app generates a signature for version 2.0.

  * The source app is built with the iOS 14 SDK or later.

  * The advertised app is App Store-signed and running on a device with iOS 14 or later.

When verifying an install-validation postback for version 2.0, use the
following Apple P-192 public key:

    
    
    MEkwEwYHKoZIzj0CAQYIKoZIzj0DAQEDMgAEMyHD625uvsmGq4C43cQ9BnfN2xslVT5V1nOmAMP6qaRRUll3PB1JYmgSm+62sosG
    

For more information, see Verifying an install-validation postback.

### New features

New features include:

  * The advertised app can now provide conversion values. For more information, see `updateConversionValue(_:)`.

  * The install-validation postback now contains additional parameters, including the version number, conversion value, source app ID, and redownload value. For more information, see Verifying an install-validation postback.

## See Also

### SKAdNetwork versions

SKAdNetwork 4 release notes

A version of SKAdNetwork available in iOS 16.1 and later.

SKAdNetwork 3 release notes

A version of SKAdNetwork available in iOS 14.6 and later.

SKAdNetwork 2.2 release notes

A version of SKAdNetwork available in iOS 14.5 and later.

SKAdNetwork 2.1 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 1 release notes

A version of SKAdNetwork available in iOS 11.3 and later.

Article

# SKAdNetwork 1 release notes

A version of SKAdNetwork available in iOS 11.3 and later.

## Overview

You’re eligible to receive a version 1.0 postback when any of these conditions
are met:

  * The source app uses iOS 13.7 SDK or earlier.

  * The advertised app is App Store-signed and running on a device with iOS 14 or earlier.

The original install-validation postback doesn’t include a version number. For
more information, see Combining parameters for previous SKAdNetwork postback
versions.

When verifying an install-validation postback for version 1.0, use the
following Apple P-192 public key:

    
    
    MEkwEwYHKoZIzj0CAQYIKoZIzj0DAQEDMgAEMyHD625uvsmGq4C43cQ9BnfN2xslVT5V1nOmAMP6qaRRUll3PB1JYmgSm+62sosG
    

For more information, see Verifying an install-validation postback.

### New features

This is the original version of SKAdNetwork.

## See Also

### SKAdNetwork versions

SKAdNetwork 4 release notes

A version of SKAdNetwork available in iOS 16.1 and later.

SKAdNetwork 3 release notes

A version of SKAdNetwork available in iOS 14.6 and later.

SKAdNetwork 2.2 release notes

A version of SKAdNetwork available in iOS 14.5 and later.

SKAdNetwork 2.1 release notes

A version of SKAdNetwork available in iOS 14 and later.

SKAdNetwork 2 release notes

A version of SKAdNetwork available in iOS 14 and later.



# SKProductStorePromotionVisibility

Enumeration Case

# SKProductStorePromotionVisibility.default

Indicates product visibility is the same as the default value set in App Store
Connect.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+

    
    
    case `default` = 0

## See Also

### Enumeration cases

`case hide`

Indicates product is hidden.

`case show`

Indicates product is shown.

Enumeration Case

# SKProductStorePromotionVisibility.hide

Indicates product is hidden.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+

    
    
    case hide = 2

## See Also

### Enumeration cases

`case `default``

Indicates product visibility is the same as the default value set in App Store
Connect.

`case show`

Indicates product is shown.

Enumeration Case

# SKProductStorePromotionVisibility.show

Indicates product is shown.

iOS 11.0+  iPadOS 11.0+  macOS 11.0+  Mac Catalyst 14.0+  tvOS 11.0+

    
    
    case show = 1

## See Also

### Enumeration cases

`case `default``

Indicates product visibility is the same as the default value set in App Store
Connect.

`case hide`

Indicates product is hidden.



# Product.PurchaseResult

Enumeration Case

# Product.PurchaseResult.success(_:)

The purchase succeeded and results in a transaction.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case success(VerificationResult<Transaction>)

## See Also

### Getting the Purchase Results

`case userCancelled`

The user canceled the purchase.

`case pending`

The purchase is pending, and requires action from the customer.

Enumeration Case

# Product.PurchaseResult.userCancelled

The user canceled the purchase.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case userCancelled

## See Also

### Getting the Purchase Results

`case success(VerificationResult<Transaction>)`

The purchase succeeded and results in a transaction.

`case pending`

The purchase is pending, and requires action from the customer.

Enumeration Case

# Product.PurchaseResult.pending

The purchase is pending, and requires action from the customer.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case pending

## Discussion

If a pending purchase succeeds, StoreKit delivers the resulting `Transaction`
in the transaction `updates`.

## See Also

### Getting the Purchase Results

`case success(VerificationResult<Transaction>)`

The purchase succeeded and results in a transaction.

`case userCancelled`

The user canceled the purchase.



# Subscriptions and offers

Article

# Handling Subscriptions Billing

Build logic around the date and time constraints of subscription products,
while planning for all scenarios where you control access to content.

## Overview

Apps that offer subscriptions have some unique behaviors and considerations.
Because subscriptions involve an element of time, your app must be able to
determine whether the subscription is currently active and determine the
subscription states for past dates. Your app must also react to new, renewed,
and lapsed subscriptions, and properly handle expired auto-renewable
subscriptions that may be in a billing retry state.

To validate changes in and identify the status of a subscription, you can use
the different values in the receipt, which provides details on app and in-app
purchases. For information about server-side receipt validation, see
Validating receipts with the App Store.

Note

Each subscription has a unique product identifier associated with a single
app. Apps with an iOS and a macOS version have separate products, with a
unique product identifier on each platform. You could let users who have a
subscription in an iOS app access the content from a macOS app, or vice versa,
but implementing that functionality is your responsibility. In order to
support cross-platform subscription products, you would need a system to
identify users and keep track of the content to which they subscribe. For more
information, see Offering a Subscription Across Multiple Apps.

There are two types of subscriptions you can offer in your app: _non-renewing_
and _auto-renewable_. Non-renewing subscriptions differ from auto-renewable
subscriptions in a few key ways. These differences give your app the
flexibility to implement the correct behavior for a non-renewing subscription,
as follows:

  * Your app is responsible for calculating the time period that the subscription is active and determining what content needs to be made available to the user.

  * Your app is responsible for detecting that a non-renewing subscription is approaching its expiration date and prompting the user to renew the subscription by purchasing the same product again.

  * Your app is responsible for making purchased subscriptions available across all the user’s devices and for letting users restore past purchases. For example, most subscriptions are provided by a server; your server would need some mechanism to identify users and associate subscription purchases with the user who purchased them.

The following sections provide guidance for handling auto-renewable
subscriptions. To quickly react to changes in users' auto-renewable
subscriptions, you can choose to receive status update notifications on your
server. Status update notifications inform you of real-time changes in a
user's subscription status and are only supported for auto-renewable
subscriptions. For more information on setting up and handling server
notifications, see Enabling App Store Server Notifications.

### Calculate a Subscription's Promotional Offer Status

You can set up promotional offers in App Store Connect to provide users with
free or discounted service for a subscription. All new and eligible
subscribers can redeem an introductory offer, and all lapsed and existing
subscribers can redeem a subscription offer. There are multiple types of
introductory and subscription offers, each with different billing cycles.
Customers who redeem a free trial introductory offer or a downgrade
subscription offer will not be billed for the subscription until the end of
the free trial period. For more information, see Implementing introductory
offers in your app and Implementing promotional offers in your app.

Check the `is_in_intro_offer_period` or `is_trial_period` field from each
receipt entry to validate whether the user redeemed an introductory offer at
the beginning of their subscription. You can use this information to
accurately present subscription products from the same subscription group at
the end of the introductory offer period for that user. Check the
`promotional_offer_id` field from each receipt entry to validate whether the
user redeemed a subscription offer. You can use this information to determine
eligibility for this user to redeem subscription offers in the future.

### Calculate a Subscription’s Active Period

Your app needs to determine which content the user has access to based on the
period of time their auto-renewable subscription is active. To provide the
customer access to the content to which they are entitled, keep a record of
the date that each piece of content is published. Read the
`original_purchase_date`, `purchase_date`, and `expires_date` field from each
receipt entry to determine the start and end dates of each subscription
period. The user has access to all content published between each subscription
start and end date in addition to the content that was initially unlocked when
the subscription was purchased.

For example, because purchasing a subscription always unlocks content, a user
who purchases a monthly subscription mid-month to a magazine that publishes a
new issue on the first day of every month gets access to two issues in their
first month of subscribing: the most recently published issue, which is
unlocked at the time that the subscription is purchased, and the issue you
publish on the subsequent first day of the month, which is unlocked at the
time you publish it.

Important

Don’t calculate the subscription period by adding a subscription duration to
the purchase date. That approach fails to take into account the free trial
period, the marketing opt-in period, and the content made available
immediately after the user purchased the subscription.

If the subscription lapsed, there will be multiple periods of time during
which the subscription was active, and there will be pieces of content
unlocked at the beginning of a subscription period. To identify lapses in a
subscription, compare the `expires_date` field from each receipt entry to the
`purchase_date` field of the previous receipt entry for all entries in the
receipt.

### Detect an Expiration or Renewal

The subscription renewal process begins in the 10 days before the expiration
date. During those 10 days, the App Store checks for any billing issues that
might delay or prevent the subscription from being automatically renewed, for
example, whether:

  * The customer’s payment method is active.

  * The product increased in price since the user bought the subscription.

  * The product is no longer available.

The App Store notifies users of any issue so that they can resolve it before
the subscription expires and avoid an interruption in their service.

During the 24-hour period before the subscription expires, the App Store
starts trying to renew it automatically. The App Store makes several attempts
to automatically renew the subscription over a period of time but eventually
stops if there are too many failed attempts.

### Handle Lapsed Subscriptions

The App Store renews the subscription slightly before it expires, to prevent
any lapse in the subscription. However, lapses are still possible. For
example, if the user’s payment information is no longer valid, the first
renewal attempt fails. Billing-related issues trigger the subscription to
enter a billing retry state where the App Store attempts to renew the
subscription for up to 60 days. You can check the `expiration_intent` and
`is_in_billing_retry_period` values to monitor the retry status of the
subscription. During this period, your app may optionally offer a grace period
to the user and show them a message in the app to update their payment
information. Additionally, your app can deep link customers to the payment
details page within App Store on their device by opening this URL

    
    
    https://apps.apple.com/account/billing
    

The user can also cancel their subscription by disabling auto-renew and
intentionally letting their subscription lapse. This action triggers the App
Store to send your server a status update notification of type
`DID_CHANGE_RENEWAL_STATUS`. Your server can parse the `auto_renew_status` and
the `auto_renew_status_change_date` to determine the current renewal status of
the subscription.

You can also check the `expiration_intent` field in the receipt to further
validate the reason for the subscription to lapse. Make sure your app’s
subscription logic can handle different values of `expiration_intent` along
with `expires_date` to show the appropriate message to the user.

### Detect a Refund

Users pay for a subscription when they purchase it, and they can receive a
refund by contacting Apple customer service. For example, if the user
accidentally buys the wrong product and requests a refund, customer support
can cancel the subscription and issue a full or partial refund. Customers may
cancel a subscription in the middle of a subscription period, but the
subscription remains paid through the end of the same period. Additionally,
users may also receive a refund when they upgrade their subscription to
another subscription product at a higher level in the same subscription group.

To identify whether a subscription has been refunded, look for the
`cancellation_date` field in the receipt. The App Store notifies your server
of refunds with a status update notification of type `CANCEL`, at which point
you can handle the refund. For example, if the user upgraded the subscription,
immediately unlock service for the higher level subscription product
purchased.

### Identify a Renewed Subscription After a Lapse

A user-initiated payment information update for an auto-renewable subscription
in the billing retry period triggers an automatic renewal attempt to succeed.
For this event, the App Store notifies your server with a notification of type
`RENEWAL` and a new receipt will be generated for the successful transaction.
You can look for a new value of the `expires_date` field to know the next
renewal date of the subscription.

StoreKit adds a new transaction for the renewal to the transaction queue on
the device. Your app can check the transaction queue on launch and handle the
renewal the same way as any other transaction. If your app is already running
when the subscription renews, the transaction observer is not called; your app
finds out about the renewal the next time the app launches.

### Detect Upgrades or Plan Changes

Users can manage their auto-renewable subscriptions in their App Store
settings on-device or within your app’s interface. For each subscription
purchased by the user, the App Store shows all the renewal options that the
subscription group offers. Users can easily change their service levels and
choose to upgrade, downgrade, or cross-grade as often as they like. Upgrades
of any duration or cross-grades with same durations go into effect
immediately. Downgrades of any duration or cross-grades with different
durations go into effect at the next renewal date.

You can check the receipt’s `auto_renew_product_id` field to learn about any
plan changes the user selected that will go into effect at the next renewal
date. Additionally, you can also use the notification of type
`DID_CHANGE_RENEWAL_PREF` to get notified for any user initiated plan changes
that will go into effect at the next renewal date.

### Manage Subscription Price Consent

When you increase the price of a subscription, the App Store informs the
affected subscribers with an email, push notification, and in-app price
consent sheet, and asks your subscribers to agree to the new price. In the
app, the system asks your delegate’s function
`paymentQueueShouldShowPriceConsent(_:)` whether to immediately display the
price consent sheet, or to delay displaying the sheet until later. For
example, you may want to delay showing the sheet if it would interrupt a
multistep user interaction, such as setting up a user account. Return `false`
in `paymentQueueShouldShowPriceConsent(_:)` to prevent the dialog from
displaying immediately.

To show the price consent sheet after a delay, call
`showPriceConsentIfNeeded()`, which shows the sheet only if the user hasn’t
responded to the price increase notifications.

If users don’t agree to the subscription price increase or take no action,
their subscription expires at the end of their current billing cycle. App
Store attempts to notify users in the app twice. For a notification schedule,
see Increase the price of an auto-renewable subscription.

Note

The price consent sheet appears only on devices running iOS. All affected
subscribers receive an email and push notification.

### Enable Users to Manage Subscriptions

Consider building auto-renewable subscription management UI in the app for
subscribers to easily move between different subscription levels in their
subscription group. Use the `subscriptionGroupIdentifier` property of
`SKProduct` to determine which products to display in the UI. For users who
wish to cancel their subscription, your app can open the following URL:

    
    
    https://apps.apple.com/account/subscriptions
    

Opening this URL launches iTunes or iTunes Store and displays the Manage
Subscriptions page where the user can upgrade, downgrade, or cancel their
subscription by disabling auto-renew. If you configure your backend server to
receive status update notifications, your server receives a
`DID_CHANGE_RENEWAL_STATUS` notification if the user cancels their
subscription.

## See Also

### Essentials

Enabling App Store Server Notifications

Configure your server and provide an HTTPS URL to receive notifications about
in-app purchase events and unreported external purchase tokens.

Offering a Subscription Across Multiple Apps

Support a single auto-renewable subscription across multiple apps.

Reducing Involuntary Subscriber Churn

Prevent unintentional loss of subscribers due to billing issues.

Article

# Enabling App Store Server Notifications

Configure your server and provide an HTTPS URL to receive notifications about
in-app purchase events and unreported external purchase tokens.

## Overview

App Store Server Notifications is a server-to-server service that sends real-
time notifications for in-app purchase events, and notifications for
unreported external purchase tokens. To enable notifications, set up an HTTPS
URL on your server, and configure settings in App Store Connect.

For information about parsing and interpreting notifications, see Receiving
App Store Server Notifications.

### Set up your server and App Store Connect settings

To receive server notifications from the App Store, your server must support
the Transport Layer Security (TLS) 1.2 protocol or later.

To enable App Store Server Notifications, follow these steps:

  1. Determine the HTTPS URL on your server to receive notifications for the production environment. 

  2. Optionally, determine the HTTPS URL on your server to receive notifications for the sandbox environment for testing notifications. You may use the same URL for both the production and the sandbox environments.

  3. App Store Connect gives you the choice of receiving version 2 or version 1 notifications for each environment. To choose version 2, set up your endpoint as App Store Server Notifications V2. 

  4. Configure your URL in App Store Connect. For more information, see Enter a URL for App Store Server Notifications. 

Important

If you specify a port in your URL, the port must be either `443` or greater
than or equal to `1024`. For example, the URL
`https://example.com:1234/notifications` specifies the port `1234`.

Configure your server to respond with HTTP status codes to indicate whether
the App Store server notification `POST` is successful. For more information,
see Responding to App Store Server Notifications.

For new implementations, use App Store Server Notifications V2. To transition
from using version 1 notifications to version 2, test version 2 notifications
in the sandbox environment before you update your production environment to
version 2.

For information about changes to App Store Server Notifications, see App Store
Server Notifications changelog.

### Configure an allow list

If your server requires IP addresses to be on an allow list, add the IP
address subnet `17.0.0.0/8` to allow your server to receive notifications from
the App Store server. This subnet applies to both the sandbox and the
production environments.

### Test your server setup

To determine whether your server is receiving notifications, call the Request
a Test Notification endpoint in the App Store Server API. This endpoint asks
the App Store server to send a notification with the `notificationType`
`TEST`. Use the `testNotificationToken` you receive to call the Get Test
Notification Status endpoint to learn how your server responds to the test
notification.

The App Store server sends the `TEST` notification in the version 2
notification format. However, it sends it to your server regardless of whether
you configure a version 1 or version 2 notification URL in App Store Connect.

## See Also

### Essentials

Handling Subscriptions Billing

Build logic around the date and time constraints of subscription products,
while planning for all scenarios where you control access to content.

Offering a Subscription Across Multiple Apps

Support a single auto-renewable subscription across multiple apps.

Reducing Involuntary Subscriber Churn

Prevent unintentional loss of subscribers due to billing issues.

Article

# Offering a Subscription Across Multiple Apps

Support a single auto-renewable subscription across multiple apps.

## Overview

You can offer customers auto-renewable subscription services that are
accessible through multiple apps across one or more operating systems.

To offer this functionality, your server must grant access to the subscription
content across all apps, despite the user having purchased the subscription
within a specific app. You can use a unified account management database along
with server-side receipt validation to validate a user’s purchase and handle
in-app transactions. By entitling subscription access from your server, you
can provide users the ability to access your subscription across multiple
apps.

### Create the Subscription for Each App

To get started, use App Store Connect to create a separate and equivalent
auto-renewable subscription for each app that offers the multi-app
subscription so that users can subscribe from any app. For design guidance,
see Human Interface Guidelines > In-App Purchase.

Tip

Use an app bundle to group apps that share auto-renewable subscriptions on the
same platform in a single App Store product page. An app bundle enables
customers to view and download apps in a single purchase.

The following image illustrates the steps for implementing a multi-app
subscription:

### Authenticate the User

When providing auto-renewable subscription access across multiple apps, you
must authenticate the user in a way that correlates across apps.
Authenticating users using a login allows you to determine if the user has
access to the content. To provide a consistent user experience, ensure that
the login process is similar across your apps.

To provide an easy and secure login, take advantage of Sign in with Apple.
Sign in with Apple allows you to identify a user across your apps, while
maintaining user privacy and protecting your app against fraud. You can store
and retrieve user account data across your apps and the user’s devices, and
use that data to unlock access appropriately.

### Check Billing Status

After authenticating the user, determine whether to grant access to the
content based on their transaction history in the receipt.

Check if the user has purchased any subscription products before showing a
subscription offer in the app. If there’s a subscription purchase from any
app, verify if the subscription is active by looking at the subscription
expiration date in the receipt.

Present users who don’t have an active subscription with the subscription for
purchase. Consider all potential billing scenarios within your account
database when determining eligibility and granting access to a user.

Important

If the user has purchased the subscription from an app, you must propagate the
purchase across all the apps that provide the subscription service. Failing to
persist the purchase to the other apps opens the possibility of a user paying
multiple times for the same service.

### Validate Subscription Status

A user’s subscription status can change any time. Validate the receipt and
check the latest subscription expiration date to maintain the billing status
for each user and reflect any changes.

Enabling App Store Server Notifications keeps your server aware of changes
made to a customer’s subscription status. Update your records to keep users'
subscription status and content current. The billing status must be accurate
in your account database to provide the expected user experience across all
apps.

### Enable Access to Purchased Content

After determining that the user should have access, you can enable access in
each app based on the subscription expiration date. The user can access the
subscription within any app that offers the same service. Repeat the previous
steps as necessary across each app or user’s session to unlock the
subscription.

## See Also

### Essentials

Handling Subscriptions Billing

Build logic around the date and time constraints of subscription products,
while planning for all scenarios where you control access to content.

Enabling App Store Server Notifications

Configure your server and provide an HTTPS URL to receive notifications about
in-app purchase events and unreported external purchase tokens.

Reducing Involuntary Subscriber Churn

Prevent unintentional loss of subscribers due to billing issues.

Article

# Reducing Involuntary Subscriber Churn

Prevent unintentional loss of subscribers due to billing issues.

## Overview

After acquiring new customers for your subscription service, you can minimize
subscriber loss, known as churn, by keeping them engaged as active
subscribers. However, irregular billing events can occur throughout the
lifecycle of a subscription that can impact your customer's subscription
status.

Involuntary churn occurs when users do not intend to leave your service but
their subscription fails to renew, usually due to billing issues. Because
involuntary churn is not related to customer satisfaction, consider creating a
user experience that avoids subscriber loss due to a failed renewal. For
business guidance on retaining subscribers, see Keeping Subscribers.

Billing-related issues trigger a subscription to automatically enter a billing
retry state, where the App Store attempts to recover the subscription. While
the App Store tries to recover these customers, you have the option to prompt
users to update their billing information or implement a grace period, or
both, to assist in recovery efforts. Enabling a grace period and providing
uninterrupted service provides a great customer experience, and avoids
interrupting your days of paid service and revenue loss if Apple is able to
recover the subscription within the grace period. For information on auto-
renewable subscription proceeds and days of paid service, see Net Revenue
After a Year.

### React to Billing Issues

If the customer's billing is invalid, the renewal fails and the user's
subscription enters a billing retry state, where the App Store attempts to
collect payment for up to 60 days. This billing retry lowers the rate of
involuntary churn and prevents the need to re-acquire subscribers if they
churned. If the user is recovered within the 60 days, the new billing date is
established on the date of recovery and subsequent renewal dates are based on
this new billing date, as shown in the figure below.

**Figure 1**  An example timeline for a monthly subscription that enters a
billing retry state

For example, if the user’s payment information is no longer valid, the first
renewal attempt fails. If you have server-to-server notifications enabled, you
receive a server notification of type `DID_FAIL_TO_RENEW`. You can check the
`expiration_intent` and `is_in_billing_retry_period` values in the
verifyReceipt response or `unified_receipt` object in the server notification
to validate the reason for the subscription to lapse and monitor the retry
status of the subscription. If the user is recovered during this period, you
receive a server notification of types `RENEWAL` and `DID_RECOVER` when the
retry is successful. For more information on server-to-server notifications,
see App Store Server Notifications.

Important

The `RENEWAL` notification type is scheduled for deprecation. Update any
existing code to rely on the identical `DID_RECOVER` notification type
instead.

Your app may optionally present in-app messaging that informs users they can
avoid losing access to paid service by taking action and resolving their
billing error. If you choose to prompt the user, ensure your app's
subscription logic can handle different values of `expiration_intent` along
with `expires_date_ms`, to show the appropriate message. An invalid payment
method could be due to a number of things, such as a low balance on a stored
value card or an expired credit card. Your app should be ready to react
immediately to a billing information update. Your app can deep link customers
to the Manage Payments page on their account settings by opening this URL:

    
    
    https://apps.apple.com/account/billing
    

Note

This URL is only supported for iOS and macOS.

For more general guidance on handling subscriptions that enter a billing retry
state, see WWDC 2018 > Engineering Subscriptions. You can also agree to
provide a grace period for subscribers in a billing retry state. Billing error
recoveries made within the set grace period automatically recover subscribers
onto their current billing cycle, also providing revenue continuity.

### Enable Billing Grace Period

To avoid interrupting days of paid service, you can enable Billing Grace
Period in App Store Connect, which allows subscribers to retain full access to
your app’s paid content while Apple attempts to collect payment. For guidance
on opting in to enable Billing Grace Period for your app, see Enable Billing
Grace Period for Auto-Renewable Subscriptions.

Billing Grace Period is applied at the time of a billing error when it's
enabled for subscriptions in the app, and cannot be altered once assigned to a
user. Grace period durations are dependent on the subscription period length
as follows:

  * 6 days for a weekly subscription

  * 16 days for monthly and longer subscriptions

If you choose to enable Billing Grace Period, ensure that you provide full
service for the subscription throughout the grace period. You can check the
`grace_period_expires_date_ms` field in the
`responseBody.Pending_renewal_info` array of the `verifyReceipt` response or
`unified_receipt` object in the server notification to determine the end of
this grace period duration. For more information on reducing involuntary churn
using a grace period, see WWDC 2019 > In-App Purchases and Using Server-to-
Server Notifications.

If the user is recovered within this grace period, neither the subscriber's
days of paid service, nor your revenue for auto-renewable subscriptions will
be interrupted. Billing error recoveries made after the grace period expires,
but within the overall billing retry period, will maintain existing behavior
and renew on the recovery date, starting a new billing cycle. Payment for the
provided full service during the grace period would not be collected.

**Figure 2**  Example timelines for a monthly subscription that enters a
billing retry state, in an app with Billing Grace Period enabled

When implementing Billing Grace Period, use the verifyReceipt JSON response
and server-to-server notifications. Consider using `expiration_intent`,
`is_in_billing_retry_period`, and `grace_period_expires_date_ms` of the
`unified_receipt` object in the server notifications of type `RENEWAL` and
`DID_RECOVER` to identify whether the subscription is in a grace period.

The `expiration_intent` value can tell you if a subscription renewal failed
due to a billing error, or simply because the user chose to cancel service.
You can also see if the App Store is actively trying to recover a subscription
by looking for an active `is_in_billing_retry_period flag`.

Consider all scenarios for subscription recovery:

  * If the subscription renews before the time specified in `grace_period_expires_date_ms`, the `grace_period_expires_date` fields are removed along with the `is_in_billing_retry_period` indicator. You can look up a past transaction’s `purchase_date_ms` and `expires_date_ms` values to determine if a user’s subscription renewed after a lapse.

  * If the subscription renews after the time specified in `grace_period_expires_date_ms` while still in the billing retry state, the `grace_period_expires_date` fields are removed along with the `is_in_billing_retry_period` indicator. You can use the `expires_date_ms` value for a past transaction to determine the lapse period. 

  * If attempts to renew the subscription fail, the `grace_period_expires_date` fields persist along with a value of `0` for the `auto_renew_status` and `is_in_billing_retry_period` indicators.

### Restore Service

When users update their payment information, the App Store immediately
attempts to renew the payment. Once the App Store successfully bills the
customer in a billing retry state, the App Store notifies your server with
notifications of types `RENEWAL` and `DID_RECOVER`, and a new receipt is
generated for the successful transaction. A new value appears in the
`expires_date_ms` field in the app transaction receipt, based on the date of
recovery, to mark the next renewal date of the subscription.

StoreKit adds a new transaction for the renewal to the transaction queue on
the device. Your app can check the transaction queue on launch and handle the
renewal the same way as any other transaction. If your app is already running
when the subscription renews, the transaction observer is not called; your app
finds out about the renewal the next time the app launches. Restore service
once the subscription is renewed if needed.

## See Also

### Essentials

Handling Subscriptions Billing

Build logic around the date and time constraints of subscription products,
while planning for all scenarios where you control access to content.

Enabling App Store Server Notifications

Configure your server and provide an HTTPS URL to receive notifications about
in-app purchase events and unreported external purchase tokens.

Offering a Subscription Across Multiple Apps

Support a single auto-renewable subscription across multiple apps.

Article

# Implementing introductory offers in your app

Offer introductory pricing for auto-renewable subscriptions to eligible users.

## Overview

Apps with auto-renewable subscriptions can offer a discounted introductory
price, including a free trial, to eligible users. You can make introductory
offers to customers who haven’t previously received an introductory offer for
the given product, or for any products in the same subscription group.

Start by setting up introductory offers in App Store Connect. Then, in your
app, determine if the user is eligible to receive an introductory offer. When
the app queries the App Store for a list of available products, display the
introductory pricing if the user is eligible to receive them.

### Set Up Introductory Offers

Before you can display introductory offers in your app, you must first
configure the offers in App Store Connect. For more information, see Set an
introductory offer for an auto-renewable subscription.

Choose from one of three types of introductory offers, which differ in their
mode of payment. All subscriptions renew at the regular price when the
introductory period is over. The offer types are “pay as you go”, “pay up
front”, and “free trial”.

#### Pay As You Go

The `SKProductDiscount.PaymentMode.payAsYouGo` value represents the pay as you
go offer type. In this introductory offer, new subscribers pay an introductory
price each billing period for a specific duration (for example, $1.99 per
month for 3 months).

#### Pay Up Front

The `SKProductDiscount.PaymentMode.payUpFront` value represents the pay up
front offer type. In this introductory offer, new subscribers pay a one-time
introductory price for a specific duration (for example, $1.99 for 2 months).

#### Free Trial

The `SKProductDiscount.PaymentMode.freeTrial` value represents a free trial
offer type. In this introductory offer, new subscribers access content for
free for a specified duration. Subscriptions begin immediately, but
subscribers won’t be billed until the free trial period is over.

### Determine Eligibility

To determine if a user is eligible for an introductory offer, check their
receipt:

  1. Validate the receipt as described in Validating receipts with the App Store.

  2. In the receipt, check the values of the `is_trial_period` and the `is_in_intro_offer_period` for all in-app purchase transactions. If either of these fields are `true` for a given subscription, the user is not eligible for an introductory offer on that subscription product or any other products within the same subscription group. Use `subscription_group_identifier` in the `responseBody.Pending_renewal_info` array to determine the subscription group to which the subscription belongs. 

Typically, you check the user's eligibility from your server. Determine
eligibility early—for example, on the first launch of the app, if possible.

Based on the receipt, you will find that new and returning customers are
eligible for introductory offers, including free trials:

  * New subscribers are always eligible. 

  * Lapsed subscribers who renew are eligible if they haven't previously used an introductory offer for the given product (or any product within the same subscription group).

Existing subscribers are not eligible for an introductory offer for any
product within the same subscription group. For example, customers are not
eligible if they are upgrading, downgrading, or crossgrading their
subscription from another product, regardless of whether they consumed an
introductory offer in the past.

### Display the Introductory Offer

Once you determine the user is eligible for an introductory offer, query the
App Store for available products, and present the offer to the user:

  1. Retrieve localized information from the App Store about a specified list of subscription products using the `SKProductsRequest` class. Products that have an available discount defined in App Store Connect always include an `introductoryPrice` object. 

  2. Use the properties in the `introductoryPrice` object to display the discounted price for the subscription. Based on the type of the introductory offer (represented by `SKProductDiscount.PaymentMode`), display a UI that describes the offer accordingly.

For design guidance, see Human Interface Guidelines > In-App Purchase.

## See Also

### Introductory offers

Testing introductory offers

Test your introductory pricing in a variety of user scenarios.

`class SKProductDiscount`

The details of an introductory offer or a promotional offer for an auto-
renewable subscription.

### Related Documentation

Receipt Validation Programming Guide

Article

# Testing introductory offers

Test your introductory pricing in a variety of user scenarios.

## Overview

To test introductory offers, verify that users see the same subscription and
introductory offer prices in your app as they do in the App Store. As part of
your test, make sure your app presents introductory offers only to users that
are eligible for them.

To test introductory offers:

  1. Configure test accounts, as described in Create a sandbox tester account. Create a variety of accounts that are eligible or ineligible for offers.

  2. Initiate in-app purchases from within the app for each test user.

  3. Verify that the user experience and pricing information dynamically represent the accurate price of your subscription.

Introductory offers are only offered once, but when testing your app, you can
reset the status of the test account to allow you to redeem an introductory
offer more than once. To reset offer eligibility for the sandbox account:

  1. On the test iOS device, open Settings > Apple ID > Media & Purchases (or iTunes & App Store for iOS 13 and earlier). Under the Sandbox Account section, tap your highlighted Sandbox Apple ID then tap Manage to open the sandbox Subscription Management page.

  2. Tap the expired subscription you want to reactivate. The subscription products that appear are those you configured in App Store Connect under the same subscription group.

  3. If the test account used an introductory offer, then the system diplays a Reset Eligibility button that lets you reset and redeem another introductory offer.

## See Also

### Introductory offers

Implementing introductory offers in your app

Offer introductory pricing for auto-renewable subscriptions to eligible users.

`class SKProductDiscount`

The details of an introductory offer or a promotional offer for an auto-
renewable subscription.

Article

# Setting up promotional offers

Generate a key and configure offers for auto-renewable subscriptions in App
Store Connect.

## Overview

You can offer a discounted or free period of service for auto-renewable
subscription products on macOS, iOS, and tvOS using promotional offers.
Limited-time, discounted promotional offers can be effective in winning back
lapsed subscribers or retaining current subscribers.

Before you can provide promotional offers in your app, you must first generate
a subscription key and set up the offers in your App Store Connect account.

Note

If your goal is to attract new users, use introductory offers and promote the
in-app purchase on the App Store. Redeeming an introductory offer doesn’t
affect a user’s eligibility for a promotional offer. For more information, see
Implementing introductory offers in your app.

### Generate a Private Key

You generate a private key in App Store Connect that you use on your server to
sign promotional offers. This key allows Apple to authenticate and validate
subscription requests.

Keys don’t expire, and you can use them with any apps in your account. To get
started, generate a subscriptions access key in App Store Connect.

#### Download and Store the Private Key

Once you’ve generated your subscription key, you’re given the opportunity to
download the private half of the key. You can only download this key one time.

The keys are provided in base64-encoded PEM format. Apple doesn’t keep a copy
of the private key.

Important

Store your private subscription key in a safe place. You should never share
your keys, store keys in a code repository, or include keys in apps or client-
side code.

If the key becomes lost or compromised, revoke it immediately and update your
promotional offers. See Revoke a subscription key for more information.

### Configure Promotional Offers

You configure promotional offers in App Store Connect, providing details such
as a reference name, payment mode, duration, and price. To configure your
offer, see Set up promotional offers for auto-renewable subscriptions. You can
have up to 10 promotional offers active at any given time per subscription.

For business guidance on using promotional offers, see Auto-renewable
Subscriptions > Providing Subscription Offers.

## See Also

### Promotional offers

Implementing promotional offers in your app

Offer discounted pricing for auto-renewable subscription products to eligible
subscribers.

Generating a signature for promotional offers

Create a signature to validate a promotional offer using your private key.

Generating a Promotional Offer Signature on the Server

Generate a signature using your private key and lightweight cryptography
libraries.

`class SKPaymentDiscount`

The signed discount to apply to a payment.

Article

# Implementing promotional offers in your app

Offer discounted pricing for auto-renewable subscription products to eligible
subscribers.

## Overview

Promotional offers can be effective in winning back lapsed subscribers or
retaining current subscribers. You can provide lapsed or current subscribers a
limited-time offer of a discounted or free period of service for auto-
renewable subscriptions on macOS, iOS, and tvOS. To implement the offers,
first complete the setup on App Store Connect, including generating a private
key. See Setting up promotional offers for more details.

You decide the criteria for which subscribers qualify for an offer. In your
app, the details of the offers you set up in App Store Connect appear in the
`discounts` array in `SKProduct`. To indicate the offer you want to give to a
user, include a signed `paymentDiscount` in the `SKMutablePayment` object.

For business guidance on using promotional offers, see Auto-renewable
Subscriptions > Providing Subscription Offers.

Note

If your goal is to attract new users, you can use introductory offers and
promote the in-app purchase on the App Store. Users are eligible to receive
only one introductory offer, but redeeming an introductory offer doesn’t
affect their eligibility for a promotional offer. For more information on
introductory offers, see Implementing introductory offers in your app.

### Prepare Your Offer

To present a promotional offer, first determine the subscriber’s eligibility,
get the product details from the App Store, and generate a signature on your
server.

**Figure 1**  Steps for determining a user's eligibility and preparing the
offer

#### Determine Eligibility

There are two aspects to determining a user’s eligibility for promotional
offers:

  * The App Store deems all customers with an existing or expired subscription in the app eligible to redeem a promotional offer. You can check whether the receipt contains any existing or expired subscription purchases to identify these current or lapsed subscribers.

  * You determine any additional eligibility criteria for a specific promotional offer. Eligibility can be contingent on a wide range of business logic determined by your business needs.

Consider using the App Store server notification `DID_CHANGE_RENEWAL_STATUS`
to determine eligibility. This notification is triggered by changes in a
subscription’s auto-renew status. For example, you receive a notification when
a subscriber disables auto-renew in Manage Subscriptions or contacts AppleCare
to cancel their subscription. For more information on server notifications,
see App Store Server Notifications. Your server can notify your app if the
user is eligible for an offer so the app can present it to the customer.

Note

Customers can redeem promotional offers only on devices running iOS 12.2 and
later, macOS 10.14.4 and later, and tvOS 12.2 and later. Consider providing
messaging prompting your customer to update their OS if they try to redeem a
promotional offer in your app on a device running an older OS version.

Consider also implementing DeviceCheck to keep track of devices that have
previously redeemed offers. `TwoBitKit` allows you to maintain user privacy
while defining parameters you use to determine eligibility.

#### Request Product Details

Once you determine that the subscriber is eligible for an offer, the next step
is requesting the product details, including offers, from the App Store. To
fetch the details, use `SKProductsRequest` with the subscription’s product
identifier.

In response, the App Store returns the localized information in `SKProduct`.
The `discounts` array of `SKProduct` contains all promotional offers you
configured in App Store Connect for that product. The `SKProductDiscount`
object contains offer details including the localized price.

You determine which offer from the `discounts` array to present to the user.

#### Create a Signature

A signature is a unique string that your server generates using specified
parameters and your private key. You include it in the `signature` parameter
of `SKPaymentDiscount`, and the App Store uses it to validate the promotional
offer. The signature is time sensitive, unique per offer, and redeemable only
once.

To generate the signature, send a secure request to your server. The server
will need to know the `applicationUsername`, `productIdentifier`, and
`identifier`. Your app should supply these parameters in the request if the
server doesn’t already know them. See Generating a signature for promotional
offers for more information.

Your server should respond with the signature string and the additional values
it used to generate the signature: a `nonce`, `timestamp`, and the
`keyIdentifier`. Use these values to complete the parameters in the
`SKPaymentDiscount` object nested in the `SKMutablePayment` object
representing the offer. If the App Store determines that the signature isn’t a
match for the parameters in the payment, the transaction fails.

Tip

To minimize latency, consider generating the signature when you display the
offer.

The following code example shows how to request a signature from your server
and prepare the discount offer.

#### Present Your Offer

You can present offers to users through various channels, such as email, but
they must interact with the offer inside your app’s UI. Display the offer in
your app at the time you choose, using the pricing and terms from the
`SKProductDiscount` object. By using the details from this object, you ensure
that the offer displayed to the user accurately reflects the offer you intend
to give. For design guidance, see Auto-Renewable Subscriptions > Clearly
Describing Subscriptions.

Present offers to eligible subscribers only, to avoid misleading or confusing
users.

### Complete the Transaction

After a user chooses to buy the promotional offer, submit the payment request,
verify the receipt, and unlock the offer.

**Figure 2**  Steps for creating a payment request with a signed offer,
verifying the receipt, and unlocking the service

#### Create a Payment Request

When the user initiates a buy of the offer in the app, send an
`SKMutablePayment` to the App Store with the signed offer. Create an
`SKPaymentDiscount` object that includes the signature you generated and its
`identifier`, `keyIdentifier`, `nonce` (one-time use), and `timestamp`
parameters. Add this object as the `paymentDiscount` property to the
`SKMutablePayment` object.

Include in the `SKMutablePayment` object the same `applicationUsername`, often
a unique hash of the username, that the signature contains. Add the
`SKMutablePayment` object to the queue.

#### Notify the User of the Transaction State

Once the App Store validates the offer, it processes your payment request and
generates an `SKPaymentTransaction`. Your app uses it to validate the
transaction and unlock content accordingly.

Handle the transaction state of the payment request and notify the customer as
needed. If the transaction is successful, the App Store automatically updates
the app receipt with the transaction in the
`SKPaymentTransactionState.purchased` state. Base64-encode the receipt on-
device and securely send the receipt data to your server.

Note

If the transaction fails with a state of `SKPaymentTransactionState.failed`,
you must generate a new signature and a new payment request for any further
attempts to purchase the offer.

#### Verify the Receipt

As you do for all purchases, verify the receipt with the App Store by calling
the verifyReceipt endpoint from your server. The App Store sends a JSON
response containing information about the user’s purchase. See Validating
Receipts With the App Store for more information.

When a subscriber redeems an offer, the receipt contains a
`promotional_offer_id` in the purchase transaction. This receipt field is a
string containing the offer ID that you configured in App Store Connect. You
can look at past transactions in the receipt to identify the offers the
customer redeemed.

#### Unlock the Service

After validating that the user has purchased the subscription product, unlock
the subscription service in the app for the user. Update the customer’s
eligibility criteria for offers, as needed.

When a customer redeems a promotional offer, the offer period starts at the
next billing event.

  * For upgrades or crossgrades to a different subscription with the same duration, the promotional offer triggers a billing event and goes into effect immediately.

  * For downgrades or crossgrades to a different subscription with different durations, the promotional offer period goes into effect at the next renewal date.

  * For the same subscription in an introductory offer, this promotional offer period goes into effect at the next scheduled billing event.

Once the offer period concludes, a promotional offer auto-renews at the
standard price.

A user can redeem and have active only one promotional offer at a time. If the
user accepts another offer before a current offer ends, the current offer is
canceled in the following billing event and the new offer takes effect.

## See Also

### Promotional offers

Setting up promotional offers

Generate a key and configure offers for auto-renewable subscriptions in App
Store Connect.

Generating a signature for promotional offers

Create a signature to validate a promotional offer using your private key.

Generating a Promotional Offer Signature on the Server

Generate a signature using your private key and lightweight cryptography
libraries.

`class SKPaymentDiscount`

The signed discount to apply to a payment.

Article

# Generating a signature for promotional offers

Create a signature to validate a promotional offer using your private key.

## Overview

Before you can create a signature on your server, you need to complete the
one-time setup to generate a private key in App Store Connect, as Setting up
promotional offers describes. Always use a secure connection when sending
data, including the signature, between your app and server. For more
information on ensuring your data’s security, see Preventing Insecure Network
Connections.

To create the signature, you use parameters that identify the product and the
offer, parameters your server generates, and your private key. To generate the
signature, you combine the required parameters, then sign and encode the
resulting string.

### Combine the parameters

In the first step of generating the signature, you need the following
parameters, most of which you also supply for `SKPaymentDiscount`:

`appBundleID`

    

The app bundle identifier.

`keyIdentifier`

    

A string that identifies the private key you use to generate the signature.
You can find this identifier in App Store Connect Users and Access > Keys in
the Key ID column for the subscription key you generate.

`productIdentifier`

    

The subscription product identifier, `productIdentifier`. The app can provide
this value.

`offerIdentifier`

    

The subscription discount identifier, `identifier`. The app can provide this
value.

`applicationUsername or appAccountToken`

    

An optional string value that you define; may be an empty string. If your app
uses `applicationUsername`, provide `applicationUsername`. If your app uses
`appAccountToken`, provide `appAccountToken`. The string representation of the
`appAccountToken` must be lowercase.

`nonce`

    

A one-time `UUID` value that your server generates. Generate a new `nonce` for
every signature. The string representation of the `nonce` you use in the
signature must be lowercase.

`timestamp`

    

A timestamp your server generates in UNIX time format, in milliseconds. The
timestamp keeps the offer active for 24 hours.

Important

Use lowercase for the string representation of the `nonce` and the
`appAccountToken`.

Combine the parameters into a UTF-8 string with an invisible separator
(`'\u2063'`) between them in the same order as the following example:

    
    
    appBundleId + '\u2063' + keyIdentifier + '\u2063' + productIdentifier + '\u2063' + offerIdentifier + '\u2063' + appAccountToken + '\u2063' + nonce + '\u2063' + timestamp
    

If you provide `applicationUsername` instead of `appAccountToken`, replace it
accordingly in the UTF-8 string above.

### Sign the combined string

Sign the combined UTF-8 string with the following key and algorithm:

  * Your PKCS #8 private key (downloaded from App Store Connect) that corresponds to the `keyIdentifier` in the UTF-8 string

  * The Elliptic Curve Digital Signature Algorithm (ECDSA) with a SHA-256 hash

The result is a Digital Encoding Rules (DER)-formatted binary value, which is
the signature.

### Validate locally and encode the signature

Consider validating your signatures locally to ensure your signing process
works correctly. You can create a public key derivative of your private key to
test against. One way to create this key is by running the `openSSL` command
from the terminal app, as the example below shows:

    
    
    openssl ec -in {downloaded_private_key} -pubout -out public_key.pem
    

Use Base64 encoding for the binary signature you generated to obtain the final
signature string to send to the App Store for validation. The signature string
resembles the following:

    
    
    MEQCIEQlmZRNfYzKBSE8QnhLTIHZZZWCFgZpRqRxHss65KoFAiAJgJKjdrWdkLUOCCjuEx2RmFS7daRzSVZRVZ8RyMyUXg==
    

### Respond to the request

Respond to the app’s request for the signature over a secure connection,
providing the encoded signature string, the `nonce`, the `timestamp`, and the
`keyIdentifier`. Note that each payload, signature, and `nonce` is only valid
for one buy request, even if the buy fails.

See Create a Signature for information about the app’s request and how it uses
the signature.

## See Also

### Promotional offers

Setting up promotional offers

Generate a key and configure offers for auto-renewable subscriptions in App
Store Connect.

Implementing promotional offers in your app

Offer discounted pricing for auto-renewable subscription products to eligible
subscribers.

Generating a Promotional Offer Signature on the Server

Generate a signature using your private key and lightweight cryptography
libraries.

`class SKPaymentDiscount`

The signed discount to apply to a payment.

Article

# Implementing offer codes in your app

Provide subscription service for customers who redeem offer codes through the
App Store or within your app.

## Overview

To help you acquire, retain, and win back subscribers, you can use offer
codes.

Note

If your app uses the In-App Purchase API and manages transactions using the
`Transaction` class, see Supporting subscription offer codes in your app
instead, which describes an app’s transaction processing using `Transaction`
rather than receipts.

Offer codes are alphanumeric codes that provide subscriptions at a discount or
for free for a specific duration. Configure the offers and create offer codes
in App Store Connect, and distribute them to your customers. Customers can
redeem offer codes in the App Store, using offer code redemption URLs, or in
your app if you’ve implemented one of the following APIs:

  * `offerCodeRedemption(isPresented:onCompletion:)` or `presentOfferCodeRedeemSheet(in:)`, which are available in iOS 16 and later and iPadOS 16 and later

  * `presentCodeRedemptionSheet()`, which is available in iOS 14 and later and iPadOS 14 and later.

When customers redeem a valid offer code, your app receives a successful
transaction on the payment queue, and you receive a server notification if
you’ve enabled App Store Server Notifications. The receipt contains an
`offer_code_ref_name` field that identifies the offer.

For information on subscription offer types and choosing the offer type to
suit your business needs, see Providing subscription offers.

### Set up offer codes in App Store Connect

Configure offers and manage your offer codes in App Store Connect. You can
have up to 10 active offers per subscription, and create codes for a maximum
of 1,000,000 redemptions per app, per quarter. There are two types of offer
codes: one-time use codes, and custom codes. The offer code redemption APIs
support both.

Download the offer codes from App Store Connect to distribute them to your
customers. For more information on creating and distributing offer codes, and
to learn which type of offer code may work for your campaign, see Set up offer
codes.

### Redeem offer codes in your app

To display the system sheet for customers to redeem offer codes within your
app, call one of the redemption APIs, depending on your app’s UI
implementation:

  * Call `offerCodeRedemption(isPresented:onCompletion:)` if your app uses SwiftUI.

  * Call `presentOfferCodeRedeemSheet(in:)` if your app uses UIKit.

  * Call `presentCodeRedemptionSheet()` for apps running on devices prior to iOS 16 and iPadOS 16.

The redemption sheet takes care of the redemption flow, including alerting
users about invalid entries, as appropriate. Invalid entries may include, for
example, expired offer codes, invalid codes, or codes that would result in a
subscription downgrade.

Including the redemption sheet in your app is recommended, but optional. For
more guidance on supporting offer code redemption within your app, see Human
Interface Guidelines > In-app purchase.

### Support offer codes redeemed outside your app

Customers may redeem subscription offer codes outside your app. If a customer
doesn’t have your app, the App Store prompts them to download it as part of
the redemption flow.

To handle offer codes — and other transactions that can occur outside of your
app – you need to set up a transaction observer at app launch. For more
information on this best practice, see Setting up the transaction observer for
the payment queue. Check that your app’s user-onboarding experience verifies
the receipt and provides subscription service. Update your records if you keep
a backend system to manage your subscribers.

### Identify subscriptions purchased with offer codes, in receipts

When a customer successfully redeems a subscription offer code, the receipt
contains a transaction with the field: `offer_code_ref_name`. This field’s
value is the offer reference name that you configured in App Store Connect.
The field appears in the `responseBody.Latest_receipt_info` and
`responseBody.Pending_renewal_info` objects for receipts, and in the
`unified_receipt.Latest_receipt_info` and
`unified_receipt.Pending_renewal_info` objects for server notifications.

### Provide subscription service to existing and new customers

When an existing customer redeems an offer code, your app receives a
transaction on the payment queue (`paymentQueue(_:updatedTransactions:)` in
the `SKPaymentTransactionState.purchased` state. This flow is the same as a
typical subscription purchase flow, but the receipt contains the offer code
reference. Your app follows these steps:

  1. Validates the receipt. For more information, see Validating receipts with the App Store.

  2. Looks for the `offer_code_ref_name` field in the receipt to determine if the subscription is from an offer code.

  3. Provides the subscription service based on the offer.

  4. Calls `finishTransaction(_:)`.

When you acquire new customers with an offer code, they open your app for the
first time already having a subscription. In addition to providing
subscription service, you may need to update your backend system’s records.
Your app follows these steps:

  1. When the app first launches, validate the receipt.

  2. In the receipt, look for a transaction with the `offer_code_ref_name` field to determine if the subscription is from an offer code.

  3. Provide the subscription service based on the offer.

  4. Guide the customer through your new-user experience as needed. Update your backend system’s records.

  5. Call `finishTransaction(_:)`.



# SKCloudServiceAuthorizationStatus

Enumeration Case

# SKCloudServiceAuthorizationStatus.notDetermined

The authorization type cannot be determined.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    case notDetermined = 0

Enumeration Case

# SKCloudServiceAuthorizationStatus.denied

The user does not authorize any access to their music library.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    case denied = 1

Enumeration Case

# SKCloudServiceAuthorizationStatus.restricted

Access to the music library is restricted in a way that the user cannot
change, so your app should not prompt for authorization. An example of this
situation is if the device is in an education mode.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    case restricted = 2

Enumeration Case

# SKCloudServiceAuthorizationStatus.authorized

The user authorizes playback of Apple Music tracks and the addition of tracks
to their music library.

iOS 9.3+  iPadOS 9.3+  macOS 11.0+  Mac Catalyst 13.0+  tvOS 9.3+  watchOS
7.0+

    
    
    case authorized = 3



# Message.Messages.AsyncIterator

Instance Method

# next()

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    mutating func next() async -> Message.Messages.Element?

## Relationships

### From Protocol

  * `AsyncIteratorProtocol`

## See Also

### Getting the Next Element

`typealias Message.Messages.AsyncIterator.Element`

Type Alias

# Message.Messages.AsyncIterator.Element

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Message.Messages.AsyncIterator.Element = Message.Messages.Element

## See Also

### Getting the Next Element

`func next() -> Message.Messages.Element?`



# SKOverlay.AppConfiguration

Initializer

# init(appIdentifier:position:)

Creates an object that represents the attributes of an overlay you use to
recommend another app on the App Store.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    init(
        appIdentifier: String,
        position: SKOverlay.Position
    )

##  Parameters

`appIdentifier`

    

The iTunes identifier of the recommended app.

`position`

    

The position of the overlay on the screen.

## See Also

### Creating an App Configuration

`var appIdentifier: String`

The iTunes identifier of the recommended app.

`var position: SKOverlay.Position`

The position of the overlay on the screen.

`enum SKOverlay.Position`

Constants that identify the position of an overlay on the screen.

Instance Property

# appIdentifier

The iTunes identifier of the recommended app.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    var appIdentifier: String { get set }

## See Also

### Creating an App Configuration

`init(appIdentifier: String, position: SKOverlay.Position)`

Creates an object that represents the attributes of an overlay you use to
recommend another app on the App Store.

`var position: SKOverlay.Position`

The position of the overlay on the screen.

`enum SKOverlay.Position`

Constants that identify the position of an overlay on the screen.

Instance Property

# position

The position of the overlay on the screen.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    var position: SKOverlay.Position { get set }

## See Also

### Creating an App Configuration

`init(appIdentifier: String, position: SKOverlay.Position)`

Creates an object that represents the attributes of an overlay you use to
recommend another app on the App Store.

`var appIdentifier: String`

The iTunes identifier of the recommended app.

`enum SKOverlay.Position`

Constants that identify the position of an overlay on the screen.

Instance Property

# userDismissible

A Boolean value that indicates whether the user can dismiss the overlay.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    var userDismissible: Bool { get set }

Instance Property

# campaignToken

A token you use to represent an ad campaign and measure its effectiveness.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    var campaignToken: String? { get set }

## Discussion

A campaign token is a 40-byte string that represents an ad campaign. By
setting the `campaignToken`, you can measure the effectiveness of an Apple
Services Performance Partners Program link or an App Store Connect Analytics
campaign.

For more information, see Apple Services Performance Partners Program and App
Store Connect.

## See Also

### Verifying Advertising Campaigns

`var providerToken: String?`

A token that represents the provider of an app promotion campaign, and that
you use to measure the campaign’s effectiveness.

`func setAdditionalValue(Any?, forKey: String)`

Sets an additional value for a key; for example, a value for measuring the
effectiveness of an ad campaign.

`func additionalValue(forKey: String) -> Any?`

Returns the object associated with the key.

Instance Property

# providerToken

A token that represents the provider of an app promotion campaign, and that
you use to measure the campaign’s effectiveness.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    var providerToken: String? { get set }

## Discussion

When you set a provider token, you must also set the `campaignToken`.

When promoting your own apps, set your own provider token using
`providerToken`. This allows you to track a promotion’s effectiveness
independently from any affiliate campaign that shares the same campaign token.

When promoting apps by other developers, set `providerToken` using their
provider token. This allows those developers to track the effectiveness of
your App Store Connect Analytics campaign.

## See Also

### Verifying Advertising Campaigns

`var campaignToken: String?`

A token you use to represent an ad campaign and measure its effectiveness.

`func setAdditionalValue(Any?, forKey: String)`

Sets an additional value for a key; for example, a value for measuring the
effectiveness of an ad campaign.

`func additionalValue(forKey: String) -> Any?`

Returns the object associated with the key.

Instance Method

# setAdditionalValue(_:forKey:)

Sets an additional value for a key; for example, a value for measuring the
effectiveness of an ad campaign.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    func setAdditionalValue(
        _ value: Any?,
        forKey key: String
    )

##  Parameters

`value`

    

The value to associate with the `key`.

`key`

    

The string that identifies an additional value.

## Discussion

Set additional values to verify and associate an app installation with an ad
campaign. For more information, see `SKAdNetwork`.

## See Also

### Verifying Advertising Campaigns

`var campaignToken: String?`

A token you use to represent an ad campaign and measure its effectiveness.

`var providerToken: String?`

A token that represents the provider of an app promotion campaign, and that
you use to measure the campaign’s effectiveness.

`func additionalValue(forKey: String) -> Any?`

Returns the object associated with the key.

Instance Method

# additionalValue(forKey:)

Returns the object associated with the key.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    func additionalValue(forKey key: String) -> Any?

##  Parameters

`key`

    

The string that identifies an additional value.

## Return Value

The associated value of the key.

## Discussion

Additional values are values you use to verify and associate an app
installation with an ad campaign. For more information, see `SKAdNetwork`.

## See Also

### Verifying Advertising Campaigns

`var campaignToken: String?`

A token you use to represent an ad campaign and measure its effectiveness.

`var providerToken: String?`

A token that represents the provider of an app promotion campaign, and that
you use to measure the campaign’s effectiveness.

`func setAdditionalValue(Any?, forKey: String)`

Sets an additional value for a key; for example, a value for measuring the
effectiveness of an ad campaign.

Instance Property

# latestReleaseID

The release ID of the latest version of your app as displayed in App Store
Connect.

iOS 15.0+  iPadOS 15.0+  Mac Catalyst 15.0+  visionOS 1.0+

    
    
    var latestReleaseID: String? { get set }

Instance Property

# customProductPageIdentifier

An optional identifier for an app’s custom product page.

iOS 15.0+  iPadOS 15.0+  Mac Catalyst 15.0+  visionOS 1.0+

    
    
    var customProductPageIdentifier: String? { get set }

## Discussion

The identifier, referred to as the product variant identifier, identifies
specific variant product pages from App Store Connect for your app.

Instance Method

# setAdImpression(_:)

iOS 16.0+  iPadOS 16.0+  Mac Catalyst 16.0+

    
    
    func setAdImpression(_ impression: SKAdImpression)

Instance Property

# appImpression

AdAttributionKit  StoreKit  iOS 17.4+  iPadOS 17.4+  Xcode 15.3+

    
    
    var appImpression: AppImpression? { get set }



# SKPaymentTransactionState

Enumeration Case

# SKPaymentTransactionState.purchasing

A transaction that is being processed by the App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case purchasing = 0

Enumeration Case

# SKPaymentTransactionState.purchased

A successfully processed transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case purchased = 1

## Discussion

Your application should provide the content the user purchased.

Enumeration Case

# SKPaymentTransactionState.failed

A failed transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case failed = 2

## Discussion

Check the `error` property to determine what happened.

Enumeration Case

# SKPaymentTransactionState.restored

A transaction that restores content previously purchased by the user.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case restored = 3

## Discussion

Read the `original` property to obtain information about the original
purchase.

Enumeration Case

# SKPaymentTransactionState.deferred

A transaction that is in the queue, but its final status is pending external
action such as Ask to Buy.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case deferred = 4

## Discussion

Update your UI to show the deferred state, and wait for another callback that
indicates the final status.

Enumeration Case

# SKPaymentTransactionState.purchasing

A transaction that is being processed by the App Store.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case purchasing = 0

Enumeration Case

# SKPaymentTransactionState.purchased

A successfully processed transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case purchased = 1

## Discussion

Your application should provide the content the user purchased.

Enumeration Case

# SKPaymentTransactionState.failed

A failed transaction.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case failed = 2

## Discussion

Check the `error` property to determine what happened.

Enumeration Case

# SKPaymentTransactionState.restored

A transaction that restores content previously purchased by the user.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case restored = 3

## Discussion

Read the `original` property to obtain information about the original
purchase.

Enumeration Case

# SKPaymentTransactionState.deferred

A transaction that is in the queue, but its final status is pending external
action such as Ask to Buy.

iOS 8.0+  iPadOS 8.0+  macOS 10.10+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    case deferred = 4

## Discussion

Update your UI to show the deferred state, and wait for another callback that
indicates the final status.



# SKOverlay

Initializer

# init(configuration:)

Creates an overlay you use to recommend another app on the App Store.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    init(configuration: SKOverlay.Configuration)

##  Parameters

`configuration`

    

The object that represents the overlay’s attributes; for example, its position
on the screen.

## Discussion

Pass an `SKOverlay.AppConfiguration` as the `configuration` parameter if you
want to display the overlay in an app. To recommend an App Clip’s
corresponding app, pass an `SKOverlay.AppClipConfiguration` object to the
initializer. For more information, see Recommending your app to App Clip
users.

## See Also

### Creating an overlay

`var configuration: SKOverlay.Configuration`

An overlay’s attributes; for example, its position on the screen.

`class SKOverlay.AppConfiguration`

An object that represents the attributes of an overlay you use to recommend
another app on the App Store.

`class SKOverlay.AppClipConfiguration`

An object that represents the attributes of an overlay you use to recommend an
App Clip’s corresponding full app.

`class SKOverlay.Configuration`

The abstract superclass for all classes that represent an overlay’s
attributes.

Instance Property

# configuration

An overlay’s attributes; for example, its position on the screen.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    @NSCopying
    var configuration: SKOverlay.Configuration { get }

## See Also

### Creating an overlay

`init(configuration: SKOverlay.Configuration)`

Creates an overlay you use to recommend another app on the App Store.

`class SKOverlay.AppConfiguration`

An object that represents the attributes of an overlay you use to recommend
another app on the App Store.

`class SKOverlay.AppClipConfiguration`

An object that represents the attributes of an overlay you use to recommend an
App Clip’s corresponding full app.

`class SKOverlay.Configuration`

The abstract superclass for all classes that represent an overlay’s
attributes.

Class

# SKOverlay.Configuration

The abstract superclass for all classes that represent an overlay’s
attributes.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    class Configuration : NSObject

## Relationships

### Inherits From

  * `NSObject`

## See Also

### Creating an overlay

`init(configuration: SKOverlay.Configuration)`

Creates an overlay you use to recommend another app on the App Store.

`var configuration: SKOverlay.Configuration`

An overlay’s attributes; for example, its position on the screen.

`class SKOverlay.AppConfiguration`

An object that represents the attributes of an overlay you use to recommend
another app on the App Store.

`class SKOverlay.AppClipConfiguration`

An object that represents the attributes of an overlay you use to recommend an
App Clip’s corresponding full app.

Instance Method

# present(in:)

Presents an overlay in a window scene.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    @MainActor
    func present(in scene: UIWindowScene)

##  Parameters

`scene`

    

The window scene used to display the overlay.

Type Method

# dismiss(in:)

Dismisses an App Store overlay.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    @MainActor
    class func dismiss(in scene: UIWindowScene)

##  Parameters

`scene`

    

The window scene used to display the overlay.

Instance Property

# delegate

The overlay’s delegate.

iOS 14.0+  iPadOS 14.0+  Mac Catalyst 14.0+  visionOS 1.0+

    
    
    weak var delegate: (any SKOverlayDelegate)? { get set }

## See Also

### Setting a delegate

`protocol SKOverlayDelegate`

Methods for responding to the overlay’s appearance, dismissal, or failure to
load.



# SKProductsRequestDelegate

Instance Method

# productsRequest(_:didReceive:)

Accepts the App Store response that contains the app-requested product
information.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    func productsRequest(
        _ request: SKProductsRequest,
        didReceive response: SKProductsResponse
    )

**Required**

##  Parameters

`request`

    

The product request sent to the Apple App Store.

`response`

    

Detailed information about the list of products.

## See Also

### Related Documentation

In-App Purchase Programming Guide



# SKAdNetwork.CoarseConversionValue

Type Property

# high

A string constant value for indicating a high coarse conversion value.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+

    
    
    static let high: SKAdNetwork.CoarseConversionValue

## Discussion

This constant has no special meaning. It’s up to the app or ad network to
determine its meaning as needed.

## See Also

### Providing coarse conversion values

`static let low: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a low coarse conversion value.

`static let medium: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a medium coarse conversion value.

`init(rawValue: String)`

Creates a coarse conversion value from the raw value.

Type Property

# low

A string constant value for indicating a low coarse conversion value.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+

    
    
    static let low: SKAdNetwork.CoarseConversionValue

## Discussion

This constant has no special meaning. It’s up to the app or ad network to
determine its meaning as needed.

## See Also

### Providing coarse conversion values

`static let high: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a high coarse conversion value.

`static let medium: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a medium coarse conversion value.

`init(rawValue: String)`

Creates a coarse conversion value from the raw value.

Type Property

# medium

A string constant value for indicating a medium coarse conversion value.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+

    
    
    static let medium: SKAdNetwork.CoarseConversionValue

## Discussion

This constant has no special meaning. It’s up to the app or ad network to
determine its meaning as needed.

## See Also

### Providing coarse conversion values

`static let high: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a high coarse conversion value.

`static let low: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a low coarse conversion value.

`init(rawValue: String)`

Creates a coarse conversion value from the raw value.

Initializer

# init(rawValue:)

Creates a coarse conversion value from the raw value.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+  Xcode 14.0+

    
    
    init(rawValue: String)

##  Parameters

`rawValue`

    

A string that is one of `low`, `medium`, or `high`.

## Discussion

You don't need to call the initializer to use coarse conversion values. When
you provide the coarse conversion value to the
`updatePostbackConversionValue(_:coarseValue:completionHandler:)` or
`updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)`
methods, use the static constants, `low`, `medium`, or `high`.

## See Also

### Providing coarse conversion values

`static let high: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a high coarse conversion value.

`static let low: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a low coarse conversion value.

`static let medium: SKAdNetwork.CoarseConversionValue`

A string constant value for indicating a medium coarse conversion value.



# Product.SubscriptionPeriod.Unit.FormatStyle

Initializer

# init(from:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    init(from decoder: any Decoder) throws

## Relationships

### From Protocol

  * `Decodable`

Instance Method

# format(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func format(_ value: Product.SubscriptionPeriod.Unit) -> String

## Relationships

### From Protocol

  * `FormatStyle`

## See Also

### Formatting subscription period units

`func locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle`

`func encode(to: any Encoder)`

Instance Method

# locale(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func locale(_ locale: Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle

## Relationships

### From Protocol

  * `FormatStyle`

## See Also

### Formatting subscription period units

`func format(Product.SubscriptionPeriod.Unit) -> String`

`func encode(to: any Encoder)`

Instance Method

# encode(to:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func encode(to encoder: any Encoder) throws

## Relationships

### From Protocol

  * `Encodable`

## See Also

### Formatting subscription period units

`func format(Product.SubscriptionPeriod.Unit) -> String`

`func locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod.Unit.FormatStyle, rhs: Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing period unit formats

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func == (a: Product.SubscriptionPeriod.Unit.FormatStyle, b: Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Alias

# Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput = Product.SubscriptionPeriod.Unit

## See Also

### Getting data types

`typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput`

Type Alias

# Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput = String

## See Also

### Getting data types

`typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput`

Generic Type Method

# list(type:width:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func list<Base>(
        type: ListFormatStyle<StringStyle, Base>.ListType,
        width: ListFormatStyle<StringStyle, Base>.Width = .standard
    ) -> ListFormatStyle<StringStyle, Base> where Base : Sequence, Base.Element == String

## See Also

### Applying list styles

`static func list<MemberStyle, Base>(memberStyle: MemberStyle, type:
ListFormatStyle<MemberStyle, Base>.ListType, width:
ListFormatStyle<MemberStyle, Base>.Width) -> ListFormatStyle<MemberStyle,
Base>`

Generic Type Method

# list(memberStyle:type:width:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func list<MemberStyle, Base>(
        memberStyle: MemberStyle,
        type: ListFormatStyle<MemberStyle, Base>.ListType,
        width: ListFormatStyle<MemberStyle, Base>.Width = .standard
    ) -> ListFormatStyle<MemberStyle, Base> where MemberStyle : FormatStyle, Base : Sequence, MemberStyle.FormatInput == Base.Element, MemberStyle.FormatOutput == String

## See Also

### Applying list styles

`static func list<Base>(type: ListFormatStyle<StringStyle, Base>.ListType,
width: ListFormatStyle<StringStyle, Base>.Width) ->
ListFormatStyle<StringStyle, Base>`

Generic Type Method

# measurement(width:usage:numberFormatStyle:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func measurement<UnitType>(
        width: Measurement<UnitType>.FormatStyle.UnitWidth,
        usage: MeasurementFormatUnitUsage<UnitType> = .general,
        numberFormatStyle: FloatingPointFormatStyle<Double>? = nil
    ) -> Measurement<UnitType>.FormatStyle where UnitType : Dimension

## See Also

### Applying measurement styles

`static func measurement(width:
Measurement<UnitTemperature>.FormatStyle.UnitWidth, usage:
MeasurementFormatUnitUsage<UnitTemperature>, hidesScaleName: Bool,
numberFormatStyle: FloatingPointFormatStyle<Double>?) ->
Measurement<UnitTemperature>.FormatStyle`

Type Method

# measurement(width:usage:hidesScaleName:numberFormatStyle:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func measurement(
        width: Measurement<UnitTemperature>.FormatStyle.UnitWidth = .abbreviated,
        usage: MeasurementFormatUnitUsage<UnitTemperature> = .general,
        hidesScaleName: Bool = false,
        numberFormatStyle: FloatingPointFormatStyle<Double>? = nil
    ) -> Measurement<UnitTemperature>.FormatStyle

## See Also

### Applying measurement styles

`static func measurement<UnitType>(width:
Measurement<UnitType>.FormatStyle.UnitWidth, usage:
MeasurementFormatUnitUsage<UnitType>, numberFormatStyle:
FloatingPointFormatStyle<Double>?) -> Measurement<UnitType>.FormatStyle`

Generic Type Method

# currency(code:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func currency<Value>(code: String) -> FloatingPointFormatStyle<Value>.Currency where Value : BinaryFloatingPoint

## See Also

### Applying currency styles

`static func currency<V>(code: String) -> IntegerFormatStyle<V>.Currency`

Generic Type Method

# currency(code:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func currency<V>(code: String) -> IntegerFormatStyle<V>.Currency where V : BinaryInteger

## See Also

### Applying currency styles

`static func currency<Value>(code: String) ->
FloatingPointFormatStyle<Value>.Currency`

Initializer

# init(from:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    init(from decoder: any Decoder) throws

## Relationships

### From Protocol

  * `Decodable`

Instance Method

# format(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func format(_ value: Product.SubscriptionPeriod.Unit) -> String

## Relationships

### From Protocol

  * `FormatStyle`

## See Also

### Formatting subscription period units

`func locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle`

`func encode(to: any Encoder)`

Instance Method

# locale(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func locale(_ locale: Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle

## Relationships

### From Protocol

  * `FormatStyle`

## See Also

### Formatting subscription period units

`func format(Product.SubscriptionPeriod.Unit) -> String`

`func encode(to: any Encoder)`

Instance Method

# encode(to:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func encode(to encoder: any Encoder) throws

## Relationships

### From Protocol

  * `Encodable`

## See Also

### Formatting subscription period units

`func format(Product.SubscriptionPeriod.Unit) -> String`

`func locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod.Unit.FormatStyle, rhs: Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing period unit formats

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func == (a: Product.SubscriptionPeriod.Unit.FormatStyle, b: Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Alias

# Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput = Product.SubscriptionPeriod.Unit

## See Also

### Getting data types

`typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput`

Type Alias

# Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput = String

## See Also

### Getting data types

`typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput`

Generic Type Method

# list(type:width:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func list<Base>(
        type: ListFormatStyle<StringStyle, Base>.ListType,
        width: ListFormatStyle<StringStyle, Base>.Width = .standard
    ) -> ListFormatStyle<StringStyle, Base> where Base : Sequence, Base.Element == String

## See Also

### Applying list styles

`static func list<MemberStyle, Base>(memberStyle: MemberStyle, type:
ListFormatStyle<MemberStyle, Base>.ListType, width:
ListFormatStyle<MemberStyle, Base>.Width) -> ListFormatStyle<MemberStyle,
Base>`

Generic Type Method

# list(memberStyle:type:width:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func list<MemberStyle, Base>(
        memberStyle: MemberStyle,
        type: ListFormatStyle<MemberStyle, Base>.ListType,
        width: ListFormatStyle<MemberStyle, Base>.Width = .standard
    ) -> ListFormatStyle<MemberStyle, Base> where MemberStyle : FormatStyle, Base : Sequence, MemberStyle.FormatInput == Base.Element, MemberStyle.FormatOutput == String

## See Also

### Applying list styles

`static func list<Base>(type: ListFormatStyle<StringStyle, Base>.ListType,
width: ListFormatStyle<StringStyle, Base>.Width) ->
ListFormatStyle<StringStyle, Base>`

Generic Type Method

# measurement(width:usage:numberFormatStyle:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func measurement<UnitType>(
        width: Measurement<UnitType>.FormatStyle.UnitWidth,
        usage: MeasurementFormatUnitUsage<UnitType> = .general,
        numberFormatStyle: FloatingPointFormatStyle<Double>? = nil
    ) -> Measurement<UnitType>.FormatStyle where UnitType : Dimension

## See Also

### Applying measurement styles

`static func measurement(width:
Measurement<UnitTemperature>.FormatStyle.UnitWidth, usage:
MeasurementFormatUnitUsage<UnitTemperature>, hidesScaleName: Bool,
numberFormatStyle: FloatingPointFormatStyle<Double>?) ->
Measurement<UnitTemperature>.FormatStyle`

Type Method

# measurement(width:usage:hidesScaleName:numberFormatStyle:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func measurement(
        width: Measurement<UnitTemperature>.FormatStyle.UnitWidth = .abbreviated,
        usage: MeasurementFormatUnitUsage<UnitTemperature> = .general,
        hidesScaleName: Bool = false,
        numberFormatStyle: FloatingPointFormatStyle<Double>? = nil
    ) -> Measurement<UnitTemperature>.FormatStyle

## See Also

### Applying measurement styles

`static func measurement<UnitType>(width:
Measurement<UnitType>.FormatStyle.UnitWidth, usage:
MeasurementFormatUnitUsage<UnitType>, numberFormatStyle:
FloatingPointFormatStyle<Double>?) -> Measurement<UnitType>.FormatStyle`

Generic Type Method

# currency(code:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func currency<Value>(code: String) -> FloatingPointFormatStyle<Value>.Currency where Value : BinaryFloatingPoint

## See Also

### Applying currency styles

`static func currency<V>(code: String) -> IntegerFormatStyle<V>.Currency`

Generic Type Method

# currency(code:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func currency<V>(code: String) -> IntegerFormatStyle<V>.Currency where V : BinaryInteger

## See Also

### Applying currency styles

`static func currency<Value>(code: String) ->
FloatingPointFormatStyle<Value>.Currency`

Initializer

# init(from:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    init(from decoder: any Decoder) throws

## Relationships

### From Protocol

  * `Decodable`

Instance Method

# format(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func format(_ value: Product.SubscriptionPeriod.Unit) -> String

## Relationships

### From Protocol

  * `FormatStyle`

## See Also

### Formatting subscription period units

`func locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle`

`func encode(to: any Encoder)`

Instance Method

# locale(_:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func locale(_ locale: Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle

## Relationships

### From Protocol

  * `FormatStyle`

## See Also

### Formatting subscription period units

`func format(Product.SubscriptionPeriod.Unit) -> String`

`func encode(to: any Encoder)`

Instance Method

# encode(to:)

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func encode(to encoder: any Encoder) throws

## Relationships

### From Protocol

  * `Encodable`

## See Also

### Formatting subscription period units

`func format(Product.SubscriptionPeriod.Unit) -> String`

`func locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle`

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func != (lhs: Product.SubscriptionPeriod.Unit.FormatStyle, rhs: Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing period unit formats

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    static func == (a: Product.SubscriptionPeriod.Unit.FormatStyle, b: Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing period unit formats

`static func != (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Product.SubscriptionPeriod.Unit.FormatStyle,
Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

Type Alias

# Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput = Product.SubscriptionPeriod.Unit

## See Also

### Getting data types

`typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput`

Type Alias

# Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput

iOS 16.0+  iPadOS 16.0+  macOS 13.0+  Mac Catalyst 16.0+  tvOS 16.0+  watchOS
9.0+  visionOS 1.0+  Xcode 14.0+

    
    
    typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput = String

## See Also

### Getting data types

`typealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput`

Generic Type Method

# list(type:width:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func list<Base>(
        type: ListFormatStyle<StringStyle, Base>.ListType,
        width: ListFormatStyle<StringStyle, Base>.Width = .standard
    ) -> ListFormatStyle<StringStyle, Base> where Base : Sequence, Base.Element == String

## See Also

### Applying list styles

`static func list<MemberStyle, Base>(memberStyle: MemberStyle, type:
ListFormatStyle<MemberStyle, Base>.ListType, width:
ListFormatStyle<MemberStyle, Base>.Width) -> ListFormatStyle<MemberStyle,
Base>`

Generic Type Method

# list(memberStyle:type:width:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func list<MemberStyle, Base>(
        memberStyle: MemberStyle,
        type: ListFormatStyle<MemberStyle, Base>.ListType,
        width: ListFormatStyle<MemberStyle, Base>.Width = .standard
    ) -> ListFormatStyle<MemberStyle, Base> where MemberStyle : FormatStyle, Base : Sequence, MemberStyle.FormatInput == Base.Element, MemberStyle.FormatOutput == String

## See Also

### Applying list styles

`static func list<Base>(type: ListFormatStyle<StringStyle, Base>.ListType,
width: ListFormatStyle<StringStyle, Base>.Width) ->
ListFormatStyle<StringStyle, Base>`

Generic Type Method

# measurement(width:usage:numberFormatStyle:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func measurement<UnitType>(
        width: Measurement<UnitType>.FormatStyle.UnitWidth,
        usage: MeasurementFormatUnitUsage<UnitType> = .general,
        numberFormatStyle: FloatingPointFormatStyle<Double>? = nil
    ) -> Measurement<UnitType>.FormatStyle where UnitType : Dimension

## See Also

### Applying measurement styles

`static func measurement(width:
Measurement<UnitTemperature>.FormatStyle.UnitWidth, usage:
MeasurementFormatUnitUsage<UnitTemperature>, hidesScaleName: Bool,
numberFormatStyle: FloatingPointFormatStyle<Double>?) ->
Measurement<UnitTemperature>.FormatStyle`

Type Method

# measurement(width:usage:hidesScaleName:numberFormatStyle:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func measurement(
        width: Measurement<UnitTemperature>.FormatStyle.UnitWidth = .abbreviated,
        usage: MeasurementFormatUnitUsage<UnitTemperature> = .general,
        hidesScaleName: Bool = false,
        numberFormatStyle: FloatingPointFormatStyle<Double>? = nil
    ) -> Measurement<UnitTemperature>.FormatStyle

## See Also

### Applying measurement styles

`static func measurement<UnitType>(width:
Measurement<UnitType>.FormatStyle.UnitWidth, usage:
MeasurementFormatUnitUsage<UnitType>, numberFormatStyle:
FloatingPointFormatStyle<Double>?) -> Measurement<UnitType>.FormatStyle`

Generic Type Method

# currency(code:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func currency<Value>(code: String) -> FloatingPointFormatStyle<Value>.Currency where Value : BinaryFloatingPoint

## See Also

### Applying currency styles

`static func currency<V>(code: String) -> IntegerFormatStyle<V>.Currency`

Generic Type Method

# currency(code:)

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 16.0+  tvOS 15.0+  watchOS
8.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func currency<V>(code: String) -> IntegerFormatStyle<V>.Currency where V : BinaryInteger

## See Also

### Applying currency styles

`static func currency<Value>(code: String) ->
FloatingPointFormatStyle<Value>.Currency`



# AutomaticProductViewStyle

Type Property

# automatic

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    static var automatic: AutomaticProductViewStyle { get }

Instance Method

# makeBody(configuration:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func makeBody(configuration: AutomaticProductViewStyle.Configuration) -> some View

## Relationships

### From Protocol

  * `ProductViewStyle`

## See Also

### Creating automatic product view styles

`typealias AutomaticProductViewStyle.Body`

`init()`

Type Alias

# AutomaticProductViewStyle.Body

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias AutomaticProductViewStyle.Body = some View

## Relationships

### From Protocol

  * `ProductViewStyle`

## See Also

### Creating automatic product view styles

`func makeBody(configuration: AutomaticProductViewStyle.Configuration) ->
View`

`init()`

Initializer

# init()

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init()

## See Also

### Creating automatic product view styles

`func makeBody(configuration: AutomaticProductViewStyle.Configuration) ->
View`

`typealias AutomaticProductViewStyle.Body`



# SubscriptionStoreView

Initializer

# init(groupID:visibleRelationships:)

Creates a view to load all subscriptions in a subscription group from the App
Store and merchandise them with automatic marketing content.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        groupID: String,
        visibleRelationships: Product.SubscriptionRelationship = .all
    ) where Content == AutomaticSubscriptionStoreMarketingContent

##  Parameters

`groupID`

    

The subscription group identifier to load from the App Store.

`visibleRelationships`

    

The kinds of subscription option relationships the view makes visible when
someone is already subscribed to the subscription.

## See Also

### Creating subscription store views with subscription group IDs

`init(groupID: String, visibleRelationships: Product.SubscriptionRelationship,
marketingContent: () -> (Content))`

Creates a view to load all the subscriptions in a subscription group from the
App Store and merchandise them with custom marketing content.

`struct AutomaticSubscriptionStoreMarketingContent`

A view that represents the default marketing content for a subscription store.

Initializer

# init(groupID:visibleRelationships:marketingContent:)

Creates a view to load all the subscriptions in a subscription group from the
App Store and merchandise them with custom marketing content.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        groupID: String,
        visibleRelationships: Product.SubscriptionRelationship = .all,
        @ViewBuilder marketingContent: () -> (Content)
    )

##  Parameters

`groupID`

    

The subscription group identifier to load from the App Store.

`visibleRelationships`

    

The kinds of subscription option relationships the view makes visible when
someone is already subscribed to the subscription.

`marketingContent`

    

The view that contains marketing content, to display above the store controls.

## See Also

### Creating subscription store views with subscription group IDs

`init(groupID: String, visibleRelationships:
Product.SubscriptionRelationship)`

Creates a view to load all subscriptions in a subscription group from the App
Store and merchandise them with automatic marketing content.

`struct AutomaticSubscriptionStoreMarketingContent`

A view that represents the default marketing content for a subscription store.

Initializer

# init(productIDs:)

Creates a view to load a collection of subscriptions and merchandise them with
automatic marketing content.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(productIDs: some Collection<String>) where Content == AutomaticSubscriptionStoreMarketingContent

##  Parameters

`productIDs`

    

The product identifiers to load from the App Store.

## See Also

### Creating subscription store views with product IDs

`init(productIDs: some Collection<String>, marketingContent: () -> (Content))`

Creates a view to load a collection of subscriptions from the App Store and
merchandise them with custom marketing content.

Initializer

# init(productIDs:marketingContent:)

Creates a view to load a collection of subscriptions from the App Store and
merchandise them with custom marketing content.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        productIDs: some Collection<String>,
        @ViewBuilder marketingContent: () -> (Content)
    )

##  Parameters

`productIDs`

    

The product identifiers to load from the App Store.

`marketingContent`

    

The view that contains marketing content, to display above the store controls.

## See Also

### Creating subscription store views with product IDs

`init(productIDs: some Collection<String>)`

Creates a view to load a collection of subscriptions and merchandise them with
automatic marketing content.

Initializer

# init(subscriptions:)

Creates a view to display a collection of subscription options and merchandise
them with automatic marketing content.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(subscriptions: some Collection<Product>) where Content == AutomaticSubscriptionStoreMarketingContent

##  Parameters

`subscriptions`

    

A collection of auto-renewable subscription `Product` instances to
merchandise. The auto-renewable subscriptions need to belong to the same
subscription group.

## See Also

### Creating subscription store views with preloaded subscriptions

`init(subscriptions: some Collection<Product>, marketingContent: () ->
(Content))`

Creates a view to display a collection of subscription options and merchandise
them with custom marketing content.

Initializer

# init(subscriptions:marketingContent:)

Creates a view to display a collection of subscription options and merchandise
them with custom marketing content.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        subscriptions: some Collection<Product>,
        @ViewBuilder marketingContent: () -> (Content)
    )

##  Parameters

`subscriptions`

    

A collection of auto-renewable subscription `Product` instances to
merchandise. The auto-renewable subscriptions need to belong to the same
subscription group.

`marketingContent`

    

A view that contains marketing content, to display above the store controls.

## See Also

### Creating subscription store views with preloaded subscriptions

`init(subscriptions: some Collection<Product>)`

Creates a view to display a collection of subscription options and merchandise
them with automatic marketing content.

Instance Method

# inAppPurchaseOptions(_:)

Adds a function the system calls before it processes a purchase from a store
view, which provides a set of purchase options.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func inAppPurchaseOptions(_ options: ((Product) async -> Set<Product.PurchaseOption>)?) -> some View

## See Also

### Responding to store events

`func onInAppPurchaseStart(perform: ((Product) -> ())?) -> View`

Adds an action to perform when a person uses the purchase button for a product
within the view.

`func onInAppPurchaseCompletion(perform: ((Product,
Result<Product.PurchaseResult, any Error>) -> ())?) -> View`

Adds an action to perform when a purchase the person initiates from within a
product view completes.

`func subscriptionStoreSignInAction((() -> ())?) -> View`

Add an action to perform when a person uses the sign-in button on a
subscription store view within the view.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# onInAppPurchaseStart(perform:)

Adds an action to perform when a person uses the purchase button for a product
within the view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func onInAppPurchaseStart(perform action: ((Product) async -> ())?) -> some View

##  Parameters

`action`

    

A closure that defines an action to perform, including the product the person
intends to purchase as a parameter.

## Discussion

Set the `action` parameter to `nil` to remove any actions that ancestor views
may add.

## See Also

### Responding to store events

`func inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) ->
View`

Adds a function the system calls before it processes a purchase from a store
view, which provides a set of purchase options.

`func onInAppPurchaseCompletion(perform: ((Product,
Result<Product.PurchaseResult, any Error>) -> ())?) -> View`

Adds an action to perform when a purchase the person initiates from within a
product view completes.

`func subscriptionStoreSignInAction((() -> ())?) -> View`

Add an action to perform when a person uses the sign-in button on a
subscription store view within the view.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# onInAppPurchaseCompletion(perform:)

Adds an action to perform when a purchase the person initiates from within a
product view completes.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func onInAppPurchaseCompletion(perform action: ((Product, Result<Product.PurchaseResult, any Error>) async -> ())?) -> some View

## See Also

### Responding to store events

`func inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) ->
View`

Adds a function the system calls before it processes a purchase from a store
view, which provides a set of purchase options.

`func onInAppPurchaseStart(perform: ((Product) -> ())?) -> View`

Adds an action to perform when a person uses the purchase button for a product
within the view.

`func subscriptionStoreSignInAction((() -> ())?) -> View`

Add an action to perform when a person uses the sign-in button on a
subscription store view within the view.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# subscriptionStoreSignInAction(_:)

Add an action to perform when a person uses the sign-in button on a
subscription store view within the view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStoreSignInAction(_ action: (() -> ())?) -> some View

## See Also

### Responding to store events

`func inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) ->
View`

Adds a function the system calls before it processes a purchase from a store
view, which provides a set of purchase options.

`func onInAppPurchaseStart(perform: ((Product) -> ())?) -> View`

Adds an action to perform when a person uses the purchase button for a product
within the view.

`func onInAppPurchaseCompletion(perform: ((Product,
Result<Product.PurchaseResult, any Error>) -> ())?) -> View`

Adds an action to perform when a purchase the person initiates from within a
product view completes.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# subscriptionStoreControlIcon(icon:)

Sets a view to use to decorate individual subscription options within a
subscription store view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStoreControlIcon(@ViewBuilder icon: @escaping (Product, Product.SubscriptionInfo) -> some View) -> some View

##  Parameters

`icon`

    

A closure that takes a `Product` and `Product.SubscriptionInfo` and returns a
view.

## Discussion

You can adjust this view to provide a different appearance for each
subscription option.

## See Also

### Configuring subscription store view controls

`func subscriptionStorePickerItemBackground(some ShapeStyle) -> View`

Sets the background style for picker items of the subscription store view
instances within a view.

`func subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View`

Configures the subscription store views within a view to use a specified
button label.

`struct SubscriptionStoreButtonLabel`

The label of the subscribe button that a subscription store view uses.

`func subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) ->
View`

Sets the control style for subscription store views within a view.

Instance Method

# subscriptionStorePickerItemBackground(_:)

Sets the background style for picker items of the subscription store view
instances within a view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStorePickerItemBackground(_ backgroundStyle: some ShapeStyle) -> some View

## See Also

### Configuring subscription store view controls

`func subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo)
-> some View) -> View`

Sets a view to use to decorate individual subscription options within a
subscription store view.

`func subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View`

Configures the subscription store views within a view to use a specified
button label.

`struct SubscriptionStoreButtonLabel`

The label of the subscribe button that a subscription store view uses.

`func subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) ->
View`

Sets the control style for subscription store views within a view.

Instance Method

# subscriptionStoreButtonLabel(_:)

Configures the subscription store views within a view to use a specified
button label.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStoreButtonLabel(_ label: SubscriptionStoreButtonLabel) -> some View

## See Also

### Configuring subscription store view controls

`func subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo)
-> some View) -> View`

Sets a view to use to decorate individual subscription options within a
subscription store view.

`func subscriptionStorePickerItemBackground(some ShapeStyle) -> View`

Sets the background style for picker items of the subscription store view
instances within a view.

`struct SubscriptionStoreButtonLabel`

The label of the subscribe button that a subscription store view uses.

`func subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) ->
View`

Sets the control style for subscription store views within a view.

Instance Method

# subscriptionStoreControlStyle(_:)

Sets the control style for subscription store views within a view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStoreControlStyle(_ style: some SubscriptionStoreControlStyle) -> some View

## Discussion

This view modifier set the style of controls for `SubscriptionStoreView`
instances within a view.

## See Also

### Configuring subscription store view controls

`func subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo)
-> some View) -> View`

Sets a view to use to decorate individual subscription options within a
subscription store view.

`func subscriptionStorePickerItemBackground(some ShapeStyle) -> View`

Sets the background style for picker items of the subscription store view
instances within a view.

`func subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View`

Configures the subscription store views within a view to use a specified
button label.

`struct SubscriptionStoreButtonLabel`

The label of the subscribe button that a subscription store view uses.

Instance Method

# storeButton(_:for:)

Specifies the visibility of auxilliary buttons that store view and
subscription store view instances may use.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func storeButton(
        _ visibility: Visibility,
        for buttonKinds: StoreButtonKind...
    ) -> some View

##  Parameters

`visibility`

    

The preferred visibility (`Visibility`) of the button.

`buttonKinds`

    

The type of store button (`StoreButtonKind`).

## See Also

### Adding accessory feature buttons

`struct StoreButtonKind`

A button to display in a store view or subscription store view.

Structure

# ContainerBackgroundPlacement

The placement of a container background.

iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+

    
    
    struct ContainerBackgroundPlacement

## Overview

This method controls where to place a background that you specify with the
`containerBackground(_:for:)` or `containerBackground(for:alignment:content:)`
modifier.

## Topics

### Getting placements

`static let navigation: ContainerBackgroundPlacement`

A background placement inside a `NavigationStack` or `NavigationSplitView`

`static let tabView: ContainerBackgroundPlacement`

A background placement inside a `TabView`.

`static let widget: ContainerBackgroundPlacement`

The container background placement for a widget.

### Getting StoreKit placements

`static var subscriptionStore: ContainerBackgroundPlacement`

A background placement inside a `SubscriptionStoreView`.

`static var subscriptionStoreFullHeight: ContainerBackgroundPlacement`

A background placement that spans the full height of a
`SubscriptionStoreView`.

`static var subscriptionStoreHeader: ContainerBackgroundPlacement`

A background placement inside the marketing content of a
`SubscriptionStoreView`

## Relationships

### Conforms To

  * `Equatable`
  * `Hashable`
  * `Sendable`

## See Also

### Layering views

Adding a background to your view

Compose a background behind your view and extend it beyond the safe area
insets.

`struct ZStack`

A view that overlays its subviews, aligning them in both axes.

`func zIndex(Double) -> some View`

Controls the display order of overlapping views.

`func background<V>(alignment: Alignment, content: () -> V) -> some View`

Layers the views that you specify behind this view.

`func background<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View`

Sets the view’s background to a style.

`func background(ignoresSafeAreaEdges: Edge.Set) -> some View`

Sets the view’s background to the default background style.

`func background<S, T>(S, in: T, fillStyle: FillStyle) -> some View`

Sets the view’s background to an insettable shape filled with a style.

`func background<S>(in: S, fillStyle: FillStyle) -> some View`

Sets the view’s background to an insettable shape filled with the default
background style.

`func background<S, T>(S, in: T, fillStyle: FillStyle) -> some View`

Sets the view’s background to a shape filled with a style.

`func background<S>(in: S, fillStyle: FillStyle) -> some View`

Sets the view’s background to a shape filled with the default background
style.

`func overlay<V>(alignment: Alignment, content: () -> V) -> some View`

Layers the views that you specify in front of this view.

`func overlay<S>(S, ignoresSafeAreaEdges: Edge.Set) -> some View`

Layers the specified style in front of this view.

`func overlay<S, T>(S, in: T, fillStyle: FillStyle) -> some View`

Layers a shape that you specify in front of this view.

`var backgroundMaterial: Material?`

The material underneath the current view.

`func containerBackground<S>(S, for: ContainerBackgroundPlacement) -> some
View`

Sets the container background of the enclosing container using a view.

`func containerBackground<V>(for: ContainerBackgroundPlacement, alignment:
Alignment, content: () -> V) -> some View`

Sets the container background of the enclosing container using a view.

Instance Method

# subscriptionStorePolicyDestination(for:destination:)

Configures a view as the destination for a policy button action in
subscription store views.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStorePolicyDestination(
        for button: SubscriptionStorePolicyKind,
        @ViewBuilder destination: () -> some View
    ) -> some View

## See Also

### Configuring the subscription store policies

`func subscriptionStorePolicyDestination(url: URL, for:
SubscriptionStorePolicyKind) -> View`

Configures a URL as the destination for a policy button action in subscription
store views.

`func subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> View`

Sets the style for the terms of service and privacy policy buttons within a
subscription store view.

`func subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle)
-> View`

Sets the primary and secondary style for the terms of service and privacy
policy buttons within a subscription store view.

`struct SubscriptionStorePolicyKind`

The type of policy, such as the terms of service or privacy policies.

Instance Method

# subscriptionStorePolicyDestination(url:for:)

Configures a URL as the destination for a policy button action in subscription
store views.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStorePolicyDestination(
        url: URL,
        for button: SubscriptionStorePolicyKind
    ) -> some View

## See Also

### Configuring the subscription store policies

`func subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind,
destination: () -> some View) -> View`

Configures a view as the destination for a policy button action in
subscription store views.

`func subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> View`

Sets the style for the terms of service and privacy policy buttons within a
subscription store view.

`func subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle)
-> View`

Sets the primary and secondary style for the terms of service and privacy
policy buttons within a subscription store view.

`struct SubscriptionStorePolicyKind`

The type of policy, such as the terms of service or privacy policies.

Instance Method

# subscriptionStorePolicyForegroundStyle(_:)

Sets the style for the terms of service and privacy policy buttons within a
subscription store view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStorePolicyForegroundStyle(_ style: some ShapeStyle) -> some View

## See Also

### Configuring the subscription store policies

`func subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind,
destination: () -> some View) -> View`

Configures a view as the destination for a policy button action in
subscription store views.

`func subscriptionStorePolicyDestination(url: URL, for:
SubscriptionStorePolicyKind) -> View`

Configures a URL as the destination for a policy button action in subscription
store views.

`func subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle)
-> View`

Sets the primary and secondary style for the terms of service and privacy
policy buttons within a subscription store view.

`struct SubscriptionStorePolicyKind`

The type of policy, such as the terms of service or privacy policies.

Instance Method

# subscriptionStorePolicyForegroundStyle(_:_:)

Sets the primary and secondary style for the terms of service and privacy
policy buttons within a subscription store view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func subscriptionStorePolicyForegroundStyle(
        _ primary: some ShapeStyle,
        _ secondary: some ShapeStyle
    ) -> some View

## See Also

### Configuring the subscription store policies

`func subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind,
destination: () -> some View) -> View`

Configures a view as the destination for a policy button action in
subscription store views.

`func subscriptionStorePolicyDestination(url: URL, for:
SubscriptionStorePolicyKind) -> View`

Configures a URL as the destination for a policy button action in subscription
store views.

`func subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> View`

Sets the style for the terms of service and privacy policy buttons within a
subscription store view.

`struct SubscriptionStorePolicyKind`

The type of policy, such as the terms of service or privacy policies.

Instance Property

# body

The content and behavior of the view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @MainActor
    var body: some View { get }

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing a subscription store view

`typealias SubscriptionStoreView.Body`

The type of view that represents the body of the subscription store view.

Type Alias

# SubscriptionStoreView.Body

The type of view that represents the body of the subscription store view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias SubscriptionStoreView<Content>.Body = some View

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing a subscription store view

`var body: View`

The content and behavior of the view.

Instance Method

# productDescription(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.4+
tvOS 17.0+  watchOS 10.0+  visionOS 1.1+  Xcode 15.0+

    
    
    func productDescription(_ visibility: Visibility) -> some View

Instance Method

# searchPresentationToolbarBehavior(_:)

StoreKit  SwiftUI  iOS 17.1+  iPadOS 17.1+  macOS 14.1+  Mac Catalyst 17.2+
tvOS 17.1+  watchOS 10.1+  visionOS 1.0+  Xcode 14.4+

    
    
    func searchPresentationToolbarBehavior(_ behavior: SearchPresentationToolbarBehavior) -> some View

Instance Method

# subscriptionPromotionalOffer(offer:signature:)

StoreKit  SwiftUI  iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+
tvOS 17.4+  watchOS 10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func subscriptionPromotionalOffer(
        offer: @escaping (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?,
        signature: @escaping (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) async throws -> Product.SubscriptionOffer.Signature
    ) -> some View



# Transaction.RefundRequestStatus

Enumeration Case

# Transaction.RefundRequestStatus.userCancelled

The user canceled submission of their refund request.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case userCancelled

## See Also

### Getting Refund Request Status

`case success`

The App Store has received the refund request.

Enumeration Case

# Transaction.RefundRequestStatus.success

The App Store has received the refund request.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    case success

## See Also

### Getting Refund Request Status

`case userCancelled`

The user canceled submission of their refund request.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func != (lhs: Transaction.RefundRequestStatus, rhs: Transaction.RefundRequestStatus) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and Hashing Refund Request Status

`static func == (Transaction.RefundRequestStatus,
Transaction.RefundRequestStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value indicating whether two values are equal.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    static func == (a: Transaction.RefundRequestStatus, b: Transaction.RefundRequestStatus) -> Bool

## See Also

### Comparing and Hashing Refund Request Status

`static func != (Transaction.RefundRequestStatus,
Transaction.RefundRequestStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of this value by feeding them into the given
hasher.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    func hash(into hasher: inout Hasher)

##  Parameters

`hasher`

    

The hasher to use when combining the components of this instance.

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Refund Request Status

`static func != (Transaction.RefundRequestStatus,
Transaction.RefundRequestStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Transaction.RefundRequestStatus,
Transaction.RefundRequestStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 15.0+  iPadOS 15.0+  macOS 12.0+  Mac Catalyst 15.0+  tvOS 17.0+  watchOS
10.0+  visionOS 1.0+  Xcode 13.0+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and Hashing Refund Request Status

`static func != (Transaction.RefundRequestStatus,
Transaction.RefundRequestStatus) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (Transaction.RefundRequestStatus,
Transaction.RefundRequestStatus) -> Bool`

Returns a Boolean value indicating whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of this value by feeding them into the given
hasher.



# PaymentMethodBinding.PaymentMethodBindingError

Enumeration Case

# PaymentMethodBinding.PaymentMethodBindingError.failed

The initialization or binding operation failed.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    case failed

## Discussion

The methods of the `PaymentMethodBinding` struct can fail if the app isn’t
entitled to use this API, or if other errors occur.

## See Also

### Getting error codes

`case invalidPinningID`

The in-app binding identifier is invalid or expired.

`case notEligible`

The user isn’t eligible.

Enumeration Case

# PaymentMethodBinding.PaymentMethodBindingError.invalidPinningID

The in-app binding identifier is invalid or expired.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    case invalidPinningID

## Discussion

For more information about the identifier, see `id`.

## See Also

### Getting error codes

`case failed`

The initialization or binding operation failed.

`case notEligible`

The user isn’t eligible.

Enumeration Case

# PaymentMethodBinding.PaymentMethodBindingError.notEligible

The user isn’t eligible.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    case notEligible

## See Also

### Getting error codes

`case failed`

The initialization or binding operation failed.

`case invalidPinningID`

The in-app binding identifier is invalid or expired.

Instance Property

# errorDescription

A description of the error, suitable for debugging.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var errorDescription: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Getting error descriptions

`var failureReason: String?`

A string that describes the reason for the failure.

`var helpAnchor: String?`

A localized message that provides additional information if the user requests
help.

`var localizedDescription: String`

A localized message that describes the error.

`var recoverySuggestion: String?`

A message that contains a suggestion for recovering from the error.

Instance Property

# failureReason

A string that describes the reason for the failure.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var failureReason: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Getting error descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var helpAnchor: String?`

A localized message that provides additional information if the user requests
help.

`var localizedDescription: String`

A localized message that describes the error.

`var recoverySuggestion: String?`

A message that contains a suggestion for recovering from the error.

Instance Property

# helpAnchor

A localized message that provides additional information if the user requests
help.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var helpAnchor: String? { get }

## See Also

### Getting error descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A string that describes the reason for the failure.

`var localizedDescription: String`

A localized message that describes the error.

`var recoverySuggestion: String?`

A message that contains a suggestion for recovering from the error.

Instance Property

# localizedDescription

A localized message that describes the error.

iOS 8.0+  iPadOS 8.0+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var localizedDescription: String { get }

## See Also

### Getting error descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A string that describes the reason for the failure.

`var helpAnchor: String?`

A localized message that provides additional information if the user requests
help.

`var recoverySuggestion: String?`

A message that contains a suggestion for recovering from the error.

Instance Property

# recoverySuggestion

A message that contains a suggestion for recovering from the error.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var recoverySuggestion: String? { get }

## Relationships

### From Protocol

  * `LocalizedError`

## See Also

### Getting error descriptions

`var errorDescription: String?`

A description of the error, suitable for debugging.

`var failureReason: String?`

A string that describes the reason for the failure.

`var helpAnchor: String?`

A localized message that provides additional information if the user requests
help.

`var localizedDescription: String`

A localized message that describes the error.

Operator

# !=(_:_:)

Returns a Boolean value indicating whether two values are not equal.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    static func != (lhs: PaymentMethodBinding.PaymentMethodBindingError, rhs: PaymentMethodBinding.PaymentMethodBindingError) -> Bool

##  Parameters

`lhs`

    

A value to compare.

`rhs`

    

Another value to compare.

## Discussion

Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
implies that `a == b` is `false`.

This is the default implementation of the not-equal-to operator (`!=`) for any
type that conforms to `Equatable`.

## See Also

### Comparing and hashing errors

`static func == (PaymentMethodBinding.PaymentMethodBindingError,
PaymentMethodBinding.PaymentMethodBindingError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Operator

# ==(_:_:)

Returns a Boolean value that indicates whether two values are equal.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    static func == (a: PaymentMethodBinding.PaymentMethodBindingError, b: PaymentMethodBinding.PaymentMethodBindingError) -> Bool

## See Also

### Comparing and hashing errors

`static func != (PaymentMethodBinding.PaymentMethodBindingError,
PaymentMethodBinding.PaymentMethodBindingError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.

`var hashValue: Int`

The hash value.

Instance Method

# hash(into:)

Hashes the essential components of the value by feeding them into the given
hasher.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    func hash(into hasher: inout Hasher)

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing errors

`static func != (PaymentMethodBinding.PaymentMethodBindingError,
PaymentMethodBinding.PaymentMethodBindingError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (PaymentMethodBinding.PaymentMethodBindingError,
PaymentMethodBinding.PaymentMethodBindingError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`var hashValue: Int`

The hash value.

Instance Property

# hashValue

The hash value.

iOS 16.4+  iPadOS 16.4+  Mac Catalyst 16.4+  visionOS 1.0+  Xcode 14.3+

    
    
    var hashValue: Int { get }

## Relationships

### From Protocol

  * `Hashable`

## See Also

### Comparing and hashing errors

`static func != (PaymentMethodBinding.PaymentMethodBindingError,
PaymentMethodBinding.PaymentMethodBindingError) -> Bool`

Returns a Boolean value indicating whether two values are not equal.

`static func == (PaymentMethodBinding.PaymentMethodBindingError,
PaymentMethodBinding.PaymentMethodBindingError) -> Bool`

Returns a Boolean value that indicates whether two values are equal.

`func hash(into: inout Hasher)`

Hashes the essential components of the value by feeding them into the given
hasher.



# ProductView

Initializer

# init(id:prefersPromotionalIcon:)

Creates a view to load and merchandise an individual product from the App
Store.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        id productID: Product.ID,
        prefersPromotionalIcon: Bool = false
    ) where Icon == EmptyView, PlaceholderIcon == EmptyView

##  Parameters

`productID`

    

The product identifier to load from the App Store.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use the promotional image from the
App Store, if it’s available. If this parameter is `false`, the system ignores
any promotional images.

## Discussion

By default, the view doesn’t show an icon. If you set the
`prefersPromotionalIcon` parameter to `true`, the view displays a placeholder
icon while loading, and replaces the placeholder with the promotional image
for the product.

Tip

To gain more control over the image that decorates this view, use the
`init(id:icon:placeholderIcon:)` initializer. It receives a
`ProductIconPhase`, which enables you to supply an image for each phase of the
image-loading process.

## See Also

### Creating product views that load products

`init(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon)`

Creates a view to load an individual product from the App Store and
merchandise it using a custom icon.

`init(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon,
placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load an individual product from the App Store and
merchandise it using an image and a custom placeholder icon.

`init(id: Product.ID, icon: (ProductIconPhase) -> Icon, placeholderIcon: () ->
PlaceholderIcon)`

Creates a view to load an individual product from the App Store, and
merchandise it using its promotional image and a custom placeholder icon.

Initializer

# init(id:prefersPromotionalIcon:icon:)

Creates a view to load an individual product from the App Store and
merchandise it using a custom icon.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        id productID: Product.ID,
        prefersPromotionalIcon: Bool = false,
        @ViewBuilder icon: () -> Icon
    ) where PlaceholderIcon == AutomaticProductPlaceholderIcon

##  Parameters

`productID`

    

The product identifier to load from the App Store.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use the promotional image from the
App Store, if it’s available. If this value is `true` and a promotional image
for the product is available, the view displays it instead of the view you
provide in the `icon` parameter.

`icon`

    

A closure that returns the image the view displays when the system finishes
loading the product from the App Store.

## Discussion

The product view displays a placeholder icon until the system finishes loading
the product. After the product loads, the system uses the view you provide in
the `icon` parameter, by default. If `prefersPromotionalIcon` is `true` and
the product has a promotional image, the view displays the promotional image
as its icon instead of the provided view.

Tip

To gain more control over the image that decorates this view, use the
`init(id:icon:placeholderIcon:)` initializer. It receives a
`ProductIconPhase`, which enables you to supply an image for each phase of the
image-loading process.

## See Also

### Creating product views that load products

`init(id: Product.ID, prefersPromotionalIcon: Bool)`

Creates a view to load and merchandise an individual product from the App
Store.

`init(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon,
placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load an individual product from the App Store and
merchandise it using an image and a custom placeholder icon.

`init(id: Product.ID, icon: (ProductIconPhase) -> Icon, placeholderIcon: () ->
PlaceholderIcon)`

Creates a view to load an individual product from the App Store, and
merchandise it using its promotional image and a custom placeholder icon.

Initializer

# init(id:prefersPromotionalIcon:icon:placeholderIcon:)

Creates a view to load an individual product from the App Store and
merchandise it using an image and a custom placeholder icon.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        id productID: Product.ID,
        prefersPromotionalIcon: Bool = false,
        @ViewBuilder icon: () -> Icon,
        @ViewBuilder placeholderIcon: () -> PlaceholderIcon
    )

##  Parameters

`productID`

    

The product identifier to load from the App Store.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use the promotional image from the
App Store, if it’s available. If this value is `true` and a promotional image
for the product is available, the view displays it instead of the view you
provide in the `icon` parameter.

`icon`

    

A closure that returns the image the view displays when the system
successfully finishes loading the product from the App Store.

`placeholderIcon`

    

A closure that returns the image that the view uses while the system loads the
product from the App Store.

## Discussion

The product view displays the custom `placeholderIcon` until the system
finishes loading the product. After the product loads, the system uses the
view you provide in the `icon` parameter by default. If
`prefersPromotionalIcon` is `true` and the product has a promotional image,
the view displays the promotional image as its image instead of the view that
`icon` provides.

The following code example shows how to create a product view using the `icon`
and a custom `placeholderIcon`:

Tip

To gain more control over the image that decorates this view, use the
`init(id:icon:placeholderIcon:)` initializer. It receives a
`ProductIconPhase`, which enables you to supply an image for each phase of the
image-loading process.

## See Also

### Creating product views that load products

`init(id: Product.ID, prefersPromotionalIcon: Bool)`

Creates a view to load and merchandise an individual product from the App
Store.

`init(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon)`

Creates a view to load an individual product from the App Store and
merchandise it using a custom icon.

`init(id: Product.ID, icon: (ProductIconPhase) -> Icon, placeholderIcon: () ->
PlaceholderIcon)`

Creates a view to load an individual product from the App Store, and
merchandise it using its promotional image and a custom placeholder icon.

Initializer

# init(id:icon:placeholderIcon:)

Creates a view to load an individual product from the App Store, and
merchandise it using its promotional image and a custom placeholder icon.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        id productID: Product.ID,
        @ViewBuilder icon: @escaping (ProductIconPhase) -> Icon,
        @ViewBuilder placeholderIcon: () -> PlaceholderIcon
    )

##  Parameters

`productID`

    

The product identifier to load from the App Store.

`icon`

    

A closure that receives a `ProductIconPhase` as an input, which indicates the
state of the loading operation of the product’s promotional image, and returns
the view to display for the specified phase.

`placeholderIcon`

    

A closure that returns an icon to display until the system finishes loading
the product from the App Store.

## Discussion

The product view shows the `placeholderIcon` until the system finishes loading
the product. After the product finishes loading, the view asynchronously loads
and displays the product’s promotional image. Use the `ProductIconPhase` to
monitor the current loading state of the product’s promotional image.

If the product is unavailable, the view displays the `placeholderIcon` as a
fallback.

The `ProductIconPhase` value indicates whether the promotional image is
loading, unavailable, or whether it succeeded or failed to load. Use the phase
to decide what to draw. While the image’s loading operation is in the
`ProductIconPhase.loading` phase, consider displaying the same view that you
provide in the `placeholderIcon` closure. For more information, see
`ProductIconPhase`.

## See Also

### Creating product views that load products

`init(id: Product.ID, prefersPromotionalIcon: Bool)`

Creates a view to load and merchandise an individual product from the App
Store.

`init(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon)`

Creates a view to load an individual product from the App Store and
merchandise it using a custom icon.

`init(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon,
placeholderIcon: () -> PlaceholderIcon)`

Creates a view to load an individual product from the App Store and
merchandise it using an image and a custom placeholder icon.

Initializer

# init(_:prefersPromotionalIcon:icon:)

Creates a view to merchandise an individual product using a custom icon.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        _ product: Product,
        prefersPromotionalIcon: Bool = false,
        @ViewBuilder icon: () -> Icon
    ) where PlaceholderIcon == EmptyView

##  Parameters

`product`

    

The product to merchandise.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use the promotional image from the
App Store, if it’s available. If this value is `true` and a promotional image
for the product is available, the view displays it instead of the view you
provide in the `icon` parameter.

`icon`

    

A closure that returns the image to use for decorating the in-app purchase
product.

## Discussion

If `prefersPromotionalIcon` is `true` and the product has a promotional image,
the view displays the promotional image instead of the view you provide in
`icon`.

The following example shows how to create a product view using a custom icon:

Tip

To gain more control over the image that decorates this view, use the
`init(_:icon:)` initializer. It receives a `ProductIconPhase`, which enables
you to supply an image for each phase of the image-loading process.

## See Also

### Creating product views with preloaded products

`init(Product, prefersPromotionalIcon: Bool)`

Creates a view to merchandise an individual product.

`init(Product, icon: (ProductIconPhase) -> Icon)`

Creates a view to display a product that the system already loaded from the
App Store, and merchandise it using its promotional image.

Initializer

# init(_:prefersPromotionalIcon:)

Creates a view to merchandise an individual product.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        _ product: Product,
        prefersPromotionalIcon: Bool = true
    ) where Icon == EmptyView, PlaceholderIcon == EmptyView

##  Parameters

`product`

    

The product to merchandise.

`prefersPromotionalIcon`

    

A Boolean value that indicates whether to use the promotional image from the
App Store, if it’s available. If this value is `true` and a promotional image
for the product is available, the view displays it.

## Discussion

If the product has a promotional image available, the view displays it.
Otherwise, the view doesn’t show an image.

If you set the `prefersPromotionalIcon` parameter to `false`, the view doesn’t
show an image even if the product has a promotional image available.

Tip

To gain more control over the image that decorates this view, use the
`init(_:icon:)` initializer. It receives a `ProductIconPhase`, which enables
you to supply an image for each phase of the image-loading process.

## See Also

### Creating product views with preloaded products

`init(Product, prefersPromotionalIcon: Bool, icon: () -> Icon)`

Creates a view to merchandise an individual product using a custom icon.

`init(Product, icon: (ProductIconPhase) -> Icon)`

Creates a view to display a product that the system already loaded from the
App Store, and merchandise it using its promotional image.

Initializer

# init(_:icon:)

Creates a view to display a product that the system already loaded from the
App Store, and merchandise it using its promotional image.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(
        _ product: Product,
        @ViewBuilder icon: @escaping (ProductIconPhase) -> Icon
    ) where PlaceholderIcon == EmptyView

##  Parameters

`product`

    

The product to merchandise.

`icon`

    

A closure that receives a `ProductIconPhase` as an input, which indicates the
state of the loading operation of the product’s promoted image, and returns
the view to display for the specified phase.

## Discussion

The product view asynchronously loads and displays the product’s promotional
image.

The `ProductIconPhase` value indicates whether the promotional image is
loading, unavailable, or whether it succeeded or failed to load. Use the
`ProductIconPhase` to monitor current loading phase, and to decide the image
to return in the `icon` closure.

## See Also

### Creating product views with preloaded products

`init(Product, prefersPromotionalIcon: Bool, icon: () -> Icon)`

Creates a view to merchandise an individual product using a custom icon.

`init(Product, prefersPromotionalIcon: Bool)`

Creates a view to merchandise an individual product.

Initializer

# init(_:)

Creates a view to merchandise an individual product using a configuration for
product view style.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    init(_ configuration: ProductViewStyleConfiguration) where Icon == ProductViewStyleConfiguration.Icon, PlaceholderIcon == ProductViewStyleConfiguration.Icon

##  Parameters

`configuration`

    

A configuration for a product view style.

## Discussion

Use this initializer within the `makeBody(configuration:)` method of a
`ProductViewStyle` to create an instance of the product view you want to
style. This is useful for custom product view styles that modify the current
style, rather than implementing a new style.

The following code example shows how to create and use custom styles by
composing standard styles:

## See Also

### Creating product views with a configuration

`struct AutomaticProductPlaceholderIcon`

A view that represents the default placeholder icon for an in-app store
product.

Instance Method

# inAppPurchaseOptions(_:)

Adds a function the system calls before it processes a purchase from a product
view, which provides a set of purchase options.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func inAppPurchaseOptions(_ options: ((Product) async -> Set<Product.PurchaseOption>)?) -> some View

##  Parameters

`options`

    

A closure you provide for the system to call before it processes a purchase.
The system sends the product the person intends to purchase as a parameter.
Return a set of purchase options (`Product.PurchaseOption`) to add to the
purchase.

## Discussion

When you provide purchase options ( `Product.PurchaseOption` ), the view adds
default purchase options to your options. These default purchase options may,
in some cases, override your purchase options. For example, the default
options sets the quantity to 1, because the product view always displays
prices based on a single item.

The product view uses the purchase options to configure the purchase.

If you want an in-app purchase to begin without adding purchase options, add
an action using `onInAppPurchaseStart(perform:)` instead.

You can remove any options that ancestor views may add by providing `nil` for
the `option` parameter, which results in the purchase having the default set
of purchase options.

## See Also

### Responding to store events

`func onInAppPurchaseStart(perform: ((Product) -> ())?) -> View`

Adds an action to perform when a person uses the purchase button for a product
within the view.

`func onInAppPurchaseCompletion(perform: ((Product,
Result<Product.PurchaseResult, any Error>) -> ())?) -> View`

Adds an action to perform when a purchase the person initiates from within a
product view completes.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# onInAppPurchaseStart(perform:)

Adds an action to perform when a person uses the purchase button for a product
within the view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func onInAppPurchaseStart(perform action: ((Product) async -> ())?) -> some View

##  Parameters

`action`

    

A closure that defines an action to perform, including the product the person
intends to purchase as a parameter.

## Discussion

Set the `action` parameter to `nil` to remove any actions that ancestor views
may add.

## See Also

### Responding to store events

`func inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) ->
View`

Adds a function the system calls before it processes a purchase from a product
view, which provides a set of purchase options.

`func onInAppPurchaseCompletion(perform: ((Product,
Result<Product.PurchaseResult, any Error>) -> ())?) -> View`

Adds an action to perform when a purchase the person initiates from within a
product view completes.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# onInAppPurchaseCompletion(perform:)

Adds an action to perform when a purchase the person initiates from within a
product view completes.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func onInAppPurchaseCompletion(perform action: ((Product, Result<Product.PurchaseResult, any Error>) async -> ())?) -> some View

##  Parameters

`action`

    

A closure that defines action to perform, including the product value and the
purchase result as parameters.

## Discussion

By default, `updates` in `Transaction` emits transactions from successful in-
app store view purchases. If the purchase fails with an error, the system
displays an alert. You can revert a view to this behavior by setting the
`action` parameter to `nil`.

Each purchase performs only one action. Descendant views can override the
action by using another `onInAppPurchaseCompletion(perform:)` modifier.

## See Also

### Responding to store events

`func inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) ->
View`

Adds a function the system calls before it processes a purchase from a product
view, which provides a set of purchase options.

`func onInAppPurchaseStart(perform: ((Product) -> ())?) -> View`

Adds an action to perform when a person uses the purchase button for a product
within the view.

`enum EntitlementTaskState`

The state of an entitlement task.

Instance Method

# productViewStyle(_:)

Sets the style for in-app purchase product views within a view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    func productViewStyle(_ style: some ProductViewStyle) -> some View

##  Parameters

`style`

    

The style to apply to the in-app purchase product views within the view.

## Discussion

This modifier styles any `ProductView` or `StoreView` instances within a view.

Instance Property

# body

The content and behavior of the view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    @MainActor
    var body: some View { get }

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing a product view

`typealias ProductView.Body`

The type of view that represents the body of the product view.

Type Alias

# ProductView.Body

The type of view that represents the body of the product view.

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.0+
tvOS 17.0+  watchOS 10.0+  visionOS 1.0+  Xcode 15.0+

    
    
    typealias ProductView<Icon, PlaceholderIcon>.Body = some View

## Relationships

### From Protocol

  * `View`

## See Also

### Implementing a product view

`var body: View`

The content and behavior of the view.

Instance Method

# productDescription(_:)

StoreKit  SwiftUI  iOS 17.0+  iPadOS 17.0+  macOS 14.0+  Mac Catalyst 17.4+
tvOS 17.0+  watchOS 10.0+  visionOS 1.1+  Xcode 15.0+

    
    
    func productDescription(_ visibility: Visibility) -> some View

Instance Method

# searchPresentationToolbarBehavior(_:)

StoreKit  SwiftUI  iOS 17.1+  iPadOS 17.1+  macOS 14.1+  Mac Catalyst 17.2+
tvOS 17.1+  watchOS 10.1+  visionOS 1.0+  Xcode 14.4+

    
    
    func searchPresentationToolbarBehavior(_ behavior: SearchPresentationToolbarBehavior) -> some View

Instance Method

# subscriptionPromotionalOffer(offer:signature:)

StoreKit  SwiftUI  iOS 17.4+  iPadOS 17.4+  macOS 14.4+  Mac Catalyst 17.4+
tvOS 17.4+  watchOS 10.4+  visionOS 1.1+  Xcode 15.3+

    
    
    func subscriptionPromotionalOffer(
        offer: @escaping (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?,
        signature: @escaping (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) async throws -> Product.SubscriptionOffer.Signature
    ) -> some View



# SKProductsResponse

Instance Property

# products

A list of products, one product for each valid product identifier provided in
the original request.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var products: [SKProduct] { get }

## Discussion

The array consists of a list of `SKProduct` objects.

## See Also

### Response Information

`var invalidProductIdentifiers: [String]`

An array of product identifier strings that the App Store doesn’t recognize.

### Related Documentation

In-App Purchase Programming Guide

Instance Property

# invalidProductIdentifiers

An array of product identifier strings that the App Store doesn’t recognize.

iOS 3.0+  iPadOS 3.0+  macOS 10.7+  Mac Catalyst 13.1+  tvOS 9.0+  watchOS
6.2+  visionOS 1.0+

    
    
    var invalidProductIdentifiers: [String] { get }

## Discussion

The App Store may not recognize your product identifiers unless you meet
following criteria, as applicable:

  * Agree to the latest Apple Developer Program License Agreement.

  * Complete all the financial agreements as described in the Agreements, Tax, and Banking Overview. When you renew your developer membership, see if you need to make updates to your agreements. When your developer membership expires, your financial agreements expire as well.

  * Your app uses an explicit App ID.

  * Clear the in-app purchases for sale in App Store Connect. See Set availability for in-app purchase.

  * Modified in-app purchases are available to the App Store servers.

  * The product identifier specified in App Store Connect matches the identifier used by the `SKProductsRequest` object in your app. 

  * Upload the content of your product to App Store Connect. See Upload in-app purchase content to App Store Connect.

For more troubleshooting information, see Fetching product information from
the App Store.

## See Also

### Response Information

`var products: [SKProduct]`

A list of products, one product for each valid product identifier provided in
the original request.



# SKAdImpression

Instance Property

# signature

The advertising network’s cryptographic signature for the ad impression.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var signature: String { get set }

## Discussion

The ad network creates a cryptographic signature that it uses to sign ads. For
instructions on generating this value, see Generating the signature to
validate view-through ads.

Initializer

#
init(sourceAppStoreItemIdentifier:advertisedAppStoreItemIdentifier:adNetworkIdentifier:adCampaignIdentifier:adImpressionIdentifier:timestamp:signature:version:)

Creates an ad impression object using the supplied values.

iOS 16.0+  iPadOS 16.0+

    
    
    init(
        sourceAppStoreItemIdentifier: NSNumber,
        advertisedAppStoreItemIdentifier: NSNumber,
        adNetworkIdentifier: String,
        adCampaignIdentifier: NSNumber,
        adImpressionIdentifier: String,
        timestamp: NSNumber,
        signature: String,
        version: String
    )

## See Also

### Creating a signature

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# version

The version of the SKAdNetwork API.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var version: String { get set }

## Discussion

Set this instance property to the SKAdNetwork version you’re using to sign the
view-through ad impression. View-through ads are available starting in version
2.2. For more information about versions and availability, see SKAdNetwork
release notes.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# adNetworkIdentifier

A string that represents the advertising network’s unique identifier.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adNetworkIdentifier: String { get set }

## Discussion

Set this property to your ad network ID.

Ad networks obtain an ad network identifier during registration. Ad networks
must share their ad network identifiers with participating app developers.
Apps that display ads must include the ad network ID in their `Info.plist` to
initiate the app install validation process. For more information about
acquiring your ad network ID, see Registering an ad network.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# sourceIdentifier

A four-digit integer that ad networks define to represent the ad campaign.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+

    
    
    var sourceIdentifier: NSNumber { get set }

## Discussion

The `sourceIdentifier` key is available for ad impressions that use
SKAdNetwork 4 and later. The `sourceIdentifier`, also known as the
_hierarchical source identifier_ , replaces and extends the campaign
identifier value, `adCampaignIdentifier`.

Ad networks and developers define the meaning of the hierarchical source
identifier. This integer can have up to four digits. You can encode
information about your advertisement in each set of digits; you may receive
two, three, or all four digits of the `sourceIdentifier` in the first winning
postback, depending on the ad impression’s postback data tier. For more
information about the value you may get in the postback, see Receiving
postbacks in multiple conversion windows.

Note

An install-validation postback represents this integer as a string in its
`source-identifier` parameter. For more details about the parameters of an
install-validation postback, see Identifying the parameters in install-
validation postbacks.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# adCampaignIdentifier

A number that represents the advertising network’s campaign.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adCampaignIdentifier: NSNumber { get set }

## Discussion

Ad networks set their own campaign identifiers, which must be an integer `>=1`
and `<=100.`

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# advertisedAppStoreItemIdentifier

The App Store ID of the app that the ad impression advertises.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var advertisedAppStoreItemIdentifier: NSNumber { get set }

## Discussion

Set this property to the App Store item identifier of the app that you’re
advertising.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# adImpressionIdentifier

A random value to use for added security.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adImpressionIdentifier: String { get set }

## Discussion

Ad networks set the value of this property to a random value (nonce) at the
time of the ad impression.

Important

When you generate `signature`, which is the signature value, you must sign the
`adImpressionIdentifier` as an all-lowercase UUID string representation.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# sourceAppStoreItemIdentifier

The App Store ID of the app that displays the ad.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var sourceAppStoreItemIdentifier: NSNumber { get set }

## Discussion

Set this property to the App Store item identifier of the app that’s
displaying the ad.

If you’re using a development-signed build to display the ads and not an app
from App Store during testing, use `0` as the item identifier.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# timestamp

A number that represents the UNIX time, in milliseconds, of the ad impression.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var timestamp: NSNumber { get set }

## Discussion

Ad networks generate the timestamp, represented as UNIX time in milliseconds,
at the time you begin to serve the ad to users.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

Instance Property

# adType

The type of the ad.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adType: String? { get set }

## Discussion

This property is not used.

## See Also

### Describing ads

`var adDescription: String?`

A human-readable description of the ad.

`var adPurchaserName: String?`

The name of the entity that purchased the ad.

Instance Property

# adDescription

A human-readable description of the ad.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adDescription: String? { get set }

## Discussion

This property is not used.

## See Also

### Describing ads

`var adType: String?`

The type of the ad.

`var adPurchaserName: String?`

The name of the entity that purchased the ad.

Instance Property

# adPurchaserName

The name of the entity that purchased the ad.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adPurchaserName: String? { get set }

## Discussion

This property is not used.

## See Also

### Describing ads

`var adType: String?`

The type of the ad.

`var adDescription: String?`

A human-readable description of the ad.

Instance Property

# signature

The advertising network’s cryptographic signature for the ad impression.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var signature: String { get set }

## Discussion

The ad network creates a cryptographic signature that it uses to sign ads. For
instructions on generating this value, see Generating the signature to
validate view-through ads.

Initializer

#
init(sourceAppStoreItemIdentifier:advertisedAppStoreItemIdentifier:adNetworkIdentifier:adCampaignIdentifier:adImpressionIdentifier:timestamp:signature:version:)

Creates an ad impression object using the supplied values.

iOS 16.0+  iPadOS 16.0+

    
    
    init(
        sourceAppStoreItemIdentifier: NSNumber,
        advertisedAppStoreItemIdentifier: NSNumber,
        adNetworkIdentifier: String,
        adCampaignIdentifier: NSNumber,
        adImpressionIdentifier: String,
        timestamp: NSNumber,
        signature: String,
        version: String
    )

## See Also

### Creating a signature

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# version

The version of the SKAdNetwork API.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var version: String { get set }

## Discussion

Set this instance property to the SKAdNetwork version you’re using to sign the
view-through ad impression. View-through ads are available starting in version
2.2. For more information about versions and availability, see SKAdNetwork
release notes.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# adNetworkIdentifier

A string that represents the advertising network’s unique identifier.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adNetworkIdentifier: String { get set }

## Discussion

Set this property to your ad network ID.

Ad networks obtain an ad network identifier during registration. Ad networks
must share their ad network identifiers with participating app developers.
Apps that display ads must include the ad network ID in their `Info.plist` to
initiate the app install validation process. For more information about
acquiring your ad network ID, see Registering an ad network.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# sourceIdentifier

A four-digit integer that ad networks define to represent the ad campaign.

iOS 16.1+  iPadOS 16.1+  Mac Catalyst 16.1+

    
    
    var sourceIdentifier: NSNumber { get set }

## Discussion

The `sourceIdentifier` key is available for ad impressions that use
SKAdNetwork 4 and later. The `sourceIdentifier`, also known as the
_hierarchical source identifier_ , replaces and extends the campaign
identifier value, `adCampaignIdentifier`.

Ad networks and developers define the meaning of the hierarchical source
identifier. This integer can have up to four digits. You can encode
information about your advertisement in each set of digits; you may receive
two, three, or all four digits of the `sourceIdentifier` in the first winning
postback, depending on the ad impression’s postback data tier. For more
information about the value you may get in the postback, see Receiving
postbacks in multiple conversion windows.

Note

An install-validation postback represents this integer as a string in its
`source-identifier` parameter. For more details about the parameters of an
install-validation postback, see Identifying the parameters in install-
validation postbacks.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# adCampaignIdentifier

A number that represents the advertising network’s campaign.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adCampaignIdentifier: NSNumber { get set }

## Discussion

Ad networks set their own campaign identifiers, which must be an integer `>=1`
and `<=100.`

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# advertisedAppStoreItemIdentifier

The App Store ID of the app that the ad impression advertises.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var advertisedAppStoreItemIdentifier: NSNumber { get set }

## Discussion

Set this property to the App Store item identifier of the app that you’re
advertising.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# adImpressionIdentifier

A random value to use for added security.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adImpressionIdentifier: String { get set }

## Discussion

Ad networks set the value of this property to a random value (nonce) at the
time of the ad impression.

Important

When you generate `signature`, which is the signature value, you must sign the
`adImpressionIdentifier` as an all-lowercase UUID string representation.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# sourceAppStoreItemIdentifier

The App Store ID of the app that displays the ad.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var sourceAppStoreItemIdentifier: NSNumber { get set }

## Discussion

Set this property to the App Store item identifier of the app that’s
displaying the ad.

If you’re using a development-signed build to display the ads and not an app
from App Store during testing, use `0` as the item identifier.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var timestamp: NSNumber`

A number that represents the UNIX time, in milliseconds, of the ad impression.

Instance Property

# timestamp

A number that represents the UNIX time, in milliseconds, of the ad impression.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var timestamp: NSNumber { get set }

## Discussion

Ad networks generate the timestamp, represented as UNIX time in milliseconds,
at the time you begin to serve the ad to users.

## See Also

### Creating a signature

`init(sourceAppStoreItemIdentifier: NSNumber,
advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String,
adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp:
NSNumber, signature: String, version: String)`

Creates an ad impression object using the supplied values.

`var version: String`

The version of the SKAdNetwork API.

`var adNetworkIdentifier: String`

A string that represents the advertising network’s unique identifier.

`var sourceIdentifier: NSNumber`

A four-digit integer that ad networks define to represent the ad campaign.

`var adCampaignIdentifier: NSNumber`

A number that represents the advertising network’s campaign.

`var advertisedAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that the ad impression advertises.

`var adImpressionIdentifier: String`

A random value to use for added security.

`var sourceAppStoreItemIdentifier: NSNumber`

The App Store ID of the app that displays the ad.

Instance Property

# adType

The type of the ad.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adType: String? { get set }

## Discussion

This property is not used.

## See Also

### Describing ads

`var adDescription: String?`

A human-readable description of the ad.

`var adPurchaserName: String?`

The name of the entity that purchased the ad.

Instance Property

# adDescription

A human-readable description of the ad.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adDescription: String? { get set }

## Discussion

This property is not used.

## See Also

### Describing ads

`var adType: String?`

The type of the ad.

`var adPurchaserName: String?`

The name of the entity that purchased the ad.

Instance Property

# adPurchaserName

The name of the entity that purchased the ad.

iOS 14.5+  iPadOS 14.5+  Mac Catalyst 14.5+

    
    
    var adPurchaserName: String? { get set }

## Discussion

This property is not used.

## See Also

### Describing ads

`var adType: String?`

The type of the ad.

`var adDescription: String?`

A human-readable description of the ad.



