# Building widgets in SwiftUI

##  Building widgets in SwiftUI

09 Sep 2020

This week I want to talk to you about home-screen widgets in iOS 14. I’ve
built several widget collections for my apps, and it is a perfect time to
share with you that experience. Today we will learn all about building and
updating widgets with SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Widgets display relevant, glanceable content, letting users quickly get to
your app for more details. Your app can provide multiple kinds of widgets,
allowing users to focus on essential information. They can add multiple copies
of the same widget, tailoring each one to their unique needs and layout. I
think it is an excellent definition for widgets, thanks to Apple.

Let’s start by adding a widget extension to your app using the Xcode menu:
_File - > New -> Target -> Widget Extension _ . Xcode creates a widget from
the template. It might look like this.

    
    
    @main
    struct MyWidget: Widget {
        let kind: String = "Widget"
    
        var body: some WidgetConfiguration {
            StaticConfiguration(kind: kind, provider: Provider()) { entry in
                WidgetEntryView(entry: entry)
            }
            .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
            .configurationDisplayName("My Widget")
            .description("This is an example widget.")
        }
    }
    

As you can see, we develop a widget by creating a struct that conforms to the
_Widget_ protocol. The only requirement of the _Widget_ protocol is body
property that should return an instance of _WidgetConfiguration_ . SwiftUI
provides us two structs that conform to _WidgetConfiguration_ :
_StaticConfiguration_ and _IntentConfiguration_ .

We can use _IntentConfiguration_ to provide user-configurable options for our
widget. In this post, we will talk about _StaticConfiguration_ .
_StaticConfiguration_ allows us to register a widget configured by the
developer that time-to-time updates its data.

_StaticConfiguration_ needs three parameters. Let’s take a look at them one-
by-one.

  1. Kind is a string that identifies the type of widget. Your app might have multiple widgets. In this case, a kind identifier allows you to update widgets of a particular kind. 
  2. The provider is a type conforming to _Provider_ protocol and used by the system to fetch widget data. 
  3. View builder closure that describes the SwiftUI view for displaying widget data. 

You can also attach a few modifiers to your widget configuration for setting
supported widget families or providing description and name.

> To learn more about _@main_ and new App lifecycle in SwiftUI, take a look at
> my [ “Managing app in SwiftUI”
> ](https://swiftwithmajid.com/2020/08/19/managing-app-in-swiftui/) post.

####  Provider

The system will call your provider to fetch new data. Let’s look at the
provider example that I use in my [ CardioBot
](https://cardiobot.swiftwithmajid.com) app to display daily heart points.

    
    
    final class HeartPointsProvider: TimelineProvider {
        public typealias Entry = HeartPointsViewModel
    
        let service = HealthService()
        var snapshotCancellable: AnyCancellable?
        var timelineCancellable: AnyCancellable?
    
        private var entryPublisher: AnyPublisher<Entry, Never> { /*.... */ }
    
        func placeholder(in with: Context) -> HeartPointsViewModel {
            HeartPointsViewModel(
                heartRates: [HeartRate(bpm: 130)],
                age: 29,
                goal: 20
            )
        }
    
        func getSnapshot(in context: Context, completion: @escaping (HeartPointsViewModel) -> Void) {
            snapshotCancellable = entryPublisher
                .receive(on: DispatchQueue.main)
                .sink(receiveValue: completion)
        }
    
        func getTimeline(in context: Context, completion: @escaping (Timeline<HeartPointsViewModel>) -> Void) {
            timelineCancellable = entryPublisher
                .map { Timeline(entries: [$0], policy: .atEnd) }
                .receive(on: DispatchQueue.main)
                .sink(receiveValue: completion)
        }
    }
    

We start by defining type alias for the associated type of _Provider_
protocol. _Provider_ protocol uses the _Entry_ type to describe an item that
should be displayed in the widget. Entry must conform to the _TimelineEntry_
protocol that requires only date property.

    
    
    extension HeartPointsViewModel: TimelineEntry {
        var date: Date {
            heartRates.last?.interval.end ?? Date()
        }
    }
    

There are three required functions in the protocol:

  1. _placeholder_ function is used by the system to generate a template view in the widget gallery. You can provide mock data here that will look nice in the gallery. 
  2. _getSnapshot_ function is used when the widget is in a transient state. Call the completion handler as soon as possible to provide data for your widget. 
  3. _getTimeline_ function is used by the system to fetch current and future entries for your widget. 

_getTimeline_ is the most exciting function here. It allows us to return a
timeline of entries for our widget and define a date for the next update.

####  Widget view

Usually, we create a SwiftUI view that accepts an entry and displays it. Then
we can easily use it inside a view builder closure in widget configuration. We
can use _widgetFamily_ environment value to understand the current widget
configuration’s size and present different views.

    
    
    struct HeartPointsEntryView: View {
        @Environment(\.widgetFamily) var size
        let entry: HeartPointsViewModel
    
        var body: some View {
            switch size {
            case .systemSmall:
                SmallWidgetEntryView(viewModel: entry).padding()
            case .systemMedium:
                HStack(alignment: .bottom) {
                    SmallWidgetEntryView(viewModel: entry)
                    HeartPointsChartView(viewModel: entry, labelCount: 6)
                }.padding()
            case .systemLarge:
                VStack(alignment: .leading) {
                    HeartPointsView(viewModel: entry, showLabel: false)
                    HeartPointsChartView(viewModel: entry)
                }.padding()
            @unknown default:
                SmallWidgetEntryView(viewModel: entry).padding()
            }
        }
    }
    

####  Widget updates

The system will try to predict the best time to perform widget updates using
providers. But you can always ask to update your widgets using _WidgetCenter_
.

    
    
    WidgetCenter.shared.reloadAllTimelines()
    WidgetCenter.shared.reloadTimelines(ofKind: "heartRateWidget")
    

As you can see, there are two options for updating your widgets. You can
update all of your widgets or update only the particular kind.

####  Widget bundle

As we know, your app might have more than one widget. In this case, we have to
create a widget bundle.

    
    
    @main
    struct CardioBotWidgets: WidgetBundle {
        var body: some Widget {
            HeartPointsWidget()
            HeartRateSummaryWidget()
        }
    }
    

Remember to remove _@main_ from your widget definitions and add it only to
your widget bundle.

> To learn about building lock screen widgets take a look at my dedicated [
> “Lock screen widgets in SwiftUI” ](/2022/08/30/lock-screen-widgets-in-
> swiftui/) post.

####  Conclusion

Today we learned about another feature that is released during WWDC20.
Remember that widgets are available on macOS in the notification center also.
I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Where Swift Concurrency will run your function?

##  Where Swift Concurrency will run your function?

20 Mar 2024

Apple released Swift 5.5 almost three years ago. The main addition to the
release was the Swift Concurrency feature. It introduced **async** and
**await** keywords, allowing us to build concurrent apps in a new way. This
week, we will learn how Swift determines where to run your function in a
concurrent environment.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

First, let’s look at creating an async function in Swift. To do so, you simply
need to add the **async** keyword to the function’s definition.

    
    
    func foo() async {
        // ...
    }
    

The _async_ keyword in the function’s definition means that the function may
suspend its execution to switch threads. To run an async function, you have to
use the **await** keyword.

    
    
    await foo()
    

The **await** keyword allows the calling thread to wait while an async
function performs its job. When the async function finishes, the calling
thread resumes where it is suspended.

The Swift language introduces the Cooperative Thread Pool, which allows you to
run concurrent parts of your apps. The number of threads in the pool is
limited to your CPU’s cores, which prevents thread explosion.

So, we have two crucial places where Swift can run our code: Main Thread and
Cooperative Thread Pool. We should use the main thread to update the UI of our
apps and we should avoid blocking it by running heavy work on it. That’s why
we have the Cooperative Thread Pool to run heavy jobs.

The next step is always to be sure where the Swift language will run your
code. The Swift language uses a few rules to determine where to run your code.

If your function is isolated to an actor, it will run as part of that actor.
It doesn’t matter if it is an async function or not. Actors always run on the
Cooperative Thread Pool, and all their functions are isolated. You can also
isolate any type or function you need using global actors.

> To learn more about global actors, take a look at my [ “Global actors in
> Swift” ](https://swiftwithmajid.com/2024/03/12/global-actors-in-swift/)
> post.

Swift applies the second rule if your function isn’t isolated to an actor. The
Swift language runs your function on the Cooperative Thread Pool whenever your
function is async. On the other hand, non-async functions run as part of the
calling thread, which means they don’t switch threads and will run where you
call them.

Let’s dive into some examples.

    
    
    @MainActor final class Store {
        var messages: [String] = []
        
        func boo() {
            messages = ["boo"]
        }
        
        
        func foo() async {
            messages = ["foo"]
        }
    }
    

As you can see in the example above, we have an actor-isolated _Store_ type.
It doesn’t matter where you call _foo_ or _boo_ functions. They will always
run on the main thread because the _Store_ type is isolated to the global
_@MainActor_ .

    
    
    struct ContentView: View {
        var body: some View {
            Text("Hello")
                .task {
                    // runs on the main thread
                    boo()
                }
                .task {
                    // runs on the cooperative thread pool
                    await foo()
                }
        }
        
        func boo() {
            // ...
        }
        
        func foo() async {
            // ...
        }
    }
    

Here, we have a more complex example confusing many developers in our
community. You should remember that SwiftUI views are not isolated to any
actor. Only the _body_ property of the _View_ protocol is isolated to the main
actor.

So, we have two non-isolated functions here. The _foo_ function is async, and
Swift runs it in the cooperative thread pool. The _boo_ function is not async,
and Swift will run it on the calling thread. As I said before, the _body_
property of the _View_ protocol is isolated to the main actor, which means in
this particular example _boo_ function will run on the main thread, where you
should avoid doing heavy work.

    
    
    struct ContentView: View {
        var body: some View {
            content
        }
        
        private var content: some View {
            Text("Hello")
                .task {
                    boo()
                }
                .task {
                    await foo()
                }
        }
        
        func boo() {
            // ...
        }
        
        func foo() async {
            // ...
        }
    }
    

I’ve slightly changed the example by introducing the _content_ property on the
_ContentView_ type. The _content_ property isn’t isolated to the main actor,
so both functions will run on the cooperative thread pool.

I hope this post will make running async functions less confusing. Feel free
to follow me on Twitter and ask your questions related to this post. Thanks
for reading, and see you next week!



# PhotosPicker in SwiftUI

##  PhotosPicker in SwiftUI

25 Apr 2023

Nowadays, many frameworks Xcode provides us contain SwiftUI views, including
the PhotosUI framework. The PhotosUI framework provides the _PhotosPicker_
button, allowing us to offer photo-picking functionality in our apps quickly.
This week we will learn how to use the _PhotosPicker_ view in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The _PhotosPicker_ view is a simple SwiftUI button handling the photo-picking
experience for us for free. It is straightforward to use and provides a nice
API. Let’s take a look at a simple example.

    
    
    struct ContentView: View {
        @State private var selectedPhoto: PhotosPickerItem?
        @State private var image: Image?
        
        var body: some View {
            NavigationStack {
                ZStack {
                    image?
                        .resizable()
                        .scaledToFit()
                }
                .toolbar {
                    PhotosPicker(selection: $selectedPhoto) {
                        Image(systemName: "pencil")
                    }
                }
            }
        }
    }
    

First, we must import the PhotosUI framework to use the _PhotosPicker_ view.
As you can see in the example above, we use an instance of the _PhotosPicker_
view in the toolbar. The _PhotosPicker_ button has only one required
parameter: the selection binding. It should be binding to the
_PhotosPickerItem_ type.

    
    
    struct ContentView: View {
        @State private var selectedPhoto: PhotosPickerItem?
        @State private var image: Image?
        
        var body: some View {
            NavigationStack {
                ZStack {
                    image?
                        .resizable()
                        .scaledToFit()
                }
                .toolbar {
                    PhotosPicker(
                        selection: $selectedPhoto,
                        matching: .images
                    ) {
                        Image(systemName: "pencil")
                    }
                }
            }
        }
    }
    

We can also limit the type of the photos user allowed to pick by using the
_matching_ parameter, an instance of the _PHPickerFilter_ type. The
_PHPickerFilter_ provides predefined filters like images, screenshots, live
photos, etc. You can also combine filters by using _any_ , _all_ , and _not_
functions.

    
    
    struct ContentView: View {
        @State private var selectedPhoto: PhotosPickerItem?
        @State private var image: Image?
        
        var body: some View {
            NavigationStack {
                ZStack {
                    image?
                        .resizable()
                        .scaledToFit()
                }
                .toolbar {
                    PhotosPicker(
                        selection: $selectedPhoto,
                        matching: .all(of: [.screenshots, .panoramas])
                    ) {
                        Image(systemName: "pencil")
                    }
                }
            }
        }
    }
    

Remember, you can pick not only images but also video content by using the
_PhotosPicker_ view.

    
    
    struct ContentView: View {
        @State private var selectedPhoto: PhotosPickerItem?
        @State private var image: Image?
        
        var body: some View {
            NavigationStack {
                ZStack {
                    image?
                        .resizable()
                        .scaledToFit()
                }
                .toolbar {
                    PhotosPicker(
                        selection: $selectedPhoto,
                        matching: .videos
                    ) {
                        Image(systemName: "pencil")
                    }
                }
            }
        }
    }
    

You can also provide a binding to an array of the _PhotosPickerItem_ type to
enable multiple selections. In this case, you can use the _maxSelectionCount_
parameter to control the maximal number of allowed items.

    
    
    struct ContentView: View {
        @State private var selectedPhotos: [PhotosPickerItem] = []
        @State private var image: Image?
        
        var body: some View {
            NavigationStack {
                ZStack {
                    image?
                        .resizable()
                        .scaledToFit()
                }
                .toolbar {
                    PhotosPicker(selection: $selectedPhoto, maxSelectionCount: 3) {
                        Image(systemName: "pencil")
                    }
                }
            }
        }
    }
    

OK, we know how to provide a photo-picking experience, but what next? How can
we load the selected images? The _PhotosPickerItem_ type contains the whole
image and video loading logic. It provides the _loadTransferable_ function
allowing us to load any type conforming to the _Transferable_ protocol.

> To learn more about the basics of the _Transferable_ protocol, take a look
> at my [ “Sharing content in SwiftUI” ](/2023/03/28/sharing-content-in-
> swiftui/) post.
    
    
    struct ContentView: View {
        @State private var selectedPhoto: PhotosPickerItem?
        @State private var image: Image?
        
        var body: some View {
            NavigationStack {
                ZStack {
                    image?
                        .resizable()
                        .scaledToFit()
                }
                .toolbar {
                    PhotosPicker(
                        selection: $selectedPhoto,
                        matching: .all(of: [.screenshots, .panoramas])
                    ) {
                        Image(systemName: "pencil")
                    }
                }
                .task(id: selectedPhoto) {
                    image = try? await selectedPhoto?.loadTransferable(type: Image.self)
                }
            }
        }
    }
    

As you can see in the example above, we use the _loadTransferable_ function to
decode the image by using the new Swift Concurrency feature. The
_PhotosPickerItem_ type also provides a callback-based alternative if you
don’t use Swift Concurrency feature.

    
    
    struct ContentView: View {
        @State private var selectedPhoto: PhotosPickerItem?
        @State private var image: Image?
        
        var body: some View {
            NavigationStack {
                ZStack {
                    image?
                        .resizable()
                        .scaledToFit()
                }
                .toolbar {
                    PhotosPicker(
                        selection: $selectedPhoto,
                        matching: .all(of: [.screenshots, .panoramas])
                    ) {
                        Image(systemName: "pencil")
                    }
                }
                .task(id: selectedPhoto) {
                    if selectedPhoto?.supportedContentTypes.first == .image {
                        image = try? await selectedPhoto?.loadTransferable(type: Image.self)
                    }
                }
            }
        }
    }
    

The _PhotosPickerItem_ type also has the _supportedContentTypes_ property
defining the supported content type of the selected image or video item,
allowing us to understand how to decode the item.

Today we learned how to use the _PhotosPicker_ view in SwiftUI to implement
the image-picking functionality in our app. I enjoy the API it provides and
believe it is an excellent example of SwiftUI and Swift Concurrency feature
usage. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# What is new in SwiftUI after WWDC22

##  What is new in SwiftUI after WWDC22

07 Jun 2022

WWDC22 brings tons of new features to SwiftUI and makes it a full-featured UI
framework that we can use daily. Unfortunately, most of the new features are
available on iOS 16 and macOS 13. This post will cover the most significant
additions and changes to the SwiftUI framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Navigation

SwiftUI 4 provides a new way to build programmatic navigation with deep
linking quickly. The old _NavigationView_ is deprecated now, and we should use
the new _NavigationStack_ instead. Here is a quick example of how we can use
it.

    
    
    struct ContentView: View {
        @State private var path: [User] = []
        @State private var users: [User] = [
            .init(name: "Majid")
        ]
    
        var body: some View {
            NavigationStack(path: $path) {
                List {
                    ForEach(users) { user in
                        NavigationLink(user.name, value: user)
                    }
    
                }
                .navigationTitle("Users")
                .navigationDestination(for: User.self) { user in
                    UserView(user: user)
                        .navigationTitle(user.name)
                }
            }
        }
    }
    

We use the new version of _NavigationLink_ type, allowing us to bind a link to
a value. Then we can use the _navigationDestination_ view modifier to provide
a destination view for a particular value.

I love the new Navigation API and the ability to manipulate the navigation
stack completely programmatically using the type-safe API. We can implement
deep linking easily now.

    
    
    struct ContentView: View {
        @State private var path: [User] = []
        @State private var users: [User] = [
            .init(name: "Majid")
        ]
    
        var body: some View {
            NavigationStack(path: $path) {
                List {
                    ForEach(users) { user in
                        NavigationLink(user.name, value: user)
                    }
    
                }
                .navigationTitle("Users")
                .navigationDestination(for: User.self) { user in
                    UserView(user: user)
                        .navigationTitle(user.name)
                }
            }
            .onAppear {
                path.append(
                    contentsOf: [
                        .init(name: "John"),
                        .init(name: "Majid")
                    ]
                )
            }
        }
    }
    

Here we use another version of the _NavigationStack_ view’s initializer to
bind its navigation stack to an array of values. It allows us to add and
remove views in the navigation stack programmatically.

####  Layout

This year another great addition to SwiftUI is the _Layout_ protocol that
allows us to build super-custom container types. You can create a flow layout
or a container size that fits the children equally. All you need is to create
a type conforming to the _Layout_ protocol and make your calculations there.

    
    
    struct EqualWidthHStack: Layout {
        func sizeThatFits(
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout ()
        ) -> CGSize {
            let maxSize = maxSize(subviews: subviews)
            let spacings = spacings(subviews: subviews)
            let totalSpacing = spacings.reduce(0.0, +)
            
            return CGSize(
                width: maxSize.width * CGFloat(subviews.count) + totalSpacing,
                height: maxSize.height
            )
        }
        
        func placeSubviews(
            in bounds: CGRect,
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout ()
        ) {
            let maxSize = maxSize(subviews: subviews)
            let spacing = spacings(subviews: subviews)
            
            let size = ProposedViewSize(
                width: maxSize.width,
                height: maxSize.height
            )
            var x = bounds.minX + maxSize.width / 2
            
            for index in subviews.indices {
                subviews[index].place(
                    at: CGPoint(x: x, y: bounds.midY),
                    anchor: .center,
                    proposal: size
                )
                x += maxSize.width + spacing[index]
            }
        }
        
        private func spacings(subviews: Subviews) -> [CGFloat] {
            let spacing: [CGFloat] = subviews.indices.map { index in
                guard index < subviews.count - 1 else {
                    return 0.0
                }
                
                return subviews[index].spacing.distance(
                    to: subviews[index + 1].spacing,
                    along: .horizontal
                )
            }
            return spacing
        }
        
        private func maxSize(subviews: Subviews) -> CGSize {
            let subviewSizes = subviews.map { $0.sizeThatFits(.unspecified) }
            let maxSize: CGSize = subviewSizes.reduce(.zero) { current, size in
                CGSize(
                    width: max(current.width, size.width),
                    height: max(current.height, size.height)
                )
            }
            return maxSize
        }
    }
    

Here we have a layout type that finds the biggest child and places the items
equally to the biggest one with the defined spacing.

    
    
    struct ContentView: View {
        var body: some View {
            EqualWidthHStack {
                Text("Hello...")
                    .foregroundColor(.red)
                Text("Hello.........")
                    .foregroundColor(.green)
                Text("Hello..............")
                    .foregroundColor(.blue)
            }
        }
    }
    

####  Swift Charts

SwiftUI provides us with a robust charting framework supporting accessibility
and localization out of the box. It supports different types of charts that
you can mix and combine using declarative syntax.

    
    
    import Charts
    
    struct Item: Identifiable {
        let id = UUID()
        let index: Int
        let value: Double
    }
    
    struct ContentView: View {
        @State private var items: [Item] = [
            .init(index: 0, value: 1),
            .init(index: 1, value: 5),
            .init(index: 2, value: 0),
            .init(index: 3, value: 7),
            .init(index: 4, value: 4)
        ]
        
        var body: some View {
            Chart(items) { item in
                LineMark(
                    x: .value("Index", item.index),
                    y: .value("Value", item.value)
                )
    
                BarMark(
                    x: .value("Index", item.index),
                    yStart: .value("Start", 0),
                    yEnd: .value("End", item.value)
                )
                .foregroundStyle(by: .value("Value", item.value))
            }
        }
    }
    

####  Bottom Sheet

The new _presentationDetents_ view modifier allows us to present sheet as a
bottom sheet and control its size.

    
    
    struct ContentView: View {
        @State private var showSettings = false
    
        var body: some View {
            Button("View Settings") {
                showSettings = true
            }
            .sheet(isPresented: $showSettings) {
                Text("Settings")
                    .presentationDetents([.medium, .large])
            }
        }
    }
    

By default, it uses the large appearance, but we allow the user to drag the
bottom sheet by adding the medium one.

####  ViewThatFits

There is a new type of view called _ViewThatFits_ . It allows you to place the
first or the second provided view depending on the size that fits.

    
    
    ViewThatFits(in: .horizontal) {
        HStack {
            Image(systemName: "star")
            Text("Long text here")
        }
                
        VStack {
            Image(systemName: "star")
            Text("Long text here")
        }
    }
    

####  Many small additions

Today we had a massive update for SwiftUI. There are also many small things
like _Transferable_ protocol allowing you to share or drag and drop items in
your apps. The new _Grid_ view allows you to place views in a simple grid. We
also have the new single window and menu bar extra scenes with environment
values for manipulating windows.

####  Conclusion

I will try to cover all the new features in the dedicated posts over the
following weeks. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Storing Codable structs on the disk

##  Storing Codable structs on the disk

22 May 2019

Most of our apps are REST clients for some backends. During the development of
this kind of apps, we want to keep it working offline. In this case, we have
to cache data somewhere locally on the device to make it readable without an
internet connection.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Apple provides a CoreData framework, which is the best way to store your app
data locally. It has a lot of excellent features which help you to boost
development. However, it is tough to use it as a simple cache. Most of the
time, we just need to display cached data without any additional
manipulations. In my opinion, all we need is pure disk storage. This week we
will discuss how easily we can implement straightforward disk store for our
Codable structs.

Let’s start with defining a couple of protocols for our storage logic. I want
to separate access to writable and readable parts of the storage, and this is
where we can use protocol composition feature of Swift language.

    
    
    import Foundation
    
    typealias Handler<T> = (Result<T, Error>) -> Void
    
    protocol ReadableStorage {
        func fetchValue(for key: String) throws -> Data
        func fetchValue(for key: String, handler: @escaping Handler<Data>)
    }
    
    protocol WritableStorage {
        func save(value: Data, for key: String) throws
        func save(value: Data, for key: String, handler: @escaping Handler<Data>)
    }
    
    typealias Storage = ReadableStorage & WritableStorage
    

Here we have two protocols describing reading and writing operations on
storage. Protocols also provide an asynchronous version for reading and
writing actions with completion handlers. We also create typealias Storage,
which is a composition of two protocols. Now we can start to work on
DiskStorage class which implements our Storage protocols.

    
    
    enum StorageError: Error {
        case notFound
        case cantWrite(Error)
    }
    
    class DiskStorage {
        private let queue: DispatchQueue
        private let fileManager: FileManager
        private let path: URL
    
        init(
            path: URL,
            queue: DispatchQueue = .init(label: "DiskCache.Queue"),
            fileManager: FileManager = FileManager.default
        ) {
            self.path = path
            self.queue = queue
            self.fileManager = fileManager
        }
    }
    

First of all, let’s describe some variables for root path of our storage,
DispatchQueue for asynchronous work and FileManager, which we will use to
navigate through the file system.

    
    
    extension DiskStorage: WritableStorage {
        func save(value: Data, for key: String) throws {
            let url = path.appendingPathComponent(key)
            do {
                try self.createFolders(in: url)
                try value.write(to: url, options: .atomic)
            } catch {
                throw StorageError.cantWrite(error)
            }
        }
    
        func save(value: Data, for key: String, handler: @escaping Handler<Data>) {
            queue.async {
                do {
                    try self.save(value: value, for: key)
                    handler(.success(value))
                } catch {
                    handler(.failure(error))
                }
            }
        }
    }
    
    extension DiskStorage {
        private func createFolders(in url: URL) throws {
            let folderUrl = url.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: folderUrl.path) {
                try fileManager.createDirectory(
                    at: folderUrl,
                    withIntermediateDirectories: true,
                    attributes: nil
                )
            }
        }
    }
    

Next step is the implementation of the writable part of our storage. It is a
little bit tricky because the key is a path to our data on the file system.
That’s why we need append the key to our root path and generate new URL for
the storing data. New URL can contain subfolders, that’s why we create a
createFolders function which creates needed folders according to the path.

    
    
    extension DiskStorage: ReadableStorage {
        func fetchValue(for key: String) throws -> Data {
            let url = path.appendingPathComponent(key)
            guard let data = fileManager.contents(atPath: url.path) else {
                throw StorageError.notFound
            }
            return data
        }
    
        func fetchValue(for key: String, handler: @escaping Handler<Data>) {
            queue.async {
                handler(Result { try self.fetchValue(for: key) })
            }
        }
    }
    

Here is the readable part of our Storage protocol, where we implement data
fetching for a passed key. Again, we use the key as a path to our data on
disk. Now we have a working example of straightforward disk storage. Next step
is implementing a simple adapter for our DiskStorage class, which will handle
JSON coding/decoding.

    
    
    class CodableStorage {
        private let storage: DiskStorage
        private let decoder: JSONDecoder
        private let encoder: JSONEncoder
    
        init(
            storage: DiskStorage,
            decoder: JSONDecoder = .init(),
            encoder: JSONEncoder = .init()
        ) {
            self.storage = storage
            self.decoder = decoder
            self.encoder = encoder
        }
    
        func fetch<T: Decodable>(for key: String) throws -> T {
            let data = try storage.fetchValue(for: key)
            return try decoder.decode(T.self, from: data)
        }
    
        func save<T: Encodable>(_ value: T, for key: String) throws {
            let data = try encoder.encode(value)
            try storage.save(value: data, for: key)
        }
    }
    

CodableStorage class wraps our DiskStorage class to add JSON coding-decoding
logic. It uses generic constraints to understand how to decode and encode
data. It’s time to use our CodableStorage in real life sample.

    
    
    struct Timeline: Codable {
        let tweets: [String]
    }
    
    let path = URL(fileURLWithPath: NSTemporaryDirectory())
    let disk = DiskStorage(path: path)
    let storage = CodableStorage(storage: disk)
    
    let timeline = Timeline(tweets: ["Hello", "World", "!!!"])
    try storage.save(timeline, for: "timeline")
    let cached: Timeline = try storage.fetch(for: "timeline")
    

In the code sample above, you can see the usage of CodableStorage class. We
create DiskCache class instance which uses a temporary folder to store data.
Timeline is a simple codable struct representing an array of strings which we
store in our CodableStorage.

####  Conclusion

Today we discussed a simple way of storing Codable structs which we can fetch
via REST API. Sometimes we don’t need complicated features of CoreData for
simple JSON caching and it is enough to implement disk storage.

Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading and see you next week!



# GraphQL in Swift

##  GraphQL in Swift

24 Feb 2021

I spent last weeks sharing more about type-safety and building robust APIs in
Swift. I want to continue the type-safety topic by talking about GraphQL.
GraphQL is a query language for your API. This week we will talk about the
benefits of GraphQL, and we will learn how to utilize it in Swift.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let me introduce GraphQL first. GraphQL is a query language for your API.
Usually, a backend developer or web service should provide you a schema file
and a single GraphQL endpoint. Schema file contains all the types and queries
which you can make with the particular endpoint. Let’s take a look at the
example of the schema file.

    
    
    schema {
      query: Query
      mutation: Mutation
    }
    
    type Query {
      film(id: ID, filmID: ID): Film
      allFilms(after: String, first: Int, before: String, last: Int): FilmsConnection
      """more code here"""
    }
    

The schema file should contain _Query_ and _Mutation_ types. These types
define all the queries and mutations that the current GraphQL endpoint
supports. The schema file also describes the list of all the types that you
can use in your queries.

    
    
    type Film implements Node {
      title: String!
    
      episodeID: Int
    
      openingCrawl: String
    
      director: String!
    }
    

GraphQL is a strongly typed language. Every field defined inside a GraphQL
custom type must declare its type. By default, every field can contain nil as
a value. The fields having exclamation marks can’t be nil.

I use Star Wars API to show you examples in this post. Let’s continue by
making some queries. You can easily play with GraphQL API using the GraphiQL
app by using this [ endpoint ](https://swapi-
graphql.netlify.app/.netlify/functions/index) .

    
    
    query AllFilms {
      allFilms {
        films {
          title
        }
      }
    }
    
    """response:
    {
      "data": {
        "allFilms": {
          "films": [
            {
              "title": "A New Hope"
            },
            {
              "title": "The Empire Strikes Back"
            },
            {
              "title": "Return of the Jedi"
            },
            {
              "title": "The Phantom Menace"
            },
            {
              "title": "Attack of the Clones"
            },
            {
              "title": "Revenge of the Sith"
            }
          ]
        }
      }
    }
    """
    

As you can see, we use the data types from the schema file to build our query.
One thing that I love about GraphQL is the response format. Request format is
directly mapped to the response format. You can add more fields to your
request, and the response will have them also.

    
    
    query AllFilms {
      allFilms {
        films {
          title
          director
        }
      }
    }
    
    """response
    {
      "data": {
        "allFilms": {
          "films": [
            {
              "title": "A New Hope",
              "director": "George Lucas"
            },
            {
              "title": "The Empire Strikes Back",
              "director": "Irvin Kershner"
            },
            {
              "title": "Return of the Jedi",
              "director": "Richard Marquand"
            },
            {
              "title": "The Phantom Menace",
              "director": "George Lucas"
            },
            {
              "title": "Attack of the Clones",
              "director": "George Lucas"
            },
            {
              "title": "Revenge of the Sith",
              "director": "George Lucas"
            }
          ]
        }
      }
    }
    """
    

Using GraphQL we only get the data that we request. Nothing more.

####  ApolloGraphQL

ApolloGraphQL is a great framework that allows you easily make GraphQL queries
and mutations. ApolloGraphQL iOS framework takes care of caching and code
generation. ApolloGraphQL generates Swift types for queries and mutations that
you define in your project. It saves your time by generating all the
boilerplate for you automatically.

There are a few steps that you need to do to setup ApolloGraphQL in your
project:

  1. You should embed ApolloGraphQL into your project using SPM or another package manager. 
  2. Add [ run script ](https://gist.github.com/mecid/6b19cc006939855748604de16bf12eca) to your build phases above the compile sources section. This script downloads the schema and generates Swift types for your queries. You can easily change the GraphQL endpoint in this script to connect to your GraphQL backend. 

We have prepared the project to use ApolloGraphQL. Now we can add the first
query to our project. We should create a file in the project with the .graphql
extension and put these lines into the file.

    
    
    query AllFilms {
      allFilms {
        films {
          title
          director
        }
      }
    }
    

Let’s build the project now. ApolloGraphQL generates an API.swift file that
you should add to the project. There are all the needed types to make GraphQL
queries in a very type-safe way. Every request type defines its response type.
ApolloGraphQL generated _AllFilmsQuery_ and _Data_ types that describe the
request and response. Now we can use generated code to make GraphQL requests.

    
    
    let url = URL(string: "https://swapi-graphql.netlify.app/.netlify/functions/index")!
    let client = ApolloClient(url: url)
    
    client.fetch(query: AllFilmsQuery()) { result in
        switch result {
        case .success(let response):
            print(response.data?.allFilms?.films ?? [])
        case .failure(let error):
            print(error)
        }
    }
    

####  Conclusion

There are a lot of benefits of GraphQL over REST API. But remember, everything
comes with its own set of pros and cons. GraphQL is a great way to build an
efficient and type-safe backend for your app. I will try to cover more
advanced features of GraphQL in the next posts. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this article. Thanks for reading, and see you next week!



# ViewModifiers in SwiftUI

##  ViewModifiers in SwiftUI

07 Aug 2019

_ViewModifiers_ play a significant role in SwiftUI. Most of the functions
called on a _View_ are _ViewModifiers_ . It is the primary way of modifying
the view instance in SwiftUI. In this post, we will take a look at some ready
to use _ViewModifiers_ , and then we will build our own custom _ViewModifier_
.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Custom ViewModifier

Assume that we are working on Github repositories search app, and we need some
_View_ to display a single repository in the search results screen. Here we
go.

    
    
    struct RepoRow: View {
        let repo: Repo
    
        var body: some View {
            HStack(alignment: .top) {
                VStack(alignment: .leading) {
                    Text(repo.name)
                        .font(.headline)
                    Text(repo.description ?? "")
                        .foregroundColor(.secondary)
                        .font(.subheadline)
                }
            }
        }
    }
    

In the example above, we use _ViewModifiers_ like _foregroundColor_ and _font_
. I apply these two modifiers together very often to any subheadline text.
Let’s create custom ViewModifier which combines _foregroundColor_ and _font_
together.

    
    
    import SwiftUI
    
    struct SubheadlineModifier: ViewModifier {
        func body(content: Content) -> some View {
            content
                .foregroundColor(.secondary)
                .font(.subheadline)
        }
    }
    

We can create custom _ViewModifiers_ by creating a struct conforming to
_ViewModifier_ protocol. The single requirement of _ViewModifier_ protocol is
body function. It looks very similar to View protocol, but instead, it accepts
an original view as a function parameter and returns a modified view. Now,
let’s see how we can use newly created modifier in the code.

    
    
    import SwiftUI
    
    struct RepoRow: View {
        let repo: Repo
    
        var body: some View {
            HStack(alignment: .top) {
                VStack(alignment: .leading) {
                    Text(repo.name)
                        .font(.headline)
                    ModifiedContent(
                        content: Text(repo.description ?? ""),
                        modifier: SubheadlineModifier()
                    )
                }
            }
        }
    }
    

As you can see in the example, we use _SubheadlineModifier_ by creating
_ModifiedContent_ struct with original _View_ and _SubheadlineModifier_
instance as parameters.

####  ViewModifiers can have a @State like Views

Another interesting fact about _ViewModifiers_ is that it conforms to View
protocol. It means you can use inside _ViewModifiers_ property wrappers like
_@State, @Binding, @Environment, @ObservableObject and @EnvironmentObject_ .
To learn more about property wrappers provided by SwiftUI, take a look at [
“Understanding Property Wrappers in SwiftUI” ](/2019/06/12/understanding-
property-wrappers-in-swiftui/) .

Swift has a lot of great libraries for loading and caching remote images.
Let’s integrate one of them with SwiftUI. Most of my projects use _Kingfisher_
library for loading and caching remote images, but it doesn’t support SwiftUI
for now. We will try to integrate it by creating _ViewModifier_ which loads
remote images with _Kingfisher_ .

    
    
    import class Kingfisher.KingfisherManager
    import SwiftUI
    
    extension Image {
        func fetchingRemoteImage(from url: URL) -> some View {
            ModifiedContent(content: self, modifier: RemoteImageModifier(url: url))
        }
    }
    
    struct RemoteImageModifier: ViewModifier {
        let url: URL
        @State private var fetchedImage: UIImage? = nil
    
        func body(content: Content) -> some View {
            if let image = fetchedImage {
                return Image(uiImage: image)
                    .resizable()
                    .eraseToAnyView()
            }
    
            return content
                .onAppear(perform: fetch)
                .eraseToAnyView()
        }
    
        private func fetch() {
            KingfisherManager.shared.retrieveImage(with: url) { result in
                self.fetchedImage = try? result.get().image
            }
        }
    }
    
    extension View {
        func eraseToAnyView() -> AnyView {
            return AnyView(self)
        }
    }
    

As you can see in the example above, we use @ _State_ property wrapper inside
_RemoteImageModifier_ . It creates an opportunity to reload the _View_ as soon
as we set something to _fetchedImage_ property. We also create here some
utility methods to simplify the usage of new _RemoteImageModifier_ . Now we
can easily use new _ViewModifier_ with any _Image_ to load remote images.

    
    
    import SwiftUI
    
    struct RepoRow: View {
        let repo: Repo
    
        var body: some View {
            HStack(alignment: .top) {
                Image(systemName: "photo") // placeholder
                    .fetchingRemoteImage(from: repo.owner.avatar)
                    .frame(width: 44, height: 44)
                VStack(alignment: .leading) {
                    Text(repo.name)
                        .font(.headline)
                    Text(repo.description ?? "")
                        .font(.subheadline)
                }
            }
        }
    }
    

####  Conclusion

Today we talked about another key concept of SwiftUI. _ViewModifiers_ allow us
to encapsulate and reuse any logic across the _Views_ . It is a compelling
concept which we can use to build composable pieces of our apps. Try to use
this method and share with me your thoughts about it. Feel free to follow me
on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading and see you next week!



# The power of Delegate design pattern

##  The power of Delegate design pattern

29 May 2019

Last week before WWDC and everybody so excited about new features which we
will have just in a few days. However, let’s keep posts related to WWDC for
next week. This week we are going to talk about my favorite design pattern
_Delegate_ . _Delegate_ is the most straightforward and powerful pattern.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In software engineering, the delegation pattern is an object-oriented design
pattern that allows object composition to achieve the same code reuse as an
inheritance. In delegation, an object handles a request by delegating to a
second object (the delegate). A delegate is a helper object, but with the
original context.

####  Protocols

We use _Delegate_ pattern every day, and iOS SDK uses it in many places. For
example, _UITableView_ delegates to _UITableViewDataSource_ populating the
table with cells, it also delegates cell selection and other actions to
_UITableViewDelegate_ . Another excellent example of delegate patters is
_FlowController_ or _Coordinators_ . _ViewControllers_ delegates navigation
logic to _Coordinator_ . I have separated post about [ extracting navigation
logic into FlowControllers ](/2019/02/20/navigation-with-flow-controllers) .

Let’s dive into code samples. Assume that you are working on a game. You
extracted game logic into separated class Game, and you want to delegate game
state changes to _UIViewController_ which renders this game.

    
    
    protocol GameDelegate: AnyObject {
        func stateChanged(from oldState: Game.State, to newState: Game.State)
    }
    
    class Game {
        private var state: State = .notStarted {
            didSet {
                delegate?.stateChanged(from: oldValue, to: state)
            }
        }
    
        weak var delegate: GameDelegate?
    
        private(set) var value: Int = 0
    
        func start() {
            state = .started
        }
    
        func generateNextValue() {
            value = Int.random(in: 0..<1000)
            state = generateState(using: value)
        }
    }
    
    extension Game {
        enum State {
            case notStarted
            case started
            case right
            case win
            case lost
        }
    }
    

Here is the source code of a simple game which generates random values. The
game engine generates state based on random values. Every state change call
delegate to pass old and new states. We define our delegate protocol extended
from _AnyObject_ , that means the only class instance can accept it. I also
use **weak** keyword to define variable holding delegate. It needed to break
the retain cycle between delegate and game class. Let’s take a look at
_GameViewController_ now.

    
    
    class GameViewController: UIViewController {
        private let game: Game
    
        init(game: Game) {
            self.game = game
            super.init(nibName: nil, bundle: nil)
        }
    
        @IBAction func play() {
            game.start()
        }
    
        @IBAction func next() {
            game.generateNextValue()
        }
    
        override func viewDidLoad() {
            super.viewDidLoad()
            game.delegate = self
        }
    }
    
    extension GameViewController: GameDelegate {
        func render(_ state: Game.State) {
            switch state {
            case .lost: renderLost()
            case .right: renderRight()
            case .win: renderWin()
            case .started: renderStart()
            case .notStarted: renderNotStarted()
            }
        }
    
        func stateChanged(from oldState: Game.State, to newState: Game.State) {
            render(newState)
        }
    }
    

Here we have a _GameViewController_ class which feeds game with user actions
and render state changes. _GameViewController_ conforms to _GameDelegate_ and
implements all needed rendering in extension. As a result, we have a
composable codebase with the help of _Delegate_ design pattern.

####  Closures

Sometimes when you have only one method in the delegate, you can replace it
with closure. The idea is the same, but now you call the closure and pass the
state instead of calling the method by protocol. Let’s take a look at the
example with closure.

    
    
    class Game {
        typealias StateHandler = (State) -> Void
    
        var handler: StateHandler?
        
        private var state: State = .notStarted {
            didSet {
                handler?(state)
            }
        }
    }
    
    class GameViewController: UIViewController {
        override func viewDidLoad() {
            super.viewDidLoad()
    
            game.handler = { [weak self] state in
                self?.render(state)
            }
        }
    }
    

As you can see, we pass the closure to the game class instance which handles
state changes. We use **weak** to break the retain cycle during closure’s
context capture. Another option here can be a usage of the fact that any Swift
function is a closure. So instead of creating separated closure, we can pass
the function name. However, be careful this method creates retain circle. Here
is an example of how we can do that.

    
    
    class GameViewController: UIViewController {
        override func viewDidLoad() {
            super.viewDidLoad()
            game.handler = render
        }
    }
    
    extension GameViewController {
        func render(_ state: Game.State) {
            switch state {
            case .lost: renderLost()
            case .right: renderRight()
            case .win: renderWin()
            case .started: renderStart()
            case .notStarted: renderNotStarted()
            }
        }
    }
    

####  Conclusion

Today we discussed the most powerful and straightforward design pattern in iOS
development. I enjoy how simple it is and how useful it can be in composing
pieces to make codebase decoupled. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# Exporting data from Unified Logging System in Swift

##  Exporting data from Unified Logging System in Swift

19 Apr 2022

We discussed building a proper logging system instead of using the print
function in the previous post. Apple provides us a framework to utilize its
logging system backed by on-disk persistence. This week we will talk about
exporting logs from the user devices by leveraging the power of the Unified
Logging System.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The Unified Logging System comes with the _OSLogStore_ type letting us fetch
and filter logs saved in our app. Let’s build the _LogStore_ type that we can
use in our settings screen to create a feature allowing our users to export
and share logs with the app maintainer.

    
    
    import OSLog
    import Foundation
    
    @MainActor final class LogStore: ObservableObject {
        private static let logger = Logger(
            subsystem: Bundle.main.bundleIdentifier!,
            category: String(describing: LogStore.self)
        )
    
        @Published private(set) var entries: [String] = []
    
        func export() {
            do {
                let store = try OSLogStore(scope: .currentProcessIdentifier)
                let position = store.position(timeIntervalSinceLatestBoot: 1)
                entries = try store
                    .getEntries(at: position)
                    .compactMap { $0 as? OSLogEntryLog }
                    .filter { $0.subsystem == Bundle.main.bundleIdentifier! }
                    .map { "[\($0.date.formatted())] [\($0.category)] \($0.composedMessage)" }
            } catch {
                Self.logger.warning("\(error.localizedDescription, privacy: .public)")
            }
        }
    }
    

As you can see in the example above, we created an instance of the
_OSLogStore_ type scoped to the current process. We use the _position_
function to build an object representing a date from which we want to export
logs. In the recent example, we use the _timeIntervalSinceLatestBoot_
parameter to fetch entries since the last boot.

> To learn about basics of the Unified Logging System, take a look at my [
> “Logging in Swift” ](/2022/04/06/logging-in-swift/) post.

Then we use the _getEntries_ function to fetch the log entries from the
defined position. In the example above, we filter entries to include only the
needed _subsystem_ . We also use different fields of log entries to build
formatted strings. Not let’s see how we can use our _LogStore_ type.

    
    
    struct SettingsView: View {
        @ObservedObject var logs: LogStore
        @State private var exportShown = false
        
        var body: some View {
            Form {
                Section(header: Text("debug")) {
                    Button("exportLogs") {
                        logs.export()
                        exportShown = true
                    }
                    .sheet(isPresented: $exportShown) {
                        ShareView(items: [logs.entries.joined(separator: "\n")])
                    }
                }
            }
        }    
    }
    
    struct ShareView: UIViewControllerRepresentable {
        typealias UIViewControllerType = UIActivityViewController
    
        let items: [Any]
    
        func makeUIViewController(context: Context) -> UIActivityViewController {
            UIActivityViewController(activityItems: items, applicationActivities: nil)
        }
    
        func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {
        }
    }
    

I have the debug section in the settings screen that provides a button to
export logged data. I also wrap the _UIActivityViewController_ with the
_UIViewControllerRepresentable_ to give a nice way to share logs with the app
maintainer.

The _OSLogStore_ type provides us another overload of the _position_ function,
allowing us to specify a particular date to fetch all the entries after it.
For example, you might need to fetch the log entries for the last 24 hours.

    
    
    import OSLog
    import Foundation
    
    @MainActor final class LogStore: ObservableObject {
        private static let logger = Logger(
            subsystem: Bundle.main.bundleIdentifier!,
            category: String(describing: LogStore.self)
        )
    
        @Published private(set) var entries: [String] = []
    
        func export() {
            do {
                let store = try OSLogStore(scope: .currentProcessIdentifier)
                let date = Date.now.addingTimeInterval(-24 * 3600)
                let position = store.position(date: date)
                
                entries = try store
                    .getEntries(at: position)
                    .compactMap { $0 as? OSLogEntryLog }
                    .filter { $0.subsystem == Bundle.main.bundleIdentifier! }
                    .map { "[\($0.date.formatted())] [\($0.category)] \($0.composedMessage)" }
            } catch {
                Self.logger.warning("\(error.localizedDescription, privacy: .public)")
            }
        }
    }
    

Today we learned how to use the Unified Logging System to export the valuable
information logged by our apps. We can’t always catch all the things on our
testing devices. That’s why a proper logging system is essential for any app.
I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Visual effects in SwiftUI

##  Visual effects in SwiftUI

07 Nov 2023

During WWDC 23, SwiftUI introduced a new view modifier called _visualEffect_ .
This modifier allows us to attach a set of animatable visual effects by
accessing layout information of the particular view. This week, we will learn
how to use the new _visualEffect_ view modifier in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start with the most simple example of using the _visualEffect_ view
modifier.

    
    
    struct ContentView: View {
        var body: some View {
            Text("Hello World!")
                .visualEffect { initial, geometry in
                    initial.offset(geometry.size)
                }
        }
    }
    

As you can see in the example above, we define a text view and attach the
_visualEffect_ view modifier. Whenever you attach the _visualEffect_ view
modifier, you should specify the effect closure. This is the place where you
apply all the effects that you need.

The effect closure provides you with two parameters. The first is an initial
state of the collections of effects attached to the view. It is an instance of
the _EmptyVisualEffect_ type. We use this instance to attach additional
effects. The second parameter is an instance of the _GeometryProxy_ type
containing all the layout information of the view you might need, like frame,
safe area, etc.

> To learn how to use the _GeometryProxy_ type, take a look at my [ “Mastering
> ScrollView in SwiftUI” ](/2020/09/24/mastering-scrollview-in-swiftui/) post.

What is a visual effect? The visual effect is anything that can change the
visual appearance of the view but doesn’t affect its layout. In the previous
iterations of the SwiftUI framework, we had view modifiers like _scale_ ,
_offset_ , _blur_ , _contrast_ , _saturation_ , _opacity_ , _rotation_ , etc.
All of them are visual effects and conform to the _VisualEffect_ protocol now.
You can use any of them inside the _visualEffect_ closure.

    
    
    struct ContentView: View {
        
        var body: some View {
            Text("Hello World!")
                .visualEffect { initial, geometry in
                    initial
                        .blur(radius: 8)
                        .opacity(0.9)
                        .scaleEffect(.init(width: 2, height: 2))
                }
        }
    }
    

Things like _frame_ and _padding_ are not visual effects, and you can’t use
them inside the _visualEffect_ closure because they modify the layout of the
view hierarchy.

The _visualEffect_ view modifier is the new way to do old things. We can
modify the opacity and offset of the view using old view modifiers. And you
can continue to use them if you don’t need the layout information. The only
difference of the new approach is the way we scope the visual effects of the
view by calculating them from the layout information that _GeometryProxy_
provides us.

The _visualEffect_ view modifier supports animatable values. So you can
continue using it to animate your view’s visual appearance depending on its
frame and bounds in the view hierarchy that you can access via an instance of
the _GeometryProxy_ type.

    
    
    struct ContentView: View {
        @State private var isScaled = false
        
        var body: some View {
            VStack {
                Button("Scale") {
                    isScaled.toggle()
                }
                
                Text("Hello World!")
                    .visualEffect { initial, geometry in
                        initial.scaleEffect(
                            CGSize(
                                width: isScaled ? 2 : 1,
                                height: isScaled ? 2 : 1
                            )
                        )
                    }
                    .animation(.smooth, value: isScaled)
            }
        }
    }
    

Today, we learned about the benefits and usage of the new _visualEffect_ view
modifier in SwiftUI. It is not backward compatible with previous versions of
Apple platforms, so keep in mind that you can achieve the same effect by using
old but gold view modifiers. I hope you enjoy the post. Feel free to follow me
on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Redux-like state container in SwiftUI. Connectors.

##  Redux-like state container in SwiftUI. Connectors.

03 Feb 2021

During the last year, I totally understood the power of a single source of
truth and a state container that holds the whole app state in a single place.
I’ve used this approach in a couple of my apps and continue to use it in new
projects.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

I’m rewriting my ShowBot app in SwiftUI using the single state container
approach. I want to talk mainly about watched episodes history screen. This is
how it looks now. Let’s try to build the first screen.

![showbot](/public/showbot.jpg)

> If you are not familiar with the concept of a single source of truth, take a
> look at my dedicated series of [ “Redux-like state container in SwiftUI”
> ](/2019/09/18/redux-like-state-container-in-swiftui/) posts.
    
    
    import Foundation
    
    struct AppState: Equatable {
        var showsById: [Ids: Show] = [:]
        var seasons: [Ids: Season] = [:]
        var episodes: [Ids: Episode] = [:]
        var showImages: [Ids: FanartImages] = [:]
        var watchedHistory: [Ids] = []
    }
    
    enum AppAction: Equatable {
        case markAsWatched(episode: Ids, watched: Bool)
    }
    
    import SwiftUI
    import KingfisherSwiftUI
    
    struct HistoryView: View {
        @ObservedObject var store: Store<AppState, AppAction>
    
        var body: some View {
            LazyVGrid(columns: [.init(), .init()]) {
                ForEach(store.state.watchedHistory, id: \.self) { id in
                    posterView(for: id)
                }
            }
        }
    
        private func posterView(for id: Ids) -> some View {
            let image = store.state.showImages[id]?.tvPosters?.first?.url
            let episode = store.state.episodes[id]
            let title = episode?.title ?? ""
            let date = episode?.firstAired ?? Date()
    
            return VStack {
                image.map {
                    KFImage($0)
                }
    
                Text(title)
                Text(verbatim: DateFormatter.shortDate.string(for: date))
                    .foregroundColor(.secondary)
                    .font(.subheadline)
            }
        }
    }
    

The main issue here is the formatting logic that lives inside the view. We
can’t verify it using unit tests. Another problem is SwiftUI previews. We have
to provide the entire store with the whole app state to render a single
screen. And we can’t keep the view in a separated Swift Package because it
depends on the whole app state.

We can improve the case a little bit by using derived stores that provide only
the app state’s needed part. But we still need to keep the formatting logic
somewhere outside of the view.

> To learn more about derived stores, take a look at my [ “Redux-like state
> container in SwiftUI. Best practices.” ](/2019/09/25/redux-like-state-
> container-in-swiftui-part2/) post.

Let me introduce another component that lives in between the whole app store
and the dedicated view. The primary responsibility of this component is the
transformation of the app state to the view state. I call it _Connector_ , and
it is Redux inspired component.

    
    
    protocol Connector {
        associatedtype State
        associatedtype Action
        associatedtype ViewState: Equatable
        associatedtype ViewAction: Equatable
    
        func connect(state: State) -> ViewState
        func connect(action: ViewAction) -> Action
    }
    
    extension Store {
        func connect<C: Connector>(
            using connector: C
        ) -> Store<C.ViewState, C.ViewAction> where C.State == State, C.Action == Action {
            derived(
                deriveState: connector.connect(state: ),
                embedAction: connector.connect(action: )
            )
        }
    }
    

As you can see, _Connector_ is a simple protocol that defines two functions.
The first one transforms the whole app state into the view state, and the
second one converts view actions into app actions. Let’s refactor our view by
introducing view state and view actions.

    
    
    extension HistoryView {
        struct State: Equatable {
            let posters: [Poster]
    
            struct Poster: Hashable {
                let ids: Ids
                let imageURL: URL?
                let title: String
                let subtitle: String
            }
        }
    
        enum Action: Equatable {
            case markAsWatched(episode: Ids)
        }
    
        typealias ViewModel = Store<State, Action>
    }
    

We create an entirely different model for our view that holds the only needed
data. The view state here is a direct mapping of the view representation and
its model. The view action enum is the only action that available for this
particular view. You eliminate the accidents where you call unrelated actions.
Finally, your view is fully independent, which allows you to extract it into a
separated Swift Package.

    
    
    import KingfisherSwiftUI
    import SwiftUI
    
    struct HistoryView: View {
        @ObservedObject var viewModel: ViewModel
    
        var body: some View {
            LazyVGrid(columns: [.init(), .init()]) {
                ForEach(viewModel.state.posters, id: \.title) { poster in
                    VStack {
                        poster.imageURL.map {
                            KFImage($0)
                        }
                        Text(poster.title)
                        Text(poster.subtitle)
                    }.onTapGesture {
                        viewModel.send(.markAsWatched(episode: poster.ids))
                    }
                }
            }
        }
    }
    

Another benefit here is the super simple view. It doesn’t do anything. The
view displays the formatted data and sends actions. You can quickly write as
many SwiftUI previews as you need to cover all the different cases like
loading, empty, etc.

    
    
    extension Store {
        static func stub(with state: State) -> Store {
            Store(
                initialState: state,
                reducer: .init { _, _, _ in Empty().eraseToAnyPublisher() },
                environment: ()
            )
        }
    }
    
    struct HistoryView_Previews: PreviewProvider {
        static var previews: some View {
            HistoryView(
                viewModel: .stub(
                    with: .init(
                        posters: [
                            .init(
                                ids: Ids(trakt: 1),
                                imageURL: URL(
                                    staticString: "https://assets.fanart.tv/fanart/tv/280619/tvposter/the-expanse-5d34ade5abdfd.jpg"
                                ),
                                title: "The Expanse",
                                subtitle: "Sci-fi show"
                            )
                        ]
                    )
                )
            )
        }
    }
    

It’s time to create the particular connector type, which we will use to bind
the app state to the view state.

    
    
    enum Connectors {}
    
    extension Connectors {
        struct WatchedHistoryConnector: Connector {
            func connect(state: AppState) -> HistoryView.State {
                .init(
                    posters: state.watchedHistory.compactMap { ids in
                        let episode = state.episodes[ids]
                        return HistoryView.State.Poster(
                            ids: ids,
                            imageURL: state.showImages[ids]?.tvPosters?.first?.url,
                            title: episode?.title ?? "",
                            subtitle: DateFormatter.shortDate.string(for: episode?.firstAired) ?? ""
                        )
                    }
                )
            }
    
            func connect(action: HistoryView.Action) -> AppAction {
                switch action {
                case let .markAsWatched(episode):
                    return AppAction.markAsWatched(episode: episode, watched: true)
                }
            }
        }
    }
    

As you can see in the example above, _WatchedHistoryConnector_ is a simple
value type that we can quickly test using unit testing. Now, we should take a
look at how we can use our connector types. Usually, I have container or flow
views that connect views to the store.

    
    
    import SwiftUI
    
    struct RootContainerView: View {
        @EnvironmentObject var store: Store<AppState, AppAction>
    
        var body: some View {
            HistoryView(
                viewModel: store.connect(using: Connectors.WatchedHistoryConnector())
            )
        }
    }
    

> To learn more about Container Views, take a look at [ “Introducing Container
> views in SwiftUI” ](/2019/07/31/introducing-container-views-in-swiftui/)
> post.

This week I’ve shared the approach that I use in my latest project. I love how
it works and the possibility to improve my test coverage by introducing a
simple value type. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
article. Thanks for reading, and see you next week!

  1. [ Redux-like state container in SwiftUI. Basics ](/2019/09/18/redux-like-state-container-in-swiftui/)
  2. [ Redux-like state container in SwiftUI. Best practices ](/2019/09/25/redux-like-state-container-in-swiftui-part2/)
  3. [ Redux-like state container in SwiftUI. Container Views. ](/2019/10/02/redux-like-state-container-in-swiftui-part3/)
  4. Redux-like state container in SwiftUI. Connectors. 
  5. [ Redux-like state container in SwiftUI. Swift concurrency model. ](/2022/02/17/redux-like-state-container-in-swiftui-part5/)

####  References

The series of posts have built on a foundation of ideas started by other
libraries, particularly Redux, Elm, and TCA.

  1. [ WWDC20 - Data Essentials in SwiftUI ](https://developer.apple.com/videos/play/wwdc2020/10040/)
  2. [ Redux ](https://redux.js.org) \- The JavaScript library that popularized unidirectional data flow. 
  3. [ The Elm Architecture ](https://guide.elm-lang.org/architecture/) \- A purely functional language and runtime that inspired the creation of Redux. 
  4. [ The Composable Architecture ](https://github.com/pointfreeco/swift-composable-architecture) \- A library that bridges concepts from the Elm Architecture and Redux to Swift. It introduced the “environment” and “effect” patterns that this series covers. 



# Mastering List in SwiftUI

##  Mastering List in SwiftUI

16 Jun 2021

List is the crucial view for many apps. I can’t imagine an app that doesn’t
use a list view anywhere in the view hierarchy. During WWDC21, list view
became even more powerful and brought us all the needed features of
_UITableView_ . This week, we will learn how to use the list view in SwiftUI
and master its features.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

List view is straightforward but very powerful. You can use it similarly to
other SwiftUI views. To create a list view in SwiftUI, you should initiate the
_List_ struct with a _ViewBuilder_ closure that defines the content of the
list.

> To learn more about _ViewBuilder_ , take a look at my dedicated [ “The power
> of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-viewbuilder-in-
> swiftui/) post.
    
    
    struct ContentView: View {
        var body: some View {
            List {
                Text("Hello")
                Text("World")
            }
        }
    }
    

![list](/public/list0.png)

Usually, we use the list view to display an array of similar items. To achieve
this behavior with SwiftUI, we should use another version of _List_ structs’s
initializer to map every item in the collection to its view representation.

    
    
    struct Message {
        let id = UUID()
        let content: String
    }
    
    struct ContentView: View {
        @State private var messages: [Message] = [
            Message(content: "Hello"),
            Message(content: "World")
        ]
    
        var body: some View {
            List(messages, id: \.id) { message in
                Text(message.content)
            }
        }
    }
    

As you can see in the example above, we construct the list by providing a
messages array and the keypath defining the message’s _ID_ . SwiftUI uses the
_ID_ to differentiate the items and animate changes like insert, remove and
reorder. Remember that you should provide a keypath to the stable _ID_
property. For example, it might be a stored property from your database.

####  Sections

Sometimes we need to display the content of the list view in different
sections. We can make it happen using the _Section_ view in SwiftUI.

    
    
    struct ContentView: View {
        @State private var incoming: [Message] = [
            Message(content: "Incoming message 1"),
            Message(content: "Incoming message 2")
        ]
    
        @State private var outgoing: [Message] = [
            Message(content: "Outgoing message 1"),
            Message(content: "Outgoing message 2")
        ]
    
        var body: some View {
            List {
                Section(header: Text("Incoming")) {
                    ForEach(incoming, id: \.id) { message in
                        Text(message.content)
                    }
                }
    
                Section(header: Text("Outgoing")) {
                    ForEach(outgoing, id: \.id) { message in
                        Text(message.content)
                    }
                }
            }
        }
    }
    

![list](/public/list2.png)

As you can see here, we use the _ForEach_ view to iterate over collections of
items and map them to particular views. It also needs a keypath to the _ID_
field to differentiate the items in the collection.

####  Recursive

I didn’t face this case too often, but we have to display recursive data
structures like trees in our apps from time to time. You can easily do that
with the list view in SwiftUI. There is a particular _List_ struct initializer
that accepts a keypath for the recursive field of your data structure. It will
use the keypath to traverse and display your data recursively.

    
    
    struct Tree<Value: Hashable>: Hashable {
        let value: Value
        var children: [Tree<Value>]? = nil
    }
    
    struct ContentView: View {
        @State private var tree: [Tree<Int>] = [
            .init(
                value: 1,
                children: [
                    .init(value: 2),
                    .init(
                        value: 3,
                        children: [
                            .init(value: 4),
                            .init(value: 5)
                        ]
                    )
                ]
            )
        ]
        
        var body: some View {
            List(tree, id: \.value, children: \.children) { item in
                Text(String(item.value))
            }
        }
    }
    

![list](/public/list3.png)

As you can see in the example above, we define the _Tree_ struct with the
_children_ field, which is another array of trees. Then, we initiate the list
view and provide a keypath to the recursive field.

> To learn more about displaying recursive data, take a look at my [
> “Displaying recursive data using OutlineGroup in SwiftUI”
> ](/2020/09/02/displaying-recursive-data-using-outlinegroup-in-swiftui/)
> post.

####  Selection

List view provides you an opportunity to select items only in the edit mode.
However, we usually want to mark several items to delete or move them
together. Therefore, to enable the selection interface, we have to move the
view to the edit mode and provide a selection binding to the list view.

    
    
    struct ContentView: View {
        @State private var selection: Set<UUID> = []
        @State private var messages: [Message] = [
            Message(content: "Hello"),
            Message(content: "World")
        ]
    
        var body: some View {
            NavigationView {
                List(selection: $selection) {
                    ForEach(messages, id: \.id) { message in
                        Text(message.content)
                    }
                }
                .navigationTitle("List")
                .toolbar { EditButton() }
            }
        }
    }
    

![list](/public/list4.png)

We add the edit button in the toolbar. Edit button toggles the edit mode for
the current scope and enables the editing interface. You can allow both single
and multi-selection modes. It depends on the type of selection binding you
provide. SwiftUI enables multi selection mode when you give a binding to the
_Set_ , or it uses single selection binding when you pass the binding to the
single _ID_ item.

    
    
    struct ContentView: View {
        @State private var selection: UUID?
        @State private var messages: [Message] = [
            Message(content: "Hello"),
            Message(content: "World")
        ]
    
        var body: some View {
            NavigationView {
                List(selection: $selection) {
                    ForEach(messages, id: \.id) { message in
                        Text(message.content)
                    }
                }
                .navigationTitle("List")
                .toolbar { EditButton() }
            }
        }
    }
    

Here we provide a binding to the single item _ID_ . That’s why SwiftUI enables
the single selection mode on the list.

####  Swipe actions

We can enable leading and trailing swipe actions for the list items. We can
quickly achieve that by using the new _swipeActions_ view modifier.

    
    
    struct ContentView: View {
        @State private var messages: [Message] = [
            Message(content: "Hello"),
            Message(content: "World")
        ]
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(messages, id: \.id) { message in
                        Text(message.content)
                            .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                                Button("Delete", role: .destructive) {
                                    messages.removeAll { $0.id == message.id }
                                }
                            }
                    }
                }
                .navigationTitle("List")
            }
        }
    }
    

In the example above, we add the opportunity to remove the items from the list
using a trailing edge swipe. We can provide multiple actions on every edge.
Here is another example with two swipeable actions on the leading edge with
different button colors.

    
    
    struct ContentView: View {
        @State private var messages: [Message] = [
            Message(content: "Hello"),
            Message(content: "World")
        ]
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(messages, id: \.id) { message in
                        Text(message.content)
                            .swipeActions(edge: .leading, allowsFullSwipe: false) {
                                Button("Favorite") {
                                    // do some work here
                                }.tint(.yellow)
    
                                Button("Move") {
                                    // do some work here
                                }.tint(.green)
                            }
                    }
                }
                .navigationTitle("List")
            }
        }
    }
    

####  Styling options

SwiftUI provides a few different styles for the list view. It includes _plain,
sidebar, inset, grouped, inset, and insetGrouped_ styles. By default, SwiftUI
uses _insetGrouped_ style, but you can change it to any style you need using
the _listStyle_ view modifier. Keep in mind that the _listStyle_ view modifier
uses the environment to propagate the selected style, and it will affect all
the list views down in the view hierarchy.

> To learn more about environment in SwiftUI, take a look at my [ “The power
> of Environment in SwiftUI” ](/2019/08/21/the-power-of-environment-in-
> swiftui/) post.
    
    
    struct ContentView: View {
        var body: some View {
            NavigationView {
                List {
                    Section(header: Text("Section 1")) {
                        Text("Hello")
                    }.headerProminence(.increased)
    
                    Section(header: Text("Section 2")) {
                        Text("World")
                    }
                }
                .listStyle(.insetGrouped)
                .navigationTitle("List")
            }
        }
    }
    

In the example above, we apply _insetGrouped_ style, also we use
_headerProminence_ modifier to increase the importance of the section which
makes the header text bolder and bigger.

SwiftUI also provides us a set of view modifier which allows us to change the
tint color of separators, list items or completely hide them from the list.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationView {
                List {
                    Section(header: Text("Section 1")) {
                        Label("Hello", systemImage: "message")
                            .listItemTint(.red)
                    }
    
                    Section(header: Text("Section 2")) {
                        Text("World")
                            .listRowSeparatorTint(.red)
                    }
                }
                .listStyle(.grouped)
                .listSectionSeparator(.hidden, edges: .all)
                .navigationTitle("List")
            }
        }
    }
    

####  Conclusion

This week we learned how to use the most crucial SwiftUI view. So I’m happy to
cover the list view in my blog finally. I hope you enjoy the post. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Building type-safe networking in Swift

##  Building type-safe networking in Swift

10 Feb 2021

More than half of the apps I built during my career had networking code.
Usually, we build apps for web services. Today we will talk about building the
type-safe networking layer using Swift language features like enums, phantom
types, and extensions.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s first take a look at the typical networking code and recognize the
issues that we want to avoid in our solution.

    
    
    struct Repo: Decodable {
        let id: Int
        let name: String
    }
    
    struct SearchResponse: Decodable {
        let items: [Repo]
    }
    
    let query = "Swift"
    let url = URL(string: "https://api.github.com/search/repositories?q=\(query)")!
    var request = URLRequest(url: url)
    request.httpMethod = "GET"
    request.httpBody = nil
    
    let cancellable = URLSession.shared.dataTaskPublisher(for: request)
        .map(\.data)
        .decode(type: SearchResponse.self, decoder: JSONDecoder())
        .map(\.items)
        .replaceError(with: [])
        .sink { print($0) }
    

In the example above, we have a standard networking code that creates the
request and decodes the response. There are a few things that I want to avoid
in the future.

  1. We create a GET request, but there is a possibility to set an HTTP body for a GET request, which looks meaningless. 
  2. We try to decode the response by providing the type of resulting data. Usually, every request has one and only one type that we can obtain. In this case, it is better to have the response type encoded into the request. 

Let’s start building our type-safe networking by introducing the _Request_
type. The _Request_ type should contain the URL we need to access, headers,
and HTTP method.

    
    
    struct Request {
        let url: URL
        let method: HttpMethod
        var headers: [String: String] = [:]
    }
    

The HTTP method is an exclusive thing. You can’t use both GET and POST, and
you can choose only one HTTP method. It looks like a perfect use-case for an
enum type.

    
    
    enum HttpMethod: Equatable {
        case get([URLQueryItem])
        case put(Data?)
        case post(Data?)
        case delete
        case head
    
        var name: String {
            switch self {
            case .get: return "GET"
            case .put: return "PUT"
            case .post: return "POST"
            case .delete: return "DELETE"
            case .head: return "HEAD"
            }
        }
    }
    

As you can see in the example above, we define the _HTTPMethod_ enum that
describes various HTTP methods. We use cases with associated types to hold the
data correlated with the HTTP method. For example, the GET method contains URL
query items, POST and PUT methods have the data we use as the HTTP body.

Now we need to make somehow _URLSession_ working with our _Request_ type. The
easiest way is defining a calculated property on the _Request_ type that
converts it to the _URLRequest_ .

    
    
    extension Request {
        var urlRequest: URLRequest {
            var request = URLRequest(url: url)
    
            switch method {
            case .post(let data), .put(let data):
                request.httpBody = data
            case let .get(queryItems):
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                components?.queryItems = queryItems
                guard let url = components?.url else {
                    preconditionFailure("Couldn't create a url from components...")
                }
                request = URLRequest(url: url)
            default:
                break
            }
    
            request.allHTTPHeaderFields = headers
            request.httpMethod = method.name
            return request
        }
    }
    

Finally, we can create an extension on _URLSession_ to make requests with our
new type.

    
    
    extension URLSession {
        func data(for request: Request) async throws -> Data {
            let (data, _) = try await self.data(for: request.urlRequest)
            return data
        }
    }
    

####  Phantom response type

One thing we forgot to do is encoding of result type into the request. We can
make it really easy by introducing phantom type. Phantom type is a generic
constraint defined in any type but is not used inside. Let’s take a look at
the example.

    
    
    struct Request<Response> {
        let url: URL
        let method: HttpMethod
        var headers: [String: String] = [:]
    }
    

As you can see, we define _Response_ type, but we didn’t use it anywhere in
the _Request_ type. That’s why it is called phantom type. Defining phantom
types allows us to store information about the response in our request type.
For example, it might be a type conforming to _Decodable_ or even an instance
of the _Data_ type. Let’s update our extension on _URLSession_ to support
response decoding.

    
    
    extension URLSession {
        func decode<Value: Decodable>(
            _ request: Request<Value>,
            using decoder: JSONDecoder = .init()
        ) async throws -> Value {
            let (data, _) = try await self.data(for: request.urlRequest)
            return try decoder.decode(Value.self, from: data)
        }
    }
    

In the example above, we introduce the _decode_ function allowing us to fetch
and decode data using our _Request_ type. Take a look at how we use the
phantom type to decode value. Let’s define a Github repo search request using
the new API.

    
    
    extension Request where Response == SearchResponse {
        static func search(matching query: String) -> Self {
            Request(
                url: URL(string: "https://api.github.com/search/repositories")!,
                method: .get(
                    [.init(name: "q", value: query)]
                )
            )
        }
    }
    
    let request: Request<SearchResponse> = .search(matching: "Swift")
    let response = try await URLSession.shared.decode(request)
    

> To learn more about the benefits of using phantom types, look at my [
> “Phantom types in Swift” ](/2021/02/18/phantom-types-in-swift/) post.

####  Conclusion

Today we built a type-safe networking layer using Swift features like enums,
phantom types, and extensions. This toolbox allows you to transform any old
API into a safe and modern API. I hope you enjoy the post. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this article. Thanks for reading, and see you next week!



# Styling custom SwiftUI views using environment

##  Styling custom SwiftUI views using environment

09 Dec 2020

One of my favorite features of SwiftUI is styling. I love the idea of style
protocols provided by every view and sharing them using the environment. I
have already covered most of the style protocols for SwiftUI provided views in
my previous posts. But what about custom views? This week we will learn how to
share styling using environment for our custom views.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

If you are not familiar with style protocols in SwiftUI, let me show you a
rapid example of using them.

    
    
    struct MyApp: App {
        var body: some Scene {
            WindowGroup {
                RootView()
                    .listStyle(InsetGroupedListStyle())
            }
        }
    }
    

In the example above, we attached the _listStyle_ modifier to the root view of
the app. This modifier shares the instance of _ListStyle_ protocol with the
whole app view hierarchy using the environment. All the app list instances
will use _InsetGroupedListStyle_ by default just because of this single line
of code. But don’t worry. Any particular part of the view hierarchy can
override this value with any other style when needed. Let’s take a look at
another example.

    
    
    struct FillButtonStyle: ButtonStyle {
        func makeBody(configuration: Configuration) -> some View {
            configuration.label
                .padding()
                .foregroundColor(.white)
                .background(Color.accentColor)
                .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
        }
    }
    
    struct MyApp: App {
        var body: some Scene {
            WindowGroup {
                RootView()
                    .buttonStyle(FillButtonStyle())
                    .listStyle(InsetGroupedListStyle())
            }
        }
    }
    

As you can see here, we apply the unified button style for all the buttons in
the app. All buttons will be filled with the accent color and will use the
rounded rectangle’s shape.

> To learn more about _ButtonStyle_ protocol, look at my [ “Mastering buttons
> in SwiftUI” ](/2020/02/19/mastering-buttons-in-swiftui/) post.

####  Styling using view parameters

Now we know how to use the style protocols that SwiftUI provides us, but what
about our custom views? I maintain [ a small charting library
](https://github.com/mecid/SwiftUICharts) . As you may know, charts can be
highly flexible in terms of configuration. Let’s take a look at the usage
example of my charting library.

    
    
    let dataPoints: [DataPoint] = []
    
    BarChartView(
        dataPoints: dataPoints,
        showLabels: true,
        labelCount: 3,
        showLegends: true
    )
    

As you can see, multiple parameters allow us to configure the chart
presentation. There are actually many more parameters, but all of them have
default values, and you don’t need to provide them here.

The first thing that I decide to do is extract the chart presentation
parameters into a separated struct to keep them apart from chart data.

    
    
    public struct ChartStyle {
        let barMinHeight: CGFloat
        let showAxis: Bool
        let axisLeadingPadding: CGFloat
        let showLabels: Bool
        let labelCount: Int?
        let showLegends: Bool
        
        public init(
            barMinHeight: CGFloat = 100,
            showAxis: Bool = true,
            axisLeadingPadding: CGFloat = 0,
            showLabels: Bool = true,
            labelCount: Int? = nil,
            showLegends: Bool = true
        ) {
            self.barMinHeight = barMinHeight
            self.showAxis = showAxis
            self.axisLeadingPadding = axisLeadingPadding
            self.showLabels = showLabels
            self.labelCount = labelCount
            self.showLegends = showLegends
        }
    }
    

Let’s take a look at the usage example now.

    
    
    let dataPoints: [DataPoint] = []
    let style = ChartStyle(showAxis: false, labelCount: 3)
    BarChartView(dataPoints: dataPoints, style: style)
    

####  Styling using environment

The previous example looks better than before, but it doesn’t give us all the
benefits of environment sharing that standard SwiftUI views have. We can
easily solve it by inserting an instance of style struct into the environment
instead of passing it via initializer. Let’s take a look at how we can do
that.

    
    
    struct ChartStyleEnvironmentKey: EnvironmentKey {
        static var defaultValue: ChartStyle = .init()
    }
    
    extension EnvironmentValues {
        var chartStyle: ChartStyle {
            get { self[ChartStyleEnvironmentKey.self] }
            set { self[ChartStyleEnvironmentKey.self] = newValue }
        }
    }
    
    extension View {
        func chartStyle(_ style: ChartStyle) -> some View {
            environment(\.chartStyle, style)
        }
    }
    

First of all, we create an additional environment value that will hold the
chart style. Then we create an extension on _View_ protocol that allows us to
insert chart styles into a view hierarchy environment.

> To learn more about the possibilities of SwiftUI’s environment feature, take
> a look at my [ “The power of Environment in SwiftUI” ](/2019/08/21/the-
> power-of-environment-in-swiftui/) post.

We can use the environment property wrapper inside _BarChartView_ to obtain
the style that the environment shares.

    
    
    public struct BarChartView: View {
        @Environment(\.chartStyle) var chartStyle
        let dataPoints: [DataPoint]
        
        var body: some View {
            // draw bars
            if chartStyle.showLabels {
                // show labels
            }
    
            if chartStyle.showLegends {
                // show legend
            }
        }
    }
    
    let dataPoints1: [DataPoint] = // ...
    let dataPoints2: [DataPoint] = // ...
    
    HStack {
        BarChartView(dataPoints: dataPoints1)
        BarChartView(dataPoints: dataPoints2)
    }.chartStyle(ChartStyle(showAxis: false, labelCount: 3))
    

![charts](/public/redacted.jpeg)

####  Conclusion

I really love this approach because it easily allows us to style the whole app
hierarchy. For example, I have a screen that displays a list of charts with
different data points. All of these charts have the same styling, which I
insert into the environment of its parent view using a single line of code.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Activities and attachments in the XCTest framework

##  Activities and attachments in the XCTest framework

21 Mar 2023

Today I want to continue the topic of UI testing in Swift by covering another
great set of tools the XCTest framework provides us. I love UI testing and
protecting the primary user flows in my app. This week we will talk about the
hidden gems of the XCTest framework, which are activities and attachments.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Activity

Let’s start with the concept of the XCTest activity. When you run a UI test in
the Report navigator section of the Xcode, you can find the log of every
action you run in the particular UI test.

    
    
    final class UITests: XCTestCase {
        var app: XCUIApplication!
        
        override func setUp() {
            continueAfterFailure = false
            app = XCUIApplication()
            app.launch()
        }
        
        func testFoodLoggingFlow() {
            goToSearch()
            search(query: "Pasta")
            chooseFirstFoodItem()
            logSelectedFood()
        }
    }
    

![XCTest activity](/public/test-activity-1.png)

It is excellent that Xcode logs every action, and we can review them later,
but it is hard to understand who is who here. And for this particular case, we
can use XCTest activities. An XCTest activity allows us to group and name a
set of actions inside the test. Let’s take a look at how we can use this API.

    
    
    final class UITests: XCTestCase {
        var app: XCUIApplication!
        
        override func setUp() {
            continueAfterFailure = false
            app = XCUIApplication()
            app.launch()
        }
        
        func testFoodLoggingFlow() {
            XCTContext.runActivity(named: "Search") { _ in
                goToSearch()
                search(query: "Pasta")
            }
            
            XCTContext.runActivity(named: "Saving") { _ in
                chooseFirstFoodItem()
                logSelectedFood()
            }
        }
    }
    

As you can see in the example above, we use the _runActivity_ function on the
_XCTContext_ type. This function accepts two parameters: the name of the
activity and the closure defining the activity. It allows us to easily group
and name actions in the test and review them in the report navigator much more
easily.

![XCTest activity](/public/test-activity-2.png)

####  Attachment

The second great feature of the XCTest framework is the concept of
attachments. You can add attachments to any test case or activity. For
example, it might be a screenshot of the current state of your app while
running a particular action. Let’s see how we can use the XCTest activity to
add some screenshots.

    
    
    protocol Screen {
        var app: XCUIApplication { get }
    }
    
    extension Screen {
        func takeScreenshot() {
            XCTContext.runActivity(named: "Screenshot") { activity in
                let screenshot = app.screenshot()
                let attachment = XCTAttachment(screenshot: screenshot)
                attachment.lifetime = .keepAlways
                activity.add(attachment)
            }
        }
    }
    

As you can see in the example above, we use the _XCTContext_ to run an
activity and use the _add_ function on the _XCTActivity_ type to attach the
screenshot. But keep in mind that the _XCTAttachment_ type allows us to attach
screenshots and any instance of _String_ and _Data_ types or the content of a
file.

    
    
    struct FeedScreen: Screen {
        let app: XCUIApplication
        
        func goToSearch() -> SearchScreen {
            app.buttons["Add"].firstMatch.tap()
            XCTAssertTrue(app.buttons["Search"].waitForExistence(timeout: 3))
            app.buttons["Search"].tap()
            XCTAssertTrue(app.navigationBars.staticTexts["Search"].waitForExistence(timeout: 3))
            takeScreenshot()
            return SearchScreen(app: app)
        }
    }
    
    struct SearchScreen: Screen {
        let app: XCUIApplication
        
        func search(query: String) -> Self {
            app.searchFields.firstMatch.tap()
            app.searchFields.firstMatch.typeText("pasta")
            takeScreenshot()
            return self
        }
        
        func verifyResults(contain text: String) -> Self {
            let cell = app.collectionViews.cells.element(boundBy: 0)
            XCTAssertTrue(cell.waitForExistence(timeout: 3))
            XCTAssertTrue(cell.accessibilityValue?.contains(text) ?? false)
            return self
        }
    }
    

I’m a big fan of the Page Object pattern and build my UI tests suite using it.
I define the _Screen_ protocol that every Page Object in my app conforms to.
It contains many useful functions, one of which is the _takeScreenshot_
function.

> To learn about the Page Object pattern I’ve used in the example above, take
> a look at my [ “UI Testing using Page Object pattern in Swift”
> ](/2021/03/24/ui-testing-using-page-object-pattern-in-swift/) post.
    
    
    import XCTest
    
    final class UITests: XCTestCase {
        var app: XCUIApplication!
        
        override func setUp() {
            continueAfterFailure = false
            app = XCUIApplication()
            app.launch()
        }
    
        func testSearchFlow() {
            FeedScreen(app: app)
                .goToSearch()
                .search(query: "Pasta")
                .verifyResults(contain: "PASTA")
        }
    }
    

And finally, we can review and save all of these attachments in the Report
navigator section of the Xcode. It allows us to do many exciting things. For
example, you can run a UI tests suite that goes through the main flows of your
app and collects screenshots for the App Store page. And you can run it under
different locales to automate collecting app screenshots.

![XCTest activity](/public/test-activity-3.png)

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering search in SwiftUI

##  Mastering search in SwiftUI

23 Jun 2021

SwiftUI Release 3.0 brought tons of expected features that we missed in
previous iterations. One of them is the ability to provide the search feature
in our apps. Fortunately, we have a new _searchable_ view modifier. This week,
we will learn about the new _searchable_ modifier and how to build a great
search experience using it.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

We can mark the content of our view as searchable using the new view modifier.
SwiftUI understands the structure of your app and displays the search bar in
the appropriate place. Let’s take a look at the quick example.

    
    
    struct RootView: View {
        @State private var query: String = ""
    
        var body: some View {
            NavigationView {
                Master()
                Details()
            }
            .searchable(text: $query, prompt: Text("Search"))
        }
    }
    

![search](/public/search.png)

We attach the _searchable_ view modifier to the _NavigationView_ at the root
of our app. SwiftUI can put the search bar in different places depending on
the environment. For example, it will put a search bar in the _Master_ view on
iOS and iPadOS. On macOS, SwiftUI places the search bar in the toolbar of the
trailing column of the _NavigationView_ .

    
    
    struct RootView: View {
        @State private var query: String = ""
    
        var body: some View {
            NavigationView {
                Master()
                Details()
            }
            .searchable(
                text: $query,
                placement: .toolbar,
                prompt: "Type something..."
            )
        }
    }
    

You can also suggest placement for the search bar using the _placement_
parameter, but keep in mind that SwiftUI can ignore it. A few possible
placements for the search bar are _automatic_ , which is the default one,
_sidebar, toolbar, and navigationBarDrawer._

    
    
    struct ContentView: View {
        @StateObject private var viewModel = SearchViewModel()
        @State private var query = ""
    
        var body: some View {
            NavigationView {
                List(viewModel.repos) { repo in
                    VStack(alignment: .leading) {
                        Text(repo.name)
                            .font(.headline)
                        Text(repo.description ?? "")
                            .foregroundColor(.secondary)
                    }
                }
                .navigationTitle("Search")
                .searchable(text: $query)
                .onChange(of: query) { newQuery in
                    Task { await viewModel.search(matching: query) }
                }
            }
        }
    }
    

Whenever we use the _searchable_ modifier, we should provide a binding to a
string value. We can observe changes and filter our content depending on the
query term using that binding.

    
    
    struct ContentView: View {
        @StateObject private var viewModel = SearchViewModel()
        @State private var searchShown = false
        @State private var query = ""
    
        var body: some View {
            NavigationView {
                List(viewModel.repos) { repo in
                    VStack(alignment: .leading) {
                        Text(repo.name)
                            .font(.headline)
                        Text(repo.description ?? "")
                            .foregroundColor(.secondary)
                    }
                }
                .navigationTitle("Search")
                .searchable(text: $query, isPresented: $searchShown)
                .onChange(of: query) { newQuery in
                    Task { await viewModel.search(matching: query) }
                }
                .onAppear {
                    searchShown = true
                }
            }
        }
    }
    

We can also control the search visibility programmatically by using the
_isPresented_ parameter of the _searchable_ view modifier accepting a boolean
binding defining the current visibility of the search.

####  Environment

SwiftUI provides us _isSearching_ environment value that indicated whether the
user is currently interacting with the search bar that has been placed by a
surrounding _searchable_ modifier. We can use this value to understand whether
to show quick search results.

    
    
    struct StarredReposList: View {
        @StateObject var viewModel = SearchViewModel()
        @Environment(\.dismissSearch) var dismissSearch
        @Environment(\.isSearching) var isSearching
    
        let query: String
    
        var body: some View {
            List(viewModel.repos) { repo in
                RepoView(repo: repo)
            }
            .overlay {
                if isSearching && !query.isEmpty {
                    VStack {
                        Button("Dismiss search") {
                            dismissSearch()
                        }
                        SearchResultView(query: query)
                            .environmentObject(viewModel)
                    }
                }
            }
        }
    }
    

Another search-related environment value we have is _dismissSearch_ .
_dismissSearch_ asks the system to dismiss the current search interaction.
Remember that both environment values work only in the views surrounded by the
_searchable_ modifier.

> To learn more about environment in SwiftUI, take a look at my [ “The power
> of Environment in SwiftUI” ](/2019/08/21/the-power-of-environment-in-
> swiftui/) post.

####  Suggestions

Suggestions are a vital part of the excellent search experience, and SwiftUI
gives us a very nice API that we can use to provide search suggestions to our
users. The _searchSuggestions_ view modifier allows us to pass a
_@ViewBuilder_ closure displaying search suggestions. Let’s see how we can use
it.

    
    
    struct ContentView: View {
        @StateObject private var viewModel = SearchViewModel()
        @State private var query = ""
    
        let suggestions: [String] = [
            "Swift", "SwiftUI", "Obj-C"
        ]
    
        var body: some View {
            NavigationView {
                List(viewModel.repos) { repo in
                    VStack(alignment: .leading) {
                        Text(repo.name)
                            .font(.headline)
                        Text(repo.description ?? "")
                            .foregroundColor(.secondary)
                    }
                }
                .navigationTitle("Search")
                .searchable(text: $query)
                .searchSuggestions {
                    ForEach(suggestions, id: \.self) { suggestion in
                        Text(suggestion)
                            .searchCompletion(suggestion)
                    }
                }
                .onChange(of: query) { newQuery in
                    Task { await viewModel.search(matching: query) }
                }
            }
        }
    }
    

![search-suggestions](/public/search1.png)

As you can see in the example above, we use the _searchSuggestions_ view
modifier and provide a _@ViewBuilder_ closure with _ForEach_ view that
iterates over an array of suggestions. We also use the _searchCompletion_ view
modifier to wrap every text view in a button that assigns its value to the
search query binding.

Keep in mind that _searchCompletion_ modifier wraps its content in a _Button_
. It means you should apply it to the view that doesn’t have user interaction
like _Text_ or _Label_ .

####  Scopes

The SwiftUI framework provides us another view modifier allowing us to improve
search experience. We can use the _searchScopes_ view modifier to provide
search scopes displayed in the segmented control under the search bar.

    
    
    struct ContentView: View {
        @State private var query = ""
        @State private var scope: Scope = .local
        
        var body: some View {
            NavigationStack {
                List {
                    // ...
                }
                .searchable(text: $query)
                .searchScopes($scope) {
                    ForEach(Scope.allCases, id: \.self) { scope in
                        Text(scope.rawValue)
                    }
                }
            }
        }
    }
    

####  Tokens

Another version of the _searchable_ view modifier allows us to display tokens
in the search bar.

    
    
    struct Token: Identifiable {
        let id = UUID()
        let value: String
    }
        
    struct ContentView: View {
        @State private var query = ""
        @State private var tokens: [Token] = []
        @State private var suggestedTokens: [Token] = [
            .init(value: "Token1"),
            .init(value: "Token2"),
            .init(value: "Token3"),
            .init(value: "Token4")
        ]
        
        var body: some View {
            NavigationStack {
                List {
                    // ...
                }
                .searchable(
                    text: $query,
                    tokens: $tokens,
                    suggestedTokens: $suggestedTokens
                ) { token in
                    Text(verbatim: token.value)
                }
                .navigationTitle("Search")
            }
        }
    }
    

In the example above, we use the _searchable_ view modifier and pass two
bindings for suggested tokens and selected tokens. The SwiftUI displays
suggested tokens and move them into the search bar as soon as user taps one of
them. It also moves the token from the suggested collection to the selected
collection of tokens.

    
    
    struct ContentView: View {
        @State private var query = ""
        @State private var tokens: [Token] = []
        
        var body: some View {
            NavigationStack {
                List {
                    // ...
                }
                .searchable(
                    text: $query,
                    tokens: $tokens
                ) { token in
                    Text(verbatim: token.value)
                }
                .navigationTitle("Search")
                .onChange(of: query) { newValue in
                    if newValue.contains("new") {
                        tokens.append(.init(value: "NEW"))
                    }
                }
            }
        }
    }
    

Another variation of the _searchable_ view modifier allows us to manually
filter the query and populate tokens.

####  Conclusion

Today we learned how to build a great search experience using the brand new
_searchable_ view modifier. It is incredible how easy you can make things like
suggestions, the platform adopted placement using the only _searchable_ view
modifier. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Measuring app performance in Swift

##  Measuring app performance in Swift

04 May 2022

The Unified Logging System is a great way to build a proper logging system
allowing you to understand different exceptional cases happening in your app.
But it is not limited only to logging. It also provides a way to measure
various events in your app. This week, we will learn how to use the Unified
Logging System to measure app performance.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Measuring app events

The Unified Logging System provides us with the Signpost API, which is a way
to measure various time intervals in your app. Let’s take a look at how we can
use it in a small example.

    
    
    @MainActor final class TimerStore: ObservableObject {
        private static let logger = Logger(
            subsystem: "com.aaplab.fastbot",
            category: "TimerStore"
        )
        private static let signposter = OSSignposter(logger: logger)
        
        @Published private(set) var accountStatus: CKAccountStatus = .couldNotDetermine
        @Published private(set) var recentFasting: Fasting? = nil
        
        private let service = CloudKitService()
        
        func fetchRecent() async {
            let signpostID = Self.signposter.makeSignpostID()
    
            let interval = Self.signposter.beginInterval("Fetching recent", id: signpostID)
            do {
                accountStatus = try await service.checkAccountStatus()
                recentFasting = try await service.fetchAllFastingRecords().last
                Self.signposter.endInterval("Fetching recent", interval)
            } catch {
                Self.signposter.endInterval("Fetching recent", interval)
            }
        }
    }
    

First, we need to import the _OSLog_ module that contains the Unified Logging
System API. Then we create an instance of the _OSSignposter_ type that we will
use to track event intervals. We use the _makeSignpostID_ function on the
_OSSignposter_ type to create a unique event identifier.

> To learn about basics of the Unified Logging System, take a look at my [
> “Logging in Swift” ](/2022/04/06/logging-in-swift/) post.

Now we can use the identifier to start monitoring an event with a particular
message using the _beginInterval_ function. This function returns a state of
the interval that we will use to associate starting and finishing points of an
event. As the last step, we call the _endInterval_ function by passing a
message and the interval state.

> Remember that the message you use while beginning and ending intervals
> should be the same.

Another thing we might need is attaching metadata to a signpost interval. For
example, we can bind a localized error description whenever interval ends with
an error.

    
    
    func fetchRecent() async {
        let signpostID = Self.signposter.makeSignpostID()
    
        let interval = Self.signposter.beginInterval("Fetching recent", id: signpostID)
        do {
            accountStatus = try await service.checkAccountStatus()
            recentFasting = try await service.fetchAllFastingRecords().last
            Self.signposter.endInterval("Fetching recent", interval)
        } catch {
            Self.signposter.endInterval("Fetching recent", interval, "\(error.localizedDescription, privacy: .public)")
        }
    }
    

We can also emit intermediate events inside a particular interval. It might be
helpful to divide a multi-step event into timepieces to understand which part
of the event is slowing the app.

    
    
    func fetchRecent() async {
        let signpostID = Self.signposter.makeSignpostID()
    
        let interval = Self.signposter.beginInterval("Fetching recent", id: signpostID)
        do {
            accountStatus = try await service.checkAccountStatus()
            Self.signposter.emitEvent("Account status fetched", id: signpostID)
            recentFasting = try await service.fetchAllFastingRecords().last
            Self.signposter.endInterval("Fetching recent", interval)
        } catch {
            Self.signposter.endInterval("Fetching recent", interval, "\(error.localizedDescription, privacy: .public)")
        }
    }
    

In the example above, we use the _emitEvent_ function on the _OSSignposter_
type to emit additional events connected to a particular signpost identifier.

####  Collecting performance data

OK, we learned how to measure app events using the _Signposter_ type. Now it
is time to learn how to read that data to analyze our app performance. There
are two ways of reading the data written by the _Signposter_ type.

First, we can use the Instruments app to visualize all the performance data
nicely. The second is a programmatic way of exporting performance data from
the user devices using the _OSLogStore_ type.

Let’s start with the simplest one. While debugging your app via Xcode, you can
build the app for profiling by pressing CMD + I. In the opened Instruments
app, choose the Logging template. It contains both logs and signposts. Now run
the app by pressing the record button and start interacting and producing
events in your app.

![instruments-logging-template](/public/signpost.png)

Instruments app is a great way to profile your app locally, but sometimes we
need data from the user devices. In this case, we can export the signpost data
using the _OSLogStore_ type.

    
    
    import OSLog
    import Foundation
    
    @MainActor final class LogStore: ObservableObject {
        private static let logger = Logger(
            subsystem: Bundle.main.bundleIdentifier!,
            category: String(describing: LogStore.self)
        )
    
        @Published private(set) var entries: [String] = []
    
        func exportPerformanceData() {
            do {
                let store = try OSLogStore(scope: .currentProcessIdentifier)
                let position = store.position(timeIntervalSinceLatestBoot: 1)
                entries = try store
                    .getEntries(at: position)
                    .compactMap { $0 as? OSLogEntrySignpost }
                    .filter { $0.subsystem == Bundle.main.bundleIdentifier! }
                    .map { "[\($0.date.formatted())] [\($0.category)] [\($0.signpostType)] \($0.signpostName)" }
            } catch {
                Self.logger.warning("\(error.localizedDescription, privacy: .public)")
            }
        }
    }
    

> To learn more about the power of _OSLogStore_ type, take a look at my [
> “Exporting data from Unified Logging System in Swift”
> ](/2022/04/19/exporting-data-from-unified-logging-system-in-swift/) post.

####  Conclusion

Today we learned how to use the Unified Logging System to measure and collect
performance data of our apps. Understanding the performance of particular
events is crucial for building a great user experience. Fortunately, we can
quickly achieve that by using the Unified Logging System. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Hiding third-party dependencies with protocols and extensions

##  Hiding third-party dependencies with protocols and extensions

13 Feb 2019

There are plenty of discussions on the Internet about using third-party
dependencies in your apps. The first part of developers suggest ignoring the
usage of libraries and write all the code yourself. The second part recommends
using third-party dependencies to speed up app development.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Sometimes it is better to use a well-tested library, rather than implementing
it yourself. A good example here is Cryptography. Cryptography is hard, and it
is effortless to make a mistake during the implementation of some common
cryptography algorithms. It is an excellent example of a situation where we
should use a third-party library.

But here we can face another problem when the author of the library abandoned
it or didn’t update for the next Swift version. In this case, we have to
replace this library with another one or implement our solution. It can be
tough to remove the library if you use it across the codebase.

So this week we will talk about two techniques which help us to hide our
third-party dependencies and make them easy to replace and refactor.

####  Extensions

Most of our apps fetch and display some data via API, very often we have some
image URLs which should be downloaded and cached on the disk/memory. There are
a lot of great libraries for downloading and caching images from the internet.
Most famous is Kingfisher.

It has an extension for UIImageView class which brings setImage method. We can
easily use this method anywhere in our codebase by importing Kingfisher
framework and calling setImage method on UIImageView.

Assume that we need to replace KingFisher with another library like
AlamofireImage. In this case, we have to go through the codebase, replace all
Kingfisher imports and setImage method calls to AlamofireImage import and
af_setImage method calls respectively. It is going to be tremendous work in
case of a huge codebase. Let’s check how we can use extensions to fix this
problem.

    
    
    import UIKit
    import Kingfisher
    
    extension UIImageView {
        func setImage(from url: URL) {
            kf.setImage(with: url)
        }
    }
    

As you can see in the code sample above, we create an UIImageView extension
with setImage method, which calls KingFisher framework’s setImage method.
Using this extension across the project give us an opportunity to replace
KingFisher framework with any other library with a single file change. The
only thing we need to change is the implementation of our setImage method.

####  Protocols

Another excellent example of a third-party dependency can be a Keychain access
library. Keychain is the safest place on iOS device to keep user sensitive
data like access tokens and passwords. Apple provides us with such ugly string
based API for Keychain access, that’s why I decide to use third-party wrapper
around Apple’s API. Here is an example of KeychainSwift library usage.

    
    
    let keychain = KeychainSwift()
    keychain.set("hello world", forKey: "my key")
    keychain.get("my key") // Returns "hello world"
    

KeychainSwift library provides nice key-value API for Keychain access. But I
don’t want to expose library usage across the codebase. Let’s create a
protocol which defines user sensitive datastore and hides library usage.

    
    
    protocol TokenStore {
        var accessToken: String { get set }
        var refreshToken: String { get set }
    }
    

Next step is adding TokenStore protocol conformance to KeychainSwift library.

    
    
    extension KeychainSwift: TokenStore {
        private enum Keys {
            static let accessToken = "accessToken"
            static let refreshToken = "refreshToken"
        }
    
        var accessToken: String {
            get { return get(Keys.accessToken) }
            set { set(newValue, forKey: Keys.accessToken) }
        }
    
        var refreshToken: String {
            get { return get(Keys.refreshToken) }
            set { set(newValue, forKey: Keys.refreshToken)}
        }
    }
    

And now we can pass TokenStore protocol across our codebase instead of
exposing usage of KeychainSwift library.

    
    
    class AuthenticationService {
        private let tokenStore: TokenStore
    
        init(tokenStore: TokenStore) {
            self.tokenStore = tokenStore
        }
    
        func fetchToken(for credentials: Credentials) {
    //        Save tokens here
    //        tokenStore.accessToken =
    //        tokenStore.refreshToken =
        }
    }
    

The single place which knows about KeychainSwift library should be a
dependency container which creates AuthenticationService object. More about
Dependency Injection we will talk in the next posts.

####  Conclusion

Today we discussed how we could use protocols and extensions to build tiny
abstractions which hide third-party dependencies and make our codebase safer.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading and see you next week!



# Redux-like state container in SwiftUI. Container Views.

##  Redux-like state container in SwiftUI. Container Views.

02 Oct 2019

This week I want to continue the topic of using a _Redux-like state container
in SwiftUI_ . I’m delighted with the new approach and already finished the
refactoring of the [ NapBot app ](https://napbot.swiftwithmajid.com) in this
way. That’s why today I want to share with you how I use _Container Views_
with a state container similar to _Redux_ .

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In previous weeks we already discussed the basics and some good practices
while using _Redux-like state containers_ . If you are not familiar with
_Redux_ , please take a look at those posts to understand how to build it in
SwiftUI and which benefits you get by using it.

  1. [ Redux-like state container in SwiftUI. Basics ](/2019/09/18/redux-like-state-container-in-swiftui/)
  2. [ Redux-like state container in SwiftUI. Best practices ](/2019/09/25/redux-like-state-container-in-swiftui-part2/)

The container which holds the whole app’s state as a single source of truth
simplifies my codebase and eliminates a bunch of bugs that I had during manual
sync between multiple states across the app screens.

> To learn more about modeling app state using multiple store objects, take a
> look at my dedicated [ “Modeling app state using Store objects in SwiftUI”
> ](/2019/09/04/modeling-app-state-using-store-objects-in-swiftui/) post.

####  Container Views

Today, I want to touch another subject from my previous posts which plays very
nice in conjunction with a _Redux-like state container_ , and this is
_Container Views_ . _Container Views_ help us to keep our SwiftUI views simple
and responsible for only one job.

The main idea is dividing your views into two types: _Container Views and
Rendering Views_ . The _Rendering View_ is responsible for drawing the
content, and that’s all. So basically it should not store the state or handle
any lifecycle event. It usually renders the data which you pass via the init
method.

_Container View_ , on another hand, is responsible for handling data-flow and
lifecycle events by providing the functions/closures to a _Rendering View_ .
Let’s take a look at a simple example.

    
    
    import SwiftUI
    
    struct SearchContainerView: View {
        @EnvironmentObject var store: ReposStore
        @State private var query: String = "Swift"
    
        var body: some View {
            SearchView(query: $query, repos: store.repos, onCommit: fetch)
                .onAppear(perform: fetch)
        }
    
        private func fetch() {
            store.fetch(matching: query)
        }
    }
    
    struct SearchView: View {
        @Binding var query: String
    
        let repos: [Repo]
        let onCommit: () -> Void
    
        var body: some View {
            List {
                TextField("Type something", text: $query, onCommit: onCommit)
                ReposView(repos: repos)
            }
        }
    }
    
    struct ReposView: View {
        let repos: [Repo]
    
        var body: some View {
            ForEach(repos) { repo in
                HStack(alignment: .top) {
                    VStack(alignment: .leading) {
                        Text(repo.name)
                            .font(.headline)
                        Text(repo.description ?? "")
                            .font(.subheadline)
                    }
                }
            }
        }
    }
    

In the example above, you can see how we build a connection between _Container
and Rendering views_ . _Container View_ provides the data to _Rendering Views_
. By doing this, we can easily reuse our _ReposView_ anywhere across the app.
_ReposView_ doesn’t have any dependency on some state or datastore and gets
all the needed data via the init method.

> To learn more about _Container Views_ , take a look at [ “Introducing
> Container views in SwiftUI” post ](/2019/07/31/introducing-container-views-
> in-swiftui/) .

####  Using Container Views with Redux-like state container

During my transition from multiple stores to a single source of truth, I
realize that _Container Views_ play a significant role in this approach. I
mainly use them for sending actions to the store and mapping the global app
state to _Rendering View_ properties. _Container Views_ perfectly fit into my
current app architecture. Let’s take a look at the example.

    
    
    import SwiftUI
    
    struct SearchContainerView: View {
        @EnvironmentObject var store: AppStore
        @State private var query: String = "Swift"
    
        var body: some View {
            SearchView(
                query: $query,
                repos: store.state.search.result,
                onCommit: fetch
            ).onAppear(perform: fetch)
        }
    
        private func fetch() {
            store.send(SideEffect.search(query))
        }
    }
    
    struct SearchView: View {
        @Binding var query: String
    
        let repos: [Repo]
        let onCommit: () -> Void
    
        var body: some View {
            List {
                TextField("Type something", text: $query, onCommit: onCommit)
                ReposView(repos: repos)
            }
        }
    }
    

As you can see in the example above, _Container View_ helps us to keep
_Rendering Views_ small and independent.

####  Conclusion

Today we talked about the benefits of using _Container Views with Redux-like
state containers_ . I love this approach and use it as my main way to go with
SwiftUI. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!

  1. [ Redux-like state container in SwiftUI. Basics ](/2019/09/18/redux-like-state-container-in-swiftui/)
  2. [ Redux-like state container in SwiftUI. Best practices ](/2019/09/25/redux-like-state-container-in-swiftui-part2/)
  3. Redux-like state container in SwiftUI. Container Views. 
  4. [ Redux-like state container in SwiftUI. Connectors. ](/2021/02/03/redux-like-state-container-in-swiftui-part4/)
  5. [ Redux-like state container in SwiftUI. Swift concurrency model. ](/2022/02/17/redux-like-state-container-in-swiftui-part5/)

####  References

The series of posts have built on a foundation of ideas started by other
libraries, particularly Redux, Elm, and TCA.

  1. [ WWDC20 - Data Essentials in SwiftUI ](https://developer.apple.com/videos/play/wwdc2020/10040/)
  2. [ Redux ](https://redux.js.org) \- The JavaScript library that popularized unidirectional data flow. 
  3. [ The Elm Architecture ](https://guide.elm-lang.org/architecture/) \- A purely functional language and runtime that inspired the creation of Redux. 
  4. [ The Composable Architecture ](https://github.com/pointfreeco/swift-composable-architecture) \- A library that bridges concepts from the Elm Architecture and Redux to Swift. It introduced the “environment” and “effect” patterns that this series covers. 



# Discovering Swift Collections package

##  Discovering Swift Collections package

19 Feb 2024

I want to continue the topic of the valuable Swift packages that I use in my
apps. This time, we will talk about the Swift Collections package, providing
us with a bunch of helpful collection types that Swift language doesn’t
include out of the box.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The Swift Collections package contains a few collection types that may help
you improve the performance of your apps if you apply them whenever needed
instead of using generic _Array_ , _Dictionary_ , and _Set_ types. The [ Swift
Collections ](https://github.com/apple/swift-collections) package lives on
Github, where you can find it and add to your project.

####  Tree-based dictionary and set

_Dictionary_ and _Set_ types that Swift language provides us store values in a
single flat hash table that you copy on every write or mutation. The Swift
Collection package introduces _TreeDictionary_ and _TreeSet_ types
implementing Compressed Hash-Array Mapped Prefix Trees. In other words,
_TreeDictionary_ and _TreeSet_ types hold values in the tree-based structure,
allowing the efficient updating of only the needed branches.

Imagine a calendar app where you store an event array per date and use the
standard _Dictionary_ type. You might need to implement paging and load events
per visible month and store them in an instance of the _Dictionary_ type.
While the user scrolls through months, your app loads a bunch of events and
copies the whole dictionary on every load, even when previously loaded events
didn’t change.

    
    
    @Observable final class CalendarStore {
        typealias Fetch = (DateInterval) async -> [Event]
        
        private(set) var events: TreeDictionary<Date, [Event]> = [:]
        private let fetch: Fetch
        
        init(fetch: @escaping Fetch) {
            self.fetch = fetch
        }
        
        func fetchEvents(inside interval: DateInterval) async {
            let newEvents = await fetch(interval)
            let groupedByDate = TreeDictionary(grouping: newEvents, by: \.date)
            events.merge(groupedByDate) { $1 }
        }
    }
    

For this case, the Swift Collections package introduces the _TreeDictionary_
and _TreeSet_ types that link the unchanged parts with the changed branches
under the hood without copying the whole dictionary into the memory. The
_TreeDictionary_ type provides us with the very same APIs that the
_Dictionary_ type has and optimizes memory for us under the hood.

The _TreeDictionary_ is still a struct, but the implementation uses the
_UnsafeMutablePointer_ type to access memory and mutate it directly without
copying on write. Another benefit of the _TreeDictionary_ and _TreeSet_ types
is the optimized way to compare because of their tree-based nature. Usually,
they handle this operation in a constant time.

    
    
    let oldEvents: TreeDictionary<Date, [Event]> = //...
    let newEvents: TreeDictionary<Date, [Event]> = //...
        
    newEvents.keys.subtracting(oldEvents.keys)
    

####  Min-max heap

Another tree-based structure that the Swift Collections package provides us is
the _Heap_ type. The _Heap_ type stores comparable elements and allows you to
query for the minimal or maximal element quickly.

    
    
    struct Event: Identifiable, Comparable {
        static func < (lhs: Event, rhs: Event) -> Bool {
            lhs.priority < rhs.priority
        }
        
        let id = UUID()
        let date: Date
        let priority: Int
    }
    
    @Observable final class EventStore {
        typealias Fetch = () async -> [Event]
        
        private(set) var events: Heap<Event> = []
        private let fetch: Fetch
        
        init(fetch: @escaping Fetch) {
            self.fetch = fetch
        }
        
        var nextEvent: Event? { events.max }
        
        func fetchEvents() async {
            let allEvents = await fetch()
            events.insert(contentsOf: allEvents)
        }
    }
    

As you can see in the example above, we fetch the calendar events and populate
the heap with them. The _Event_ type conforms to the _Comparable_ protocol and
allows us to get the minimal and maximal elements depending on the event
priority.

    
    
    @Observable final class EventStore {
        private(set) var events: Heap<Event> = []
        
        func printEvents() {
            for event in events.unordered {
                print(event)
            }
        }
    }
    

You can access the unordered read-only array of elements stored in the _Heap_
type whenever needed. Remember that you can’t access the sorted collection of
items from the heap. It is, after all, a heap.

####  Ordered dictionary and set

How often do you need to access values in a set or dictionary in the order you
have added them? Unfortunately, the flat hash table that _Dictionary_ and
_Set_ types use doesn’t allow to keep the adding order of elements. The Swift
Collection package introduces the _OrderedSet_ and _OrderedDictionary_ types
to solve the issue.

    
    
    let letters: OrderedSet = ["a", "b", "c"]
        
    for element in letters {
        print(element)
    }
        
    print(letters[0])
    print(letters.contains("b"))
    print(letters.isSuperset(of: ["a", "b", "c", "d"]))
    

The _OrderedSet_ type allows us to access the element by index like the
_Array_ type but keeps elements unique.

    
    
    printArray(letters.elements) // Array
    printSet(letters.unordered) // Set
    

Whenever you need to pass the elements of the _OrderedSet_ as an _Array_ , you
can use the _elements_ property, or you can use the _unordered_ property
whenever you want to extract the plain _Set_ of the elements. Remember, the
_OrderedSet_ type implements most of the functions from the _SetAlgebra_
protocol but doesn’t conform to it, that’s why it has the _unordered_
property.

    
    
    let lettersAndNumbers: OrderedDictionary = [
        "a": 1,
        "b": 2,
        "c": 3
    ]
        
    print(lettersAndNumbers["a"])
    print(lettersAndNumbers.elements[0])
    

The _OrderedDictionary_ behaves very similarly to the _OrderedSet_ type and
allows you to access the dictionary both by key and index.

####  Deque

_Deque_ is another collection type that the Swift Collections package provides
us. _Deque_ is almost identical to the _Array_ type, except it offers
efficient insert and removal from both ends of the collection.

    
    
    var deque: Deque = [1, 2, 3, 4]
    
    deque.prepend(0)
    deque.append(5)
    deque.popFirst()
    deque.popLast()
        
    deque[0]
    

The _Deque_ type implements a double-ended queue, allowing us to insert and
remove elements from the ends of the collection at O(1) complexity, which may
become very handy when you build any queue functionality in your app.

####  Conclusion

Today, we discovered another great Swift package provided by Apple. The
community constantly works on the package and adds more value to it. So, check
the documentation and find the valuable collection types that may improve your
apps. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering GroupBox in SwiftUI

##  Mastering GroupBox in SwiftUI

15 Oct 2020

Styleable views is the thing I love in SwiftUI. You can separate your view
logic and its style. You can easily apply different styles in different
conditions whenever you need to change appearance depending on the platform or
other environmental requirements. This week we will talk about _GroupBox_ ,
another view container that SwiftUI provides, and allows us easily change its
look and feel using a style protocol.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

_GroupBox_ is a stylized view with an optional label that is associated with a
logical grouping of content. Default styling on iOS is a simple card with the
title and content. Let’s take a look at it.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            GroupBox(
                label: Label("Heart Rate", systemImage: "heart.fill")
                    .foregroundColor(.red)
            ) {
                Text("Your hear rate is 90 BPM.")
            }.padding()
        }
    }
    

![group-box](/public/groupbox1.png)

As you can see in the example above, the default styling of _GroupBox_ is a
card with the system grouped background and continuous corner radius. It looks
similar to cards that we used to see in the Apple Health app or Apple Fitness
app. I should mention that it can look differently on different Apple
platforms. It is available for macOS and iOS now, but I hope to see it on
watchOS and tvOS during the next iteration of SwiftUI.

Cards are great, and I use them a lot in my apps. You can use _GroupBox_ as
the root container for every item in your grid or stack, and you will gain a
modest card-based look and feel.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                LazyVGrid(columns: [.init(), .init()]) {
                    ForEach(0..<10) { _ in
                        GroupBox(
                            label: Label("Heart Rate", systemImage: "heart.fill")
                                .foregroundColor(.red)
                        ) {
                            Text("Your hear rate is 90 BPM.")
                        }.groupBoxStyle(PlainGroupBoxStyle())
                    }
                }.padding()
            }
        }
    }
    

![group-box](/public/groupbox2.png)

As you can see, SwiftUI provides nice card-based styling for _GroupBox_ view
by default. Sometimes it is not what we need. For example, when you place
_GroupBox_ inside a grouped _List_ , it looks like a card inside a card.
Fortunately, we can tune the look and feel using the _GroupBoxStyle_ protocol.

> To learn more about grids in SwiftUI, take a look at my [ “Mastering grids
> in SwiftUI” ](/2020/07/08/mastering-grids-in-swiftui/) post.

####  Styling

SwiftUI provides us the _GroupBoxStyle_ protocol that allows us to change the
look and feel of any _GroupBox_ instance completely. We can create different
styles for any use-cases we need. For example, I don’t need a background and
corner radius when I use _GroupBox_ inside a _List_ .

    
    
    struct PlainGroupBoxStyle: GroupBoxStyle {
        func makeBody(configuration: Configuration) -> some View {
            VStack(alignment: .leading) {
                configuration.label
                configuration.content
            }
        }
    }
    
    struct ContentView: View {
        var body: some View {
            GroupBox(
                label: Label("Heart Rate", systemImage: "heart.fill")
                    .foregroundColor(.red)
            ) {
                Text("Your hear rate is 90 BPM.")
            }.groupBoxStyle(PlainGroupBoxStyle())
        }
    }
    

All you need to do to create your own _GroupBox_ style is create a struct that
conforms to _GroupBoxStyle_ protocol. _GroupBoxStyle_ has the only
requirement. You have to create a _makeBody_ function that accepts an instance
of _GroupBoxStyleConfiguration_ type and returns a new view.

_GroupBoxStyleConfiguration_ provides us both the label and content of our
_GroupBox_ . You can use them inside the _makeBody_ function as you need. Our
_PlainGroupBoxStyle_ example put the label and content view inside a _VStack_
with leading alignment and returns the stack.

You can set the style by using the _groupBoxStyle_ modifier. SwiftUI will
share it using environment across all children of the view hierarchy.

![group-box](/public/groupbox3.png)

You can create super custom _GroupBox_ styles. To show more complex styling
options, let’s replicate the default card-based layout.

    
    
    struct CardGroupBoxStyle: GroupBoxStyle {
        func makeBody(configuration: Configuration) -> some View {
            VStack(alignment: .leading) {
                configuration.label
                configuration.content
            }
            .padding()
            .background(Color(.systemGroupedBackground))
            .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
        }
    }
    

As you can see, we are able to create any _GroupBox_ style we need. Another
option might be a style that hides the label or something else.

> To learn more about other styling protocols available in SwiftUI, take a
> look at [ “Mastering buttons in SwiftUI” ](/2020/02/19/mastering-buttons-in-
> swiftui/) post.

####  Conclusion

_GroupBox_ provides us a simple card-based look and feel that we used to see
in many apps on iOS. The great thing about _GroupBox_ that it allows us to
customize its appearance as we need. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this article. Thanks for reading, and see you next week!



# Gestures in SwiftUI

##  Gestures in SwiftUI

10 Jul 2019

SwiftUI has a powerful and easy to use approach in building _Gestures_ . Today
we will talk about how we can use gestures in SwiftUI. We will touch special
_GestureState Property Wrapper_ which is very similar to _State_ but works
only with gestures. Finally, we will build swipeable Tinder cards as a sample
project.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Gesture modifier

SwiftUI provides a bunch of ready to use gestures like _TapGesture,
DragGesture, RotationGesture, MagnificationGesture, LongPressGesture_ . You
can use them by attaching gesture modifier to any view. Let’s take a look at a
code sample.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @GestureState var isLongPressed = false
    
        var body: some View {
            let longPress = LongPressGesture()
                .updating($isLongPressed) { value, state, transaction in
                    state = value
            }
    
            return Rectangle()
                .fill(isLongPressed ? Color.purple : Color.red)
                .frame(width: 300, height: 300)
                .cornerRadius(8)
                .shadow(radius: 8)
                .padding()
                .scaleEffect(isLongPressed ? 1.1 : 1)
                .gesture(longPress)
                .animation(.interactiveSpring(), value: isLongPressed)
        }
    }
    

Here we use @ _GestureState Property Wrapper_ to bind gesture value changes to
_isLongPressed_ property. To attach gesture changes to @ _GestureState_
property, we have to call _updating_ method on gesture instance and pass
property wrapper with closure where we implement binding. In the current
sample, we just bind a value to the state, but in more complex gestures, we
can have here any calculations before assigning a new value to the state. Now
we can use _isLongPressed_ while declaring the view to animate changes based
on the gesture. SwiftUI will rebuild the view whenever _isLongPressed_
changes.

The critical point here is that SwiftUI reset property marked with @
_GestureState_ when gesture ended. Keep it in mind and use @ _State_ whenever
you need to store value after gesture finish.

> To learn more about _Property Wrappers_ provided by SwiftUI, take a look at
> my [ “Understanding Property Wrappers in SwiftUI” post
> ](/2019/06/12/understanding-property-wrappers-in-swiftui/) .

As a result, we have a red rectangle which scales and change color to purple
during a long-press gesture. As soon as gesture finishes SwiftUI resets
_isLongPressed_ to initial false value rebuilds view to show red rectangle
again. All these transitions nicely animated by adding animation modifier with
interactive spring.

####  DragGesture

Let’s try to create a Tinder-like swipeable card. We will use _DragGesture_ to
track dragging. When the user finishes the dragging we have to check if
translation enough to remove the card, if not we will animate it back to the
center of the screen. Here is the implementation.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var offset: CGSize = .zero
    
        var body: some View {
            let drag = DragGesture()
                .onChanged { self.offset = $0.translation }
                .onEnded {
                    if $0.translation.width < -100 {
                        self.offset = .init(width: -1000, height: 0)
                    } else if $0.translation.width > 100 {
                        self.offset = .init(width: 1000, height: 0)
                    } else {
                        self.offset = .zero
                    }
            }
    
            return PersonView()
                .background(Color.red)
                .cornerRadius(8)
                .shadow(radius: 8)
                .padding()
                .offset(x: offset.width, y: offset.height)
                .gesture(drag)
                .animation(.interactiveSpring(), value: offset)
        }
    }
    
    struct PersonView: View {
        var body: some View {
            VStack(alignment: .leading) {
                Rectangle()
                    .fill(Color.gray)
                    .cornerRadius(8)
                    .frame(height: 300)
    
                Text("Majid Jabrayilov")
                    .font(.title)
                    .foregroundColor(.white)
    
                Text("iOS Developer")
                    .font(.body)
                    .foregroundColor(.white)
            }.padding()
        }
    }
    

Instead of using @ _GestureState_ we use @ _State_ here because when the
gesture ends, we don’t need to reset offset, we want to increase it in the
right direction to animate cart move outside the screen. Instead of using the
_updating_ method, we use _onChanged_ and _onEnded_ gesture callbacks, where
we can make our calculations and state updates. Now we have pleasant dragging
experience which is animated by spring only by adding _animation_ modifier.

> To learn more about animations in SwiftUI, please take a look at my [
> “Animations in SwiftUI” ](/2019/06/26/animations-in-swiftui/) post.

####  Composing gestures

Sometimes we need to add more than one gesture to a _View_ , and for this
special case, SwiftUI provides three ways of gesture composition.

  1. Simultaneous 
  2. Sequenced 
  3. Exclusive 

Let’s add a dragging gesture simultaneously with a long-press gesture to our
red rectangle sample.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var offset: CGSize = .zero
        @GestureState var isLongPressed = false
    
        var body: some View {
            let longPressAndDrag = LongPressGesture()
                .updating($isLongPressed) { value, state, transaction in
                    state = value
            }.simultaneously(with: DragGesture()
                .onChanged { self.offset = $0.translation }
                .onEnded { _ in self.offset = .zero }
            )
    
            return Rectangle()
                .fill(isLongPressed ? Color.purple : Color.red)
                .frame(width: 300, height: 300)
                .cornerRadius(8)
                .shadow(radius: 8)
                .padding()
                .scaleEffect(isLongPressed ? 1.1 : 1)
                .offset(x: offset.width, y: offset.height)
                .gesture(longPressAndDrag)
                .animation(.interactiveSpring(), value: offset)
                .animation(.interactiveSpring(), value: isLongPressed)
        }
    }
    

Now we can both drag and long-press our rectangle, and it changes position and
scale as expected.

####  Conclusion

SwiftUI has a powerful declarative way of handling gestures. Try to add some
delight to your app by adding gestures. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# Building custom layout in SwiftUI. LayoutValueKey.

##  Building custom layout in SwiftUI. LayoutValueKey.

14 Dec 2022

During the last weeks, we covered many aspects of building custom layouts
using the new _Layout_ protocol in SwiftUI. But we still have a lot to cover.
This week we will learn how to use the _LayoutValueKey_ protocol to pass
custom layout parameters while composing views in the custom layout.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In the previous posts, we built the flow layout type using the new _Layout_
protocol in SwiftUI. Let’s continue the work on the _FlowLayout_ type by
adding another feature. Assume that we want to tune the anchor point while
placing views in the layout. The first view might use the top point and the
second one use the bottom.

> To learn more about the basics of the _Layout_ protocol, take a look at my
> dedicated [ “Building custom layout in SwiftUI. Basics”
> ](/2022/11/16/building-custom-layout-in-swiftui-basics/) post.

SwiftUI provides us with the _LayoutValueKey_ protocol allowing us to register
a custom layout parameter. We can use this type to attach any value we need to
a view inside the layout and extract this value later in the layout cycle.

First, we should define a type conforming to the _LayoutValueKey_ protocol.

    
    
    struct UnitPointKey: LayoutValueKey {
        static var defaultValue: UnitPoint = .center
    }
    

Creating a custom layout parameter is pretty straightforward. The only thing
we have to do is to provide a default value for the parameter. Second, we
should create an extension on the _View_ type to simplify passing the custom
layout parameters.

    
    
    extension View {
        func anchor(_ anchor: UnitPoint) -> some View {
            layoutValue(key: UnitPointKey.self, value: anchor)
        }
    }
    

As you can see in the example above, we use the _layoutValue_ view modifier to
attach the particular value to the specific type conforming to the
_LayoutValueKey_ protocol. We can use the _layoutValue_ view modifier without
creating an extension on the _View_ type, but the extension provides a much
nicer and cleaner API.

    
    
    Text("!!!")
        .font(.title3)
        .layoutValue(key: UnitPointKey.self, value: .top)
        
    Text("!!!")
        .font(.title3)
        .anchor(.top)
    

Now, we can define a flow layout with the set of views and pass the custom
anchor point for each view inside the layout. Whenever we don’t set the value
for the custom layout parameter, SwiftUI uses the default value we provide.

    
    
    struct ContentView: View {
        var body: some View {
            FlowLayout {
                Text("Hello")
                    .font(.largeTitle)
                    .anchor(.bottom)
                Text("World")
                    .font(.title)
                    .anchor(.top)
                Text("!!!")
                    .font(.title3)
            }
        }
    }
    

The last step is to use the custom layout parameter while placing or sizing
the layout. We can access custom layout parameters by using the subscript on
the _Subview_ proxy type.

    
    
    struct FlowLayout: Layout {
    //  ....
        func placeSubviews(
            in bounds: CGRect,
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Cache
        ) {
            var lineX = bounds.minX
            var lineY = bounds.minY
            var lineHeight: CGFloat = 0
            
            for index in subviews.indices {
                if lineX + cache.sizes[index].width > (proposal.width ?? 0) {
                    lineY += lineHeight
                    lineHeight = 0
                    lineX = bounds.minX
                }
                
                let anchor = subviews[index][UnitPointKey.self]
                let position = CGPoint(
                    x: lineX + cache.sizes[index].width / 2,
                    y: lineY + cache.sizes[index].height / 2
                )
                
                lineHeight = max(lineHeight, cache.sizes[index].height)
                lineX += cache.sizes[index].width
                
                subviews[index].place(
                    at: position,
                    anchor: anchor,
                    proposal: ProposedViewSize(cache.sizes[index])
                )
            }
        }
    }
    

As you can see in the example above, we use the subscript on the _Subview_
proxy type to extract the value of the _UnitPointKey_ type. Finally, we use
this value to provide an anchor point while placing the views in the layout.

Custom layout parameters allow us to build super customizable and reusable
layouts in SwiftUI very easily. I hope you enjoy the post. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Discovering Swift Async Algorithms package

##  Discovering Swift Async Algorithms package

26 Feb 2024

Another week on a series of posts about discovering Swift packages. This week,
we will discover the Swift Async Algorithms package, allowing us to completely
switch from the Combine framework to the Swift Concurrency feature with
async/await. We will learn what the Swift Async Algorithms package offers to
eliminate the Combine framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The [ Swift Async Algorithms package ](https://github.com/apple/swift-async-
algorithms) is another package that Apple maintains and provides us. You can
always become a part of this great community by contributing to the package on
GitHub.

####  Combining

The Swift Async Algorithms package offers a set of functions allowing us to
combine two or three async sequences into a single sequence. For example, you
can merge two async sequences in a single one and observe values from the
resulting sequence.

    
    
    @Observable final class CalendarStore {
        private(set) var events: [Event] = []
        
        func observeEvents() async {
            let dayChanges = NotificationCenter.default.notifications(named: .NSCalendarDayChanged)
            let timezoneChanges = NotificationCenter.default.notifications(named: .NSSystemTimeZoneDidChange)
            
            for await change in merge(dayChanges, timezoneChanges) {
                await fetchEvents()
            }
        }
        
        func fetchEvents() async {
            // ...
        }
    }
    

As you can see in the example above, we use the _merge_ function that allows
us to create a single sequence then observe day and timezone changes at once.
The Swift Async Algorithms package provides not only _merge_ functions but
also _combineLatest_ , _zip_ , _chain_ , and _join_ .

    
    
    @Observable final class CalendarStore {
        private(set) var events: [Event] = []
        
        func observeEvents() async {
            let dayChanges = NotificationCenter.default.notifications(named: .NSCalendarDayChanged)
            let timezoneChanges = NotificationCenter.default.notifications(named: .NSSystemTimeZoneDidChange)
            
            for await change in zip(dayChanges, timezoneChanges) {
                await fetchEvents()
            }
        }
        
        func fetchEvents() async {
            // ...
        }
    }
    

The Swift Async Algorithms package also includes grouping and filtering
operators from the Swift Algorithms package but applies to async sequences
like _compacted_ for filtering _nil_ values or chunking and removing
duplicates.

> To learn more about the Swift Algorithms package, take a look at my [
> “Discovering Swift Algorithms package” ](/2024/02/13/discovering-swift-
> algorithms-package/) post.

####  Time manipulations

The Swift Async Algorithms package introduces a few operators, allowing us to
manipulate the sequence using time, similar to the Combine framework. For
example, you can debounce and throttle async sequences.

    
    
    @Observable final class CalendarStore {
        private(set) var events: [Event] = []
        
        func observeEvents() async {
            let dayChanges = NotificationCenter.default.notifications(named: .NSCalendarDayChanged)
            let timezoneChanges = NotificationCenter.default.notifications(named: .NSSystemTimeZoneDidChange)
            
            for await change in merge(dayChanges, timezoneChanges).debounce(for: .seconds(1)) {
                await fetchEvents()
            }
        }
        
        func fetchEvents() async {
            // ...
        }
    }
    

As you can see in the example above, we use the _debounce_ function to wait
for a particular period of time before emitting a value. Another helpful type
that we have in The Swift Async Algorithms package is _AsyncTimerSequence_ .
It emits the current date at a given interval.

    
    
    @Observable final class CalendarStore {
        private(set) var events: [Event] = []
        
        func observeEvents() async {
            let dayChanges = NotificationCenter.default.notifications(named: .NSCalendarDayChanged)
            let timezoneChanges = NotificationCenter.default.notifications(named: .NSSystemTimeZoneDidChange)
            
            let timer = AsyncTimerSequence(interval: .seconds(5), clock: .suspending)
            for await interval in timer {
                await fetchEvents(in: Date.now)
            }
        }
        
        func fetchEvents(in date: Date) async {
            // ...
        }
    }
    

####  AsyncChannel

The _AsyncChannel_ type allows us to replace passthrough subjects from the
Combine framework. It is a great way to bridge the part of the code that
doesn’t support async context with the async context in your app.

    
    
    let channel = AsyncChannel<UUID>()
    
    Task {
        for await id in channel {
            print(id)
        }
    }
    
    await channel.send(UUID())
    await channel.send(UUID())
    channel.finish()
    

As you can see in the example above, we use the _send_ function on an instance
of the _AsyncChannel_ type to emit values. Conversely, the _AsyncChannel_
conforms to the _AsyncSequence_ protocol to support for-each loop with the
_await_ keyword. Remember to call the _finish_ function on the channel to
close the sequence.

    
    
    let channel = AsyncThrowingChannel<UUID>()
    
    Task {
        for await id in channel {
            print(id)
        }
    }
    
    await channel.send(UUID())
    await channel.fail(SomeError())
    

There is also the _AsyncThrowingChannel_ type with a similar functionality
supporting failing with errors. Whenever you need to close the channel with an
error, you can use the _fail_ function on an instance of the
_AsyncThrowingChannel_ type.

####  Conclusion

Today we discovered the Swift Async Algorithms package, allowing us to move
completely from the Combine framework to the Swift Concurrency feature. I hope
you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Building async button in SwiftUI

##  Building async button in SwiftUI

26 Mar 2024

Swift Concurrency became a vital part of my development stack. I leverage the
power of the new Swift Concurrency features like async/await and task groups
almost everywhere. SwiftUI _Button_ type doesn’t support Swift Concurrency out
of the box, but it is flexible enough to allow us to build a button type
supporting Swift Concurrency.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Almost every interaction starting a task in our apps is displayed as a button.
A considerable part of this task should be non-blocking for other user
interface parts. Let’s start with a simple example demonstrating how to start
an async task when the user presses a button.

    
    
    struct ExampleView: View {
        @State private var counter = 0
        
        var body: some View {
            VStack {
                Text(counter, format: .number)
                
                Button {
                    Task {
                        await heavyUpdate()
                    }
                } label: {
                    Text("Increment")
                }
            }
        }
        
        private func heavyUpdate() async {
            do {
                print("update started")
                try await Task.sleep(for: .seconds(3))
                counter += 1
                print("update finished")
            } catch {
                print("update cancelled")
            }
        }
    }
    

As you can see in the example above, we define a button that starts a task on
every press. The _heavyUpdate_ function simulates the long-running task by
sleeping for some time. You can press the button as many times as you need,
and it will create numerous tasks. Usually, you need to disable the button
while the action is in progress.

    
    
    struct ExampleView: View {
        @State private var isRunning = false
        @State private var counter = 0
        
        var body: some View {
            VStack {
                Text(counter, format: .number)
                
                Button {
                    isRunning = true
                    Task {
                        await heavyUpdate()
                        isRunning = false
                    }
                } label: {
                    Text("Increment")
                }
                .disabled(isRunning)
            }
        }
        
        private func heavyUpdate() async {
            do {
                print("update started")
                try await Task.sleep(for: .seconds(3))
                counter += 1
                print("update finished")
            } catch {
                print("update cancelled")
            }
        }
    }
    

Now, we define the _isRunning_ property, which allows us to track the state of
the async task. When the _isRunning_ property changes to true, we disable the
button. Let’s extract the button’s logic into the dedicated view.

    
    
    struct AsyncButton<Label: View>: View {
        let action: () async -> Void
        let label: Label
        
        @State private var isRunning = false
        
        init(
            action: @escaping () async -> Void,
            @ViewBuilder label: () -> Label
        ) {
            self.action = action
            self.label = label()
        }
        
        var body: some View {
            Button {
                isRunning = true
                Task {
                    await action()
                    isRunning = false
                }
            } label: {
                label
            }
            .disabled(isRunning)
        }
    }
    

As you can see in the example above, we have extracted our button’s logic into
a separate _AsyncButton_ type. The SwiftUI framework’s environment feature
allows us to style any instance of the _AsyncButton_ type the same way we
style plain buttons.

    
    
    struct AsyncButtonExampleView: View {
        @State private var counter = 0
        
        var body: some View {
            VStack {
                Text(counter, format: .number)
                
                AsyncButton {
                    do {
                        try await Task.sleep(for: .seconds(3))
                        counter += 1
                    } catch {
                        // handle cancelation...
                    }
                } label: {
                    Text("Increment")
                }
                .controlSize(.large)
                .buttonStyle(.borderedProminent)
            }
        }
    }
    

> To learn more about styling buttons in SwiftUI, take a look at my dedicated
> [ “The many faces of button in SwiftUI” ](/2021/06/30/the-many-faces-of-
> button-in-swiftui/) post.

The final touch we need to add to our _AsyncButton_ type is cancelation
support. We need to be able to cancel the running task. I will use the trigger
value, a commonly used pattern in the SwiftUI framework, to achieve this. The
idea is straightforward. You only need an equatable value to observe and react
to its change.

    
    
    struct AsyncButton<Label: View, Trigger: Equatable>: View {
        var cancellation: Trigger
        let action: () async -> Void
        let label: Label
        
        @State private var task: Task<Void, Never>?
        @State private var isRunning = false
        
        init(
            cancellation: Trigger = false,
            action: @escaping () async -> Void,
            @ViewBuilder label: () -> Label
        ) {
            self.cancellation = cancellation
            self.action = action
            self.label = label()
        }
        
        var body: some View {
            Button {
                isRunning = true
                task = Task {
                    await action()
                    isRunning = false
                }
            } label: {
                label
            }
            .disabled(isRunning)
            .onChange(of: cancellation) {
                task?.cancel()
            }
        }
    }
    

As you can see, we have introduced the _trigger_ property and used the
_onChange_ view modifier to observe it. As soon as the _trigger_ property
changes, we cancel the button’s ongoing task. Let’s look at how to use the
trigger pattern in a simple example.

    
    
    struct AsyncButtonExampleView: View {
        @State private var counter = 0
        @State private var trigger = false
        
        var body: some View {
            VStack {
                Text(counter, format: .number)
                
                AsyncButton(cancellation: trigger) {
                    do {
                        try await Task.sleep(for: .seconds(3))
                        counter += 1
                    } catch {
                        
                    }
                } label: {
                    Text("Increment")
                }
                .controlSize(.large)
                .buttonStyle(.borderedProminent)
                
                Button {
                    trigger.toggle()
                } label: {
                    Text("Cancel")
                }
            }
        }
    }
    

The simple toggling of a boolean value is enough to run the _onChange_ view
modifier and cancel the task. This approach is used widely across SwiftUI. For
example, the same pattern is used in the sensory feedback and scroll view
APIs.

Today, we learned how to build a custom button type that supports the Swift
Concurrency feature. We were also introduced to the new trigger pattern, which
is a declarative way of doing imperative things. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Mastering Canvas in SwiftUI

##  Mastering Canvas in SwiftUI

11 Apr 2023

You can draw 2D graphics in SwiftUI using Shape API, but in the end, the
framework converts all the shapes into SwiftUI views and render them. This
approach has its pros and cons. Fortunately, we can draw rich 2D graphics
without combining multiple shapes. This week we will learn how to use _Canvas_
view in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

_Canvas_ view supports immediate mode drawing without using Shape API. We can
use it to draw anything we want in a procedural way, line by line. Let’s take
a look at a small example.

    
    
    struct ContentView: View {
        var body: some View {
            Canvas(
                opaque: true,
                colorMode: .linear,
                rendersAsynchronously: false
            ) { context, size in
                let rect = CGRect(origin: .zero, size: size)
                
    
                var path = Circle().path(in: rect)
                context.fill(path, with: .color(.red))
            }
        }
    }
    

![canvas-with-a-circle](/public/canvas1.png)

As you can see in the example above, we create a _Canvas_ view as the root
view of our _ContentView_ . It accepts a few parameters allowing us to
configure the canvas with opaque, color mode, and asynchronous rendering
options.

We should place all the drawing logic in the closure we pass to the _Canvas_
view. This closure is called a renderer. A renderer closure provides us with
an instance of _GraphicalContext_ that we use to draw content and the size of
the canvas.

The instance of the _GraphicsContext_ type is the _inout_ parameter of the
renderer closure. It means we can mutate it in place while drawing our
content.

    
    
    struct ContentView: View {
        var body: some View {
            Canvas(
                opaque: true,
                colorMode: .linear,
                rendersAsynchronously: false
            ) { context, size in
                context.opacity = 0.3
                
                let rect = CGRect(origin: .zero, size: size)
                
                var path = Circle().path(in: rect)
                context.fill(path, with: .color(.red))
    
                let newRect = rect.applying(.init(scaleX: 0.5, y: 0.5))
                path = Circle().path(in: newRect)
                context.fill(path, with: .color(.red))
            }
        }
    }
    

![canvas-with-two-circles](/public/canvas2.png)

As you can see in the example above, we tune the opacity of the context, and
it affects all the drawing logic appearing after that line. The
_GraphicsContext_ type allows us to adjust many drawing process parameters,
like opacity, scaling, and blend mode. It also allows us to add different
filters using the _addFilter_ function.

The _GraphicsContext_ type provides the _stroke_ , _fill_ , and _clip_
functions, allowing us to draw any path we need. But it also provides the
_draw_ function allowing us to draw text and images.

    
    
    struct ContentView: View {
        var body: some View {
            Canvas(
                opaque: true,
                colorMode: .linear,
                rendersAsynchronously: false
            ) { context, size in
                context.opacity = 0.3
      
                let text = Text(verbatim: "Hello").font(.largeTitle)
                var resolvedText = context.resolve(text)
                resolvedText.shading = .color(.red)
                context.draw(resolvedText, in: rect)
            }
        }
    }
    

We can’t draw an instance of _Text_ or _Image_ type directly. Instead, we
should convert them into the format the draw function accepts using the
_resolve_ function on the _GraphicsContext_ type. The _resolve_ function
returns us an instance of the _ResolvedText_ or _ResolvedImage_ types that
allows us to tune the shading of the resolved object.

You can use the _Canvas_ type to draw not only text and images, but you can
also draw any SwiftUI view. But before, we should register them by using
symbols closure while creating a canvas. Every SwiftUI view in the symbols
closure should have its unique tag allowing us to resolve the view by id later
in the renderer closure.

    
    
    struct ContentView: View {
        var body: some View {
            Canvas(
                opaque: true,
                colorMode: .linear,
                rendersAsynchronously: false
            ) { context, size in
                context.opacity = 0.3
                
                let rect = CGRect(origin: .zero, size: size)
                
                if let symbol = context.resolveSymbol(id: 1) {
                    context.draw(symbol, in: rect)
                }
            } symbols: {
                Text(verbatim: "Hello")
                    .foregroundColor(.red)
                    .tag(1)
            }
        }
    }
    

####  Animation

The _Canvas_ view doesn’t support animations, but you can animate it by
embedding it into the _TimelineView_ with the animation scheduler.

    
    
    struct ContentView: View {
        var body: some View {
            TimelineView(.animation) { timelineContext in
                let value = secondsValue(for: timelineContext.date)
                
                Canvas(
                    opaque: true,
                    colorMode: .linear,
                    rendersAsynchronously: false
                ) { context, size in
                    let newSize = size.applying(.init(scaleX: value, y: 1))
                    let rect = CGRect(origin: .zero, size: newSize)
                    
                    context.fill(
                        Rectangle().path(in: rect),
                        with: .color(.red)
                    )
                }
            }
        }
        
        private func secondsValue(for date: Date) -> Double {
            let seconds = Calendar.current.component(.second, from: date)
            return Double(seconds) / 60
        }
    }
    

> To learn more about the power of TimelineView, take a look at my [
> “Mastering TimelineView in SwiftUI” ](/2022/05/18/mastering-timelineview-in-
> swiftui/) post.

####  Accessibility

The _Canvas_ view doesn’t have an accessibility tree because it is a simple 2D
graphics engine. Instead, you can attach a set of accessibility view modifiers
that SwiftUI provides us to make its content accessible to everyone.

####  Conclusion

Today we learned how to use the _Canvas_ view to draw rich 2D graphics in
SwiftUI without using Shape API. You should use the _Canvas_ view whenever you
need immediate mode drawing by skipping SwiftUI rendering. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading, and see you next
week!



# Mastering StoreKit 2. SwiftUI view modifiers.

##  Mastering StoreKit 2. SwiftUI view modifiers.

29 Aug 2023

We talked a lot about StoreKit 2 in this series of posts. This week, we will
finalize the series by covering the set of view modifiers StoreKit 2 provides
us to use in SwiftUI views.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

As I said before, StoreKit views handle loading and purchasing in-app
purchases completely. But sometimes, you must be aware of the current step in
the flow to react. For example, you might need to dismiss the paywall whenever
the user finishes the purchase or show a loading indicator while waiting for
the App Store server result.

    
    
    struct PaywallView: View {
        @Environment(\.dismiss) private var dismiss
        
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1")
                .onInAppPurchaseStart { product in
                    print(product.displayName)
                }
                .onInAppPurchaseCompletion { product, result in
                    dismiss()
                }
        }
    }
    

StoreKit 2 provides us with _onInAppPurchaseStart_ and
_onInAppPurchaseCompletion_ view modifiers to handle the start and completion
of any purchase in the view hierarchy using StoreKit views. Both view
modifiers accept a closure to perform and have product and purchase result as
parameters.

> To learn more about _SubscriptionStoreView_ , take a look at my dedicated [
> “Mastering StoreKit 2. SubscriptionStoreView in SwiftUI”
> ](/2023/08/23/mastering-storekit2-subscriptionstoreview-in-swiftui/) post.

Another view modifier that simplifies our job is the _subscriptionStatusTask_
modifier. It allows us to observe the status of a particular subscription
group constantly. It updates you whenever the status of the subscription
changes.

    
    
    struct ContentView: View {
        @State private var paywallShown = false
        @State private var isPro = false
        
        var body: some View {
            RootView()
                .sheet(isPresented: $paywallShown) {
                    PaywallView()
                }
                .subscriptionStatusTask(for: "598392E1") { taskState in
                    if let value = taskState.value {
                        isPro = !value
                            .filter { $0.state != .revoked && $0.state != .expired }
                            .isEmpty
                    } else {
                        isPro = false
                    }
                }
        }
    }
    

As you can see in the example above, we use the _subscriptionStatusTask_ view
modifier to observe the status of the particular subscription group. As you
may have noticed, we provide a closure handling the subscription status
changes, and it takes an array of the subscription statuses as the parameter.
It uses an array instead of a single value because the user might purchase a
subscription but also has access to the subscription by family sharing.

The _subscriptionStatusTask_ view modifier works only with subscriptions.
StoreKit 2 provides the _currentEntitlementTask_ view modifier for consumable
and non-consumable in-app purchases. It works similarly to the
_subscriptionStatusTask_ view modifier but instead gives you an optional
transaction of the particular product.

    
    
    struct ContentView: View {
        @State private var paywallShown = false
        @State private var isPro = false
        
        var body: some View {
            RootView()
                .sheet(isPresented: $paywallShown) {
                    PaywallView()
                }
                .currentEntitlementTask(for: "1232") { taskState in
                    if let verification = taskState.transaction,
                       let transaction = try? verification.payloadValue {
                        isPro = transaction.revocationDate == nil
                    } else {
                        isPro = false
                    }
                }
        }
    }
    

As you can see, the _currentEntitlementTask_ view modifier allows us to
provide a closure accepting an optional transaction wrapped into the
_VerificationResult_ type. It is optional because there might be no
transaction for the particular product. Whenever the user purchases or revokes
the product, StoreKit 2 runs the attached closure.

> To learn more about the _VerificationResult_ type, take a look at my [
> “Mastering StoreKit 2” ](/2023/08/01/mastering-storekit2/) post.

Another view modifier StoreKit 2 provides us is the _storeProductsTask_
modifier. It allows us to load the list of products and observe them. It runs
the provided closure whenever any product in the collection changes.

    
    
    struct ContentView: View {
        @State private var paywallShown = false
        
        var body: some View {
            RootView()
                .sheet(isPresented: $paywallShown) {
                    PaywallView()
                }
                .storeProductTask(for: "12763") { taskState in
                    print(taskState.product?.displayName)
                }
        }
    }
    

Today, we learned how to query StoreKit 2 from SwiftUI views using brand-new
view modifiers. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!

  1. [ Mastering StoreKit 2 ](/2023/08/01/mastering-storekit2/)
  2. [ Mastering StoreKit 2. ProductView and StoreView in SwiftUI. ](/2023/08/08/mastering-storekit2-productview-in-swiftui/)
  3. [ Mastering StoreKit 2. SubscriptionStoreView in SwiftUI ](/2023/08/23/mastering-storekit2-subscriptionstoreview-in-swiftui/)
  4. Mastering StoreKit 2. SwiftUI view modifiers. 
  5. [ StoreKit testing in Swift ](/2024/01/09/storekit-testing-in-swift/)



# Accessibility focus in SwiftUI

##  Accessibility focus in SwiftUI

23 Sep 2021

One of the new features of SwiftUI Release 3 is accessibility focus
management. SwiftUI allows us easily handle the focus state for assistive
technologies like VoiceOver and Switch Control. This week we will learn how to
use the _AccessibilityFocusState_ property wrapper to move the accessibility
focus in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

SwiftUI Release 3 provides us a particular set of tools for managing
accessibility focus. It includes the _AccessibilityFocusState_ property
wrapper and the _accessibilityFocused_ view modifier. We can handle
accessibility focus in a similar way that we manage it without assistive
technologies.

> To learn more about focus management in SwiftUI, take a look at my [
> “Mastering FocusState property wrapper in SwiftUI” ](/2021/08/24/mastering-
> focusstate-property-wrapper-in-swiftui/) post.
    
    
    import SwiftUI
    
    struct SignInView: View {
        @AccessibilityFocusState
        private var isEmailFocused: Bool
    
        @State private var email = ""
    
        var body: some View {
            NavigationView {
                Form {
                    TextField("email", text: $email, prompt: Text("email"))
                        .accessibilityFocused($isEmailFocused)
                }
                .navigationTitle("Sign in")
                .onChange(of: isEmailFocused) { newValue in
                    print(newValue)
                }
            }
        }
    }
    

As you can see in the example above, we use the _AccessibilityFocusState_
property wrapper to define a variable that represents whenever the email field
is focused. SwiftUI initializes the variable with the false value by default
because the user can focus on any other area of the screen. We also use the
_accessibilityFocused_ view modifier to bind the focus state of a particular
view to a variable holding its value.

Remember that you can declare as many variables as you need to cover your
accessibility focus logic with the _AccessibilityFocusState_ property wrapper.

    
    
    import SwiftUI
    
    struct SignInView: View {
        @AccessibilityFocusState
        private var isEmailFocused: Bool
        
        @AccessibilityFocusState
        private var isPasswordFocused: Bool
    
        @State private var email = ""
        @State private var password = ""
    
        var body: some View {
            NavigationView {
                Form {
                    TextField("email", text: $email, prompt: Text("email"))
                        .accessibilityFocused($isEmailFocused)
                    SecureField("password", text: $password, prompt: Text("password"))
                        .accessibilityFocused($isPasswordFocused)
                }
                .navigationTitle("Sign in")
            }
        }
    }
    

The nice thing about the _AccessibilityFocusState_ property wrapper is that
you can limit its behavior to a dedicated assistive technology. For example,
you can activate the _AccessibilityFocusState_ property wrapper only for
VoiceOver or Switch Control. By default, SwiftUI aggregates the value for all
assistive technologies available on the device.

    
    
    import SwiftUI
    
    struct SignInView: View {
        @AccessibilityFocusState(for: .switchControl)
        private var isEmailFocused: Bool
    
        @State private var email = ""
    
        var body: some View {
            NavigationView {
                Form {
                    TextField("email", text: $email, prompt: Text("email"))
                        .accessibilityFocused($isEmailFocused)
                }
                .navigationTitle("Sign in")
                .onChange(of: isEmailFocused) { newValue in
                    print(newValue)
                }
            }
        }
    }
    

Usually, you have more than one element on the screen, and you might want to
move the focus between them. For this particular case, SwiftUI provides us a
way to define our focusable fields via enum and switch between them.

    
    
    enum FocusableField: Hashable {
        case email
        case password
    }
    
    struct ContentView: View {
        @State private var email = ""
        @State private var password = ""
        
        @AccessibilityFocusState
        private var focus: FocusableField?
    
        var body: some View {
            NavigationView {
                Form {
                    TextField("email", text: $email, prompt: Text("email"))
                        .accessibilityFocused($focus, equals: .email)
                    SecureField("password", text: $password, prompt: Text("password"))
                        .accessibilityFocused($focus, equals: .password)
                    Button("login", action: login)
                }
                .toolbar {
                    ToolbarItem(placement: .keyboard) {
                        Button("next") {
                            if email.isEmpty {
                                focus = .email
                            } else if password.isEmpty {
                                focus = .password
                            } else {
                                focus = nil
                            }
                        }
                    }
                }
                .navigationTitle("Sign in")
                .onAppear {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        focus = .email
                    }
                }
            }
        }
    
        private func login() {
            // your logic here
        }
    }
    

In the example above, we use the _AccessibilityFocusState_ view modifier with
our new _FocusableField_ enum that defines all the focusable views on the
screen. Keep in mind that you should make the _FocusableField_ enum hashable
and define an optional variable with the help of the _AccessibilityFocusState_
view modifier to allow the framework to set the value to **nil** whenever the
user moves the focus from the views you define.

We should also use another version of the _accessibilityFocused_ view modifier
to bind a view to a particular case of the hashable enum. Remember that you
can programmatically move the focus of VoiceOver or Switch Control by changing
the value of the variable wrapped with _AccessibilityFocusState_ .

> To learn about the basics of accessibility in SwiftUI, take a look at my [
> “Accessibility in SwiftUI” ](/2019/09/10/accessibility-in-swiftui/) post.

I love SwiftUI because the different APIs use the same style and they are
consistent across various features. You can learn it once and apply it in
multiple places. This week we learned how to manage the accessibility focus
which is very similar to the first responder management. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Adapting app for iPad with UISplitViewController

##  Adapting app for iPad with UISplitViewController

03 Apr 2019

Apple promotes iPad as the primary computer for regular users. This trend is
visible during the last couple of years. More and more users start to use iPad
as the main device. I think it is essential to support iPad screens and
efficiently use that space. This week we will talk about adapting apps for
iPad with the help of UISplitViewController.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Adaptive presentation

As a part of iOS 9 SDK, Apple released an adaptive “show” method on
UIViewController. We have to use this method to present another
UIViewController, here is a quote from Apple Documentation which describes how
it works:

> You use this method to decouple the need to display a view controller from
> the process of actually presenting that view controller onscreen. Using this
> method, a view controller does not need to know whether it is embedded
> inside a navigation controller or split-view controller. It calls the same
> method for both. For example, a navigation controller overrides this method
> and uses it to push UIViewController onto its navigation stack.

This method uses the Responder Chain pattern to find the object which
overrides the “show” method to run it. For example, the UINavigationController
overrides “show” method and calls the “pushViewController” method. When your
UIViewController wrapped in UINavigationController, the “show” will find
UINavigationController’s “show” method in Responder Chain. In the case when
there is no overridden “show” method, it presents UIViewController modally
using root UIViewController.

####  UISplitViewController

Apple provides us with the UISplitViewController which uses the
UIViewController containment feature to show UIViewControllers in Master-
Details flow side-by-side. UISplitViewController uses adaptive “show” and
“showDetailViewController” methods together with trait collection to
understand when there is enough space to show UIViewControllers side-by-side
or shows the master UIViewController only.

Let’s take a look at the UISplitViewController usage sample.

    
    
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
        let splitViewController = UISplitViewController()
    
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
            let masterVC = MasterViewController()
            masterVC.delegate = self
    
            splitViewController.preferredDisplayMode = .automatic
            splitViewController.viewControllers = [
                UINavigationController(rootViewController: masterVC),
                UINavigationController(rootViewController: EmptyViewController())
            ]
            window = UIWindow(frame: UIScreen.main.bounds)
            window?.rootViewController = splitViewController
            window?.makeKeyAndVisible()
            return true
        }
    }
    
    extension AppDelegate: MasterDelegate {
        func start(_ show: Show) {
            let detailsVC = DetailsViewController(show: show)
            splitViewController.showDetailViewController(detailsVC, sender: self)
        }
    }
    
    extension AppDelegate: UISplitViewControllerDelegate {
        func splitViewController(_ splitViewController: UISplitViewController, collapseSecondary secondaryViewController: UIViewController, onto primaryViewController: UIViewController) -> Bool {
            return true
        }
    }
    

Apple recommends using UISplitViewController as window’s root ViewController.
By passing an array with two UIViewController, we set Master-Details flow. You
can use the “show” method to present UIViewController in the Master part of
UISplitViewController or “showDetailViewController” to present in Details
part. When you are running UISplitViewController on iPhone, there is not
enough space and it collapse Details controller. In this case,
“showDetailViewController” method works as the “show” method and present
UIViewController in the master part.

The UISplitViewController has several configuration properties like
“preferredPrimaryColumnWidthFraction” and “maximumPrimaryColumnWidth” which
give us opportunity to setup needed presentation. Another interesting property
here is “preferredDisplayMode” field. It has several options like allVisible,
primaryOverlay, primaryHidden and automatic. By using this property, you
recommend display mode to UISplitViewController, but it can ignore it in the
case when there is not enough space.

![ShowBot-iPad](/public/showbot-ipad-land.png)

UISplitViewController has a UISplitViewControllerDelegate field, where you can
set your own delegate object. By using a delegate object, you can override
some default behaviors of UISplitViewControllers. For example, you can replace
“show” and “showDetailViewController” methods implementation with your custom
one, or implement “collapseSecondary” method where you can decide when you
have to collapse or expand Details UIViewController.

####  Conclusion

This week we discuss how easily we can adapt our apps to iPad screens by
efficiently using all the space. Try to adapt your app for iPad this week and
feel free to contact me via [ Twitter ](https://twitter.com/mecid) in case of
any problems. Thanks for reading and see you next week!



# Mastering Swift Foundation Formatter API. Custom Format Styles

##  Mastering Swift Foundation Formatter API. Custom Format Styles

04 Jul 2023

Swift Foundation Formatter API is one of my favorite recent additions to the
Swift ecosystem. I use it in every project and build my custom-type formatting
logic using the same approach. This week we will learn how to introduce custom
formatters and use them with our own types.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

As I said in the previous post, many types from the Swift Foundation provide
the _formatted_ function allowing us to format dates, numbers, etc., into the
user-presentable style. The whole formatting logic lives outside of the
concrete type. The Swift Foundation defines many different types conforming to
the _FormatStyle_ protocol, allowing encapsulation of the formatting logic.

> To learn more about the basics of the Swift Foundation Formatter API, take a
> look at my [ “Mastering Swift Foundation Formatter API. Basics”
> ](/2023/05/30/mastering-swift-foundation-formatter-api-basics/) post.
    
    
    protocol FormatStyle {
        associatedtype Input
        associatedtype Output
    
        func format(_ value: Input) -> Output
    }
    

The _FormatStyle_ protocol is simple. It has the only required function called
_format_ . It takes two generic parameters: one for input and another for
output. Using generic parameters allows us to format any type into any
presentation you need. But let’s start with a simple example of a custom
format style.

    
    
    struct ShortNumberFormat: FormatStyle {
        let maxFractionLength: Int
        func format(_ value: Double) -> String {
            value.formatted(.number.precision(.fractionLength(0...maxFractionLength)))
        }
    }
    
    extension FormatStyle where Self == ShortNumberFormat {
        static func short(maxFractionLength: Int = 1) -> ShortNumberFormat {
            .init(maxFractionLength: maxFractionLength)
        }
    }
    

As you can see in the example above, we create the _ShortNumberFormat_ type
conforming to the _FormatStyle_ protocol. We define generic parameters of the
_format_ function as _Double_ and _String_ . It means it should convert any
instance of the _Double_ type to a _String_ .

    
    
    let number = 100.001
    Text(verbatim: number.formatted(.short(maxFractionLength: 2)))
    // Text displays 100
    

Now we can easily reuse our short number format style across the codebase and
cover it with unit tests to verify the formatting logic. As I said before, the
_FormatStyle_ protocol allows us to convert any type into anything we might
need. In the following example, we will create a format style converting a
double to an attributed string.

    
    
    struct BoldNumberFormat: FormatStyle {
        func format(_ value: Double) -> AttributedString {
            var string = AttributedString(value.formatted(.number))
            
            if let range = string.range(of: String(Int(value))) {
                string[range].inlinePresentationIntent = .stronglyEmphasized
            }
            
            return string
        }
    }
    
    extension FormatStyle where Self == BoldNumberFormat {
        static var bold: BoldNumberFormat { .init() }
    }
    

As you can see in the example above, we define the _BoldNumberFormat_ type
that conforms to the _FormatStyle_ and generates an attributed string from a
double. We use the bold style for the part of the number before the decimal
separator.

    
    
    let a = 10.001
    Text(a.formatted(.bold))
    

We can use the _BoldNumberFormat_ type with _Text_ in SwiftUI or _UILabel_ in
UIKit to display doubles using attributed strings.

The _formatted_ function is part of the many Swift Foundation types, but what
about our own types? We can easily define the same formatted function on our
types and reuse the _FormatStyle_ protocol.

    
    
    struct Product {
        let title: String
        let price: Decimal
        let oldPrice: Decimal?
    }
    
    extension Product {
        func formatted<Style: FormatStyle>(
            _ style: Style
        ) -> Style.FormatOutput where Style.FormatInput == Self {
            style.format(self)
        }
    }
    
    struct ProductPriceFormat: FormatStyle {
        func format(_ value: Product) -> AttributedString {
            guard let oldPrice = value.oldPrice else {
                return value.price.formatted(.number.attributed)
            }
    
            let priceFormatted = value.price.formatted()
            let oldPriceFormatted = oldPrice.formatted()
    
            var string = AttributedString("\(priceFormatted) \(oldPriceFormatted)")
    
            if let range = string.range(of: oldPriceFormatted) {
                string[range].inlinePresentationIntent = .strikethrough
            }
    
            return string
        }
    }
    
    extension FormatStyle where Self == ProductPriceFormat {
        static var price: ProductPriceFormat { .init() }
    }
    

As you can see in the example above, we define the _formatted_ function on our
_Product_ type. We also create the _ProductPriceFormat_ type that uses current
and old prices to generate an attributed string with a price where the old
price is crossed out.

    
    
    let product = Product(title: "App", price: 0.99, oldPrice: 1.99)
    Text(product.formatted(.price))
    

I use this approach to encapsulate and reuse my formatting logic for my own
model types. But usually, instead of creating a bunch of types conforming to
the _FormatStyle_ protocol, I define a nested _Formatter_ struct inside a
model type and create a bunch of extensions to cover every single use-case I
need.

    
    
    extension Product {
        struct Formatter<Output> {
            let format: (Product) -> Output
        }
        
        func formatted<Output>(_ formatter: Formatter<Output>) -> Output {
            formatter.format(self)
        }
    }
    
    extension Product.Formatter where Output == AttributedString {
        static var price: Self {
            .init { value in
                guard let oldPrice = value.oldPrice else {
                    return value.price.formatted(.number.attributed)
                }
                
                let priceFormatted = value.price.formatted()
                let oldPriceFormatted = oldPrice.formatted()
                
                var string = AttributedString("\(priceFormatted) \(oldPriceFormatted)")
                
                if let range = string.range(of: oldPriceFormatted) {
                    string[range].inlinePresentationIntent = .strikethrough
                }
                
                return string
            }
        }
    }
    
    let anotherProduct = Product(title: "Another app", price: 0.99, oldPrice: 1.99)
    Text(anotherProduct.formatted(.price))
    

This week we discussed encapsulating formatting logic for our model types by
reusing the lovely approach from the Swift Foundation. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Chaining publishers with Combine in Swift

##  Chaining publishers with Combine in Swift

04 May 2021

The Combine framework provides you a bunch of operators to map, filter, and
chain asynchronous operations. This week I want to focus on the chaining
asynchronous jobs using two main operators that the Combine framework provides
us. We will learn how to use _flatMap_ and _switchToLatest_ operators to chain
asynchronous tasks in a declarative way.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Chaining basics with the flatMap operator

The _flatMap_ operator allows us to take the result of one publisher, pass it
to another and run the second publisher. We can use it to chain two different
publishers. Let’s take a look at how we can use it.

    
    
    final class GithubService {
        private let session: URLSession
        private let decoder: JSONDecoder
    
        init(session: URLSession = .shared, decoder: JSONDecoder = .init()) {
            self.session = session
            self.decoder = decoder
        }
    
        func searchPublisher(matching query: String) -> AnyPublisher<[Repo], Error> {
            // some code here
        }
    }
    
    final class SearchViewModel: ObservableObject {
        @Published var query: String = ""
        @Published private(set) var repos: [Repo] = []
    
        private let service = GithubService()
    
        init() {
            $query
                .flatMap { 
                    self.service.searchPublisher(matching: $0)
                        .replaceError(with: []) 
                }
                .receive(on: DispatchQueue.main)
                .assign(to: &$repos)
        }
    }
    

As you can see in the example above, we create the _SearchViewModel_ class
that conforms to _ObservableObject_ . Here we define two properties query and
repos. @ _Published_ property wrapper automatically provides a publisher for
property and allows us to access it via projected value using **$** sign.

> To learn more about designing API with Combine publishers, take a look at my
> [ “Designing API using Combine framework” ](/2021/04/07/designing-api-using-
> combine-framework/) post.

In the _SearchViewModel_ initializer, we use the _flatMap_ operator to pass
the value of query publisher and generate a new search publisher using the
provided query. Then we use the _assign_ operator to save the result of the
search operation in the repos property.

    
    
    struct ContentView: View {
        @StateObject var viewModel = SearchViewModel()
    
        var body: some View {
            NavigationView {
                List {
                    TextField("Query", text: $viewModel.query)
                    ForEach(viewModel.repos, id: \.id) { repo in
                        VStack(alignment: .leading) {
                            Text(repo.name)
                                .font(.headline)
                            if let description = repo.description {
                                Text(description)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                }.navigationTitle("Search")
            }
        }
    }
    

Now we can use the _SearchViewModel_ in our SwiftUI app to implement a GitHub
repos search screen. Here we have a SwiftUI view that contains a text field
for query terms and a list of results.

_SearchViewModel_ will make a network request as soon as the user types
something in the query text field. Every new character in the text field
generates a new API request. Usually, we want to delay requests till user
typing. We can achieve this behavior by using _debounce_ operator on query
publisher in the _SearchViewModel_ .

    
    
    final class SearchViewModel: ObservableObject {
        @Published var query: String = ""
        @Published private(set) var repos: [Repo] = []
    
        private let service = GithubService()
    
        init() {
            $query
                .debounce(for: 0.5, scheduler: DispatchQueue.main)
                .flatMap { 
                    self.service.searchPublisher(matching: $0)
                        .replaceError(with: []) 
                }
                .receive(on: DispatchQueue.main)
                .assign(to: &$repos)
        }
    }
    

The _debounce_ operator blocks the chain for a time interval that you provide
and doesn’t emit any values in that period of time. It emits the latest value
after the timeout that you provide. We can significantly reduce the number of
network requests we make using _debounce_ operator.

> To learn more about the set of operators that the Combine framework provides
> us, take a look at my [ “Catching errors in Combine” ](/2020/04/22/catching-
> errors-in-combine/) post.

####  Advanced chaining with switchToLatest operator

Assume that you have a situation where a user types two queries in a sequence,
but the network delays the first one, and the second one finishes earlier. The
view represents the search result for the second request, but after a decent
amount of time, the first query finishes, and the data appears on the screen
by replacing the results of the second query.

Usually, we want to present the results of the latest query and ignore the
previous attempts. We can’t achieve that with the _flatMap_ operator, and
especially for this case, the Combine framework provides us the
_switchToLatest_ operator.

    
    
    final class SearchViewModel: ObservableObject {
        @Published var query: String = ""
        @Published private(set) var repos: [Repo] = []
    
        private let service = GithubService()
    
        init() {
            $query
                .debounce(for: 0.5, scheduler: DispatchQueue.main)
                .map { 
                    self.service.searchPublisher(matching: $0)
                        .replaceError(with: [])
                }
                .switchToLatest()
                .receive(on: DispatchQueue.main)
                .assign(to: &$repos)
        }
    }
    

In the example above, we refactored our _SearchViewModel_ to use the
_switchToLatest_ operator. The _switchToLatest_ operator is designed to work
with a publisher that emits other publishers. That’s why we use the _map_
operator to transform our publisher into the publisher that emits search
publishers. Then we attach the _switchToLatest_ operator flattening the stream
of publishers and delivering results only from the latest one.

####  Conclusion

This week we learned about two different ways of chaining asynchronous
operations with the Combine framework. Usually, the _flatMap_ operator is what
you need to chain multiple operations. When you should do some work as a
response to a user action, you should use the combination of _map_ and
_switchToLatest_ operators to deliver the latest results. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Combine and SwiftUI views

##  Combine and SwiftUI views

27 Nov 2019

_Combine_ is one of the new frameworks released during WWDC 2019. It provides
a declarative _Swift API_ for processing values over time. Today we will talk
about one of the hidden features of SwiftUI views, which is _onReceive_
modifier. It allows views to subscribe and react as soon as the publisher
emits the value.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Combine

We didn’t talk much about Combine on my blog, but I mainly use it for handling
asynchronous work. Usually, we have a data layer that is responsible for all
operations in the app, like fetching or saving, and this is the place where
all asynchronous operations take place. To learn more about the modeling app
state, please take a look at [ “Redux-like state container in SwiftUI” post
](/2019/09/18/redux-like-state-container-in-swiftui/) .

But sometimes it is very handy to receive some system-wide notifications in
the view layer. An excellent example of this type of notifications can be
_keyboardWillShowNotification_ . Framework emits this notification as soon as
the system keyboard appears. By listening to this notification, we can
understand when to add some bottom padding to the root view to keep it visible
above the keyboard.

Let’s take a look at how we can subscribe to the _Notification Center_ using
the Combine framework and react to the changes.

    
    
    NotificationCenter.default
        .publisher(for: UIResponder.keyboardWillShowNotification)
        .compactMap { $0.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect }
        .map { $0.height }
        .sink { print("height: \($0)") }
    

As you can see in the example above, the Combine framework provides an
extension for the _Notification Center_ , which allows us to receive and
handle events in a reactive style. Now let’s see how we can use it inside a
SwiftUI view.

####  onReceive modifier

SwiftUI views provide the **onReceive** modifier, which has two arguments: the
_Publisher_ from Combine framework and the closure. SwiftUI subscribes to the
publisher and runs passed closure whenever the publisher emits the value.
Let’s take a look at the sample code now.

    
    
    import SwiftUI
    import Combine
    
    struct ItemsView: View {
        let items: [String]
    
        @State private var keyboardHeight: CGFloat = 0
        private var keyboardHeightPublisher: AnyPublisher<CGFloat, Never> {
            Publishers.Merge(
                NotificationCenter.default
                    .publisher(for: UIResponder.keyboardWillShowNotification)
                    .compactMap { $0.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect }
                    .map { $0.height },
                NotificationCenter.default
                    .publisher(for: UIResponder.keyboardWillHideNotification)
                    .map { _ in CGFloat(0) }
            ).eraseToAnyPublisher()
        }
    
        var body: some View {
            List(items, id: \.self) { item in
                Text(item)
            }
            .padding(.bottom, keyboardHeight)
            .onReceive(keyboardHeightPublisher) { self.keyboardHeight = $0 }
        }
    }
    

In the example above, we ask SwiftUI to update the state with the value
emitted by the publisher, and as soon as state changes, SwiftUI updates our
view with a new bottom padding value, which keeps our view above the keyboard.
We can extract this piece of code into a _ViewModifier_ to make it more
reusable.

    
    
    import SwiftUI
    import Combine
    
    struct KeyboardAwareModifier: ViewModifier {
        @State private var keyboardHeight: CGFloat = 0
    
        private var keyboardHeightPublisher: AnyPublisher<CGFloat, Never> {
            Publishers.Merge(
                NotificationCenter.default
                    .publisher(for: UIResponder.keyboardWillShowNotification)
                    .compactMap { $0.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect }
                    .map { $0.height },
                NotificationCenter.default
                    .publisher(for: UIResponder.keyboardWillHideNotification)
                    .map { _ in CGFloat(0) }
            ).eraseToAnyPublisher()
        }
    
        func body(content: Content) -> some View {
            content
                .padding(.bottom, keyboardHeight)
                .onReceive(keyboardHeightPublisher) { self.keyboardHeight = $0 }
        }
    }
    
    extension View {
        func keyboardAwarePadding() -> some View {
            ModifiedContent(content: self, modifier: KeyboardAwareModifier())
        }
    }
    

To learn more about [ ViewModifiers in SwiftUI, take a look at my dedicated
post ](/2019/08/07/viewmodifiers-in-swiftui/) .

Another good example of handling system-wide notifications can be
_userDidTakeScreenshotNotification_ . Framework emits this notification as
soon the user takes a screenshot of your app. Assume that we are working on
the shopping app where we have a product details screen, and we can present a
share sheet as soon as the user takes the screenshot of the product. Let’s
take a look at how we can achieve this behavior in SwiftUI.

    
    
    import SwiftUI
    
    struct ProductContainerView: View {
        let product: Product
        
        @State private var shareShown = false
        private var screenshotPublisher: AnyPublisher<Notification, Never> {
            NotificationCenter.default
                .publisher(for: UIApplication.userDidTakeScreenshotNotification)
                .eraseToAnyPublisher()
        }
    
        var body: some View {
            ProductDetailsView(product: product)
                .onReceive(screenshotPublisher) { _ in self.shareShown = true }
                .sheet(isPresented: $shareShown) { ShareView(url: self.product.url) }
        }
    }
    

Here we have another excellent example of using the Combine framework in
SwiftUI views to present a share sheet as soon as the user takes a screenshot.

####  Conclusion

Combine framework is a great way to model your data processing, but today we
learned about another interesting usage of publishers in combination with
SwiftUI views. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Accessibility in SwiftUI

##  Accessibility in SwiftUI

10 Sep 2019

This week I want to talk to you about _Accessibility in SwiftUI_ . SwiftUI
provides a ready to use accessibility implementation for standard User
Interface elements like _Text, Button, Toggle, etc_ . In most of the cases,
you don’t need to do something additional to make it work. But I will show how
you can modify the accessibility tree by using accessibility modifiers to
improve your User Experience.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Accessibility modifiers

SwiftUI provides a bunch of accessibility modifiers for any view. By using
accessibility modifiers, you can easily set label and value for a view, add
accessibility traits and actions.

Assume that we are working on _BarChart_ component and we want to make every
_Bar_ accessible to VoiceOver and VoiceControl users. Let’s take a look at how
we can do that by adding accessibility modifiers to custom shape view.

    
    
    struct BarsView: View {
        let bars: [Bar]
    
        private var max: Double {
            bars.map { $0.value }.max() ?? 0
        }
    
        var body: some View {
            GeometryReader { container in
                HStack(alignment: .bottom, spacing: 1) {
                    ForEach(self.bars, id: \.self) { bar in
                        Capsule()
                            .fill(bar.legend.color)
                            .accessibility(label: Text(bar.label))
                            .accessibility(value: Text(bar.legend.label))
                            .frame(height: CGFloat(bar.value) / CGFloat(self.max) * container.size.height * 0.8)
                    }
                }
            }
        }
    }
    

In the example above, we use multiple overloaded versions of accessibility
modifier to set label and value on a capsule shape.

####  Accessibility tree

Let’s talk about accessibility path of every view. SwiftUI builds
accessibility tree for the entire screen and provides it to VoiceOver or any
other assistive technology. VoiceOver reads the accessibility tree from top to
bottom and allows to user navigate through it via short swipes.

SwiftUI allows us to modify the accessibility tree in different ways. For
example, we can change the order used by VoiceOver to navigate through the
tree. To do that we have to use accessibility modifier with sort priority
parameter.

We also can hide some elements in the accessibility tree by using another
overloaded version of accessibility modifier. It accepts a boolean parameter
indicating whenever element should be hidden or not.

    
    
    VStack {
        BarsView(bars: bars)
        LabelsView(bars: bars, labelsCount: labelsCount)
            .accessibility(hidden: true)
        LegendView(bars: bars)
            .padding()
            .accessibility(sortPriority: 1)
    }
    

In the recent example, we use accessibility with sort priority parameter to
reorder accessibility tree of the view. By default, every view has a priority
equals to zero. **Remember that higher numbers appear first.**

####  AccessibilityChildBehavior

Sometimes we need to combine accessibility elements inside any view and assign
it to a parent view as a single accessibility element. It becomes super handy
when you want to make your cells easily navigable with VoiceOver. You can
combine accessibility elements inside it into a single element attached to the
cell itself. We can do that by using _accessibilityElement_ modifier. Let’s
take a look at a quick example.

    
    
    struct SleepDetailsRow: View {
        let value: String
        let symbol: String
        let description: String
    
        var body: some View {
            HStack {
                Text(description)
                    .foregroundColor(.secondary)
                    .font(.body)
    
                Spacer()
    
                Text(value)
                    .font(.headline)
                    +
                    Text(symbol)
                        .font(.subheadline)
            }.accessibilityElement(children: .combine)
        }
    }
    

Here we use _accessibilityElement_ modifier with children combine option which
merges all the accessibility information provided by the children into a
single element and assign it to a parent view. _accessibilityElement_ modifier
also allows us to ignore or contain children accessibility information by
using other options provided by _AccessibilityChildBehavior_ .

####  Conclusion

Today we learned how to customize accessibility experience in our apps by
using simple accessibility modifier in SwiftUI. I hope you will use that
information to improve your User Experience. Remember that accessibility isn’t
a feature or a “nice to have.” **It’s a necessity** . So let’s make your app
accessible for everyone. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# visionOS ornaments in SwiftUI

##  visionOS ornaments in SwiftUI

30 Jan 2024

The new Apple Vision Pro device is almost here, and SwiftUI is the best way to
build a visionOS app quickly and natively. This week, we will continue the
topic of the new SwiftUI APIs that we can use to adapt our apps to visionOS.
We will learn about the new user interface component called ornaments.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In visionOS, an ornament presents controls and information related to a window
without crowding or obscuring the window’s contents. visionOS uses ornaments
to display toolbars, tab bars, etc. But you can build your custom ornaments
too. Let’s start by creating our first ornament using old but gold _TabView_ .

    
    
    struct ExampleView1: View {
        var body: some View {
            TabView {
                Text("List")
                    .tabItem {
                        Label("List", systemImage: "checklist")
                    }
                
                Text("Favorites")
                    .tabItem {
                        Label("Favorites", systemImage: "star")
                    }
            }
        }
    }
    

![ornament-example](/public/ornament1.png)

As you can see in the example above, we don’t do something special. We use the
_TabView_ that the SwiftUI framework offers us from the very first version.
This is another place where the magic of the declarative framework works
seamlessly. SwiftUI automatically adapts its environment and creates an
ornament to display the tab bar. We can’t control the ornament that the system
creates, and it provides us with default behavior while we hover it.

![ornament-example](/public/ornament2.png)

_TabView_ automatically creates an ornament to provide us access to navigation
in a very native way. We can also use the Toolbar API that the SwiftUI
framework provides to build another type of ornament.

    
    
    struct ExampleView2: View {
        var body: some View {
            Text("Hello World")
                .toolbar {
                    ToolbarItem(placement: .bottomOrnament) {
                        Button("New", systemImage: "pencil") {
                            // new action
                        }
                    }
                    
                    ToolbarItem(placement: .bottomOrnament) {
                        Button("Save", systemImage: "square.and.arrow.down") {
                            // save action
                        }
                    }
                }
        }
    }
    

![ornament-example](/public/ornament3.png)

In the example above, we use the Toolbar API to place action controls in an
ornament. The _ToolbarPlacement_ type provides us the _bottomOrnament_
property, allowing us to place controls in the ornament below the window.
While adapting your app to visionOS, you might need different toolbar
placements depending on the platform. In this case, you can use conditional
compilation directives to provide the particular placement.

    
    
    struct ExampleView2: View {
        var body: some View {
            Text("Hello World")
                .toolbar {
                    ToolbarItem(placement: placement) {
                        Button("New", systemImage: "pencil") {
                            // new action
                        }
                    }
                    
                    ToolbarItem(placement: placement) {
                        Button("Save", systemImage: "square.and.arrow.down") {
                            // save action
                        }
                    }
                }
        }
        
        private var placement: ToolbarItemPlacement {
            #if os(visionOS)
            return .bottomOrnament
            #else
            return .primaryAction
            #endif
        }
    }
    

We learned how easily SwiftUI creates ornaments to adapt the look and feel of
visionOS. But we can go further and create custom ornaments to control its
position, look, and feel. SwiftUI provides the _ornament_ view modifier,
allowing us to develop super-custom ornament.

    
    
    struct ContentView: View {
        var body: some View {
            Text("Hello World!")
                .ornament(
                    visibility: .visible,
                    attachmentAnchor: .scene(.bottomTrailing),
                    contentAlignment: .bottom
                ) {
                    VStack {
                        Button("New", systemImage: "pencil") {
                            // new action
                        }
                        
                        Button("Save", systemImage: "square.and.arrow.down") {
                            // save action
                        }
                    }
                    .labelStyle(.iconOnly)
                    .padding(.vertical)
                    .glassBackgroundEffect()
                }
        }
    }
    

![ornament-example](/public/ornament4.png)

As you can see in the example above, we use the _ornament_ view modifier. The
_ornament_ view modifier takes a set of parameters. The _visibility_ parameter
allows us to control when the framework displays the ornament. We can hide it
by passing the _hidden_ value.

The _attachmentAnchor_ parameter allows us to control the position of the
ornament. It will enable us to define the point of the scene where we want to
attach the ornament.

The _contentAlignment_ parameter allows us to define which point of the
ornament framework should use while calculating its attachment point in
conjuction with the _attachmentAnchor_ parameter.

The last parameter of the _ornament_ view modifier is the _ViewBuilder_
closure, which allows us to provide the content of the ornament. As you can
see, we also use the _glassBackgroundEffect_ view modifier to add the
visionOS-styled background to our content.

Today, we learned how to use the SwiftUI framework to improve the user
experience of our apps on visionOS by using the new ornament concept. I hope
you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# API availability in Swift

##  API availability in Swift

17 May 2023

WWDC is coming pretty soon, and we are going to use a bunch of new APIs. But
how to use new APIs available only for the latest version of iOS? This week we
will learn about availability conditions in Swift.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Swift provides **#available** attributes allowing us to check the availability
of the function. Here is a quick example.

    
    
    func foo() {
        if #available(iOS 16, *) {
            // Use new APIs
        } else {
            // Use old APIs
        }
    }
    

As you can see in the example above, we use the _#available_ attribute to
check if the current platform supports the APIs from iOS 16. We also can use
the _#unavailable_ attribute to check if the platform is unavailable.

    
    
    func foo() {
        if #unavailable(iOS 16) {
            // Use old APIs
        } else {
            // Use new APIs
        }
    }
    

We learned how to use the _#available_ attribute to check the platform
version. But how the API developer should define functions and types to
provide the availability information?

    
    
    extension View {
        @available(iOS 14, *)
        func backportedTask<Value: Equatable>(
            id: Value,
            task: @Sendable @escaping () async -> Void
        ) -> some View {
            if #available(iOS 15, macOS 12, *) {
                return self.task(id: id, task)
            } else {
                return self.onChange(of: id) { _ in
                    Task { await task() }
                }
            }
        }
    }
    

Swift allows us to use the **@available** attribute to provide information
about the platform that function or type needs to run. We can separate
different platforms by using commas.

    
    
    extension View {
        @available(iOS 14, macOS 12, *)
        func backportedTask<Value: Equatable>(
            id: Value,
            task: @Sendable @escaping () async -> Void
        ) -> some View {
            if #available(iOS 15, macOS 12, *) {
                return self.task(id: id, task)
            } else {
                return self.onChange(of: id) { _ in
                    Task { await task() }
                }
            }
        }
    }
    

We also can define a function as deprecated or obsoleted by using the
_@available_ attribute. In the example below, we define a function as
introduced in iOS 14, deprecated in iOS 15, and obsoleted in iOS 16. The
_introduced_ parameter defines the minimal platform version needed to run the
particular function.

    
    
    extension View {
        @available(iOS, introduced: 14, deprecated: 15, obsoleted: 16)
        @available(macOS, introduced: 11, deprecated: 12, obsoleted: 13)
        func backportedTask<Value: Equatable>(
            id: Value,
            task: @Sendable @escaping () async -> Void
        ) -> some View {
            if #available(iOS 15, macOS 12, *) {
                return self.task(id: id, task)
            } else {
                return self.onChange(of: id) { _ in
                    Task { await task() }
                }
            }
        }
    }
    

Swift compiler generates the warning whenever you build the project with iOS
15 as the target. When you try to build the project with the target version
iOS 16, it will generate a compiler error. This is the main difference between
deprecated and obsoleted parameters.

    
    
    extension View {
        @available(iOS, introduced: 14, deprecated: 16, obsoleted: 17, message: "Use `task` view modifier instead.")
        func backportedTask<Value: Equatable>(
            id: Value,
            task: @Sendable @escaping () async -> Void
        ) -> some View {
            if #available(iOS 15, macOS 12, *) {
                return self.task(id: id, task)
            } else {
                return self.onChange(of: id) { _ in
                    Task { await task() }
                }
            }
        }
    }
    

You can also use the _message_ parameter to allow Swift compiler provide an
error or warning message during compilation.

    
    
    extension View {
        @available(iOS, introduced: 14, deprecated: 16, obsoleted: 17, renamed: "task")
        func backportedTask<Value: Equatable>(
            id: Value,
            task: @Sendable @escaping () async -> Void
        ) -> some View {
            if #available(iOS 15, macOS 12, *) {
                return self.task(id: id, task)
            } else {
                return self.onChange(of: id) { _ in
                    Task { await task() }
                }
            }
        }
    }
    

Another variant of the _@available_ attribute allows us to mark the function
or type as renamed. In this case, Xcode allows the user to press the warning
message and shows the fix button that replaces the old name with the new one.

Swift 5.8 introduced the _@backDeployed_ attribute allowing you to back-deploy
the functionality introduced in new versions but relying on the old code.

    
    
    extension View {
        @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
        @backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0)
        func task<Value: Equatable>(
            id: Value,
            closure: @Sendable @escaping () async -> Void
        ) -> some View {
            return self.onChange(of: id) { _ in
                Task { await closure() }
            }
        }
    }
    

Today we learned not only how to use the new APIs in the legacy codebase but
also how to be a good citizen on the platform and define the functions and
types with the platform availability information, which is crucial when you
work on a framework or library. I hope you enjoy the post. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Global actors in Swift

##  Global actors in Swift

12 Mar 2024

The Swift language allows us to define thread-safe types using actors. Actor
type automatically manages serial access to the data it protects. But what if
we need multiple types protected by a single serial access queue? That’s why
we have global actors, and today, we will learn how to use global actors in
Swift.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The main thread rendering is the best example of why we need to protect
multiple types with a single serial access queue. You may have a massive
collection of _UIViewControllers_ , _UIViews_ , or SwiftUI views running
concurrently, but in the end, you should update your user interface on the
serial main thread.

> If you are unfamiliar with the actor concept, look at my dedicated [ “Thread
> safety in Swift with actors” ](/2023/09/19/thread-safety-in-swift-with-
> actors/) post.

That’s why Swift provides us _@MainActor_ . Any _UIViewController_ or _UIView_
you create inherits _@MainActor_ access from its definition. SwiftUI’s _View_
protocol also defines its _body_ property with _@MainActor_ . This means your
view’s body, view, or controller always runs on the main thread and protects
you from accidentally updating the user interface from the background thread.

To fully understand the idea of the global actors, let’s inspect the
_@MainActor_ type a bit further.

    
    
    @globalActor actor MainActor : GlobalActor {
        static let shared: MainActor
    }
    

As you can see in the code example above, the _MainActor_ type is defined with
**actor** keyword and conforms to the _GlobalActor_ protocol. It also has the
**@globalActor** attribute. The _GlobalActor_ protocol requires you to specify
the _shared_ property to create a shared, also called a global instance of the
actor.

    
    
    @Observable @MainActor final class Store {
        // ...
    }
    

Now, we can easily mark any type we need with the _@MainActor_ attribute to
isolate it to the main actor. This means all the work in the particular type
runs serially on the main actor.

Let’s move forward and build our own global actor. Assume that you have a set
of types accessing the local storage and you want to keep files conflict-free
on the disk by running only in a serial order.

    
    
    @globalActor actor StorageActor: GlobalActor {
        static let shared = StorageActor()
    }
    

As you can see in the example above, we define the _StorageActor_ type
conforming to the _GlobalActor_ protocol using the **actor** keyword. The
_@globalActor_ attribute allows us to mark any type, function, or property
with the _@StorageActor_ .

    
    
    @StorageActor final class Cache {
        let folder: URL
        
        init(folder: URL) {
            self.folder = folder
        }
        
        func get(_ key: String) -> Data? {
            // ...
        }
        
        func set(data: Data, for key: String) {
            // ...
        }
    }
    
    @StorageActor final class Database<Value> {
        let folder: URL
        
        init(folder: URL) {
            self.folder = folder
        }
        
        func search(matching query: String) -> [Value] {
            // ...
        }
    }
    

Here, we create _Сache_ and _Database_ types using the _@StorageActor_
attribute. It allows us to run them on a shared serial queue managed by the
_StorageActor_ we created before.

Why do we use global actors rather than defining _Cache_ and _Database_ types
as actors? We can define _Cache_ and _Database_ as actors. Still, in this
case, every instance of the _Cache_ or _Database_ types will run on an
independent serial queue and protect its access alone. By marking our types
with the _@StorageActor_ , we belong them to a single serial queue managed by
the shared instance of the _StorageActor_ .

    
    
    @Observable final class Store {
        private(set) var data: Data?
        
        @StorageActor func load() async {
            let path: String = "some path"
            let content = FileManager.default.contents(atPath: path)
            
            await MainActor.run {
                self.data = content
            }
        }
    }
    

Remember that you can mark with the _@StorageActor_ attribute not only types
but also functions or properties of any type.

Today, we learned why and how to use global actors in Swift. You don’t need to
use global actors often in your apps. However, they become handy in particular
cases, such as main thread rendering. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Performance testing in Swift using the XCTest framework

##  Performance testing in Swift using the XCTest framework

15 Mar 2023

In Swift, we can do performance testing using the XCTest framework, which is a
part of the Xcode development environment. XCTest provides a comprehensive set
of tools for writing, running, and analyzing unit and performance tests for
Swift applications. This week we will learn how to do performance testing in
Swift using the XCTest framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The XCTest framework includes support for measuring the performance of
specific code paths in your application using XCTest’s performance testing
API. This API allows you to write tests that measure the execution time of a
particular block of code, and we can use it to measure how the performance of
your application changes over time as you make changes to your code.

To measure the performance of a specific code path, you can use the _measure_
function provided by the XCTest framework. This _function_ takes a closure
containing the code you want to measure, and it runs that code multiple times
to accurately measure its performance.

    
    
    import XCTest
    
    final class PerformanceTests: XCTestCase {
        func testPerformanceOfMyFunction() {
            self.measure {
                myFunction()
            }
        }
    }
    

When you run this test, the _measure_ function will run the code inside the
closure multiple times and calculate the average execution time. It will also
report the minimum and maximum execution times

Remember that we should use the _measure_ function to measure the performance
of small code paths, such as a single method or function. Don’t use the
_measure_ function to measure the performance of an entire application or a
large portion of code, as this can lead to inaccurate results.

To test the performance of larger code paths, we can use another overload of
the _measure_ function, allowing us to specify a particular metric or set of
metrics to measure while testing.

    
    
    import XCTest
    
    final class PerformanceTests: XCTestCase {
        var app: XCUIApplication!
    
        override func setUp() {
            continueAfterFailure = false
            app = XCUIApplication()
            app.launch()
        }
        
        func testPerformanceOfSearchFlow() {
             self.measure(metrics: [XCTMemoryMetric()]) {
                SearchScreen(app: app)
                    .goToSearch()
                    .query("Pasta")
                    .verifyResults(contains: "Pasta")
            }
        }
    }
    

As you can see in the example above, we create an instance of the
_XCTMemoryMetric_ type to measure only memory usage. There are a bunch of
available metric types like _XCTApplicationLaunchMetric_ , _XCTMemoryMetric_ ,
_XCTCPUMetric_ , _XCTStorageMetric_ , _XCTClockMetric_ , and
_XCTOSSignpostMetric_ .

> To learn about the Page Object pattern I’ve used in the example above, take
> a look at my [ “UI Testing using Page Object pattern in Swift”
> ](/2021/03/24/ui-testing-using-page-object-pattern-in-swift/) post.

You can use these measurements to optimize the performance of your code by
identifying any bottlenecks or areas where the execution time is longer than
expected.

In this article, we’ve explored the XCTest framework and its capabilities for
performance testing in Swift. We’ve learned how to write and run performance
tests using the XCTest framework. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!

Written by ChatGPT, redacted by Majid Jabrayilov.



# Mastering charts in SwiftUI. Scrolling.

##  Mastering charts in SwiftUI. Scrolling.

25 Jul 2023

Another feature we have been waiting for is scrolling charts. The latest
version of the Swift Charts framework provides the functionality, allowing us
to make any chart scroll in a few different ways. This week we will learn how
to make our charts scroll, and the customization points the Swift Charts
framework provides.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

We can make any chart scrollable by applying to it the _chartScrollableAxes_
modifier. You can make it scroll in the horizontal or vertical direction or
both. Let’s take a look at a quick example.

    
    
    struct ContentView: View {
        @State private var numbers = (0..<100)
            .map { _ in Double.random(in: 0...100) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
            }
            .chartScrollableAxes(.horizontal)
        }
    }
    

As you can see in the example above, we make our chart scrolling by attaching
the _chartScrollableAxes_ modifier with horizontal axes. We can also tune the
visible amount of data points in the chart using the _chartXVisibleDomain_
modifier.

    
    
    struct ContentView: View {
        @State private var numbers = (0..<100)
            .map { _ in Double.random(in: 0...100) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
            }
            .chartScrollableAxes(.horizontal)
            .chartXVisibleDomain(length: 10)
        }
    }
    

You can also use the _chartYVisibleDomain_ modifier if you make your chart
scroll in the vertical direction. Another customization point in the latest
version of the Swift Charts framework is the ability to set an initial scroll
position of a particular chart instance using the _chartScrollPosition_
modifier.

    
    
    struct ContentView: View {
        @State private var numbers = (0..<100)
            .map { _ in Double.random(in: 0...100) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
            }
            .chartScrollableAxes(.horizontal)
            .chartScrollPosition(initialX: 50)
            .chartXVisibleDomain(length: 10)
        }
    }
    

You must use the _chartScrollPosition_ modifier with a value on the particular
axes. In our example, we use the _chartScrollPosition_ modifier with the
number 50 indicating an index of the 50th element in the array.

The Swift Charts framework provides another overload of the
_chartScrollPosition_ modifier accepting a binding to a plottable value. This
version of the _chartScrollPosition_ modifier allows us to read and change the
visible region of the chart.

    
    
    struct ContentView: View {
        @State private var scrollPosition = 50
        @State private var numbers = (0..<100)
            .map { _ in Double.random(in: 0...100) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
            }
            .chartScrollableAxes(.horizontal)
            .chartScrollPosition(x: $scrollPosition)
            .onChange(of: scrollPosition) {
                print(scrollPosition)
            }
        }
    }
    

Remember that you can both read and write to the current position of the chart
using the _chartScrollPosition_ modifier accepting a binding. It updates the
value of the binding whenever the user changes the visible region of the
chart. It also updates the visible region of the chart whenever you change the
value of the binding programmatically.

The Swift Charts framework allows us to control the scrolling behavior using
the _chartScrollTargetBehavior_ modifier. For example, we can use it to enable
paging in the chart.

    
    
    struct ContentView: View {
        @State private var numbers = (0..<100)
            .map { _ in Double.random(in: 0...100) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
            }
            .chartScrollableAxes(.horizontal)
            .chartScrollTargetBehavior(
                .valueAligned(
                    unit: 5, 
                    majorAlignment: .page
                )
            )
        }
    }
    

As you can see in the example above, we use the _chartScrollTargetBehavior_
modifier with the value-aligned behavior. The Swift Charts uses the _unit_
parameter to calculate the next target while the user snaps the chart.

In contrast, the _majorAlignment_ parameter estimates the next target while
swiping. In our example, we use the _page_ option as _majorAlignment_ , which
means the chart will use the visible region’s size to calculate the next
target. We can also use units to define the major alignment.

    
    
    struct ContentView: View {
        @State private var numbers = (0..<100)
            .map { _ in Double.random(in: 0...100) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
            }
            .chartScrollableAxes(.horizontal)
            .chartScrollTargetBehavior(
                .valueAligned(
                    unit: 5,
                    majorAlignment: .unit(10)
                )
            )
        }
    }
    

We use dates on X axes very often while building charts. For this particular
case, the Swift Charts framework allows to align charts with dates.

    
    
    struct ContentView: View {
        let data: [Stats]
        
        var body: some View {
            Chart(data) { item in
                LineMark(
                    x: .value("Date", item.date, unit: .day),
                    y: .value("Value", item.value)
                )
            }
            .chartScrollableAxes(.horizontal)
            .chartScrollTargetBehavior(
                .valueAligned(
                    matching: DateComponents(minute: 0),
                    majorAlignment: .matching(DateComponents(hour: 0))
                )
            )
        }
    }
    

The value-aligned behavior is an instance of the
_ValueAlignedChartScrollTargetBehavior_ type conforming to the
_ChartScrollTargetBehavior_ protocol. You can build your own behaviors by
defining a type conforming to the _ChartScrollTargetBehavior_ protocol.

> To learn more about _ChartScrollTargetBehavior_ protocol and building custom
> target behaviors, take a look at my [ “Mastering ScrollView in SwiftUI.
> Target Behavior” ](/2023/06/20/mastering-scrollview-in-swiftui-target-
> behavior/) post.

Today we learned how to make our charts scrolling using new APIs available in
the Swift Charts framework. I hope you enjoy the post. Feel free to follow me
on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Customizing Toggle in SwiftUI

##  Customizing Toggle in SwiftUI

04 Mar 2020

This week we will continue mastering SwiftUI components by learning _Toggle_ .
_Toggle_ is a view that we can use to allow users to toggle any boolean state
in the app. SwiftUI enables us to customize toggles in a very convenient way
by providing _ToggleStyle_ protocol.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s start with the basics of the _Toggle_ component. To use _Toggle_ , we
need to create it by providing a binding to a boolean value that it is going
to toggle and a label view that can be any combination of views. Let’s take a
look at the very quick example of using a toggle.

    
    
    struct ContentView: View {
        @State private var status = true
    
        var body: some View {
            Toggle(isOn: $status) {
                Text("toggle")
            }
        }
    }
    

> _Binding_ is a property wrapper that allows us to access value types in a
> reference like manner. To learn more about binding and other property
> wrappers provided by SwiftUI, take a look at my [ “Understanding Property
> Wrappers in SwiftUI” ](/2019/06/12/understanding-property-wrappers-in-
> swiftui/) post.

By default, SwiftUI uses the _UISwitch_ view from _UIKit_ to represent a
_Toggle_ . There is no way to change the tint color of _Toggle_ from SwiftUI,
but we can use _UIAppearance API_ from _UIKit_ to set the tint color for all
_UISwitch_ instances across the app. You can paste this line in _AppDelegate_
to configure the color before you create a view.

    
    
    UISwitch.appearance().onTintColor = .orange
    

Another thing which I want to mention is that you can easily hide the label of
your _Toggle_ by using a _labelsHidden_ modifier.

    
    
    struct ContentView: View {
        @State private var status = true
    
        var body: some View {
            Toggle(isOn: $status) {
                Text("toggle")
            }.labelsHidden()
        }
    }
    

####  Toggle collection

The SwiftUI framework allows us to create a _Toggle_ that binds to a
collection of values. In the example below, we define a _Toggle_ that uses
keypath to boolean on the array of tasks.

    
    
    struct Task: Identifiable {
        let id = UUID()
        var done = false
        var title = ""
    }
        
    struct ContentView: View {
        @State private var tasks: [Task] = [
            .init(title: "Task 1"),
            .init(title: "Task 2"),
        ]
        
        var body: some View {
            List {
                ForEach($tasks, id: \.id) { $task in
                    Toggle(isOn: $task.done) {
                        Text(verbatim: task.title)
                    }
                }
                
                Toggle(sources: $tasks, isOn: \.done) {
                    Text("Mark all")
                }
            }
        }
    }
    

####  Styling

We learned how to change the tint color of _Toggle_ , but what about real
styling options. For example, you might want to replace the _UISwitch_
presentation of toggles with a checkbox. SwiftUI provides a _ToggleStyle_
protocol that allows us to customize toggles in a way we can imagine.

    
    
    @available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
    public protocol ToggleStyle {
        associatedtype Body : View
    
        func makeBody(configuration: Self.Configuration) -> Self.Body
    
        typealias Configuration = ToggleStyleConfiguration
    }
    

> It is so awesome that SwiftUI allows us to style views in a consistent way.
> SwiftUI also provides _ButtonStyle_ protocol that we can use to design
> buttons. To learn more, take a look at my [ “Mastering buttons in SwiftUI”
> ](/2020/02/19/mastering-buttons-in-swiftui/) post.

The only requirement of _ToggleStyle_ protocol is _makeBody_ function that
should return some view. _makeBody_ function has a single parameter that we
can use to access a user-defined label to place it according to our design and
binding that we can toggle when the user alters the state. Let’s create our
very first _Toggle_ style that will render it as a checkbox.

    
    
    struct CheckboxToggleStyle: ToggleStyle {
        func makeBody(configuration: Configuration) -> some View {
            return HStack {
                configuration.label
                Spacer()
                Image(systemName: configuration.isOn ? "checkmark.square" : "square")
                    .resizable()
                    .frame(width: 22, height: 22)
                    .onTapGesture { configuration.isOn.toggle() }
            }
        }
    }
    

As you can see in the example above, we create a _CheckboxToggleStyle_ struct
that conforms _ToggleStyle_ protocol. We place a user-defined label in an
_HStack_ with the _Image_ that uses _SF Symbols_ to display checkmark in a
square whenever binding is true or an empty square when binding is false.

![toggle](/public/toggle.png)

We can easily apply our _CheckboxToggleStyle_ to every _Toggle_ in our app by
using the _toggleStyle_ modifier. It uses the environment feature of SwiftUI
to share the style with all views in the current environment. But remember
that you can easily use this modifier on the concrete _Toggle_ instance also.

    
    
    struct ContentView: View {
        @State private var status = true
    
        var body: some View {
            Toggle(isOn: $status) {
                Text("toggle")
            }.toggleStyle(CheckboxToggleStyle())
        }
    }
    

> SwiftUI uses environment to pass system-wide and application-related
> information. You can also populate environment with your custom objects. To
> learn more about environment, take a look at my [ “The power of Environment
> in SwiftUI” ](/2019/08/21/the-power-of-environment-in-swiftui/) post.

####  Conclusion

Today we learned about another vital SwiftUI component. I’m delighted that
SwiftUI provides a very consistent way of styling views. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Redux-like state container in SwiftUI. Best practices.

##  Redux-like state container in SwiftUI. Best practices.

25 Sep 2019

Last week we talked about [ building a state container similar to Redux in
SwiftUI ](/2019/09/18/redux-like-state-container-in-swiftui/) . _Redux_
provides a single source of truth, which eliminates tons of bugs produced by
multiple states across the app. This week we will talk about best practices in
building _Redux-based_ apps which allows us to keep our codebase simple and
clean.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  State normalization

_Redux_ stores the whole app’s state as a single source of truth. It allows us
to keep our _User Interface_ in sync with the app state. But to achieve this,
we have to normalize our state. Let’s take a look at the example.

    
    
    struct AppState {
        var allTasks: [Task]
        var favorited: [Task]
    }
    

Here we have an _AppState_ struct which stores a task list and favorited
tasks. It looks straightforward, but it has one big downside. Assume that you
have the edit task screen where you can modify the selected task. Whenever the
user hits the save button, you have to find and update a particular task in
the allTasks list and favorited list. It can be error-prone and lead to a
performance issue as soon as you have a long list of tasks.

Let’s improve performance by normalizing our state struct. First of all, we
need to store our tasks in _Dictionary_ where task id is the key and task
itself is the value. _Dictionary_ can retrieve the value by key in constant
**(O(1))** time, but it doesn’t keep the order. We can create an array with
ids to save the order. Let’s take a look at the normalized version of our
state.

    
    
    struct AppState {
        var tasks: [Int: Task]
        var allTasks: [Int]
        var favorited: [Int]
    }
    

As you can see in the example above, we store our tasks in the _Dictionary_
where task _id_ is the key, and the task is the value. We also store arrays of
identifiers for all tasks and favorited ones. By using identifiers instead of
copies, we achieve a centralized state persistence which keeps our _User
Interface_ and data in sync.

####  State composition

It is very natural to store your app’s state as a single struct, but it simply
can blow up as soon as you add more and more fields to your state struct. We
can use state composition to solve this issue. Let’s take a look at the
example.

    
    
    struct AppState {
        var calendar: CalendarState
        var trends: TrendsState
        var settings: SettingState
    }
    

In the example above, we divide our state into three dedicated pieces and
compose them into _AppState_ .

####  Reducer composition

Another important component of our _Redux-like_ state container is _Reducer_ .
We can extract and compose it as we do with state struct. It will allow us to
respect a _Single Responsibility_ principle and keep our reducers small and
clean.

    
    
    enum AppAction {
        case calendar(action: CalendarAction)
        case trends(action: TrendsAction)
    }
    
    func trendsReducer(
        state: inout TrendsState,
        action: TrendsAction
    ) -> AnyPublisher<TrendsAction, Never> {
        // Implement your state changes here
    }
    
    func calendarReducer(
        state: inout CalendarState,
        action: CalendarAction
    ) -> AnyPublisher<CalendarAction, Never>{
        // Implement your state changes here
    }
    
    func appReducer(
        state: inout AppState,
        action: AppAction
    ) -> AnyPublisher<AppAction, Never> {
        switch action {
        case let .calendar(action):
            return calendarReducer(&state.calendar, action)
                .map(AppAction.calendar)
                .eraseToAnyPublisher()
        case let .trends(action):
            trendsReducer(&state.trends, action)
                .map(AppAction.trends)
                .eraseToAnyPublisher()
        }
    
        return Empty().eraseToAnyPublisher()
    }
    

####  Derived stores

Another way of composition that should simplify our architecture is derived
stores. I don’t want to expose the whole app state to every view or update
views on not related state updates. Here is a small example from my CardioBot
app.

    
    
    import SwiftUI
    
    struct RootView: View {
        @EnvironmentObject var store: Store<AppState, AppAction>
    
        var body: some View {
            TabView {
                NavigationView {
                    SummaryContainerView()
                        .navigationBarTitle("today")
                        .environmentObject(
                            store.derived(
                                deriveState: \.summary,
                                deriveAction: AppAction.summary
                            )
                    )
                }.tabItem {
                    Image(systemName: "heart.fill")
                        .imageScale(.large)
                    Text("today")
                }
    
                NavigationView {
                    TrendsContainerView()
                        .navigationBarTitle("trends")
                        .environmentObject(
                            store.derived(
                                deriveState: \.trends,
                                deriveAction: AppAction.trends
                            )
                    )
                }.tabItem {
                    Image(systemName: "chevron.up.circle.fill")
                        .imageScale(.large)
                    Text("trends")
                }
            }
        }
    }
    

As you can see, every tab of my app gets its part of the state via the derived
store. We still use the global store to handle all the state mutation. Derived
store works as a pipeline that allows us to transform the state from the
global store and redirect actions to the global store. Let’s take a look at
how we can implement the _derived_ method for our _Store_ class.

    
    
    func derived<DerivedState: Equatable, ExtractedAction>(
        deriveState: @escaping (State) -> DerivedState,
        embedAction: @escaping (ExtractedAction) -> Action
    ) -> Store<DerivedState, ExtractedAction> {
        let store = Store<DerivedState, ExtractedAction>(
            initialState: deriveState(state),
            reducer: Reducer { _, action, _ in
                self.send(embedAction(action))
                return Empty().eraseToAnyPublisher()
            },
            environment: ()
        )
        $state
            .map(deriveState)
            .removeDuplicates()
            .receive(on: DispatchQueue.main)
            .assign(to: &store.$state)
        return store
    }
    

####  Conclusion

Today we talked about two important strategies which we should use during app
development using _Redux-like_ state containers in SwiftUI. Both normalization
and composition keep our app state simple and maintainable. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading and see you next
week!

  1. [ Redux-like state container in SwiftUI. Basics ](/2019/09/18/redux-like-state-container-in-swiftui/)
  2. Redux-like state container in SwiftUI. Best practices 
  3. [ Redux-like state container in SwiftUI. Container Views. ](/2019/10/02/redux-like-state-container-in-swiftui-part3/)
  4. [ Redux-like state container in SwiftUI. Connectors. ](/2021/02/03/redux-like-state-container-in-swiftui-part4/)
  5. [ Redux-like state container in SwiftUI. Swift concurrency model. ](/2022/02/17/redux-like-state-container-in-swiftui-part5/)

####  References

The series of posts have built on a foundation of ideas started by other
libraries, particularly Redux, Elm, and TCA.

  1. [ WWDC20 - Data Essentials in SwiftUI ](https://developer.apple.com/videos/play/wwdc2020/10040/)
  2. [ Redux ](https://redux.js.org) \- The JavaScript library that popularized unidirectional data flow. 
  3. [ The Elm Architecture ](https://guide.elm-lang.org/architecture/) \- A purely functional language and runtime that inspired the creation of Redux. 
  4. [ The Composable Architecture ](https://github.com/pointfreeco/swift-composable-architecture) \- A library that bridges concepts from the Elm Architecture and Redux to Swift. It introduced the “environment” and “effect” patterns that this series covers. 



# Thread safety in Swift with locks

##  Thread safety in Swift with locks

05 Sep 2023

Today, we will discuss thread safety, an essential programming aspect. I
decided to cover this topic because of the issue I’ve noticed in the codebase
I helped to build. This type of bug is straightforward to create but very hard
to fix. So investing time into building a type-safe type in your codebase is
much better.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s look at a simple example of the state management concept.

    
    
    @dynamicMemberLookup final class Store<State, Action> {
        typealias Reduce = (State, Action) -> State
        
        private var state: State
        private let reduce: Reduce
        
        init(state: State, reduce: @escaping Reduce) {
            self.state = state
            self.reduce = reduce
        }
        
        subscript<T>(dynamicMember keyPath: KeyPath<State, T>) -> T {
            state[keyPath: keyPath]
        }
        
        func send(_ action: Action) {
            state = reduce(state, action)
        }
    }
    

The _Store_ type looks pretty simple. Is there a condition where this type can
crash your app? Yes, this type may lead to data races and race conditions
where the first one crashes your app, and the second may break the logic you
use. We can prove it by writing a simple unit test.

    
    
    import XCTest
    
    final class StoreTests: XCTestCase {
        struct State {
            var value = 0
        }
        
        func testThreadSafety() {
            let store = Store<State, Void>(state: .init()) { state, _ in
                var state = state
                state.value += 1
                return state
            }
            
            DispatchQueue.concurrentPerform(iterations: 1_000_000) { _ in
                store.send(())
            }
            
            XCTAssertEqual(store.value, 1_000_000)
        }
    }
    

Assume that you share a _Store_ instance between different threads in your
app, and whenever one thread tries to read the state variable while another
thread is writing it crashes.

We can control the concurrent access to the state variable using a lock
mechanism to solve the issue. Apple provides us with the
_OSAllocatedUnfairLock_ type from iOS 16. It allows us to lock the access to
the variable while we read or write it to guarantee exclusive access.

    
    
    @dynamicMemberLookup final class Store<State, Action> {
        typealias Reduce = (State, Action) -> State
        
        private var state: OSAllocatedUnfairLock<State>
        private let reduce: Reduce
        
        init(state: State, reduce: @escaping Reduce) {
            self.state = .init(initialState: state)
            self.reduce = reduce
        }
        
        subscript<T>(dynamicMember keyPath: KeyPath<State, T>) -> T {
            state.withLock { $0[keyPath: keyPath] }
        }
        
        func send(_ action: Action) {
            state.withLock { state in
                state = reduce(state, action)
            }
        }
    }
    

As you can see in the example above, we wrap our _state_ property with an
instance of the _OSAllocatedUnfairLock_ type. Whenever we need to read or
write the _state_ property, we cover the logic with the _withLock_ function.
It automatically locks and releases at the end of the closure we provide.

_OSAllocatedUnfairLock_ is very fast, but it doesn’t support recursive
locking. It crashes whenever you lock it twice from the same thread, so you
should be careful while using it and not call it recursively. Instead, you can
use the _NSRecursiveLock_ type, allowing the same thread to lock recursively,
but this implementation is a bit slower than _OSAllocatedUnfairLock_ .

    
    
    @dynamicMemberLookup final class Store<State, Action> {
        typealias Reduce = (State, Action) -> State
        
        private var state: State
        private let reduce: Reduce
        
        private let lock = NSRecursiveLock()
        
        init(state: State, reduce: @escaping Reduce) {
            self.state = state
            self.reduce = reduce
        }
        
        subscript<T>(dynamicMember keyPath: KeyPath<State, T>) -> T {
            lock.withLock {
                state[keyPath: keyPath]
            }
        }
        
        func send(_ action: Action) {
            lock.withLock {
                state = reduce(state, action)
            }
        }
    }
    

Finally, we can safely share an instance of the _Store_ type between different
threads and never worry about strange crashes. You should always make your
classes thread-safe whenever possible to use them in the multithreaded
environment, even accidentally. Invest earlier and save your time in the
future.

Today we learned how to use the _NSRecursiveLock_ and _OSAllocatedUnfairLock_
types to make any class thread safe. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and happy multithreading!



# Reusing SwiftUI views across Apple platforms

##  Reusing SwiftUI views across Apple platforms

23 Oct 2019

This week we will talk about reusing SwiftUI views between Apple platforms. We
will learn how to run the same views both on iOS, watchOS and macOS without
any changes. To make it possible, all we need is an understanding of the view
decomposition principle.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

One of the slogans of SwiftUI during _WWDC_ this year was “Learn one time, use
anywhere”. SwiftUI is a _declarative_ framework for building _User Interfaces_
on Apple platforms. But what does mean the word **declarative** ? It means
that you describe what you want to achieve, and the framework does all the
needed work for you. Depending on the platform, SwiftUI can render content
differently.

![napbot-screenshot](/public/napbot.jpeg)

Last month I had released my [ NapBot app ](https://napbot.swiftwithmajid.com)
, which I wrote entirely in SwiftUI. What I really love in this app is the how
easy I was able to share my views between iOS and watchOS apps. I was able to
run my app on watchOS just in a few minutes by adding a couple of small target
checks.

Let’s take a look at a calendar day details screen. It uses a list component
as the root view. Inside the list, we have a chart and a bunch of sections
with text data. We already talked about creating a bar chart in [ “Building
BarChart with Shape API in SwiftUI” ](/2019/08/14/building-barchart-with-
shape-api-in-swiftui/) post, check that post if you want to learn more about
_Shapes API_ .

####  #if macro

This screen also has a picker component with the _SegmentedPicker_ style,
which allows changing the data represented in the chart. Unfortunately,
watchOS doesn’t support _SegmentedPicker_ style. That’s why I decide to remove
it from the watchOS app but keep it in the iOS app. We can conditionally
include or exclude code by using **#if macro** in SwiftUI. Let’s take a look
at the source code of my _SleepDetailsView_ .

    
    
        @State private var chart: Chart = .sleepPhases
    
        private var chartSection: some View {
            VStack {
                #if os(iOS)
                Picker(selection: $chart, label: Text("chartType")) {
                    Text("phases").tag(Chart.sleepPhases)
                    Text("heartRate").tag(Chart.heartRate)
                }
                .pickerStyle(SegmentedPickerStyle())
                .labelsHidden()
                #endif
    
                BarChartView(bars: bars, labelsCount: 5)
                    .frame(height: 280)
            }
        }
    

As you can see in the example above, we keep the picker component in the view
hierarchy only when we build it for iOS. Swift compiler will exclude these
lines during the watch app build process.

####  Container views

Another problem while adopting the sleep details screen to watchOS was a
_NavigationBarItems_ . watchOS doesn’t have support for navigation bar items
at all. Fortunately, I’m a huge fan of the _Container Views_ concept, which
allows us to get rid of this problem.

_Container View_ is a view that handles the data flow and doesn’t render any
_User Interface_ itself. Instead, _Container View_ fetches the data and passes
it to a _Rendering View_ . We already talked about _Container Views_ a few
times on my blog. Please check the [ “Introducing Container views in SwiftUI”
](/2019/07/31/introducing-container-views-in-swiftui/) post to learn more.

I have a _SleepDetailsContainer_ and _SleepDetailsView_ .
_SleepDetailsContainer_ controls the data flow and passes data to
_SleepDetailsView_ . _SleepDetailsView_ simply renders the data. Here is the
source code of these two views.

    
    
    struct SleepDetailsContainer: View {
        @EnvironmentObject var store: SleepStore
    
        var body: some View {
            SleepDetailsView(sleep: store.sleep)
                .onAppear(perform: store.fetch)
                .navigationBarItems(trailing: EditButton())
        }
    }
    
    struct SleepDetailsView: View {
        let sleep: Sleep
    
        var body: some View {
            Form {
                chartSection
                durationSection
                phasesSection
                heartRateSection
                noiseSection
            }
        }
    }
    

In this case, we have _SleepDetailsView_ , which is fully compatible with
watchOS. All we need is creating a new version of _SleepDetailsContainer_ for
watchOS, which doesn’t use navigation items. And here is the result.

![napbot-watch-screenshot](/public/napbot-watch.jpeg)

####  Conclusion

Today we learned how to reuse SwiftUI views on all Apple platforms with the
minimum amount of changes. _Container Views_ concept is still one of my
favorite patterns, which I use a lot while developing SwiftUI apps. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering Observation framework in Swift

##  Mastering Observation framework in Swift

03 Oct 2023

Apple introduced the new Observation framework powered by the macro feature of
the Swift language. The new Observation framework, in combination with the
Swift Concurrency features, allows us to replace the Combine framework that
looks deprecated by Apple. This week, we will learn how to use the Observation
framework to handle data flow in our apps.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Using the new Observation Framework is super easy. All you need to do is to
mark your class with the **@Observable** macro.

    
    
    @Observable final class Store<State, Action> {
        typealias Reduce = (State, Action) -> State
        
        private(set) var state: State
        private let reduce: Reduce
        
        init(initialState state: State, reduce: @escaping Reduce) {
            self.state = state
            self.reduce = reduce
        }
        
        func send(_ action: Action) {
            state = reduce(state, action)
        }
    }
    

As you can see in the example above, we use the _@Observable_ macro to
annotate our _Store_ type. After that, we can observe any variable in the
_Store_ type. We have only one variable in the _Store_ type that defines the
store’s state. Another field is a _let_ constant that never changes.

    
    
    withObservationTracking {
        render(store.state)
    } onChange: {
        print("State changed")
    }
    

To observe an instance of the _Store_ type, we need to call the
_withObservationTracking_ function with two closures. In the first closure, we
can touch all the needed properties of the observable type. The Observation
framework calls the second closure only once as soon as any touched property
of the observed type changes.

    
    
    func startObservation() {
        withObservationTracking {
            render(store.state)
        } onChange: {
            Task { startObservation() }
        }
    }
    

The Observation framework runs the _onChange_ only once, which means you
should call it recursively to observe changes constantly. Another thing you
should be aware of is that _onChange_ closure runs before the actual change
applies. That’s why we postpone the _onChange_ action by starting a new task.

In SwiftUI, you don’t need to use the _withObservationTracking_ function to
observe changes. SwiftUI automatically tracks changes of any observable type’s
property used inside the view body.

    
    
    struct ProductsView: View {
        let store: Store<AppState, AppAction>
        
        var body: some View {
            List(store.state.products, id: \.self) { product in
                Text(product)
            }
            .onAppear {
                store.send(.fetch)
            }
        }
    }
    

As you can see in the example above, we don’t use any property wrappers to
observe the store. SwiftUI does it automatically. As soon as the state
property of the store changes, SwiftUI updates the view. We don’t need the
_@ObservedObject_ property wrapper to track changes in observable types, but
we still need the _@StateObject_ alternative to survive through the SwiftUI
lifecycle.

Apple simplifies the set of property wrappers we should use with the new
Observation framework. Instead of the _@StateObject_ property wrapper, we can
use _@State_ now. _@State_ property wrapper works for simple value types and
any observable types now.

    
    
    struct ContentView: View {
        @State private var store = Store<AppState, AppAction>(
            initialState: .init(),
            reduce: reduce
        )
        
        var body: some View {
            ProductsView(store: store)
        }
    }
    

The same approach goes to the environment feature of the SwiftUI framework.
There is no need for the _@EnvironmentObject_ property wrapper now. You can
now use the _@Environment_ property wrapper and the _environment_ view
modifier with observable types.

    
    
    struct ContentView: View {
        @State private var store = Store<AppState, AppAction>(
            initialState: .init(),
            reduce: reduce
        )
        
        var body: some View {
            ProductsView()
                .environment(store)
        }
    }
    
    struct ProductsView: View {
        @Environment(Store<AppState, AppAction>.self) var store
        
        var body: some View {
            List(store.state.products, id: \.self) { product in
                Text(product)
            }
            .onAppear {
                store.send(.fetch)
            }
        }
    }
    

The last thing you may wonder is how to derive a binding from an observable
type. SwiftUI introduces a _@Bindable_ property wrapper for this case that
works only with observable types.

    
    
    @Observable final class AuthViewModel {
        var username = ""
        var password = ""
        
        var isAuthorized = false
        
        func authorize() {
            isAuthorized.toggle()
        }
    }
    
    struct AuthView: View {
        @Bindable var viewModel: AuthViewModel
        
        var body: some View {
            VStack {
                if !viewModel.isAuthorized {
                    TextField("username", text: $viewModel.username)
                    SecureField("password", text: $viewModel.password)
                    
                    Button("authorize") {
                        viewModel.authorize()
                    }
                } else {
                    Text("Hello, \(viewModel.username)")
                }
            }
        }
    }
    

You can use the _@Bindable_ property wrapper to create bindings from the
properties of any observable type easily. Sometimes, you may need to inline
_@Bindable_ inside the view body to create bindings.

    
    
    struct InlineAuthView: View {
        @Environment(AuthViewModel.self) var viewModel
        
        var body: some View {
            @Bindable var viewModel = viewModel
            
            VStack {
                if !viewModel.isAuthorized {
                    TextField("username", text: $viewModel.username)
                    SecureField("password", text: $viewModel.password)
                    
                    Button("authorize") {
                        viewModel.authorize()
                    }
                } else {
                    Text("Hello, \(viewModel.username)")
                }
            }
        }
    }
    

I love how the new Observation framework simplifies the data flow in SwiftUI.
I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering ScrollView in SwiftUI

##  Mastering ScrollView in SwiftUI

24 Sep 2020

We had the scroll view from the very first version of SwiftUI. It was quite
limited. But this year changed everything when Apple released
_ScrollViewReader_ during WWDC 20. This week we will learn all about scroll
views in SwiftUI. We will learn how to scroll to the particular position and
read the current offset of scroll view content.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

The usage of a scroll view is pretty simple. You create a scroll view and pass
the content inside a _ViewBuilder_ closure. Let’s take a look at the first
example.

    
    
    import SwiftUI
    
    struct ContentView1: View {
        var body: some View {
            ScrollView {
                ForEach(0..<100) { index in
                    Text(String(index))
                }
            }
        }
    }
    

We have a few parameters to control the scroll view behavior. We can set the
axis of the scroll. It can be horizontal, vertical, or both. Another parameter
allows us to show or hide the scrolling indicators.

####  ScrollViewReader

During WWDC20, Apple released _ScrollViewReader_ that allows us to scroll to a
particular position. Let’s take a look at how we can use it.

    
    
    import SwiftUI
    
    struct ContentView1: View {
        var body: some View {
            ScrollViewReader { scrollView in
                ScrollView {
                    Button("Scroll to bottom") {
                        scrollView.scrollTo(99, anchor: .center)
                    }
    
                    ForEach(0..<100) { index in
                        Text(String(index))
                            .id(index)
                    }
                }
            }
        }
    }
    

As you can see in the example above, we define a _ScrollViewReader_ that
passes the scroll view parameter to its _ViewBuilder_ closure.
_ScrollViewReader_ traverses its child view, find the first scroll view and
pass it into its _ViewBuilder_ closure.

The parameter of _ViewBuilder_ closure is an instance of _ScrollViewProxy_ .
_ScrollViewProxy_ is a simple struct that provides us _scrollTo_ function. We
can use this function to scroll to any view that defines its **id** . We can
also provide an anchor point of the view to align its position.

I have to mention that the _scrollTo_ function is animatable, and you can wrap
it using _withAnimation_ function to animate scrolling.

    
    
    import SwiftUI
    
    struct ContentView1: View {
        var body: some View {
            ScrollViewReader { scrollView in
                ScrollView {
                    Button("Scroll to bottom") {
                        withAnimation {
                            scrollView.scrollTo(99, anchor: .center)
                        }
                    }
    
                    ForEach(0..<100) { index in
                        Text(String(index))
                            .id(index)
                    }
                }
            }
        }
    }
    

**Tip: You can use ScrollViewReader with List also.**

####  ScrollView content offset

Now we can move scroll view content to a particular position, but what about
reading the content offset. How can we keep the view updated while the user
scrolling the content? We don’t have this behavior out of the box, but we can
easily implement it using preferences.

> If you are not familiar with preferences in SwiftUI, I suggest reading my [
> “The magic of view preferences in SwiftUI” ](/2020/01/15/the-magic-of-view-
> preferences-in-swiftui/) post.

Let’s start with defining a preference key type that will store the current
content offset using _CGPoint_ .

    
    
    private struct ScrollOffsetPreferenceKey: PreferenceKey {
        static var defaultValue: CGPoint = .zero
        
        static func reduce(value: inout CGPoint, nextValue: () -> CGPoint) {}
    }
    

Now we can create a view that will replace the scroll view from SwiftUI and
reuse it under the hood by providing the ability to read the content offset.

    
    
    struct ScrollView<Content: View>: View {
        let axes: Axis.Set
        let showsIndicators: Bool
        let offsetChanged: (CGPoint) -> Void
        let content: Content
    
        init(
            axes: Axis.Set = .vertical,
            showsIndicators: Bool = true,
            offsetChanged: @escaping (CGPoint) -> Void = { _ in },
            @ViewBuilder content: () -> Content
        ) {
            self.axes = axes
            self.showsIndicators = showsIndicators
            self.offsetChanged = offsetChanged
            self.content = content()
        }
    }
    

As you can see, we have a pretty similar to SwiftUI’s scroll view definition.
It uses the same parameters but also adds _offsetChanged_ closure that we will
call whenever content offset changes. Let’s move to the body property
implementation of our scroll view.

    
    
    struct ScrollView<Content: View>: View {
        // ...
        var body: some View {
            SwiftUI.ScrollView(axes, showsIndicators: showsIndicators) {
                GeometryReader { geometry in
                    Color.clear.preference(
                        key: ScrollOffsetPreferenceKey.self,
                        value: geometry.frame(in: .named("scrollView")).origin
                    )
                }.frame(width: 0, height: 0)
                content
            }
            .coordinateSpace(name: "scrollView")
            .onPreferenceChange(ScrollOffsetPreferenceKey.self, perform: offsetChanged)
        }
    }
    

As I said before, we use SwiftUI’s scroll view under the hood and pass all the
parameters to configure its behavior. Before adding the content, we place a
_GeometryReader_ view that allows us to track the content offset changes. We
use preferences to pass the origin point of our content to the parent view.

> To learn more about _GeometryReader_ , look at my [ “Building BarChart with
> Shape API in SwiftUI” ](/2019/08/14/building-barchart-with-shape-api-in-
> swiftui/) post.
    
    
    struct ContentView: View {
        var body: some View {
            ScrollView(
                axes: [.horizontal, .vertical],
                showsIndicators: false,
                offsetChanged: { print($0) }
            ) {
                ForEach(0..<100) { i in
                    Text("Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.")
                }
            }
        }
    }
    

####  Conclusion

Today we learned all about using a scroll view in SwiftUI. It looks like now
we can use SwiftUI’s scroll view and forget about wrapping _UIScrollView_ with
_UIViewRepresentable_ . I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
article. Thanks for reading, and see you next week!



# Microapps architecture in Swift. Dependency Injection.

##  Microapps architecture in Swift. Dependency Injection.

02 Feb 2022

We covered a lot of things related to microapps architecture in Swift during
the last month. I would love to finalize the series of posts by touching
another essential edge of the approach: Dependency Injection. This week we
will learn how to inject the dependencies into feature modules to improve
testability and facilitate Xcode previews.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

As we told before, we should build our feature modules as completely isolated
apps. That’s why we call them microapps. Every microapp can have its
architecture or state management approach depending on the feature complexity.
You can use MVVM in one module or unidirectional flow in another module.

> To learn more about unidirectional flow, take a look at my [ “Redux-like
> state container in SwiftUI” ](/2019/09/18/redux-like-state-container-in-
> swiftui/) post.

Feature modules shouldn’t implement low-level functionality like networking or
caching. Feature modules should define the dependencies needed, and the app
coordinator or container fulfills them. Let’s take a look at some examples.

Assume that we are working on a search feature module. We need to make an API
request to search for the items matching our query. We also need to fetch
recent queries to show query history. Let’s start with defining the view model
for our search view.

    
    
    @MainActor public final class SearchViewModel: ObservableObject {
        public struct Dependencies {
            var search: (String) async throws -> [String]
            var fetchRecent: () async throws -> [String]
        }
    
        let dependencies: Dependencies
        public init(dependencies: Dependencies) {
            self.dependencies = dependencies
        }
    }
    

As you can see in the example above, we create the _SearchViewModel_ that
defines the _Dependencies_ type. The _Dependencies_ struct list all the low-
level pieces that we need to implement the functionality of our view model.
Now we can move on to fulfill the logic we need in our _SearchView_ .

    
    
    @MainActor public final class SearchViewModel: ObservableObject {
        public struct Dependencies {
            var search: (String) async throws -> [String]
            var fetchRecent: () async throws -> [String]
        }
    
        let dependencies: Dependencies
        public init(dependencies: Dependencies) {
            self.dependencies = dependencies
        }
    
        @Published private(set) var items: [String] = []
        @Published private(set) var recent: [String] = []
    
        func fetchRecent() async {
            do {
                recent = try await dependencies.fetchRecent()
            } catch {
                recent = []
            }
        }
    
        func search(matching query: String) async {
            do {
                items = try await dependencies.search(query)
            } catch {
                items = []
            }
        }
    }
    

This approach allows us to expose only necessary low-level logic to our view
model. The _SearchViewModel_ type defines its own set of dependencies and
requires them to compile.

In another case, the _SearchService_ type might implement different search
endpoint functions, and we can pass the instance inside the _SearchViewModel_
. The downside of this approach is that the _SearchViewModel_ type will have
access to all the parts of the _SearchService_ type, even if it doesn’t need
them.

    
    
    public struct SearchView: View {
        @ObservedObject var viewModel: SearchViewModel
        @State private var query: String = ""
    
        public init(viewModel: SearchViewModel) {
            self.viewModel = viewModel
        }
    
        public var body: some View {
            List(viewModel.items, id: \.self) { item in
                Text(item)
            }
            .navigationTitle("Search")
            .searchable(text: $query) {
                ForEach(viewModel.recent, id: \.self) { query in
                    Text(query)
                        .searchCompletion(query)
                }
            }
            .onSubmit(of: .search) {
                Task {
                    await viewModel.search(matching: query)
                }
            }
            .task { await viewModel.fetchRecent() }
        }
    }
    

> To learn more about the _searchable_ view modifier, take a look at my [
> “Mastering search in SwiftUI” ](/2021/06/23/mastering-search-in-swiftui/)
> post.

Another benefit of the approach we describe in this post is the opportunity to
easily mock dependencies to write unit tests and run previews in Xcode.

    
    
    extension SearchViewModel.Dependencies {
        static let mock: Self = .init(
            search: { _ in ["Search Item 1", "Search Item 2"] },
            fetchRecent: { ["query1", "query2"] }
        )
    }
    
    struct SearchView_Previews: PreviewProvider {
        static var previews: some View {
            NavigationView {
                SearchView(
                    viewModel: .init(
                        dependencies: .mock
                    )
                )
            }
        }
    }
    

Now let’s talk about where to store the whole app dependencies. Usually, we
have a container that initializes and keeps all the app’s services. We can
store it in the _AppDelegate_ or inside the root view of a SwiftUI app.

    
    
    struct SearchService {
        func search(matching query: String) async throws -> [String] {
            // ...
        }
    
        func fetchRecent() async throws -> [String] {
            // ...
        }
    
        func save(query: String) async throws {
            // ...
        }
    
        func delete(query: String) async throws {
            // ...
        }
    }
    
    struct AppDependencies {
        let searchService: SearchService
        let storage: Storage
    }
    
    extension AppDependencies {
        var search: SearchViewModel.Dependencies {
            .init(
                search: searchService.search,
                fetchRecent: searchService.fetchRecent
            )
        }
    }
    
    struct RootView: View {
        let dependencies = AppDependencies()
    
        var body: some View {
            SearchView(
                viewModel: .init(
                    dependencies: dependencies.search
                )
            )
        }
    }
    

As you can see, I also added the extension with calculated property to easily
extract dependencies only needed for the search feature module. You can have
this kind of property as many as you need to fulfill the requirements of all
the app’s feature modules.

Today we learned how to inject the low-level functionality inside feature
modules without exposing information about the concrete implementation. I hope
you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!

####  References

  1. [ Meet the microapps architecture ](https://increment.com/mobile/microapps-architecture/)
  2. [ Introduction to App Modularisation with Swift Package Manager ](https://holyswift.app/introduction-to-app-modularisation-with-swift-package-manager-a-tale-to-be-told)
  3. [ How to Control the World ](https://www.pointfree.co/blog/posts/21-how-to-control-the-world)



# Introducing Container views in SwiftUI

##  Introducing Container views in SwiftUI

31 Jul 2019

During app development using SwiftUI, you can see that your views are very
coupled with the data flow. Views fetch and render the data, handle user input
and actions, etc. By doing so many things views become very fat and we can’t
reuse them across the app. Let’s take a look at a different way of decomposing
views by using _Container Views_ .

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In my first post about SwiftUI, we build a Github app.

    
    
    import SwiftUI
    import Combine
    
    struct FavoritesView : View {
        @EnvironmentObject var store: ReposStore
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(store.repos) { repo in
                        HStack(alignment: .top) {
                            VStack(alignment: .leading) {
                                Text(repo.name)
                                    .font(.headline)
                                Text(repo.description ?? "")
                                    .font(.subheadline)
                            }
                        }
                    }
                }
                .navigationBarTitle(Text("Favorites"))
                .onAppear(perform: fetch)
            }
        }
    
        private func fetch() {
            store.fetchFavorites()
        }
    }
    

Here we have a simple view which fetches and renders my starred repositories.
It looks very straightforward, but there is a massive problem. _FavoritesView_
mixes data fetching plus rendering, and because of that, we can’t reuse this
view. For example, I want to use it to render a user’s repositories or repos
search result. To make it possible, let’s start our refactoring process.

####  Composition

As you can see, SwiftUI uses mainly value types instead of classes and built
on top _Composition over Inheritance_ principle. Let’s follow this way by
decomposing our _FavoritesView_ into a few small composable views.

    
    
    import SwiftUI
    
    struct ReposView : View {
        let repos: [Repo]
    
        var body: some View {
            List {
                ForEach(repos) { repo in
                    HStack(alignment: .top) {
                        VStack(alignment: .leading) {
                            Text(repo.name)
                                .font(.headline)
                            Text(repo.description ?? "")
                                .font(.subheadline)
                        }
                    }
                }
            }
        }
    }
    

Now we have a simple _ReposView_ , which accepts an array of repos and render
them. That’s it. We can use it anywhere across the app where we need to
display a repos list.

####  Introducing Container views

But now we have another question, where we can do data-flow stuff like data
fetching and user actions handling. Let’s introduce _Container View_ concept.
_Container View_ fetches data and passes it to a _Rendering View_ or another
_Container View_ . _Container View_ doesn’t present any User Interface itself.
It is just managing data-flow and passes the data to the _Rendering View_ .

    
    
    import SwiftUI
    
    struct FavoritesContainerView: View {
        @EnvironmentObject var store: ReposStore
    
        var body: some View {
            ReposView(repos: store.repos)
                .onAppear(perform: fetch)
        }
    
        private func fetch() {
            store.fetchFavorites()
        }
    }
    

In the example above, we have a _FavoritesContainerView_ which handles the
data fetching and passes repos array to _ReposView_ . By doing this, we have a
clear separation between our data-flow and data rendering. Let’s take a look
at a more complicated example.

    
    
    import SwiftUI
    
    struct SearchContainerView: View {
        @EnvironmentObject var store: ReposStore
        @State private var query: String = "Swift"
    
        var body: some View {
            SearchView(query: $query, repos: store.repos, onCommit: fetch)
                .onAppear(perform: fetch)
        }
    
        private func fetch() {
            store.fetch(matching: query)
        }
    }
    
    struct SearchView : View {
        @Binding var query: String
        
        let repos: [Repo]
        let onCommit: () -> Void
    
        var body: some View {
            List {
                TextField("Type something", text: $query, onCommit: onCommit)
                ForEach(repos) { repo in
                    HStack(alignment: .top) {
                        VStack(alignment: .leading) {
                            Text(repo.name)
                                .font(.headline)
                            Text(repo.description ?? "")
                                .font(.subheadline)
                        }
                    }
                }
            }
        }
    }
    

Here we have a more complex example, where _Container View_ provides an acton
handling closure and state binding to _Rendering View_ . Let’s summarize our
thoughts about _Container and Rendering views in SwiftUI_ .

**_Container Views_ should do things only related to data-flow: **

  1. Store the state of the _Rendering View_
  2. Fetch data using _ObservableObject_
  3. Handle life cycle ( _onAppear/onDisappear_ ) 
  4. Provide action handlers to the _Rendering View_

**_Rendering Views_ should do things only related to rendering: **

  1. Build User Interface using primitive components provided by SwiftUI. 
  2. Compose User Interface by using other _Rendering Views_ . 
  3. Use data as input to render User Interface and don’t store any state. 

####  Conclusion

Today we discussed a way of decomposing your complex view into small and
reusable pieces. I try to follow this approach as much as possible to make a
clean separation between data-flow and displaying data. Try to use this method
and share with me your thoughts about it. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# SwiftUI learning curve in 2019

##  SwiftUI learning curve in 2019

31 Dec 2019

This year we had a massive change in iOS development world. We got a SwiftUI
framework. SwiftUI is a brand new declarative way of building apps for Apple
ecosystem. Let’s build our learning curve. I want to share with you the list
of all the needed posts to learn SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Apple did an excellent job this year by creating the SwiftUI [ tutorials page
](https://developer.apple.com/tutorials/swiftui/) . I suggest starting with
those tutorials to learn the basics of SwiftUI.

One of the new features of the Swift language powering SwiftUI framework is
property wrappers. To learn about the most important property wrappers like
_@State, @Binding, @ObservedObject, @EnvironmentObject, and @Environment_ read
my [ “Understanding Property Wrappers in SwiftUI” ](/2019/06/12/understanding-
property-wrappers-in-swiftui/) post.

Another post that I wrote about the mechanics of SwiftUI is [ “You have to
change mindset to use SwiftUI” ](/2019/11/19/you-have-to-change-mindset-to-
use-swiftui/) . It should help you to understand how SwiftUI works under the
hood.

####  Layout system

SwiftUI also has a brand new layout system, which I enjoy much more than
AutoLayout. The new layout system is very powerful and straightforward. I
highly suggest you read these posts to understand the new layout system and
its benefits.

  1. [ SwiftUI Layout System ](https://kean.github.io/post/swiftui-layout-system)
  2. [ Alignment guides in SwiftUI ](/2020/03/11/alignment-guides-in-swiftui/)
  3. [ The magic of view preferences in SwiftUI ](/2020/01/15/the-magic-of-view-preferences-in-swiftui/)
  4. [ Anchor preferences in SwiftUI ](/2020/03/18/anchor-preferences-in-swiftui/)
  5. [ Inspecting the View Tree – Part 3: Nested Views ](https://swiftui-lab.com/communicating-with-the-view-tree-part-3/)

####  Architecture

SwiftUI has a lot of similarities with _React_ framework, which brings many
new concepts to iOS development. I’ve built a few apps using those ideas and
really like how it works. Here is the list of useful posts.

  1. [ Introducing Container views in SwiftUI ](/2019/07/31/introducing-container-views-in-swiftui/)
  2. [ Modeling app state using Store objects in SwiftUI ](/2019/09/04/modeling-app-state-using-store-objects-in-swiftui/)
  3. [ Redux-like state container in SwiftUI ](/2019/09/18/redux-like-state-container-in-swiftui/)

####  Declarative nature of SwiftUI

SwiftUI is a declarative framework. It means you declare what you want to
achieve, and the framework takes care of that and decides how to render your
views. The very same view can have another look, depending on the context. I
wrote a few posts about the declarative approach in SwiftUI.

  1. [ Building forms with SwiftUI ](/2019/06/19/building-forms-with-swiftui/)
  2. [ View composition in SwiftUI ](/2019/10/30/view-composition-in-swiftui/)
  3. [ Reusing SwiftUI views across Apple platforms ](/2019/10/23/reusing-swiftui-views-across-apple-platforms/)
  4. [ ViewModifiers in SwiftUI ](/2019/08/07/viewmodifiers-in-swiftui/)
  5. [ Composable styling in SwiftUI ](/2019/08/28/composable-styling-in-swiftui/)

####  Animations and interactions

SwiftUI handles all the state changes using animations just for free for you.
It allows us to build interactive views in a very straightforward and nice
way. I covered this topic many times on my blog.

  1. [ Animations in SwiftUI ](/2019/06/26/animations-in-swiftui/)
  2. [ Gestures in SwiftUI ](/2019/07/10/gestures-in-swiftui/)
  3. [ Building Bottom sheet in SwiftUI ](/2019/12/11/building-bottom-sheet-in-swiftui/)
  4. [ Building Pager view in SwiftUI ](/2019/12/25/building-pager-view-in-swiftui/)

I also want to mention the excellent series of posts by [ Javier
](https://swiftui-lab.com) about advanced animations in SwiftUI.

  1. [ Advanced SwiftUI Animations – Part 1: Paths ](https://swiftui-lab.com/swiftui-animations-part1/)
  2. [ Advanced SwiftUI Animations – Part 2: GeometryEffect ](https://swiftui-lab.com/swiftui-animations-part2/)
  3. [ Advanced SwiftUI Animations – Part 3: AnimatableModifier ](https://swiftui-lab.com/swiftui-animations-part3/)

####  Accessibility

SwiftUI did another step to make our apps accessible by default. It works very
well out of the box, but it also provides a very nice API to customize the
accessibility tree. To learn more about accessibility in SwiftUI, I suggest
reading these articles:

  1. [ Accessibility in SwiftUI ](/2019/09/10/accessibility-in-swiftui/)
  2. [ Dynamic Type in SwiftUI ](/2019/10/09/dynamic-type-in-swiftui/)
  3. [ Localization in SwiftUI ](/2019/10/16/localization-in-swiftui/)

####  Drawing custom views

SwiftUI provides a lovely _Shape API_ that allows us to build custom views
quickly. I learned it while making charts in one of my apps.

  1. [ Building BarChart with Shape API in SwiftUI ](/2019/08/14/building-barchart-with-shape-api-in-swiftui/)
  2. [ Gradient in SwiftUI ](/2019/11/13/gradient-in-swiftui/)
  3. [ GeometryReader to the Rescue ](https://swiftui-lab.com/geometryreader-to-the-rescue/)

####  Unique features

SwiftUI has unique features like _Environment_ and _Preferences_ , which we
don’t have in _UIKit_ . To learn more about these features, take a look at the
next posts.

  1. [ The power of Environment in SwiftUI ](/2019/08/21/the-power-of-environment-in-swiftui/)
  2. [ The magic of view preferences in SwiftUI ](/2020/01/15/the-magic-of-view-preferences-in-swiftui/)
  3. [ The power of @ViewBuilder in SwiftUI ](/2019/12/18/the-power-of-viewbuilder-in-swiftui/)

####  Conclusion

It was a huge year, and I hope we will get SwiftUI 2.0 with a lot of new
features during WWDC 2020. We have many things to learn until the next release
of SwiftUI. Let’s say thanks to our awesome community which wrote all these
articles. Merry Christmas and Happy New Year!



# Mastering ContentUnavailableView in SwiftUI

##  Mastering ContentUnavailableView in SwiftUI

31 Oct 2023

SwiftUI introduces the new _ContentUnavailableView_ type, allowing us to
display empty, error states or any other state where content is unavailable in
our apps. This week, we will learn how to use the _ContentUnavailableView_ to
guide users through empty states of your app.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start with the very first example showing the basic usage of the
_ContentUnavailableView_ view.

    
    
    struct ContentView: View {
        let store: Store
        
        var body: some View {
            NavigationStack {
                List(store.products, id: \.self) { product in
                    Text(verbatim: product)
                }
                .navigationTitle("Products")
                .overlay {
                    if store.products.isEmpty {
                        ContentUnavailableView(
                            "Connection issue",
                            systemImage: "circle"
                        )
                    }
                }
            }
        }
    }
    

![empty-state](/public/ContentUnavailableView1.png)

As you can see in the example above, we define the _ContentUnavailableView_ as
overlay for the list of products. Whenever the product list is empty we
display the _ContentUnavailableView_ with title and image. Another variant of
the _ContentUnavailableView_ view allows us also define the description text
of the current state.

    
    
    struct ContentView: View {
        let store: Store
        
        var body: some View {
            NavigationStack {
                List(store.products, id: \.self) { product in
                    Text(verbatim: product)
                }
                .navigationTitle("Products")
                .overlay {
                    if store.products.isEmpty {
                        ContentUnavailableView(
                            "Connection issue",
                            systemImage: "wifi.slash",
                            description: Text("Check your internet connection")
                        )
                    }
                }
            }
        }
    }
    

![empty-state](/public/ContentUnavailableView2.png)

The _ContentUnavailableView_ allows us also display action buttons below the
description. That’s why there is another variant of the
_ContentUnavailableView_ initializer allowing us to define every piece of the
view using _ViewBuilder_ closures.

    
    
    struct ContentView: View {
        let store: Store
        
        var body: some View {
            NavigationStack {
                List(store.products, id: \.self) { product in
                    Text(verbatim: product)
                }
                .navigationTitle("Products")
                .overlay {
                    if store.products.isEmpty {
                        ContentUnavailableView {
                            Label("Connection issue", systemImage: "wifi.slash")
                        } description: {
                            Text("Check your internet connection")
                        } actions: {
                            Button("Refresh") {
                                store.fetch()
                            }
                        }
                    }
                }
            }
        }
    }
    

As you can see in the example above, we use a set of closures to define label,
description and actions. This initializer allows us to fully customize the
look and feel of an instance of the _ContentUnavailableView_ type.

![empty-state](/public/ContentUnavailableView3.png)

SwiftUI provides us a ready-to-use predefined instance of the
_ContentUnavailableView_ type that we can use in search screens.

    
    
    struct ContentView: View {
        @Bindable var store: Store
        
        var body: some View {
            NavigationStack {
                List(store.products, id: \.self) { product in
                    Text(verbatim: product)
                }
                .navigationTitle("Products")
                .overlay {
                    if store.products.isEmpty {
                        ContentUnavailableView.search
                    }
                }
                .searchable(text: $store.query)
            }
        }
    }
    

Whenever you have a search screen displaying search results, you can use the
_search_ function of the _ContentUnavailableView_ type. It is localized by the
framework and traverse the view hierarchy to find a search bar and extract its
text to display inside the view.

![empty-state](/public/ContentUnavailableView4.png)

Remember that you should place the _searchable_ view modifier below the
overlay if you want to extract the text from the search bar otherwise it
doesn’t personalize the message.

    
    
    struct ContentView: View {
        @Bindable var store: Store
        
        var body: some View {
            NavigationStack {
                List(store.products, id: \.self) { product in
                    Text(verbatim: product)
                }
                .navigationTitle("Products")
                .overlay {
                    if store.products.isEmpty {
                        ContentUnavailableView.search(text: store.query)
                    }
                }
                .searchable(text: $store.query)
            }
        }
    }
    

You can also provide query into the description manually by using the _search_
function of the _ContentUnavailableView_ type with a single parameter.

Today, we learned how to use the _ContentUnavailableView_ type in SwiftUI to
display empty states in a user-friendly manner. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# UI Testing in Swift with XCTest framework

##  UI Testing in Swift with XCTest framework

18 Mar 2021

I’m not going to talk about the importance of testing in general, but I want
to talk about UI testing. One obvious benefit of UI testing over Unit Testing
is the opportunity to write UI tests even when you have a smelling and deeply
coupled codebase. This week we will learn how to write UI tests both for
SwiftUI and UIKit-based projects.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

UI test is a programmatic way to verify that the particular user flow works
correctly in your app. For example, you can write a UI test to mimic user
behavior while adding a product to the shopping cart and checkout.

Xcode provides us XCTest framework that we use to write both unit and UI
tests. XCTest utilize Accessibility APIs to access controls in your view
hierarchy and interact with them. As you might know, UIKit and SwiftUI provide
accessibility support out of the box. That’s why you can easily use the XCTest
framework to write UI tests for your apps written in UIKit or SwiftUI.

> To learn more about accessibility support in UIKit, take a look at my [
> “Make your app accessible for everyone” ](/2018/07/09/make-your-app-
> accessible-for-everyone/) post.

Let’s start writing our first UI test for a simple view that displays a
message.

    
    
    struct ContentView: View {
        var body: some View {
            Text("Hello World!")
        }
    }
    

To create a new UI testing target, go to the Xcode menu _File - > New ->
Target -> UI Testing bundle _ . Now we can write our first UI test.

    
    
    import XCTest
    
    final class UITests: XCTestCase {
        var app: XCUIApplication!
    
        override func setUp() {
            continueAfterFailure = false
            app = XCUIApplication()
            app.launchArguments = ["testing"]
            app.launch()
        }
        
        func testWelcomeMessage() {
            XCTAssertTrue(app.staticTexts["Hello World!"].exists)
        }
    }
    

To write a UI test, we have to create a Swift class that extends _XCTestCase_
. Xcode runs every method that starts with the word **test** as a separate
test. As you can see in the example above, we override the _setUp_ method.
Xcode runs this method before every test in the test case. It is an excellent
place for an initial setup for every test.

Here we run the app from scratch before every UI test to keep them consistent
over multiple runs. XCTest provides us the _XCUIApplication_ class as a proxy
for the application specified by the “Target Application” target setting. We
can access and interact with our app via the instance of the _XCUIApplication_
class.

In our simple test, we verify that our app displays a static text with a
particular message.

####  Queries

_XCUIApplication_ provides a lot of properties to query view hierarchy. You
can access buttons, labels, tables, sliders, switches, and other views living
in your view hierarchy. The main requirement to access a view is enabled
accessibility. By default, accessibility support is enabled for any view.

    
    
    let email = app.textFields["email"]
    let pwd = app.secureTextFields["password"]
    let message = app.staticTexts["Hello World!"]
    let loginButton = app.buttons["login"]
    

As you can see, we can access all the needed views by using subscript syntax.
We pass a string to find a control in the view hierarchy. Xcode tries to find
the view matching accessibility label or accessibility identifier.

> To learn more about accessibility support in SwiftUI, take a look at my [
> “Accessibility in SwiftUI” ](/2019/09/10/accessibility-in-swiftui/) post.

Labels, buttons, and switches use titles as accessibility labels out of the
box. But you still need to set accessibility identifiers for views like
_UITableView_ and _UICollectionView_ manually.

    
    
    // UIKit
    let tableView = UITableView()
    tableView.accessibilityIdentifier = "newsList"
    
    // SwiftUI
    List {
        Text("news item")
    }.accessibilityIdentifier("newsList")
    

To learn more about query properties of _XCUIApplication_ , take a look at the
documentation for the _XCUIElementTypeQueryProvider_ protocol.

####  Actions

XCTest framework provides us a lot of functions for interacting with views.
You can easily tap, double-tap, swipe, pinch and rotate views.

    
    
    app.switches["rememberMe"].tap()
    app.buttons["login"].doubleTap()
    app.buttons["logout"].twoFingerTap()
    

To learn more about the actions that XCTest provides us, take a look at the
documentation for the _XCUIElement_ class.

####  Advanced example

Now we can interact with our app using the XCTest framework. Let’s write a
more interesting test that verifies login flow. Assume that you have a login
view written in SwiftUI. It might look like this:

    
    
    struct LoginView: View {
        @ObservedObject var viewModel: ViewModel
    
        var body: some View {
            Form {
                Section {
                    TextField("email", text: $viewModel.email)
                        .textContentType(.emailAddress)
                        .accessibilityLabel("email")
                    SecureField("password", text: $viewModel.password)
                        .textContentType(.password)
                        .accessibilityLabel("password")
                    Toggle("rememberMe", isOn: $viewModel.rememberMe)
                        .accessibilityIdentifier("rememberMe")
                }
    
                Button("login", action: viewModel.login)
            }
        }
    }
    
    struct ContentView: View {
        @StateObject var viewModel = ViewModel()
    
        var body: some View {
            if viewModel.isAuthorized {
                Text("Hello World!")
            } else {
                LoginView(viewModel: viewModel)
            }
        }
    }
    

Here we have the _ContentView_ that presents _LoginView_ and replace it with
the message as soon as the user logged in.

    
    
    import XCTest
    
    final class UITests: XCTestCase {
        var app: XCUIApplication!
    
        override func setUp() {
            continueAfterFailure = false
            app = XCUIApplication()
            app.launchArguments = ["testing"]
            app.launch()
        }
    
        func testLoginFlow() {
            let email = app.textFields["email"]
            email.tap()
            email.typeText("cmecid@gmail.com")
    
            let pwd = app.secureTextFields["password"]
            pwd.tap()
            pwd.typeText("pwd")
    
            app.switches["rememberMe"].tap()
            app.buttons["login"].doubleTap()
            app.buttons["login"].twoFingerTap()
    
            let message = app.staticTexts["Hello World!"]
            XCTAssertTrue(message.waitForExistence(timeout: 5))
        }
    }
    

In the example above, we have the test that verifies the login flow. Please
note that we use the _waitForExistence_ function here. It waits for a
particular timeout and returns **false** if the element doesn’t appear. On the
other hand, it returns **true** as soon as the element appears on the screen.

####  Performance

UI tests run slower than unit tests because they needs to run the whole app.
That’s why we usually try to write as many unit tests as we can and cover the
essential user flows with UI tests. But still, there is a way to improve
performance by disabling animations while running UI tests.

    
    
    final class AppDelegate: NSObject, UIApplicationDelegate {
        func applicationDidFinishLaunching(_ application: UIApplication) {
            if CommandLine.arguments.contains("testing") {
                // clear your app state before running UI tests here.
                UIView.setAnimationsEnabled(false)
            }
        }
    }
    

Here we check if the app runs under the UI test using command-line arguments.
In the previous examples, we set the launch arguments while running UI tests,
and this is how we can check arguments and prepare our app for UI tests. For
instance, we can reset the app state by removing user defaults, keychain data,
and cleaning the local database.

####  Conclusion

UI tests is an excellent way to verify the most crucial user flows in your
app. XCTest framework provides a very nice and simple API that we can utilize
to write complex tests straightforwardly. You can write your first UI test
without any refactoring just by interacting with your app user interface.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Mastering NavigationStack in SwiftUI. Navigator Pattern.

##  Mastering NavigationStack in SwiftUI. Navigator Pattern.

15 Jun 2022

SwiftUI is the declarative data-driven framework allowing us to build complex
user interfaces by defining the data rendering on the screen. Navigation was
the main pain point of the framework from the very first day. Fortunately,
things have changed since WWDC 22, and SwiftUI provides the new data-driven
Navigation API. This week we will learn how to use the new Navigation API to
build complex user flows.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

First, I must mention that the old _NavigationView_ is deprecated, and we
should use the new _NavigationStack_ instead. Let’s take a look at a quick
example.

    
    
    struct MasterView: View {
        let products: [Product]
        
        var body: some View {
            NavigationStack {
                List(products) { product in
                    NavigationLink(product.title) {
                        ProductDetailView(product: product)
                    }
                }
                .navigationTitle("Products")
            }
        }
    }
    
    struct ProductDetailView: View {
        let product: Product
        
        var body: some View {
            Text(product.title)
                .font(.title)
                .navigationTitle(product.title)
        }
    }
    

In the example above, we define a simple master-detail flow. We place
_NavigationStack_ at the root of our view hierarchy. Next, we define a list of
messages where every message provides a link to the details screen of the
particular message. As you can see, we still use the old _NavigationLink_ type
here, and it works great for this use case.

> To learn more about other new features of SwiftUI, take a look at my [ “What
> is new in SwiftUI after WWDC22” ](/2022/06/07/what-is-new-in-swiftui-after-
> wwdc22/) post.

The _NavigationLink_ type adds new data-driven capabilities. A brand new
initializer allows us to create a link bound to some value. Here is the
previous example refactored using the new data-driven Navigation API.

    
    
    struct MasterView1: View {
        let products: [Product]
        
        var body: some View {
            NavigationStack {
                List(products) { product in
                    NavigationLink(product.title, value: product)
                }
                .navigationTitle("Products")
                .navigationDestination(for: Product.self) { product in
                    ProductDetailView(product: product)
                }
            }
        }
    }
    

We use the new value-based navigation links to route the user through the app.
Look at how we associate every item on the list with a particular value. Keep
in mind, **value** must conform to the **Hashable** protocol. Next, we define
a destination view for a specific value using the _navigationDestination_ view
modifier. In the current example, we have only one type of destination, but
you can have as many as you need by applying multiple _navigationDestination_
view modifiers.

    
    
    struct MasterView2: View {
        let categories: [Category]
        let recentProducts: [Product]
        
        var body: some View {
            NavigationStack {
                List {
                    Section("Categories") {
                        ForEach(categories) { category in
                            NavigationLink(value: category) {
                                Text(category.query)
                                    .font(.headline)
                            }
                        }
                    }
                    
                    Section("Recent") {
                        ForEach(recentProducts) { product in
                            NavigationLink(product.title, value: product)
                        }
                    }
                }
                .navigationTitle("Home")
                .navigationDestination(for: Category.self) { category in
                    CategoryView(category: category)
                }
                .navigationDestination(for: Product.self) { product in
                    ProductDetailView(product: product)
                }
            }
        }
    }
    

Remember that we also have another version of the value-based _NavigationLink_
initializer, allowing us to provide a custom label for the link. We use this
version of the initializer to give the headline font for category links.

####  Placing rules

You should be careful about placing the _navigationDestination_ view modifier
in the view hierarchy. There are three rules for placing the
_navigationDestination_ view modifier:

  1. The _navigationDestination_ view modifier should be inside the _NavigationStack_ . 
  2. Don’t place _navigationDestination_ view modifier on the child of lazy container like _List_ , _ScrollView_ , _LazyVStack_ , etc. 
  3. The top-level _navigationDestination_ view modifier will always override the lowest one for the same type. 

####  Navigator pattern

I love to keep my feature’s navigation flow in a single place. That’s why I
usually implement the Navigator pattern allowing me to handle my navigation in
a type-safe way. It is effortless to implement the Navigator pattern with the
new data-driven Navigation API in SwiftUI. First, we should create an enum
type defining all our app/feature/module routes.

    
    
    enum Route: Hashable {
        case product(Product)
        case category(Category)
    }
    

Next, we should use Route enum with the new value-based navigation links.

    
    
    struct MasterView3: View {
        let categories: [Category]
        let recentProducts: [Product]
        
        var body: some View {
            List {
                Section("Categories") {
                    ForEach(categories) { category in
                        NavigationLink(value: Route.category(category)) {
                            Text(category.query)
                        }
                    }
                }
                
                Section("Recent") {
                    ForEach(recentProducts) { product in
                        NavigationLink(value: Route.product(product)) {
                            Text(product.title)
                        }
                    }
                }
            }
            .navigationTitle("Home")
        }
    }
    

Finally, we can place the single _navigationDestination_ view modifier and
handle all the cases of our _Route_ type.

    
    
    struct AppContainerView: View {
        @StateObject private var store = Store()
        
        var body: some View {
            NavigationStack {
                MasterView3(
                    categories: store.categories,
                    recentProducts: store.products
                )
                .navigationDestination(for: Route.self) { route in
                    switch route {
                    case let .category(category):
                        CategoryView(category: category)
                    case let .product(product):
                        ProductDetailView(product: product)
                    }
                }
            }
        }
    }
    

####  Conclusion

I’m thrilled to use the new data-driven Navigation API in SwiftUI. If you
follow my blog, you might know that I have been waiting for it since the first
day. I will continue to cover the new data-driven Navigation API in detail,
and next week we will talk about deep linking. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Sidebar navigation in SwiftUI

##  Sidebar navigation in SwiftUI

21 Jul 2020

We already covered master-detail navigation in SwiftUI on my blog. But today,
I want to talk about the new three-column navigation that landed this year
into iOS and macOS worlds. We will learn how to build a sidebar navigation
flow by using _NavigationView_ in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

A sidebar provides app-level navigation and quick access to top-level
collections of content in your app. Selecting an item in the sidebar allows
people to navigate to a specific piece of content. For example, the sidebar in
Mail shows a list of all mailboxes. People can select a mailbox to access its
list of messages, and select a specific message to display in the content
pane.

![sidebar](/public/sidebar.png)

Let’s build a prototype of a mail app that uses three-column navigation.
SwiftUI provides _NavigationView_ that allows us to create a master-detail
flow. You can put up to three children inside a _NavigationView_ . In this
case, SwiftUI will place views side-by-side. But let’s start with declaring
our data model.

    
    
    import SwiftUI
    
    struct Mail: Identifiable, Hashable {
        let id = UUID()
        let date: Date
        let subject: String
        let body: String
        var isFavorited = false
    }
    
    final class MailStore: ObservableObject {
        @Published var allMails: [String: [Mail]] = [
            "Inbox": [ .init(date: Date(), subject: "Subject1", body: "Very long body...") ],
            "Sent": [ .init(date: Date(), subject: "Subject2", body: "Very long body...") ],
        ]
    }
    

> To learn about building navigation using _NavigationView_ and
> _NavigationLink_ , take a look at my [ “Navigation in SwiftUI”
> ](/2019/07/17/navigation-in-swiftui/) post.

In the listing above, we create a simple mail store that we will use as a
datastore for our prototype. Now let’s move forward by implementing the first
column of our navigation flow.

    
    
    struct Sidebar: View {
        @ObservedObject var store: MailStore
        @Binding var selectedFolder: String?
        @Binding var selectedMail: Mail?
    
        var body: some View {
            List {
                ForEach(Array(store.allMails.keys), id: \.self) { folder in
                    NavigationLink(
                        destination: FolderView(
                            title: folder,
                            mails: store.allMails[folder, default: []],
                            selectedMail: $selectedMail
                        ),
                        tag: folder,
                        selection: $selectedFolder
                    ) {
                        Text(folder).font(.headline)
                    }
                }
            }.listStyle(SidebarListStyle())
        }
    }
    

As you can see, we create a view called sidebar. It needs an instance of store
object to access our emails and two bindings that we will use to bind the
current folder and selected email. We also use the new _SidebarListStyle_ to
apply a brand new styling to our list that available on iOS 14 and macOS Big
Sur.

    
    
    struct FolderView: View {
        let title: String
        let mails: [Mail]
        @Binding var selectedMail: Mail?
    
        var body: some View {
            List {
                ForEach(mails) { mail in
                    NavigationLink(
                        destination: MailView(mail: mail),
                        tag: mail,
                        selection: $selectedMail
                    ) {
                        VStack(alignment: .leading) {
                            Text(mail.subject)
                            Text(mail.date, style: .date)
                        }
                    }
                }
            }.navigationTitle(title)
        }
    }
    

Here we have the _FolderView_ struct that we use to display a list of emails
in the folder. _FolderView_ also needs the binding for a selected email.
Whenever the user selects an email in the list, SwiftUI sets the value of the
binding and updates the view hierarchy. Now let’s take a look at _MailView_ .

    
    
    struct MailView: View {
        let mail: Mail
    
        var body: some View {
            VStack(alignment: .leading) {
                Text(mail.subject)
                    .font(.headline)
                Text(mail.date, style: .date)
                Text(mail.body)
            }
        }
    }
    

OK, now we have all the needed pieces to build our three-column navigation
flow. As I mentioned earlier, we will put our column views inside a
_NavigationView_ .

    
    
    @main
    struct TestProjectApp: App {
        @StateObject var store = MailStore()
        @State private var selectedLabel: String? = "Inbox"
        @State private var selectedMail: Mail?
    
        var body: some Scene {
            WindowGroup {
                NavigationView {
                    Sidebar(
                        store: store,
                        selectedFolder: $selectedLabel,
                        selectedMail: $selectedMail
                    )
    
                    Text("Select label...")
                    Text("Select mail...")
                }
            }
        }
    }
    

As you can see, we have _NavigationView_ , which is the root of our app scene.
We also define two state properties which describe selected label and email.
We pass bindings to these state properties down into the view hierarchy, it
allows us to programmatically navigate to the selected folder and mail when
needed. You can remove these bindings if you don’t need programmatic
navigation.

Thanks to SwiftUI’s declarative nature, the code above works great both on
iPhone, where it uses the single column navigation and iPad where is uses
sidebar navigation.

Sidebar navigation plays a huge role in new [ Human Interface Guidelines
](https://developer.apple.com/design/human-interface-
guidelines/ios/bars/sidebars/) . It is effortless to implement in SwiftUI
using _NavigationView_ . I hope you enjoy the post. Feel free to follow me on
[ Twitter ](https://twitter.com/mecid) and ask your questions related to this
article. Thanks for reading, and see you next week!



# Using MapKit with SwiftUI

##  Using MapKit with SwiftUI

29 Jul 2020

This year we saw that Apple started using SwiftUI across macOS and iOS to
build notification center and widgets. Another great addition was a SwiftUI
integration for frameworks that Apple provides us like MapKit and AVKit. This
week we will talk about _Map_ view that SwiftUI provides us as soon as you
import both MapKit and SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

As you might remember, I already covered using _MKMapView_ in SwiftUI by using
the _UIViewRepresentable_ protocol. This protocol easily allows us to wrap
_UIView_ and use it in SwiftUI. You don’t need to do it anymore, starting iOS
14, macOS 11, tvOS 14, and watchOS 7 SwiftUI provides us _Map_ view. Let’s
take a look at how easily we can use it.

> To learn more about using [ UIKit views in SwiftUI ](/2020/01/29/using-
> uikit-views-in-swiftui/) , take a look at my dedicated post.
    
    
    import SwiftUI
    import MapKit
    
    struct MapExample: View {
        @State private var region = MKCoordinateRegion(
            center: CLLocationCoordinate2D(
                latitude: 25.7617,
                longitude: 80.1918
            ),
            span: MKCoordinateSpan(
                latitudeDelta: 10,
                longitudeDelta: 10
            )
        )
    
        var body: some View {
            Map(coordinateRegion: $region)
        }
    }
    

As you can see in the example above, all you need to do is constructing _Map_
view and passing it the binding for an instance of _MKCoordinateRegion_ .
SwiftUI will update the binding as soon as the user changes the visible region
on the map by zoom or pan gestures. You can also update the camera by
assigning a new value to the state property that controls the visible region.

    
    
    import SwiftUI
    import MapKit
    
    struct MapExample: View {
        @State private var region = MKCoordinateRegion(
            center: CLLocationCoordinate2D(
                latitude: 25.7617,
                longitude: 80.1918
            ),
            span: MKCoordinateSpan(
                latitudeDelta: 10,
                longitudeDelta: 10
            )
        )
    
        var body: some View {
            VStack {
                Map(coordinateRegion: $region)
    
                Button("zoom") {
                    withAnimation {
                        region.span = MKCoordinateSpan(
                            latitudeDelta: 100,
                            longitudeDelta: 100
                        )
                    }
                }
            }
        }
    }
    

_Map_ view supports the animation system of SwiftUI, which allows us to change
the visible boundaries of the map with animation. Let’s move further and take
a look at the customization points that map view provides us.

    
    
    import SwiftUI
    import MapKit
    
    struct MapExample: View {
        @State private var userTrackingMode: MapUserTrackingMode = .follow
        @State private var region = MKCoordinateRegion(
            center: CLLocationCoordinate2D(
                latitude: 25.7617,
                longitude: 80.1918
            ),
            span: MKCoordinateSpan(
                latitudeDelta: 10,
                longitudeDelta: 10
            )
        )
    
        var body: some View {
            Map(
                coordinateRegion: $region,
                interactionModes: MapInteractionModes.all,
                showsUserLocation: true,
                userTrackingMode: $userTrackingMode
            )
        }
    }
    

As you can see map view provides us quite a few customization points. Let’s
discuss them one by one.

  1. _coordinateRegion_ represents the currently visible region of the map view. You can easily change it by updating the value of your binding. Remember that it is an animatable parameter of the view. 
  2. _interactionModes_ allows us to set allowed gestures for our map view. For example, it might be only zoom or pan gestures. In our case, we use all the available gestures to interact with the map. 
  3. _showsUserLocation_ is the boolean parameter that allows us to control whenever we want to show the user’s current location on the map or not. Remember that you have to request permission to access the location. 
  4. _userTrackingMode_ is the way to configure map tracking mode. It describes whenever we want to follow the user as soon as location changes. 

####  Annotations

We usually use map screens to display the points of interest in our apps.
SwiftUI allows us to place the annotations on the map by using simple views.
To provide annotation items, we have to use another initializer that accepts
the random access collection of identifiable elements.

    
    
    import SwiftUI
    import MapKit
    
    struct City: Identifiable {
        let id = UUID()
        let coordinate: CLLocationCoordinate2D
    }
    
    struct MapExample: View {
        @State private var cities: [City] = [
            City(coordinate: .init(latitude: 40.7128, longitude: 74.0060)),
            City(coordinate: .init(latitude: 37.7749, longitude: 122.4194)),
            City(coordinate: .init(latitude: 47.6062, longitude: 122.3321))
        ]
    
        @State private var userTrackingMode: MapUserTrackingMode = .follow
        @State private var region = MKCoordinateRegion(
            center: CLLocationCoordinate2D(latitude: 25.7617, longitude: 80.1918),
            span: MKCoordinateSpan(latitudeDelta: 10, longitudeDelta: 10)
        )
    
        var body: some View {
            Map(coordinateRegion: $region, annotationItems: cities) { city in
                MapAnnotation(
                    coordinate: city.coordinate,
                    anchorPoint: CGPoint(x: 0.5, y: 0.5)
                ) {
                    Circle()
                        .stroke(Color.green)
                        .frame(width: 44, height: 44)
                }
            }
        }
    }
    

SwiftUI provides us _MapAnnotation_ struct that we can use to build our
annotation view. It accepts the center coordinate of the annotation, its
anchor point, and the @ _ViewBuilder_ closure to create a custom view.

SwiftUI also provides us two standard views that we can use to display our
points of interest. These are _MapMarker_ and _MapPin_ .

    
    
    var body: some View {
        Map(coordinateRegion: $region, annotationItems: cities) { city in
            MapPin(coordinate: city.coordinate, tint: .green)
        }
    }
    

####  Fit the map with MKMapRect

There is another initializer for the _Map_ view that accepts _MKMapRect_
instead of _MKCoordinateRegion_ to control the visible part of the map.

    
    
    final class PinsViewModel: ObservableObject {
        @Published var mapRect = MKMapRect()
        let cities: [City]
    
        init(cities: [City]) {
            self.cities = cities
        }
    
        func fit() {
            let points = cities.map(\.coordinate).map(MKMapPoint.init)
            mapRect = points.reduce(MKMapRect.null) { rect, point in
                let newRect = MKMapRect(origin: point, size: MKMapSize())
                return rect.union(newRect)
            }
        }
    }
    
    struct PinsView: View {
        @ObservedObject var viewModel: PinsViewModel
    
        var body: some View {
            Map(
                mapRect: $viewModel.mapRect,
                annotationItems: viewModel.cities
            ) { city in
                MapPin(coordinate: city.coordinate, tint: .accentColor)
            }.onAppear(perform: viewModel.fit)
        }
    }
    

In the example above, we use _MKMapRect_ to calculate the rectangle that is
able to show all the pins on the map at once.

####  Conclusion

I am happy to see that Apple provides us more views to use in SwiftUI. I hope
to see 100% coverage of UIKit views in SwiftUI anytime in the future. But
let’s learn the things that we have right now. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this article. Thanks for reading, and see you next week!



# Custom accessibility content in SwiftUI

##  Custom accessibility content in SwiftUI

06 Oct 2021

SwiftUI Release 3 brought a lot of new accessibility APIs, which we can use to
improve user experience drastically in an effortless way. This week I want to
talk about another new API that allows us to provide customized accessibility
content using the new _accessibilityCustomContent_ view modifier in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start with a simple example that defines the _User_ struct and a view
presenting an instance of the _User_ struct.

    
    
    import SwiftUI
    
    struct User: Decodable {
        let name: String
        let email: String
        let address: String
        let age: Int
    }
    
    struct UserView: View {
        let user: User
    
        var body: some View {
            VStack(alignment: .leading) {
                Text(user.name)
                    .font(.headline)
                Text(user.address)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Text(user.email)
                    .foregroundColor(.secondary)
                Text("Age: \(user.age)")
                    .foregroundColor(.secondary)
            }
        }
    }
    

SwiftUI provides us with excellent accessibility support out of the box. You
don’t need to do anything to make your _UserView_ accessible. Every piece of
text inside the _UserView_ is accessible for assistive technologies like
VoiceOver and Switch Control. It might sound good, but it can overwhelm
VoiceOver users with a lot of data. Let’s improve accessibility support a
little bit but adding a few accessibility modifiers to our _UserView_ .

    
    
    struct UserView: View {
        let user: User
    
        var body: some View {
            VStack(alignment: .leading) {
                Text(user.name)
                    .font(.headline)
                Text(user.address)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Text(user.email)
                    .foregroundColor(.secondary)
                Text("Age: \(user.age)")
                    .foregroundColor(.secondary)
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel(user.name)
        }
    }
    

As you can see in the example above, we use accessibility modifiers to ignore
the accessibility content of the children to make the stack itself an
accessibility element. We also add the accessibility label to the stack but
still miss the other parts. We want to make all the data accessible. Usually,
we use different fonts and colors to prioritize text visually, but how can we
achieve the same impact for assistive technologies?

> To learn about the basics of accessibility in SwiftUI, take a look at my [
> “Accessibility in SwiftUI” ](/2019/09/10/accessibility-in-swiftui/) post.

Fortunately, SwiftUI provides a way to generate customized accessibility
content with different importance using the brand new
_accessibilityCustomContent_ view modifier. Let’s take a look at how we can
use it.

    
    
    struct UserView: View {
        let user: User
    
        var body: some View {
            VStack(alignment: .leading) {
                Text(user.name)
                    .font(.headline)
                Text(user.address)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Text(user.email)
                    .foregroundColor(.secondary)
                Text("Age: \(user.age)")
                    .foregroundColor(.secondary)
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel(user.name)
            .accessibilityCustomContent("Age", "\(user.age)")
            .accessibilityCustomContent("Email", user.email, importance: .high)
            .accessibilityCustomContent("Address", user.address, importance: .default)
        }
    }
    

Here we add a bunch of _accessibilityCustomContent_ view modifiers to define
custom accessibility content with various priorities. The
_accessibilityCustomContent_ view modifier has three parameters:

  1. The first one is the localized label for your custom content that VoiceOver uses to announce. 
  2. The second one is the localized label or string value presenting custom content. 
  3. The third one is the importance level of your custom content. It can be _default_ or _high_ . VoiceOver reads content with high importance immediately, while the content with default importance is spoken only in verbose mode when the user uses vertical swipes to access more data. 

The _accessibilityCustomContent_ view modifier allows us to prioritize data
for assistive technologies. For example, VoiceOver reads the data with _high_
importance immediately and enables the user to access data with _default_
importance as needed using vertical swipes.

You can use as many _accessibilityCustomContent_ view modifiers as needed to
present a massive subset of your data. Remember that you can also replace and
override data or importance by introducing _accessibilityCustomContent_ view
modifiers with the same label.

An excellent way to keep your custom accessibility content labels consistent
across the large codebase is using the _AccessibilityCustomContentKey_ type.
You can use an instance of it as the first parameter of the
_accessibilityCustomContent_ view modifier.

    
    
    extension AccessibilityCustomContentKey {
        static let age = AccessibilityCustomContentKey("Age")
        static let email = AccessibilityCustomContentKey("Email")
        static let address = AccessibilityCustomContentKey("Address")
    }
    
    struct UserView: View {
        let user: User
    
        var body: some View {
            VStack(alignment: .leading) {
                Text(user.name)
                    .font(.headline)
                Text(user.address)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Text(user.email)
                    .foregroundColor(.secondary)
                Text("Age: \(user.age)")
                    .foregroundColor(.secondary)
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel(user.name)
            .accessibilityCustomContent(.age, "\(user.age)")
            .accessibilityCustomContent(.email, user.email, importance: .high)
            .accessibilityCustomContent(.address, user.address, importance: .default)
        }
    }
    

In the example above, we define a few shortcuts for our custom accessibility
content keys and use them in conjunction with the _accessibilityCustomContent_
view modifier.

Today we learned how to use the _accessibilityCustomContent_ view modifier to
make our apps more accessible by prioritizing our data for assistive
technologies and allowing user access as more details as needed. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Profiling SwiftUI app using Instruments

##  Profiling SwiftUI app using Instruments

20 Jan 2021

Xcode comes with a bunch of tools you need to build, debug and release your
apps. One of these tools is the Instruments app. The Instruments app is a
great tool for profiling your iOS apps. It provides many profiling templates
for debugging Core Data, catching memory leaks, disk read/writes, and much
more. This week we will learn how to profile SwiftUI apps using the SwiftUI
template.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Many developers profile apps only when they have some issues. That’s why
Instruments looks like the hidden gem of Xcode. I suggest you profile your
apps on a weekly or bi-weekly basis. Profiling your app by making incremental
changes is the best way to identify and fix small performance downgrades.

![instruments](/public/profile1.png)

First of all, you need to build the app in profiling mode by selecting
_Product - > Profile _ or pressing _CMD+I_ . Remember that you should profile
your app only on the real device and not the simulator. Then you can select
the SwiftUI template in the newly opened Instruments window and press the
record button.

![instruments](/public/profile2.png)

SwiftUI profiling template is divided into four main sections: View Body, View
Properties, Core Animation Commits, Time Profiler. By understanding the values
in these sections, you can investigate the issues that your app might have.

####  View Body

The first section you see is View Body. As you already know, SwiftUI calls the
body property of your views to understand changes in the view hierarchy and
render them. SwiftUI calls body property whenever view dependencies change.
For example, when you change the value of the state or observed object.

![instruments](/public/profile3.png)

The most interesting value here is the Average Duration. You should keep your
body properties as fast as possible. Don’t create heavy objects inside the
body property. For example, try to avoid creating _DateFormatter_ inside the
body property.

> To learn more about the diffing process that SwiftUI applies, take a look at
> my [ “You have to change mindset to use SwiftUI” ](/2019/11/19/you-have-to-
> change-mindset-to-use-swiftui/) post.

Remember that iOS uses 16ms frames to render your app. On devices with
ProMotion display iOS uses even shorter 8ms frames. SwiftUI runs the body
property whenever you change view dependencies, diff it with the previous
version, and commit the Core Animation transaction. You should keep the whole
process inside the 8ms time frame. In other cases, you will have a glitch.

####  View Properties

In the View Properties section, you can find every changed view property. You
should expect to have view property updates more often than body property
calls because SwiftUI merge multiple property updates to run a single body
update.

Here you can check the values of changed properties and find the properties
which update more often than you need or expect.

![instruments](/public/profile4.png)

####  Time Profiler

In the Time Profiler section, you can find the timing for every function in
your app. You can see the heaviest stack trace on the right, and usually, this
is all you need to solve a performance issue. The filters pane on the bottom
is where you can hide system libraries by pressing the Call Tree button.

![instruments](/public/profile5.png)

> To learn more about other templates available in Instruments app, take a
> look at [ “Instruments Tutorial with Swift: Getting Started”
> ](https://www.raywenderlich.com/16126261-instruments-tutorial-with-swift-
> getting-started) .

####  Conclusion

Today we have learned how to use Instruments app and its SwiftUI template to
profile our apps. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
article. Thanks for reading, and see you next week!



# Building custom layout in SwiftUI. Basics.

##  Building custom layout in SwiftUI. Basics.

16 Nov 2022

Nowadays, SwiftUI provides the _Layout_ protocol allowing us to build super-
custom layouts by digging into the layout system without using
_GeometryReader_ . _Layout_ protocol brings us the incredible power of
building and reusing any layout you can imagine. This week we will learn how
to use the new _Layout_ protocol to build a flow layout in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Any layout you want to build must conform to the new _Layout_ protocol. It has
two required functions to implement.

    
    
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public protocol Layout : Animatable {
        func sizeThatFits(
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Self.Cache
        ) -> CGSize
        
        func placeSubviews(
            in bounds: CGRect,
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Self.Cache
        ) 
    }
    

  1. _sizeThatFits_ function must calculate and return the final size of your layout. 
  2. _placeSubviews_ function should place the subviews according to your layout rules. 

Today we will start learning the _Layout_ protocol by implementing flow layout
in SwiftUI. Flow layout usually behaves like _HStack_ , but it drops the line
as soon as the views fill the horizontally available space.

Let’s start with calculating the final size of our flow layout. It should
iterate over all the subviews and sum the width of the views until we have
space horizontally available. As soon as we reach the end of the available
space, we should drop the placement line below and continue to place views
from the leading edge.

    
    
    struct FlowLayout: Layout {
        func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
            let sizes = subviews.map { $0.sizeThatFits(.unspecified) }
            
            var totalHeight: CGFloat = 0
            var totalWidth: CGFloat = 0
            
            var lineWidth: CGFloat = 0
            var lineHeight: CGFloat = 0
            
              for size in sizes {
                if lineWidth + size.width > proposal.width ?? 0 {
                    totalHeight += lineHeight
                    lineWidth = size.width
                    lineHeight = size.height
                } else {
                    lineWidth += size.width
                    lineHeight = max(lineHeight, size.height)
                }
    
                totalWidth = max(totalWidth, lineWidth)
            }
    
            totalHeight += lineHeight
            
            return .init(width: totalWidth, height: totalHeight)
        }
    }
    

In the example above, we have the implementation of the _sizeThatFits_
function. This function provides a few interesting parameters that we will use
to calculate the final size of our layout. The first one is the
_ProposedViewSize_ providing us with the size the parent proposes. The second
one is the instance of type _Subviews_ which is a proxy instance for the
collection of subviews allowing us to place and measure the size of the views.

We use the instance of the _Subviews_ proxy to iterate over all the children
and calculate their ideal sizes using the _sizeThatFits_ function. It accepts
a parameter allowing us to get its minimal, maximal, and ideal dimensions. In
the example above, we use an _unspecified_ parameter which means ideal size.
But you can also use _zero_ and _infinity_ instances to get their minimal and
maximal size accordingly.

After calculating the ideal sizes for all the views, we go over them to
calculate the total width and height of the final layout. We use the
_ProposedViewSize_ parameter to understand the width that the parent view
provides us to know when we need to drop the line of the flow layout.

Finally, we construct and return the final size of the flow layout using all
the knowledge that SwiftUI’s layout system provides us. Now we can move to the
implementation details of the _placeSubviews_ function.

    
    
    struct FlowLayout: Layout {
        func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
            let sizes = subviews.map { $0.sizeThatFits(.unspecified) }
            
            var lineX = bounds.minX
            var lineY = bounds.minY
            var lineHeight: CGFloat = 0
            
            for index in subviews.indices {
                if lineX + sizes[index].width > (proposal.width ?? 0) {
                    lineY += lineHeight
                    lineHeight = 0
                    lineX = bounds.minX
                }
                
                subviews[index].place(
                    at: .init(
                        x: lineX + sizes[index].width / 2,
                        y: lineY + sizes[index].height / 2
                    ),
                    anchor: .center,
                    proposal: ProposedViewSize(sizes[index])
                )
                
                lineHeight = max(lineHeight, sizes[index].height)
                lineX += sizes[index].width
            }
        }
    }
    

As you can see in the example above, the _placeSubviews_ function has the same
set of parameters we had in the _sizeThatFits_ but also provides us with the
bounds rectangle. The bounds rectangle is the place in the view hierarchy we
will fill with our subviews. Please don’t assume that it has zero origin
because it can be placed anywhere on the screen, and you should use the _minX,
minY, maxX, maxY, midX, midY_ properties to put your views ideally.

_Subviews_ type allows us to access the view proxy by index and use its
_place_ function to put the view into a specific position. It also allows us
to move the view’s anchor point according to the position we pass.

    
    
    struct ContentView: View {
        var body: some View {
            FlowLayout {
                ForEach(0..<5) { _ in
                    Group {
                        Text("Hello")
                            .font(.largeTitle)
                        Text("World")
                            .font(.title)
                        Text("!!!")
                            .font(.title3)
                    }
                    .border(Color.red)
                }
            }
        }
    }
    

![flow-layout](/public/flowlayout.png)

Today we learned the _Layout_ protocol’s basics and built an elementary
version of the flow layout. We will continue digging into the _Layout_
protocol in the following posts to create more flexible configurations. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Animations in SwiftUI

##  Animations in SwiftUI

26 Jun 2019

SwiftUI brings declarative and straightforward approach in building User
Interfaces. We have _List_ and _Form_ components and _Bindings_ . All of these
things make SwiftUI so easy to use and very powerful. But today we are going
to talk about another feature of SwiftUI, and it is animations.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Animation

You can smoothly animate any change in SwiftUI by wrapping it into
_withAnimation_ block. By default, SwiftUI uses fade in and fade out for
animating changes. Let’s take a look at a small example.

    
    
    struct ContentView : View {
        @State private var isButtonVisible = true
    
        var body: some View {
            VStack {
                Button(action: {
                    withAnimation {
                        self.isButtonVisible.toggle()
                    }
                }) {
                    Text("Press me")
                }
    
                if isButtonVisible {
                    Button(action: {}) {
                        Text("Hidden Button")
                    }
                }
            }
        }
    }
    

In the current example, we wrap the _State_ change with _withAnimation_ block,
and it produces nice fade in animation. You can modify animation by passing
timing and spring values. Another option can be attaching animation modifier
to the animating view.

    
    
    struct ContentView : View {
        @State private var isButtonVisible = true
    
        var body: some View {
            VStack {
                Button(action: {
                    self.isButtonVisible.toggle()
                }) {
                    Text("Press me")
                }
    
                if isButtonVisible {
                    Button(action: {}) {
                        Text("Hidden Button")
                    }.animation(.easeInOut, value: isButtonVisible)
                }
            }
        }
    }
    

In the code sample above, we achieve the same animation by simply adding
animation modifier. We use _easeInOut_ animation, but you can pass custom
animation properties. The second parameter is the equatable value that SwiftUI
observes to understand changes and animate them.

Sometimes we have a situation where multiple views depend on some state, and
we want to animate all depending view changes together. For this case, we have
animatable bindings.

    
    
    struct ContentView : View {
        @State private var isButtonVisible = true
    
        var body: some View {
            VStack {
                Toggle(isOn: $isButtonVisible.animation()) {
                    Text("Show/Hide button")
                }
    
                if isButtonVisible {
                    Button(action: {}) {
                        Text("Hidden Button")
                    }
                }
            }
        }
    }
    

As you can see, we can easily convert our binding into animatable binding by
calling animation method on it. This method wraps every change of binding
value into an animation block. You can pass animation settings as parameters
to this method. More about bindings you can read in my [ previous post
](/2019/06/12/understanding-property-wrappers-in-swiftui) .

####  Transitions

As I said before, SwiftUI uses fade in and fade out transition by default, but
we can apply any other transition we want. Let’s replace fading with moving.

    
    
    struct ContentView : View {
        @State private var isButtonVisible = true
    
        var body: some View {
            VStack {
                Toggle(isOn: $isButtonVisible.animation()) {
                    Text("Show/Hide button")
                }
    
                if isButtonVisible {
                    Button(action: {}) {
                        Text("Hidden Button")
                    }.transition(.move(edge: .trailing))
                }
            }
        }
    }
    

In the example above, we attach transition modifier to the view. SwiftUI has a
bunch of ready to use transitions like _move_ , _slide_ , _scale_ , _offset_ ,
_opacity_ , etc. We can combine them into a single transition. Let’s take a
look at the example.

    
    
    extension AnyTransition {
        static func moveAndScale(edge: Edge) -> AnyTransition {
            AnyTransition.move(edge: edge).combined(with: .scale())
        }
    }
    
    struct ContentView : View {
        @State private var isButtonVisible = true
    
        var body: some View {
            VStack {
                Toggle(isOn: $isButtonVisible.animation()) {
                    Text("Show/Hide button")
                }
    
                if isButtonVisible {
                    Button(action: {}) {
                        Text("Hidden Button")
                    }.transition(.moveAndScale(edge: .trailing))
                }
            }
        }
    }
    

We created a _moveAndScale_ transition, which is basically a combination of
move and scale transitions. SwiftUI applies the current transition
symmetrically according to timing or spring values which you pass into the
animation method.

SwiftUI provides a way of building asymmetric transitions also. Assume that
you need a move transition on insertion and a fade transition on removal. For
those cases, we have an _asymmetric_ method on _AnyTransition_ struct, which
we can use to build asymmetric transitions.

    
    
    extension AnyTransition {
        static func moveOrFade(edge: Edge) -> AnyTransition {
            AnyTransition.asymmetric(
                insertion: .move(edge: edge),
                removal: .opacity
            )
        }
    }
    
    struct ContentView : View {
        @State private var isButtonVisible = true
    
        var body: some View {
            VStack {
                Toggle(isOn: $isButtonVisible.animation()) {
                    Text("Show/Hide button")
                }
    
                if isButtonVisible {
                    Button(action: {}) {
                        Text("Hidden Button")
                    }.transition(.moveOrFade(edge: .trailing))
                }
            }
        }
    }
    

As you can see, we use _asymmetric_ method to pass two transitions, the first
one for insertion and another one for removal. We can pass here combined
transition which we created.

####  Conclusion

Today we discussed multiple ways of animating changes in SwiftUI. It totally
depends on you and on use-case which way you have to choose. By spending more
and more time with SwiftUI, I understand that it is already a compelling
framework. Feel free to follow me on [ Twitter ](https://twitter.com/mecid)
and ask your questions related to this post. Thanks for reading and see you
next week!



# Lazy navigation in SwiftUI

##  Lazy navigation in SwiftUI

27 Jan 2021

Most of our apps are more than just a single screen app. We use the navigation
to connect different screens inside the app. SwiftUI provides us
_NavigationLink_ struct that we can use to link views. This week we will learn
how to use _NavigationLink_ more efficiently than before by making it lazy.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Usually, we have to set up navigation links by providing both source and
destination views. In some cases, it might be a bottleneck for your view. I
have a calendar screen in my app that displays the summary for every day
during the last two years. Every date in the calendar is clickable and linked
to the details screen using _NavigationLink_ .

> To learn more about the basics of _NavigationLink_ , take a look at my [
> “Navigation in SwiftUI” ](/2019/07/17/navigation-in-swiftui/) post.

OK, my calendar screen shows the information for every date during the last
two years. It means I have to construct 730 _NavigationLinks_ plus destination
views for every date. This makes 1460 views. Assume that the state in this
view changes and SwiftUI has to recalculate all these views. It is a lot of
work to do.

![calendar](/public/lazy.PNG)

In this case, I don’t want to create navigation links when the calendar view
is loaded. I would like to have only one _NavigationLink_ , which activates as
soon as the user selects the calendar date. Let’s take a look at the API that
I want to achieve.

    
    
    import SwiftUI
    
    struct CalendarContainerView: View {
        let interval: DateInterval
    
        @State private var selectedDate: Date?
    
        var body: some View {
            ScrollView(.vertical, showsIndicators: false) {
                CalendarView(interval: interval, onHeaderAppear: fetch) { date in
                    DateView(date: date) {
                        // Some content here
                    }
                }
            }
            .navigationBarTitle("calendar", displayMode: .inline)
            .navigate(using: $selectedDate, destination: makeDestination)
        }
    }
    

As you can see in the example above, we have the _navigate_ view modifier that
accepts binding and the closure to build the destination view. First, we need
to bind over the optional value to activate _NavigationLink_ only when a value
is available. Next, we should define a closure accepting a value and annotate
it with _@ViewBuilder_ . Let’s start by creating a _NavigationLink_ extension
to add a new initializer that supports our flow.

    
    
    import SwiftUI
    
    extension NavigationLink where Label == EmptyView {
        init?<Value>(
            _ binding: Binding<Value?>,
            @ViewBuilder destination: (Value) -> Destination
        ) {
            guard let value = binding.wrappedValue else {
                return nil
            }
    
            let isActive = Binding(
                get: { true },
                set: { newValue in if !newValue { binding.wrappedValue = nil } }
            )
    
            self.init(destination: destination(value), isActive: isActive, label: EmptyView.init)
        }
    }
    

> To learn more about benefits of _@ViewBuilder_ , take a look at [ “The power
> of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-viewbuilder-in-
> swiftui/) post.

We create the failable initializer for _NavigationLink_ , where Label is
_EmptyView_ . It means we will hide _NavigationLink_ from the screen, but it
still will be there, and we can activate it as soon as our binding provides a
value. Now we can create an extension on the _View_ protocol to use the new
API nicely.

    
    
    extension View {
        @ViewBuilder
        func navigate<Value, Destination: View>(
            using binding: Binding<Value?>,
            @ViewBuilder destination: (Value) -> Destination
        ) -> some View {
            background(NavigationLink(binding, destination: destination))
        }
    }
    

Here we define an extension on the _View_ protocol that allows us to bind a
value to the destination view. As you remember, we use _EmptyView_ as
_NavigationLink_ label, and it allows us to set the _NavigationLink_ as the
view background invisibly. Now let’s take a look at how we can use the new API
in our apps.

    
    
    import SwiftUI
    
    struct CalendarContainerView: View {
        let interval: DateInterval
    
        @EnvironmentObject var store: Store<CalendarState, CalendarAction>
        @State private var selectedDate: Date?
    
        var body: some View {
            ScrollView(.vertical, showsIndicators: false) {
                CalendarView(interval: interval, onHeaderAppear: fetch) { date in
                    Button(action: { self.selectedDate = date }) {
                        DateView(date: date) {
                            // Some content here
                        }
                    }
                }
            }
            .navigationBarTitle("calendar", displayMode: .inline)
            .navigate(using: $selectedDate, destination: makeDestination)
        }
    
        @ViewBuilder
        private func makeDestination(for date: Date) -> some View {
            // create and configure destination view here
        }
    }
    

As you can see, it decreases the number of views that SwiftUI should
recalculate on state changes. The second benefit is the lazy nature that
allows us to move decision flow to a later date. So you can dynamically decide
which view should be the destination depending on the value you have in the
binding.

I would like to see the approach we use in this post as a part of SwiftUI next
year. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Building complex screens with Child ViewControllers

##  Building complex screens with Child ViewControllers

27 Feb 2019

Container view controllers are a way to combine the content from multiple
ViewControllers into a single user interface. Child ViewControllers are one of
the undervalued features of iOS SDK. We use it every day by use of
UINavigationController or UITabBarController. Last week we talked about using
ViewController containment feature to create [ FlowControllers
](/2019/02/20/navigation-with-flow-controllers/) . But today we are going to
discuss how to use this feature to build complex screens.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Complex screens

CardioBot is Heart Rate tracker app on which I was working last two years. It
uses HealthKit to read Heart Rate values, make some calculations and present
Heart Rate analysis for every day in a nice way. Here is Day screen of
CardioBot app.

![CardioBot](/public/cardiobot.jpg)

Every day has several sections like Average, Summary, Sleep, Workout, Weekly
sleep, etc. If I build this screen as a single ViewController for sure, it
will be a Massive-View-Controller. Instead, let’s extract every section in
separated ViewController and combine them in parent ViewController by using
ViewController containment. It gives me the opportunity to make my
ViewControllers small and testable. Another achievement here is reusability. I
want to use SummaryViewController as Today extension, so extracting it in
another ViewController is what I need.

####  StackViewController

Let’s create base ViewController for our day screen. First of all, it should
be able to manage the dynamic count of child ViewControllers with the
opportunity to scroll the screen if items too many. The second needed feature
is the ability to hide/show Child ViewControllers with animation. UIStackView
embedded in UIScrollView is the best candidate here. Animating views inside by
switching isHidden property is super easy. Another benefit here is support for
intrinsicContentSize by UIStackView. We need to add proper constraints to
child ViewController’s root view to make it self sizing, and UIStackView will
take care of the right positioning of this view.

    
    
    import UIKit
    
    class StackViewController: UIViewController {
        private let scrollView = UIScrollView()
        private let stackView = UIStackView()
    
        override func viewDidLoad() {
            super.viewDidLoad()
            view.addSubview(scrollView)
            scrollView.addSubview(stackView)
            setupConstraints()
            stackView.axis = .vertical
        }
    
        private func setupConstraints() {
            scrollView.translatesAutoresizingMaskIntoConstraints = false
            stackView.translatesAutoresizingMaskIntoConstraints = false
    
            NSLayoutConstraint.activate([
                scrollView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
                scrollView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
                scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
                scrollView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor),
                stackView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
                stackView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
                stackView.topAnchor.constraint(equalTo: scrollView.topAnchor),
                stackView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
                stackView.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor)
                ])
        }
    }
    
    extension StackViewController {
        func add(_ child: UIViewController) {
            addChild(child)
            stackView.addArrangedSubview(child.view)
            child.didMove(toParent: self)
        }
    
        func remove(_ child: UIViewController) {
            guard child.parent != nil else {
                return
            }
    
            child.willMove(toParent: nil)
            stackView.removeArrangedSubview(child.view)
            child.view.removeFromSuperview()
            child.removeFromParent()
        }
    }
    

In the example above, I create StackViewController which has UIStackView
embedded in UIScrollView. I added all needed constraints to make UIScrollView
working correctly with UIStackView and understand its real content size. We
also have here two public methods which we will use to add or remove child
ViewControllers to UIStackView.

####  Day Screen

Now we can implement our Day Screen which extends from StackViewController and
populates its view with child ViewControllers. Here is a source code.

    
    
    class DayViewController: StackViewController {
        override func viewDidLoad() {
            super.viewDidLoad()
            setupUI()
        }
    
        private func setupUI() {
            let today = Date()
            let calendarVC = CalendarViewController(date: today)
            calendarVC.delegate = self
    
            add(calendarVC)
            add(SummaryViewController(date: today))
            add(SleepViewController(date: today))
            add(WorkoutViewController(date: today))
        }
    }
    
    extension DayViewController: CalendarViewControllDelegate {
        func dateSelected(_ date: Date) {
            reloadDay(with: date)
        }
    }
    

As you can see, DayViewController hosts four child ViewControllers. It also
acts as a delegate for CalendarViewController, which presents the current
week. As soon as any date selected in the calendar, it passes the date via
delegate to parent ViewController, which job is asking child ViewControllers
to reload data.

####  Conclusion

We used to create one ViewController per screen, but sometimes this rule leads
to buggy Massive-View-Controllers. Today we discussed how we could break this
rule and compose complex screens from as many child ViewControllers as we
need.

Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading and see you next week!



# Animating changes in UITableView and UICollectionView

##  Animating changes in UITableView and UICollectionView

13 Mar 2019

Most of our apps present lists or grids of some data by using UITableView or
UICollectionView. Often users can update this list by using Pull-to-Refresh
technique or by pressing the update button. Everybody knows how to update
UITableView by calling the reloadData method on the tableView instance. But
what about animation? ReloadData method is invalidating the current items
provided by data source and draws new ones without any animation. Today we
will talk about animating data changes in UITableView and UICollectionView.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  UICollectionView/UITableView animation API

iOS SDK provides particular methods like insertRows, deleteRows, and moveRow
which give us an opportunity to animate changes in our data source. But only a
few apps use this technique to update UITableView and here are two reasons for
that.

  1. It’s hard to calculate what kind of changes applied to your data after the update. 
  2. There is a particular order on animating changes. You should call deletions first and insertions next, and after that make your movement changes. 

I think it’s a little bit complicated, and that’s why not so many apps use
this API. But we are going to find an easy way of animating changes.

####  Understanding the changes

There are a lot of third-party libraries which provide fast diffing algorithm
implementations. Here is a list of the most famous.

  * [ DeepDiff ](https://github.com/onmyway133/DeepDiff)
  * [ Differ ](https://github.com/tonyarnold/Differ)
  * [ ListDiff ](https://github.com/lxcid/ListDiff)

I prefer the second one. It works super fast with my dataset. As a part of
this post, we will use Differ library, but you can choose any library you want
because usually, it provides a similar API.

    
    
    let old = ["1", "2", "3"]
    let new = ["4", "3", "2"]
    
    let diff = old.diff(new)
    

####  Hashable

First of all, we have to implement Hashable protocol on our model types,
thanks to Swift it is super easy, all you need to do is adding Hashable
protocol to your type declaration and compiler will generate all required
code. Here is a sample from my pet project which is a TV show tracking app.

    
    
    struct Show: Hashable {
        let title: String
        let year: Int
        let ids: Ids
        let overview: String
        let runtime: Int
        let certification: String
        let network: String
        let country: String
        let trailer: String?
        let homepage: String?
        let status: String
        let rating: Double
        let votes: Int
        let commentCount: Int
        let updatedAt: Date
        let language: String
        let availableTranslations: [String]
        let genres: [String]
        let airedEpisodes: Int
    }
    

####  Animation API

Most of the diffing libraries provide UICollectionView and UITableView
extensions, which takes oldData, newData, and animate the changes from one
state to another. All you need to do is put new data to your data source and
instead of calling the reloadData method call animateRowChanges method. This
method will handle all the animations based on your changes.

First of all, let’s use the technique which we discussed before [ to hide our
third-party dependencies with extensions ](/2019/02/13/hiding-third-party-
dependencies-with-protocols-and-extensions) .

    
    
    import UIKit
    import Differ
    
    extension UICollectionView {
        func reloadChanges<T: Collection>(from old: T, to new: T) where T.Element: Equatable {
            animateItemChanges(oldData: old, newData: new)
        }
    }
    
    extension UITableView {
        func reloadChanges<T: Collection>(from old: T, to new: T) where T.Element: Equatable {
            animateRowChanges(oldData: old, newData: new)
        }
    }
    

We create an extension which adds a reloadChanges method to UICollectionView
and UITableView. With the help of this extension, you can easily switch
libraries or your implementation by making changes in a single file.

    
    
    func render(_ newData: [Show]) {
        let oldData = dataSource.posters
        dataSource.posters = newData
        collectionView.reloadChanges(from: oldData, to: newData)
    }
    

![ShowBot-animation](/public/showbot-animation.gif)

####  Conclusion

Today we discussed how it is easy to add delight to our apps by animating
changes. This kind of animations makes apps feel natural and fluid. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading and see you next week!



# The magic of fixed size modifier in SwiftUI

##  The magic of fixed size modifier in SwiftUI

29 Apr 2020

You may have seen some examples of fixed size modifier usage while trying to
fix the issue with multiline text in SwiftUI. But do you know what exactly
fixed size modifier does? How does it work? Today I want to talk about all the
magic and power behind the fixed size modifier.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

SwiftUI documentation says that the fixed size modifier fixes this view at its
ideal size. I think the best way to understand how the fixed size modifier
works is the visual example. Let’s take a look at a small sample.

    
    
    struct Example1: View {
        var body: some View {
            Text("Very very very long text!")
                .font(.title)
                .frame(width: 100, height: 100, alignment: .center)
                .border(Color.red)
        }
    }
    

We try to simulate the rendering of very long text. I also use the _frame_
modifier to limit available space. As you can see in the example above, the
text doesn’t fit the available space, and the SwiftUI layout system decides to
truncate it.

![fixed-size](/public/fixedSize1.png)

> To learn more about the logic behind the layout system of SwiftUI, take a
> look at my [ “Layout priorities in SwiftUI” post ](/2020/04/15/layout-
> priorities-in-swiftui/) .

Now let’s take a look at the same example but with the fixed size modifier
attached to the text component.

    
    
    struct Example1: View {
        var body: some View {
            Text("Very very very long text!")
                .font(.title)
                .fixedSize()
                .frame(width: 100, height: 100, alignment: .center)
                .border(Color.red)
        }
    }
    

As you can see in the code sample above, the fixed size modifier allows to
text to ignore the frame and use as much space as needed to render the
content. The text component simply exceeds the provided frame by continuing
the rendering outside of the frame. You can use the _clipped_ modifier after
the frame modifier to cut the content inside the provided rectangle.

![fixed-size](/public/fixedSize2.png)

> To learn more about clipping and changing the shape of a view, take a look
> at my [ “Customizing the shape of views in SwiftUI” post
> ](/2020/02/12/customizing-the-shape-of-views-in-swiftui/) .

SwiftUI provides us two versions of fixed size modifier. The first one, which
we already used in previous examples, doesn’t have any parameters and allows
the view to grow both vertically and horizontally. The second variant of the
fixed size modifier accepts two boolean parameters. These parameters describe
the axis of expansion.

    
    
    struct Example1: View {
        var body: some View {
            Text("Very very very long text!")
                .font(.title)
                .fixedSize(horizontal: true, vertical: false)
                .frame(width: 100, height: 100, alignment: .center)
                .border(Color.red)
        }
    }
    

Here we use the fixed size modifier to allow the view to expand horizontally.
This level of control lets us use the fixed size modifier as an alternative to
layout priorities in SwiftUI. Let’s take a look at another example.

    
    
    struct Example2: View {
        var body: some View {
            HStack {
                Text("Hello World!")
                    .font(.headline)
                Text("Hello World!")
                    .font(.largeTitle)
                Text("Hello World!")
                    .font(.title)
            }.lineLimit(1)
        }
    }
    

In the example above, we have the horizontal stack that contains three text
labels. The layout system can’t render all of them without truncating because
labels have pretty big font sizes. Assume that we want to display the second
label without truncating and allow to SwiftUI cut other labels. We have at
least two solutions here. The first one is layout priority, and the second one
is the fixed size modifier.

    
    
    struct Example2: View {
        var body: some View {
            HStack {
                Text("Hello World!")
                    .font(.headline)
                Text("Hello World!")
                    .font(.largeTitle)
                    .fixedSize(horizontal: true, vertical: false)
                Text("Hello World!")
                    .font(.title)
            }.lineLimit(1)
        }
    }
    

####  Conclusion

As you can see, the fixed size modifier provides us much more control over the
layout system than layout priorities. Sometimes it can be more beneficial when
you need to control the growth of the view in some specific direction. I hope
you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering ProgressView in SwiftUI

##  Mastering ProgressView in SwiftUI

25 Nov 2021

Many of our apps do heavy work on background threads like networking or data
processing. We usually want to display progress or the activity indicator of
the ongoing work. This week we will learn how to use _ProgressView_ to present
both indeterminate and determinate progress in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  indeterminate progress

All you need to do to display indeterminate progress is to place
_ProgressView_ anywhere in your layout. Let’s try to do that in a simple
example.

    
    
    struct ContentView: View {
        var body: some View {
            ProgressView()
        }
    }
    

![progress](/public/progress2.png)

    
    
    struct ContentView: View {
        var body: some View {
            ProgressView("Loading")
        }
    }
    

![progress](/public/progress.png)

As you can see in the examples above, plain _ProgressView_ displays an
indeterminate circular indicator by default. Usually, it means that there is
ongoing work in the background, and the user should wait to see some results.
We also can provide a localizable string by placing it near to circular
activity indicator.

SwiftUI uses a circular activity indicator by default to display indeterminate
progress, but there is a way to show determinate progress using a linear
progress indicator.

####  Determinate progress

_ProgressView_ provides us with a special initializer that allows us to
display determinate progress. We might use it in the case where we expect the
final result by some time. For example, we usually know the final size of the
file while downloading it. This is the case where we have to show determinate
progress. Let’s see how we can do that.

    
    
    struct ContentView: View {
        var body: some View {
            ProgressView(value: 250, total: 1000)
        }
    }
    

![progress](/public/progress1.png)

As you can see in the example above, we use another initializer of the
_ProgressView_ to display the current progress and the total value. SwiftUI
automatically calculates the percentage of the work done and shows
corresponding progress using the linear indicator.

####  Styling

We can easily customize the _ProgressView_ using another initializer that
accepts _@ViewBuilder_ representing the label of the view.

    
    
    struct ContentView: View {
        var body: some View {
            ProgressView {
                Text("Loading")
                    .font(.title)
            }
        }
    }
    

![progress](/public/progress3.png)

There is also an initializer with _@ViewBuilder_ that works with determinate
progress and allows you to customize the label.

> To learn more about _ViewBuilder_ , take a look at my dedicated [ “The power
> of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-viewbuilder-in-
> swiftui/) post.

As usual, SwiftUI provides a style protocol that allows us completely redesign
the default look and feel. You need to create a type that conforms to the
_ProgressViewStyle_ and implement the makeBody function.

    
    
    struct HorizontalProgressViewStyle: ProgressViewStyle {
        func makeBody(configuration: Configuration) -> some View {
            HStack(spacing: 8) {
                ProgressView()
                    .progressViewStyle(.circular)
                configuration.label
            }.foregroundColor(.secondary)
        }
    }
    
    extension ProgressViewStyle where Self == HorizontalProgressViewStyle {
        static var horizontal: HorizontalProgressViewStyle { .init() }
    }
    
    struct ContentView: View {
        var body: some View {
            ProgressView("Loading")
                .progressViewStyle(.horizontal)
        }
    }
    

In the example above, we create a horizontal style to display the circular
animating indicator and the label. _Configuration_ parameter provides us the
completed fraction of the progress, which allows us to draw a super-custom
progress view.

    
    
    struct CustomProgressView: View {
        let value: Double
    
        var body: some View {
            // Draw progress here
        }
    }
    
    struct CustomProgressViewStyle: ProgressViewStyle {
        func makeBody(configuration: Configuration) -> some View {
            VStack {
                if let value = configuration.fractionCompleted {
                    CustomProgressView(value: value)
                }
                Text("Loading...")
            }
        }
    }
    

Here we have a custom view that renders the progress. It might be anything you
want, from straightforward text to a custom animated path. Keep in mind that
_fractionCompleted_ might be nil when you use the indeterminate progress view.

####  Conclusion

The _ProgressView_ might seem to be very simple, but it provides an excellent
level of customization and styling options. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# The power of task view modifier in SwiftUI

##  The power of task view modifier in SwiftUI

28 Jun 2022

_Task_ view modifier is the key to the Swift Concurrency world through
SwiftUI. It allows us to build complex async tasks by leveraging the power of
cooperative cancellation and the lifecycle of a SwiftUI view. This week we
will learn all the powerful features of the _task_ view modifier in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

    
    
    struct ContentView: View {
        @StateObject private var store = Store()
        
        var body: some View {
            NavigationStack {
                List(store.products) { product in
                    NavigationLink {
                        Text(product.id.uuidString)
                    } label: {
                        Text(product.id.uuidString)
                    }
                }
                .task {
                    await store.fetchProducts()
                }
            }
        }
    }
    

The _task_ view modifier starts the unstructured async task and binds it to
the view lifecycle. SwiftUI automatically cancels ongoing tasks whenever the
view disappears by propagating cooperative cancellation.

    
    
    @MainActor final class Store: ObservableObject {
        @Published private(set) var products: [Product] = [
            .init(), .init(), .init()
        ]
        
        func fetchProducts() async {
            do {
                try await Task.sleep(nanoseconds: 3_000_000_000)
                products = [.init(), .init(), .init()]
            } catch {
                // Ignore CancellationError
            }
        }
    }
    

As you can see in the example above, we pause the task by using the _sleep_
function that throws _CancellationError_ whenever a task is canceled during
the sleep. Alternatively, you can use the _isCancelled_ property on the _Task_
type indicating whether or not the current task is canceled.

By default, the _task_ view modifier uses the user-initiated (highest)
priority for the created task, but you can also use lower preferences like
utility or background.

    
    
    struct ContentView: View {
        @StateObject private var store = Store()
        
        var body: some View {
            NavigationStack {
                List(store.products) { product in
                    NavigationLink {
                        Text(product.id.uuidString)
                    } label: {
                        Text(product.id.uuidString)
                    }
                }
                .task(priority: .utility) {
                    await store.fetchProducts()
                }
            }
        }
    }
    

Another variant of the _task_ view modifier allows us to observe equitable
data and run the async task whenever the data changes. The task lifecycle is
still bound to the view lifecycle, but SwiftUI also cancels the ongoing job
whenever data changes and creates a new one for the latest data.

    
    
    struct ContentView: View {
        @StateObject private var store = Store()
        @State private var query = ""
        
        var body: some View {
            NavigationStack {
                List(store.products) { product in
                    NavigationLink {
                        Text(product.id.uuidString)
                    } label: {
                        Text(product.id.uuidString)
                    }
                }
                .searchable(text: $query)
                .task(id: query) {
                    await store.search(matching: query)
                }
            }
        }
    }
    

> To learn more about building search functionality in SwiftUI, take a look at
> my [ “Mastering search in SwiftUI” ](/2021/06/23/mastering-search-in-
> swiftui/) post.

In the example above, whenever the user types the query in the search bar
SwiftUI creates a task. SwiftUI makes a task for every change in the search
query in this case. Usually, we want to debounce requests to our servers and
make them after a slight pause. We can quickly achieve this effect by
leveraging the power of the cooperative cancellation and data observing
capabilities of the _task_ view modifier.

    
    
    struct ContentView: View {
        @StateObject private var store = Store()
        @State private var query = ""
        
        var body: some View {
            NavigationStack {
                List(store.products) { product in
                    NavigationLink {
                        Text(product.id.uuidString)
                    } label: {
                        Text(product.id.uuidString)
                    }
                }
                .searchable(text: $query)
                .task(id: query) {
                    do {
                        try await Task.sleep(nanoseconds: 300_000_000)
                        await store.search(matching: query)
                    } catch {
                        // Task cancelled without network request.
                    }
                }
            }
        }
    }
    

Here we try to sleep for a bit and make a network query only if the user
doesn’t type a new query. In another case, SwiftUI cancels the task and
creates a new one.

    
    
    struct DebouncingTaskViewModifier<ID: Equatable>: ViewModifier {
        let id: ID
        let priority: TaskPriority
        let nanoseconds: UInt64
        let task: @Sendable () async -> Void
        
        init(
            id: ID,
            priority: TaskPriority = .userInitiated,
            nanoseconds: UInt64 = 0,
            task: @Sendable @escaping () async -> Void
        ) {
            self.id = id
            self.priority = priority
            self.nanoseconds = nanoseconds
            self.task = task
        }
        
        func body(content: Content) -> some View {
            content.task(id: id, priority: priority) {
                do {
                    try await Task.sleep(nanoseconds: nanoseconds)
                    await task()
                } catch {
                    // Ignore cancellation
                }
            }
        }
    }
    
    extension View {
        func task<ID: Equatable>(
            id: ID,
            priority: TaskPriority = .userInitiated,
            nanoseconds: UInt64 = 0,
            task: @Sendable @escaping () async -> Void
        ) -> some View {
            modifier(
                DebouncingTaskViewModifier(
                    id: id,
                    priority: priority,
                    nanoseconds: nanoseconds,
                    task: task
                )
            )
        }
    }
    

Debouncing via _task_ view modifier becomes very handy in my projects. That’s
why I created a small wrapper around the _task_ view modifier, allowing us to
debounce tasks without this boilerplate.

> To learn more about building custom view modifiers, take a look at my [
> “ViewModifiers in SwiftUI” ](/2019/08/07/viewmodifiers-in-swiftui/) post.
    
    
    struct ContentView: View {
        @StateObject private var store = Store()
        @State private var query = ""
        
        var body: some View {
            NavigationStack {
                List(store.products) { product in
                    NavigationLink {
                        Text(product.id.uuidString)
                    } label: {
                        Text(product.id.uuidString)
                    }
                }
                .searchable(text: $query)
                .task(id: query, nanoseconds: 300_000_000) {
                    await store.search(matching: query)
                }
            }
        }
    }
    

Today we learned how to use the _task_ view modifier and the different
opportunities it provides to handle complex async flows. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Mastering FocusState property wrapper in SwiftUI

##  Mastering FocusState property wrapper in SwiftUI

24 Aug 2021

SwiftUI became very powerful during the last WWDC. We gained many new
features, and one of them was a brand new _FocusState_ property wrapper.
_FocusState_ property wrapper allows us to read and write the current focus
position in the view hierarchy. This week we will learn how to manage focus in
SwiftUI apps using _FocusState_ property wrapper and _focused_ view modifier.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

SwiftUI provides a new _FocusState_ property wrapper that works on all Apple
platforms and allows us to focus on a particular view or check if that view is
already focused. The usage is effortless. Let’s see how we can use it.

    
    
    import SwiftUI
    
    struct SignInView: View {
        @FocusState private var isEmailFocused: Bool
        @State private var email = ""
    
        var body: some View {
            NavigationView {
                Form {
                    TextField("email", text: $email, prompt: Text("email"))
                        .focused($isEmailFocused)
                }
                .navigationTitle("Sign in")
                .onChange(of: isEmailFocused) { newValue in
                    print(newValue)
                }
            }
        }
    }
    

As you can see in the example above, we need to define a boolean variable
using the _FocusState_ property wrapper. We also have to bind its value to the
focus state of a particular view using the _focused_ view modifier. SwiftUI
sets the boolean value of the view to true as soon as the user focuses on it.
It also changes it to false as soon as the view loses focus.

> To learn more about focus management in SwiftUI, take a look at my [ “Focus
> management in SwiftUI” ](/2020/12/02/focus-management-in-swiftui/) post.

You can define as many _FocusState_ variables as needed to cover your focus
management logic. SwiftUI takes care of them by keeping in sync the focused
view with its binding.

    
    
    import SwiftUI
    
    struct SignInView: View {
        @FocusState private var isEmailFocused: Bool
        @FocusState private var isPasswordFocused: Bool
    
        @State private var email = ""
        @State private var password = ""
    
        var body: some View {
            NavigationView {
                Form {
                    TextField("email", text: $email, prompt: Text("email"))
                        .focused($isEmailFocused)
                    SecureField("password", text: $password, prompt: Text("password"))
                        .focused($isPasswordFocused)
                }
                .navigationTitle("Sign in")
            }
        }
    }
    

In the example above, we have two variables bound to email and password text
fields. SwiftUI can manage them together and keep them in sync with the user
interface. Remember that you can change the value to false programmatically to
hide the keyboard or set the value to true to move the focus to a particular
view.

    
    
    import SwiftUI
    
    struct SignInView: View {
        @FocusState private var isEmailFocused: Bool
        @FocusState private var isPasswordFocused: Bool
    
        @State private var email = ""
        @State private var password = ""
    
        var body: some View {
            NavigationView {
                Form {
                    TextField("email", text: $email, prompt: Text("email"))
                        .focused($isEmailFocused)
                    SecureField("password", text: $password, prompt: Text("password"))
                        .focused($isPasswordFocused)
    
                    Button("login") {
                        if email.isEmpty {
                            isEmailFocused = true
                        } else if password.isEmpty {
                            isPasswordFocused = true
                        } else {
                            isPasswordFocused = false
                            isEmailFocused = false
    
                            login()
                        }
                    }
                }
                .navigationTitle("Sign in")
            }
        }
    
        private func login() {
            // your logic here
        }
    }
    

> To learn about other focus related property wrappers in SwiftUI, take a look
> at my [ “FocusedValue and FocusedBinding property wrappers in SwiftUI”
> ](/2021/03/03/focusedvalue-and-focusedbinding-property-wrappers-in-swiftui/)
> post.

Defining many _FocusState_ properties in complex view hierarchies can become
cumbersome. Fortunately, _FocusState_ works not only with boolean values but
also with any _Hashable_ type. It means that we can model the focused state
using an enum type conforming to _Hashable_ protocol. Let’s take a look at the
example.

    
    
    enum FocusableField: Hashable {
        case email
        case password
    }
    

Here we have the _Field_ enum that conforms to _Hashable_ and defines all the
focusable views we manage. Now, we can use this enum to bind the focus state
of different views to various enum cases.

    
    
    struct ContentView: View {
        @State private var email = ""
        @State private var password = ""
        @FocusState private var focus: FocusableField?
    
        var body: some View {
            NavigationView {
                Form {
                    TextField("email", text: $email, prompt: Text("email"))
                        .focused($focus, equals: .email)
                    SecureField("password", text: $password, prompt: Text("password"))
                        .focused($focus, equals: .password)
                    Button("login", action: login)
                }
                .toolbar {
                    ToolbarItem(placement: .keyboard) {
                        Button("next") {
                            if email.isEmpty {
                                focus = .email
                            } else if password.isEmpty {
                                focus = .password
                            } else {
                                focus = nil
                            }
                        }
                    }
                }
                .navigationTitle("Sign in")
                .defaultFocus($focus, .email)
            }
        }
    
        private func login() {
            // your logic here
        }
    }
    

As you can see, we use another version of the _focused_ view modifier to bind
a view to a concrete case of the _Field_ enum. SwiftUI updates the value of
the _FocusState_ property whenever the user focuses on any of the bound views.
We also use, the _defaultFocus_ view modifier to programmatically focus on the
email field as soon as view appears.

Remember that we should make our _FocusState_ property optional to use it with
_Hashable_ enum because there might be no focused view at the moment.

> To learn more about toolbars in SwiftUI, take a look at my [ “Mastering
> toolbars in SwiftUI” ](/2020/07/15/mastering-toolbars-in-swiftui/) post.

Today we learned how to use the _FocusState_ property wrapper to manage focus
in our views. Remember that _FocusState_ allows us both to read and change the
focused view programmatically. I hope you enjoy the post. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Dynamic Type in SwiftUI

##  Dynamic Type in SwiftUI

09 Oct 2019

This week I want to talk to you about Dynamic Type support in SwiftUI. I think
there is no way to create an excellent user experience without Dynamic Type
support in your apps. SwiftUI provides Dynamic Type out of the box for any
text representation and simplifies our job. But we still need to do some work,
so let’s talk about it.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Dynamic Type basics

The Dynamic Type feature allows users to choose the size of textual content
displayed on the screen. It helps users who need larger text for better
readability. It also accommodates those who can read a smaller text, allowing
more information to appear on the screen. Apps that support _Dynamic Type
also_ provide a more consistent reading experience.

You don’t need to do anything to support Dynamic Type in your SwiftUI views,
because by default, all the components representing text are multiline.
Apple’s [ Human Interface Guidelines
](https://developer.apple.com/design/human-interface-
guidelines/ios/overview/themes/) have a special section about _Typography_ ,
which provides common text styles. These text styles describe font
configuration for different types of text content like _title, headline, body,
subhead, caption, footnote_ . The styles are shared between all the apps. Try
to use these predefined text styles as much as possible. Here is a small
example of how to use _HIG_ defined text styles in SwiftUI.

    
    
    struct PostView: View {
        let post: Post
    
        var body: some View {
            VStack(alignment: .leading) {
                Image(post.image)
    
                Text(post.title)
                    .font(.headline)
    
                Text(post.time)
                    .font(.subheadline)
    
                Text(post.body)
                    .font(.body)
            }
        }
    }
    

To learn how to adapt custom fonts to Dynamic Type take a look at Paul
Hudson’s [ “How to use Dynamic Type with a custom font”
](https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-dynamic-
type-with-a-custom-font) post.

####  Content size category

In the previous paragraph, I said that SwiftUI supports Dynamic Type out of
the box, and that’s true. But to support Dynamic Type, we need to keep in mind
that every text can be multiline even when it has just two words. It all
depends on user-defined font size, which can be extra-extra-large. SwiftUI
provides a special environment value describing the user-defined size
category. Let’s take a look at how we can use it.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @Environment(\.sizeCategory) var sizeCategory
    
        var buttons: some View {
            Group {
                Button("Action 1") {}
                Button("Action 2") {}
            }
        }
    
        var body: some View {
            Group {
                if sizeCategory.isAccessibilityCategory {
                    VStack { buttons }
                } else {
                    HStack { buttons }
                }
            }
        }
    }
    

By using _sizeCategory_ value of the environment, we can read the defined font
size and decide how to render our content. By using the environment, our app
will subscribe to the system settings, and as soon as the user changes the
font size, our view will reload.

> To learn more about environment feature, take a look at [ “The power of
> Environment in SwiftUI” ](/2019/08/21/the-power-of-environment-in-swiftui/)
> post.

Let’s go ahead and create an extension for _Group_ component, which embeds it
into a horizontal or vertical stack depending on the user-defined size
category.

    
    
    import SwiftUI
    
    fileprivate struct EmbedInStack: ViewModifier {
        @Environment(\.sizeCategory) var sizeCategory
    
        func body(content: Content) -> some View {
            Group {
                if sizeCategory > ContentSizeCategory.medium {
                    VStack { content }
                } else {
                    HStack { content }
                }
            }
        }
    }
    
    extension Group where Content: View {
        func embedInStack() -> some View {
            modifier(EmbedInStack())
        }
    }
    

In the example above, we use _ViewModifier_ , which wraps the _Group_ of views
into a stack. One of the benefits of _ViewModifiers_ is the ability to have a
state or subscribe to an environment value.

> To learn more about _ViewModifiers_ , take a look at [ “ViewModifiers in
> SwiftUI” ](/2019/08/07/viewmodifiers-in-swiftui/) post.

####  ScrollViews

The possibility of a short text to be multiline brings another requirement. We
need to embed our root views into the scroll view to allow the user to scroll
the content when it doesn’t fit the screen. It quickly turns into boilerplate,
that’s why I’ve created a special extension to reuse this functionality.

    
    
    import SwiftUI
    
    extension View {
        func embedInScrollView(alignment: Alignment = .center) -> some View {
            GeometryReader { geometry in
                ScrollView {
                    self.frame(
                        minWidth: geometry.size.width,
                        minHeight: geometry.size.height,
                        maxHeight: .infinity,
                        alignment: alignment
                    )
                }
            }
        }
    }
    

####  ScaledMetric

During WWDC20 Apple released a new property wrapper called _ScaledMetric_ .
_ScaledMetric_ allows you to scale a _BinaryFloatingValue_ according to the
size category chosen by the user. Let’s take a look at the quick example.

    
    
    struct ContentView: View {
        @ScaledMetric(relativeTo: .body) var spacing: CGFloat = 8
    
        var body: some View {
            VStack(spacing: spacing) {
                ForEach(0...10, id: \.self) { number in
                    Text(String(number))
                }
            }
        }
    }
    

Here we have the vertical spacing value which is scaled using the selected
size category.

> To learn more about new property wrappers in SwiftUI, take a look at [ “New
> property wrappers in SwiftUI” ](/2020/06/29/new-property-wrappers-in-
> swiftui/) post.

####  Conclusion

Dynamic Type is a super important feature, and every app should support it.
SwiftUI does much stuff out of the box to support Dynamic Type, but it
requires some boilerplate. Today we learned how to reduce it by creating
special view extensions. I hope you enjoy the post. Feel free to follow me on
[ Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# The power of @ViewBuilder in SwiftUI

##  The power of @ViewBuilder in SwiftUI

18 Dec 2019

Last week we started a series of posts about developing interactive components
using SwiftUI, where we talked about building the bottom sheet. We need to
understand the power of _@ViewBuilder_ before moving to the next post about
building another interactive view. That’s why this week, we will talk about
_@ViewBuilder_ and its benefits while developing custom views.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Result builders

_@ViewBuilder_ is one of the possible result builders. The result builder
feature of Swift is described in [ Swift Evolution Proposal
](https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-
builders.md) . The main goal of result builder is providing _DSL_ like syntax.
Let’s take a look at a very quick example of _@ViewBuilder_ usage.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            HStack{
                Text("hello")
                Text("world")
            }
        }
    }
    

We need to go down one layer to understand how _@ViewBuilder_ works.

    
    
    @inlinable public init(
        alignment: VerticalAlignment = .center,
        spacing: CGFloat? = nil,
        @ViewBuilder content: () -> Content
    )
    

Here is the declaration of _HStack_ view, as you can see the content closure
inside the init method marked with _@ViewBuilder_ . It means that expression
inside that closure needs to be handled by _@ViewBuilder_ . The swift compiler
will try to find the static buildBlock method declared in _@ViewBuilder_
struct that has two views as parameters. Let’s take a look at _@ViewBuilder_
struct declaration to find that method.

    
    
    @available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
    extension ViewBuilder {
        public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> TupleView<(C0, C1)> where C0 : View, C1 : View
    }
    

As you can see, _@ViewBuilder_ has a static _buildBlock_ method that accepts
two views, combine them and return _TupleView_ . It also has other
declarations of _buildBlock_ method, which takes from one to ten child views,
and all of them combine child views into a _TupleView_ . That’s why
_@ViewBuilder_ can accept only ten views inside the closure.

    
    
    struct ContentView: View {
        @ObservedObject var viewModel: ViewModel
    
        @ViewBuilder
        var body: some View {
            if viewModel.isAuthorized {
                Text("Hello World!")
            } else {
                LoginView(viewModel: viewModel)
            }
        }
    }
    

_@ViewBuilder_ also has support for conditions via _if_ and _switch_
expressions.

    
    
    struct ContentView: View {
        @ObservedObject var viewModel: ViewModel
    
        @ViewBuilder
        var body: some View {
            switch viewModel.isAuthorized {
            case true:
                Text("Hello")
            case false:
                LoginView(viewModel: viewModel)
            }
        }
    }
    

> To learn how to avoid ten views limitation, take a look at my [ “View
> Composition in SwiftUI” ](/2019/10/30/view-composition-in-swiftui/) post.

####  TupleView

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            HStack{
                Text("hello")
                Text("world")
            }
        }
    }
    
    print(Mirror(reflecting: ContentView().body))
    // Mirror for HStack<TupleView<(Text, Text)>>
    

_TupleView_ is a view created from a swift tuple of view values. _TupleView_
doesn’t have any logic inside. It just holds the views. _TupleView_ completely
transparent and behaves like its parent view. It means when you put it inside
the _HStack_ , _TupleView_ places the views from the tuple in a horizontal
direction.

####  Using @ViewBuilder

Now we know all the needed things to build our own custom view container,
which uses _@ViewBuilder_ . Assume that our app needs a notification view. The
notification view should have a consistent design and appear in the top of the
screen, but content can be various. It is a perfect use case for
_@ViewBuilder_ . Let’s see how we can utilize it.

    
    
    import SwiftUI
    
    struct NotificationView<Content: View>: View {
        let content: Content
    
        init(@ViewBuilder content: () -> Content) {
            self.content = content()
        }
    
        var body: some View {
            content
                .padding()
                .background(Color(.tertiarySystemBackground))
                .cornerRadius(16)
                .transition(.move(edge: .top))
                .animation(.spring())
        }
    }
    

As you can see, we use _@ViewBuilder_ to mark our content closure. It gives us
the opportunity to use _NotificationView_ in the same way as _VStack_ or
_HStack_ . Here is the example of using _NotificationView_ .

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var notificationShown = false
    
        var body: some View {
            VStack {
                if self.notificationShown {
                    NotificationView {
                        Text("notification")
                    }
                }
    
                Spacer()
    
                Button("toggle") {
                    self.notificationShown.toggle()
                }
    
                Spacer()
            }
        }
    }
    

> We also used the ability to build custom views via _@ViewBuilder_ during [
> “Building Bottom sheet in SwiftUI” ](/2019/12/11/building-bottom-sheet-in-
> swiftui/) post.

####  Conclusion

This week we talked about the benefits of result builders and used
_@ViewBuilder_ as a concrete example. _@ViewBuilder_ allows us to build super
reusable SwiftUI views by separating its presentation logic and content. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Pull-to-Refresh in SwiftUI

##  Pull-to-Refresh in SwiftUI

14 Jul 2021

Pull-to-refresh is a widespread User Interface pattern that we use to request
a data update in our apps. The SwiftUI Release 3 provides a brand new way to
set up a pull-to-refresh action using the new _refreshable_ view modifier.
This week, we will learn how to use the _refreshable_ view modifier and
provide a super custom experience with it.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s start with a simple example where you have a _List_ displaying items
from the view model. It should also provide a pull-to-refresh gesture to
update the list of items.

    
    
    struct ContentView: View {
        @StateObject private var viewModel = SearchViewModel()
        @State private var query = "Swift"
    
        var body: some View {
            NavigationView {
                List(viewModel.repos) { repo in
                    Text(repo.name)
                }
                .navigationTitle("Search")
                .refreshable {
                    await viewModel.search(matching: query)
                }
            }
        }
    }
    

In the example above, we attach the _refreshable_ view modifier to the _List_
view, configuring the pull-to-refresh gesture. We pass an async closure that
SwiftUI runs when a user enables the pull-to-refresh gesture. Keep in mind
that the pull-to-refresh gesture is only available for the _List_ view at the
moment.

The _refreshable_ view modifier uses the new Swift Concurrency feature and
automatically disables the refreshing indicator when the async task finishes.
Remember that the only way to control the refreshing indicator is async/await.
You can’t show/hide it manually at the moment.

> To learn more about the new Swift Concurrency feature, look at the [
> Concurrency chapter of Swift book ](https://docs.swift.org/swift-
> book/LanguageGuide/Concurrency.html) .

####  Custom refreshable views

SwiftUI uses pull-to-refresh in List views out of the box. You don’t need to
do additional work like creating and adding spinner to the view hierarchy. But
sometimes, you might need to build ultimately custom refresh experience.

    
    
    struct ContentView: View {
        @StateObject private var viewModel = SearchViewModel()
        @State private var query = "Swift"
    
        var body: some View {
            NavigationView {
                SearchView(viewModel: viewModel)
                    .refreshable {
                        await viewModel.search(matching: query)
                    }
            }
        }
    }
    

Assume that you are working on a custom reusable view that represents the list
of items. You might want to show a refresh button in the toolbar whenever the
_refreshable_ view modifier is attached to the view. Fortunately, when you
attach the _refreshable_ view modifier, SwiftUI propagates it down to the view
hierarchy by using the environment.

    
    
    struct SearchView: View {
        @ObservedObject var viewModel: SearchViewModel
        @Environment(\.refresh) private var refreshAction
        @State private var isRefreshing = false
    
        var body: some View {
            LazyVGrid(columns: Array(repeating: .init(), count: 4)) {
                ForEach(viewModel.repos) { repo in
                    AsyncImage(url: repo.owner.avatar)
                        .frame(width: 44, height: 44)
                        .clipShape(Circle())
                }
            }.toolbar {
                if let refreshAction = refreshAction {
                    Button("Refresh") {
                        async {
                            isRefreshing = true
                            await refreshAction()
                            isRefreshing = false
                        }
                    }
                    .disabled(isRefreshing)
                    .opacity(isRefreshing ? 0 : 1)
                    .overlay {
                        if isRefreshing {
                            ProgressView()
                        }
                    }
                }
            }
        }
    }
    

As you can see in the example above, we have a view representing a grid of
items. SwiftUI grids don’t provide a pull-to-refresh behavior. That’s why I
decide to show a refresh button in the toolbar.

We use the _Environment_ property wrapper to access the optional refresh
action of the view. SwiftUI sets the refresh action in the environment when
you attach the _refreshable_ view modifier. Otherwise, it is nil.

> To learn more about environment in SwiftUI, take a look at my [ “The power
> of Environment in SwiftUI” ](/2019/08/21/the-power-of-environment-in-
> swiftui/) post.

We use a closure that we provide to the _refreshable_ view modifier as an
action closure for the refresh button. I also track the refreshing internal
state of the view to disable the button during the refresh and display the
progress indicator.

![refresh](/public/refresh.png)

####  Conclusion

Today we learned about another SwiftUI feature available in Release 3. I love
how SwiftUI is consistent in providing functionality out of the box and
allowing us to customize the behavior using the environment. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading, and see you next
week!



# Anchor preferences in SwiftUI

##  Anchor preferences in SwiftUI

18 Mar 2020

Today we will continue mastering view preferences in SwiftUI that we touched a
few weeks ago. Anchor preferences are another type of view preferences
provided by SwiftUI. The main goal of anchor preferences is to pass layout
data like bounds, center coordinates, etc. to its parent view.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

First of all, I want to ask you to check the post about view preferences if
you are not familiar with these API. Anchor preferences use a very similar
API. The only difference is that it is tuned to pass layout-specific data.

> To learn more about the benefits of preferences in SwiftUI, take a look at
> my [ “The magic of view preferences in SwiftUI” ](/2020/01/15/the-magic-of-
> view-preferences-in-swiftui/) post.

Let’s build a simple view that shows text and passes its bounds to the
ancestor. The parent view will draw an overlaying rectangle in that position.

    
    
    struct BoundsPreferenceKey: PreferenceKey {
        typealias Value = Anchor<CGRect>?
    
        static var defaultValue: Value = nil
    
        static func reduce(
            value: inout Value,
            nextValue: () -> Value
        ) {
            value = nextValue()
        }
    }
    
    struct ExampleView: View {
        var body: some View {
            ZStack {
                Color.yellow
                Text("Hello World !!!")
                    .anchorPreference(
                        key: BoundsPreferenceKey.self,
                        value: .bounds
                    ) { $0 }
            }
            .overlayPreferenceValue(BoundsPreferenceKey.self) { preferences in
                GeometryReader { geometry in
                    preferences.map {
                        Rectangle()
                            .stroke()
                            .frame(
                                width: geometry[$0].width,
                                height: geometry[$0].height
                            )
                            .offset(
                                x: geometry[$0].minX,
                                y: geometry[$0].minY
                            )
                    }
                }
            }
        }
    }
    

As you can see in the example above, we still use the _PreferenceKey_ protocol
to create an anchor preference key. It has two requirements: default value and
reduce function. Reduce function allows us to merge multiple values that
appear from different views. We can replace the current value with the new one
for now. We will see more advanced usage of reduce function later in the post.

Anchor preferences use opaque _Anchor_ type. You can’t merely use Anchor type
anywhere in the app. You have to use it in pair with _GeometryProxy_ provided
by _GeometryReader_ . You can use the subscript of _GeometryProxy_ to resolve
anchor and access wrapped _CGRect_ value. As a bonus, SwiftUI will convert a
coordinate space between views while solving anchor, and you don’t need to do
it manually.

We use the _anchorPreference_ modifier to define the type of _PreferenceKey_
and the value we want to gather. It can be bounds, center, leading, trailing,
top, bottom. We also pass a closure that transforms provided anchor value. In
this case, we don’t need any transformation and return the _CGRect_ value as
is.

In the end, we use _overlayPreferenceValue_ on ancestor view to access
gathered preference values and return overlay view. As I mentioned before, we
need a _GeometryProxy_ to resolve an anchor. That’s why we use here
_GeometryReader_ .

![anchor-basics](/public/anchor-basics.png)

We can easily use border modifier on the text view to achieve the same result,
but I’ve done it to show you the basics of anchor preferences.

####  Advanced usage

Now we can move to more advanced usage of anchor preferences. As an example,
we will build a grid view. We will need to gather the size of every view
inside the grid to calculate its positions. Let’s start by defining the
_PreferenceKey_ for our grid view.

    
    
    struct SizePreferences<Item: Hashable>: PreferenceKey {
        typealias Value = [Item: CGSize]
    
        static var defaultValue: Value { [:] }
    
        static func reduce(
            value: inout Value,
            nextValue: () -> Value
        ) {
            value.merge(nextValue()) { $1 }
        }
    }
    

As you can see here, we will store the dictionary that represents an item and
its size. In the reduce function, we merge old and new dictionaries by
overriding new values. Now we can define our grid view.

    
    
    struct Grid<Data: RandomAccessCollection, ElementView: View>: View where Data.Element: Hashable {
        private let data: Data
        private let itemView: (Data.Element) -> ElementView
    
        @State private var preferences: [Data.Element: CGRect] = [:]
    
        init(_ data: Data, @ViewBuilder itemView: @escaping (Data.Element) -> ElementView) {
            self.data = data
            self.itemView = itemView
        }
    
        var body: some View {
            GeometryReader { geometry in
                ZStack(alignment: .topLeading) {
                    ForEach(self.data, id: \.self) { item in
                        self.itemView(item)
                            .alignmentGuide(.leading) { _ in
                                -self.preferences[item, default: .zero].origin.x
                            }
                            .alignmentGuide(.top) { _ in
                                -self.preferences[item, default: .zero].origin.y
                            }
                            .anchorPreference(
                                key: SizePreferences<Data.Element>.self,
                                value: .bounds
                            ) {
                                [item: geometry[$0].size]
                            }
                    }
                }
            }
        }
    }
    

We use _ZStack_ with top leading alignment. It allows us to position items
inside in an effortless way. Instead of using the offset modifier which
doesn’t affect the layout, we use overridden alignment guides to position our
child views. We also resolve our anchors here, because we already have access
to the instance of _GeometryProxy_ .

> To learn more about the benefits of alignment guides in SwiftUI, take a look
> at my [ “Alignment guides in SwiftUI” ]() post.
    
    
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .topLeading) {
                ...
            }
            .onPreferenceChange(SizePreferences<Data.Element>.self) { sizes in
                var newPreferences: [Data.Element: CGRect] = [:]
                var bounds: [CGRect] = []
                for item in self.data {
                    let size = sizes[item, default: .zero]
                    let rect: CGRect
                    if let lastBounds = bounds.last {
                        if lastBounds.maxX + size.width > geometry.size.width {
                            let origin = CGPoint(x: 0, y: lastBounds.maxY)
                            rect = CGRect(origin: origin, size: size)
                        } else {
                            let origin = CGPoint(x: lastBounds.maxX, y: lastBounds.minY)
                            rect = CGRect(origin: origin, size: size)
                        }
                    } else {
                        rect = CGRect(origin: .zero, size: size)
                    }
                    bounds.append(rect)
                    newPreferences[item] = rect
                }
                self.preferences = newPreferences
            }
        }
    }
    

As the last step, we calculate bounds for every item using
_onPreferenceChange_ modifier which provides us the access to gathered sizes.
Let’s take a look at the final result.

    
    
    struct RootView: View {
        @State private var cards: [String] = [
            "Lorem", "ipsum", "is", "placeholder", "text", "!!!"
        ]
    
        var body: some View {
            Grid(cards) { card in
                Text(card)
                    .frame(width: 120, height: 120)
                    .background(Color.orange)
                    .cornerRadius(8)
                    .padding(4)
            }
        }
    }
    

![anchor](/public/anchor.png)

####  Conclusion

SwiftUI provides us so many great tools that we can use to build impressive
views. Anchor preferences feature is one of the powerful hidden gems of
SwiftUI. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Introducing SwiftUI on visionOS

##  Introducing SwiftUI on visionOS

23 Jan 2024

Apple Vision Pro is coming soon, and it is the perfect time to look at SwiftUI
API, which allows us to adapt our apps to the immersive world that visionOS
provides us. Apple states that the best way to build an app is with Swift and
SwiftUI. This week, we will learn how to use SwiftUI to build a visionOS app.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Windows

What I love about SwiftUI is how it automatically adapts to the platform. You
don’t need to do anything to run your app written in SwiftUI on visionOS. It
works out of the box. But you can always improve the user experience by going
forward and adapting the platform features.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationSplitView {
                List {
                // list content
                }
                .navigationTitle("Models")
                .toolbar {
                    ToolbarItem(placement: .bottomOrnament) {
                        Button("open", systemImage: "doc.badge.plus") {
                            
                        }
                    }
                    
                    ToolbarItem(placement: .bottomOrnament) {
                        Button("open", systemImage: "link.badge.plus") {
                            
                        }
                    }
                }
            } detail: {
                Text("Choose something from the sidebar")
            }
        }
    }
    

> To learn more about building apps supporting multiple windows, take a look
> at my dedicated [ “Window management in SwiftUI” ](/2022/11/02/window-
> management-in-swiftui/) post.

In the example above, we use the new toolbar placement called _bottomOrnament_
. Ornament in visionOS is the place outside the window presenting controls
connected to the window. You can also create them manually by using the new
_ornament_ view modifier.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationSplitView {
                List {
                // list content
                }
                .navigationTitle("Models")
                .ornament(attachmentAnchor: .scene(.leading)) {
                    // Place your views here
                }
            } detail: {
                Text("Choose something from the sidebar")
            }
        }
    }
    

The new _ornament_ view modifier allows us to create an ornament with a
particular anchor point for the window it is connected to. Another option to
adapt your app content to the immersive experience that visionOS provides is
to use the _transform3DEffect_ and _rotation3DEffect_ view modifiers to
incorporate depth effects.

![visionOS](/public/visionOS.webp)

####  Volumes

Your apps can display 2D and 3D content side by side in the same scene on
visionOS. We can use the RealityKit framework to present 3D content in this
case. For example, RealityKit provides us with the _Model3D_ SwiftUI view,
allowing us to display 3D models from the USDZ or reality files.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationSplitView {
                List(Model.all) { model in
                    NavigationLink {
                        Model3D(named: model.name)
                    } label: {
                        Text(verbatim: model.name)
                    }
                }
                .navigationTitle("Models")
            } detail: {
                Model3D(named: "robot")
            }
        }
    }
    

_Model3D_ view works similarly to the _AsyncImage_ view and loads the model
asynchronously. You can also use another variant of the _Model3D_ initializer,
which allows you to customize the model configuration and add a placeholder
view.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationSplitView {
                List(Model.all) { model in
                    NavigationLink {
                        Model3D(
                            url: Bundle.main.url(
                                forResource: model.name,
                                withExtension: "usdz"
                            )!
                        ) { resolved in
                            resolved
                                .resizable()
                                .aspectRatio(contentMode: .fit)
                        } placeholder: {
                            ProgressView()
                        }
                    } label: {
                        Text(verbatim: model.name)
                    }
                }
                .navigationTitle("Models")
            } detail: {
                Model3D(named: "robot")
            }
        }
    }
    

While presenting 3D content in your app, you can use the _windowStyle_
modifier to enable _volumetric_ display of your content. The _volumetric_
style allows your content to grow in the third dimension to match the model’s
size.

For more complex 3D scenes, we can use the _RealityView_ and populate it with
3D content.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationSplitView {
                List(Model.all) { model in
                    NavigationLink {
                        RealityView { content in
                            // load the content and add to the scene
                        }
                    } label: {
                        Text(verbatim: model.name)
                    }
                }
                .navigationTitle("Models")
            } detail: {
                Text("Choose something from the sidebar")
            }
        }
    }
    

####  Immersive spaces

The third option on visionOS is the fully immersive experience, allowing us to
dive into the 3D scene by hiding everything around by focusing on your scene.

    
    
    @main
    struct MyApp: App {
        var body: some Scene {
            WindowGroup {
                ContentView()
            }
            
            ImmersiveSpace(id: "solar-system") {
                SolarSystemView()
            }
        }
    }
    

As you can see in the example above, we define a scene by using the
_ImmersiveSpace_ type. It allows us to enable it by using the
_openImmersiveSpace_ environment value.

    
    
    struct MyMenuView: View {
        @Environment(\.openImmersiveSpace) private var openImmersiveSpace
        
        var body: some View {
            Button("Enjoy immersive space") {
                Task {
                    await openImmersiveSpace(id: "solar-system")
                }
            }
        }
    }
    

We can also use the _dismissImmersiveSpace_ environment value to dismiss the
immersive space. Remember that you can only display one immersive space at a
time.

    
    
    struct SolarSystemView: View {
        @Environment(\.dismissImmersiveSpace) private var dismiss
        
        var body: some View {
            // Immersive experience
            
            Button("Dismiss") {
                Task {
                    await dismiss()
                }
            }
        }
    }
    

####  Conclusion

Today, we learned the basics of the SwiftUI framework for the brand new
visionOS platform. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# The difference between @StateObject, @EnvironmentObject, and @ObservedObject in SwiftUI

##  The difference between @StateObject, @EnvironmentObject, and
@ObservedObject in SwiftUI

02 Jul 2020

This week I decided to share as much as I can about data flow in SwiftUI. In
this post, we will discuss the difference between @ _StateObject_ , @
_EnvironmentObject_ , and @ _ObservedObject_ property wrappers. I know that
this is the most confusing topic in SwiftUI for newcomers.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Why SwiftUI does need property wrappers?

SwiftUI uses immutable struct types to describe the view hierarchy. All the
views that SwiftUI provides are immutable. That’s why SwiftUI gives us a bunch
of property wrappers to handle data mutations. Property wrappers allow us to
declare them inside SwiftUI views but store the data outside of the view
declaring it.

####  @StateObject

@ _StateObject_ is the new property wrapper that initializes the instance of a
class that conforms to _ObservableObject_ protocol and store it inside the
SwiftUI framework’s internal memory. SwiftUI creates @ _StateObject_ only once
for every container that declares it and keeps it outside of view lifecycle.
Let’s look at some examples where we use @ _StateObject_ to keep the whole
app’s state.

    
    
    import SwiftUI
    
    @main
    struct CardioBotApp: App {
        @StateObject var store = Store(
            initialState: AppState(),
            reducer: appReducer,
            environment: AppEnvironment(service: HealthService())
        )
    
        var body: some Scene {
            WindowGroup {
                RootView().environmentObject(store)
            }
        }
    }
    

As you can see, @ _StateObject_ perfectly fits to store the whole app state
and share it with different scenes or views of your app. SwiftUI will store it
in special framework memory to keep your data in a safe place outside of scene
or view lifecycle.

> To learn more about using a single state container, take a look at my [
> “Redux-like state container in SwiftUI. Basics.” ](/2019/09/18/redux-like-
> state-container-in-swiftui/) post.

####  @ObservedObject

@ _ObservedObject_ is another way to subscribe and keep track of changes in
_ObservableObject_ . SwiftUI doesn’t control the lifecycle of @
_ObservedObject_ , and you have to manage it yourself. @ _ObservedObject_
perfectly fits a case where you have an _ObservableObject_ stored by @
_StateObject_ , and you want to share it with any reusable view.

    
    
    struct CalendarContainerView: View {
        @ObservedObject var store: Store<CalendarState, CalendarAction>
        let interval: DateInterval
    
        var body: some View {
            CalendarView(interval: interval) { date in
                DateView(date: date) {
                    self.view(for: date)
                }
            }.navigationBarTitle("calendar", displayMode: .inline)
        }
    }
    

I mention reusable views because I use _CalendarContainerView_ in multiple
places in my app, and I don’t want to make it dependent on the environment. I
use @ _ObservedObject_ to explicitly indicate the data used by the view in
that particular case.

    
    
    NavigationLink(
        destination: CalendarContainerView(
            store: transformedStore,
            interval: .twelveMonthsAgo
        )
    ) {
        Text("Calendar")
    }
    

> To learn more about using container views, take a look at my [ “Redux-like
> state container in SwiftUI. Container Views.” ](/2019/10/02/redux-like-
> state-container-in-swiftui-part3/) post.

####  @EnvironmentObject

@ _EnvironmentObject_ is an excellent way to implicitly inject an instance of
a class that conforms to _ObservableObject_ into a part of the view hierarchy.
Assume that you have a module in your app that contains 3-4 screens, and all
of them use the same view model. If you don’t want to pass the same view model
explicitly from one view to another, then @ _EnvironmentObject_ is all you
need. Let’s take a look at how we can use it.

    
    
    @main
    struct CardioBotApp: App {
        @StateObject var store = Store(
            initialState: AppState(),
            reducer: appReducer,
            environment: .production
        )
    
        var body: some Scene {
            WindowGroup {
                TabView {
                    NavigationView {
                        SummaryContainerView()
                            .navigationBarTitle("today")
                            .environmentObject(
                                store.derived(
                                    deriveState: \.summary,
                                    embedAction: AppAction.summary
                                )
                            )
                    }
    
                    NavigationView {
                        TrendsContainerView()
                            .navigationBarTitle("trends")
                            .environmentObject(
                                store.derived(
                                    deriveState: \.trends,
                                    embedAction: AppAction.trends
                                )
                            )
                    }
                }
            }
        }
    }
    

In the example above, we inject the environment object into the view hierarchy
of _SummaryContainerView_ . SwiftUI will implicitly give access for inserted
environment objects to all child views that live inside _SummaryContainerView_
. We can quickly obtain and subscribe to injected environment objects using @
_EnvironmentObject_ property wrapper.

    
    
    struct SummaryContainerView: View {
        @EnvironmentObject var store: Store<SummaryState, SummaryAction>
    
        var body: some View {
            //......
        }
    }
    

I have to mention that @ _EnvironmentObject_ has the same lifecycle as @
_ObservedObject_ . It means that you can get a new environment object whenever
you create it inside a view that can be recreated by SwiftUI.

> To learn more about advanced techniques while using a single state
> container, take a look at my [ “Redux-like state container in SwiftUI. Best
> practices.” ](/2019/09/25/redux-like-state-container-in-swiftui-part2/)
> post.

####  Conclusion

Today we talked about the differences between @ _StateObject_ , @
_EnvironmentObject_ , and @ _ObservedObject_ property wrappers. I hope this
post makes it easier to understand which property wrapper fits best your case.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# What's new in SwiftUI

##  What's new in SwiftUI

23 Jun 2020

I have been waiting for this day for the last nine months, and it has finally
arrived. We saw the next iteration of the SwiftUI framework. Apple did a great
job during the last year by improving SwiftUI and moving it towards by making
it a standalone way for building apps for the Apple ecosystem. Today we will
take a peek at all-new SwiftUI features.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  App structure

Apple provides a brand new way of defining the app’s entry point by using the
_App_ protocol. _App_ protocol allows us to easily replace the _AppDelegate_
and _SceneDelegate_ with a single struct that will manage our scenes and app
lifecycle. Let’s take a look at a very quick example.

    
    
    @main
    struct CardioBotApp: App {
        @SceneBuilder var body: some Scene {
            WindowGroup {
                ContentView()
            }
        }
    }
    

In the example above, we have a struct that conforms to the _App_ protocol.
The only requirement is the _body_ property that should return any _Scene_ .
The _Scene_ is another new protocol introduced by SwiftUI that allows us to
declare an app scene. SwiftUI comes with a few ready to use implementations,
and one of them is _WindowGroup_ . _WindowGroup_ is a scene type that we will
mostly use for the main interface of our app that isn’t document-based.

    
    
    @main
    struct MyApp: App {
        @SceneBuilder var body: some Scene {
            DocumentGroup(newDocument: TextFile()) { textFile in
                TextEditor(textFile.$document.text)
            }
    
            #if os(macOS)
            Settings {
                SettingsView()
            }
            #endif
        }
    }
    

For document-based apps, SwiftUI provides a _DocumentGroup_ scene that
automatically handles the navigation through files.

####  Lazy stacks

One thing that I don’t like about SwiftUI stacks is the eager initialization.
Whenever you have ten or thousand views in a stack, SwiftUI tries to create
them immediately. Fortunately, it is changed today. The new version of the
SwiftUI framework provides us _LazyHStack_ and _LazyVStack_ which create its
children only when needed.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                LazyVStack {
                    ForEach(0...1000, id: \.self) { index in
                        Text(String(index))
                            .onAppear { print(index) }
                    }
                }
            }
        }
    }
    

####  Grids

It was so tough to create a photo gallery or calendar layout in SwiftUI
without _UICollectionView_ . Nowadays, most of the apps have a screen with a
grid layout. It was nearly impossible to create a grid layout efficiently
using SwiftUI. Fortunately, now we can do it using the new _LazyVGrid_ and
_LazyHGrid_ views. Let’s take a look at a quick example.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                LazyVGrid(
                    columns: Array(
                        repeating: GridItem(.flexible()),
                        count: 3
                    )
                ) {
                    ForEach(0...1000, id: \.self) { _ in
                        Color.red
                    }
                }
            }
        }
    }
    

####  ScrollView

If you read my post about [ SwiftUI wishes ](/2020/06/10/swiftui-wishlist-for-
wwdc20/) , you might know that I have been waiting for an ability to scroll to
a particular offset using a _ScrollView_ . That part of functionally stopped
me from using SwiftUI’s _ScrollView_ . It is also changed today when Apple
released the _ScrollViewReader_ . _ScrollViewReader_ works very similarly to
_GeometryReader_ and provides a way to scroll to a specific view using its
_ID_ .

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ScrollViewReader { scrollView in
                    LazyVStack {
                        ForEach(0...1000, id: \.self) { index in
                            Text(String(index))
                                .id(index)
                        }
                        Button("Scroll to the middle") {
                            scrollView.scrollTo(500)
                        }
                    }
                }
            }
        }
    }
    

####  TextEditor

One of the most missing components in SwiftUI was _TextView_ . There was no
way to edit or type multiline text. We end up with wrapping _TextView_ with
_UIViewRepresentable_ , but it doesn’t work well in different circumstances.
Finally, this year SwiftUI provides us a _TextEditor_ view that allows us to
edit multiline text. Let’s take a look at how we can use it.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var text = "Hello World!"
    
        var body: some View {
            TextEditor(text: $text)
        }
    }
    

The usage is pretty similar to _TextField_ , but in this case, we allowed to
type very long text examples. There is still no way to use attributed text,
but I hope it will arrive during the next betas.

####  New data flow property wrappers

Besides all the new views that Apple released today, we also have brand new
ways to handle data flow in SwiftUI. SwiftUI now includes the _AppStorage_
property wrapper that accesses _UserDefauls_ and invalidates view as soon as
corresponding key changes. Let’s take a look at the example.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @AppStorage("isNotificationsEnabled") var enabled = false
    
        var body: some View {
            Toggle("Notifications", isOn: $enabled)
        }
    }
    

There is also _SceneStorage_ property wrapper that we can use for the
automatic state restoration of the value. It works similarly to _AppStorage_ ,
but instead of _UserDefaults_ , it uses per-scene storage managed by the
system.

Another new property wrapper is _StateObject_ . _StateObject_ works similarly
to _State_ property wrapper. It allocates memory inside the SwiftUI framework
and stores your _ObservableObject_ there. It allows to _ObservableObject_ to
survive during view updates.

    
    
    @main
    struct CardioBotApp: App {
        @StateObject var store = Store()
    
        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environmentObject(store)
            }
        }
    }
    

####  New styling opportunities

One of the best things about SwiftUI is the way that the framework uses to
apply styling. Most of the views in SwiftUI provides protocols that we can
conform to share the styling across the app. This year the list of styling
protocols increased. SwiftUI allows us to transform _TabView_ into a paging
view by applying _PageTabViewStyle_ . There is also a new collection of list
styles like _SidebarListStyle_ , _InsetGroupedListStyle_ , and
_InsetListStyle_ .

####  New views

This year SwiftUI integrates more deeply with all the frameworks across the
Apple ecosystem. For example, MapKit provides _Map_ and _MapAnnotations_
SwiftUI views. ClockKit provides us a _Gauge_ view that we can use to show
value within a range. AVKit provides the _VideoPlayer_ view that we can use to
integrate with _AVPlayer_ .

There is also a bunch of new views that SwiftUI provides us today. We finally
have a system-wide color picker, native _SignInWithAppleButton_ ,
_ProgressView_ that supports both linear and circular progress indicators,
_OutlineGroup_ that allows us to display tree-structured collections of data,
and much more.

####  Conclusion

I’m delighted to see that the next iteration of SwiftUI is so strong. Of
course, I will share with you detailed posts about all new features of SwiftUI
as soon as I play with them enough to share something. Feel free to follow me
on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and have a nice week!



# ImageRenderer in SwiftUI

##  ImageRenderer in SwiftUI

18 Apr 2023

I work on a medical app where the user needs to export health data rendered
using the Swift Charts framework. It was straightforward to achieve by
leveraging the power of the new _ImageRenderer_ type. This week we will learn
how to use the _ImageRenderer_ type to export SwiftUI view as image or PDF.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The _ImageRenderer_ type provides an easy-to-use API, allowing us to export
the SwiftUI view hierarchy as an image. Let’s take a look at a quick example.

    
    
    import SwiftUI
    import Charts
    
    struct MyChartView: View {
        let numbers: [Double]
        
        var body: some View {
            Chart {
                ForEach(Array(numbers.enumerated()), id: \.offset) { index, value in
                    LineMark(
                        x: .value("Index", index),
                        y: .value("Value", value)
                    )
                }
            }
        }
    }
    
    struct ContentView: View {
        @StateObject private var renderer = ImageRenderer(
            content: MyChartView(
                numbers: [1,2,3]
            )
        )
        
        var body: some View {
            if let image = renderer.uiImage {
                Image(uiImage: image)
            }
        }
    }
    

As you can see in the example above, we use the _StateObject_ property wrapper
to define an instance of the _ImageRenderer_ type. The _ImageRenderer_ type
conforms to the _ObservableObject_ protocol, and SwiftUI automatically updates
the view hierarchy whenever an instance of the _ImageRenderer_ marked with the
_StateObject_ property wrapper changes.

The only parameter we need to create an instance of the _ImageRenderer_ type
is the _content_ , and it has to be a SwiftUI view. The _ImageRenderer_ type
provides us _uiImage_ and _cgImage_ properties allowing us to access the
rendered image of the content view.

In the previous example, we create an instance of the _ImageRenderer_ type by
passing an instance of the _MyChartView_ type, which uses the Swift Charts
framework to display its content. In the body of the _ContentView_ , we place
_Image_ view to show rendered version of the _MyChartView_ . As soon as the
renderer is ready, SwiftUI updates the body of the _ContentView_ .

It was a static example of using the _ImageRenderer_ type. Usually, we need to
export dynamic SwiftUI views with the data available only during app runtime.

    
    
    struct SummaryContainerView: View {
        @State private var image: UIImage?
        @State private var shareSheetShown = false
        
        var body: some View {
            List {
                summarySection
            }
            .toolbar {
                Button("Export") {
                    let renderer = ImageRenderer(content: summarySection)
                    image = renderer.uiImage
                    shareSheetShown = true
                }
            }
            .sheet(isPresented: $shareSheetShown) {
                if let image = image {
                    Image(uiImage: image)
                }
            }
        }
        
        private var summarySection: some View {
            Section {
                // ...
            }
        }
    }
    

As you can see in the example above, we render the part of the particular
SwiftUI view as an image displaying some data summary. The _ImageRenderer_
type allows us to tune a few parameters affecting the final result of the
exported image. For example, we can change the scale, size, and color mode
using the _scale_ , _proposedSize_ , and _colorMode_ properties.

    
    
    struct SummaryContainerView: View {
        @State private var image: UIImage?
        @State private var shareSheetShown = false
        @Environment(\.displayScale) private var scale
        
        var body: some View {
            List {
                summarySection
            }
            .toolbar {
                Button("Export") {
                    let renderer = ImageRenderer(content: summarySection)
                    renderer.scale = scale
                    image = renderer.uiImage
                    shareSheetShown = true
                }
            }
            .sheet(isPresented: $shareSheetShown) {
                if let image = image {
                    Image(uiImage: image)
                }
            }
        }
        
        private var summarySection: some View {
            Section {
                // ...
            }
        }
    }
    

Another exciting feature of the _ImageRenderer_ type is the ability to draw
the rendered image in any instance of the _CGContext_ type. It means you can
use the _ImageRenderer_ to make an image of SwiftUI view a part of your PDF
context.

    
    
    struct SummaryContainerView: View {
        var body: some View {
            List {
                summarySection
            }
            .toolbar {
                Button("Save as PDF") {
                    let renderer = ImageRenderer(content: summarySection)
                    renderer.render { size, renderInContext in
                        var box = CGRect(
                            origin: .zero,
                            size: .init(width: 600, height: 800)
                        )
                        
                        guard let context = CGContext(fileUrl as CFURL, mediaBox: &box, nil) else {
                            return
                        }
                        
                        context.beginPDFPage(nil)
                        renderInContext(context)
                        context.endPage()
                        context.closePDF()
                    }
                }
            }
        }
        
        private var summarySection: some View {
            Section {
                // ...
            }
        }
    }
    

As you can see in the example above, we create an instance of the _CGContext_
to generate a PDF file. We use the _render_ function of the _ImageRenderer_
type allowing us to access the size of the image displaying a SwiftUI view,
and the renderer function that we can use to inject the image into an instance
of the _CGContext_ type.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Dynamic member lookup in Swift

##  Dynamic member lookup in Swift

23 May 2023

One of my favorite features of the Swift Language is the dynamic member
lookup. We don’t use it very often, but it improves the API of the provided
type significantly by improving the way we access the data of the particular
type.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Assume that we are working on a type providing caching functionality, and we
model it as the struct called _Cache_ .

    
    
    struct Cache {
        var storage: [String: Data] = [:]
    }
    

To access cached data, we call the subscript of the storage property that the
_Dictionary_ type provides us.

    
    
    var cache = Cache()
    let profile = cache.storage["profile"]
    

Nothing is exceptional here. We access the dictionary as we used by using the
subscript of the _Dictionary_ type. Let’s look at how we can improve the API
of the _Cache_ type using the _@dynamicMemberLookup_ attribute.

    
    
    @dynamicMemberLookup
    struct Cache {
        private var storage: [String: Data] = [:]
        
        subscript(dynamicMember key: String) -> Data? {
            storage[key]
        }
    }
    

As you can see in the example above, we mark our _Cache_ type with the
_@dynamicMemberLookup_ attribute. We must implement the subscript with the
_dynamicMember_ parameter returning anything we need.

    
    
    var cache = Cache()
    let profile = cache.profile
    

Now, we can access the profile data of our _Cache_ type more nicely. The user
of our API may assume that the _profile_ is the property of the _Cache type_ .
But it is not.

This feature works completely in runtime and leverages the name of any
property we type after the dot symbol to the subscript of the _Cache_ type
with the _dynamicMember_ parameter.

The whole logic runs in runtime, and the result is undefined during
compilation. It is entirely up to you to decide which data you should return
from the subscript during runtime and how you want to handle the
_dynamicMember_ parameter.

####  Compile-time safety with KeyPath

The only downside we can find is the absence of compile-time safety. We can
treat the _Cache_ type as if it has any property name we type in the code.
Fortunately, the parameter of the _@dynamicMemberLookup_ subscript may be not
only String-typed but also _KeyPath_ .

    
    
    @dynamicMemberLookup
    final class Store<State, Action>: ObservableObject {
        typealias ReduceFunction = (State, Action) -> State
        
        @Published private var state: State
        private let reduce: ReduceFunction
        
        init(
            initialState state: State,
            reduce: @escaping ReduceFunction
        ) {
            self.state = state
            self.reduce = reduce
        }
        
        subscript<T>(dynamicMember keyPath: KeyPath<State, T>) -> T {
            state[keyPath: keyPath]
        }
        
        func send(_ action: Action) {
            state = reduce(state, action)
        }
    }
    

As you can see in the example above, we define the subscript with the
_dynamicMember_ parameter accepting an instance of the strong-typed _KeyPath_
. In this case, we allow _KeyPath_ of the _State_ type, which helps us to have
compile-time safety. Because the compiler will show an error anytime we pass a
wrong _KeyPath_ , which is not connected to the _State_ type.

    
    
    struct State {
        var products: [String] = []
        var isLoading = false
    }
    
    enum Action {
        case fetch
    }
    
    let store: Store<State, Action> = .init(initialState: .init()) { state, action in
        var state = state
        switch action {
        case .fetch:
            state.isLoading = true
        }
        return state
    }
    
    
    print(store.isLoading)
    print(store.products)
    print(store.favorites) // Compiler error
    

In the example above, we access the private _state_ property of the _Store_
using the subscript accepting the _KeyPath_ . It looks similar to the previous
example, but in this case, the compiler shows an error whenever you try to
access an unavailable property of the _State_ type.

Today we learned how to improve the API of a particular type by using the
_@dynamicMemberLookup_ attribute. You don’t need it in every type, but you can
use it carefully to improve the API. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Mastering charts in SwiftUI. Basics.

##  Mastering charts in SwiftUI. Basics.

10 Jan 2023

Swift Charts is a new framework by Apple allowing us to visualize our data in
a declarative way using SwiftUI. The Swift Charts framework inherits from
SwiftUI its declarative nature and the power of intelligent defaults. This
week we will start with the basics of the Charts framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start by plotting a simple line chart from an array of numbers.

    
    
    struct ContentView: View {
        let numbers: [Double]
        
        var body: some View {
            Chart {
                ForEach(Array(numbers.enumerated()), id: \.offset) { index, value in
                    LineMark(
                        x: .value("Index", index),
                        y: .value("Value", value)
                    )
                }
            }
        }
    }
    

![mastering-chart](/public/chart1.png)

As you can see in the example above, we define an instance of the _Chart_
view. Then inside the _ViewBuilder_ closure of the _Chart_ view, we use the
_ForEach_ view to place the array of numbers using the _LineMark_ . The
_Chart_ view is smart enough to plot the single line passing all the points
defined via _LineMark_ .

> To learn more about the logic behind the _ViewBuilder_ type, take a look at
> my [ “The power of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-
> viewbuilder-in-swiftui/) post.

Swift Charts allow us to compose different types of marks on a single chart.
We have plenty of marks in use, like _AreaMark_ , _BarMark_ , _LineMark_ ,
_PointMark_ , _RectangleMark_ , and _RuleMark_ .

    
    
    struct ContentView: View {
        let numbers: [Double]
        
        var body: some View {
            Chart {
                RuleMark(y: .value("Limit", 50))
                
                ForEach(Array(numbers.enumerated()), id: \.offset) { index, value in
                    LineMark(
                        x: .value("Index", index),
                        y: .value("Value", value)
                    )
                    
                    PointMark(
                        x: .value("Index", index),
                        y: .value("Value", value)
                    )
                }
            }
        }
    }
    

![mastering-chart](/public/chart2.png)

In the example above, we use the _PointMark_ type to draw a circular point for
every data point. We also use _RuleMark_ to draw a horizontal limit line. As
you can see, we easily compose different marks on the same chart.

The heart of the Swift Charts framework is the _Plottable_ protocol. It allows
us to define a mark with any value that conforms to the _Plottable_ protocol.
By default, types like _Int_ , _String_ , _Double_ , _Date_ , and _Decimal_
conform to the _Plottable_ protocol. But you can always conform your own type
to the _Plottable_ protocol if needed.

Swift Charts support quantitative, categorical, and temporal values. For
example, _Double_ is quantitative, _String_ is categorical, and _Date_ is
temporal value.

    
    
    enum Gender: String {
        case male
        case female
        case notSet
    }
    
    struct Stats {
        let city: String
        let population: Int
        let gender: Gender
    }
    

Here we create a type called _Stats_ to define a city’s population by gender.
The city’s population is a quantitative value. The name and gender are
categorical.

    
    
    struct ContentView1: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                }
            }
        }
    }
    
    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            NavigationStack {
                ContentView1(
                    stats: [
                        .init(city: "NY", population: 10_164_966, gender: .female),
                        .init(city: "NY", population: 9_581_261, gender: .male),
                        .init(city: "LA", population: 5_133_906, gender: .female),
                        .init(city: "LA", population: 4_982_799, gender: .male)
                    ]
                )
                .preferredColorScheme(.dark)
            }
        }
    }
    

![mastering-chart](/public/chart3.png)

As you can see in the example above, we use the _BarMark_ type to draw the
population of the provided cities. We use the city name, which is categorical
type as X position. That’s why the _Chart_ view concatenate every mark with
the same X position.

    
    
    struct ContentView1: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender.rawValue))
                }
            }
        }
    }
    

![mastering-chart](/public/chart4.png)

We can use different foreground styles for the _BarMark_ type and style them
using gender value. It allows us to see the different ranges in a single bar.

    
    
    enum Gender: String {
        case male
        case female
        case notSet
    }
    
    extension Gender: Plottable {
        var primitivePlottable: String {
            rawValue
        }
    }
    
    struct Stats {
        let city: String
        let population: Int
        let gender: Gender
    }
    
    struct ContentView1: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender))
                }
            }
        }
    }
    

Now we conform the _Gender_ type to the _Plottable_ protocol to simplify our
code a little bit. Remember that you can provide any logic you need to convert
your custom data to plottable primitives.

Today we learned basics of the new Swift Charts framework. Charts framework
provides us a lot of defaults out of the box. Every chart we build supports
accessibility and automatically provides us legends, correctly scaled plotting
area, etc.

In the next posts, we will learn more about customization options in the new
Charts framework. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Mastering buttons in SwiftUI

##  Mastering buttons in SwiftUI

19 Feb 2020

_Button_ is one of the regularly used components in SwiftUI. We use buttons to
allow users to produce actions. That’s why it is so essential to generalize
the look and feel of buttons in our apps. This week we will master buttons in
SwiftUI. We will learn how to customize the look and feel of our buttons.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basic usage

Let’s start by presenting a simple button that prints something in the console
whenever the user presses it.

    
    
    struct RootView: View {
        var body: some View {
            Button("Button 1") {
                print("Button 1")
            }
        }
    }
    

![button](/public/button.png)

Pretty easy, right? Now we can move forward, I want to style my buttons in
Apple way. Buttons should be filled with the accent color of my app and have a
corner radius. Let’s take a look at the quick implementation.

    
    
    Button("Button 2") {}
        .foregroundColor(.white)
        .padding()
        .background(Color.accentColor)
        .cornerRadius(8)
    

![button](/public/button1.png)

Now my button looks like I need, but my app has a lot of actions represented
by buttons, and I don’t want to copy-paste these styling code every time. We
can solve the issue by introducing a new view.

    
    
    struct FilledButton: View {
        let title: String
        let action: () -> Void
    
        var body: some View {
            Button(title, action: action)
                .foregroundColor(.white)
                .padding()
                .background(Color.accentColor)
                .cornerRadius(8)
        }
    }
    

Now we can use _FilledButton_ everywhere in the app. We create a new view that
renders our button, but this approach has one downside. We can’t modify the
label of our button. For example, we can’t change the text color while the
user presses the button.

####  ButtonStyle protocol

SwiftUI allows us to customize buttons in our apps without introducing new
views or copy-pasting the styling code. SwiftUI provides the special
_ButtonStyle_ protocol. We can implement _FilledButton_ struct that conforms
to _ButtonStyle_ instead of _View_ protocol. Let’s see what benefits we have
by using _ButtonStyle_ protocol.

    
    
    struct FilledButton: ButtonStyle {
        @Environment(\.isEnabled) private var isEnabled
    
        func makeBody(configuration: Configuration) -> some View {
            configuration
                .label
                .foregroundColor(configuration.isPressed ? .gray : .white)
                .padding()
                .background(isEnabled ? Color.accentColor : .gray)
                .cornerRadius(8)
        }
    }
    

As you can see in the example above, _ButtonStyle_ protocol has the only one
requirement. We need to implement _makeBody_ function. This function provides
a configuration that we can use to obtain the label of the button and
understand whenever it is pressed or not. I have to mention that we also have
access to the environment inside the _FilledButton_ type.

    
    
    Button("Button 1") {}
        .buttonStyle(FilledButton())
    

####  Custom behavior with button styles

Button styles can change the button instance drastically. For example, we can
make a button style that accepts a boolean value and shows an activity
indicator depending on that value.

    
    
    struct ProgressButtonStyle: ButtonStyle {
        let isLoading: Bool
    
        func makeBody(configuration: Configuration) -> some View {
            configuration.label
                .opacity(isLoading ? 0 : 1)
                .overlay {
                    if isLoading {
                        ProgressView()
                    }
                }
        }
    }
    
    struct ContentView: View {
        @State private var isLoading = true
    
        var body: some View {
            Button("Download") {
                isLoading.toggle()
            }.buttonStyle(ProgressButtonStyle(isLoading: isLoading))
        }
    }
    

####  Button styles and environment

Another benefit of _ButtonStyle_ protocol is the ability to set it in the
environment. It means we don’t need to set a button style manually for every
button. SwiftUI will automatically apply it whenever we configure it for the
current environment. Let’s take a look at the small example.

    
    
    import SwiftUI
    
    struct RootView: View {
        var body: some View {
            HStack(spacing: 16) {
                Button("Button 1") {}
    
                Button("Button 2") {}
    
                Button("Button 3") {}
            }
        }
    }
    
    import PlaygroundSupport
    
    let rootView = RootView()
        .accentColor(.orange)
        .buttonStyle(FilledButton())
    PlaygroundPage.current.setLiveView(rootView)
    

After setting a button style in the environment, we don’t need to configure
our buttons again. SwiftUI will apply that styling options by default. I want
to mention that you can easily override any button or environment style by
directly calling the _buttonStyle_ modifier again.

    
    
    struct OutlineButton: ButtonStyle {
        func makeBody(configuration: Configuration) -> some View {
            configuration
                .label
                .foregroundColor(configuration.isPressed ? .gray : .accentColor)
                .padding()
                .background(
                    RoundedRectangle(
                        cornerRadius: 8,
                        style: .continuous
                    ).stroke(Color.accentColor)
            )
        }
    }
    
    struct RootView: View {
        var body: some View {
            HStack(spacing: 16) {
                Button("Button 1") {}
    
                Button("Button 2") {}
                    .buttonStyle(OutlineButton())
    
                Button("Button 3") {}
            }
        }
    }
    
    import PlaygroundSupport
    
    let rootView = RootView()
        .accentColor(.orange)
        .buttonStyle(FilledButton())
    PlaygroundPage.current.setLiveView(rootView)
    

> SwiftUI uses environment to pass system-wide and application-related
> information. You can also populate environment with your custom objects. To
> learn more about environment, take a look at my [ “The power of Environment
> in SwiftUI” ](/2019/08/21/the-power-of-environment-in-swiftui/) post.

####  PrimitiveButtonStyle protocol

Sometimes we need to implement super custom buttons. For example, assume that
we need a button that acts only after a long press. We can’t achieve that with
_ButtonStyle_ protocol because it doesn’t provide us control on triggering the
button action. Instead, SwiftUI gives us _PrimitiveButtonStyle_ protocol that
looks very similar to _ButtonStyle_ but provides all the needed API to build a
super custom button. Let’s build our button that acts after a long press.

    
    
    struct LongPressButton: PrimitiveButtonStyle {
        func makeBody(configuration: Configuration) -> some View {
            configuration
                .label
                .gesture(
                    LongPressGesture()
                        .onEnded { _ in configuration.trigger() }
            )
        }
    }
    

As you can see in the example above, _PrimitiveButtonStyle_ looks very similar
to our good friend _ButtonStyle_ , but instead of _isPressed_ property
_configuration_ provides us a _trigger_ closure that represents the action of
the button. We can trigger the button using that closure whenever we want. We
can apply our _PrimitiveButtonStyle_ in the same way by using the
_buttonStyle_ modifier.

![buttons](/public/buttons.png)

####  Conclusion

This week we learned a few ways of customizing buttons in our apps. I am
delighted with this protocol based styling approach in SwiftUI and love it. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering LabeledContent in SwiftUI

##  Mastering LabeledContent in SwiftUI

13 Jul 2022

One of the new SwiftUI views released during WWDC22 was _LabeledContent_ . And
it became one of my favorite views that I try to use everywhere because it
fits very well into Human Design Guidelines. This week we will learn how to
use _LabeledContent_ to provide a platform-oriented experience.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

_LabeledContent_ view is a simple view that composes a label and content.
Usually, it displays the label on the leading edge and the content on the
trailing edge. You can achieve similar behavior by inserting the label and
content into the _HStack_ and placing the _Spacer_ view between them.

But _LabeledContent_ is not that simple. It understands its parent container
and can display the content in different ways. _LabeledContent_ can also apply
additional styling like using secondary color as foreground color for its
content. Let’s take a look at how we can use it.

    
    
    struct ContentView: View {
        var body: some View {
            Form {
                LabeledContent("Label", value: "Content")
            }
        }
    }
    

![labeled-content](/public/labeled-content1.png)

As you can see in the example above, the usage of the _LabeledContent_ view is
straightforward. But it works not only for _String_ values. You can use it to
present any data supporting the _FormatStyle_ protocol.

    
    
    struct ContentView: View {
        var body: some View {
            Form {
                LabeledContent(
                    "Number",
                    value: 100.0,
                    format: .number.precision(.fractionLength(0))
                )
            }
        }
    }
    

![labeled-content](/public/labeled-content2.png)

The _LabeledContent_ view allows you to present any SwiftUI view as a label or
content. For example, you might use it to display a _Stepper_ inside the
_Form_ .

    
    
    struct ContentView: View {
        @State private var value = 0.0
        
        var body: some View {
            Form {
                LabeledContent {
                    Stepper(value: $value, in: 0...10.0) {
                        Text(value.formatted(.number))
                    }
                } label: {
                    Text("Count")
                }
            }
        }
    }
    

![labeled-content](/public/labeled-content3.png)

####  Styling

Like many SwiftUI views, the _LabeledContent_ view supports styling via the
particular _LabeledContentStyle_ protocol. You only need to create a type
conforming to _LabeledContentStyle_ protocol and implement your _makeBody_
function.

    
    
    struct AccentedLabeledContentStyle: LabeledContentStyle {
        func makeBody(configuration: Configuration) -> some View {
            LabeledContent(configuration)
                .foregroundColor(.accentColor)
        }
    }
    
    extension LabeledContentStyle where Self == AccentedLabeledContentStyle {
        static var accented: AccentedLabeledContentStyle { .init() }
    }
    
    struct ContentView: View {
        var body: some View {
            Form {
                LabeledContent("Label", value: "Content")
                    .labeledContentStyle(.accented)
            }
        }
    }
    

As you can see in the example above, we create another instance of the
_LabeledContent_ view and pass the instance of the _Configuration_ type that
holds the label and content views. It works great when you want to apply
custom styling options. But sometimes we need to provide a completely
different layout with our custom styling. We can achieve it by implementing
the _makeBody_ function without using _LabeledContent_ .

    
    
    struct VerticalLabeledContentStyle: LabeledContentStyle {
        func makeBody(configuration: Configuration) -> some View {
            VStack(alignment: .leading) {
                configuration.label
                configuration.content
            }
        }
    }
    
    extension LabeledContentStyle where Self == VerticalLabeledContentStyle {
        static var vertical: VerticalLabeledContentStyle { .init() }
    }
    
    
    struct ContentView: View {
        var body: some View {
            Form {
                LabeledContent("Label", value: "Content")
                    .labeledContentStyle(.vertical)
            }
        }
    }
    

Using the _labeledContentStyle_ view modifier, we put our custom style into
the environment where all the child views of the view hierarchy use this style
unless it is overridden. You can also hide the label of the _LabeledContent_
view by attaching the _labelsHidden_ view modifier.

    
    
    struct ContentView: View {
        var body: some View {
            Form {
                LabeledContent("Label", value: "Content")
                    .labelsHidden()
            }
        }
    }
    

> To learn more about sharing styles using the environment, take a look at my
> [ “Styling custom SwiftUI views using environment” ](/2020/12/09/styling-
> custom-swiftui-views-using-environment/) post.

####  Conclusion

Today we learned about another great view that SwiftUI provides to simplify
our lives. To be honest, I have a similar view in my codebase that doing the
same, but it is always great to have this kind of thing provided by the SDK. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering Preview macro in Swift

##  Mastering Preview macro in Swift

17 Oct 2023

Xcode Preview Canvas is a crucial part of my development experience. Previews
have significant changes this year by introducing the new **#Preview** macro.
This week, we will learn about using the new **#Preview** macro and the
benefits of this approach.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The new **#Preview** macro is super easy to use. Let’s take a look at the
first example.

    
    
    #Preview {
        ContentView()
            .preferredColorScheme(.dark)
    }
    

As you can see in the example above, all you need to do is embed your SwiftUI
view into the _#Preview_ macro. That’s it. And let me tell you that it works
not only with SwiftUI views. You can embed any instance of _UIViewController_
or _UIView_ .

    
    
    #Preview {
        SearchViewController()
    }
    

> To learn more about Xcode Preview Canvas, take a look at my [ “Mastering
> SwiftUI previews” ](/2021/03/10/mastering-swiftui-previews/) post.

You may want to have a set of previews displaying different states of your
view. In this case, you can put as many _#Preview_ macros as you want to
display more than one preview.

    
    
    #Preview {
        ItemsView(data: .empty)
    }
    
    #Preview {
        ItemsView(data: .error)
    }
    

Whenever you have more than one preview, you should give them different titles
to differentiate them in the preview canvas. You can easily do that by passing
a title as a parameter of the _#Preview_ macro.

    
    
    #Preview("Empty state") {
        ItemsView(data: .empty)
    }
    
    #Preview("Error state") {
        ItemsView(data: .error)
    }
    

The _#Preview_ macro has the _traits_ parameter, allowing us to display your
preview in landscape or a particular size. This version of the _#Preview_
macro is not working on previous versions and requires an availability
attribute.

    
    
    @available(iOS 17, *)
    #Preview(traits: .landscapeLeft) {
        ContentView()
    }
    
    @available(iOS 17, *)
    #Preview(traits: .fixedLayout(width: 300, height: 300)) {
        ContentView()
    }
    

Another option is to use the _#Preview_ macro with widgets to provide a
timeline provider and display an interactive widget timeline.

    
    
    #Preview(as: .accessoryRectangular) {
        SugarBotWidget()
    } timeline: {
        RawValuesProvider()
    }
    

Today, we learned how to use the new _#Preview_ macro to improve our
development experience. Remember that you can create a Swift file containing
only previews for your design system package or an example case displaying how
to use your custom view.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Redux-like state container in SwiftUI. Swift concurrency model.

##  Redux-like state container in SwiftUI. Swift concurrency model.

17 Feb 2022

Over the last two years, I have actively used unidirectional flow to develop
my apps. I covered the approach I use in the series of posts about building
Redux-like state containers. This week I want to share with you how this
approach adapts to the latest changes in Swift by applying the new concurrency
model.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Swift concurrency is the new language feature allowing us to write concurrent
code straightforwardly. I’m not going to cover this in detail and assume that
you know how to use it. If you are not familiar with the Swift Concurrency
model, I suggest starting with the [ official docs
](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html) .

    
    
    typealias Reducer<State, Action, Dependencies> =
        (inout State, Action, Dependencies) -> AnyPublisher<Action, Never>?
        
    final class Store<State, Action, Dependencies>: ObservableObject {
        @Published private(set) var state: State
    
        private let dependencies: Dependencies
        private let reducer: Reducer<State, Action, Dependencies>
        private var cancellables: Set<AnyCancellable> = []
    
        init(
            initialState: State,
            reducer: @escaping Reducer<State, Action, Dependencies>,
            dependencies: Dependencies
        ) {
            self.state = initialState
            self.reducer = reducer
            self.dependencies = dependencies
        }
    
        func send(_ action: Action) {
            guard let effect = reducer(&state, action, dependencies) else {
                return
            }
    
            effect
                .receive(on: DispatchQueue.main)
                .sink(receiveValue: send)
                .store(in: &cancellables)
        }
    }
    

As you can see above, I have been using the Combine framework heavily to do
asynchronous work. But now I’m switching to the new Swift concurrency model.
And I am pleased to see that the new concurrency model plays very well with
the Combine framework, and we can mix them to don’t break the working code in
our apps and migrate step by step.

    
    
    typealias Reducer<State, Action, Dependencies> =
        (inout State, Action, Dependencies) -> AnyPublisher<Action, Never>?
    
    @MainActor final class Store<State, Action, Dependencies>: ObservableObject {
        @Published private(set) var state: State
    
        private let dependencies: Dependencies
        private let reducer: Reducer<State, Action, Dependencies>
    
        init(
            initialState: State,
            reducer: @escaping Reducer<State, Action, Dependencies>,
            dependencies: Dependencies
        ) {
            self.state = initialState
            self.reducer = reducer
            self.dependencies = dependencies
        }
    
        func send(_ action: Action) async {
            guard let effect = reducer(&state, action, dependencies) else {
                return
            }
    
            for await action in effect.values {
                await send(action)
            }
        }
    }
    

Here we pushed a few changes to support the new concurrency model:

  1. We made our _send_ method an async by adding the particular keyword to the method definition. 
  2. We use the _values_ property on the Combine framework’s _Publisher_ type to convert it into an _AsyncSequence_ . 
  3. We use _for await_ keyword to iterate over values of _AsyncSequence_ and apply them to the store. 
  4. We added _@MainActor_ annotation to access our state only via the main thread. 

As you can see, we made very few changes to migrate to the new concurrency
model and gain new features like task cancellation out of the box. We don’t
need to change anything else, and we still can use our old reducers with the
Combine framework because they work together very nicely.

    
    
    func appReducer(
        state: inout AppState,
        action: AppAction,
        dependencies: AppDependencies
    ) -> AnyPublisher<AppAction, Never>? {
        switch action {
        case let .setSearchResults(repos):
            state.searchResult = repos
        case let .search(query):
            return dependencies.service
                .searchPublisher(matching: query)
                .replaceError(with: [])
                .map { AppAction.setSearchResults(repos: $0) }
                .eraseToAnyPublisher()
        }
        return nil
    }
    

Let’s go forward and replace the dependencies of our reducers with async
closures. We still must return the Combine framework’s _Publisher_ type, but
we need somehow to wrap an async closure call with the Combine publisher.
Unfortunately, there is no way to do it automatically, but we can create the
_Publisher_ type that does it for us.

> To learn more about using async closures as dependencies, take a look at my
> [ “Microapps architecture in Swift. Dependency Injection”
> ](/2022/02/02/microapps-architecture-in-swift-dependency-injection/) post.
    
    
    import Foundation
    import Combine
    
    public struct SendablePublisher<Output, Failure: Error>: Publisher {
        let upstream: AnyPublisher<Output, Failure>
    
        public init(
            fullFill: @Sendable @escaping () async throws -> Output
        ) where Failure == Error {
            var task: Task<Void, Never>?
            upstream = Deferred {
                Future { promise in
                    task = Task {
                        do {
                            let result = try await fullFill()
                            try Task.checkCancellation()
                            promise(.success(result))
                        } catch {
                            promise(.failure(error))
                        }
                    }
                }
            }
            .handleEvents(receiveCancel: { task?.cancel() })
            .eraseToAnyPublisher()
        }
    
        public func receive<S>(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
            upstream.subscribe(subscriber)
        }
    }
    

Let me introduce the _SendablePublisher_ type that allows us to convert any
async closure to the Combine publisher. Please look at how we use the
_handleEvents_ operator to implement the support for the cooperative
cancellation. Now we can refactor our reducer to use async closures for side
effects.

    
    
    struct AppDependencies {
        let search: @Sendable (String) async throws -> [Repo]
    }
    
    func appReducer(
        state: inout AppState,
        action: AppAction,
        dependencies: AppDependencies
    ) -> AnyPublisher<AppAction, Never>? {
        switch action {
        case let .setSearchResults(repos):
            state.searchResult = repos
        case let .search(query):
            return SendablePublisher {
                try await dependencies.search(query)
            }
                .replaceError(with: [])
                .map(AppAction.setSearchResults)
                .eraseToAnyPublisher()
        }
        return nil
    }
    

SwiftUI provides us with the _task_ view modifier accepting an async closure.
It automatically runs the closure when the view appears and tracks its
lifecycle. SwiftUI cancels the task created for an async closure whenever the
view disappears, and if you support the cooperative cancellation model, your
task automatically stops.

    
    
    import SwiftUI
    
    typealias AppStore = Store<AppState, AppAction, AppDependencies>
    
    struct SearchView: View {
        @ObservedObject var store: AppStore
        let query: String
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(store.state.searchResult, id: \.id) { repo in
                        Text(repo.title)
                    }
                }
                .navigationTitle("Search")
                .task {
                    await store.send(.search(query))
                }
            }
        }
    }
    

This week we learned how to migrate our codebase from the Combine framework to
the new Swift concurrency model using small steps. I love the way they play
together, but I believe that the new Swift concurrency model is the future of
async tasks. I hope to eliminate the Combine framework whenever the
_AsyncSequence_ type gains all the needed transformation operators offered by
the Combine framework’s _Publisher_ type.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!

  1. [ Redux-like state container in SwiftUI. Basics ](/2019/09/18/redux-like-state-container-in-swiftui/)
  2. [ Redux-like state container in SwiftUI. Best practices ](/2019/09/25/redux-like-state-container-in-swiftui-part2/)
  3. [ Redux-like state container in SwiftUI. Container Views. ](/2019/10/02/redux-like-state-container-in-swiftui-part3/)
  4. [ Redux-like state container in SwiftUI. Connectors. ](/2021/02/03/redux-like-state-container-in-swiftui-part4/)
  5. Redux-like state container in SwiftUI. Swift concurrency model. 

####  References

The series of posts have built on a foundation of ideas started by other
libraries, particularly Redux, Elm, and TCA.

  1. [ WWDC20 - Data Essentials in SwiftUI ](https://developer.apple.com/videos/play/wwdc2020/10040/)
  2. [ Redux ](https://redux.js.org) \- The JavaScript library that popularized unidirectional data flow. 
  3. [ The Elm Architecture ](https://guide.elm-lang.org/architecture/) \- A purely functional language and runtime that inspired the creation of Redux. 
  4. [ The Composable Architecture ](https://github.com/pointfreeco/swift-composable-architecture) \- A library that bridges concepts from the Elm Architecture and Redux to Swift. It introduced the “environment” and “effect” patterns that this series covers. 



# Blur effect and materials in SwiftUI

##  Blur effect and materials in SwiftUI

28 Oct 2021

SwiftUI has the _blur_ view modifier from the very first day. It allows us to
build super custom blur effects quickly. On the other hand, SwiftUI Release 3
gives us the new _Material_ type that specifies different blur effects defined
in Human Interface Guidelines. This week we will learn how to use the _blur_
view modifier and the new _Material_ type to build translucent effects.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s start with learning how to use the _blur_ view modifier in SwiftUI. All
you need to do is to apply the view modifier to any view you want to blur.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                LinearGradient(
                    colors: [.red, .yellow],
                    startPoint: .top,
                    endPoint: .bottom
                ).ignoresSafeArea()
    
                Text("Hello")
                    .padding()
                    .background {
                        Color.black
                            .blur(radius: 8, opaque: false)
                    }
            }
        }
    }
    

![blur](/public/blur.png)

As you can see in the example above, we create a _Text view with a black
background. Next, we add the *blur_ view modifier to apply a gaussian blur
effect to the rendering of this view. The _blur_ view modifier has two
parameters that allow us to customize the produced result. The first one is
the _radius_ that defines the radial size of the blur effect. The second one
is the _bool_ value that specifies whether the renderer allows transparency.
By default, it is _false_ .

> To learn more about gradients in SwiftUI, take a look at my [ “Gradient in
> SwiftUI” ](/2019/11/13/gradient-in-swiftui/) post.

####  Materials

Apple provides us with a collection of materials. Material is ready to use
translucent blur effect. You can use it to achieve a feeling of depth.
Materials allow you to blur the background without changing the foreground
content.

SwiftUI has a set of standard materials that allow you to make your views look
magnificent in any context. These effects automatically support both the light
and dark modes. Let’s take a look at how we can use them.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                LinearGradient(
                    colors: [.red, .yellow],
                    startPoint: .top,
                    endPoint: .bottom
                ).ignoresSafeArea()
    
                Text("Hello")
                    .padding()
                    .background(
                        .regularMaterial,
                        in: RoundedRectangle(cornerRadius: 8, style: .continuous)
                    )
            }
        }
    }
    

![regular-material](/public/blur1.png)

As you can see in the example, we use the _background_ view modifier with
regular material. Material isn’t a view, but attaching material is similar to
inserting a translucent layer between the view and its background. The
blurring effect produced by the material isn’t simple transparency. It uses an
environment-defined mixing that produces a result that matches glass.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                LinearGradient(
                    colors: [.red, .yellow],
                    startPoint: .top,
                    endPoint: .bottom
                ).ignoresSafeArea()
    
                Text("Hello")
                    .padding()
                    .background(
                        .ultraThickMaterial,
                        in: RoundedRectangle(cornerRadius: 8, style: .continuous)
                    )
            }
        }
    }
    

![ultra-thick-material](/public/blur2.png)

SwiftUI has a set of materials with different thicknesses. Thicker materials
have better contrast for text and other views.

  * regular material 
  * thin material 
  * ultra-thin material 
  * thick material 
  * ultra-thick material 

Remember that a material blurs the app’s background, but not the content
behind the app on the screen. For example, the content on the Home Screen
doesn’t affect the appearance of a widget.

####  Conclusion

This week we learned how to use the blur effect and system-provided materials
defined in Human Interface Guidelines. Now you can go back and make your apps
more vibrant by using new materials available in SwiftUI Release 3. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Submitting values to SwiftUI view

##  Submitting values to SwiftUI view

21 Jul 2021

SwiftUI Release 3 brought us a new declarative approach for handling submitted
values. Text fields, forms, search bars allow users to submit values that we
can take and react to them using the new _onSubmit_ view modifier. This week
we will learn how to use the _onSubmit_ view modifier and what benefits it
provides us.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s build a view that allows us to search for messages using the
_searchable_ view modifier.

    
    
    struct SearchView: View {
        @ObservedObject var viewModel: ViewModel
        @Binding var query: String
    
        var body: some View {
            List(viewModel.messages, id: \.self) { message in
                Text(message)
            }
            .searchable(text: $query)
            .onSubmit(of: .search) {
                viewModel.search(matching: query)
            }
            .navigationTitle("Search")
        }
    }
    

As you can see in the example above, we display the list of messages from
_ViewModel_ and provide the search functionality. We also use the _onSubmit_
view modifier to provide a closure that SwiftUI runs whenever the user submits
the value. As soon as the user hits the return key on the software or hardware
keyboard, SwiftUI calls the provided closure.

> To learn more about using the search view modifier, take a look at my [
> “Mastering search in SwiftUI” ](/2021/06/23/mastering-search-in-swiftui/)
> post.

We use the _onSubmit_ view modifier with a search submit trigger. It means
SwiftUI runs the given closure only as a result of search action. SwiftUI
provides us a set of different submit triggers like _search, text, form,_ and
its count can increase in the future releases of SwiftUI.

Other views which we can use in conjunction with the _onSubmit_ view modifier
are _TextField_ and _SecureField_ . We can attach the _onSubmit_ view modifier
directly to the text field. In this case, we have to use the text submit
trigger.

    
    
    struct ContentView: View {
        @State private var query = ""
    
        var body: some View {
            NavigationView {
                TextField("query", text: $query)
                    .onSubmit(of: .text) {
                        print(query)
                    }
            }
        }
    }
    

Keep in mind that we can attach multiple _onSubmit_ view modifiers with
various submit triggers to the view hierarchy and provide different closures
for separate triggers.

We can also change the label of the return key on the software keyboard using
the _submitLabel_ view modifier. _submitLabel_ view modifier requires the
instance of _SubmitLabel_ struct as the parameter which defined the return key
label. It has many predefined values like _done, go, send, join, route,
search, return, next and continue._

    
    
    struct ContentView: View {
        @State private var query = ""
    
        var body: some View {
            NavigationView {
                TextField("query", text: $query)
                    .submitLabel(.send)
                    .onSubmit(of: .text) {
                        print(query)
                    }
            }
        }
    }
    

####  Scopes

I should mention that you can place the _onSubmit_ view modifier not only
under text fields, but it can be anywhere in the view hierarchy. That’s why
SwiftUI provides us an opportunity to control submit scopes. For example, you
can disable a part of the view hierarchy to react on submitting values.

    
    
    struct ContentView: View {
        @StateObject private var viewModel = ViewModel()
    
        var body: some View {
            NavigationView {
                VStack {
                    TextField("phone", text: $viewModel.phone)
                        .submitScope(viewModel.phone.count > 11)
    
                    VStack {
                        TextField("email", text: $viewModel.email)
                        TextField("password", text: $viewModel.password)
                    }
                }
                .onSubmit(of: .text) {
                    viewModel.signUp()
                }
            }
        }
    }
    

The _submitScope_ view modifier allows you to avoid specific views from
invoking a submission action. In our example, the phone text field will not
initiate a submission while the provided condition is false.

####  Conclusion

This week, we learned about the new _onSubmit_ view modifier that provides us
with a generic way to handle the value submission for different views. I hope
you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Phantom types in Swift

##  Phantom types in Swift

18 Feb 2021

Not every language with a static type system has so strong type-safety like
Swift. Swift features like phantom types, generic type extensions, enums with
associated types create an excellent foundation. This week we will learn how
to use phantom types to build type-safe APIs.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

A phantom type is a generic type that is declared but never used inside a type
where it is declared. It is usually used as a generic constraint to build a
more type-safe and robust API. Let’s take a look at the quick example.

    
    
    struct Identifier<Holder> {
        let value: Int
    }
    

In the example above, we have the _Identifier_ struct with a generic _Holder_
type declared. As you can see, we don’t use the _Holder_ type inside the
_Identifier_ type. That’s why it is called phantom type. Now let’s think about
the benefits of using phantom types like this.

    
    
    struct User {
        let id: Identifier<Self>
    }
    
    struct Product {
        let id: Identifier<Self>
    }
    
    let product = Product(id: .init(value: 1))
    let user = User(id: .init(value: 1))
    
    user.id == product.id
    

We create _User_ and _Product_ types and use the previously created
_Identifier_ struct. We set the value of the identifier to 1 for the newly
created user and product. But when we try to compare them, the Swift compiler
fails with the error:

> Binary operator ‘==’ cannot be applied to operands of type ‘ _Identifier-
> User_ ’ and ‘ _Identifier-Product_ ’.

And that’s great because there is no reason to compare user and product
identifiers. We can do it only accidentally. The Swift compiler doesn’t allow
us to mix the identifiers between users and products because of phantom type
and recognize them as entirely different types. Here is another example where
the Swift compiler doesn’t allow us to mix identifiers.

    
    
    func fetch(_ product: Identifier<Product>) -> Product? {
        // return product by id
    }
    
    fetch(user.id)
    

> To learn more about the benefits of using phantom types, look at my [
> “Building type-safe networking in Swift” ](/2021/02/10/building-type-safe-
> networking-in-swift/) post.

####  Type safety in HealthKit

We learned the basics of phantom types. Now we can move to more advanced
examples. I built a couple of health-oriented apps that use HealthKit to store
and query health data from the Apple Watch. Let’s look at the typical code
that I use to fetch data from the Apple Health app.

    
    
    import HealthKit
    
    let store = HKHealthStore()
    let bodyMass = HKQuantityType.quantityType(
        forIdentifier: HKQuantityTypeIdentifier.bodyMass
    )!
    let query = HKStatisticsQuery(
        quantityType: bodyMass,
        quantitySamplePredicate: nil,
        options: .discreteAverage
    ) { _, statistics, _ in
        let average = statistics?.averageQuantity()
        let mass = average?.doubleValue(for: .meter())
    }
    
    store.execute(query)
    

In the example above, we create a query to fetch user’s weight from the Apple
Health app. In the completion handler, we try to get the average and convert
it to meters. As you can guess, it is impossible to convert body mass to
meters, and the app will crash here. We will try to solve the issue by
introducing phantom type to build more type-safe API.

    
    
    enum Distance {
        case mile
        case meter
    }
    
    enum Mass {
        case pound
        case gram
        case ounce
    }
    
    struct Statistics<Unit> {
        let value: Double
    }
    
    
    extension Statistics where Unit == Mass {
        func convert(to unit: Mass) -> Double {
    
        }
    }
    
    extension Statistics where Unit == Distance {
        func convert(to unit: Distance) -> Double {
    
        }
    }
    
    let weight = Statistics<Mass>(value: 75)
    weight.convert(to: Distance.meter)
    

Here is a possible solution for the HealthKit framework that uses phantom type
to improve API safety. We introduce _Mass_ and _Distance_ enums to have
distinct units. And as soon you try to convert mass into the distance, the
Swift compiler stops you with a great error message:

> Cannot convert the value of type ‘ _Distance_ ’ to expected argument type ‘
> _Mass_ ’

####  Conclusion

Today we learned phantom types, one of my favorite features of the Swift
language. It looks like there are a lot of possible applications for phantom
types. Feel free to share with me how you make your API more type-safe by
using phantom types. I hope you enjoy the post. Follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Microapps architecture in Swift. Resources and localization.

##  Microapps architecture in Swift. Resources and localization.

26 Jan 2022

This week we will continue the topic of microapps architecture in Swift by
touching on another essential edge of this approach. In this post, we will
talk about sharing resources between modules and separating the localization
of feature modules.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Bundle API

Usually, we don’t care much about resource bundles in single module apps
because the only bundle is the app target bundle. Let’s take a quick look at
the example using Bundle API.

    
    
    Image("image")
    Image("image", bundle: nil)
    Image("image", bundle: .main)
    

These three lines do the same thing. They look for the image in the bundle of
the running target. We can try to access an image from a particular bundle.
Here is another example.

    
    
    Image("image", bundle: Bundle(identifier: "com.example.myapp"))
    

####  SPM and Resources

Swift Package Manager allows us to put code and related resources in Swift
modules. In this case, the Swift compiler generates a bundle for every module
that contains resources. Imagine our design system module containing an asset
catalog with custom icons to reuse in feature modules.

To achieve that, first, we need to create an asset catalog with icons and
place it inside the _DesignSystem_ folder. Xcode automatically recognizes the
format of the asset catalog and generates a bundle for the module. You can
access the bundle of the current module by using the **module** property on
the _Bundle_ type. But remember, Xcode generates it only for modules with
resources inside.

    
    
    // DesignSystem module
    extension UIImage {
        public enum Icon: String {
            case trash
            case star
            case plus
        }
    
        public static func get(_ icon: Icon) -> UIImage {
            .init(
                named: icon.rawValue,
                in: .module,
                compatibleWith: .current
            )!
        }
    }
    

As you can see in the example above, we create a type-safe image factory that
loads icons from the design system bundle. Please look at how we use the
_module_ property on the _Bundle_ type. This is how we can load the resources
from the bundle of the current module. If we omit the _bundle_ parameter, the
app will try to load the image from the app target module, which doesn’t
contain these images.

> To learn more about writing type-safe code in Swift, take a look at my [
> “Writing idiomatic Swift code” ](/2021/04/01/writing-idiomatic-swift-code/)
> post.

Xcode automatically generates bundles whenever finds asset catalogs, Core Data
models, Storyboards, NIBs, and localization files. For any other types of
resources, you should use _Package.swift_ file to ask the Swift compiler to
bundle them.

    
    
    // Package.swift
    let package = Package(
        ...
        targets: [
            .target(
                name: "DesignSystem",
                dependencies: [],
                resources: [
                    .copy("Resources/Fonts"),
                    .process("Resources/PNGs")
                ]
            )
        ]
    )
    

The design system module contains the _Resources_ folder with fonts and
different PNGs that I want to bundle with my module. Unfortunately, Xcode
doesn’t recognize them automatically, but we can bundle them manually via a
few lines of code in the _Package.swift_ file. There are two ways of bundling
resources in Swift modules. We can process or copy them directly in the
bundle.

When you choose processing resources, Xcode applies platform-specific rules
for compressing files, when you select copying, Xcode copies files simply by
keeping the structure of the sub-directories.

####  SPM and Localization

Swift Packages support localization out of the box. Every feature module
should contain its localization file and be ready to build and run as a
separate microapp. We can quickly achieve that by enabling localization in the
_Package.swift_ file by adding a single line of code.

    
    
    // Package.swift
    let package = Package(
        name: "MyAppLibrary",
        defaultLocalization: "en",
        platforms: [.iOS(.v15)],
        ...
    )
    

We added the _defaultLocalization_ parameter to the package declaration in the
example above. This parameter is necessary if you want to support
localization. Now you can create _en.lproj, es.lproj, or any-locale-
identifier.lproj_ folders in your module to place your _Localizable.strings_
files with particular translations. Remember that you still need to specify
the correct bundle whenever you want to access the localization of the current
module.

    
    
    // Feature module
    Text("helloMessage", bundle: .module)
    

We should learn from SwiftUI views how to leverage the power of modules while
modeling the public interfaces of our custom views. For example, the design
system module contains a generic view that I use as an empty or error view. I
will use it in various feature modules with different localizations coming
from different bundles.

    
    
    // DesignSystem module
    public struct PlaceholderView: View {
        let systemImage: String
        let text: LocalizedStringKey
        let bundle: Bundle?
    
        public init(
            _ text: LocalizedStringKey,
            bundle: Bundle? = nil,
            systemImage: String
        ) {
            self.systemImage = systemImage
            self.bundle = bundle
            self.text = text
        }
    
        public var body: some View {
            Label {
                Text(text, bundle: bundle)
                    .multilineTextAlignment(.center)
            } icon: {
                Image(systemName: systemImage)
                    .imageScale(.large)
                    .font(.largeTitle)
            }
            .labelStyle(.vertical)
            .padding(.horizontal)
            .padding(.horizontal)
        }
    }
    

As you can see in the example above, we define a public _init_ that accepts
the bundle to retrieve localization. Without this parameter, the view can
access only the main or its own bundle. But we need to access bundles of
various feature modules. That’s why we have to introduce an optional _bundle_
parameter.

    
    
    // Search feature module
    import DesignSystem
    
    struct SearchView: View {
        let results: [SearchItems]
        
        var body: some View {
            if results.isEmpty {
                PlaceholderView(
                    "emptySearchPlaceholder",
                    bundle: .module,
                    systemImage: "magnifyingglass"
                )
            } else {
            // display the list of items
            }
        }
    }
    

####  Conclusion

This week we learned how to use resources within microapps architecture. We
also learned how to encapsulate localization inside the feature modules. There
are two rules which I use to build well-separated modules.

First, I try to keep resources only inside the module that uses them. Feature
modules contain the localization strings they need. Second, create a type-safe
public API for retrieving shared resources, as we do in the design system
module, to get the icons across different feature modules.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!

####  References

  1. [ Meet the microapps architecture ](https://increment.com/mobile/microapps-architecture/)
  2. [ Introduction to App Modularisation with Swift Package Manager ](https://holyswift.app/introduction-to-app-modularisation-with-swift-package-manager-a-tale-to-be-told)



# iOS development trends in review

##  iOS development trends in review

27 Dec 2022

2022 has come to an end, and it is a perfect time for retrospective analysis.
Today I want to review trends in iOS development over the past year that I
notice while building my own apps or consulting others.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  SwiftUI

SwiftUI has a lot of criticism about its functionality compared to more mature
UIKit. During the last few years, Apple invested a lot of time into the
SwiftUI framework and improved it in a few ways. SwiftUI became a robust
framework allowing you to build great apps declaratively.

This year we finally got the new data-driven Navigation API allowing us to
move the user through the app using a value-oriented approach. The new
Navigation API is also simplifying deep linking and state restoration.

Another great addition was the _Layout_ protocol which provided us with a very
low-level API to build custom layouts. Now we can create reusable layout types
with the same API as _VStack_ and _HStack_ .

Nowadays, many system-oriented features of the apps require using the SwiftUI
framework. The SwiftUI framework is the only way to build home screen, lock
screen, live activity widgets, etc.

  * [ What is new in SwiftUI after WWDC22 ](/2022/06/07/what-is-new-in-swiftui-after-wwdc22/)
  * [ Building custom layout in SwiftUI. Basics. ](/2022/11/16/building-custom-layout-in-swiftui-basics/)
  * [ Mastering NavigationStack in SwiftUI. Navigator Pattern. ](/2022/06/15/mastering-navigationstack-in-swiftui-navigator-pattern/)
  * [ Mastering NavigationStack in SwiftUI. Deep Linking. ](/2022/06/21/mastering-navigationstack-in-swiftui-deep-linking/)
  * [ What is new in SwiftUI after WWDC 23 ](/2023/06/06/what-is-new-in-swiftui-after-wwdc23/)

####  Unidirectional flow

Unidirectional flow means that all the data in the application follows the
same pattern, making the logic of your app more predictable and easier to
understand. The unidirectional flow pattern works great in conjunction with
the idea of a single source of truth.

The single state for the whole app makes it easier to debug and inspect. The
single source of truth eliminates tons of bugs produced by creating multiple
duplicates of the same piece of state across the app.

  * [ Unidirectional flow in Swift ](/2023/07/11/unidirectional-flow-in-swift/)
  * [ Redux-like state container in SwiftUI. Basics. ](/2019/09/18/redux-like-state-container-in-swiftui/)
  * [ Functional core Imperative shell in Swift. Unidirectional Flow. ](/2022/03/16/functional-core-imperative-shell-in-swift-unidirectional-flow/)

####  Modularization

Mobile apps become bigger and bigger by providing a complete set of business
features. Teams become larger, and the number of developers working on the
product increases. This process often creates problems like increased compile
time, merge conflicts, and violates the separation of concerns in the
codebase.

Fortunately, modularization solves all of these problems. Swift Package
Manager became the heart of this approach. It allows us to extract every
feature into a separate Swift module and reduce the compile time of your
project. Teams can produce a module per app feature and run it as a separate
app to improve the value delivery.

  * [ Microapps architecture in Swift. SPM basics. ](/2022/01/12/microapps-architecture-in-swift-spm-basics/)
  * [ Microapps architecture in Swift. Feature modules. ](/2022/01/19/microapps-architecture-in-swift-feature-modules/)
  * [ Microapps architecture in Swift. Dependency Injection. ](/2022/02/02/microapps-architecture-in-swift-dependency-injection/)
  * [ Microapps architecture in Swift. Resources and localization. ](/2022/01/26/microapps-architecture-in-swift-resources-and-localization/)

####  Testing

As I said before, apps have become the primary source of income for many types
of businesses around the world. We as developers, should take care of the
stability and consistency of the apps. It is tough to achieve a good level of
crash and bug-free sessions of the app without good test coverage.

UI tests become essential for validating crucial user flows in our apps. UI
tests are very slow, and we should try to cover as much logic as we can with
unit tests and use UI tests only for important user flows like checkout or add
to cart.

Usually, UI tests require much more effort than unit tests, and keeping the
test codebase as clean as possible is vital. I saw that many developers
treated differently to testing code. But it is important to design testing
code the same way we do with the feature code. A few patterns allow us to keep
UI tests in excellent shape.

  * [ UI Testing in Swift with XCTest framework ](/2021/03/18/ui-testing-in-swift-with-xctest-framework/)
  * [ UI Testing using Page Object pattern in Swift ](/2021/03/24/ui-testing-using-page-object-pattern-in-swift/)

####  Accessibility

Last but not least is accessibility. Accessibility isn’t a feature or a “nice
to have.” It’s a necessity. First, I would like to mention that Apple has done
a great job with the Accessibility framework. Most of the things are handled
by the system without our action.

Usually, your app is accessible by default. You only need to test your app
with Voice Over and try to improve the user experience by grouping or hiding
particular elements on the screen. You can also provide some shortcuts for the
actions in your app for accessible users.

Don’t hesitate to add a few lines of code to improve your app’s user
experience significantly.

  * [ Make your app accessible for everyone ](/2018/07/09/make-your-app-accessible-for-everyone/)
  * [ Accessibility in SwiftUI ](/2019/09/10/accessibility-in-swiftui/)
  * [ Dynamic Type in SwiftUI ](/2019/10/09/dynamic-type-in-swiftui/)
  * [ Custom accessibility content in SwiftUI ](/2021/10/06/custom-accessibility-content-in-swiftui/)

####  Conclusion

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Merry Christmas and Happy New Year!



# Frames in SwiftUI

##  Frames in SwiftUI

02 Jun 2021

SwiftUI provides us a magical frame modifier that you might think is very
simple and straightforward to use. But there is a lot of complicated logic
under the hood. This week we will talk about fixed and flexible frames and the
frame modifier to control them.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Fixed frame

Let’s start with the straightforward type of frame called a fixed frame. The
fixed frame is a way to create an invisible frame around the view that will
propose the size you mention to the view. It doesn’t mean that the frame will
set the size of the view inside. The frame only suggests the size, and the
view can completely ignore it. Let’s take a look two different examples.

    
    
    PlaygroundPage.current.setLiveView(
        Text("Happy WWDC 21!")
            .foregroundColor(Color.white)
            .frame(width: 50, height: 50)
            .border(Color.red)
            .frame(width: 300, height: 300)
            .background(Color.black)
    )
    

![fixed-frame](/public/fixed-frame2.png)

As you can see in the example above, we have a _Text_ view that shrinks its
content to fit the size proposed by the frame.

    
    
    PlaygroundPage.current.setLiveView(
        Rectangle()
            .fill(Color.green)
            .frame(width: 100, height: 100)
            .frame(width: 50, height: 50)
            .border(Color.yellow)
            .frame(width: 300, height: 300)
            .background(Color.black)
    )
    

![fixed-frame](/public/fixed-frame1.png)

In the second example, we use a green rectangle with the size of 100x100. We
also add a small fixed frame around the rectangle, but in this case, the green
rectangle ignores the size proposed by the frame and draws itself outside of
the frame.

> To learn more about layout process in SwiftUI, take a look at my [ “Layout
> priorities in SwiftUI” ](/2020/04/15/layout-priorities-in-swiftui/) post.

####  Flexible frame

There is another version of the frame modifier that accepts seven parameters.

    
    
    func frame(
        minWidth: CGFloat? = nil,
        idealWidth: CGFloat? = nil,
        maxWidth: CGFloat? = nil,
        minHeight: CGFloat? = nil,
        idealHeight: CGFloat? = nil,
        maxHeight: CGFloat? = nil,
        alignment: Alignment = .center
    ) -> some View {}
    

Let’s focus on the horizontal axis because the same applies to the vertical.
We will talk about ideal width and height in the next section because it
doesn’t affect flexible frames. As you can see, there are optional parameters
for minimal and maximal width. You have three options here:

  1. You provide both minimal and maximal value. 
  2. You provide only minimal value. 
  3. You provide only maximal value. 

Let’s start with the first one when you provide both minimal and maximal
value. In this case, SwiftUI completely ignores the size of the child inside
the frame and clamps the final size of the frame between minimal and maximal
value.

    
    
    PlaygroundPage.current.setLiveView(
        Text("Happy WWDC 21!")
            .foregroundColor(Color.white)
            .border(Color.green)
            .frame(minWidth: 20, maxWidth: 50)
            .border(Color.red)
            .frame(width: 300, height: 300)
            .background(Color.black)
    )
    

![flexible-frame](/public/flexible-frame1.png)

In the second case, we have only minimal value provided, which leads to the
situation where SwiftUI checks the content size of a child view inside a frame
and makes a decision based on this value. The final size of the frame will be
the minimum value that you pass if the content size of the child view is
smaller than the value you provide. Otherwise, it will be equal to the content
size of the child view.

    
    
    PlaygroundPage.current.setLiveView(
        Text("Happy WWDC 21!")
            .foregroundColor(Color.white)
            .border(Color.green)
            .frame(minWidth: 20)
            .border(Color.red)
            .frame(width: 300, height: 300)
            .background(Color.black)
    )
    

![flexible-frame](/public/flexible-frame2.png)

In the third case, we have only maximal value provided, and it leads to the
condition where SwiftUI checks the content size of a child view inside a
frame. It sets the final size of the frame to the maximal value whenever the
content size bigger than the size you pass. Otherwise, it will be equal to the
content size of the child view.

    
    
    PlaygroundPage.current.setLiveView(
        Text("Happy WWDC 21!")
            .foregroundColor(Color.white)
            .border(Color.green)
            .frame(maxWidth: 40)
            .border(Color.red)
            .frame(width: 300, height: 300)
            .background(Color.black)
    )
    

![flexible-frame](/public/flexible-frame3.png)

####  Ideal size

Ideal width and heigh parameters allow us to provide an intrinsic size.
Intrinsic size is usually the size of the content. In the case of the _Text_
view, it is the size of the string presented in the view. In the case of a
shape like a _Rectangle_ or _Circle_ , the ideal size is undefined, and the
view tries to fill the available space. The frame modifier allows you to
provide the ideal size for the views that don’t have content. SwiftUI uses
ideal size only in conjunction with the _fixedSize_ modifier.

> To learn more about the fixedSize modifier, take a look at my [ “The magic
> of fixed size modifier in SwiftUI” ](/2020/04/29/the-magic-of-fixed-size-
> modifier-in-swiftui/) post.

####  Conclusion

The most challenging topic in SwiftUI for me was frame behavior. Fixed-size,
flexible frames, ideal size, so many options for a single frame modifier. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Navigation in SwiftUI

##  Navigation in SwiftUI

17 Jul 2019

This week I want to talk about _Navigation in SwiftUI_ . SwiftUI provides both
declarative and imperative ways of implementing navigation in your apps. Today
we will cover two ways of _Master-Detail_ navigation available in SwiftUI. We
will learn how use _NavigationLink_ , and how to do programmatic navigation in
SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

> _NavigationView_ is deprecated. Use _NavigationStack_ instead. To learn
> more, take a look at my [ “Mastering NavigationStack in SwiftUI. Navigator
> Pattern” ](/2022/06/15/mastering-navigationstack-in-swiftui-navigator-
> pattern/) post.

####  Master-Detail flow

Assume that you are working on app which shows a list of some items and you
want to move to details screen as soon as the user selects any item. For this
type of navigation, SwiftUI provides _NavigationView_ and _NavigationLink_
components. Let’s check how we can use them.

    
    
    struct MasterView: View {
        private let messages = [
            "Hello", "How are you?"
        ]
    
        var body: some View {
            NavigationView {
                List(messages, id: \.self) { message in
                    NavigationLink(destination: DetailsView(message: message)) {
                        Text(message)
                    }
                }.navigationBarTitle("Messages")
            }
        }
    }
    
    struct DetailsView: View {
        let message: String
    
        var body: some View {
            VStack {
                Text(message)
                    .font(.largeTitle)
            }
        }
    }
    

Here we have a list of messages, to make navigation possible we embed our
_List_ into a _NavigationView_ , it adds standard _NavigationBar_ on top of
our _List_ . We can also set text as a title of _NavigationBar_ by adding
_navigationBarTitle_ modifier to a _List_ . Please make sure that you add the
_navigationBarTitle_ modifier to a _List_ component, and not to a
_NavigationView_ because multiple views can share same _NavigationView_ and
every view can have a different title.

**Hidden gem: You can embed two views into NavigationView to achieve Split on
iPadOS and MacOS**

Next, we embed List rows into _NavigationLink_ , while creating
_NavigationLink_ , we have to provide a destination view. SwiftUI presents a
destination view when the user presses the _List row_ . By wrapping _List row_
into a _NavigationLink_ , SwiftUI adds trailing arrow to the view which
indicates that there is a details screen next to the view. And this is where
the real power of declarative programming comes. _List row_ starts appearing
in another way only by embedding it into _NavigationLink_ . To learn more
about environment-based appearance in SwiftUI, you can check out [ “Building
forms with SwiftUI” post ](/2019/06/19/building-forms-with-swiftui/) .

####  Programmatic navigation

Sometimes we need to check multiple conditions and after that push some view.
For this kind of situations, _NavigationLink_ provides a different way of
initialization, which binds it to some value, and as soon as you set the
tagged value to the binding, it pushes the view. Let’s take a look at the code
sample.

    
    
    import SwiftUI
    
    struct Master: View {
        @State var selection: Int? = nil
        
        var body: some View {
            NavigationView {
                VStack {
                    NavigationLink(destination: Details(), tag: 1, selection: $selection) {
                        Button("Press me") {
                            self.selection = 1
                        }
                    }
                }
            }
        }
    }
    
    struct Details: View {
        @Environment(\.presentationMode) var presentation
    
        var body: some View {
            Group {
                Text("Details")
                Button("pop back") {
                    self.presentation.wrappedValue.dismiss()
                }
            }
        }
    }
    

As you can see in the example above, we create _NavigationLink_ by passing
destination view and two additional parameters _Hashable_ tag and binding to
the _Hashable_ . As soon as the value of binding is equal to tag,
_NavigationView_ pushes _NavigationLink_ . You can programmatically pop back
by using _dismiss_ method on _EnvironmentValue_ called _presentationMode_ .

####  Conclusion

As you can see, SwiftUI provides both imperative and declarative ways of
pushing views into navigation stack by using _NavigationLink_ . Feel free to
use a way of navigation which fits best to your app requirements. Follow me on
[ Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading and see you next week!



# New property wrappers in SwiftUI

##  New property wrappers in SwiftUI

29 Jun 2020

WWDC20 brought a lot of new features into SwiftUI that I will discuss on my
blog during the next weeks. Today I would like to start with the main
additions to SwiftUI data flow with the brand new @ _StateObject_ , @
_AppStorage_ , @ _SceneStorage_ , and @ _ScaledMetric_ property wrappers.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  StateObject

As you remember, SwiftUI provides us the @ _ObservedObject_ property wrapper
that allows us to observe the changes in the data model that lives outside of
the SwiftUI framework. For example, it might be the data that you fetch from
web service or the local database. The main concern about @ _ObservedObject_
was the lifecycle. You have to store it somewhere outside of SwiftUI to save
it during view updates, for example, in _SceneDelegate_ or _AppDelegate_ . In
other cases, you can lose the data backed by @ _ObservedObject_ in certain
circumstances.

> If you are not familiar with the legacy property wrappers that SwiftUI
> provides, I suggest to start with my [ “Understanding Property Wrappers in
> SwiftUI” ](/2019/06/12/understanding-property-wrappers-in-swiftui/) post.

Here is the brand new _StateObject_ property wrapper that fills the most
significant gap in SwiftUI data flow management. SwiftUI creates only one
instance of the _StateObject_ for each container instance that you declare and
holds it in the internal framework memory that saves it during view updates.
_StateObject_ works in a very similar way to _State_ property wrapper, but
instead of value types, it is designed to work with reference types.

    
    
    struct CalendarContainerView: View {
        @StateObject var viewModel = ViewModel()
    
        var body: some View {
            CalendarView(viewModel.dates)
                .onAppear(perform: viewModel.fetch)
        }
    }
    

####  AppStorage

_AppStorage_ is another new property wrapper that we have this year. It is a
perfect way to store a small amount of key-value data backed by _UserDefaults_
. _AppStorage_ is _DynamicProperty_ , which means SwiftUI will update your
views as soon as the value of a particular key in _UserDefaults_ will update.
_AppStorage_ perfectly fits to store app settings. Let’s take a look at how we
can use it.

    
    
    enum Settings {
        static let notifications = "notifications"
        static let sleepGoal = "sleepGoal"
    }
    
    struct SettingsView: View {
        @AppStorage(Settings.notifications) var notifications: Bool = false
        @AppStorage(Settings.sleepGoal) var sleepGoal: Double = 8.0
    
        var body: some View {
            Form {
                Section {
                    Toggle("Notifications", isOn: $notifications)
                }
    
                Section {
                    Stepper(value: $sleepGoal, in: 6...12) {
                        Text("Sleep goal is \(sleepGoal, specifier: "%.f") hr")
                    }
                }
            }
        }
    }
    

In the example above, we build a settings screen using the _AppStorage_
property wrapper and _Form_ view. Now we can access our settings anywhere
across the app using _AppStorage_ , and as soon as we change the values,
SwiftUI will update the views.

    
    
    struct ContentView: View {
        @AppStorage(Settings.sleepGoal) var sleepGoal = 8
        @StateObject var store = SleepStore()
    
        var body: some View {
            WeeklySleepChart(store.sleeps, goal: sleepGoal)
                .onAppear(perform: store.fetch)
        }
    }
    

####  SceneStorage

This year we got all the abilities to control scenes in SwiftUI without UIKit.
As a result, we have a new _SceneStorage_ property wrapper that allows us to
implement proper state restoration for our scenes. _SceneStorage_ works
similarly to _AppStorage_ , but instead of _UserDefaults_ , it uses per-scene
storage. It means every scene has its private storage that can’t be accessed
by other scenes. The system entirely responsible for managing per-scene
storage, and you don’t have access to the data without _SceneStorage_ property
wrapper.

    
    
    struct ContentView: View {
        @SceneStorage("selectedTab") var selection = 0
    
        var body: some View {
            TabView(selection: $selection) {
                Text("Tab 1").tag(0)
                Text("Tab 2").tag(1)
            }
        }
    }
    

I recommend using _SceneStorage_ to store scene-specific data like tab
selection or selected book index in a reader app. Nowadays, iOS is very
aggressive in terms of killing apps in the background, and state restoration
is the key solution to provide a great user experience.

####  ScaledMetric

Another brand new property wrapper that we have is _ScaledMetric_ .
_ScaledMetric_ allows us to scale any binary floating value relative to the
Dynamic Type size category. For example, it is so easy to change the spacing
in your app according to the Dynamic Type size category. Let’s take a look at
the small example.

    
    
    struct ContentView: View {
        @ScaledMetric(relativeTo: .body) var spacing: CGFloat = 8
    
        var body: some View {
            VStack(spacing: spacing) {
                ForEach(0...10, id: \.self) { number in
                    Text(String(number))
                }
            }
        }
    }
    

As soon as user changes the Dynamic Type settings, SwiftUI scales the value of
spacing and update the view.

####  Conclusion

Today we learned about new property wrappers in SwiftUI. I believe there are
enough data flow property wrappers that can cover any logic we need while
implementing our apps. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and have a nice week!



# Mastering NavigationSplitView in SwiftUI

##  Mastering NavigationSplitView in SwiftUI

18 Oct 2022

My final post in the new navigation APIs series in SwiftUI is about building
two-three column apps. I have been waiting for all the betas to solve the
critical issues with the brand-new _NavigationSplitView_ , and it looks like
it is almost ready to use. This week we will learn how to use and customize
_NavigationSplitView_ to build multi-column apps in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

The new iteration of the SwiftUI framework provides a brand new
_NavigationSplitView_ type, allowing us to build multi-column apps in SwiftUI
quickly. The usage of the new type is straightforward.

    
    
    // For two-column navigation
    struct RootView: View {
        var body: some View {
            NavigationSplitView {
                // sidebar
            } detail: {
                // item details
            }
        }
    }
    
    // For three-column navigation
    struct RootView: View {
        var body: some View {
            NavigationSplitView {
                // sidebar
            } content: {
                // content list
            } detail: {
                // item details
            }
        }
    }
    

Usually, we should place the _NavigationSplitView_ at the root of our scene.
Two different options allow us to display two or three-column navigation.
_NavigationSplitView_ automatically wraps root views inside the sidebar,
content, and detail columns into the _NavigationStack_ view. You don’t need to
do it manually unless you need further navigation outside the content pane.

    
    
    struct ContentView: View {
        @State private var selectedFolder: String?
        @State private var selectedItem: String?
        
        @State private var folders = [
            "All": [
                "Item1",
                "Item2"
            ],
            "Favorites": [
                "Item2"
            ]
        ]
        
        var body: some View {
            NavigationSplitView {
                List(selection: $selectedFolder) {
                    ForEach(Array(folders.keys.sorted()), id: \.self) { folder in
                        NavigationLink(value: folder) {
                            Text(verbatim: folder)
                        }
                    }
                }
                .navigationTitle("Sidebar")
            } content: {
                if let selectedFolder {
                    List(selection: $selectedItem) {
                        ForEach(folders[selectedFolder, default: []], id: \.self) { item in
                            NavigationLink(value: item) {
                                Text(verbatim: item)
                            }
                        }
                    }
                    .navigationTitle(selectedFolder)
                } else {
                    Text("Choose a folder from the sidebar")
                }
            } detail: {
                if let selectedItem {
                    NavigationLink(value: selectedItem) {
                        Text(verbatim: selectedItem)
                            .navigationTitle(selectedItem)
                    }
                } else {
                    Text("Choose an item from the content")
                }
            }
        }
    }
    

As you can see in the example above, we display the hierarchy of folders and
items using the three-column navigation. We use value-based navigation links
in conjunction with selection-based lists. SwiftUI automatically assigns the
list selection to the value of a navigation link whenever the user presses it.

> To learn about the basics of the new data-driven Navigation API in SwiftUI,
> look at my [ “Mastering NavigationStack in SwiftUI. Navigator Pattern.”
> ](/2022/06/15/mastering-navigationstack-in-swiftui-navigator-pattern/) post.

All the navigation links inside selection-based lists work unless you have a
navigation link outside of the list, as we have in the content column. In this
case, we should wrap the content view with the _NavigationStack_ to provide
additional destination points.

    
    
    struct ContentView: View {
        @State private var selectedFolder: String?
        @State private var selectedItem: String?
        
        @State private var folders = [
            "All": [
                "Item1",
                "Item2"
            ],
            "Favorites": [
                "Item2"
            ]
        ]
        
        var body: some View {
            NavigationSplitView {
                List(selection: $selectedFolder) {
                    ForEach(Array(folders.keys.sorted()), id: \.self) { folder in
                        NavigationLink(value: folder) {
                            Text(verbatim: folder)
                        }
                    }
                }
                .navigationTitle("Sidebar")
            } content: {
                if let selectedFolder {
                    List(selection: $selectedItem) {
                        ForEach(folders[selectedFolder, default: []], id: \.self) { item in
                            NavigationLink(value: item) {
                                Text(verbatim: item)
                            }
                        }
                    }
                    .navigationTitle(selectedFolder)
                } else {
                    Text("Choose a folder from the sidebar")
                }
            } detail: {
                NavigationStack {
                    ZStack {
                        if let selectedItem {
                            NavigationLink(value: selectedItem) {
                                Text(verbatim: selectedItem)
                                    .navigationTitle(selectedItem)
                            }
                        } else {
                            Text("Choose an item from the content")
                        }
                    }
                    .navigationDestination(for: String.self) { text in
                        Text(verbatim: text)
                    }
                }
            }
        }
    }
    

####  Adaptive navigation

Selection-based list is not the only way to navigate through columns of the
split view. You can provide destination points by using the
_navigationDestination_ view modifier. In this case, SwiftUI will navigate to
the particular view in the column coming next to the one with the
_navigationDestination_ view modifier. But make sure, you don’t embed the view
with _navigationDestination_ view modifier into the _NavigationStack_ ,
because in this case it will push the view to the current _NavigationStack_ .

    
    
    NavigationSplitView {
        List {
            NavigationLink {
                InsightsFeatureView()
            } label: {
                Label("insights", systemImage: "chart.xyaxis.line")
            }   
            
            NavigationLink {
                SettingsFeatureView()
            } label: {
                Label("settings", systemImage: "gear")
            }
        }
    } content: {
        ContentUnavailableView("Use sidebar navigation", systemImage: "sidebar.left")
    } detail: {
        ContentUnavailableView("Use sidebar navigation", systemImage: "sidebar.left")
    }
    

####  Styling

_NavigationSplitView_ allows us to control the visibility of columns by
providing a binding for the _NavigationSplitViewVisibility_ type. You can
change it programmatically also. Here is an example of changing column
visibility programmatically.

    
    
    struct ContentView: View {
        @State private var visibility: NavigationSplitViewVisibility = .all
        @State private var selectedFolder: String?
        @State private var selectedItem: String?
        
        @State private var folders = [
            "All": [
                "Item1",
                "Item2"
            ],
            "Favorites": [
                "Item2"
            ]
        ]
        
        var body: some View {
            NavigationSplitView(columnVisibility: $visibility) {
                List(selection: $selectedFolder) {
                    ForEach(Array(folders.keys.sorted()), id: \.self) { folder in
                        NavigationLink(value: folder) {
                            Text(verbatim: folder)
                        }
                    }
                }
                .navigationTitle("Sidebar")
            } content: {
                if let selectedFolder {
                    List(selection: $selectedItem) {
                        ForEach(folders[selectedFolder, default: []], id: \.self) { item in
                            NavigationLink(value: item) {
                                Text(verbatim: item)
                            }
                        }
                    }
                    .navigationTitle(selectedFolder)
                } else {
                    Text("Choose a folder from the sidebar")
                }
            } detail: {
                NavigationStack {
                    ZStack {
                        if let selectedItem {
                            NavigationLink(value: selectedItem) {
                                Text(verbatim: selectedItem)
                                    .navigationTitle(selectedItem)
                                    .toolbar {
                                        Button("Focus") {
                                            visibility = .detailOnly
                                        }
                                    }
                            }
                        } else {
                            Text("Choose an item from the content")
                        }
                    }
                    .navigationDestination(for: String.self) { text in
                        Text(verbatim: text)
                    }
                }
            }
        }
    }
    

The _NavigationSplitViewVisibility_ type provides a few options: _automatic,
all, doubleColumn, detailOnly_ .

  * _automatic_ \- Chooses the one from _all, doubleColumn, and detailOnly_ depending on the device environment. 
  * _all_ \- Shows all the columns 
  * _doubleColumn_ \- Shows two trailing columns 
  * _detailOnly_ \- Shows only the details column by hiding the sidebar and content columns. 

Another customization point of the _NavigationSplitView_ is its style. You can
set the style of the _NavigationSplitView_ by using the
_navigationSplitViewStyle_ view modifier. It accepts a few options:
_automatic, balanced, and prominentDetail_ .

  * _automatic_ \- Chooses the style depending on the device environment. 
  * _balanced_ \- Tries to show the first two columns by reducing the detail column size. 
  * _prominentDetail_ \- Focuses on presenting the detail column. 

    
    
    struct RootView: View {
        var body: some View {
            NavigationSplitView {
                // sidebar
            } content: {
                // content list
            } detail: {
                // item details
            }
            .navigationSplitViewStyle(.balanced)
        }
    }
    

The last thing you can customize is the width of the particular column in the
_NavigationSplitView_ by using the _navigationSplitViewColumnWidth_ view
modifier on the root view inside the column.

    
    
    struct RootView: View {
        var body: some View {
            NavigationSplitView {
                // sidebar
            } content: {
                ZStack {
                
                }
                .navigationSplitViewColumnWidth(300)
            } detail: {
                // item details
            }
            .navigationSplitViewStyle(.balanced)
        }
    }
    

####  Conclusion

Today we learned how to build two or three-column navigation in SwiftUI using
the brand-new _NavigationSplitView_ . I think it is much easier than before or
at least works better now. I hope you enjoy the post. Feel free to follow me
on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Managing scenes in SwiftUI

##  Managing scenes in SwiftUI

26 Aug 2020

This week we will continue the series of posts about the app and scene
lifecycle in SwiftUI. Today we will concentrate on scene management and the
features that the new _Scene_ protocol provides us to replace the old
_SceneDelegate_ .

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

The scene is a part of an app’s user interface with a lifecycle managed by the
system. The system will decide how to present it to a user depending on the
running platform. For example, it might be a full-screen window on iOS and
watchOS, or it can use the part of the screen to render user interface on
macOS and iPadOS. Let’s start with a small example.

    
    
    @main
    struct MyApp: App {
        var body: some Scene {
            WindowGroup {
                Text("Hello World!")
            }
        }
    }
    

As you can see in the example above, we use the new app lifecycle API to build
our app. The only requirement of _App_ protocol is the body property that
should return the instance of _Scene_ protocol.

> If you are not familiar with the new App lifecycle API in SwiftUI, I highly
> recommend you to take a look at my [ “Managing app in SwiftUI”
> ](/2020/08/19/managing-app-in-swiftui/) post.

Here we use _WindowGroup_ . It is one of the primitive scene types that
SwiftUI gives us out of the box. _WindowGroup_ is a scene that presents a
group of identically structured windows. It allows the user to create as many
windows with the same user interface as needed and provide functionality for
grouping them into tabs on macOS. On iOS and watchOS, _WindowGroup_ consumes
the entire screen to render its content.

_WindowGroup_ is the scene type that you will mostly use. But there are other
scene types like _DocumentGroup_ and _Settings_ that you can use to build
document-based apps or to provide settings window on macOS.

> To learn more about other types of scenes in SwiftUI, take a look at my [
> “What’s new in SwiftUI” ](/2020/06/23/what-is-new-in-swiftui/) post.

####  Scene phase

There are several scene callbacks like _sceneDidBecomeActive_ and
_sceneWillEnterForeground_ that we used to handle in _SceneDelegate_ . SwiftUI
gives us a new solution to achieve the same result in a new way. Scenes
provide us the _onChange_ modifier and scene phase environment value that we
can use to handle scene state changes. Let’s take a look at the example.

    
    
    import SwiftUI
    
    @main
    struct CardioBotApp: App {
        @Environment(\.scenePhase) var scenePhase
        @StateObject var store = Store(
            initialState: AppState(),
            reducer: appReducer,
            environment: .live
        )
    
        var body: some Scene {
            WindowGroup {
                RootView().environmentObject(store)
            }
            .onChange(of: scenePhase) { phase in    
                switch phase {
                case .background:
                    store.send(.notifications(.startObservers))
                case .active:
                    store.send(.fetch)
                default: break
                }
            }
        }
    }
    

SwiftUI will run the closure that you pass to _onChange_ modifier whenever the
value of scene phase changes.

####  Custom scenes

Composition is my favorite thing about SwiftUI. You can create many small
views and compose them together into a complex picture. The same rule applies
to scenes. You can create your custom scene that uses primitive scenes
provided by SwiftUI.

I work on the app that supports both watchOS and iOS. It shares the codebase
between two platforms, but it has different feature sets on iOS and watchOS.
Let’s start with iOS.

    
    
    struct MainScene: Scene {
        @Environment(\.scenePhase) var scenePhase
        @ObservedObject var store: Store<AppState, AppAction>
    
        var body: some Scene {
            WindowGroup {
                RootView().environmentObject(store)
            }.onChange(of: scenePhase) { scenePhase in
                switch scenePhase {
                case .active:
                    store.send(.fetch)
                case .background:
                    store.send(.startObservers)
                default:
                    break
                }
            }
        }
    }
    

We create a custom scene type that conforms to _Scene_ protocol. The only
requirement is the body property that should also return an instance of scene
protocol. My app is derived by a global store that I ask to fetch data when
the scene becomes active. I even start observers when the scene enters the
background.

On the other hand, my watchOS app doesn’t have background observers. It also
provides an additional scenes for handling dynamic notifications in SwiftUI.
That’s why I decided to create another scene for the watchOS app.

    
    
    struct WatchAppScene: Scene {
        @Environment(\.scenePhase) var scenePhase
        @ObservedObject var store: Store<AppState, AppAction>
    
        var body: some Scene {
            WindowGroup {
                RootView().environmentObject(store)
            }.onChange(of: scenePhase) { scenePhase in
                if scenePhase == .active {
                    store.send(.fetch)
                }
            }
    
            WKNotificationScene(controller: DailyReportController.self, category: "dailyReport")
            WKNotificationScene(controller: WorkoutController.self, category: "workoutReport")
        }
    }
    

As you can see, my watchOS app is slightly different. Now let’s take a look at
how we can compose our custom scene types in one app.

    
    
    @main
    struct CardioApp: App {
        @StateObject var store = Store(
            initialState: AppState(),
            reducer: appReducer,
            environment: AppEnvironment(
                healthService: HealthService(store: .init())
            )
        )
    
        var body: some Scene {
            #if os(watchOS)
            WatchAppScene(store: store)
            #else
            MainScene(store: store)
            #endif
        }
    }
    

####  Conclusion

Today we learned another new SwiftUI API that allows us to handle scenes in a
composable way. We understood how to use scenes API to build custom scenes for
different platforms. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
article. Thanks for reading, and see you next week!



# Mastering grid layout in SwiftUI

##  Mastering grid layout in SwiftUI

10 Aug 2022

You might be familiar with the _LazyVGrid_ and _LazyHGrid_ views we have from
the second iteration of the SwiftUI framework. They work great for the massive
data arrays you want to display as the grid. But it is not always possible to
arrange the columns and rows strictly because of their lazy nature.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

For these cases, SwiftUI introduces another type of grid that immediately lays
out all of its children. This week we will learn how to use the new grid
layout in SwiftUI and the benefits of the new grid over the lazy version of
the grid component. Let’s start with a basic grid layout presenting a list of
user data.

    
    
    struct ContentView: View {
        @State private var users = mockUsers
        
        var body: some View {
            Grid(alignment: .leading, horizontalSpacing: 10, verticalSpacing: 10) {
                ForEach(users) { user in
                    GridRow(alignment: .firstTextBaseline) {
                        Text(user.name)
                        Text(user.familyName)
                        Text(user.age.formatted())
                    }
                }
            }
        }
    }
    

![new-grid](/public/egrid.png)

Here we define a grid layout with leading alignment and particular vertical
and horizontal spacing. SwiftUI renders every view inside a row as a column
and uses the alignment we pass to align the view inside the available space of
the cell.

> To learn more about lazy grids, take a look at my [ “Mastering grids in
> SwiftUI” ](/2020/07/08/mastering-grids-in-swiftui/) post.

SwiftUI uses spacing parameters to preserve the space between cells. Because
of the eager nature of the _Grid_ layout, it measures the sizes of all
children and lays them into strict columns and rows. As you can see in the
example, we also can tune the alignment inside the particular grid row. Now
let’s try to add the separator after every grid row.

    
    
    struct ContentView: View {
        @State private var users = mockUsers
        
        var body: some View {
            Grid(alignment: .leading, horizontalSpacing: 10, verticalSpacing: 10) {
                ForEach(users) { user in
                    GridRow(alignment: .firstTextBaseline) {
                        Text(user.name)
                        Text(user.familyName)
                        Text(user.age.formatted())
                    }
    
                    GridRow {
                        Rectangle()
                            .fill(.secondary)
                            .frame(height: 1)
                    }
                }
            }
        }
    }
    

![new-grid](/public/egrid1.png)

As I said, the grid layout immediately measures all the children and draws
strict columns. It understands that there is three column layout and renders
our separator in the first and only column. We can expand our divider to fill
all three columns using the _gridCellColumns_ view modifier on the view
representing the cell.

    
    
    struct ContentView: View {
        @State private var users = mockUsers
        
        var body: some View {
            Grid(alignment: .leading, horizontalSpacing: 10, verticalSpacing: 10) {
                ForEach(users) { user in
                    GridRow(alignment: .firstTextBaseline) {
                        Text(user.name)
                        Text(user.familyName)
                        Text(user.age.formatted())
                    }
    
                    GridRow {
                        Rectangle()
                            .fill(.secondary)
                            .frame(height: 1)
                            .gridCellColumns(3)
                    }
                }
            }
        }
    }
    

![new-grid](/public/egrid2.png)

Another solution is to put the separator outside the _GridRow_ view. All the
views placed directly inside the grid without the _GridRow_ view fill the
available space.

    
    
    struct ContentView: View {
        @State private var users = mockUsers
        
        var body: some View {
            Grid(alignment: .leading, horizontalSpacing: 10, verticalSpacing: 10) {
                ForEach(users) { user in
                    GridRow(alignment: .firstTextBaseline) {
                        Text(user.name)
                        Text(user.familyName)
                        Text(user.age.formatted())
                    }
    
                    Rectangle()
                        .fill(.secondary)
                        .frame(height: 1)
                }
            }
        }
    }
    

We set the grid cell alignment for all cells while defining a grid layout, but
we can set a particular alignment only for the cell we need using the
_gridColumnAlignment_ view modifier.

    
    
    struct ContentView: View {
        @State private var users = mockUsers
        
        var body: some View {
            Grid(alignment: .leading, horizontalSpacing: 10, verticalSpacing: 10) {
                ForEach(users) { user in
                    GridRow(alignment: .firstTextBaseline) {
                        Text(user.name)
                        Text(user.familyName)
                        Text(user.age.formatted())
                            .gridColumnAlignment(.trailing)
                    }
                }
            }
        }
    }
    

![new-grid](/public/egrid3.png)

SwiftUI allows us to set not only the alignment of the particular cell but
also its anchor point. For example, we might want to shift the cell content to
25% of the horizontally available space. In this case, we can use the
_gridCellAnchor_ view modifier.

    
    
    struct ContentView: View {
        @State private var users = mockUsers
        
        var body: some View {
            Grid(alignment: .leading, horizontalSpacing: 10, verticalSpacing: 10) {
                ForEach(users) { user in
                    GridRow(alignment: .firstTextBaseline) {
                        Text(user.name)
                        Text(user.familyName)
                        Text(user.age.formatted())
                            .gridCellAnchor(.init(x: 0.25, y: 0.0))
                    }
                }
            }
        }
    }
    

As you can see in the previous examples, flexible views like shapes and
dividers take the whole available space while placed inside the grid directly.
We can prevent this behavior by using the _gridCellUnsizedAxes_ view modifier.

    
    
    struct ContentView: View {
        @State private var users = mockUsers
        
        var body: some View {
            Grid(alignment: .leading, horizontalSpacing: 10, verticalSpacing: 10) {
                ForEach(users) { user in
                    GridRow(alignment: .firstTextBaseline) {
                        Text(user.name)
                        Text(user.familyName)
                        Text(user.age.formatted())
                    }
    
                    GridRow {
                        Rectangle()
                            .fill(.secondary)
                            .frame(height: 1)
                            .gridCellColumns(3)
                            .gridCellUnsizedAxes([.horizontal])
                    }
                }
            }
        }
    }
    

![new-grid](/public/egrid4.png)

In this case, we ask our separator view to take place by respecting the width
of other rows and don’t fill all the available width.

Today we learned how to use the new grid layout in SwiftUI. Try to use it by
default whenever you need a grid and switch to the lazy version of the grid
component whenever performance issues appear. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Building BarChart with Shape API in SwiftUI

##  Building BarChart with Shape API in SwiftUI

14 Aug 2019

This week I want to show you how to use _Shape_ API in SwiftUI. We will take a
look at ready to use shapes like _Circle, Capsule, Rectangle_ , etc. We will
learn how to draw super custom shapes by using _Path_ and _GeometryReader_ .
In the end, we will build _BarChart_ implementation ultimately in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Shape protocol

SwiftUI provides _Shape_ protocol which has a single requirement _path_
function. We use _path_ function to describe our shape inside a provided
rectangle. Let’s try to use it to draw a progress ring.

    
    
    struct ProgressShape: Shape {
        let progress: Double
    
        func path(in rect: CGRect) -> Path {
            var path = Path()
            path.addArc(
                center: CGPoint(x: rect.midX, y: rect.midY),
                radius: rect.width / 2,
                startAngle: .radians(1.5 * .pi),
                endAngle: .init(radians: 2 * Double.pi * progress + 1.5 * Double.pi),
                clockwise: false
            )
            return path
        }
    }
    

Here we use a little math to calculate _arc_ which describes our progress.
_Shape_ protocol conforms to _View_ protocol that’s why we can easily use it
inside _Stack_ or _Group_ . We can also customize default drawing by setting
custom _StrokeStyle_ .

    
    
    struct ProgressView: View {
        let progress: Double
    
        var body: some View {
            ProgressShape(progress: progress)
                .stroke(Color.blue,
                        style: StrokeStyle(
                            lineWidth: 4,
                            lineCap: .round,
                            lineJoin: .round,
                            miterLimit: 0,
                            dash: [],
                            dashPhase: 0
                        )
            )
        }
    }
    

####  Ready to use shapes

We discussed how to draw custom shapes, but most of the time, it is enough to
apply ready to use shapes provided by SwiftUI. SwiftUI offers shapes like
_Circle, Capsule, Rectangle_ , etc. We can easily use them to build _BarChart_
in SwiftUI. Let’s start by describing the Bar data model.

    
    
    struct Legend: Hashable {
        let color: Color
        let label: String
    }
    
    struct Bar: Identifiable {
        let id: UUID
        let value: Double
        let label: String
        let legend: Legend
    }
    

As you can see, our _Bar_ struct conforms to _Identifiable_ protocol. We need
_Identifiable_ conformance to use _Bar_ struct inside _ForEach_ . _ForEach_
uses _Identifiable_ to understand data changes during the rendering process.
Now we can draw our bars by using shape _Capsule_ .

    
    
    struct BarsView: View {
        let bars: [Bar]
        let max: Double
    
        init(bars: [Bar]) {
            self.bars = bars
            self.max = bars.map { $0.value }.max() ?? 0
        }
    
        var body: some View {
            GeometryReader { geometry in
                HStack(alignment: .bottom, spacing: 0) {
                    ForEach(self.bars) { bar in
                        Capsule()
                            .fill(bar.legend.color)
                            .frame(height: CGFloat(bar.value) / CGFloat(self.max) * geometry.size.height)
                            .overlay(Rectangle().stroke(Color.white))
                            .accessibility(label: Text(bar.label))
                            .accessibility(value: Text(bar.legend.label))
                    }
                }
            }
        }
    }
    

Here we implement _BarsView_ which uses _HStack_ to display capsules in the
horizontal layout. Another interesting fact here is _GeometryReader_ . By
wrapping any view inside the _GeometryReader_ , we can access the geometry
data like parent size and safe area insets provided by its container. We use
container size to calculate the height of bars and draw them properly. We also
use accessibility modifier here to make our bars more accessible and
navigable.

Every chart should have a legend view. Let’s implement it by using another
regular shape provided by SwiftUI. I want to display legends as a view which
contains a small colored circle on the left and title on the right.

    
    
    struct LegendView: View {
        private let legends: [Legend]
    
        init(bars: [Bar]) {
            legends = Array(Set(bars.map { $0.legend }))
        }
    
        var body: some View {
            HStack(alignment: .center) {
                ForEach(legends, id: \.self) { legend in
                    VStack(alignment: .center) {
                        Circle()
                            .fill(legend.color)
                            .frame(width: 16, height: 16)
    
                        Text(legend.label)
                            .font(.subheadline)
                            .lineLimit(nil)
                    }
                }
            }
        }
    }
    

In the example above, we use _Сircle_ shape to draw color indicators of every
_Legend_ . Now we can compose our _BarsView_ and _LegendsView_ to provide
_BarChart_ experience.

    
    
    struct BarChartView: View {
        let bars: [Bar]
    
        var body: some View {
            Group {
                if bars.isEmpty {
                    Text("There is no data to display chart...")
                } else {
                    VStack {
                        BarsView(bars: bars)
                        LegendView(bars: bars)
                            .padding()
                            .accessibility(hidden: true)
                    }
                }
            }
        }
    }
    

Here we have _BarChartView_ which puts _BarsView and LegendsView_ inside the
_VStack_ . We also use accessibility modifier to hide _LegendsView_ in the
_Accessibility tree_ .

####  Real-life example

I use the source code from this post to implement _BarChart_ in my _SleepBot_
app. Besides the implementation which we have in the current post, I’ve added
_LabelsView_ . _LabelsView_ presents the _BarChart_ labels below the chart
itself. Here is the implementation of that view.

    
    
    struct LabelsView: View {
        let bars: [Bar]
        let labelsCount: Int
    
        private var threshold: Int {
            let threshold = bars.count / labelsCount
            return threshold == 0 ? 1 : threshold
        }
    
        var body: some View {
            HStack {
                ForEach(0..<bars.count, id: \.self) { index in
                    Group {
                        if index % self.threshold == 0 {
                            Spacer()
                            Text(self.bars[index].label)
                                .font(.caption)
                            Spacer()
                        }
                    }
                }
            }
        }
    }
    

Take a look at the final version of _BarChartView_ in _SleepBot_ app.
![chart](/public/chart.jpg)

####  Conclusion

Today we talked about _Shape_ API which we have in SwiftUI. We also build
_BarChart_ experience by using ready to use _Capsule_ and _Circle_ shapes. We
made our chart accessible by providing labels and values for our bars. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading and see you next week!



# Accessibility actions in SwiftUI

##  Accessibility actions in SwiftUI

15 Apr 2021

SwiftUI provides us accessible views out of the box, and usually, you don’t
need to do anything to build an accessible app for your users. But there is
always room for improvements and additional functionality that you can create
using Accessibility API. This week we will learn how to provide custom
accessibility actions for SwiftUI views.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Adjustable action

SwiftUI provides us an adjustable trait that VoiceOver uses to indicate the
ability to adjust the view using swipes up or down. Assume that you are
working on the _RatingView_ . _RatingView_ has to present the current 5-star
rating and should provide the opportunity to change the rating. Let’s see how
we can implement this view.

    
    
    struct RatingView: View {
        @Binding var rating: Int
    
        var body: some View {
            HStack {
                ForEach(1..<6) { index in
                    Button(action: { rating = index }) {
                        Image(systemName: index <= rating ? "star.fill" : "star")
                    }
                }
            }
        }
    }
    

As you can see in the example above, the implementation of the _RatingView_ is
pretty straightforward. The _RatingView_ changes the value of rating using
binding whenever you press the particular button. But what about
accessibility? How does VoiceOver work with the _RatingView_ ?

> To learn about the basics of accessibility in SwiftUI, take a look at my [
> “Accessibility in SwiftUI” ](/2019/09/10/accessibility-in-swiftui/) post.

Buttons are accessible out of the box, and VoiceOver will focus on the first
button and pronounce the message: “star fill”. This is the default behavior,
and it doesn’t make sense in this case. Fortunately, SwiftUI provides us a few
modifiers to customize the user experience here.

    
    
    struct RatingView: View {
        @Binding var rating: Int
    
        var body: some View {
            HStack {
                ForEach(1..<6) { index in
                    Button(action: { rating = index }) {
                        Image(systemName: index <= rating ? "star.fill" : "star")
                    }
                }
            }
            .accessibilityElement()
            .accessibilityLabel(Text("rating"))
            .accessibilityValue(Text(String(rating)))
            .accessibilityAdjustableAction { direction in
                switch direction {
                case .increment:
                    guard rating < 5 else { break }
                    rating += 1
                case .decrement:
                    guard rating > 1 else { break }
                    rating -= 1
                @unknown default:
                    break
                }
            }
        }
    }
    

By default, the _HStack_ works as a transparent accessibility container for
its children and exposes children’s information. We prevent the default
behavior using _accessibilityElement_ modifier that enables accessibility for
_HStack_ and ignores the children. We also provide the accessibility label and
value.

We use the _accessibilityAdjustableAction_ modifier, which automatically adds
the adjustable trait. We also have to provide a closure that handles the
action. The only parameter of the closure is the instance of the
_AccessibilityAdjustmentDirection_ enum.

Whenever the user navigates to the _RatingView_ , VoiceOver focuses on the
_HStack_ itself and pronounces the message: “rating, 3. Adjustable”. Users can
use swipe up and down gestures to change the value of the rating.

> To learn about the adjustable views in UIKit, take a look at my [ “Make your
> app accessible for everyone” ](/2018/07/09/make-your-app-accessible-for-
> everyone/) post.

####  Additional actions

VoiceOver supports additional actions which we can handle in our views. For
example, there is a two-finger double-tap action called magic tap. Apple
suggests us to use the magic tap for the main action in our view.

There is two-finger scrub (move two fingers back and forth three times
quickly, making a “z”) action that users do to go back in the navigation or
dismiss the alert. You can handle this action in your view if it utilizes the
custom navigation behavior.

    
    
    struct PlayerView: View {
        @ObservedObject var viewModel: ViewModel
        @Environment(\.presentationMode) var presentation
    
        var body: some View {
            HStack {
                // Player content
            }
            .accessibilityAction(.magicTap) {
                if viewModel.isPlaying {
                    viewModel.pause()
                } else {
                    viewModel.play()
                }
            }
            .accessibilityAction(.escape) {
                viewModel.pause()
                presentation.wrappedValue.dismiss()
            }
        }
    }
    

You can also provide named actions in addition to the predefined actions.

    
    
    struct PlayerView: View {
        @ObservedObject var viewModel: ViewModel
    
        var body: some View {
            HStack {
                // Player content
            }
            .accessibilityAction(named: Text("skip")) {
                viewModel.skip()
            }
            .accessibilityAction(named: Text("repeat")) {
                viewModel.repeat()
            }
        }
    }
    

####  Conclusion

This week we learned how to make our apps more accessible by adding VoiceOver-
friendly actions. Remember that accessibility isn’t a feature or a “nice to
have”. It’s a necessity. So let’s make your app accessible for everyone. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering StoreKit 2. SubscriptionStoreView in SwiftUI.

##  Mastering StoreKit 2. SubscriptionStoreView in SwiftUI.

23 Aug 2023

This week we will continue the series of posts about StoreKit views in SwiftUI
by covering another StoreKit view called _SubscriptionStoreView_ . This view
allows us to easily display and handle subscriptions in a single group.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

The _SubscriptionStoreView_ provides a complete subscription management flow
in a single line of code.

    
    
    import SwiftUI
    import StoreKit
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1")
        }
    }
    

All you need is to place an instance of the _SubscriptionStoreView_ with a
single parameter defining the subscription group. Ensure you provide the group
identifier, not the group title or any other string. The
_SubscriptionStoreView_ completely handles subscription flow, including
loading and purchasing products. You don’t need to do anything.

![default-subscription-store](/public/subs3.png)

You can customize the list of subscriptions in the _SubscriptionStoreView_ by
providing a list of product identifiers for every subscription you want to
include. Keep in mind that _SubscriptionStoreView_ can handle only
subscriptions in the same group.

    
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(productIDs: ["123456789", "987654321"])
        }
    }
    

Another option is to provide a list of loaded instances of the Product type
that StoreKit 2 uses to encapsulate a particular in-app purchase product.

> To learn more about the basics of the StoreKit 2, take a look at my [
> “Mastering StoreKit 2” ](/2023/08/01/mastering-storekit2/) post.

As I said before, the _SubscriptionStoreView_ handles the subscription
management flow completely. So it provides the user interface for upgrades,
downgrades, crossgrades, etc. By default, it displays all available actions,
but you can control the availability of the provided actions by using the
_visibleRelationships_ parameter.

    
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1", visibleRelationships: .all)
        }
    }
    

The _visibleRelationships_ parameter is defined via the
_SubscriptionRelationship_ struct. It provides many ready-to-use options like
upgrade, crossgrade, downgrade, and current.

    
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1", visibleRelationships: .current)
        }
    }
    

In the example above, we use the _SubscriptionStoreView_ only to display the
subscription the user has already subscribed for.

> _SubscriptionStoreView_ supports the _storeButton_ view modifier allowing to
> set the visibility for a set of buttons provided by the store. To learn more
> take a look at my [ “Mastering StoreKit 2. ProductView and StoreView in
> SwiftUI” ](/2023/08/08/mastering-storekit2-productview-in-swiftui/) post.

####  Styling

By default, _SubscriptionStoreView_ uses the app icon and the title of the
subscription group as additional content to display above the list of
subscriptions. It works great for my apps on watchOS, but something other than
what I want to show on iOS or iPadOS.

Fortunately, you can quickly provide your super custom view to display above
the list of subscriptions. I usually use that area to give information on
features included in the subscription.

    
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1", visibleRelationships: .all) {
                MyMarketingContentView()
            }
        }
    }
    

As you can see in the example above, we use another variant of the
_SubscriptionStoreView_ , allowing us to pass a _ViewBuilder_ closure to
display as marketing content.

You can customize the background of the _SubscriptionStoreView_ by using the
brand-new _containerBackground_ view modifier. It allows us to place a SwiftUI
as a background of the _SubscriptionStoreView_ .

    
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1", visibleRelationships: .all) {
                MyMarketingContentView()
                    .containerBackground(Color.blue, for: .subscriptionStoreHeader)
                    .containerBackground(Color.red, for: .subscriptionStoreFullHeight)
            }
        }
    }
    

As you can see, we can control the placement of the background by using the
second parameter of the _containerBackground_ view modifier. We can set
different backgrounds for marketing content or the whole store view.

![default-subscription-store](/public/subs1.png)

Another styling option _SubscriptionStoreView_ provides us is the control
style. By default, it uses pickers, but we can easily change it to use buttons
instead by using the _subscriptionStoreControlStyle_ view modifier.

    
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1", visibleRelationships: .all)
                .subscriptionStoreControlStyle(.buttons)
        }
    }
    

The _subscriptionStoreControlStyle_ view modifier allows us to set the style
to the following options: buttons, picker, prominent picker, and automatic.
The _SubscriptionStoreView_ works on all Apple platforms, but only some
control styles work on some platforms. That’s why default is the _automatic_
style that uses a different look and feel depending on the platform.

We also have the _subscriptionStoreButtonLabel_ view modifier allowing us to
customize store buttons. When you use pickers in your subscription store, the
_subscriptionStoreButtonLabel_ view modifier affects only a single button that
calls to action.

    
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1", visibleRelationships: .all)
                .subscriptionStoreButtonLabel(.multiline)
        }
    }
    

The _subscriptionStoreButtonLabel_ view modifier allows us to set different
predefined labels for the call to action button. By default, it uses an
automatic label that shows action based on the selected subscription. So it
can display “Try free” when your subscription has a free trial or “Change to”
when you already have an active subscription.

    
    
    struct ContentView: View {
        var body: some View {
            SubscriptionStoreView(groupID: "598392E1", visibleRelationships: .all)
                .subscriptionStoreButtonLabel(.multiline)
        }
    }
    

You can use the multiline option to include more information about your
subscription in the button. Whenever you use the buttons style as the
subscription control, the _subscriptionStoreButtonLabel_ view modifier affects
that buttons also.

![default-subscription-store](/public/subs2.png)

This week we learned about the _SubscriptionStoreView_ from StoreKit 2 and how
to use it to make a recurring revenue for your app. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!

  1. [ Mastering StoreKit 2 ](/2023/08/01/mastering-storekit2/)
  2. [ Mastering StoreKit 2. ProductView and StoreView in SwiftUI. ](/2023/08/08/mastering-storekit2-productview-in-swiftui/)
  3. Mastering StoreKit 2. SubscriptionStoreView in SwiftUI 
  4. [ Mastering StoreKit 2. SwiftUI view modifiers. ](/2023/08/29/mastering-storekit2-swiftui-view-modifiers/)
  5. [ StoreKit testing in Swift ](/2024/01/09/storekit-testing-in-swift/)



# Template-view pattern in SwiftUI

##  Template-view pattern in SwiftUI

13 May 2020

Today I want to share with you a technique that I use a lot in SwiftUI. It
helps me to solve the problem when I need to place a vertical or horizontal
stack with equal-sized views that support Dynamic Type. I didn’t find the
right name for this approach and call it template-view.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Assume that you’re working on a view that should represent an average heart
rate for every day of the week. I would implement that view using a horizontal
stack with text components.

    
    
    struct WeekView: View {
        let heartRates: [Int]
    
        var body: some View {
            HStack {
                ForEach(self.heartRates, id: \.self) { hr in
                    Text(String(hr))
                        .padding(4)
                        .background(Color.purple)
                        .cornerRadius(4)
                }
            }
        }
    }
    

![template-view](/public/template1.png)

Pretty easy, right? But this code has one issue. Every view inside the
horizontal stack has a different size based on its text content. The
fundamental layout system rule says that every view in SwiftUI calculates its
size and sends it back to the parent.

> To learn more about the layout system in SwiftUI, take a look at my [
> “Layout priorities in SwiftUI” ](/2020/04/15/layout-priorities-in-swiftui/)
> post.

I want to make all views in the horizontal stack the same size. We can easily
solve the issue by adding the _frame_ modifier to fix the size for every view.

    
    
    struct WeekView: View {
        let heartRates: [Int]
    
        var body: some View {
            HStack {
                ForEach(self.heartRates, id: \.self) { hr in
                    Text(String(hr))
                        .frame(width: 40, height: 40, alignment: .center)
                        .background(Color.purple)
                        .cornerRadius(4)
                }
            }
        }
    }
    

![template-view](/public/template2.png)

Looks nice, but what about Dynamic Type? My users can change the font size in
system settings, and I want respect that font size configuration. It is
impossible with _frame_ modifier because it just sets the size of the view and
doesn’t support Dynamic Type. Let’s see what happens when I increase the font
size in system settings.

![template-view](/public/template3.png)

> To learn more about the benefits of Dynamic Type, take a look at my [
> “Dynamic Type in SwiftUI” ](/2019/10/09/dynamic-type-in-swiftui/) post.

As you can see, the _frame_ modifier creates additional problems for us. It is
a perfect time to introduce a template-view here.

    
    
    struct WeekView: View {
        let heartRates: [Int]
    
        var body: some View {
            HStack {
                ForEach(self.heartRates, id: \.self) { hr in
                    Text("190")
                        .hidden()
                        .padding(4)
                        .background(Color.purple)
                        .cornerRadius(4)
                        .overlay(Text(String(hr)))
                }
            }
        }
    }
    

It might look strange, but let me describe what happens here. First of all, I
create a hidden text component with some stub value that I think should have
the largest width. SwiftUI doesn’t show a hidden view but still calculates its
size, and this hidden view supports Dynamic Type.

We use an overlay to display content on top of the background that we have
configured using the template-view. The benefit of using overlay is the
ability to place the view in the center of template-view and limit its size
with the size of template-view.

![template-view](/public/template4.png)

Remember that we have to use the same font size both for template-view and the
overlay to support Dynamic Type and to keep layout correct. As soon as the
user changes the font size in system settings, template-view reacts by
recalculating its size and providing more or less room for its overlay
depending on user preferred font size.

####  Dynamic Type for images

Dynamic Type is not something connected only to text. Assume that you have a
button with an image and text label.

    
    
    Button(action: { print("Hello!")}) {
        HStack {
            Image("icon")
                .resizable()
                .frame(width: 24, height: 24, alignment: .center)
            Text("Press me")
        }
    }
    

What happens when the user increases the font size? SwiftUI increases the size
of the text component, but image size stays the same. It might look really
weird, but how can I change the size of the image according to the text?

    
    
    Button(action: { print("Hello!")}) {
        HStack {
            Text("00")
                .font(.title)
                .hidden()
                .overlay(
                    Image("icon")
                        .resizable()
                        .scaledToFit()
                )
            Text("Press me")
        }
    }
    

As you can see, we use the very same approach by creating a template-view. We
display a resizable image in the overlay of the hidden text. SwiftUI resizes
the image in the overlay as soon as the template-view changes according to
system font settings.

####  Conclusion

Dynamic Type is essential, and I believe that every app should support and
respect user-defined font size. Template-view is a great way to limit the size
of your view but also appreciate the Dynamic Type. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Mastering NavigationStack in SwiftUI. Deep Linking.

##  Mastering NavigationStack in SwiftUI. Deep Linking.

21 Jun 2022

This week we will continue exploring the new Navigation API in SwiftUI. One of
the benefits of the new data-driven Navigation API is the programmatic
navigation with deep-linking possibilities. Let’s dive into the new API by
learning how to build programmatic deep navigation flows.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Programmatic navigation

There is a special _NavigationStack_ initializer accepting a binding to a
mutable collection. SwiftUI maps values of the mutable collection into a view
hierarchy and allows us to push and pop views into the _NavigationStack_
programmatically. Let’s take a look at the example.

    
    
    struct ShopContainerView: View {
        @StateObject private var store = Store()
        @State private var path: [Product] = []
    
        var body: some View {
            NavigationStack(path: $path) {
                List(store.products) { product in
                    NavigationLink(product.title, value: product)
                }
                .task { await store.fetch() }
                .navigationDestination(for: Product.self) { product in
                    ProductView(product: product)
                        .toolbar {
                            Button("Show similar") {
                                path.append(product.similar[0])
                            }
                        }
                }
            }
        }
    }
    

As you can see in the example above, we define a piece of state that drives
our navigation via binding. We also display a button that adds another product
to the path. SwiftUI automatically maps the contents of the path binding to
the view hierarchy in the navigation stack and automatically removes the
product from the path whenever the user presses the back button.

> To learn about the basics of the new data-driven Navigation API in SwiftUI,
> look at my [ “Mastering NavigationStack in SwiftUI. Navigator Pattern.”
> ](/2022/06/15/mastering-navigationstack-in-swiftui-navigator-pattern/) post.

We also can quickly implement pop to the root view by removing all the items
from the path. With this new data-driven approach, SwiftUI is responsible for
keeping your navigation stack in sync with the path binding.

    
    
    struct ShopContainerView: View {
        @StateObject private var store = Store()
        @State private var path: [Product] = []
    
        var body: some View {
            NavigationStack(path: $path) {
                List(store.products) { product in
                    NavigationLink(product.title, value: product)
                }
                .task { await store.fetch() }
                .navigationDestination(for: Product.self) { product in
                    ProductView(product: product)
                        .toolbar {
                            Button("Show similar") {
                                path.append(product.similar[0])
                            }
                            
                            Button("Back to the list") {
                                path.removeAll()
                            }
                        }
                }
            }
        }
    }
    

Usually, our navigation stack contains different screens representing
different values. In this case, we can define the path as an array of enum
where every case specifies a particular destination in our app.

    
    
    enum Route: Hashable {
        case search(String)
        case product(Product)
        case related(Product)
    }
    
    struct ShopContainerView: View {
        @StateObject private var store = Store()
        @State private var path: [Route] = []
    
        var body: some View {
            NavigationStack(path: $path) {
                List(store.products) { product in
                    NavigationLink(product.title, value: Route.product(product))
                }
                .task { await store.fetch() }
                .navigationDestination(for: Route.self) { route in
                    switch route {
                    case let .related(product):
                        ProductView(product: product.similar[0])
                    case let .product(product):
                        ProductView(product: product)
                            .toolbar {
                                NavigationLink(
                                    "Show similar",
                                    value: Route.related(product)
                                 )
                            }
                    case let .search(query):
                        SearchView(query: query)
                    }
                }
            }
        }
    }
    

####  Programmatic navigation with multiple scenes

One thing I have to mention is that you never should define the path in the
_App_ protocol. In this case, you will have a synchronized navigation stack
across all of the scenes of your app. Usually, users create multiple scenes of
our apps to use different parts simultaneously.

    
    
    @main
    // Never do this!
    struct NavigationTestApp: App {
        @State private var path: [Route] = []
        var body: some Scene {
            WindowGroup {
                NavigationStack(path: $path) {
                    RootView()
                }
            }
        }
    }
    

Instead, we should hold our state defining the path in the root view of our
app or inside a container view representing a particular user flow.

####  Deep linking and handoff

Let’s move to the next thing we might need in our app: deep linking and
handoff. With the new data-driven Navigation API, we can quickly implement
deep linking and handoff support. All we need to do is handle the URL and add
the corresponding value to the array specifying the path of the navigation
stack.

    
    
    struct ShopContainerView: View {
        @StateObject private var store = Store()
        @State private var path: [Route] = []
    
        var body: some View {
            NavigationStack(path: $path) {
                List(store.products) { product in
                    NavigationLink(product.title, value: Route.product(product))
                }
                .task { await store.fetch() }
                .navigationDestination(for: Route.self) { route in
                    // ...
                }
                .onOpenURL { url in
                    let components = URLComponents(string: url.absoluteString)
                    let searchQuery = components?.queryItems?.first { $0.name == "query" }?.value
    
                    guard let query = searchQuery else {
                        return
                    }
                    path.append(.search(query))
                }
                .onContinueUserActivity("com.app.search") { activity in
                    guard let query = activity.userInfo?["query"] as? String else {
                        return
                    }
                    path.append(.search(query))
                }
            }
        }
    }
    

####  State restoration

State restoration is one of the essential features that you should implement
to provide a pleasant user experience. SwiftUI provides the _SceneStorage_
property wrapper, allowing us to keep data in the specific storage bound to
the scene and survive when the system shuts down the app.

> To learn more about state restoration in SwiftUI, look at my [ “State
> restoration in SwiftUI” ](/2022/03/10/state-restoration-in-swiftui/) post.

We can use the _SceneStorage_ property wrapper to encode our navigation path
and store it in the scene memory. Whenever the system kills the app, we can
restore the path from the scene storage and programmatically navigate to the
last entry.

    
    
    protocol UrlHandler<Route> {
        associatedtype Route: Hashable
        func handle(_ url: URL, mutating: inout [Route])
    }
    
    protocol ActivityHandler<Route> {
        associatedtype Route: Hashable
        func handle(_ activity: NSUserActivity, mutating: inout [Route])
    }
    
    @MainActor final class NavigationStore<Route: Hashable>: ObservableObject {
        @Published var path: [Route] = []
    
        private let decoder = JSONDecoder()
        private let encoder = JSONEncoder()
        private let urlHandler: any UrlHandler<Route>
        private let activityHandler: any ActivityHandler<Route>
    
        init(
            urlHandler: some UrlHandler<Route>,
            activityHandler: some ActivityHandler<Route>
        ) {
            self.urlHandler = urlHandler
            self.activityHandler = activityHandler
        }
    
        func handle(_ activity: NSUserActivity) {
            activityHandler.handle(activity, mutating: &path)
        }
    
        func handle(_ url: URL) {
            urlHandler.handle(url, mutating: &path)
        }
    }
    
    extension NavigationStore where Route: Codable {
        func encoded() -> Data? {
            try? encoder.encode(path)
        }
        
        func restore(from data: Data) {
            do {
                path = try decoder.decode([Route].self, from: data)
            } catch {
                path = []
            }
        }
    }
    

Here we have the _NavigationStore_ class providing the common functionality
for deep linking and handoff support. It also allows us to encode our path and
decode it from the serialized representation. Now we can use it in our root
view for state restoration whenever needed.

    
    
    struct RootView: View {
        @SceneStorage("navigation") private var path: Data?
        @StateObject private var store = Store()
        @StateObject private var navigation = NavigationStore<Route>(
            urlHandler: SomeUrlHandler(),
            activityHandler: SomeActivityHandler()
        )
        
        var body: some View {
            NavigationStack(path: $navigation.path) {
                CategoriesView(categories: store.categories)
                    .task { await store.fetch() }
                    .navigationDestination(for: Route.self) { route in
                        // ...
                    }
                    .onOpenURL { navigation.handle($0) }
            }
            .task {
                if let path {
                    navigation.restore(from: path)
                }
                
                for await _ in navigation.$path.values {
                    path = navigation.encoded()
                }
            }
        }
    }
    

As you can see in the example above, we use the _task_ view modifier to
restore the navigation from the scene storage and observe the navigation path
to save it as soon as any changes appear.

####  Conclusion

Today we learned how to use the new data-driven Navigation API to control our
navigation stack programmatically and implement the deep linking feature. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Deep dive into Pattern matching with ~= operator

##  Deep dive into Pattern matching with ~= operator

20 Mar 2019

[ In one of my previous posts, we talked about the Pattern Matching feature of
Swift language ](/2019/02/06/pattern-matching-with-case-let) . We discussed
how we could use “case let” keyword in our daily development to find patterns
in Enums, Turples, and Optionals. But today we are going to talk about
particular Pattern Matching operator which hides all of this magic behind it.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Pattern Matching is the act of checking a given sequence of tokens for the
presence of the constituents of some pattern. Let’s take a look at a simple
string matching operation.

    
    
    let message = "Hello World!"
    
    switch message {
    case "Hello": print("hello")
    case "World": print("world")
    case "Hello World!": print("Hello World!")
    default: break
    }
    

As you can understand this code will print “Hello World!” message in the
console. In most of the cases Pattern Matching work as equality check, except
Ranges, where it refers to the “contains” method of Range type.

So, the question is “How it is really working?”. Behind the Pattern Matching
operation, Swift uses ~= operator, which is overloaded for most of the
standard types. While using Pattern Matching, Swift is looking for ~= operator
for the current types. Here is an example of how ~= operator looks for String
type.

    
    
    func ~= (pattern: String, value: String) -> Bool {
        return pattern == value
    }
    

The good news here is that we can easily overload ~= operator to change this
behavior. For example, in the code listing below we change the implementation
to custom one, where we instead of equality checking match for containment and
now you will see the “Hello” message in the console.

    
    
    func ~= (pattern: String, value: String) -> Bool {
        return value.contains(pattern)
    }
    
    let message = "Hello World!"
    
    switch message {
    case "Hello": print("hello")
    case "World": print("world")
    case "Hello World!": print("Hello World!")
    default: break
    }
    

There is no magic behind the Pattern Matching. It is just a simple ~=
function. We can easily define it for our types and use them in switch
statements. Let’s do that.

    
    
    struct User {
        let firstName: String
        let secondName: String
        let age: Int
    }
    
    extension User {
        static func ~= (range: ClosedRange<Int>, user: User) -> Bool {
            return range.contains(user.age)
        }
    }
    
    let user = User(firstName: "Majid", secondName: "Jabrayilov", age: 27)
    
    switch user {
    case 21...30: print("The user age is between 21 and 30")
    case 31...40: print("The user age is between 31 and 40")
    default: break
    }
    

Here we have straightforward User struct which contains the name, second name
and age fields. I want to be able to use User struct instances in switch
statements for matching the age range of my users. Please take a look at the
order of parameters in ~= function. The first one describes the case value,
where the second one is the value used after the switch keyword. Console
output, in this case, is “The user age is between 20 and 30”.

Another good option for overloading Pattern Matching operator can be regular
expressions. I want to match the text to multiple regular expression patterns.
Let’s dive into the code.

    
    
    struct Regex {
        let pattern: String
    
        static let email = Regex(pattern: "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}")
        static let phone = Regex(pattern: "([+]?1+[-]?)?+([(]?+([0-9]{3})?+[)]?)?+[-]?+[0-9]{3}+[-]?+[0-9]{4}")
    }
    
    extension Regex {
        static func ~=(regex: Regex, text: String) -> Bool {
            return text.range(of: regex.pattern, options: .regularExpression) != nil
        }
    }
    

Here we have Regex struct which has only one field, and that is the pattern
string. We also implement email and phone static constants with predefined
regular expressions. Next, we overload ~= operator, in this case, it matches
text to our Regex struct by using “range of” method of string type. That’s all
we need to use our Regex type for Pattern Matching. Here is the usage example.

    
    
    let email = "cmecid@gmail.com"
    
    switch email {
    case Regex.email: print("email")
    case Regex.phone: print("phone")
    default: print("default")
    }
    

Today we discussed how actually is working Pattern Matching in Swift, how
easily we can override the logic for standard types and how we can add the
ability for Pattern Matching to custom types. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading and see you next week!



# Displaying recursive data using OutlineGroup in SwiftUI

##  Displaying recursive data using OutlineGroup in SwiftUI

02 Sep 2020

This week we will talk about another excellent UI component called
_OutlineGroup_ . Apple released _OutlineGroup_ during the WWDC20 side-by-side
with other great things, including grids, menus, and toolbars. I already
covered them in my previous posts. And finally, today is time to talk about
_OutlineGroup_ and _DisclosureGroup_ that handles the expanding behavior.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  OutlineGroup

_OutlineGroup_ is a view that enumerates tree-structured collection and
renders its view representation recursively. It is a perfect solution to
display recursive data like trees. Assume that you are working on the shopping
app where you obtain a categories tree via API. Let’s take a look at a
straightforward tree implementation in Swift.

    
    
    struct Tree<Value: Hashable>: Hashable {
        let value: Value
        var children: [Tree]? = nil
    }
    

Now we have a pretty simple tree structure that allows us to define complex
category hierarchy. For example, the API response from the categories endpoint
might look like this.

    
    
    let categories: [Tree<String>] = [
        .init(
            value: "Clothing",
            children: [
                .init(value: "Hoodies"),
                .init(value: "Jackets"),
                .init(value: "Joggers"),
                .init(value: "Jumpers"),
                .init(
                    value: "Jeans",
                    children: [
                        .init(value: "Regular"),
                        .init(value: "Slim")
                    ]
                ),
            ]
        ),
        .init(
            value: "Shoes",
            children: [
                .init(value: "Boots"),
                .init(value: "Sliders"),
                .init(value: "Sandals"),
                .init(value: "Trainers"),
            ]
        )
    ]
    

As you can see, we already have a recursive structure. Let’s try to feed it
into the _OutlineGroup_ to display the tree hierarchy.

    
    
    struct ContentView: View {
        var body: some View {
            OutlineGroup(categories, id: \.value, children: \.children) { tree in
                Text(tree.value).font(.subheadline)
            }
        }
    }
    

_OutlineGroup_ allows us to display very complex tree-structured collections
in a few lines of code. We construct _OutlineGroup_ in a very familiar
fashion. It looks similar to the _ForEach_ view but also needs the children
parameter. Children parameter is a _KeyPath_ to a recursive property of our
structure. Keep in mind that the recursive property must be optional. This is
how _OutlineGroup_ understands the end of the tree node.

![outline group](/public/outlineGroup1.png)

Another thing that Apple released side-by-side with _OutlineGroup_ is a new
way to configure a _List_ that uses _OutlineGroup_ to display its items. It
automatically applies list styling to _OutlineGroup_ and allows us to use it
in the sidebar navigation. Let’s take a look at how we can use List with
_OutlineGroup_ under the hood.

    
    
    struct ContentView: View {
        var body: some View {
            List(categories, id: \.value, children: \.children) { tree in
                Text(tree.value).font(.subheadline)
            }.listStyle(SidebarListStyle())
        }
    }
    

As you can see, there is a new _List_ initializer that takes additional
children parameter. You can simply replace your _OutlineGroup_ with _List_ ,
and you will get a list styling for your tree-structured collection.

![outline group](/public/outlineGroup2.png)

> To learn more about building three-column navigation in SwiftUI, take a look
> at my [ “Sidebar navigation in SwiftUI” ](/2020/07/21/sidebar-navigation-in-
> swiftui/) post.

_OutlineGroup_ is really shining when you use it inside a _List_ . We can use
_OutlineGroup_ inside sections. This approach allows us to expand the first
level of your tree-structured collection automatically. It looks gorgeous with
sidebar style. Let’s take a look at the quick example of section-based
_OutlineGroup_ usage.

    
    
    struct ContentView: View {
        var body: some View {
            List {
                ForEach(categories, id: \.self) { section in
                    Section(header: Text(section.value)) {
                        OutlineGroup(
                            section.children ?? [],
                            id: \.value,
                            children: \.children
                        ) { tree in
                            Text(tree.value)
                                .font(.subheadline)
                        }
                    }
                }
            }.listStyle(SidebarListStyle())
        }
    }
    

![outline group](/public/outlineGroup3.png)

####  DisclosureGroup

As you can see on the screenshots that I provide during the post, the main
component of _OutlineGroup_ is an expandable view called _DisclosureGroup_ .
_DisclosureGroup_ is a straightforward view that accepts title string, content
view, and boolean binding, which shows or hides the content.

    
    
    struct ContentView: View {
        @State private var showContent = false
    
        var body: some View {
            DisclosureGroup("Message", isExpanded: $showContent) {
                Text("Hello World!")
            }
        }
    }
    

You can use _DisclosureGroup_ inside a _Form_ view that allows you to build
complex forms quickly in a very declarative way.

> To learn more about the power of Form view in SwiftUI, take a look at my [
> “Building forms with SwiftUI” ](/2019/06/19/building-forms-with-swiftui/)
> post.

####  Conclusion

Today we learned about another view that WWDC20 brings us in addition to the
current collection of views. With the help of _OutlineGroup_ , we can easily
display the massive collection of tree-structured items.

We also learned about _DisclosureGroup_ that powers _OutlineGroup_ . The nice
bonus is that we can use _DisclosureGroup_ separately. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this article. Thanks for reading, and see you next
week!



# The magic of Animatable values in SwiftUI

##  The magic of Animatable values in SwiftUI

17 Jun 2020

_WWDC20_ is already around the corner, and we are waiting for massive changes
and additions to the SwiftUI framework. It is a perfect week to wrap up the
season with a post about one of the strongest sides of the SwiftUI framework,
which is _animation_ . Today we will learn how to build complex animations by
using _VectorArithmetic_ protocol.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s start with the basics. Usually, we attach the animation modifier to a
view and change some state variables. SwiftUI docs say that animation modifier
applies the given animation to all **animatable** values within this view.
Here is a small example that animates the button on every tap.

    
    
    struct RootView: View {
        @State private var scale: CGFloat = 1
    
        var body: some View {
            Button("Press me") {
                self.scale += 1
            }
            .padding()
            .foregroundColor(.white)
            .background(Color.blue)
            .cornerRadius(8)
            .scaleEffect(scale)
            .animation(.default, value: scale)
        }
    }
    

> To learn more about basics of animation in SwiftUI, take a look at my [
> “Animations in SwiftUI” post ](/2019/06/26/animations-in-swiftui/) .

But how SwiftUI understand which values are **animatable** ? SwiftUI
introduces a protocol called _Animatable_ . This protocol has the only
requirement, _animatableData_ property, that describes the changes during an
animation. So during the state changes, SwiftUI traverses the view hierarchy
and finds all the values that conform to _Animatable_ protocol and animate its
changes by understanding _animatableData_ of a particular item. Let’s take a
look at another example.

    
    
    struct Line1: Shape {
        let coordinate: CGFloat
    
        func path(in rect: CGRect) -> Path {
            Path { path in
                path.move(to: .zero)
                path.addLine(to: CGPoint(x: coordinate, y: coordinate))
            }
        }
    }
    
    struct RootView: View {
        @State private var coordinate: CGFloat = 0
    
        var body: some View {
            Line1(coordinate: coordinate)
                .stroke(Color.red)
                .animation(Animation.linear(duration: 1).repeatForever())
                .onAppear { self.coordinate = 100 }
        }
    }
    

Here we have a _Line_ struct that conforms to the _Shape_ protocol. All shapes
in SwiftUI conform to _Animatable_ protocol, but as you can see, there is no
animation while running the example. SwiftUI doesn’t animate our line because
the framework doesn’t know how to animate it.

> To learn more about _Shape API_ in SwiftUI, take a look at my [ “Building
> BarChart with Shape API in SwiftUI” post ](/2019/08/14/building-barchart-
> with-shape-api-in-swiftui/) .

By default, shape returns the instance of _EmptyAnimatableData_ struct as its
_animatableData_ . SwiftUI allows us to use _EmptyAnimatableData_ whenever we
don’t know how to animate the value. Let’s solve the problem by replacing
_EmptyAnimatableData_ with some value.

    
    
    struct Line1: Shape {
        var coordinate: CGFloat
    
        var animatableData: CGFloat {
            get { coordinate }
            set { coordinate = newValue }
        }
    
        func path(in rect: CGRect) -> Path {
            Path { path in
                path.move(to: .zero)
                path.addLine(to: CGPoint(x: coordinate, y: coordinate))
            }
        }
    }
    

In the example above, we made our _Line_ struct animatable by implementing
_animatableData_ property. But how we can animate multiple properties of the
same shape? There is another type called _AnimatablePair_ that helps us to
animate the paired values. Let’s make our _Line_ struct animatable in both
vertical and horizontal directions.

    
    
    struct Line2: Shape {
        var x: CGFloat
        var y: CGFloat
    
        var animatableData: AnimatablePair<CGFloat, CGFloat> {
            get { AnimatablePair(x, y) }
            set {
                x = newValue.first
                y = newValue.second
            }
        }
    
        func path(in rect: CGRect) -> Path {
            Path { path in
                path.move(to: .zero)
                path.addLine(to: CGPoint(x: x, y: y))
            }
        }
    }
    

OK, nice. Now we can animate two values of the same shape. But what about the
line chart? Assume that you are working on the charting library, and you want
to build an animatable line chart? There might be hundreds of values that we
want to animate. How could we deal with this challenge?

####  Introducing VectorArithmetic protocol

As you can see, we have already used _CGFloat_ and _AnimatablePair_ types as
animatable data. But it doesn’t mean that you can use any type here.
_Animatable_ protocol has a constraint on _animatableData_ property. Any type
that conforms to _VectorArithmetic_ protocol can be used as _animtableData_ .
SwiftUI provides us a few types that conform to _VectorArithmetic_ protocol
out of the box. For example, _Float_ , _Double_ , _CGFloat_ , and
_AnimatablePair_ .

Let’s back to our line chart idea. I want to make a line chart shape that
animates all the values. There are probably could be hundreds of points, and
it looks like an excellent candidate for a custom type that conforms to
_VectorArithmetic_ protocol. _VectorArithmetic_ has a few requirements like
scaling, adding, subtracting, etc. You should describe how SwiftUI must handle
these operations on your type. Here is a drop-in implementation for an array
of values.

    
    
    import SwiftUI
    import enum Accelerate.vDSP
    
    struct AnimatableVector: VectorArithmetic {
        static var zero = AnimatableVector(values: [0.0])
    
        static func + (lhs: AnimatableVector, rhs: AnimatableVector) -> AnimatableVector {
            let count = min(lhs.values.count, rhs.values.count)
            return AnimatableVector(values: vDSP.add(lhs.values[0..<count], rhs.values[0..<count]))
        }
    
        static func += (lhs: inout AnimatableVector, rhs: AnimatableVector) {
            let count = min(lhs.values.count, rhs.values.count)
            vDSP.add(lhs.values[0..<count], rhs.values[0..<count], result: &lhs.values[0..<count])
        }
    
        static func - (lhs: AnimatableVector, rhs: AnimatableVector) -> AnimatableVector {
            let count = min(lhs.values.count, rhs.values.count)
            return AnimatableVector(values: vDSP.subtract(lhs.values[0..<count], rhs.values[0..<count]))
        }
    
        static func -= (lhs: inout AnimatableVector, rhs: AnimatableVector) {
            let count = min(lhs.values.count, rhs.values.count)
            vDSP.subtract(lhs.values[0..<count], rhs.values[0..<count], result: &lhs.values[0..<count])
        }
    
        var values: [Double]
    
        mutating func scale(by rhs: Double) {
            values = vDSP.multiply(rhs, values)
        }
    
        var magnitudeSquared: Double {
            vDSP.sum(vDSP.multiply(values, values))
        }
    }
    

As you can see, I use the _Accelerate_ framework that provides us high-
performance vector-based arithmetic. By using _AnimatableVector_ struct, we
can animate as many values as we want, and it will work super fast because it
uses the _Accelerate_ framework. Now we have all we need to implement an
animatable line chart shape.

    
    
    import SwiftUI
    
    struct LineChart: Shape {
        var vector: AnimatableVector
    
        var animatableData: AnimatableVector {
            get { vector }
            set { vector = newValue }
        }
    
        func path(in rect: CGRect) -> Path {
            Path { path in
                let xStep = rect.width / CGFloat(vector.values.count)
                var currentX: CGFloat = xStep
                path.move(to: .zero)
    
                vector.values.forEach {
                    path.addLine(to: CGPoint(x: currentX, y: CGFloat($0)))
                    currentX += xStep
                }
            }
        }
    }
    

You can download the source code of _AnimatableVector_ through [ Github gist
](https://gist.github.com/mecid/18a80b18cc9670eef1d8667cf8c886bd) .

    
    
    struct RootView: View {
        @State private var vector: AnimatableVector = .zero
    
        var body: some View {
            LineChart(vector: vector)
                .stroke(Color.red)
                .animation(Animation.default.repeatForever())
                .onAppear { 
                    self.vector = AnimatableVector(values: [50, 100, 75, 100]) 
                }
        }
    }
    

![linechart-animation](/public/linechart.gif)

####  Conclusion

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering grids in SwiftUI

##  Mastering grids in SwiftUI

08 Jul 2020

This week I want to talk about grids in SwiftUI. It was the most expected
feature. Everybody has been waiting for _UICollectionView_ alternative in
SwiftUI, and finally, it arrived this year. SwiftUI provides us _LazyVGrid_
and _LazyHGrid_ views that we can use to build grid-based layouts.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

_LazyVGrid_ and _LazyHGrid_ are two new view types that SwiftUI gives us to
build a super custom grid-based layout. The only difference between them is
the layout axis. _LazyVGrid_ populates the available space in the vertical
direction. On the other hand, _LazyHGrid_ arranges its children in the
horizontal direction. Axis is the only difference between these two views.
That’s why everything that you see about _LazyVGrid_ applies to _LazyHGrid_
and vice versa. Let’s take a look at our first example.

    
    
    struct ContentView: View {
        private var columns: [GridItem] = [
            GridItem(.fixed(100), spacing: 16),
            GridItem(.fixed(100), spacing: 16),
            GridItem(.fixed(100), spacing: 16)
        ]
    
        var body: some View {
            ScrollView {
                LazyVGrid(
                    columns: columns,
                    alignment: .center,
                    spacing: 16,
                    pinnedViews: [.sectionHeaders, .sectionFooters]
                ) {
                    Section(header: Text("Section 1").font(.title)) {
                        ForEach(0...10, id: \.self) { index in
                            Color.random
                        }
                    }
    
                    Section(header: Text("Section 2").font(.title)) {
                        ForEach(11...20, id: \.self) { index in
                            Color.random
                        }
                    }
                }
            }
        }
    }
    

![grid](/public/grid1.png)

In the example above, we create a three-column grid where every column has a
fixed size of 100pt. I’m going to use this example to describe every
configuration option that we have.

  1. _columns_ parameter is the array that defines columns in a grid layout. SwiftUI provides us _GridItem_ type to describe a column. We will talk about it later in the post. 
  2. _alignment_ parameter allows us to align the grid’s content using _HorizontalAlignment_ enum for _LazyVGrid_ and _VerticalAlignment_ for _LazyHGrid_ . It works the same way as the stack alignment. 
  3. _spacing_ parameter specifies the space between every row inside the _LazyVGrid_ or space between every column inside the _LazyHGrid_ . 
  4. _pinnedViews_ parameter specifies the pinning options for section headers and footers. By default, it is empty, which means that section headers and footers behave as content and go away while scrolling. You can enable header and footer pinning, in this case, headers and footers overlay the content and become сonstantly visible. 

####  GridItem

Every column in a grid has to be defined using _GridItem_ struct. _GridItem_
type allows us to specify size, alignment, and spacing for every column. Let’s
take a look at a small example.

    
    
    private var columns: [GridItem] = [
        GridItem(.fixed(50), spacing: 16, alignment: .leading),
        GridItem(.fixed(75)),
        GridItem(.fixed(100))
    ]
    

![grid](/public/grid2.png)

As you can see, every column can have different sizing, spacing, and alignment
options. The most interesting here is sizing. There are three ways to define
the size of a column inside a grid. It can be fixed or flexible or adaptive.

The **fixed** column is the easiest one. Grid setup the column to match the
size that you define. In the previous example, we created a three-column
layout where columns have fixed sizes 50pt, 75pt, and 100pt accordingly.

The **flexible** option allows us to define a column that expands or shrinks
depending on available space. We can also provide a minimum and maximum size
for the flexible column. By default, it uses 10pt as minimal value and
infinity as maximal.

    
    
    private var columns: [GridItem] = [
        GridItem(.flexible(minimum: 250)),
        GridItem(.flexible())
    ]
    

![grid](/public/grid3.png)

Here we create a layout that divides available space between two flexible
columns. The first column requires 250pt to be a minimum size, where the
second one consumes all the available space.

The most exciting option is **adaptive** . The adaptive option allows us to
place multiple items in the space of a single flexible column. Let’s take a
look at the example to understand it better.

    
    
    private var columns: [GridItem] = [
        GridItem(.adaptive(minimum: 50, maximum: 100)),
        GridItem(.adaptive(minimum: 150))
    ]
    

![grid](/public/grid4.png)

As you can see, we have two adaptive columns. There are multiple items inside
the first adaptive column with a minimal size of 50pt and maximal 100pt.
Adaptive columns are handy when the count of items inside the column should
depend on available space.

The real power of grids appears when you start mixing multiple column types.
You can create a layout of two columns, where the first one is fixed, and the
second is adaptive. Let’s take a look at this example.

    
    
    private var columns: [GridItem] = [
        GridItem(.fixed(100)),
        GridItem(.adaptive(minimum: 50))
    ]
    

![grid](/public/grid5.png)

####  Conclusion

Grids allow us to create very complex and great layouts by mixing different
types of _GridItems_ . Remember that all the changes in grids are animatable.
I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering StoreKit 2

##  Mastering StoreKit 2

01 Aug 2023

StoreKit provides us with an opportunity to make revenue from our apps. It
allows us to set up the purchase flow for in-app purchases and subscriptions.
StoreKit 2 introduces a modern Swift-based API to build type-safe in-app
purchases. This week we will start the series of posts about StoreKit 2.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

First, we must configure our project by adding in-app purchases in the
projects’ “Signing & Capabilities” tab. Next, we should create a StoreKit
configuration file to test in-app purchases without a network connection with
the App Store. Go to File -> New -> File and choose “StoreKit Configuration
File”.

You can create a local-only configuration file and populate it with test
subscriptions and in-app purchases. Another option is to fetch the list of
subscriptions and in-app purchases from the App Store Connect by enabling the
“Sync this file with an app in App Store Connect” checkbox.

The final step is to run your app with the predefined StoreKit configuration
file. You need to edit the scheme of your project, and in the options tab of
the run section, choose your StoreKit configuration file. Now you have a
fully-configured project allowing us to test in-app purchases in the Xcode.

Let’s start building our paywall feature by introducing the _Store_ type to
handle all the logic related to in-app purchases.

    
    
    import StoreKit
    
    @MainActor final class Store: ObservableObject {
        @Published private(set) var products: [Product] = []
        
        init() {}
        
        func fetchProducts() async {
            do {
                products = try await Product.products(
                    for: [
                        "123456789", "987654321"
                    ]
                )
            } catch {
                products = []
            }
        }
    }
    

As you can see in the example above, we define the _Store_ type fetching and
storing the list of products we will display on the paywall screen. The
StoreKit 2 framework provides the _Product_ type encapsulating all the logic
around an in-app purchase. The _Product_ type has a static function called
_products_ that we can use to fetch the list of products by providing a
collection of identifiers.

    
    
    struct ContentView: View {
        @StateObject private var store = Store()
        
        var body: some View {
            VStack {
                if store.products.isEmpty {
                    ProgressView()
                } else {
                    ForEach(store.products, id: \.id) { product in
                        Button {
                            Task {
                                try await store.purchase(product)
                            }
                        } label: {
                            VStack {
                                Text(verbatim: product.displayName)
                                    .font(.headline)
                                Text(verbatim: product.displayPrice)
                            }
                        }
                        .buttonStyle(.borderedProminent)
                    }
                }
            }
            .task {
                await store.fetchProducts()
            }
        }
    }
    

We use our _Store_ type to fetch and display the list of available in-app
purchases. An instance of the _Product_ type contains all information we need
to show, like the title, description, and price of an in-app purchase.

The _Product_ type also has the _purchase_ function that we can use to start
an in-app purchase flow for a particular product. It returns an instance of
the _PurchaseResult_ enum defining three cases: _success_ , _pending_ , and
_userCancelled_ .

    
    
    @MainActor final class Store: ObservableObject {
        // ...
        
        @Published private(set) var activeTransactions: Set<StoreKit.Transaction> = []
        
        func purchase(_ product: Product) async throws {
            let result = try await product.purchase()
            switch result {
            case .success(let verificationResult):
                if let transaction = try? verificationResult.payloadValue {
                    activeTransactions.insert(transaction)
                    await transaction.finish()
                }
            case .userCancelled:
                break
            case .pending:
                break
            @unknown default:
                break
            }
        }
    }
    

Whenever the purchase result is in the success state, it provides an
associated value of type _Transaction_ defining the successful transaction.
StoreKit wraps the transaction in the _VerificationResult_ type allowing us to
validate that transaction is correctly signed and comes from the App Store.

The _VerificationResult_ type used by StoreKit 2 to verify that the data is
valid and signed by the App Store. It provides us the _payloadValue_
calculated property that we can use to unwrap the signed data or throw an
error if the data is not correctly signed.

As soon as you retrieve the transaction, you should unlock the feature user
purchased and call the _finish_ function on the particular transaction.
Remember, you should always finish the transaction only after unlocking the
purchased feature.

    
    
    struct ContentView: View {
        @StateObject private var store = Store()
        
        var body: some View {
            VStack {
                Text("Purchased items: \(store.activeTransactions.count)")
                
                if store.products.isEmpty {
                    ProgressView()
                } else {
                    if store.activeTransactions.isEmpty {
                        ForEach(store.products, id: \.id) { product in
                            Button {
                                Task {
                                    try await store.purchase(product)
                                }
                            } label: {
                                VStack {
                                    Text(verbatim: product.displayName)
                                        .font(.headline)
                                    Text(verbatim: product.displayPrice)
                                }
                            }
                            .buttonStyle(.borderedProminent)
                        }
                    }
                }
            }
            .task {
                await store.fetchProducts()
            }
        }
    }
    

The purchase becomes pending whenever the ask to buy is enabled. In this case,
the transaction arrives later, only after approval by the parent. You should
observe the _Transaction.updates_ stream to handle this kind of transaction.
We must start monitoring this stream as soon as the app launches to never miss
a transaction.

    
    
    @MainActor final class Store: ObservableObject {
        @Published private(set) var activeTransactions: Set<StoreKit.Transaction> = []
        private var updates: Task<Void, Never>?
        
        // ...
        
        init() {
            updates = Task {
                for await update in StoreKit.Transaction.updates {
                    if let transaction = try? update.payloadValue {
                        await fetchActiveTransactions()
                        await transaction.finish()
                    }
                }
            }
        }
        
        deinit {
            updates?.cancel()
        }
    }
    

StoreKit 2 provides an easy way to fetch all active subscriptions and
purchased products. The _currentEntitlements_ property on _Transaction_ type
lists all the active subscriptions and not refunded products.

    
    
    @MainActor final class Store: ObservableObject {
        @Published private(set) var activeTransactions: Set<StoreKit.Transaction> = []
        // ...
        
        func fetchActiveTransactions() async {
            var activeTransactions: Set<StoreKit.Transaction> = []
            
            for await entitlement in StoreKit.Transaction.currentEntitlements {
                if let transaction = try? entitlement.payloadValue {
                    activeTransactions.insert(transaction)
                }
            }
            
            self.activeTransactions = activeTransactions
        }
    }
    

We can use the _currentEntitlements_ property to fetch all the active
purchases on every app launch or more often. By actively monitoring the
_currentEntitlements_ property we eliminate need for restoring purchases
because the _currentEntitlements_ always contains the latest list of active
subscriptions and non-consumable purchases even if they purchased on another
device.

    
    
    @main
    struct MyApp: App {
        @Environment(\.scenePhase) private var scenePhase
        @StateObject private var store = Store()
        
        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environmentObject(store)
                    .task(id: scenePhase) {
                        if scenePhase == .active {
                            await store.fetchActiveTransactions()
                        }
                    }
            }
        }
    }
    

Today we started the series of posts about StoreKit 2. As you can see, it is
really easy to use and it handle a bunch of use-cases out of the box for you.
I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!

  1. Mastering StoreKit 2 
  2. [ Mastering StoreKit 2. ProductView and StoreView in SwiftUI. ](/2023/08/08/mastering-storekit2-productview-in-swiftui/)
  3. [ Mastering StoreKit 2. SubscriptionStoreView in SwiftUI ](/2023/08/23/mastering-storekit2-subscriptionstoreview-in-swiftui/)
  4. [ Mastering StoreKit 2. SwiftUI view modifiers. ](/2023/08/29/mastering-storekit2-swiftui-view-modifiers/)
  5. [ StoreKit testing in Swift ](/2024/01/09/storekit-testing-in-swift/)



# Hero animations in SwiftUI

##  Hero animations in SwiftUI

17 Dec 2020

Animation is one of the powerful features of SwiftUI. I was shocked when I saw
how easy we could animate changes in view hierarchy by simply mutating
_@State_ properties and attaching animation modifiers. This week we will talk
about another animation type called hero animation. We will learn how we can
implement hero animations using the new _matchedGeometryEffect_ view modifier.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Assume that we are working on an app that shows a grid of images. You can
select an image by tapping on it. On the bottom of the screen, we have another
grid that shows only selected images. Let’s start implementing this app
example.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var allImages = [
            "heart.fill",
            "bandage.fill",
            "cross.fill",
            "bed.double.fill",
            "cross.case.fill",
            "pills.fill"
        ]
        
        @State private var selectedImages: [String] = []
    
        var body: some View {
            VStack {
                Text("All images")
                    .font(.headline)
                allImagesView
    
                Spacer()
    
                Text("Selected images")
                    .font(.headline)
                selectedImagesView
            }
        }
    }
    

Here we have a view that defines the list of images and the empty list of
selected images. We also structured our view’s body to place the list of
available images on the top and the list of selected images on the bottom of
the screen. Let’s move forward and implement a grid that displays our images.

    
    
    // ContentView.swift
    private var allImagesView: some View {
        LazyVGrid(columns: [.init(.adaptive(minimum: 44))]) {
            ForEach(allImages, id: \.self) { image in
                Image(systemName: image)
                    .resizable()
                    .frame(width: 44, height: 44)
                    .onTapGesture {
                        withAnimation {
                            allImages.removeAll { $0 == image }
                            selectedImages.append(image)
                        }
                    }
            }
        }
    }
    

As you can see in the example above, we have a grid with a single adaptive
column displaying squared images of 44pt. We also attach a tap gesture to
every image that removes the image from the list and moves it to the selected
image list. We wrap this mutation using the _withAnimation_ function, which
animates this change.

> To learn more about grids, look at my [ “Mastering grids in SwiftUI”
> ](/2020/07/08/mastering-grids-in-swiftui/) post.
    
    
    // ContentView.swift
    private var selectedImagesView: some View {
        LazyVGrid(columns: [.init(.adaptive(minimum: 88))]) {
            ForEach(selectedImages, id: \.self) { image in
                Image(systemName: image)
                    .resizable()
                    .frame(width: 88, height: 88)
                    .onTapGesture {
                        withAnimation {
                            selectedImages.removeAll { $0 == image }
                            allImages.append(image)
                        }
                    }
            }
        }
    }
    

Here is the source code of the selected images grid, which looks very similar
to the previous one. There are two differences. The first one is the size of
the images. Here we use 88pt instead of 44pt. The second difference is the tap
gesture. In this case, we move an image from the list of the selected image to
the all images list.

By default, SwiftUI uses fade-in and fade-out transitions to animate layout
changes. For example, when you remove a view from a view hierarchy, SwiftUI
uses a fade-out transition. You can change this behavior by adding a
_transition_ modifier to the view and providing another transition.

> If you are not familiar with transitions in SwiftUI, take a look at my [
> “Animations in SwiftUI” ](/2019/06/26/animations-in-swiftui/) post.

![fading-animation](/public/hero1.mp4)

As you can see here, SwiftUI removes the image you tap using fade-out
transition and adds it to another grid using fade-in transition. Now, it is
time to talk about hero animations.

Hero animation is a special effect in motion pictures and animations that
changes one image into another through a seamless transition. For example, we
want to achieve a morphing animation while moving an image from top to bottom
by applying the scaling transformation.

Fortunately, SwiftUI provides us a special view modifier called
_matchedGeometryEffect_ to implement hero animations easily. By attaching
_matchedGeometryEffect_ to multiple views, we define a connection between
them. SwiftUI can use this connection to understand the geometry of transition
and automatically apply shape, position, and size transformation between these
changes.

    
    
    // ContentView.swift
    @Namespace private var imageEffect
    
    private var allImagesView: some View {
        LazyVGrid(columns: [.init(.adaptive(minimum: 44))]) {
            ForEach(allImages, id: \.self) { image in
                Image(systemName: image)
                    .resizable()
                    .matchedGeometryEffect(id: image, in: imageEffect)
                    .frame(width: 44, height: 44)
                    .onTapGesture {
                        withAnimation {
                            allImages.removeAll { $0 == image }
                            selectedImages.append(image)
                        }
                    }
            }
        }
    }
    
    private var selectedImagesView: some View {
        LazyVGrid(columns: [.init(.adaptive(minimum: 88))]) {
            ForEach(selectedImages, id: \.self) { image in
                Image(systemName: image)
                    .resizable()
                    .matchedGeometryEffect(id: image, in: imageEffect)
                    .frame(width: 88, height: 88)
                    .onTapGesture {
                        withAnimation {
                            selectedImages.removeAll { $0 == image }
                            allImages.append(image)
                        }
                    }
            }
        }
    }
    

As you can see, we attach _matchedGeometryEffect_ view modifier by passing a
unique identifier and namespace. SwiftUI uses these parameters to identify
views in the view hierarchy and understand layout changes.

If inserting a view in the same transaction that another view with the same
identifier is removed, the system will interpolate their frame rectangles in
window space to make it appear that a single view moves from its old position
to its new position. Remember that you should use unique identifiers for every
view that applies a matched geometry effect.

![hero-animation](/public/hero2.mp4)

####  Conclusion

Today we learned about implementing hero animations in SwiftUI using the
_matchedGeometryEffect_ view modifier. I love how easy we can achieve this
effect in SwiftUI. Unfortunately, it doesn’t work between different views
inside navigation links, but I hope to see this working during the next
iteration of SwiftUI. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
article. Thanks for reading, and see you next week!



# Discovering Swift Algorithms package

##  Discovering Swift Algorithms package

13 Feb 2024

Almost every app I built and supported includes the Swift Algorithms package.
However, I noticed that only some developers are familiar with it. Today, we
will discover what the Swift Algorithms package offers us to write better,
safer code for complex algorithms.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Reason

You can write every algorithm from the Swift Algorithms package, but you must
maintain and test it in this case. On the other hand, you can depend on the
ready-to-use package that you can include in every app you work on without
code duplication and be sure that the community members well-tested the
package.

> Remember, you can always become a part of this great community by
> contributing to this package.

####  Setup

First, you must add the package to the project in the Xcode project settings
screen. The “Package Dependencies” tab allows you to add or remove any package
you need. The [ Swift Algorithms ](https://github.com/apple/swift-algorithms)
package lives on Github, where you can easily follow updates, browse pull
requests, and monitor issues.

The Swift Algorithms package contains tons of valuable collections and
sequence algorithms. It is nearly impossible to cover them as part of a single
post, but I will cover my favorite things.

####  Binary search

I mainly work on health-related apps, and my users’ privacy is crucial to me.
That’s why I make all of my calculations on the devices. Searching a massive
array of health-related data for a particular item is a common task.

As you may know, the binary search is the best way to find an item in the
sorted data array. Usually, we query HealthKit for sorted data, allowing us to
use binary search efficiently. Binary search requires your data to be sorted
by the key you seek.

    
    
    let someDate = Date.now
    let index = heartRates.partitioningIndex { $0.startDate >= someDate }
    
    guard
        index != heartRates.endIndex,
        heartRates[index].startDate == someDate
    else {
        return nil
    }
    
    return heartRates[index]
    

The Swift Algorithms package provides the _partitioningIndex_ function, the
generalized version of the binary search. It uses the same logic as the binary
search.

Still, instead of returning an item, it returns the index of the first item,
dividing your collection into two parts where any item from the first part
returns false for your predicate, and any item from the second part always
returns true for the same predicate.

We must wrap its results with an additional guard statement verifying them.
Whenever the _partitioningIndex_ function can’t find the relevant index, it
returns the end of the collection.

We also verify that the resulting index divides the array into two partitions,
and an item for the index also equals the item we are looking for. There might
be a case where you can find an index dividing the array using your predicate,
but the array doesn’t contain the value you want.

####  Chunking

Dividing a collection into chunks is another common task in my apps. You might
need to divide the collection into chunks of any count or by any additional
logic. The Swift Algorithms package provides us with chunking API for this
particular case.

    
    
    let numbers = [1, 2, 3, 4, 5, 6]
    print(numbers.chunks(ofCount: 2))
    // [1, 2]
    // [3, 4]
    // [5, 6]
    

The Swift Algorithms package provides the _chunks_ function, taking a count of
items in a single chunk as the parameter and returning the subsequence array.

My app has a more interesting situation where the particular logic should
drive chunking. In my case, I need the chunks where items have time intervals
between them no longer than one hour.

    
    
    sleepSamples.chunked { $1.startDate.timeIntervalSince($0.endDate) < 3600 }
    

As you can see in the example above, we use the _chunked_ function with the
predicate, where we can compare two adjacent elements of the collection and
decide whenever we want to put them into the same chunk.

####  Filtering

Almost every app has a situation where you have a collection with optional
values, and you need to keep only non-nil values. For this case, the Swift
Algorithms package introduces the _compacted_ functions.

    
    
    let array: [Int?] = [10, nil, 30, nil, 2, 3, nil, 5]
    let withNoNils = array.compacted()
    // Array(withNoNils) == [10, 30, 2, 3, 5]
    

Another common task is to remove the duplicates from a collection of elements,
and you can easily do it with the help of the _uniqued_ function.

    
    
    let numbers = [1, 2, 3, 3, 2, 3, 3, 2, 2, 2, 1]
    let unique = numbers.uniqued()
    // Array(unique) == [1, 2, 3]
    

####  Sampling

Another situation I came across in my apps is extracting some number of
minimal or maximal elements from the collection. You can easily do that with
the Swift Algorithms package’s _min_ , _max_ , or _minAndMax_ functions.

    
    
    let numbers = [7, 1, 6, 2, 8, 3, 9]
    let smallestThree = numbers.min(count: 3)
    // [1, 2, 3]
    
    let numbers = [7, 1, 6, 2, 8, 3, 9]
    let largestThree = numbers.max(count: 3)
    // [7, 8, 9]
    

How often do you need to get the particular count of the random elements from
the collection? The Swift Algorithms package has the _randomSample_ function,
taking the _count_ as a single parameter and returning an array of the random
elements.

    
    
    let numbers = [7, 1, 6, 2, 8, 3, 9]
    let randomNumbers = numbers.randomSample(count: 3)
    

####  Combinations

The Swift Algorithms package provides us with the _combinations_ function,
allowing us to combine every element of the collection with each other.

    
    
    let colors = ["fuchsia", "cyan", "mauve", "magenta"]
    for combo in colors.combinations(ofCount: 3) {
        print(combo.joined(separator: ", "))
    }
    // fuchsia, cyan, mauve
    // fuchsia, cyan, magenta
    // fuchsia, mauve, magenta
    // cyan, mauve, magenta
    

As you can see in the example above, the _combinations_ function takes only
one parameter, defining the number of elements that it should use per
combination.

####  Conclusion

Today, we discovered only the visible part of Swift Algorithms iceberg. There
are many things to learn, and I encourage you to check its documentation and
replace your custom implementation with it. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Functional core Imperative shell in Swift. Unidirectional Flow.

##  Functional core Imperative shell in Swift. Unidirectional Flow.

16 Mar 2022

A few weeks ago, we talked about the idea of Functional core and Imperative
shell in Swift. The goal is to extract the pure logic using value types and
keep side effects in the thin object layer. This week, we will look at how we
can apply this approach in an opinionated way by using unidirectional flow.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Functional Core

The functional core is the layer responsible for all the logic in our app that
we want to verify using unit tests. It should be pure, without any side
effects. We want to provide the input and verify the output. Usually, the
implementation of unidirectional flow requires many reducer functions that
accept the state and action and return a new state. Let’s define the reducer
function in code.

> If you are not familiar with the idea of unidirectional flow, I highly
> encourage you to read my series of posts about [ “Redux-like state container
> in SwiftUI” ](/2019/09/18/redux-like-state-container-in-swiftui/) .
    
    
    typealias Reducer<State, Action> = (State, Action) -> State
    

As you can see, the reducer function takes the current state and action to
apply on that state and returns a new state. I’m working on the app for
intermittent fasting tracking. Let’s take a look at how I could implement the
timer logic.

    
    
    struct TimerState: Equatable {
        var start: Date?
        var end: Date?
        var goal: TimeInterval
    }
    
    enum TimerAction {
        case start
        case finish
        case reset
    }
    
    let timerReducer: Reducer<TimerState, TimerAction> = { state, action in
        var state = state
    
        switch action {
        case .start:
            state.start = .now
        case .finish:
            state.end = .now
        case .reset:
            state.start = nil
            state.end = nil
        }
    
        return state
    }
    

Here is the real example from my codebase implementing timer management logic.
As you can see, it is pure and doesn’t have any side effects. It allows me to
quickly verify the logic using unit tests without mocks and stubs.

    
    
    import XCTest
    
    final class TimerReducerTests: XCTestCase {
        func testStart() {
            let state = TimerState(goal: 13 * 3600)
            XCTAssertNil(state.start)
            let newState = timerReducer(state, .start)
            XCTAssertNotNil(newState.start)
        }
    }
    

Value types like structs and enums are great tools for implementing app logic
in a pure and very testable. But we still need side effects. For example, I
want to share the timer state with my friends using CloudKit.

####  Imperative Shell

The imperative shell is the object layer holding the app’s state represented
by a value type. We also utilize the object layer to make side-effects and
apply results on top of the state. Let’s start by defining a generic object
that holds the state.

    
    
    @MainActor public final class Store<State, Action>: ObservableObject {
        @Published public private(set) var state: State
    
        private let reducer: Reducer<State, Action>
    
        public init(
            initialState state: State,
            reducer: @escaping Reducer<State, Action>
        ) {
            self.reducer = reducer
            self.state = state
        }
    
        public func send(_ action: Action) {
            state = reducer(state, action)
        }
    }
    

Here is the imperative shell defined using the _Store_ class. As you can see,
we use the object layer to hold the app state represented by a value type.
Object layer allows us to share the state of the app and make it a single
source of truth. We also provide thread safety by utilizing the _MainActor_
and allowing mutations only by feeding actions into the store using the _send_
method on _Store_ type. This is how we implement unidirectional flow with the
idea of Functional core and Imperative shell. But we still miss side effects.

####  Side effects

The imperative shell should provide us with a way to make side effects. We
should separate side effects from the pure logic of our app, but we still want
to test side effects using integration tests. Let’s introduce a new type
called _Middleware_ that defines a side effect handler.

    
    
    typealias Middleware<State, Action, Dependencies> =
        (State, Action, Dependencies) async -> Action?
    

The main idea behind the _Middleware_ type is to intercept pure actions, make
side effects like async requests, and return a new action that we can feed
into the store and reduce. Let’s add this functionality to the _Store_ type.

    
    
    @MainActor public final class Store<State, Action, Dependencies>: ObservableObject {
        @Published public private(set) var state: State
    
        private let reducer: Reducer<State, Action>
        private let dependencies: Dependencies
        private let middlewares: [Middleware<State, Action, Dependencies>]
    
        public init(
            initialState state: State,
            reducer: @escaping Reducer<State, Action>,
            dependencies: Dependencies,
            middlewares: [Middleware<State, Action, Dependencies>] = []
        ) {
            self.reducer = reducer
            self.state = state
            self.dependencies = dependencies
            self.middlewares = middlewares
        }
    
        public func send(_ action: Action) async {
            state = reducer(state, action)
    
            await withTaskGroup(of: Optional<Action>.self) { [state, dependencies] group in
                for middleware in middlewares {
                    group.addTask {
                        await middleware(state, action, dependencies)
                    }
                }
    
                for await case let action? in group {
                    await send(action)
                }
            }
        }
    }
    

As you can see, we use the new Swift concurrency feature to implement async
work inside the _Store_ type. It allows us to run our side effects in parallel
and feed the actions into the store. We secure access to our state by marking
the _Store_ type with _@MainActor_ . Using the _TaskGroup_ , we automatically
gain the cooperative cancellation of side effects. The _Store_ type also holds
all the dependencies like networking, notification center, etc., to provide
them to middlewares.

    
    
    struct TimerState: Equatable {
        var start: Date?
        var end: Date?
        var goal: TimeInterval
        var sharingStatus = SharingStatus.notShared
    }
    
    enum SharingStatus: Equatable {
        case shared
        case uploading
        case notShared
    }
    
    enum TimerAction: Equatable {
        case start
        case finish
        case reset
        case share
        case setSharingStatus(SharingStatus)
    }
    
    let timerReducer: Reducer<TimerState, TimerAction> = { state, action in
        var state = state
    
        switch action {
        case .start:
            state.start = .now
        case .finish:
            state.end = .now
        case .reset:
            state.start = nil
            state.end = nil
        case .share:
            state.sharingStatus = .uploading
        case let .setSharingStatus(status):
            state.sharingStatus = status
        }
    
        return state
    }
    
    struct TimerDependencies {
        let share: (Date, Date?) async throws -> Void
    }
    
    let timerMiddleware: Middleware<TimerState, TimerAction, TimerDependencies> = { state, action, dependencies in
        switch action {
        case .share:
            guard let start = state.start else {
                return .setSharingStatus(.notShared)
            }
    
            do {
                try await dependencies.share(start, state.end)
                return .setSharingStatus(.shared)
            } catch {
                return .setSharingStatus(.notShared)
            }
        default:
            return nil
        }
    }
    
    import XCTest
    
    final class TimerMiddlewareTests: XCTestCase {
        func testSharing() async throws {
            let state = TimerState(goal: 13 * 3600)
            let dependencies: TimerDependencies = .init { _, _ in }
            let action = await timerMiddleware(state, .share, dependencies)
            XCTAssertEqual(action, .setSharingStatus(.shared))
        }
    }
    

> To learn more about using async closures as dependencies, take a look at my
> [ “Microapps architecture in Swift. Dependency Injection”
> ](/2022/02/02/microapps-architecture-in-swift-dependency-injection/) post.

And here is the example code showing how to implement a middleware. As you can
see, we intercept the action feed into the store, make an async request, and
provide another action to the system. We also can easily write integration
test by mocking _TimerDependencies_ type.

    
    
    import SwiftUI
    
    struct RootView: View {
        @StateObject var store = Store(
            initialState: TimerState(goal: 13 * 3600),
            reducer: timerReducer,
            dependencies: TimerDependencies.production
        )
    
        var body: some View {
            NavigationView {
                VStack {
                    if let start = store.state.start, store.state.end == nil {
                        Text(start, style: .timer)
                        
                        Button("Stop") {
                            Task { await store.send(.finish) }
                        }
    
                        Button("Reset") {
                            Task { await store.send(.reset) }
                        }
                    } else {
                        Button("Start") {
                            Task { await store.send(.start) }
                        }
                    }
                }
                .navigationTitle("Timer")
                .toolbar {
                    ToolbarItem(placement: .primaryAction) {
                        Button("Share") {
                            Task {
                                await store.send(.share)
                            }
                        }
                    }
                }
            }
        }
    }
    

####  Conclusion

I use the idea of Functional core and Imperative shell in two of my apps and
enjoy the infrastructure it provides me. I hope you enjoy the post. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!

####  References

  1. [ swift-unidirectional-flow ](https://github.com/mecid/swift-unidirectional-flow) \- Unidirectional flow implemented using the latest Swift Generics and Swift Concurrency features. 
  2. [ “Boundaries”, a talk by Gary Bernhardt from SCNA 2012 ](https://www.destroyallsoftware.com/talks/boundaries)
  3. [ Functional core Imperative shell in Swift ](/2022/03/01/functional-core-imperative-shell-in-swift/)
  4. [ Functional Core Reactive Shell ](https://mokacoding.com/blog/functional-core-reactive-shell/)
  5. [ Writing idiomatic Swift code ](/2021/04/01/writing-idiomatic-swift-code/)



# The power of Environment in SwiftUI

##  The power of Environment in SwiftUI

21 Aug 2019

_Environment_ is one of the unique features of SwiftUI which we didn’t have
before in _UIKit_ . Today I would like to show you all the benefits of using
_Environment_ in your apps.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Environment

Let’s start with describing the idea of _Environment_ . We already discussed
it previously in [ “Understanding Property Wrappers in SwiftUI”
](/2019/06/12/understanding-property-wrappers-in-swiftui/) , but I want to
start with basics. When you create and start your very first _View_ in
SwiftUI, the framework generates _Environment_ for it. SwiftUI creates it
automatically, and we don’t need to do something.

SwiftUI uses _Environment_ to pass system-wide settings like
_ContentSizeCategory, LayoutDirection, ColorScheme, etc_ . _Environment_ also
contains app-specific stuff like _UndoManager_ and _NSManagedObjectContext_ .
Full list of the passed values you can find in [ _EnvironmentValues_ struct
documentation
](https://developer.apple.com/documentation/swiftui/environmentvalues) . Let’s
take a look at an example where we access _Environment_ values.

    
    
    struct ButtonsView: View {
        @Environment(\.sizeCategory) var sizeCategory
    
        var body: some View {
            Group {
                if sizeCategory == .accessibilityExtraExtraExtraLarge {
                    VStack {
                        buttons
                    }
                } else {
                    HStack {
                        buttons
                    }
                }
            }
        }
    }
    

By using @ _Environment property wrapper_ , we can read and subscribe on
changes for the selected value. Here we have _ButtonsView_ that reads Dynamic
Type value from _Environment_ and put buttons in _VStack_ or _HStack_
depending on the size category value. User can change Dynamic Type value in
the system settings, and as soon as it happens, SwiftUI will recreate
_ButtonsView_ to respect the changes.

Now let’s see how we can modify _Environment_ values. In SwiftUI we don’t have
separation like _Controllers_ or _Views_ . Everything is a _View_ , and
because of that, we can easily modify _Environment_ for an entire view
hierarchy of the app by adding _environment modifier_ to the root view.

    
    
    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
            window = UIWindow(windowScene: scene as! UIWindowScene)
            window?.rootViewController = UIHostingController(
                rootView: RootView()
                    .environment(\.multilineTextAlignment, .center)
                    .environment(\.lineLimit, nil)
                    .environment(\.lineSpacing, 8)
            )
    
            window?.makeKeyAndVisible()
        }
    

In the example above, we made all the text in the app center-aligned with line
spacing 8pt without any line limit.

####  Environment inheritance

Every view inside SwiftUI inherits _Environment_ from its parent view by
default. But remember that you can override any values you want while creating
the child view by attaching _Environment_ modifier.

    
    
    struct RootView {
        var body: some View {
            PlayerView()
                .environment(\.layoutDirection, .leftToRight)
        }
    }
    
    struct PlayerView: View {
        var body: some View {
            HStack {
                Button("previous") {
    
                }
                Button("play") {
    
                }
                Button("next") {
    
                }
            }
        }
    }
    

We don’t need to change the order of the buttons on right-to-left locales like
Arabic. That’s why _RootView_ set layout direction to _leftToRight_ on
_PlayerView_ . It’s important to understand that this modification will apply
only to _PlayerView_ and all its child views.

####  View specific Environment values

We already covered how SwiftUI pass system-wide settings via _Environment_ ,
but this is not the end. SwiftUI uses _Environment_ to inject visible view
specific values like _isEnabled, editMode, presentationMode,
horizontalSizeClass, verticalSizeClass, etc._

    
    
    struct ModalView: View {
        @Environment(\.presentationMode) var presentation
    
        var body: some View {
            Button("dismiss") {
                self.presentation.value.dismiss()
            }
        }
    }
    

Here we use view-specific environment values to dismiss presented modal view.

####  Custom Environment keys

Now we know that SwiftUI provides us plenty of system-wide and view-specific
values via the environment. However, I have to mention that we can create a
custom environment key and push any value we want into the environment. Let’s
take a look at how we can insert custom values into the environment.

    
    
    import SwiftUI
    
    struct ItemsPerPageKey: EnvironmentKey {
        static var defaultValue: Int = 10
    }
    
    extension EnvironmentValues {
        var itemsPerPage: Int {
            get { self[ItemsPerPageKey.self] }
            set { self[ItemsPerPageKey.self] = newValue }
        }
    }
    
    struct RelatedProductsView: View {
        @Environment(\.itemsPerPage) var count
    
        let products: [Product]
    
        var body: some View {
            ForEach(products[..<count], id: \.id) { product in
                Text(product.title)
            }
        }
    }
    

In the example above, we create a custom key that represents a count of items
that can be presented on a screen. We also implement a view that uses that
environment value. You can easily pass that value to any view you want by
using the _environment modifier_ .

####  Dependency Injection via Environment

Another great use-case for _Environment_ is Dependency Injection. Every view
has its copy of the parent’s _Environment_ , and we can use it to add all
_ObservableObjects_ related to the current view.

    
    
    struct CalendarView : View {
        @EnvironmentObject var store: CalendarStore
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(self.store.sleeps) { sleep in
                        NavigationLink(
                            destination: SleepDetailsView()
                                .environmentObject(SleepStore(sleep: sleep))
                        ) {
                            CalendarRow(sleep: sleep)
                        }
                    }
                }
            }.navigationBarTitle("calendar")
        }
    }
    

In the example above, we use _environmentObject_ modifier to pass an instance
of _SleepStore_ object. _SleepStore_ should conform to _ObservableObject_
protocol, which is used by SwiftUI to recreate the view during data changes.

> To learn more about _ObservableObject_ check another post [ “Making real-
> world app with SwiftUI” ](/2019/06/05/swiftui-making-real-world-app/) .

The significant benefit of using _Environment_ and not passing
_ObservableObject_ via the _init_ method of the view is the internal SwiftUI
storage. SwiftUI stores _Environment_ in the special framework memory outside
the view. It gives an implicit access to view-specific _Environment_ for all
child views.

####  Conclusion

As much as I use SwiftUI, I enjoy the concept of _Environment_ . As you can
see, it allows us to configure our app’s view hierarchy and make nice
Dependency Injection out of the box. I hope you will love _Environment_
feature of SwiftUI. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# Asynchronous completion handlers with Result type

##  Asynchronous completion handlers with Result type

17 Apr 2019

[ Enums are one of my favorite features in Swift language.
](/2019/01/23/maintaining-state-in-view-controllers/) This week we will talk
about Result enum, which had been a part of the standard library since Swift
5. With Result enum, we can easily describe the resulting state of an
asynchronous operation. It can be success or failure at one time not both of
them. Let’s take a look at Result enum definition in the Swift standard
library.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

    
    
    public enum Result<Success, Failure> where Failure : Error {
        case success(Success)
        case failure(Failure)
    

Result type described as two case enum, which has success and failure cases.
Both of them have generic associated types, while Failure type is constrained
to conform Error protocol, Success type can be anything that we want to return
as a proper result of our operation. Let’s take a look at completion handler
in the URLSession’s dataTask function which passes both data and error to the
handler.

    
    
    URLSession.shared.dataTask(with: API.history) { data, _ , error in
    }
    

The downside of this approach is the undefined state where we have both data
and error in the completion handler. So let’s clarify completion handler by
using Result type instead.

    
    
    typealias Handler<T> = (Result<T, Error>) -> Void
    
    extension URLSession {
        func dataTask(with url: URL, completionHandler: @escaping Handler<Data>) {
            dataTask(with: url) { data, _, error in
                if let error = error {
                    completionHandler(.failure(error))
                } else {
                    completionHandler(.success(data ?? Data()))
                }
            }
        }
    }
    

Here we have an extension on the URLSession class which adds dataTask method
overload. Instead of passing both data and error, we give the instance of
Result enum which stores data value or error. I am using Result enum in many
places across my codebase, that’s why I created type alias for Handler type
which is closure with a generic Result as a parameter. Let’s move to the usage
of our new extension.

    
    
    class HistoryService {
        private let session: URLSession
        private let decoder: JSONDecoder
    
        init(session: URLSession, decoder: JSONDecoder) {
            self.session = session
            self.decoder = decoder
        }
    
        func fetch(handler: @escaping Handler<History>) {
            session.dataTask(with: API.history) { [weak self] result in
                guard let self = self else { return }
    
                do {
                    let data = try result.get()
                    let user = try self.decoder.decode(History.self, from: data)
                    handler(.success(user))
                } catch {
                    handler(.failure(error))
                }
            }
        }
    }
    

In the code samples above we have a HistoryService class which uses URLSession
to fetch data and deserialize it into History structure instance. Result type
provides the particular _get_ method which tries to return the value of Result
enum or throws the error. I feel like I have a lot of places across my
codebase where I need to fetch data and deserialize into some structure. We
can easily create another extension, this time extension on Result type.

    
    
    extension Result where Success == Data {
        func decode<T: Decodable>(with decoder: JSONDecoder = .init()) -> Result<T, Error> {
            do {
                let data = try get()
                let decoded = try decoder.decode(T.self, from: data)
                return .success(decoded)
            } catch {
                return .failure(error)
            }
        }
    }
    

The extension which we have above tries to decode data into decodable generic
by returning value wrapped into Result type or by returning failure with
error. Here is the new version of the HistoryService which uses our extension.
One of the benefits here is the type inference, which saves us from indicating
type in which we are going to decode data. Decode function uses generic
constraint which infers from the completion handler definition. Now it looks
in a very nice way.

    
    
    func fetch(handler: @escaping Handler<History>) {
        session.dataTask(with: API.history) { result in
            handler(result.decode())
        }
    }
    

####  Conclusion

This week we talked about Result type which comes with Swift 5 standard
library. It helps us to make our codebase cleaner and easy to understand. I
think it is a perfect time to move our asynchronous code to use Result enum
for completion handlers. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# Alignment guides in SwiftUI

##  Alignment guides in SwiftUI

11 Mar 2020

This week we will talk about another great tool that we have in SwiftUI. The
alignment guide is a way that we can use to speak to SwiftUI’s layout system.
By using alignment guides, we can easily align views that live in different
parts of a view hierarchy.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

SwiftUI provides us a few container views that we can use to build our layout.
You might already be familiar with _VStack, HStack, and ZStack_ . All of these
container views use alignments to regulate the position of child views inside
the container. Let’s take a look at the very basic example.

    
    
    VStack(alignment: .leading) {
        Text("Toronto")
        Text("Paris")
        Text("London")
        Text("Madrid")
    }
    

In the example above, we have a vertical container view that displays child
views from the top to bottom. We set alignment to leading, and it means that
_VStack_ will use the leading point of every child view to align them.

_VStack_ uses _HorizontalAlignment_ enum to define possible alignments. On the
other hand, _HStack_ uses _VerticalAlignment_ enum. It might be strange, but
after all, it is logical. We can set the alignment of _VStack_ only in the
horizontal way because the container view controls the vertical direction.
_ZStack_ uses _Alignment_ enum, which is the combination of
_HorizontalAlignment_ and _VerticalAlignment_ enums.

####  Overriding alignment guides

SwiftUI allows us to override standard alignments by using the
_alignmentGuide_ modifier. For example, we might need to align the bottom of
_Image_ and _Text_ views in a horizontal stack. We can face the problem when
image has some spacing inside a bitmap, and it looks not aligned very well.
This is a perfect case for overriding an alignment guide.

    
    
    struct ContentView: View {
        var body: some View {
            HStack(alignment: .bottom) {
                Image(systemName: "zzz")
                    .alignmentGuide(.bottom) { d in d[.bottom] + 8 }
                Text("Sleep")
            }
        }
    }
    

As you can see in the example above, we use _alignmentGuide_ modifier to
override the default value for . _bottom_ alignment by adding 8 points. We
read the default value by using subscript of **d** , which is an instance of
_ViewDimensions_ struct. _ViewDimensions_ struct provides us access to the
width and height of the view and default alignment values by using a
subscript.

####  Custom alignment guides

We learned how to override default alignments in SwiftUI, but SwiftUI also
allows us to create a custom alignment guide that we can use in container
views to align its child views. But why we might need it? Custom alignments
allow us to align views that live in different container views. Let’s take a
look at the example below.

    
    
    struct ContentView: View {
        var body: some View {
            HStack(alignment: .center) {
                Image(systemName: "star")
                VStack(alignment: .center) {
                    Text("Toronto")
                    Text("Paris")
                    Text("London")
                    Text("Madrid")
                }
            }
        }
    }
    

We have a horizontal stack that contains an image and vertical stack with a
few text views. I might need to align the image with the third text view, but
it doesn’t look possible with the current configuration, because these views
live in different containers. Fortunately, SwiftUI allows us to create a
custom alignment and use it in the parent container view.

    
    
    extension VerticalAlignment {
        struct CustomAlignment: AlignmentID {
            static func defaultValue(in context: ViewDimensions) -> CGFloat {
                return context[VerticalAlignment.center]
            }
        }
    
        static let custom = VerticalAlignment(CustomAlignment.self)
    }
    
    struct ContentView: View {
        var body: some View {
            HStack(alignment: .custom) {
                Image(systemName: "star")
                VStack(alignment: .leading) {
                    Text("Toronto")
                    Text("Paris")
                    Text("London")
                        .alignmentGuide(.custom) { $0[VerticalAlignment.center] }
                    Text("Madrid")
                }
            }
        }
    }
    

In the example above, we use _AlignmentID_ protocol to create a custom
alignment. This protocol has the only requirement that we need to provide.
SwiftUI will use the _defaultValue_ whenever we leave it without custom value.
The interesting fact is that the inner _VStack_ didn’t specify a value for
custom alignment, but it uses the value that provides its child view.

![align](/public/align.png)

####  Conclusion

Today we learned how powerful could be custom alignments in SwiftUI. We also
can use the overriding alignment technique to build super custom layouts. For
example, we can build a grid view that arranges child views using alignments.
I suggest you play around alignments to understand it well. It is something
that can take time. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Keyboard shortcuts in SwiftUI

##  Keyboard shortcuts in SwiftUI

17 Nov 2020

This year Apple released the new App Lifecycle API for SwiftUI, which brings
tons of new modifiers to replace _AppDelegate_ callbacks. I have already
covered most of them in previous posts. This week, we will discuss the new
_keyboardShortcut_ modifier, which allows us to assign a shortcut to any
interacting view.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

SwiftUI provides us the _keyboardShortcut_ modifier that we can attach to any
view in the view hierarchy and define a keyboard shortcut. Pressing the
defined keyboard shortcut is the equivalent to direct interaction with the
view to perform its primary action. Let’s take a look at the example.

> To learn more about new App Lifecycle API, take a look at [ “Managing app in
> SwiftUI” ](/2020/08/19/managing-app-in-swiftui/) post.
    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            Button("Print message") {
                print("Hello World!")
            }.keyboardShortcut("p", modifiers: [.command, .shift])
        }
    }
    

As you can see in the example above, we assign a keyboard shortcut to the
button. We define it by using _keyboardShortcut_ modifier and passing the “p”
key equivalent and a list of modifier keys. A modifier key is an instance of
_EventModifiers_ struct that conforms to _OptionSet_ protocol and defines keys
like shift, command, control, option, etc. You can ignore the key modifier
parameter, and in this case, SwiftUI will use the command modifier by default.

> To learn more about _OptionSet_ in Swift, look at my [ “Inclusive enums with
> OptionSet” ](/2019/04/10/inclusive-enums-with-optionset/) post.

This first parameter of _keyboardShortcut_ modifier should be an instance of
_KeyEquivalent_ struct. _KeyEquivalent_ struct conforms to
_ExpressibleByExtendedGraphemeClusterLiteral_ protocol, which allows us to
create an instance of the _KeyEquivalent_ using a string literal containing
only one character. _KeyEquivalent_ also defines a few key symbols like
arrows, escape, delete, home, etc.

Remember that you have to press the “Capture Keyboard” button in the simulator
chrome to test keyboard shortcuts on a simulator.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var isEnabled = false
    
        var body: some View {
            Toggle(isOn: $isEnabled) {
                Text(String(isEnabled))
            }.keyboardShortcut("t")
        }
    }
    

I have to mention that _keyboardShortcut_ is a view modifier, and you can
apply it to any SwiftUI view. In the example above, we define a keyboard
shortcut on the toggle view. By pressing this shortcut, we interact with the
toggle and switch its value.

> To learn more about view modifiers, take a look at my [ “ViewModifiers in
> SwiftUI” ](/2019/08/07/viewmodifiers-in-swiftui/) post.

You can also attach the _keyboardShortcut_ modifier to any container view like
_VStack_ or _HStack_ . In this case, the shortcut will apply to the first
interactive child in the container hierarchy.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var isEnabled = false
    
        var body: some View {
            VStack {
                Button("Print message") {
                    print("Hello World!")
                }
                
                Button("Delete message") {
                    print("Message deleted.")
                }
            }.keyboardShortcut("p")
        }
    }
    

####  Conclusion

This week we learned about implementing keyboard shortcuts in your SwiftUI
apps. Keyboard shortcuts can improve your app user experience in a great way.
It is effortless to implement in SwiftUI, and I believe you will not waste
your time and add it as soon as possible. I hope you enjoy the post. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this article. Thanks for reading, and see you next week!



# What is new in SwiftUI after WWDC 23

##  What is new in SwiftUI after WWDC 23

06 Jun 2023

WWDC 23 is here, so many things have changed and been added to the SwiftUI
framework. In this post, you can find the summary of the most significant
SwiftUI features available in the 5th iteration of the framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Data flow

Swift 5.9 introduced the macros feature, which became the heart of the SwiftUI
data flow. SwiftUI became Combine-free and uses the new Observation framework
now. The Observation framework provides us with the _Observable_ protocol that
we have to use to allow SwiftUI to subscribe to changes and update views.

    
    
    @Observable
    final class Store {
        var products: [String] = []
        var favorites: [String] = []
        
        func fetch() async {
            try? await Task.sleep(nanoseconds: 1_000_000_000)
            // load products
            products = [
                "Product 1",
                "Product 2"
            ]
        }
    }
    

You don’t need to conform to the _Observable_ protocol in your code. Instead,
you mark your type with the **@Observable** macro, which makes that
conformance to the _Observable_ protocol for you. You also don’t need the
_@Published_ property wrapper now because SwiftUI views automatically track
the changes in the available properties of any observable type.

    
    
    struct ProductsView: View {
        @State private var store = Store()
        
        var body: some View {
            List(store.products, id: \.self) { product in
                Text(verbatim: product)
            }
            .task {
                if store.products.isEmpty {
                    await store.fetch()
                }
            }
        }
    }
    

Previously, there were a bunch of property wrappers like _State_ ,
_StateObject_ , _ObservedObject_ , and _EnvironmentObject_ , which you should
understand when and why to use. Nowadays, state management has become much
more manageable. You will only use the _State_ property wrappers both for
value types like strings and integers and reference types conforming to the
_Observable_ protocol.

    
    
    struct FavoriteProductsView: View {
        let store: Store
        
        var body: some View {
            List(store.favorites, id: \.self) { product in
                Text(verbatim: product)
            }
        }
    }
    

In the example above, we have a view that accepts the _Store_ type. In the
previous iterations of the SwiftUI framework, we should mark it with the
_@ObservedObject_ property wrapper to subscribe changes. We don’t need it now
because SwiftUI views automatically track changes in the types conforming to
the _Observable_ protocol.

    
    
    struct EnvironmentViewExample: View {
        @Environment(Store.self) private var store
        
        var body: some View {
            Button("Fetch") {
                Task {
                    await store.fetch()
                }
            }
        }
    }
    
    struct ProductsView: View {
        @State private var store = Store()
        
        var body: some View {
            List(store.products, id: \.self) { product in
                Text(verbatim: product)
            }
            .task {
                if store.products.isEmpty {
                    await store.fetch()
                }
            }
            .toolbar {
                NavigationLink {
                    EnvironmentViewExample()
                } label: {
                    Text(verbatim: "Environment")
                }
            }
            .environment(store)
        }
    }
    

You can also use the _Environment_ property wrapper in pair with the
_environment_ view modifier to put the observable type into the SwiftUI
environment. There is no need to use the _@EnvironmentObject_ property wrapper
or the _environmentObject_ view modifier. The same _Environment_ property
wrapper works with the observable types now.

    
    
    struct BindanbleViewExample: View {
        @Bindable var store: Store
        
        var body: some View {
            List($store.products, id: \.self) { $product in
                TextField(text: $product) {
                    Text(verbatim: product)
                }
            }
        }
    }
    

You can use the new _Bindable_ property wrapper whenever you need to extract
_Binding_ from the observable type.

####  Animations

Animations always was the most vital part of the SwiftUI framework. It is
effortless to animate anything in SwiftUI, but previous framework versions
lack some features that we have now.

    
    
    struct AnimationExample: View {
        @State private var value = false
        
        var body: some View {
            Text(verbatim: "Hello")
                .scaleEffect(value ? 2 : 1)
                .onTapGesture {
                    withAnimation {
                        value.toggle()
                    } completion: {
                        print("Animation have finished")
                    }
                }
        }
    }
    

As you can see in the example above, we have the new version of the
_withAnimation_ function allowing us to provide an animation completion
handler. It is a great addition, and you can build phased animations now.

    
    
    enum Phase: CaseIterable {
        case start
        case loading
        case finish
        
        var offset: CGFloat {
            // Calculate offset for the particular phase
            switch self {
            case start: 100.0
            case loading: 0.0
            case finish: 50.0
            }
        }
    }
    
    struct PhasedAnimationExample: View {
        @State private var value = false
        
        var body: some View {
            PhaseAnimator(Phase.allCases, trigger: value) { phase in
                LoadingView()
                    .offset(x: phase.offset)
            } animation: { phase in
                switch phase {
                case .start: .easeIn(duration: 0.3)
                case .loading: .easeInOut(duration: 0.5)
                case .finish: .easeOut(duration: 0.1)
                }
            }
        }
    }
    

The SwiftUI framework introduces the new _PhaseAnimator_ view that iterates
over the sequence of phases, allows you to provide different animations for
every phase, and updates the content whenever phase changes. There is also the
_KeyframeAnimator_ view allowing us to animate changes with keyframes.

####  ScrollView

ScrollView has excellent additions this year. First, we can observe content
offset using the _scrollPosition_ view modifier.

    
    
    struct ContentView: View {
        @State private var scrollPosition: Int? = 0
        
        var body: some View {
            ScrollView {
                Button("Scroll") {
                    scrollPosition = 80
                }
                
                ForEach(1..<100, id: \.self) { number in
                    Text(verbatim: number.formatted())
                }
                .scrollTargetLayout()
            }
            .scrollPosition(id: $scrollPosition)
        }
    }
    

As you can see, we use the _scrollPosition_ view modifier to bind the content
offset to a state property. Whenever the user scrolls the view, it updates the
binding by setting the identity of the first visible view. You can also scroll
to any view by updating the binding programmatically. But remember that you
should use the _scrollTargetLayout_ view modifier to tell the SwiftUI
framework where to find identities to update the binding.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ForEach(1..<100, id: \.self) { number in
                    Text(verbatim: number.formatted())
                }
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.paging)
        }
    }
    

You can now change the scroll behavior by using the _scrollTargetBehavior_
view modifier. It allows you to enable paging in a scroll view.

####  Search

Search-related view modifiers have a few great additions too. For example, you
can programmatically focus on a search field.

    
    
    struct ProductsView: View {
        @State private var store = Store()
        @State private var query = ""
        @State private var scope: Scope = .default
        
        var body: some View {
            List(store.products, id: \.self) { product in
                Text(verbatim: product)
            }
            .task {
                if store.products.isEmpty {
                    await store.fetch()
                }
            }
            .searchable(text: $query, isPresented: .constant(true), prompt: "Query")
            .searchScopes($scope, activation: .onTextEntry) {
                Text(verbatim: scope.rawValue)
            }
        }
    }
    

As you can see in the example above, you can use the _isPresented_ parameter
of the _searchable_ view modifier to show/hide the search field. You can also
use the _activation_ parameter of the _searchScopes_ view modifier to define
scopes visibility logic.

####  New gestures

New _RotateGesture_ and _MagnifyGesture_ allow us to track the view’s rotation
and magnification.

    
    
    struct RotateGestureView: View {
        @State private var angle = Angle(degrees: 0.0)
    
        var rotation: some Gesture {
            RotateGesture()
                .onChanged { value in
                    angle = value.rotation
                }
        }
    
        var body: some View {
            Rectangle()
                .frame(width: 200, height: 200, alignment: .center)
                .rotationEffect(angle)
                .gesture(rotation)
        }
    }
    

####  Small additions

We have the brand new _ContentUnavailableView_ type that we can use whenever
we should display an empty view. It is a small but delightful addition.

    
    
    struct ProductsView: View {
        @State private var store = Store()
        
        var body: some View {
            List(store.products, id: \.self) { product in
                Text(verbatim: product)
            }
            .background {
                if store.products.isEmpty {
                    ContentUnavailableView("Products list is empty", systemImage: "list.dash")
                }
            }
            .task {
                if store.products.isEmpty {
                    await store.fetch()
                }
            }
        }
    }
    

There are also a pair of new view modifiers allowing us to tune the spacing in
the list. You can use the _listRowSpacing_ and _listSectionSpacing_ view
modifier to set the spacing you need in the list. The _EnvironmentValues_
struct includes a bunch of new properties related to the latest platform
updates like _isActivityFullscreen_ and _showsWidgetContainerBackground_ .
Swift Charts also became scrollable and SF Symbols animatable.

    
    
    #Preview {
        ContentView()
    }
    

There is a new _Preview_ macro allowing us to build previews easily both for
UIKit and SwiftUI in a few lines of code.

####  Conclusion

There are tons of small additions all over the SwiftUI framework that we will
cover during the upcoming months. So stay tuned to my blog, and don’t miss
anything. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Content transition in SwiftUI

##  Content transition in SwiftUI

02 Aug 2022

View transitions are available from the very first version of the SwiftUI
framework. The framework can apply a particular transition whenever the view
is removed or added to the view hierarchy. The latest iteration of the SwiftUI
framework brings us a new type of transition called content transitions. It
allows us to apply a particular transition to the content of the view whenever
it changes. This week we will learn how to use the new API to apply content
transition in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In the previous versions of SwiftUI, we couldn’t apply transitions to the
view’s content. And if you run this example on iOS 15, you will see no
transition.

    
    
    struct ContentView: View {
        @State private var flag = false
        
        var body: some View {
            VStack {
                Text(verbatim: "1000")
                    .fontWeight(flag ? .black : .light)
                    .foregroundColor(flag ? .yellow : .red)
            }
            .onTapGesture {
                withAnimation(.default.speed(0.1)) {
                    flag.toggle()
                }
            }
        }
    }
    

The previous version of SwiftUI doesn’t support any transition for _Text_ view
content, and it applies changes immediately without any visual effect.
Fortunately, the latest iteration of SwiftUI allows us to apply a content
transition to the _Text_ view by using the _contentTransition_ view modifier.

    
    
    struct ContentView: View {
        @State private var flag = false
        
        var body: some View {
            VStack {
                Text(verbatim: "1000")
                    .fontWeight(flag ? .black : .light)
                    .foregroundColor(flag ? .yellow : .red)
            }
            .contentTransition(.interpolate)
            .onTapGesture {
                withAnimation(.default.speed(0.1)) {
                    flag.toggle()
                }
            }
        }
    }
    

As you can see in the example above, the only line of code we added is the
_contentTransition_ view modifier. It accepts an instance of a particular
transition that SwiftUI applies to the view whenever content changes. In this
case, we use interpolation because transition affects the size and color of
the text.

    
    
    struct ContentView: View {
        @State private var flag = false
        
        var body: some View {
            VStack {
                Text(verbatim: "1000")
                    .fontWeight(flag ? .black : .light)
                    .foregroundColor(flag ? .yellow : .red)
            }
            .contentTransition(.opacity)
            .onTapGesture {
                withAnimation(.default.speed(0.1)) {
                    flag.toggle()
                }
            }
        }
    }
    

In the current example, we use another instance of _ContentTransition_ called
opacity. In this case, SwiftUI uses fade in/out whenever the text changes.

> To learn more about view transitions in SwiftUI, take a look at my [
> “Animations in SwiftUI” ](/2019/06/26/animations-in-swiftui/) post.

SwiftUI provides a type of _ContentTransition_ that works with numeric text.
It works only with numeric text, understands how the number changed, and
provides a nice visual effect that changes only the needed part of the _Text_
view representing a number.

    
    
    struct TextContentView: View {
        @State private var number = "99"
        
        var body: some View {
            Text(verbatim: number)
                .font(.system(size: 36))
                .contentTransition(.numericText())
                .onTapGesture {
                    withAnimation(.default.speed(0.2)) {
                        number = "98"
                    }
                }
        }
    }
    

> To learn more about other options for animating text changes, take a look at
> my [ “AnimatableModifier in SwiftUI” ](/2021/01/11/animatablemodifier-in-
> swiftui/) post.

The _contentTransition_ view modifier passes the provided instance of the
_ContentTransition_ via the SwiftUI environment and allows us to access it via
a particular _EnvironmentKey_ .

    
    
    struct MySuperCustomTextView: View {
        let text: String
        
        @Environment(\.contentTransition) private var transition
        
        var body: some View {
            switch transition {
            case .opacity:
                drawWithOpacity()
            case .interpolate:
                drawWithInterpolation()
            default:
                draw()
            }
        }
        
        // ...
    }
    

Here we have our super custom text view that uses the SwiftUI environment to
understand which transition should be used while applying the custom drawing
technique of the passed text.

There is another content transition-related _EnvironmentKey_ , allowing us to
control whenever we want to use GPU-accelerated rendering by wrapping the
transition content into a drawing group.

    
    
    struct ContentView: View {
        @State private var flag = false
        
        var body: some View {
            VStack {
                Text(verbatim: "1000")
                    .fontWeight(flag ? .black : .light)
                    .foregroundColor(flag ? .yellow : .red)
            }
            .environment(\.contentTransitionAddsDrawingGroup, true)
            .contentTransition(.interpolate)
            .onTapGesture {
                withAnimation(.default.speed(0.1)) {
                    flag.toggle()
                }
            }
        }
    }
    

Today we learned about new content transitions in SwiftUI. Not so many views
currently support them, but their count can change in the future. Try to
support it in your views by adopting the new APIs we covered today. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Managing Data Flow in SwiftUI

##  Managing Data Flow in SwiftUI

03 Jul 2019

Last week we talked about [ “Animations and Transitions in SwiftUI”
](/2019/06/26/animations-in-swiftui/) . But it’s time to touch the crucial
aspect of every app, and it is _Data Flow_ . All the apps have data to present
or mutate. Data plays a vital role in apps using SwiftUI. Every view in
SwiftUI is just a function of some state, where the state is our data.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Fetching data from local/remote storage

Today we will build a small app which uses core SwiftUI concepts like
_Binding_ and _ObservableObject_ . Assume that you work on the app, which has
two primary responsibilities:

  1. Fetch and show the list of employees from local or remote storage 
  2. Edit personal information about selected employee 

Let’s start with describing our model layer.

    
    
    import SwiftUI
    import Combine
    
    struct Person: Identifiable {
        let id: UUID
        var name: String
        var age: Int
    }
    
    final class PersonStore: ObservableObject {
        @Published var persons: [Person] = [
            .init(id: .init(), name: "Majid", age: 27),
            .init(id: .init(), name: "John", age: 31),
            .init(id: .init(), name: "Fred", age: 25)
        ]
    }
    

Here we have simple _Person_ struct which conforms _Identifiable_ protocol.
The single requirement of _Identifiable_ is _Hashable_ _id_ field. We
implement it by defining _id_ as _UUID_ . We also can use _Int_ instead of
_UUID_ .

Next, we can implement _PersonStore_ class, which is providing data for our
view. _PersonStore_ type conforms to _ObservableObject_ it will allow SwiftUI
to refresh the view as soon as any of _@Published_ fields change.

Now let’s take a look at _PersonListView_ .

    
    
    struct PersonsView : View {
        @ObservedObject var store: PersonStore
    
        var body: some View {
            NavigationView {
                List(store.persons) { person in
                    VStack(alignment: .leading) {
                        Text(person.name)
                            .font(.headline)
                        Text("Age: \(person.age)")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
            }.navigationBarTitle(Text("Persons"))
        }
    }
    

We use _List_ component to present an array of _Person_ structs. Every row in
_List_ contains _VStack_ with two _Text_ components representing the name and
age of a _Person_ . We call _fetch_ method on store object as soon as List
appears. As you remember, our _PersonStore_ object notifies SwiftUI about data
changes, and SwiftUI rebuilds the view to present new data.

####  Editing

Next step is creating a new view which allows us to edit personal information
of selected _Person_ . We will use _Form_ component to show nice form for data
entry. You can check [ “Building forms with SwiftUI” ](/2019/06/19/building-
forms-with-swiftui/) to learn more about _Form_ component and its advantages.
Let’s dive into code which represents editing view.

    
    
    struct EditingView: View {
        @Environment(\.presentationMode) var presentation
        @Binding var person: Person
    
        var body: some View {
            Form {
                Section(header: Text("Personal information")) {
                    TextField("type something...", text: $person.name)
                    Stepper(value: $person.age) {
                        Text("Age: \(person.age)")
                    }
                }
    
                Section {
                    Button("Save") {
                        self.presentation.wrappedValue.dismiss()
                    }
                }
            }.navigationBarTitle(Text(person.name))
        }
    }
    

Here we use _Binding_ for selected person item. _Binding Property Wrapper_
allows passing a reference to a value type. By using _Binding_ property,
_EditingView_ can read and mutate the _Person_ struct, but it doesn’t store a
copy of it. We use this _Binding_ to mutate value inside _PersonsStore_ and as
soon as we do that SwiftUI will update the view with the updated list of
_Persons_ . If you want to learn more about _Property Wrappers_ available in
SwiftUI like @ _Binding_ , @ _Environment_ , @ _EnvironmentObject_ ,
_@ObservedObject_ , please take a look at the [ “Understanding Property
Wrappers in SwiftUI” ](/2019/06/12/understanding-property-wrappers-in-
swiftui/) .

Now let’s refactor our _PersonsView_ to support editing by passing _Binding_
to a selected _Person_ inside _EditingView_ .

    
    
    import Foundation
    
    extension RandomAccessCollection {
        func indexed() -> Array<(offset: Int, element: Element)> {
            Array(enumerated())
        }
    }
    
    import SwiftUI
    
    struct PersonsView : View {
        @ObservedObject var store: PersonStore
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(store.persons.indexed(), id: \.1.id) { index, person in
                        NavigationLink(destination: EditingView(person: self.$store.persons[index])) {
                            VStack(alignment: .leading) {
                                Text(person.name)
                                    .font(.headline)
                                Text("Age: \(person.age)")
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                }
                .onAppear(perform: store.fetch)
                .navigationBarTitle(Text("Persons"))
            }
        }
    }
    

And here is the screenshot of our app, you can see how it looks. ![managing-
data-flow-in-swiftui](/public/managing-data-flow-in-swiftui.png)

####  Conclusion

Today we built simple Master-Detail flow in SwiftUI. I’ve tried to show the
power of _Bindings_ in SwiftUI. You don’t need to post notifications or
observe key-values to indicate changes in your User Interface, all you need is
using correct _Property Wrapper provided by SwiftUI_ . Again, if you want to
learn when and which one should be used, check out my [ post about Property
Wrappers in SwiftUI ](/2019/06/12/understanding-property-wrappers-in-swiftui/)
. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading and see you next week!



# Fitting and filling views in SwiftUI

##  Fitting and filling views in SwiftUI

20 May 2020

This week I want to continue the topic of layout system in SwiftUI. The
SwiftUI layout engine works predictably, and usually, an outcoming result
looks like we expect. Today, to make this process even more apparent, we will
talk about fitting and filling views in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

A few weeks ago, we will talk about layout priorities in SwiftUI. Let me
refresh your memory by describing how the layout system works in SwiftUI.
Usually, a parent view proposes the available space to its child and asks to
calculate its size. Then the parent view places the child in the center of
available space. Pretty easy, right?

> To learn more about the SwiftUI layout engine, take a look at my [ “Layout
> priorities in SwiftUI” ](/2020/04/15/layout-priorities-in-swiftui/) post.

But how exactly view calculates its size? There are two types of views:
fitting and filling.

####  Fitting views

A fitting view calculates its size based on its content. It tries to fit its
content into available space and return the size. Most of the views we use in
SwiftUI are fitting. For example, buttons, stacks, texts, toggles, and
pickers. All of them use the content that should be displayed to calculate its
size. Let’s take a look at the small example.

    
    
    struct RootView: View {
        var body: some View {
            HStack {
                Text("Hello World!")
            }.border(Color.red)
        }
    }
    

I think the border modifier is the best way to highlight the view’s frame. As
you can see in the example above, the stack has the size of its content. Stack
always uses the space that it needs to place its children.

####  Filling views

A filling view tries to fill all available space provided by its parent view.
Usually, this view doesn’t have a proper way to understand its content. That’s
why it fills all the free space. SwiftUI provides us a bunch of filling views.
For example, shapes, colors, spacers, dividers, and _GeometryReader_ .

Yes, yes. _GeometryReader_ is also a filling view. _GeometryReader_ always
consumes all the available space provided by its parent and allows you to
place its child using a manual calculation based on the given instance of
_GeometryProxy_ that holds all the needed information about available space
and safe area. Let’s take a look at another example.

    
    
    struct RootView: View {
        var body: some View {
            HStack {
                Circle().fill(Color.green)
            }.border(Color.blue)
        }
    }
    

> To learn more about the benefits of GeometryReader view, take a look at my [
> “Building BarChart with Shape API in SwiftUI” ](/2019/08/14/building-
> barchart-with-shape-api-in-swiftui/) post.

The best way to manage the size of a filling view is by using the _frame_
modifier.

    
    
    struct RootView: View {
        var body: some View {
            Color.red.frame(width: 100, height: 100)
        }
    }
    

It might be strange, but the color is also a view. It just fills the available
space with the color you choose.

####  Both fitting and filling views

There is one exception that I clearly see, and it is Image view. By default,
the image component has the size of the image that it should to display. We
can call it fitting, but we also can add the _resizable_ modifier to the image
component, which resizes the image to fill the entire available space. As we
do with other filling views, we can control the size of the resizable image by
using the _frame_ modifier in pair with _scale to fit_ modifier to save the
aspect ratio of the original image.

####  Conclusion

Today we divide views in SwiftUI into two groups. I believe this post dispels
myths about the work of the SwiftUI layout engine. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Mastering charts in SwiftUI. Custom Marks.

##  Mastering charts in SwiftUI. Custom Marks.

26 Jan 2023

The Swift Charts framework is an excellent example of composition. In the
previous posts, we saw how we could use different marks on the same chart view
to plot different data points. This week we will learn how to use composition
to build new custom mark types and reuse them across the app.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s take a look at the basic example of composition in the Swift Charts
framework by plotting a line chart with point marks.

    
    
    struct ContentView1: View {
        @State private var numbers = (0...10)
            .map { _ in Int.random(in: 0...10) }
        
        var body: some View {
            Chart {
                ForEach(Array(numbers.enumerated()), id: \.element) { index, number in
                    LineMark(
                        x: .value("index", index),
                        y: .value("value", number)
                    )
                    
                    PointMark(
                        x: .value("index", index),
                        y: .value("value", number)
                    )
                }
            }
        }
    }
    

![line-chart-with-points](/public/chart13.png)

As you can see in the example above, we use a single chart view to plot both
lines and points on it. We can use the same strategy to create super custom
marks that the Swift Charts framework doesn’t provide out of the box.

> To learn more about the basics of the Charts framework, take a look at my
> dedicated [ “Mastering charts in SwiftUI. Basics.” ](/2023/01/10/mastering-
> charts-in-swiftui-basics/) post.

Charts are viral in the financial industry, and the unique candlestick chart
is used to present market prices visually. The Swift Charts framework doesn’t
provide us with the candlestick mark, but fortunately, we can build it by
using the composition of other primitive marks.

Let’s think about candlestick marks and how we can implement them using the
Swift Charts framework. Every candlestick mark should display the lowest and
highest prices. It doesn’t stop there because it also should present another
two prices indicating market open and close prices.

Fortunately, the Swift Charts framework provides us with the _RectangleMark_
type allowing us to place a rectangle in the plot area using the _X_ value and
two values representing the _Y start_ and _Y end_ .

    
    
    struct Candle: Hashable {
        let open: Double
        let close: Double
        let low: Double
        let high: Double
    }
    
    struct ContentView2: View {
        let candles: [Candle] = [
            .init(open: 3, close: 6, low: 1, high: 8),
            .init(open: 4, close: 7, low: 2, high: 9),
            .init(open: 5, close: 8, low: 3, high: 10)
        ]
        
        var body: some View {
            Chart {
                ForEach(Array(zip(candles.indices, candles)), id: \.1) { index, candle in
                    RectangleMark(
                        x: .value("index", index),
                        yStart: .value("low", candle.low),
                        yEnd: .value("high", candle.high),
                        width: 4
                    )
                    
                    RectangleMark(
                        x: .value("index", index),
                        yStart: .value("open", candle.open),
                        yEnd: .value("close", candle.close),
                        width: 16
                    )
                    .foregroundStyle(.red)
                }
            }
        }
    }
    

![candlestick-chart](/public/chart12.png)

As you can see in the example above, we use _RectangleMark_ type to plot
candles. We use the composition of two rectangle marks where the first
rectangle displays the low/high price pair, and the second one presents the
open/close price pair.

_RectangeMark_ type provides the _width_ parameter allowing us to tune the
width of the plotted rectangle on the chart. We efficiently use it to separate
two pairs of prices visually.

Ok, it looks good, but in the case of the chart-heavy financial apps, we might
have a bunch of screens with different candlestick charts, and I don’t want to
duplicate this code so many times. I want to extract my code in the particular
_CandlestickMark_ type and reuse it across my app.

Fortunately, the Swift Charts framework provides us with the _ChartContent_
protocol. Every mark provided by the Swift Charts framework conforms to this
protocol and inherits basic modifiers like _foregroundStyle_ , _offset_ , etc.

    
    
    struct CandlestickMark<X: Plottable, Y: Plottable>: ChartContent {
        let x: PlottableValue<X>
        let low: PlottableValue<Y>
        let high: PlottableValue<Y>
        let open: PlottableValue<Y>
        let close: PlottableValue<Y>
        
        init(
            x: PlottableValue<X>,
            low: PlottableValue<Y>,
            high: PlottableValue<Y>,
            open: PlottableValue<Y>,
            close: PlottableValue<Y>
        ) {
            self.x = x
            self.low = low
            self.high = high
            self.open = open
            self.close = close
        }
        
        var body: some ChartContent {
            RectangleMark(x: x, yStart: low, yEnd: high, width: 4)
            RectangleMark(x: x, yStart: open, yEnd: close, width: 16)
                .foregroundStyle(.red)
        }
    }
    

Here we create the _CandlestickMark_ type conforming to the _ChartContent_
protocol. The _ChartContent_ protocol has the only requirement: the _body_
property, which should return some instance of the _ChartContent_ protocol.
The API is very similar to SwiftUI’s _View_ protocol.

In the _body_ property of the _CandlestickMark_ , we use the same pair of
_RectangleMark_ to plot our candle. Here we follow the same API that other
mark types provide and use the _PlottableValue_ type as input for our mark
type. Now we are ready to use it in our code.

    
    
    struct ContentView: View {
        var body: some View {
            Chart {
                ForEach(0...10, id: \.self) { index in
                    CandleMark(
                        x: .value("index", index),
                        low: .value("low", Int.random(in: 0...2)),
                        high: .value("high", Int.random(in: 8...10)),
                        open: .value("open", Int.random(in: 2...8)),
                        close: .value("close", Int.random(in: 2...8))
                    )
                    .foregroundStyle(.green)
                }
            }
        }
    
    

By conforming our type to the _ChartContent_ protocol, we create another
fully-functional mark type that inherits all the modifiers we used to see in
standard marks. We can easily apply the _foregroundStyle_ or _offset_
modifiers on it.

> To learn more about customization options available via the _ChartContent_
> protocol, take a look at my dedicated [ “Mastering charts in SwiftUI. Mark
> styling.” ](/2023/01/18/mastering-charts-in-swiftui-mark-styling/) post.

Today we learned how to use composition in the Swift Charts framework to
create new types of marks and reuse them across the app. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Building custom layout in SwiftUI. Spacing.

##  Building custom layout in SwiftUI. Spacing.

06 Dec 2022

Multiple layouts allow us to compose views in different ways. One crucial
thing is the spacing between children of the concrete layout. This week we
will learn how to build a custom layout allowing us to specify a particular
spacing between views and how to respect the platform-oriented predefined
spacing rules in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

As many types we create in Swift, the type conforming to the _Layout_ protocol
can define its properties and initialize it via the _init_ function. Our
_FlowLayout_ type is not an exception here. Let’s add the _spacing_ property
to the _FlowLayout_ type.

    
    
    struct FlowLayout: Layout {
        var spacing: CGFloat = 0
        
        struct Cache {
            var sizes: [CGSize] = []
        }
        
        func makeCache(subviews: Subviews) -> Cache {
            let sizes = subviews.map { $0.sizeThatFits(.unspecified) }
            return Cache(sizes: sizes)
        }
    }
    

> To learn more about the basics of the _Layout_ protocol, take a look at my
> dedicated [ “Building custom layout in SwiftUI. Basics”
> ](/2022/11/16/building-custom-layout-in-swiftui-basics/) post.
    
    
    struct ContentView: View {
        var body: some View {
            FlowLayout(spacing: 8) {
                Text("Hello")
                    .font(.largeTitle)
                Text("World")
                    .font(.title)
                Text("!!!")
                    .font(.title3)
            }
            .border(Color.red)
        }
    }
    

As you can see in the example above, now we can place an instance of the
_FlowLayout_ type with the particular spacing between views. But first, we
should tune the _sizeThatFits_ function to respect the spacing between views
while calculating the final size of the layout.

    
    
    struct FlowLayout: Layout {
    //  ....
        func sizeThatFits(
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Cache
        ) -> CGSize {
            var totalHeight = 0.0
            var totalWidth = 0.0
            
            var lineWidth = 0.0
            var lineHeight = 0.0
            
            for index in subviews.indices {
                if lineWidth + cache.sizes[index].width > proposal.width ?? 0 {
                    totalHeight += lineHeight
                    lineWidth = cache.sizes[index].width
                    lineHeight = cache.sizes[index].height
                } else {
                    lineWidth += cache.sizes[index].width + spacing
                    lineHeight = max(lineHeight, cache.sizes[index].height)
                }
                
                totalWidth = max(totalWidth, lineWidth)
            }
            
            totalHeight += lineHeight
            
            return .init(width: totalWidth, height: totalHeight)
        }
    }
    

Second, we must add spacing between views while placing them in the
_placeSubviews_ function.

    
    
    struct FlowLayout: Layout {
    //  ....
        func placeSubviews(
            in bounds: CGRect,
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Cache
        ) {
            var lineX = bounds.minX
            var lineY = bounds.minY
            var lineHeight: CGFloat = 0
            
            for index in subviews.indices {
                if lineX + cache.sizes[index].width > (proposal.width ?? 0) {
                    lineY += lineHeight
                    lineHeight = 0
                    lineX = bounds.minX
                }
                
                let position = CGPoint(
                    x: lineX + cache.sizes[index].width / 2,
                    y: lineY + cache.sizes[index].height / 2
                )
                
                lineHeight = max(lineHeight, cache.sizes[index].height)
                lineX += cache.sizes[index].width + spacing
                
                subviews[index].place(
                    at: position,
                    anchor: .center,
                    proposal: ProposedViewSize(cache.sizes[index])
                )
            }
        }
    }
    

Finally, we have a fully working _FlowLayout_ that allows us to set the custom
spacing between views.

####  Preferred spacing

As you can see, most of the layouts in SwiftUI allow us to set the spacing to
_nil_ , where the layout uses the preferred spacing instead of zero. SwiftUI
has spacing preferences between views. For example, it has preferred spacing
between _Image_ and _Text_ views, but this value might differ from _Text_ to
_Text_ views. And these spacing preferences might be different for iOS, macOS,
watchOS, and tvOS.

Fortunately, SwiftUI provides an API to calculate spacing between views by
respecting platform-oriented spacing preferences. This API is a part of the
_Layout_ protocol and lives in the _Subview_ proxy type.

    
    
    struct FlowLayout: Layout {
        var spacing: CGFloat? = nil
        
        struct Cache {
            var sizes: [CGSize] = []
            var spacing: [CGFloat] = []
        }
        
        func makeCache(subviews: Subviews) -> Cache {
            let sizes = subviews.map { $0.sizeThatFits(.unspecified) }
            let spacing: [CGFloat] = subviews.indices.map { index in
                guard index != subviews.count - 1 else {
                    return 0
                }
                
                return subviews[index].spacing.distance(
                    to: subviews[index+1].spacing,
                    along: .horizontal
                )
            }
            
            return Cache(sizes: sizes, spacing: spacing)
        }
    }
    

Let’s start by adding the _spacing_ property to our cache. It is a perfect
candidate to live in the cache because we want to calculate it once when the
list of the subviews changes.

Next, we iterate over the subviews and use the _spacing_ property on the
_Subview_ type to call the _distance_ function with the following view as a
parameter to calculate the preferred spacing between two views in the
horizontal axis. We also can measure vertical spacing between views if needed
by using the same function with vertical parameter for axis.

> To learn more about implementing a layout cache, take a look at my dedicated
> [ “Building custom layout in SwiftUI. Caching.” ](/2022/11/29/building-
> custom-layout-in-swiftui-caching/) post.

Let’s tune the _sizeThatFits_ function to respect the spacing between views
while calculating the final size of the layout.

    
    
    struct FlowLayout: Layout {
        func sizeThatFits(
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Cache
        ) -> CGSize {
            var totalHeight = 0.0
            var totalWidth = 0.0
            
            var lineWidth = 0.0
            var lineHeight = 0.0
            
            for index in subviews.indices {
                if lineWidth + cache.sizes[index].width > proposal.width ?? 0 {
                    totalHeight += lineHeight
                    lineWidth = cache.sizes[index].width
                    lineHeight = cache.sizes[index].height
                } else {
                    lineWidth += cache.sizes[index].width + (spacing ?? cache.spacing[index])
                    lineHeight = max(lineHeight, cache.sizes[index].height)
                }
                
                totalWidth = max(totalWidth, lineWidth)
            }
            
            totalHeight += lineHeight
            
            return .init(width: totalWidth, height: totalHeight)
        }
    }
    

The next step is to add spacing between views while placing them. We can apply
similar changes to the _placeSubviews_ function to respect the preferred
spacing between different views.

    
    
    struct FlowLayout: Layout {
        func placeSubviews(
            in bounds: CGRect,
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Cache
        ) {
            var lineX = bounds.minX
            var lineY = bounds.minY
            var lineHeight: CGFloat = 0
            
            for index in subviews.indices {
                if lineX + cache.sizes[index].width > (proposal.width ?? 0) {
                    lineY += lineHeight
                    lineHeight = 0
                    lineX = bounds.minX
                }
                
                let position = CGPoint(
                    x: lineX + cache.sizes[index].width / 2,
                    y: lineY + cache.sizes[index].height / 2
                )
                
                lineHeight = max(lineHeight, cache.sizes[index].height)
                lineX += cache.sizes[index].width + (spacing ?? cache.spacing[index])
                
                subviews[index].place(
                    at: position,
                    anchor: .center,
                    proposal: ProposedViewSize(cache.sizes[index])
                )
            }
        }
    }
    

Finally, we have a flow layout that respects the preferred view spacing by
default. The _Layout_ protocol provides us with the reach API to build
reusable layouts across all the platforms. We should carefully learn the API
SwiftUI provides to create layouts respecting the platform-oriented rules.

    
    
    struct ContentView: View {
        var body: some View {
            FlowLayout {
                Text("Hello")
                    .font(.largeTitle)
                Text("World")
                    .font(.title)
                Text("!!!")
                    .font(.title3)
            }
            .border(Color.red)
        }
    }
    

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Displaying badges in SwiftUI

##  Displaying badges in SwiftUI

10 Nov 2021

One of the many things included in SwiftUI Release 3 was the ability to
display badges. SwiftUI Release 3 provides you with the _badge_ view modifier
that we can use to generate badges in lists and tabs. This week we will learn
how to use the _badge_ view modifier and customize the look and feel of
badges.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

The _badge_ view modifier is available only for iOS and macOS. You can use the
_badge_ view modifier to generate and display a badge for your view. Keep in
mind that only lists and tabs can display badges at the moment. Let’s start
with a simple example of the _badge_ view modifier usage.

    
    
    struct ContentView: View {
        var body: some View {
            List {
                Text("Group 1")
                    .badge(12)
    
                Text("Group 2")
                    .badge(20)
            }
        }
    }
    

![badges](/public/badge1.png)

As you can see in the example above, we use the _badge_ view modifier on the
_Text_ view, which is a list item. A list displays the badge on the trailing
part of the list item. The _badge_ view modifier also looks great with sidebar
styled lists.

> To learn more about sidebar styled lists, take a look at my “ [ Mastering
> List in SwiftUI ](/2021/06/16/mastering-list-in-swiftui/) ” post.

The _badge_ view modifier has a few different options. In the previous
example, we used the _badge_ view modifier with an integer value. SwiftUI uses
the environment to format an integer value in an appropriate locale
automatically. SwiftUI also hides the badge whenever the integer value is
zero.

There is also an opportunity to use another version of the _badge_ view
modifier to display a string or localized string key instead of an integer
value.

    
    
    struct ContentView: View {
        var body: some View {
            TabView {
                Text("Hello World")
                    .tabItem {
                        Text("Favorites")
                        Image(systemName: "star")
                    }
                    .badge(10)
            }
        }
    }
    

![badges](/public/badge2.png)

Remember that you can use the _badge_ view modifier with tabs, and that’s why
you should keep the content of a badge as short as possible. The _badge_ view
modifier is one of the many inert view modifiers that SwiftUI provides us,
which means you can pass the _nil_ as the value to hide the badge.

    
    
    struct ContentView: View {
        let count: Int
        var body: some View {
            TabView {
                Text("Hello World")
                    .tabItem {
                        Text("Favorites")
                        Image(systemName: "star")
                    }
                    .badge(count > 0 ? "\(count) stars" : nil)
            }
        }
    }
    

> To learn more about tabs in SwiftUI, take a look at my “ [ Tabs and pages in
> SwiftUI ](/2020/09/16/tabs-and-pages-in-swiftui/) ” post.

####  Customization

Another version of the _badge_ view modifier allows us to pass an instance of
the _Text_ view instead of integer or string values. This fantastic
opportunity creates tons of customization options available while displaying
badges in SwiftUI.

    
    
    struct ContentView: View {
        var body: some View {
            List {
                Text("Group 1")
                    .badge(12)
    
                Text("Group 2")
                    .badge(20)
                    
                Text("Group 3")
                    .badge(
                        Text("31 \(Image(systemName: "star"))")
                            .foregroundColor(.red)
                            .font(.headline)
                    )
            }
        }
    }
    

![badges](/public/badge3.png)

As you can see in the example above, we use the _badge_ view modifier with an
instance of the _Text_ view. It allows us to use _Text_ view’s modifiers to
tune the badge’s look and feel the way we need. We even can use interpolation
to inject the image into the _Text_ view.

####  Conclusion

This week, we learned how to use the new _badge_ view modifier, a small
feature of SwiftUI Release 3 that allows us to badge views effortlessly. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Binding in SwiftUI

##  Binding in SwiftUI

08 Apr 2020

Binding is one of the several property wrappers that SwiftUI presents us to
control data flow in the app. Binding provides us a reference like access to a
value type. This week we will understand how and when to use binding. We will
learn how to avoid common mistakes while using binding in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Binding is a property wrapper type that can read and write a value owned by a
source of truth. We have several possible types of sources of truth in
SwiftUI. It can be _EnvironmentObject_ , _ObservedObject_ or _State_ . All
these property wrappers provide a projected value, which is binding. Let’s
take a look at the quick example.

    
    
    import SwiftUI
    
    struct ExampleView: View {
        @State private var text = "Hello World."
    
        var body: some View {
            TextField("type something...", text: $text)
        }
    }
    

Here we have a state that is a source of truth. We also have a _TextField_ ,
which requires a binding for a text value. We use a _dollar sign_ to access
the projected value of the state property wrapper, which is a binding to the
value of property wrapper.

> To learn more about property wrappers in SwiftUI, take a look at my [
> “Understanding Property Wrappers in SwiftUI” post
> ](/2019/06/12/understanding-property-wrappers-in-swiftui/) .

####  Common mistakes

Let’s take a look at the more complicated example. We will build an app that
shows the list of users and allows us to edit user data.

    
    
    import SwiftUI
    import Combine
    
    struct Person: Identifiable {
        let id: UUID
        var name: String
        var age: Int
    }
    
    final class PersonStore: ObservableObject {
        @Published var persons: [Person] = [
            .init(id: .init(), name: "Majid", age: 28),
            .init(id: .init(), name: "John", age: 31),
            .init(id: .init(), name: "Fred", age: 25)
        ]
    }
    
    struct PersonsView : View {
        @ObservedObject var store: PersonStore
    
        var body: some View {
            NavigationView {
                List {
                    ForEach($store.persons) { $person in
                        NavigationLink(destination: EditingView(person: $person)) {
                            VStack(alignment: .leading) {
                                Text(person.name)
                                    .font(.headline)
                                Text("Age: \(person.age)")
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                }.navigationBarTitle(Text("Persons"))
            }
        }
    }
    

Take a look at how we generate bindings inside _ForEach_ view. We use **$**
sign to define closure parameter and it automatically generates binding for
us.

Please keep in mind that the value of binding must be a value type. It means
it has to be an enum or a struct. I see that people sometimes use classes to
describe a state or entry inside _EnvironmentObject_ or _ObservedObject_ and
notice that binding is not working. Apple’s documentation on binding says: if
_Value_ is not value semantic, the updating behavior for any views that make
use of the resulting _Binding_ is unspecified.

    
    
    struct EditingView: View {
        @Environment(\.presentationMode) var presentation
        @Binding var person: Person
    
        var body: some View {
            Form {
                Section(header: Text("Personal information")) {
                    TextField("type something...", text: $person.name)
                    Stepper(value: $person.age) {
                        Text("Age: \(person.age)")
                    }
                }
    
                Section {
                    Button("Save") {
                        self.presentation.wrappedValue.dismiss()
                    }
                }
            }.navigationBarTitle(Text(person.name))
        }
    }
    

As you can see in the example above, we use binding to pass a writable
reference to a person struct. As soon as we modify the user instance inside
the _EditingView_ SwiftUI updates _PersonsView_ to respect the changes.

> To learn more about building editable forms using _Form_ component, take a
> look at my [ “Building forms with SwiftUI” ](/2019/06/19/building-forms-
> with-swiftui/) post.

####  Computed Binding

Usually, we access binding using a projected value of a source of truth. In
this section, we will talk about another way of creating a binding. Binding is
a two-way connection between the data and a view that access it. SwiftUI
provides a way to construct a binding using getter and setter closures. In
this case, we are responsible for calculating the value inside these closures.
It is hard to imagine where we can use it, but it plays very well with Redux-
like state containers.

    
    
    typealias Reducer<State, Action> = (inout State, Action) -> Void
    
    final class Store<State, Action>: ObservableObject {
        @Published private(set) var state: State
        private let reducer: Reducer<State, Action>
    
        init(initialState: State, reducer: Reducer<State, Action>) {
            self.state = initialState
            self.reducer = reducer
        }
    
        func send(_ action: Action) {
            reducer(&state, action)
        }
    }
    

Here we have a concept of store that holds the entire state of the app. All
changes to the state come from the unidirectional flow. Reducer is the single
place where we can mutate the state of the app. By using computed binding, we
can provide read-only access to the state and respect the unidirectional flow
by sending action to the reducer.

    
    
    extension Store {
        func binding<Value>(
            for keyPath: KeyPath<State, Value>,
            transform: @escaping (Value) -> Action
        ) -> Binding<Value> {
            Binding<Value>(
                get: { self.state[keyPath: keyPath] },
                set: { self.send(transform($0)) }
            )
        }
    }
    

As you can see, we generate a computed binding that reads a part of the state
and emits an action through reducer to modify the state when needed. You might
need this type of bindings when you, for example, have a settings screen that
describes some checkboxes bound to the app state.

> To learn more about implementing Redux in SwiftUI, take a look at my [
> “Redux-like state container in SwiftUI” post ](/2019/09/18/redux-like-state-
> container-in-swiftui/) .

####  Constant binding

Another way to create binding is the _static constant_ function. This function
allows us to create a binding that provides value but ignores any mutations on
it. In other words, it generates an immutable binding for provided value.

    
    
    import SwiftUI
    
    struct ExampleView: View {
        var body: some View {
            TextField("type something...", text: Binding.constant("Hello!"))
        }
    }
    

####  Conclusion

Today we learned another great tool to control data flow in SwiftUI. Binding
can be a tool which is more complicated than others, but I believe we cover
all the needed things for efficient use of bindings in SwiftUI. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# The many faces of button in SwiftUI

##  The many faces of button in SwiftUI

30 Jun 2021

Button is one of the crucial components of any app. We use buttons to provide
actions in the user interface of the app. SwiftUI 3 released a bunch of new
view modifiers that allow us to style buttons in different ways. New
_bordered_ and _borderedProminent_ button styles in conjunction with
_controlSize_ and _buttonBorderShape_ view modifiers can change button
presentation drastically.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Button role

New in SwiftUI Release 3, you can provide an optional button role. By default,
it is _nil_ and uses a standard one, but you can set the predefined role
provided by _ButtonRole_ enum. The role can be _destructive_ or _cancel_ . In
this case, SwiftUI will set a specified button appearance. For example,
SwiftUI changes the button tint to red for destructive buttons.

    
    
    Button("Delete", role: .destructive) {
        viewModel.delete()
    }
    

![button-destructive](/public/buttons-destructive.png)

Button roles change the appearance in many places across the app, like context
menus, toolbar menus, etc.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationView {
                Text("Hello, World!")
                    .toolbar {
                        Menu("Actions") {
                            Button("New action") {}
                            Button("Delete", role: .destructive) {}
                    }
                }.navigationTitle("Buttons")
            }
        }
    }
    

![button-toolbar](/public/buttons-toolbar.png)

####  Bordered button style

There is a new _BorderedButtonStyle_ type that allows us to display buttons
with rounded corners. You can set the button style for a particular button or
the full view hierarchy using the _buttonStyle_ view modifier.

    
    
    Button("New action") {}
        .buttonStyle(.bordered)
    

![button-bordered](/public/buttons-bordered.png)

_BorderedButtonStyle_ provides you a bordered button appearance with rounded
corners that you can see in many places across the iOS system.

> To learn more about buttons and how to create custom button style, take a
> look at my [ “Mastering buttons in SwiftUI” ](/2020/02/19/mastering-buttons-
> in-swiftui/) post.

####  Button tint

There is a new _tint_ view modifier that we should use to override the default
accent color. Unlike an app’s accent color, which can be overridden by user
preference, the tint color is always respected.

    
    
    Button("New action") {}
        .buttonStyle(.bordered)
        .tint(.green)
    

![button-tint](/public/buttons-bordered-tint.png)

####  Control size

We can’t directly control the corner radius of the bordered button, but we can
affect it using the _controlSize_ view modifier. The _controlSize_ view
modifier allows us to set the size of controls within the view. There is a
_ControlSize_ enum with four cases: _mini, small, regular, and large_ . We can
use one of them and pass it via the _controlSize_ modifier.

    
    
     Button("New action") {}
        .tint(.green)
        .buttonStyle(.bordered)
        .controlSize(.large)
    

![button-bordered-large](/public/buttons-bordered-large.png)

In the example above, we set the large size for controls in our view
hierarchy. As you can see, it affects the size of our button and changes its
corner radius.

####  Bordered button shape

There is a new _buttonBorderShape_ view modifier that allows us to change the
shape of bordered button in the view. _buttonBorderShape_ view modifier
accepts an instance of _ButtonBorderShape_ struct that defines the shape.
There are a few predefined options like _capsule, roundedRectangle, and
automatic_ .

    
    
    Button("New action") {}
        .tint(.green)
        .buttonStyle(.bordered)
        .buttonBorderShape(.capsule)
        .controlSize(.large)
    

![button-bordered-capsule](/public/buttons-bordered-capsule.png)

####  Button prominence

Button prominence defines the dominance of a button in the user interface. You
can increase the importance using the new _borderedProminent_ style.

    
    
    Button("New action") {}
        .tint(.green)
        .controlSize(.large)
        .buttonStyle(.borderedProminent)
    

![button-bordered-tint-important](/public/buttons-tint-fill.png)

As you can see in the example above, SwiftUI changes button appearance
whenever we set the increased prominence. SwiftUI displays buttons with
increased prominence by filling them with tint color.

####  Conclusion

There are a lot of new opportunities for customizing buttons both in SwiftUI
and UIKit. New control size and prominence APIs will play a crucial role in
styling SwiftUI buttons without implementing custom button styles. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# State restoration in SwiftUI

##  State restoration in SwiftUI

10 Mar 2022

We always want to provide a great user experience in our apps. The system can
shut down your app when the user leaves it and when the user relaunches your
app, the system creates it from scratch, and the current state of your app is
lost. This is a bad user experience. To avoid this kind of situation, we
should provide a state restoration mechanism. This week we will learn how to
implement state restoration in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  SceneStorage property wrapper

_State_ and _StateObject_ property wrappers are great tools to hold a view
state in runtime. The only problem is the ability to restore its value after
app relaunch. SwiftUI sets the initial values to _State_ and _StateObject_
whenever it recreates a view holding these property wrappers.

> To learn more about property wrappers in SwiftUI, take a look at my [
> “Understanding Property Wrappers in SwiftUI” ](/2019/06/12/understanding-
> property-wrappers-in-swiftui/) post.

Fortunately, SwiftUI provides us with the _SceneStorage_ property wrapper
allowing us to store values in the memory allocated by the current scene. It
means every scene has private storage that other scenes can’t access. The
system is entirely responsible for managing per-scene storage, and you don’t
have access to the data without the _SceneStorage_ property wrapper.

    
    
    struct RootView: View {
        @SceneStorage("selectedTab")
        private var selectedTab = 0
    
        var body: some View {
            TabView(selection: $selectedTab) {
                NavigationView {
                    TimerView()
                }
                .tabItem {
                    Image(systemName: "timer")
                    Text("timer")
                }
                .tag(0)
    
                NavigationView {
                    InsightsContainerView()
                        .navigationTitle("Insights")
                }
                .tabItem {
                    Image(systemName: "chart.bar")
                    Text("insights")
                }
                .tag(1)
            }
        }
    }
    

As you can see in the example above, we use the _SceneStorage_ property
wrapper to hold the tab selection. When the system relaunches the app, it also
restores the value of _SceneStorage_ property wrappers. The _SceneStorage_
property wrapper is an excellent tool for storing tab selection, active
navigation links, sheet presentation conditions, etc.

    
    
    struct RootView: View {
        @EnvironmentObject var store: Store<AppState, AppAction>
        
        @SceneStorage("bloodPressureFormShown")
        private var bloodPressureFormShown = false
        
        @SceneStorage("selectedTab")
        private var selectedTab = 0
    
        var body: some View {
            TabView(selection: $selectedTab) {
                NavigationView {
                    SummaryContainerView()
                        .navigationBarTitle("today")
                        .sheet(isPresented: $bloodPressureFormShown) {
                            AddBloodPressureView()
                        }
                    }
                    .tabItem {
                        Image(systemName: "heart")
                        Text("today")
                    }.tag(0)
                    
                    NavigationView {
                        SettingsView()
                    }
                    .tabItem {
                        Image(systemName: "gear")
                        Text("Settings")
                    }.tag(1)
                }
            }
        }
    }
    

Remember that the system doesn’t guarantee when and how often the data
persists. Make sure you don’t use _SceneStorage_ property wrapper with
sensitive data. _SceneStorage_ is not a replacement for the _State_ and
_StateObject_ property wrappers. It is designed to operate in pair with them.

> To learn more about scene management in SwiftUI, take a look at my [
> “Managing scenes in SwiftUI” ](/2020/08/26/managing-scenes-in-swiftui/)
> post.

####  User Activity

_UserActivity_ type is another option to provide a state restoration. It
allows us to mark a particular feature with unique data that the system
preserves across launches. For example, you can mark a purchase flow in the
e-commerce app with the purchased item identifier and any additional
information you need.

Whenever the system relaunches the app, it passes the instance of
_UserActivity_ type with the data populated previously. SwiftUI provides a few
view modifiers to populate and handle user activities in the app. Let’s take a
quick look at how we can use these view modifiers.

    
    
    struct PurchaseView: View {
        static let userActivity = "com.aaplab.app.purchase"
        let product: Product
    
        @State private var isPurchaseLinkActivated = false
    
        var body: some View {
            VStack {
                Text(product.title)
                NavigationLink(isActive: $isPurchaseLinkActivated) {
                        CheckoutView(product: product)
                    } label: {
                        Label("Go to checkout", systemImage: "creditcard")
                    }
            }
            .userActivity(
                PurchaseView.userActivity,
                isActive: isPurchaseLinkActivated
            ) { userActivity in
                userActivity.title = "Purchase \(product.title)"
                userActivity.userInfo = ["id": product.id]
            }
        }
    }
    

In the example above, we enable user activity when the user presses: “Go to
checkout” button. The system recognizes the user activity and stores it.
Whenever the system relaunches the app, it provides an instance of
_UserActivity_ type that we can grab and handle to continue the user flow.

    
    
    struct CommerceApp: App {
        var body: some Scene {
            WindowGroup {
                RootView()
                    .onContinueUserActivity(PurchaseView.userActivity) { userActivity in
                        if let id = userActivity.userInfo?["id"] {
                            // mutate the state of the app and navigate to the purchase view
                        }
                    }
            }
        }
    }
    

Here we use the _onContinueUserActivity_ view modifier to extract the instance
of _UserActivity_ type if it is available and navigate to the particular
screen.

####  Conclusion

State restoration is the key feature to implement a fluid user experience.
SwiftUI provides us with all the needed APIs to implement it quickly without
too many lines of code. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Unidirectional flow in Swift

##  Unidirectional flow in Swift

11 Jul 2023

This week I will talk about the state management approach I have used in my
apps for years. We will cover building a predictable, testable, debuggable,
and modular state management system in Swift.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Swift promotes type-safe code by using a set of language features allowing us
to encode the correct behavior into the type system. We aim to model our types
so that the logical mistake becomes a compile-time error instead of a runtime
error. We can achieve that by using value types, enums, optionals, protocols,
generics, phantom types, etc.

> To learn more about writing type-safe code in Swift, take a look at my [
> “Writing idiomatic Swift code” ](/2021/04/01/writing-idiomatic-swift-code/)
> post.

But what about type-safe state management systems? How can we build it using
Swift language features? We will apply the same tools to build a functional
and safe state management system.

    
    
    import Observation
    
    @Observable final class Store<State, Action> {
        private(set) var state: State
        private let reduce: (State, Action) -> State
        
        init(
            initialState state: State,
            reduce: @escaping (State, Action) -> State
        ) {
            self.state = state
            self.reduce = reduce
        }
        
        func send(_ action: Action) {
            state = reduce(state, action)
        }
    }
    

Here is a basic example of the state management system we can build in Swift.
We express the _Store_ type that defines two generic types: one for state and
another for action. It holds the current state in the variable that we can
only mutate inside the _Store_ type. It also provides us with the _send_
function, which takes a generic action as a parameter and mutates the current
state. The whole type is marked with the _Observable_ macro allowing us to be
notified whenever the state changes.

####  Predictable

The first goal in building a state management system we want to achieve is to
make it predictable. As you can see in the example above, the only way to
mutate the state is by sending a predefined action. All the view and view
controllers in your app take an instance of the _Store_ type and only can read
the actual state. There is no way to change something in the state directly.
The only way to update the state is to send an action.

    
    
    struct ShopState: Equatable {
        var products: [String] = []
    }
    
    enum ShopAction: Equatable {
        case add(String)
        case remove(String)
    }
    
    let reduce: (ShopState, ShopAction) -> ShopState = { state, action in
        var newState = state
        
        switch action {
        case let .add(product):
            newState.products.append(product)
        case let .remove(product):
            newState.products.removeAll { $0 == product }
        }
        
        return newState
    }
    
    typealias ShopStore = Store<ShopState, ShopAction>
    

_Reduce_ function is the only place containing state update logic. It doesn’t
mean you should have a single function for the whole app. You can compose
multiple _reduce_ functions into a single one. Usually, I have a _reduce_
function per feature module of my app.

    
    
    import SwiftUI
    
    struct ShopView: View {
        @State private var store = ShopStore(
            initialState: .init(products: []),
            reduce: reduce
        )
        
        var body: some View {
            List(store.state.products, id: \.self) { product in
                Text(verbatim: product)
                    .swipeActions {
                        Button(role: .destructive) {
                            store.send(.remove(product))
                        } label: {
                            Label("Delete", systemImage: "trash")
                        }
                    }
            }
        }
    }
    

As you can see in the example above, we define a list displaying the products.
We also allow to remove a product from the list by using swipe actions. The
view has read-only access to the state and can only render it as is. The only
way to mutate the state is to use the _send_ function with one of the
predefined cases of the _ShopAction_ enum.

This approach is called unidirectional flow. As its name says, there is only
one direction to go. The view sends actions, the store updates the state, and
the view takes the updated state. By applying this approach, we make our state
management predictable. You always know where to look for the mutation and
where your app’s business logic lives.

####  Testable

As we said before, the app logic lives in the _reduce_ function. It is a pure
function that takes the current state and action to apply as parameters and
returns a new state. Both state and action are value types. Usually, we use a
struct for the state and enum for the action. It means we can easily verify
any _reduce_ functions in unit tests.

    
    
    import XCTest
    
    final class ShopReducerTests: XCTestCase {
        func testRemove() {
            let initialState = ShopState(products: ["p1"])
            let newState = reduce(initialState, .remove("p1"))
            
            XCTAssertTrue(newState.products.isEmpty)
        }
    }
    

All we need to do is to create an initial state and call the _reduce_ function
with the particular action. Then, we can verify that the new state returned by
the _reduce_ function contains all the required changes.

####  Previewable

This approach works great with Xcode previews. You can create multiple
previews with different initial states. For example, one for the empty list
and another for the list of products. There is no need for mocking protocols
because the state is a simple struct you can create and put into the store to
render in the view.

    
    
    #Preview {
        AnotherShopView(
            store: .init(
                initialState: .init(products: ["Product"]),
                reduce: reduce
            )
        )
    }
    
    #Preview {
        AnotherShopView(
            store: .init(
                initialState: .init(products: []),
                reduce: reduce
            )
        )
    }
    

####  Debuggable

Debugging and logging became very easy. If something goes wrong, you know
where to look. The _reduce_ function is the only place containing app logic,
and it is the best place to put log messages because all actions go through
the _reduce_ function. It means your logs will never miss any state change.

By keeping the feature state in a single place, we can easily track the
history of the state changes. It will help us to understand which action
sequence led to a bug. We also can encode the state into a JSON and retrieve
it to analyze or restore it under the debugger to inspect the bug.

####  Modular

Many of my colleagues correlate the unidirectional flow with a single-state
container where the whole app state lives in a single instance of the
particular _AppState_ struct. Yes, it is possible, but it is not the only way.

> To learn more about modularizing your app, take a look at my [ “Microapps
> architecture in Swift. Feature modules” ](/2022/01/19/microapps-
> architecture-in-swift-feature-modules/) post.

Usually, I define a store per feature. So every independent feature has its
own store. It allows us to optimize for the performance because, in the case
of a huge app, a single store in the app can lead to performance degradation
where the whole app hierarchy refreshes on every small state change.

####  References

After years of building apps similarly, these ideas resulted in a Swift
Package called [ swift-unidirectional-flow ](http://github.com/mecid/swift-
unidirectional-flow) . It implements all the ideas we discussed in a
production-ready code supporting concurrency and other features you might need
to build a real-life app.

I’m not advocating for using this package. Specifically, you should not import
any third-party library or framework to build the core features of your app.
But you can use it for inspiration to build state management system in your
app with your needs.

####  Conclusion

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Structural identity in SwiftUI

##  Structural identity in SwiftUI

09 Dec 2021

Structural identity is the type of identity that SwiftUI uses to understand
your views without an explicit identifier by using your layout description.
This week we will learn how to improve performance and eliminate unwanted
animations by using inert view modifiers in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Structural identity

Structural identity is how SwiftUI understands your view hierarchy and
recognizes particular views without specific identifiers. Let’s look at the
quick examples that demonstrate the logic behind the structural identity.

    
    
    struct UserView: View {
        let user: User?
    
        var body: some View {
            if let user = user {
                LoggedUser(user: user)
            } else {
                AnonymousUserView()
            }
        }
    }
    
    print(Mirror(reflecting: UserView(user: nil).body))
    // Mirror for _ConditionalContent<LoggedUser, AnonymousUserView>
    

As you can see in the example above, SwiftUI creates an instance of
__ConditionalContent_ view that uses some condition to present one or another
view. In our case, __ConditionalContent_ view uses **if let** binding to
decide which views it has to show. SwiftUI destroys and creates the views
whenever the condition changes. This process deallocates the destroyed view’s
state and uses animation to remove the destroyed view.

    
    
    struct AchievementView: View {
        let isEnabled: Bool
    
        var body: some View {
            if isEnabled {
                ComplexView()
            } else {
                ComplexView()
                    .disabled(true)
            }
        }
    }
    

In the current example, we use the _if_ statement to enable or disable the
view conditionally. We still use branching via _if_ statement, and SwiftUI
will destroy and create views accordingly. It might look correct, but we lose
the state of the instance of _ComplexView_ during the condition change because
SwiftUI recreates view inside the branches of the _if_ statement, and more, we
get unwanted animation while swapping these views.

Let’s solve our issue by removing the _if_ statement and moving the condition
inside the _disabled_ view modifier.

    
    
    struct AchievementView: View {
        let isEnabled: Bool
    
        var body: some View {
            ComplexView()
                .disabled(isEnabled ? false : true)
        }
    }
    

In the example above, we don’t have the _if_ statement. We inline the
condition inside the _disable_ view modifier, which allows us to keep the
structural identity of our view. SwiftUI understands that it is the same view
but with a different value for the _disabled_ view modifier.

Remember that you should use branching via **if** or **switch** statement only
when you need to present different views. Always try to inline your conditions
inside the view modifiers to keep your structural identity.

> To learn more why SwiftUI uses structural identity, take a look at my [ “You
> have to change mindset to use SwiftUI” ](/2019/11/19/you-have-to-change-
> mindset-to-use-swiftui/) post.

####  Inert modifiers

SwiftUI framework is smart enough to understand and optimize your view
hierarchy. It provides us with a set of inert view modifiers which doesn’t
affect view tree, and you can use them for free. Let’s take a look at some of
them in the example below.

    
    
    struct AchievementView: View {
        let isEnabled: Bool
    
        var body: some View {
            ComplexView()
                .opacity(isEnabled ? 1 : 0)
                .padding(isEnabled ? 8 : 0)
        }
    }
    

There is no changes in the view tree when you set the padding to 0 or opacity
to 1. SwiftUI understands that and doesn’t apply these view modifiers. That’s
why we call them inert view modifiers. Try to use them as much as possible to
improve the performance of your view and remove unwanted transitions.

> To learn more tips and tricks dedicated to view composition in SwiftUI, take
> a look at my [ “View composition in SwiftUI” ](/2019/10/30/view-composition-
> in-swiftui/) post.

####  Conclusion

This week we learned about structural identity in SwiftUI. It is crucial to
understand how it works to build great and performant views with SwiftUI. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering NavigationStack in SwiftUI. NavigationPath.

##  Mastering NavigationStack in SwiftUI. NavigationPath.

05 Oct 2022

SwiftUI provides us with a brand new data-driven navigation API allowing us to
map a value to a destination in the view hierarchy. This week I want to
continue the story of the new navigation API in SwiftUI by covering another
tool. We will learn how to use the _NavigationPath_ type to build a navigation
stack with different destinations.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

As you might know from my previous posts, SwiftUI provides value-based
navigation links allowing us to bind value programmatically to any view in the
navigation stack. Here is a quick example.

    
    
    struct ShopContainerView: View {
        @StateObject private var store = Store()
        @State private var path: [Product] = []
    
        var body: some View {
            NavigationStack(path: $path) {
                List(store.products) { product in
                    NavigationLink(product.title, value: product)
                }
                .task { await store.fetch() }
                .navigationDestination(for: Product.self) { product in
                    ProductView(product: product)
                        .toolbar {
                            Button("Show similar") {
                                path.append(product.similar[0])
                            }
                        }
                }
            }
        }
    }
    

In the example above, we define the piece of state that controls our
navigation stack. In this case, we can push only values of type _Product_ .
Usually, we want to push different views into the navigation stack. To achieve
that, we can define an enum type covering all the possible cases of navigation
destinations we have in the app. But suppose you are a bit lazy to define an
enum type. In that case, SwiftUI provides you with a type called
_NavigationPath_ , allowing us to store any hashable value and map them to the
destination in the navigation stack.

    
    
    struct ShopContainerView: View {
        @StateObject private var store = Store()
        @State private var path = NavigationPath()
        
        var body: some View {
            NavigationStack(path: $path) {
                List(store.products) { product in
                    NavigationLink(product.title, value: product)
                }
                .task { await store.fetch() }
                .navigationDestination(for: String.self) { query in
                    SearchView(query: query)
                }
                .navigationDestination(for: Product.self) { product in
                    ProductView(product: product)
                        .toolbar {
                            Button("Show similar") {
                                path.append(product.query)
                            }
                        }
                }
            }
        }
    }
    

As you can see in the example above, we define a variable of the type
_NavigationPath_ to store the whole navigable state. _NavigationPath_ erases
the type of pushed values and allows us to keep values of different types. The
only requirement is to push only hashable values.

> To learn about the basics of the new data-driven Navigation API in SwiftUI,
> look at my [ “Mastering NavigationStack in SwiftUI. Navigator Pattern.”
> ](/2022/06/15/mastering-navigationstack-in-swiftui-navigator-pattern/) post.

Another bonus of using _NavigationPath_ is the codable representation of
pushed values. The _NavigationPath_ provides the codable property of type
_CodableRepresentation_ , allowing us to encode pushed values into the _Data_
type and store it somewhere. Make sure that the values you push conform to
_Codable_ . Otherwise, the codable representation of the _NavigationPath_ will
be _nil_ .

The _NavigationPath_ type also has a particular initializer accepting a value
of type _CodableRepresentation_ to restore the whole navigation stack from the
serialized representation.

    
    
    protocol UrlHandler {
        func handle(_ url: URL, mutating: inout NavigationPath)
    }
    
    protocol ActivityHandler {
        func handle(_ activity: NSUserActivity, mutating: inout NavigationPath)
    }
    
    @MainActor final class NavigationStore: ObservableObject {
        @Published var path = NavigationPath()
        
        private let decoder = JSONDecoder()
        private let encoder = JSONEncoder()
        private let urlHandler: UrlHandler
        private let activityHandler: ActivityHandler
        
        init(urlHandler: UrlHandler, activityHandler: ActivityHandler) {
            self.urlHandler = urlHandler
            self.activityHandler = activityHandler
        }
        
        func handle(_ activity: NSUserActivity) {
            activityHandler.handle(activity, mutating: &path)
        }
        
        func handle(_ url: URL) {
            urlHandler.handle(url, mutating: &path)
        }
        
        func encoded() -> Data? {
            try? path.codable.map(encoder.encode)
        }
        
        func restore(from data: Data) {
            do {
                let codable = try decoder.decode(
                    NavigationPath.CodableRepresentation.self, from: data
                )
                path = NavigationPath(codable)
            } catch {
                path = NavigationPath()
            }
        }
    }
    

Here is the implementation of the _NavigationStore_ type that I use in my apps
to maintain navigation and deep linking logic. As you can see, I use the
_NavigationPath_ type to keep the state of a navigation stack. There are also
helper functions allowing me to serialize and restore the navigation state
quickly.

    
    
    struct AppContainerView: View {
        @StateObject private var navigationStore = NavigationStore(
            urlHandler: SomeUrlHandler(),
            activityHandler: SomeActivityHandler()
        )
        
        @SceneStorage("navigation")
        private var navigationData: Data?
        
        var body: some View {
            NavigationStack(path: $navigationStore.path) {
                ContentView()
                    .environmentObject(navigationStore)
                    .onOpenURL { navigationStore.handle($0) }
                    .navigationDestination(for: String.self) { string in
                        Text(string)
                    }
                    .task {
                        if let navigationData {
                            navigationStore.restore(from: navigationData)
                        }
                        
                        for await _ in navigationStore.$path.values {
                            navigationData = navigationStore.encoded()
                        }
                    }
            }
        }
    }
    

As you can see in the example above, we use our _NavigationStore_ to serialize
and store the state of navigation in the scene storage.

> To learn more about state restoration in SwiftUI, look at my [ “State
> restoration in SwiftUI” ](/2022/03/10/state-restoration-in-swiftui/) post.

Today we learned how to use the _NavigationPath_ type to push different views
programmatically without defining additional types. We also learned how to
serialize and store the current state of navigation in the scene storage to
provide a better user experience. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Building calendar without UICollectionView in SwiftUI

##  Building calendar without UICollectionView in SwiftUI

06 May 2020

One of the most expected features of SwiftUI 2.0 is a SwiftUI alternative to
_UICollectionView_ . _UICollectionView_ provides us an easy way to build super
custom interfaces like calendar or photos grid. But today, I want to show you
that we can create a calendar view without _UICollectionView_ by using only
pure SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start by describing what we want to achieve with our calendar view. The
calendar view is a container view that displays its child views using a
calendar-based grid. These are my requirements for a calendar view:

  1. It should scroll vertically through months. 
  2. It should respect to calendar settings that the user has on the device. 
  3. It should provide a nice API to build custom day cells. 

OK, now we have the list of requirements for our component. We can start
coding.

    
    
    struct CalendarView<DateView>: View where DateView: View {
        let interval: DateInterval
        let content: (Date) -> DateView
    
        init(
            interval: DateInterval,
            @ViewBuilder content: @escaping (Date) -> DateView
        ) {
            self.interval = interval
            self.content = content
        }
    }
    

Here we define our _CalendarView_ struct that accepts date interval in which
it needs to display dates and a _@ViewBuilder_ closure that we will use to
build day cells.

> _ViewBuilder_ is a great way to extract view construction logic and provide
> a DSL like syntax. I already talked about _@ViewBuilder_ function builder on
> my blog multiple times. To learn more, take a look at my [ “The power of
> @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-viewbuilder-in-swiftui/)
> post.
    
    
    struct CalendarView<DateView>: View where DateView: View {
        @Environment(\.calendar) var calendar
    
        let interval: DateInterval
        let content: (Date) -> DateView
    
        init(
            interval: DateInterval,
            @ViewBuilder content: @escaping (Date) -> DateView
        ) {
            self.interval = interval
            self.content = content
        }
    
        private var months: [Date] {
            calendar.generateDates(
                inside: interval,
                matching: DateComponents(day: 1, hour: 0, minute: 0, second: 0)
            )
        }
    
        var body: some View {
            ScrollView(.vertical, showsIndicators: false) {
                VStack {
                    ForEach(months, id: \.self) { month in
                        MonthView(month: month, content: self.content)
                    }
                }
            }
        }
    }
    

Now we can display a scroll view that has a vertical stack as its root view.
We use a calendar to generate all months in the date interval that the user
provides us. As you can see, we use a system calendar that SwiftUI put in the
environment. SwiftUI will also update the view as soon as the user changes the
calendar in system settings.

> As I said before, the environment is one of my favorite features of SwiftUI.
> To learn more about the environment feature, take a look at my [ “The power
> of Environment in SwiftUI” ](/2019/08/21/the-power-of-environment-in-
> swiftui/) post.

As you can see, I decided to create the separated _MonthView_ struct that
displays a single month in our calendar view. SwiftUI allows us to compose
multiple views to build an excellent view hierarchy. I want to note that I
reuse _MonthView_ in other parts of my app to present a calendar preview.

    
    
    struct MonthView<DateView>: View where DateView: View {
        @Environment(\.calendar) var calendar
    
        let month: Date
        let content: (Date) -> DateView
    
        init(
            month: Date,
            @ViewBuilder content: @escaping (Date) -> DateView
        ) {
            self.month = month
            self.content = content
        }
    
        private var weeks: [Date] {
            guard
                let monthInterval = calendar.dateInterval(of: .month, for: month)
                else { return [] }
            return calendar.generateDates(
                inside: monthInterval,
                matching: DateComponents(hour: 0, minute: 0, second: 0, weekday: calendar.firstWeekday)
            )
        }
    
        var body: some View {
            VStack {
                ForEach(weeks, id: \.self) { week in
                    WeekView(week: week, content: self.content)
                }
            }
        }
    }
    

As you can see in the code example above, _MonthView_ struct is a plain view
that uses the system provided calendar to generate weeks and render them using
a vertical stack with a collection of week views.

    
    
    struct WeekView<DateView>: View where DateView: View {
        @Environment(\.calendar) var calendar
    
        let week: Date
        let content: (Date) -> DateView
    
        init(
            week: Date,
            @ViewBuilder content: @escaping (Date) -> DateView
        ) {
            self.week = week
            self.content = content
        }
    
        private var days: [Date] {
            guard
                let weekInterval = calendar.dateInterval(of: .weekOfYear, for: week)
                else { return [] }
            return calendar.generateDates(
                inside: weekInterval,
                matching: DateComponents(hour: 0, minute: 0, second: 0)
            )
        }
    
        var body: some View {
            HStack {
                ForEach(days, id: \.self) { date in
                    HStack {
                        if self.calendar.isDate(self.week, equalTo: date, toGranularity: .month) {
                            self.content(date)
                        } else {
                            self.content(date).hidden()
                        }
                    }
                }
            }
        }
    }
    

Week view is the latest piece of my calendar view. It also uses the system
provided calendar to generate days inside the given week and renders them
using a horizontal stack by applying passed _@ViewBuilder_ closure to
construct a view per day.

    
    
    struct RootView: View {
        @Environment(\.calendar) var calendar
    
        private var year: DateInterval {
            calendar.dateInterval(of: .year, for: Date())!
        }
    
        var body: some View {
            CalendarView(interval: year) { date in
                Text("30")
                    .hidden()
                    .padding(8)
                    .background(Color.blue)
                    .clipShape(Circle())
                    .padding(.vertical, 4)
                    .overlay(
                        Text(String(self.calendar.component(.day, from: date)))
                    )
            }
        }
    }
    

In the example above, you see how we can use our calendar view. I want you to
pay attention to the way that I use to construct a day view. I call it
template view. I create a hidden text with the template value that has the
maximal width. Then I show the real content as the overlay of the template
view. This approach allows me to have day views of the same size. We can use
the frame modifier instead, but in this case, we will break dynamic type
support by limiting the space.

> To learn more about benefits of view composition, take a look at my [ “View
> composition in SwiftUI” ](/2019/10/30/view-composition-in-swiftui/) post.

![calendar-screenshot](/public/calendar.png)

Here is the final result of our work. I think it looks nice, and I will use it
in my next app. You can access full source code via [ Github Gist
](https://gist.github.com/mecid/f8859ea4bdbd02cf5d440d58e936faec/9169b0293f709bb1f560de2ca8184ea903fd5116)
.

####  Conclusion

I still think that we will have a _UICollectionView_ alternative later this
year. But I need to mention that SwiftUI has such a friendly layout system
that we can use to build great views. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Sensory feedback in SwiftUI

##  Sensory feedback in SwiftUI

10 Oct 2023

SwiftUI introduced the new _sensoryFeedback_ view modifier, allowing us to
play haptic feedback on all Apple platforms. This week, we will learn how to
use the _sensoryFeedback_ modifier to give haptic feedback on different
actions in our apps.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

All we need to play haptic feedback in a SwiftUI view is to attach the
_sensoryFeedback_ view modifier with two parameters. The first defines a
feedback style, and the second is a trigger value.

    
    
    struct ContentView: View {
        @State private var store = Store()
        
        var body: some View {
            NavigationStack {
                List(store.results, id: \.self) { result in
                    Text(result)
                }
                .searchable(text: $store.query)
                .sensoryFeedback(.success, trigger: store.results)
            }
        }
    }
    

As you can see in the example above, we use the _sensoryFeedback_ view
modifier with _success_ style. We also define the _results_ property of the
store as a trigger. It means SwiftUI will play the success-styled haptic
feedback whenever store results change.

SwiftUI provides a bunch of predefined feedback styles like _success_ ,
_warning_ , _error_ , _selection_ , _increase_ , _decrease_ , _start_ , _stop_
, _alignment_ , _levelChange_ , _impact_ , etc.

    
    
    struct ContentView: View {
        @State private var trigger = false
        
        var body: some View {
            NavigationStack {
                Button("Action") {
                    // do something
                    trigger.toggle()
                }
                .sensoryFeedback(
                    .impact(weight: .heavy, intensity: 0.9),
                    trigger: trigger
                )
            }
        }
    }
    

As you can see, the _impact_ style allows us to tune the _weight_ and
_intensity_ of the feedback. Remember that it is always better to use the
predefined style and customize the haptic feedback for super custom cases.

    
    
    struct ContentView: View {
        @State private var store = Store()
        
        var body: some View {
            NavigationStack {
                List(store.results, id: \.self) { result in
                    Text(result)
                }
                .searchable(text: $store.query)
                .sensoryFeedback(trigger: store.results) { oldValue, newValue in
                    return newValue.isEmpty ? .error : .success
                }
            }
        }
    }
    

Another variant of the _sensoryFeedback_ view modifier allows us to choose a
particular feedback style depending on the trigger value. Here, we play
_success_ feedback whenever our store contains results and play _error_
feedback whenever results are empty.

    
    
    struct ContentView: View {
        @State private var store = Store()
        
        var body: some View {
            NavigationStack {
                List(store.results, id: \.self) { result in
                    Text(result)
                }
                .searchable(text: $store.query)
                .sensoryFeedback(.success, trigger: store.results) { oldValue, newValue in
                    return newValue.isEmpty
                }
            }
        }
    }
    

SwiftUI also provides an option to define a condition on trigger value,
deciding whenever it should play or not a predefined feedback style.

This week, we learned how to use the new _sensoryFeedback_ view modifier to
play haptic feedback in our SwiftUI views. Remember that you shouldn’t
overwhelm the user with haptics. Use them to improve accessibility and
significant task results. I hope you enjoy the post. Feel free to follow me on
[ Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Designing API using Combine framework

##  Designing API using Combine framework

07 Apr 2021

Combine framework provides a declarative Swift API for processing values over
time. It allows you to chain, transform and reduce multiple operations. This
week we will learn how to design our APIs using the Combine framework to
leverage all the data processing power that the framework provides us.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Future and Deferred publishers

The easiest way to integrate your asynchronous API with the Combine framework
is to use _Future_ publisher. All you need to do is provide closure that calls
the completion handler whenever it finishes the job. Let’s take a look at the
simple example.

    
    
    final class HealthService {
        private let store = HKHealthStore()
    
        func authorize() -> AnyPublisher<Bool, Error> {
            Future { handler in
                self.store.requestAuthorization(
                    toShare: [.workout], 
                    read: [.hr]
                ) { success, error in
                    if let error = error {
                        handler(.failure(error))
                    } else {
                        handler(.success(success))
                    }
                }
            }.eraseToAnyPublisher()
        }
    

As you can see in the example above, we wrap the old school HealthKit API with
_Future_ publisher. Inside the _Future_ publisher, we call the asynchronous
method of _HKHealthStore_ to authorize the user. We deliver the result of the
_HKHealthStore_ ’s authorize method using the handler of _Future_ publisher.

The _Future_ publisher has a few downsides, and one of them is the publisher’s
eager nature. It means Combine will run the publisher as soon as you create
it.

    
    
    let health = HealthService()
    let authPublisher = health.authorize()
    

In the example above, we create an instance of an authorization publisher but
never subscribe to it. We expect that Combine will run the publisher later
when we subscribe to it using a _sink_ or _assign_ , but it runs immediately.
The Combine framework provides us the _Deferred_ publisher that prevents these
situations.

    
    
    final class HealthService {
        private let store = HKHealthStore()
    
        func authorize() -> AnyPublisher<Bool, Error> {
            Deferred {
                Future { handler in
                    self.store.requestAuthorization(
                        toShare: [.workout], 
                        read: [.hr]
                    ) { success, error in
                        if let error = error {
                            handler(.failure(error))
                        } else {
                            handler(.success(success))
                        }
                    }
                }
            }.eraseToAnyPublisher()
        }
    }
    

We can quickly wrap a _Future_ publisher with a _Deferred_ publisher to make
it lazy. _Deferred_ publisher runs only when we subscribe to it. Now we can
use our new API and leverage all the power of declarative value processing.

    
    
    let health = HealthService()
    var cancellables: Set<AnyCancellable> = []
    
    health
        .authorize()
        .retry(3)
        .replaceError(with: false)
        .sink { print("user authorized: \($0)") }
        .store(in: &cancellables)
    

> To learn more about the set of operators that the Combine framework provides
> us, take a look at my [ “Catching errors in Combine” ](/2020/04/22/catching-
> errors-in-combine/) post.

####  PassthroughSubject

_Future_ publisher works excellent when you need to wrap the asynchronous task
and deliver a single result. But what about the stream of values that we want
to provide over time? We can’t do that with _Future_ publisher because it
finishes its work as soon as it delivers the first result. We can handle this
case with _PassthroughSubject_ .

_PassthroughSubject_ is a publisher that you can use to inject values into a
stream by calling its _send_ method. We will use _PassthroughSubject_ to
design the APIs that provide values through time. For example, it might be
user location or user heart rate. These values appear over time.

    
    
    final class HealthService1 {
        private let store = HKHealthStore()
    
        func heartRate() -> AnyPublisher<[Double], Error> {
            let subject = PassthroughSubject<[Double], Error>()
    
            let query = HKAnchoredObjectQuery(
                type: HKQuantityType.heartRate,
                predicate: nil,
                anchor: nil,
                limit: HKObjectQueryNoLimit
            ) { query, newSamples, _, _, error in
                if let error = error {
                    subject.send(completion: .failure(error))
                } else {
                    let newSamples = newSamples as? [HKQuantitySample] ?? []
                    let hr = newSamples.compactMap { $0.quantity.doubleValue(for: .bpm()) }
                    subject.send(hr)
                }
            }
    
            return subject.handleEvents(
                receiveSubscription: { _ in self.store.execute(query) },
                receiveCancel: { self.store.stop(query) }
            ).eraseToAnyPublisher()
        }
    }
    

As you can see, we use the subject’s _send_ method to emit values that we
obtain from a closure-based handler of _HKAnchoredObjectQuery_ .
_HKAnchoredObjectQuery_ runs forever. That’s why we use the _handleEvents_
operator to provide additional logic to handle the publisher’s lifecycle. We
want to start the query only when we have a subscription and stop it
immediately when the subscription is canceled.

    
    
    var cancellables: Set<AnyCancellable> = []
    
    health
        .authorize()
        .retry(3)
        .flatMap { authorized -> AnyPublisher<[Double], Error> in
            if authorized {
                return health.heartRate().eraseToAnyPublisher()
            } else {
                return Empty().eraseToAnyPublisher()
            }
        }
        .replaceError(with: [])
        .sink { print("user authorized: \($0)") }
        .store(in: &cancellables)
    

####  Conclusion

Combine provides us a straightforward and friendly way to handle asynchronous
operations. We need to design our own APIs using the Combine to leverage the
powerful operators that it gives us. We can model complex operation chains
using a declarative approach and tools like _Future_ and _PassthroughSubject_
. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering MapKit in SwiftUI. Customizations.

##  Mastering MapKit in SwiftUI. Customizations.

05 Dec 2023

Last week, we started a series of posts about the new MapKit API in SwiftUI.
We talked about the basics of the new API, and now we can continue the topic
by covering the customization part of new APIs. This week, we will learn the
customization points of MapKit API in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Map style

The new MapKit API introduces the _mapStyle_ view modifier, allowing us to
customize the style of the data presented on the map.

    
    
    struct ContentView: View {
        var body: some View {
            Map {
                // ...
            }
            .mapStyle(.imagery(elevation: .realistic))
        }
    }
    

As you can see in the example above, we use the _mapStyle_ view modifier with
the _imagery_ style and realistic elevation. Another option for the elevation
parameter of the imagery style is flat.

![imagery-map](/public/map4.png)

SwiftUI provides us with a set of predefined and configurable map styles. In
the previous example, we used a style called _imagery_ . By default, the
SwiftUI framework uses the _standard_ style. The standard style allows us to
configure the elevation of the map, points of interest we want to include or
exclude from the map, and whenever we need to show traffic.

    
    
    struct ContentView: View {
        var body: some View {
            Map {
                // ...
            }
            .mapStyle(
                .standard(
                    elevation: .flat,
                    pointsOfInterest: .excluding([.store]),
                    showsTraffic: false
                )
            )
        }
    }
    

Another option is the _hybrid_ style, allowing us to display imagery, roads,
and road names on the map. The hybrid style also configures elevation,
traffic, and points of interest.

    
    
    struct ContentView: View {
        var body: some View {
            Map {
                // ...
            }
            .mapStyle(
                .hybrid(
                    elevation: .flat,
                    pointsOfInterest: .including([.airport]),
                    showsTraffic: true
                )
            )
        }
    }
    

####  Map interactions

MapKit supports different types of interactions with the map. You can _zoom_ ,
_pan_ , _pitch_ , and _rotate_ the content on the map. By default, SwiftUI
activates all of the available gestures. But you can easily limit available
interactions to the list of the preferred ones.

    
    
    struct ContentView: View {
        var body: some View {
            Map(interactionModes: [.pan, .pitch]) {
                // ...
            }
        }
    }
    

####  Map controls

Whenever you import MapKit in pair with SwiftUI, you will get access to the
particular SwiftUI views you can use as map controls. These views include
_MapScaleView_ , _MapCompass_ , _MapPitchToggle_ , _MapUserLocationButton_ ,
and _MapZoomStepper_ views.

    
    
    struct ContentView: View {
        var body: some View {
            Map {
                // ...
            }
            .mapControls {
                MapScaleView()
                MapCompass()
            }
        }
    }
    

You can use these views in pair with the _mapControls_ view modifier to
specify controls for any map instances sharing the same environment in the
SwiftUI view hierarchy.

Whenever you place _MapScaleView_ or _MapCompass_ views inside the
_mapControls_ view modifier, you allow SwiftUI to control the placement of the
map controls. In this case, SwiftUI decides the placement of the control
depending on the platform running the app.

As you may have noticed, _MapScaleView_ and other map controls are simple
SwiftUI views, which means you can use them outside of the _mapControls_ view
modifier anywhere you want. In this case, to bind a map control to a
particular map instance, you should use the _mapScope_ view modifier.

    
    
    struct MapScopeExample: View {
        @Namespace private var favoritesMap
        var body: some View {
            VStack {
                Map(scope: favoritesMap) {
                    // favorite pins
                }
                
                HStack {
                    MapScaleView(scope: favoritesMap)
                    MapCompass(scope: favoritesMap)
                }
            }
            .mapScope(favoritesMap)
        }
    }
    

As you can see in the example above, we use _Namespace_ property wrapper to
generate a map identifier to bind controls to the map instance. You can also
use the _mapControlVisibility_ view modifier when you need to change the
automatic visibility configuration to always visible or hidden.

    
    
    struct MapScopeExample: View {
        @Namespace private var favoritesMap
        var body: some View {
            VStack {
                Map(scope: favoritesMap) {
                    // favorite pins
                }
                
                HStack {
                    MapScaleView(scope: favoritesMap)
                    MapCompass(scope: favoritesMap)
                        .mapControlVisibility(.hidden)
                }
            }
            .mapScope(favoritesMap)
        }
    }
    

Today, we learned how to customize map presentation in SwiftUI. SwiftUI
provides a flexible and easy-to-use API for configuring map controls, styles,
and interaction modes. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!

  1. [ Mastering MapKit in SwiftUI. Basics. ](/2023/11/28/mastering-mapkit-in-swiftui-basics/)
  2. Mastering MapKit in SwiftUI. Customizations. 
  3. [ Mastering MapKit in SwiftUI. Camera. ](/2023/12/12/mastering-mapkit-in-swiftui-camera/)
  4. [ Mastering MapKit in SwiftUI. Interactions. ](/2023/12/19/mastering-mapkit-in-swiftui-interactions/)



# Confirmation dialogs in SwiftUI

##  Confirmation dialogs in SwiftUI

28 Jul 2021

SwiftUI Release 3 brings a few generic view modifiers that allow us to handle
semantically similar operations for different views in the very same way. One
of these view modifiers is _onSubmit_ , which we can use to manage both forms
and search fields. This week we will talk about another view modifier that
SwiftUI provides us to display confirmation dialogs.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Confirmation dialog is a widespread UI/UX pattern that we usually use to
confirm some dangerous actions in our apps. For example, we might present a
confirmation dialog before deleting any sensitive data from the app.

    
    
    struct ContentView: View {
        @StateObject var viewModel = ViewModel()
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(viewModel.messages, id: \.self) { message in
                        Text(message)
                            .swipeActions {
                                Button(
                                    role: .destructive,
                                    action: { 
                                        withAnimation {
                                            viewModel.delete(message) 
                                        } 
                                    }
                                ) {
                                    Image(systemName: "trash")
                                }
                            }
                    }
                }
                .navigationTitle("Messages")
                .onAppear { viewModel.fetch() }
            }
        }
    }
    

As you can see in the example above, we have a screen showing a list of
messages from the view model. We use swipe actions to provide actions related
to a list item. In our case, we display a destructive button that deletes the
message as soon as you hit it. Let’s take a look at how we can show
confirmation dialog using the new _confirmationDialog_ view modifier.

    
    
    struct ContentView: View {
        @StateObject var viewModel = ViewModel()
        @State private var confirmationShown = false
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(viewModel.messages, id: \.self) { message in
                        Text(message)
                            .swipeActions {
                                Button(
                                    role: .destructive,
                                    action: { confirmationShown = true }
                                ) {
                                    Image(systemName: "trash")
                                }
                            }
                            .confirmationDialog(
                                "Are you sure?",
                                 isPresented: $confirmationShown
                            ) { 
                                Button("Yes") {
                                    withAnimation { 
                                        viewModel.delete(message) 
                                    }
                                }
                            }
                    }
                }
                .navigationTitle("Messages")
                .onAppear { viewModel.fetch() }
            }
        }
    }
    

![confirmation-dialog](/public/confirmation0.png)

We attach the _confirmationDialog_ view modifier to the _Text_ view that we
want to delete. It needs a few parameters to display a confirmation dialog.

  1. The first one is the title of the particular confirmation dialog. It can be a _Text_ view or _LocalizedStringKey_ . 
  2. The second one is binding to a boolean value that indicates whenever to present the confirmation dialog. 
  3. The third one is the _@ViewBuilder_ closure that we can use to provide available actions using button views. Keep in mind that we can use buttons with text only. 

You don’t need to provide a cancel button. SwiftUI does it automatically for
any confirmation dialog. But you can still offer a button with the cancelation
role to replace the default cancel button.

    
    
    .confirmationDialog("Are you sure?", isPresented: $confirmationShown) {
        Button("Yes") {
            withAnimation { 
                viewModel.delete(message) 
            }
        }
    
        Button("No", role: .cancel) {}
    }
    

![confirmation-dialog](/public/confirmation1.png)

Remember that you don’t need to change the value of binding to false to
dismiss a confirmation dialog. SwiftUI dismisses the confirmation dialog as
soon as the user hits any of the provided actions.

I should mention that the system can reorder the buttons based on their roles
and prominence. SwiftUI uses the higher prominence for the default action. You
can make any of the provided actions default using the _keyboardShortcut_ view
modifier.

    
    
    .confirmationDialog("Are you sure?", isPresented: $confirmationShown) {
        Button("Yes") {
            withAnimation { 
                viewModel.delete(message) 
            }
        }.keyboardShortcut(.defaultAction)
    
        Button("No", role: .cancel) {}
    }
    

SwiftUI handles different environments gracefully and displays confirmation
dialog as a popover when runs in regular size classes and as an action sheet
in compact size classes.

> To learn more about popovers and action sheets in SwiftUI, take a look at my
> [ “Alerts, Action Sheets, Modals and Popovers in SwiftUI”
> ](/2019/07/24/alerts-actionsheets-modals-and-popovers-in-swiftui/) post.

The _confirmationDialog_ view modifier also provides us a way to control the
title visibility of the presented dialog. The _titleVisibility_ parameter
accepts an instance of _Visibility_ enum with one of the following values:
_automatic, visible, and hidden_ .

    
    
    .confirmationDialog(
        "Are you sure?",
        isPresented: $confirmationShown,
        titleVisibility: .visible
    ) {
        Button("Yes") {
            withAnimation { 
                viewModel.delete(message) 
            }
        }.keyboardShortcut(.defaultAction)
    
        Button("No", role: .cancel) {}
    }
    

We can also provide an additional message under the title using a message
parameter that accepts another _@ViewBuilder_ closure to build a view
displaying a custom message.

    
    
    .confirmationDialog(
        "Are you sure?",
        isPresented: $confirmationShown,
        titleVisibility: .visible
    ) {
        Button("Yes") {
            withAnimation { 
                viewModel.delete(message) 
            }
        }.keyboardShortcut(.defaultAction)
    
        Button("No", role: .cancel) {}
    } message: {
        Text("This action cannot be undone")
    }
    

The _confrimationDialog_ view modifier allows us to provide optional data to
pass into _@ViewBuilder_ closures both for message and actions.

    
    
    .confirmationDialog(
        "Are you sure?",
        isPresented: $confirmationShown,
        titleVisibility: .visible,
        presenting: message
    ) { message in
        Button("Yes, delete: \(message)") {
            withAnimation { 
                viewModel.delete(message) 
            }
        }.keyboardShortcut(.defaultAction)
    
        Button("No", role: .cancel) {}
    } message: { message in
        Text(message)
    }
    

> To learn more about the benefits of _ViewBuilder_ closures in SwiftUI, take
> a look at my [ “The power of @ViewBuilder in SwiftUI” ](/2019/12/18/the-
> power-of-viewbuilder-in-swiftui/) post.

I love the new _confirmationDialog_ view modifier and the level of flexibility
it provides to customize the user experience in our apps. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Extracting presentation logic to make it testable

##  Extracting presentation logic to make it testable

01 May 2019

Last week we touched the entirely new topic on my blog. This week we will
continue the Unit Testing subject. One of the smells of a good architecture is
the ability to cover it with Unit Tests. Today we will talk about extracting
Presentation logic into testable and straightforward pieces of code.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

> To learn more about the basics of Unit Testing, take a look at my [
> “Starting Unit Testing with Model layer” ](/2019/04/24/starting-unit-
> testing-with-model-layer/) post.

####  Typical issues

Assume that you have a screen presenting a list of the progress of your TV
show collection. Every cell presents TV show poster, title, and next episode
number and title. Let’s see on typical _ShowCell_ code:

    
    
    struct Show: Decodable {
        let title: String
        let images: Images
        let unwatched: [Episode]
    }
    
    class ShowCell: UICollectionViewCell {
        @IBOutlet private weak var titleLabel: UILabel!
        @IBOutlet private weak var nextEpisodeLabel: UILabel!
        @IBOutlet private weak var posterImageView: UIImageView!
    
        var show: Show? {
            didSet {
                guard let show = show else {
                    return
                }
    
                posterImageView.setImage(from: show.images.poster)
                titleLabel.text = show.title
    
                if let nextEpisode = show.unwatched.first {
                    nextEpisodeLabel.text = "S\(nextEpisode.season)E\(nextEpisode.number) \(nextEpisode.title)"
                }
            }
        }
    }
    

This code looks very simple, and at first glance, there are no huge problems.
But there are probably a few downsides:

  1. We are breaking SOLID principles by mixing presentation logic with view logic inside _ShowCell_ . Our cell is responsible for laying out views and formatting show data into user presentable format. 

  2. We want to test our data formatting logic to be sure that we are presenting the correct information to the user. But it is hard to cover _UIViews_ with Unit Tests, and there is no clear intention on what you test, layout or presentation logic (we will talk about UI testing in next posts). 

####  Refactoring

Let’s start to refactor our codebase. First of all, I want to reuse this
_ShowCell_ across the app for presenting search response, TV shows collection
progress, etc.

    
    
    protocol PosterPresentable {
        var title: String { get }
        var subtitle: String? { get }
        var poster: URL { get }
    }
    
    class PosterCell: UICollectionViewCell {
        @IBOutlet private weak var titleLabel: UILabel!
        @IBOutlet private weak var subtitleLabel: UILabel!
        @IBOutlet private weak var posterImageView: UIImageView!
    
        var presentation: PosterPresentable? {
            didSet {
                guard let presentation = presentation else {
                    return
                }
    
                posterImageView.setImage(from: presentation.poster)
                titleLabel.text = presentation.title
                subtitleLabel.text = presentation.subtitle
            }
        }
    }
    

Here we have refactored version of our _ShowCell_ , now it is called
_PosterCell_ , and it can render any data which conforms _PosterPresentable_
protocol. Let’s go ahead and create a separated struct which will contain
presentation logic for show model and which we will pass to our cell instead
of show model struct.

    
    
    struct ShowPresentation {
        let show: Show
    }
    
    extension ShowPresentation: PosterPresentable {
        var title: String {
            return show.title
        }
    
        var subtitle: String? {
            guard
                let nextEpisode = show.unwatched.first
                else { return nil }
            return "S\(nextEpisode.season)E\(nextEpisode.number) \(nextEpisode.title)"
        }
    
        var poster: URL {
            return show.images.poster
        }
    }
    

By extracting show model formatting logic into _ShowPresentation_ struct, we
fix the encapsulation problem when cell class responsible for formatting own
data model. Another positive effect here is that we can easily cover
_ShowPresentation_ with Unit Testing to make sure it works correctly. So,
let’s continue with implementing tests for our presentation logic.

    
    
    class ShowPresentationTests: XCTestCase {
        func testShowPresentation() {
            let mockedImages = Images(
                poster: URL(string: "https://image.tmdb.org/t/p/original/fbtaoynlPpENx3Ss2laC7wgqLIP.jpg")!,
                banner: URL(string: "https://image.tmdb.org/t/p/original/fbtaoynlPpENx3Ss2laC7wgqLIP.jpg")!,
                background: URL(string: "https://image.tmdb.org/t/p/original/fbtaoynlPpENx3Ss2laC7wgqLIP.jpg")!
            )
    
            let mockedEpisode = Episode(
                title: "The One Where Monica Gets A Roommate",
                season: 1,
                number: 1)
    
            let mockedShow = Show(
                title: "Friends",
                images: mockedImages,
                unwatched: [mockedEpisode]
            )
    
            let presentation = ShowPresentation(show: mockedShow)
            XCTAssertEqual(presentation.title, "Friends")
            XCTAssertEqual(presentation.subtitle,  "S1E1 The One Where Monica Gets A Roommate")
            XCTAssertEqual(presentation.poster.absoluteString, "https://image.tmdb.org/t/p/original/fbtaoynlPpENx3Ss2laC7wgqLIP.jpg")
        }
    }
    

Here we have a Unit Test which is checking the way of how our presentation
struct formats the data. You might have more fields and more complex logic
there. This Unit Test will keep you from breaking the presentation rules of
your data in the future during refactoring or any other changes.

####  Conclusion

Today we discussed how easily we can follow the Single Responsibility
principle during UI development and how we can extract data presentation and
formatting logic into testable and reusable pieces of code. We will continue
the Unit Testing topic on my blog through the next posts. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading and see you next week!



# Focus management in SwiftUI

##  Focus management in SwiftUI

02 Dec 2020

WWDC 20 brings us tons of new SwiftUI APIs, which we can use to improve our
apps user experience without using UIKit. One of these new APIs was the focus
management API that we can use on iOS, macOS, tvOS, and watchOS. This week we
will talk about SwiftUI functionality that allows us to manage the focus in
our apps.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Focus indicates the act of selecting an element of a graphical user interface.
On Apple TV, people use the remote to interact indirectly with onscreen
elements. This interaction is based on a focus model. By pressing buttons and
using gestures on the remote, people move the focus from element to element,
stop on a specific one, and click to access content or initiate action.

You can easily make any view focusable by using the _focusable_ modifier.
Remember that you don’t need to use it with already focusable views like
_List_ and _Button_ . Let’s take a look at how we can use this modifier in
code.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView(.horizontal) {
                LazyHStack {
                    ForEach(0..<100) { index in
                        PosterView()
                            .focusable(true, interactions: .automatic)
                    }
                }
            }
        }
    }
    

As you can see in the example above, we use the _focusable_ modifier to enable
focusing abilities on _PosterView_ . _Focusable_ modifier accepts two
parameters. The first one is the bool value that indicates whenever the view
is focusable or not. The second one is an instance of the _FocusInteractions_
type indicating the focus interaction type, like _activate_ , _edit_ or
_automatic_ . This modifier is available on all Apple platforms.

Another thing that SwiftUI provides us to handle the focused state in our
views is environment value, which allows us to recognize if the view’s nearest
focusable ancestor has focus.

    
    
    struct PosterView: View {
        @Environment(\.isFocused) var isFocused
    
        var body: some View {
            RoundedRectangle(cornerRadius: 8)
                .frame(width: 100, height: 150)
                .scaleEffect(isFocused ? 1.2 : 1)
                .animation(.easeInOut, value: isFocused)
        }
    }
    
    struct ContentView: View {
        var body: some View {
            ScrollView(.horizontal) {
                LazyHStack {
                    ForEach(0..<100) { index in
                        ZStack {
                            PosterView()
                        }
                        .focusable()
                    }
                }
            }
        }
    }
    

In this example, we use the _isFocused_ environment value to understand
whenever our parent _ZStack_ is focused. The view itself doesn’t have to be
focusable because this environment value checks if the view is within the
focused view.

    
    
    struct MyCustomButton: View {
        @Environment(\.isFocused) private var isFocused
        
        var body: some View {
            Button("Some title") {
                // action
            }
            .focusEffectDisabled()
            .border(isFocused ? .red: .clear)
        }
    }
    

You can also disable the default focus effect by using the
_focusEffectDisabled_ view modifier and apply your own customizations by
tracking _isFocused_ environment value.

> SwiftUI uses environment to pass system-wide and application-related
> information. To learn more about environment, take a look at my [ “The power
> of Environment in SwiftUI” ](/2019/08/21/the-power-of-environment-in-
> swiftui/) post.

####  Focus on watchOS and tvOS

We already talked about the APIs available on most Apple platforms, but there
is much more new stuff. There is a bunch of new APIs that we can use only on
watchOS and tvOS. For example, we can define focus entry points for our views
on watchOS and tvOS. Assume that you are working on the login screen. You want
to focus on text fields as soon as the view appears. Let’s take a look at how
we can achieve this behavior with SwiftUI.

    
    
    struct LoginView: View {
        @State private var email = ""
        @State private var password = ""
    
        @State private var hasFilledCredentials = false
        @Namespace private var namespace
    
        @Environment(\.resetFocus) var resetFocus
    
        var body: some View {
            VStack {
                TextField("email", text: $email)
                    .prefersDefaultFocus(!hasFilledCredentials, in: namespace)
    
                SecureField("password", text: $password)
    
                Button("login") {}
                    .prefersDefaultFocus(hasFilledCredentials, in: namespace)
    
                Button("reset credentials") {
                    hasFilledCredentials = false
                    resetFocus(in: namespace)
                }
            }
            .focusScope(namespace)
        }
    }
    

As you can see, SwiftUI provides us a special _prefersDefaultFocus_ modifier
that allows us to define a preferred focus area in our view. Let’s take a
deeper look at how this modifier works. It accepts two parameters. The first
one is bool value describing whenever this view should be preferred as the
default focus area. The second one is the _namespace_ , defined by its
ancestor view and indicates the focus scope. Default focus preference is
limited to its _namespace_ . It allows you to define multiple scopes and
define different focus entry points in a single view hierarchy.

> To learn more about new property wrappers, take a look at my [ “New property
> wrappers in SwiftUI” ](/2020/06/29/new-property-wrappers-in-swiftui/) post.

There is also the _resetFocus_ environment action, which we can use to reset a
focus to its preferred default position when needed.

####  Conclusion

I really like how Apple transforms imperative UIKit APIs into the declarative
world of SwiftUI. I am still not sure why Apple doesn’t make all of these new
APIs available for all platforms, but I believe we will see them on iOS also.
I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Microapps architecture in Swift. Feature modules.

##  Microapps architecture in Swift. Feature modules.

19 Jan 2022

In the first post of the current series, I talked about Swift Package Manager
basics and how we can maintain the project with many Swift modules. This week
we continue the topic of Microapps architecture by introducing feature
modules.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

[ Last week ](/2022/01/12/microapps-architecture-in-swift-spm-basics/) we
created a separate module for the design system of our app that contains
buttons and other shared UI components. We call them foundation modules
because we will import them into many different modules and use their
functionality. Another excellent example of the foundation module is the
networking layer. We can also extract it into a separate module and import it
whenever needed.

In the current post, I want to focus on the feature modules. Feature module
provides complete functionality for a dedicated app feature. We can also call
them product modules because they usually implement a particular part of the
final product. Let’s create the first feature module that onboards users on
the first app launch. As always, we should start with declaring our module in
the _Package.swift_ file.

    
    
    import PackageDescription
    
    let package = Package(
        name: "MyAppLibrary",
        platforms: [.iOS(.v15)],
        products: [
            .library(name: "DesignSystem", targets: ["DesignSystem"]),
            .library(name: "Onboarding", targets: ["Onboarding"])
        ],
        dependencies: [],
        targets: [
            .target(name: "DesignSystem"),
            .testTarget(
                name: "DesignSystemTests",
                dependencies: ["DesignSystem"]
            ),
            .target(
                name: "Onboarding",
                dependencies: ["DesignSystem"]
            )
        ]
    )
    

As you can see, we define the _Onboarding_ module as a separate target with
_DesignSystem_ as the dependency. It allows us to import the _DesignSystem_
module and reuse its functionality. The onboarding screen should present a few
items that we define below.

    
    
    public struct OnboardingItem: Hashable {
        let systemImage: String
        let title: String
        let body: String
    
        public init(
            systemImage: String,
            title: String,
            body: String
        ) {
            self.systemImage = systemImage
            self.title = title
            self.body = body
        }
    }
    

Please look at how we use the _public_ access modifier to make the dedicated
parts of code visible outside of the current module. Now we can move to
_OnboardingView_ itself.

    
    
    import DesignSystem
    
    public struct OnboardingView: View {
        let items: [OnboardingItem]
        let action: () -> Void
    
        public init(
            items: [OnboardingItem],
            action: @escaping () -> Void
        ) {
            self.items = items
            self.action = action
        }
    
        public var body: some View {
            VStack(alignment: .leading, spacing: 16) {
                Spacer()
                ForEach(items, id: \.self) { item in
                    HStack {
                        Image(systemName: item.systemImage)
                            .resizable()
                            .frame(width: 48, height: 48)
                        VStack(alignment: .leading) {
                            Text(item.title)
                                .font(.headline)
                            Text(item.body)
                                .foregroundColor(.secondary)
                        }
                    }
                }
    
                Button("Start using app", action: action)
                    .buttonStyle(.main)
                    .padding(.vertical)
                Spacer()
            }
        }
    }
    

First, we import the _DesignSystem_ module to use the main button style. Next,
we implement the _OnboardingView_ by iterating through onboarding items and
presenting them in the vertical stack. We also display a button on the bottom
of the screen with the style that we imported from the _DesignSystem_ module.

OK, now we have a separate module representing the onboarding feature.
Remember that we should implement all the app logic in the dedicated feature
modules. The app target should only provide a thin coordinator layer that
instantiates different features and navigates between them.

    
    
    import SwiftUI
    import Onboarding
    import DailySummary
    
    struct RootView: View {
        @AppStorage("isFirstLaunch")
        var isFirstLaunch: Bool = true
    
        var body: some View {
            NavigationView {
                DailySummaryView(date: .now)
            }
            .sheet(isPresented: $isFirstLaunch) {
                OnboardingView(
                    items: [
                        .init(
                            systemImage: "pills",
                            title: "Pills",
                            body: "Track your pills"
                        ),
                        .init(
                            systemImage: "heart",
                            title: "Monitor",
                            body: "Monitor your heart"
                        )
                    ]
                ) {
                    isFirstLaunch = false
                }
            }
        }
    }
    

As you can see in the example above, we have the _RootView_ in the app target
that imports both _Onboarding_ and _DailySummary_ modules. _RootView_ doesn’t
contain any logic. The only thing it does is coordinate between two feature
modules.

Dividing the app into many decoupled feature modules allows us to create
micro-apps for different user flows and deliver them to the QA team to get
early feedback without waiting for other features.

Feature modules can contain more than one screen and should encapsulate the
whole feature. For example, it can be a multi-screen checkout feature in the
store app. A dedicated team can work on this module and deliver a microapp
using TestFlight to test the checkout flow.

This week we learned about the feature modules and how they can improve the
development of the big app by delivering a microapp for the dedicated feature
set. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!

####  References

  1. [ Meet the microapps architecture ](https://increment.com/mobile/microapps-architecture/)
  2. [ Introduction to App Modularisation with Swift Package Manager ](https://holyswift.app/introduction-to-app-modularisation-with-swift-package-manager-a-tale-to-be-told)



# Microapps architecture in Swift. SPM basics.

##  Microapps architecture in Swift. SPM basics.

12 Jan 2022

This week I want to start a series of posts about the new approach I use to
build scalable apps in Swift. Microapps architecture allows you to reduce the
compile-time and enhances the separation of concerns in your codebase. Teams
can produce a module per feature and run it as a separate app to improve the
value delivery.

> To learn more about the benefits of Microapps architecture, take a lookt at
> [ “Meet the microapps architecture”
> ](https://increment.com/mobile/microapps-architecture/) .

Swift Package Manager became the heart of this approach. It allows us to
extract every feature into a separate Swift module and reduce the compile-time
of your project. In this case, Xcode compiles only changed modules and doesn’t
compile untouched modules.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

First of all, let’s create a Swift Package that contains all our app’s
modules. Swift packages are flexible enough and can include many modules that
may depend on each other.

![Swift-Package-Manager-Creation](/public/spm-lib.png)

We have an already created empty Xcode project called _MyApp_ . Go to the menu
and choose _File - > New -> Package _ to create a new Swift package. Let’s
call our Swift package _MyAppLibrary_ and put it in the root folder of the
project. You also need to add it to your app project at the bottom of the
dialog screen.

Now we have a Swift package that will contain all the modules we want to share
between multiple targets of our app. For example, watch app and widgets may
need different modules to build their functionality. So we shouldn’t bundle
the whole app codebase to create a simple widget.

![Swift-Package-Manager-Project](/public/spm-project.png)

Let’s remove the content of the _Sources_ and _Tests_ folders in our Swift
package. These two folders are crucial for any Swift package. We must place
all the source code and tests there. Swift package doesn’t use any project
file. It is smart enough to understand your folder structure.

We should define our modules in the _Package.swift_ file. This file contains
all the information about the targets living in the package and the products
we can import into other projects. Let’s take a detailed look at the package
definition.

    
    
    import PackageDescription
    
    let package = Package(
        name: "MyAppLibrary",
        platforms: [.iOS(.v15)],
        products: [
            .library(
                name: "DesignSystem",
                targets: ["DesignSystem"]
            )
        ],
        dependencies: [
            .package(
                url: "https://github.com/mecid/SwiftUICharts",
                from: "0.6.3"
            )
        ],
        targets: [
            .target(
                name: "DesignSystem",
                dependencies: ["SwiftUICharts"]
            ),
            .testTarget(
                name: "DesignSystemTests",
                dependencies: ["DesignSystem"]),
        ]
    )
    

  1. Name - the name of the package. 
  2. Platforms - platforms supported by the package. 
  3. Products - libraries and executables that another Swift project can import or run. 
  4. Dependencies - the list of dependencies needed to build the current package. 
  5. Targets - Swift modules that complier builds independently. 

Now we can create our first module that contains the Design System of our app.
This module includes button styles, empty views, and other design-related
things that we want to use across different features of our app. To create a
new module, we have to create a folder inside the Sources folder of our
package. Let’s call this folder _DesignSystem_ as we define it in
Package.swift file.

    
    
    import SwiftUI
    
    public struct MainButtonStyle: PrimitiveButtonStyle {
        public func makeBody(configuration: Configuration) -> some View {
            Button(configuration)
                .controlSize(.large)
                .buttonStyle(.borderedProminent)
        }
    }
    
    extension PrimitiveButtonStyle where Self == MainButtonStyle {
        public static var main: Self { .init() }
    }
    
    struct ButtonStyles_Previews: PreviewProvider {
        static var previews: some View {
            Button("Action") {}
                .buttonStyle(.main)
        }
    }
    

Here is the source code for the main button style that we will use across the
app. Take a look at the **public** access modifier. Swift uses the _internal_
access modifier by default making your code visible only inside the current
module. We should explicitly mark the types and functions with the _public_
access modifier to make them visible outside the current module. This way, we
can improve the boundaries of our modules and control which types should be
visible.

We also should create a _DesignSystemTests_ folder in the _Tests_ folder of
the Swift package to place our tests there. Xcode automatically updates the
scheme of our project, and you can run the tests by pressing **CMD+U** .

Now we can add _DesignSystem_ library in the Frameworks, Libraries, and
Embedded Content section of the MyApp project to import and use it. This week
we learned about the basics of Swift Package Manager that we would use as the
core tool while implementing Microapps architecture. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!

####  References

  1. [ Meet the microapps architecture ](https://increment.com/mobile/microapps-architecture/)
  2. [ Introduction to App Modularisation with Swift Package Manager ](https://holyswift.app/introduction-to-app-modularisation-with-swift-package-manager-a-tale-to-be-told)



# ViewThatFits in SwiftUI

##  ViewThatFits in SwiftUI

26 Jul 2022

How often did you use _GeometryReader_ to measure layout and place different
views? _GeometryReader_ was always a great tool in our toolbox, but It is
elementary to break the layout while using the _GeometryReader_ . Fortunately,
the next generation of the SwiftUI framework introduces a new way to measure
available space and place different views. This week we will learn how to use
the brand new _ViewThatFits_ view.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The introduced _ViewThatFits_ view is elementary to use. You don’t need to
manually measure available space or calculate if the particular view fits into
the available space. All you need to do is to create an instance of the
_ViewThatFits_ view and place in its _ViewBuilder_ closure up to 10 views.
_ViewThatFits_ automatically measures available space and the size of its
children and takes the first view that perfectly fits the available space.
That’s it.

    
    
    struct ContentView: View {
        var body: some View {
            ViewThatFits {
                HugeView()
                MediumView()
                SmallView()
            }
        }
    }
    

As you can see in the example above, it is straightforward to use the new
_ViewThatFits_ view. But you should be careful about the order of the passed
views. _ViewThatFits_ uses the first view that fits the available space. It
means that you should usually place your views from the biggest to the
smallest.

> To learn how to use the GeometryReader properly, look at my [ “How to use
> GeometryReader without breaking SwiftUI layout” ](/2020/11/04/how-to-use-
> geometryreader-without-breaking-swiftui-layout/) post.

By default, the _ViewThatFits_ view considers all the available space, but you
can set the particular axis you need to measure. For example, it might be a
horizontal or vertical axis.

    
    
    struct ContentView: View {
        var body: some View {
            ViewThatFits(in: .horizontal) {
                HugeView()
                MediumView()
                SmallView()
            }
        }
    }
    

In the current example, we completely ignore the vertical axis and consider
only horizontally available space. Let me describe the steps the
_ViewThatFits_ view applies while choosing a view.

  1. _ViewThatFits_ measures available space for a particular axis or both of them. 
  2. It measures the size of the first view and places it if it fits the available space. 
  3. It measures the size of the second view if the first one doesn’t fit the available space and place the second one if it fits. 
  4. It places the last view in the _ViewBuilder_ closure if no view fits the available space. 

Today we learned the new and easy way of measuring available space and placing
a view fitting that space. I hope you enjoy the post. Feel free to follow me
on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Pattern Matching with case let

##  Pattern Matching with case let

06 Feb 2019

Today we will talk about Pattern Matching, one of my favorite features in
Swift. Pattern Matching is the act of checking a given sequence of tokens for
the presence of the constituents of some pattern. Swift has a particular
keyword for applying Pattern Matching: **case let** . Let’s dive into
examples.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Enums

Pattern Matching is very useful while working with enums. As a part of [
“Maintaining State in Your ViewControllers” post ](/2019/01/23/maintaining-
state-in-view-controllers/) , we talk about State enum, which describes the
state of ViewController. Let’s see how we can efficiently use Pattern Matching
with it.

    
    
    enum State<Data> {
        case loading
        case loaded(Data)
        case failed(Error)
    }
    
    switch state {
    case .loading: renderLoading()
    case let .loaded(shows) where shows.isEmpty: renderEmptyView()
    case let .loaded(shows): render(shows)
    case let .failed(error): render(error)
    }
    

While regular switching on enum with associated values we can also use **case
let** keyword to match it to some pattern and assign associated value to a
variable. Another beautiful option here is filtering associated value by using
where keyword.

####  Optionals

Optional in Swift is the enum with two cases, so you can apply Pattern
Matching as we do it before with enums. But in the case of optionals, we have
some additional features. Let’s check the example code.

    
    
    let value: Int? = 10
    
    switch value {
    case let value? where value > 10: print("higher than ten")
    case let .some(value): print(value)
    case .none: print("none")
    }
    

value? here means the non-nil value of optional. So, it is the same as
.some(value).

####  Tuples

Another good use case for Pattern Matching can be tuples. Tuples often used as
lightweight types for grouping some data. Let’s see how we can use Pattern
Matching on a tuple which presents authentication data.

    
    
    let auth = (username: "majid", password: "veryStrongPassword")
    
    switch auth {
    case ("admin", "admin"): renderAdmin()
    case let (_, password) where password.count < 6: renderShortPasswordMessage()
    case let (username, password): renderUserProfile(username, password)
    }
    

As you can see, we can apply to tuples all the matching features which we used
with enums. We can also match the particular value to the tuple as we do for
matching admin data.

####  case let with flow statements

I want to mention that you can easily use **case let** keyword with any flow
control statement, let’s see how we can use it with if condition statements.

    
    
    if case let .loaded(shows) = state, shows.isEmpty {
        renderEmptyView()
    }
    

Same is possible with guard statement.

    
    
    guard case let .loaded(shows) = state, shows.isEmpty else {
        // Do something here
    }
    

Another compelling **case let** usage is possible with for-in loops, we can
easily filter items.

    
    
    let stateHistory: [State<[Show]>] = [.loaded([]), .loading]
    for case let .loaded(shows) in stateHistory where shows.count > 2 {
        // Do something here
    }
    

####  Conclusion

Today we discussed how powerful can be Pattern Matching in Swift, and how we
can use it in daily development. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# View composition in SwiftUI

##  View composition in SwiftUI

30 Oct 2019

SwiftUI is a declarative framework for building User Interfaces on Apple
platforms. The keyword here is **declarative** . Declarative means that you
need to declare what you want to achieve, and the framework takes care of it.
Framework knows the best way to render the User Interface, which you declare.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  View decomposition

Containers in SwiftUI has a nasty limitation for the count of children. It is
limited to **ten** items. This restriction can sound ugly, but I think it is
awesome. Let’s accept it as a rule. Whenever you reach this limitation,
decompose your view into several views. Don’t be afraid to extract your
complex views into small pieces and then compose them into a large view.

Sometimes to make that possible, we have to embed our views into additional
layout containers like stacks. But don’t worry about additional containers, it
won’t affect your rendering performance. SwiftUI is smart enough to understand
the final result and optimize your layout to ignore unnecessary layout
containers. Let’s take a look at the example of complex view decomposition.

    
    
    struct SleepDetailsView : View {
        private var chartSection: some View {
            // return some view here
        }
    
        private var sleepSection: some View {
            // return some view here
        }
    
        private var phasesSection: some View {
            // return some view here
        }
    
        private var heartRateSection: some View {
            // return some view here
        }
    
        var body: some View {
            List {
                chartSection
                sleepSection
                phasesSection
                heartRateSection
            }
        }
    }
    

In the example above, we extract our sections into the computed properties. It
makes our codebase more clean, easy to follow, and still very fast because
SwiftUI knows how to optimize your layout.

####  Groups

_Group_ is another way to get around the restriction of ten child views and
achieve view composition in SwiftUI. _Group_ doesn’t have any layout logic
like _VStack/HStack/ZStack_ , and It is completely transparent. When you put
_Group_ inside a _VStack_ , it behaves like _VStack_ and arranges children in
a vertical direction. In the case when _Group_ embedded into _HStack_ , it
renders views horizontally.

It looks like SwiftUI has a _Group_ component to get rid of that ten element
limitation only. But it is not. _Group_ component has unusual behavior. Any
view modifier added to the _Group_ component will apply to every child view
**separately** . Let’s take a look at the sample to understand how it works.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            VStack {
                Group {
                    Text("Hello")
                    Text("World")
                    Text("!!!")
                }
                .background(Color.yellow)
                .padding()
            }
        }
    }
    

In this example, we add padding and background color to a group of text
components. These modifiers won’t affect _Group_ component itself. Instead,
_Group_ applies them to every text **individually** . It means every text
inside _Group_ will have a yellow background and padding. In other words,
_Group_ maps every child view with modifiers, which was applied to the _Group_
.

####  ViewModifiers

_ViewModifiers_ is a third form of view composition in SwiftUI. All these
things which we use to modify our views like foreground color, padding, font,
etc. are _ViewModifiers_ . When you find yourself repeating the same code to
alter your views, just introduce a _ViewModifier_ for that and reuse it across
your codebase. Here is a small example of extracting few modifiers into a
single custom _ViewModifier_ .

    
    
    import SwiftUI
    
    struct SubheadlineModifier: ViewModifier {
        func body(content: Content) -> some View {
            content
                .foregroundColor(.secondary)
                .font(.subheadline)
        }
    }
    
    Text("subhead")
        .modifier(SubheadlineModifier())
    

All the subheads in my apps use the same styling. That’s why I decide to
extract it into a custom ViewModifier, which I can reuse across my codebase.
To learn more about _ViewModifiers_ , please check my [ “ViewModifiers in
SwiftUI” ](/2019/08/07/viewmodifiers-in-swiftui/) post.

####  Conclusion

Today we learned three ways of view composition in SwiftUI. Composition allows
us to build a highly reusable codebase that we can easily support and
maintain. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering ScrollView in SwiftUI. Transitions

##  Mastering ScrollView in SwiftUI. Transitions

13 Jun 2023

The fifth iteration of the SwiftUI framework brings a lot of new APIs related
to ScrollView, making it much more powerful than before. This week will begin
the series of posts about new abilities of the ScrollView in SwiftUI, and we
will start with scroll transitions.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The brand new _scrollTransition_ view modifier allows us to observe the
transition of the view while the user scrolls content. It will enable us to
understand whenever a view is in the viewport of the _ScrollView_ and allows
us to apply visual effects like scaling, rotating, etc. Let’s take a look at a
quick example.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ForEach(0..<10, id: \.self) { _ in
                    Rectangle()
                        .fill(Color.random)
                        .frame(width: 300, height: 300)
                        .scrollTransition { view, transition in
                            view.opacity(transition.isIdentity ? 1 : 0.3)
                        }
                }
            }
        }
    }
    

As you can see in the example above, we use the new _scrollTransition_ view
modifier to accept a closure with two parameters. The first is the view
without any effects, and the second is an instance of the
_ScrollTransitionPhase_ type.

![scroll-transition-video](/public/scroll-transition.mp4)

The _ScrollTransitionPhase_ type defines a state of a view transition in the
viewport of an instance of the _ScrollView_ . The _ScrollTransitionPhase_ type
is an enum with three cases: _topLeading_ , _bottomTrailing_ , and _identity_
. The _ScrollTransitionPhase_ enum provides the _isIdentity_ property allowing
us to check whenever the view finished its transition.

Usually, you display the view in the identity phase without any effects. The
SwiftUI framework animates all the changes you apply during the transition. In
our example, I use the _opacity_ view modifier to change the view’s alpha
during the transition.

The _ScrollTransitionPhase_ enum provides another property called _value_ . It
ranges from -1 to 1 and defines the numeric phase of transition where -1 means
_topLeading_ and 1 means _bottomTrailing_ . We can use it to scale our visual
effects while a view transition from _topLeading_ to _bottomTrailing_ .

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ForEach(0..<10, id: \.self) { _ in
                    Rectangle()
                        .fill(Color.random)
                        .frame(width: 300, height: 300)
                        .scrollTransition { view, transition in
                            view.scaleEffect(transition.isIdentity ? 1 : transition.value)
                        }
                }
            }
        }
    }
    

As you can see in the example above, we use the _value_ property on the
_ScrollTransitionPhase_ type to scale our view while transitioning from one
phase to another.

The _scrollTransition_ view modifier allows us to tune the animation we want
to use while interpolating the transition.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ForEach(0..<10, id: \.self) { _ in
                    Rectangle()
                        .fill(Color.random)
                        .frame(width: 300, height: 300)
                        .scrollTransition(.animated(.bouncy)) { view, transition in
                            view.scaleEffect(transition.isIdentity ? 1 : transition.value)
                        }
                }
            }
        }
    }
    

Here we use the bouncy animation to interpolate between transition phases. You
can use a few options to configure the transition: _interactive_ , _animated_
with the particular animation you provide, and _identity_ to disable
animation.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ForEach(0..<10, id: \.self) { _ in
                    Rectangle()
                        .fill(Color.random)
                        .frame(width: 300, height: 300)
                        .scrollTransition(
                            topLeading: .identity,
                            bottomTrailing: .interactive
                        ) { view, transition in
                            view.rotationEffect(.radians(transition.value))
                        }
                }
            }
        }
    }
    

We also can use different configurations for _topLeading_ and _bottomTrailing_
transitions. I use the _identity_ configuration to disable transition effects
in this direction.

Today we learned how to use the new _scrollTransition_ view modifier to
animate viewport transitions in the _ScrollView_ . I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Mastering SwiftUI previews

##  Mastering SwiftUI previews

10 Mar 2021

This week, I want to talk about one of the most powerful Xcode features,
SwiftUI previews. SwiftUI previews allow you to look at your SwiftUI views
inside Xcode without running the app in the simulator. You can also preview
UIKit views and controllers by wrapping them in SwiftUI. Today we will learn
about all the powerful features of previews in Xcode.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Xcode monitors your Swift files, and as soon as your Swift file contains the
struct that conforms to _PreviewProvider_ protocol, it shows you the preview
canvas. Let’s take a look at the example.

    
    
    struct ContentView: View {
        var body: some View {
            Text("Hello World!")
        }
    }
    
    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
        }
    }
    

![preview-debug](/public/preview1.png)

We declare the _ContentView_Previews_ struct that conforms to
_PreviewProvider_ protocol. The only requirement of _PreviewProvider_ protocol
is the static _previews_ calculated property. In this property, you should
return the view that you want to preview. You can preview more than one view
by placing them in previews property.

    
    
    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
                .preferredColorScheme(.dark)
            ContentView()
                .preferredColorScheme(.light)
        }
    }
    

![preview-debug](/public/preview3.png)

####  Environment

Preview is a simple SwiftUI view. You can apply different modifiers in
previews to check how your view looks with various user settings. One of the
essential things is Dynamic Type support. You can easily verify your view with
different font size options.

    
    
    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
                .environment(\.sizeCategory, .extraLarge)
        }
    }
    

As you can see in the example above, we can apply the _environment_ modifier
in our previews to check the view’s look and feel with different font sizes.
I’m doing this very often in my projects. That’s why I create a special view
which automates this process.

> To learn more about providing custom values via SwiftUI’s Environment, take
> a look at my [ “The power of Environment in SwiftUI” ](/2019/08/21/the-
> power-of-environment-in-swiftui/) post.
    
    
    struct SizeCategoryPreview<Content: View>: View {
        let content: Content
    
        var body: some View {
            ForEach(ContentSizeCategory.allCases, id: \.self) { size in
                content.environment(\.sizeCategory, size)
            }
        }
    }
    

Here we declare the _SizeCategoryPreview_ struct, a SwiftUI view accepting
another view and putting it in a loop by applying different content size
conditions. It allows you to validate the look and feel of your view in all
possible size categories.

    
    
    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            SizeCategoryPreview(content: ContentView())
        }
    }
    

![preview-debug](/public/preview2.png)

####  UIKit previews

Xcode previews are not limited to SwiftUI views. You can quickly wrap any
UIKit view or controller with a struct conforming to _UIViewRepresentable_ or
_UIViewControllerRepresentable_ and preview it.

> To learn more about using UIKit view and controllers in SwiftUI, look at my
> [ “Using UIKit views in SwiftUI” ](/2020/01/29/using-uikit-views-in-
> swiftui/) post.
    
    
    struct UIKitPreview: UIViewRepresentable {
        typealias UIViewType = UIView
    
        let view: UIViewType
    
        func makeUIView(context: Context) -> UIViewType {
            view
        }
    
        func updateUIView(_ uiView: UIViewType, context: Context) {
    
        }
    }
    

Here we create a generic struct that allows us to preview any UIKit view in
Xcode previews. We need to create a UIKit view, wrap it with _UIKitPreview_
struct and return it in previews property. By doing that, you can preview any
UIKit view in Xcode previews.

    
    
    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            UIKitPreview(view: MKMapView())
        }
    }
    

####  Preview files

I want to mention that you are not limited for creating a preview only inside
a Swift file containing a SwiftUI view. You can create Swift files that
contain only previews. It might be handy when you provide a complete design
system or a UI library. For example, I maintain a SwiftUI charting library,
and I have a Swift file that contains the previews of all available chart
views in my library.

> Don’t be afraid to extract your complex views into small pieces and then
> compose them into a large view. To learn more about view decomposition, look
> at my [ “View composition in SwiftUI” ](/2019/10/30/view-composition-in-
> swiftui/) post.

####  Debug previews

SwiftUI previews use the simulator to render themselves. So you can think
about them as an embedded simulator in the Xcode window. That’s why we can run
and debug SwiftUI preview directly in the Xcode canvas.

You can attach the debugger to the app running in the preview by using Debug
menu -> Attach to Process and choose your app. Now you can press Debug View
Hierarchy button in the toolbar on the bottom of Xcode to run visual debugger.

![preview-debug](/public/debug-preview.jpeg)

####  Shortcuts

There are two shortcuts that you should remember. Both of them will make your
life easier during the development cycle of your SwiftUI views.

  1. _Cmd + Option + Enter_ shows or hides previews. 
  2. _Cmd + Option + P_ runs the previews. 

####  Conclusion

Xcode preview is one of my favorite features of Xcode that changed my
development habits enormously. Keep your views small by using decomposition to
make your previews fast and stable. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this article. Thanks for reading, and see you next week!



# Hover effect in SwiftUI

##  Hover effect in SwiftUI

25 Mar 2020

Apple introduced the hover effect a few years ago to improve the interaction
of the trackpads on iPadOS. Later, it became available on tvOS, producing the
same effect while the user navigated through the app using Apple TV Remote.
Nowadays, we can use the hover effect in response to eye focus on visionOS.
This week, we will learn all about hover effect interaction in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  hoverEffect view modifier

SwiftUI provides us the _hoverEffect_ modifier that we can attach to any view.
This modifier enables the transformation of eye focus or mouse pointer into
the covering view shape. It is tough to explain this transformation and better
to see. Let’s run the example on an iPad or Vision Pro simulator.

    
    
    import SwiftUI
    
    struct RootView: View {    
        var body: some View {
            Text("Hello World!")
                .hoverEffect()
        }
    }
    

Fortunately, iPad simulator supports trackpad simulation. You have to enable
it by using _I/O - > Input -> Send cursor to Device _ menu. Now we can see the
pointer on the screen. Let’s cover the text view with the pointer.

SwiftUI provides us the _HoverEffect_ struct that describes three types of
transformation of the pointer into a view shape. By default, _hoverEffect_
modifier uses the first one, which is called _automatic_ . Besides that, we
have _highlight_ and _lift_ transformations. You can use them by only passing
it as a parameter of the _hoverEffect_ modifier.

    
    
    struct RootView: View {    
        var body: some View {
            VStack {
                Text("Hello")
                    .hoverEffect(.lift)
                Text("World")
                    .hoverEffect(.highlight)
            }
        }
    }
    

Highlight transformation describes an effect that morphs the pointer into a
platter behind the view and shows a light source indicating position. On the
other hand, lift transformation defines an effect that slides the pointer
under the view and disappears as the view scales up and gains a shadow.
Usually, we need the _automatic_ transformation that attempts to determine the
effect automatically.

    
    
    struct ContentView: View {
        @State private var isEnabled = false
        
        var body: some View {
            VStack {
                Toggle(isOn: $isEnabled) {
                    Text(isEnabled ? "Disable" : "Enable")
                }
                
                Text("Hello World!")
                    .hoverEffect(.lift, isEnabled: isEnabled)
            }
        }
    }
    

As you can see in the example above, the _hoverEffect_ view modifier also
allows us to control whenever to turn the effect on or off by using the
_isEnabled_ parameter.

The only downside of the _hoverEffect_ view modifier is that you must apply it
to every view you want to enable the hover effect. You can easily forget to
add it to a particular view. Fortunately, SwiftUI provides the
_defaultHoverEffect_ view modifier, allowing us to enable selected hover
effects on every view in the hierarchy with a single line of code.

    
    
    struct ContentView: View {
        var body: some View {
            VStack {
                Text("Hello")
                Text("World")
            }
            .defaultHoverEffect(.lift)
        }
    }
    

Whenever you use the _defaultHoverEffect_ on the whole hierarchy, you can use
the _hoverEffectDisabled_ view modifier to turn off the hover effect on the
particular view.

    
    
    struct ContentView: View {
        var body: some View {
            VStack {
                Text("Hello")
                Text("World")
                    .hoverEffectDisabled(true)
            }
            .defaultHoverEffect(.lift)
        }
    }
    

####  onHover view modifier

Now we are familiar with the standard types of hover effect that SwiftUI
provides us. But what about custom effects? Happily, SwiftUI enables us to
create super custom hover effects by using _onHover_ modifier. This modifier
allows us to register a closure that will be called whenever the pointer
intersects the view. _onHover_ modifier enables all the power of animations in
SwiftUI that we can use to highlight interaction.

    
    
    struct CustomView: View {
        @State private var hovered = false
        
        var body: some View {
            Text("Hello World!")
                .scaleEffect(hovered ? 2.0 : 1.0)
                .animation(.default, value: hovered)
                .onHover { isHovered in
                    self.hovered = isHovered
                }
        }
    }
    

As you can see in the example above, we use _onHover_ modifier to register a
closure that delivers us a _Boolean_ value. This _Boolean_ value is _true_
whenever the pointer covers the view. We save the value into a state variable
and scale our view using default animation.

> To learn more about the power of animation modifier in SwiftUI, take a look
> at my [ “Animations in SwiftUI” ](/2019/06/26/animations-in-swiftui/) post.

When you build the custom view, you can use the _isHoverEffectEnabled_
environment value to understand whether to apply a custom hover effect.

    
    
    struct CustomView: View {
        @Environment(\.isHoverEffectEnabled) var isEnabled
        @State private var hovered = false
        
        var body: some View {
            Text("Hello World!")
                .scaleEffect(hovered && isEnabled ? 2.0 : 1.0)
                .animation(.default, value: hovered)
                .onHover { isHovered in
                    self.hovered = isHovered
                }
        }
    }
    

####  onContinuousHover view modifier

SwiftUI also provides the _onContinuousHover_ view modifier, allowing us to
track the hover phases. For example, you can read the hover’s location and
react whenever it changes.

    
    
    struct CustomView: View {
        @State private var scale = 1.0
        
        var body: some View {
            Text("Hello World!")
                .scaleEffect(scale)
                .animation(.default, value: scale)
                .onContinuousHover { phase in
                    switch phase {
                    case .active(let location):
                        scale = location.y / location.x
                    case .ended:
                        scale = 1
                    }
                }
        }
    }
    

####  Conclusion

I am pleased to see that hover effect expands from iPadOS and tvOS to
visionOS. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading, and see you next
week!



# Bottom sheet API in SwiftUI

##  Bottom sheet API in SwiftUI

19 Jul 2022

Two years ago, I wrote a post about building a custom bottom sheet in SwiftUI.
Nowadays, there is no need to make it manually, at least if you don’t need a
super custom behavior. SwiftUI introduces a new API to display a bottom sheet
in a few lines of code. This week we learn the new API allowing us to present
bottom sheets in different appearances.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The new bottom sheet API in SwiftUI is straightforward to use. All you need to
do is to attach the _presentationDetents_ view modifier to the content of the
_sheet_ view modifier.

    
    
    struct ContentView: View {
        @State private var sheetShown = false
        @State private var query = ""
    
        var body: some View {
            Button("Display bottom sheet") {
                sheetShown = true
            }
            .sheet(isPresented: $sheetShown) {
                NavigationStack {
                    Text("You query: \(query)")
                        .searchable(text: $query)
                        .navigationTitle("Search")
                }
                .presentationDetents([.medium])
            }
        }
    }
    

> To learn how to create a bottom sheet in SwiftUI from scratch, take a look
> at my [ “Building Bottom sheet in SwiftUI” ](/2019/12/11/building-bottom-
> sheet-in-swiftui/) post.

As you can see in the example above, we use the _presentationDetents_ view
modifier to display a sheet as the bottom sheet. We also set the size of the
bottom sheet to _medium_ . In this case, it will take half of the screen. You
can use the _presentationDetents_ view modifier to pass an array of available
sizes, allowing the user to resize the sheet by dragging it.

    
    
    struct ContentView: View {
        @State private var sheetShown = false
        @State private var query = ""
    
        var body: some View {
            Button("Display bottom sheet") {
                sheetShown = true
            }
            .sheet(isPresented: $sheetShown) {
                NavigationStack {
                    Text("You query: \(query)")
                        .searchable(text: $query)
                        .navigationTitle("Search")
                }
                .presentationDetents([.medium, .large])
            }
        }
    }
    

![bottom-sheet](/public/new-bottom-sheet.png)

The new bottom sheet API is very flexible and allows you to tune the height of
the sheet as you need by using the following options.

    
    
    struct ContentView: View {
        @State private var sheetShown = false
        @State private var query = ""
    
        var body: some View {
            Button("Display bottom sheet") {
                sheetShown = true
            }
            .sheet(isPresented: $sheetShown) {
                NavigationStack {
                    Text("You query: \(query)")
                        .searchable(text: $query)
                        .navigationTitle("Search")
                }
                .presentationDetents(
                    [
                        .fraction(0.2),
                        .height(300),
                        .fraction(0.5),
                        .height(600)
                    ]
                )
            }
        }
    }
    

As you can see in the example above, we use the _fraction_ function to set the
height of the sheet to a particular fraction of the available space. You can
also use the _height_ function to set the height to a fixed size. Remember
that you can mix different options to achieve the appearance you need.

Depending on the current environment, we might need to build a super custom
sizing logic. For example, I would like to display a bottom sheet by taking
80% of the available space on the iPad and full height on the iPhone. We can
implement this custom presentation logic and reuse it across multiple screens.

    
    
    struct MyCustomDetent: CustomPresentationDetent {
        static func height(in context: Context) -> CGFloat? {
            if context.verticalSizeClass == .regular {
                return context.maxDetentValue * 0.8
            } else {
                return context.maxDetentValue
            }
        }
    }
    

First, we should create a type conforming to the _CustomPresentationDetent_
protocol. Second, we should implement the only required function called
_height_ which takes the _context_ as the parameter. Parameter _context_ holds
all the SwiftUI’s environment values, and you can use it to decide what height
you need in a particular environment. I use vertical size classes in the
example above to decide on the sheet’s height.

    
    
    struct ContentView: View {
        @State private var sheetShown = false
        @State private var query = ""
    
        var body: some View {
            Button("Display bottom sheet") {
                sheetShown = true
            }
            .sheet(isPresented: $sheetShown) {
                NavigationStack {
                    Text("You query: \(query)")
                        .searchable(text: $query)
                        .navigationTitle("Search")
                }
                .presentationDetents([.medium, .custom(MyCustomDetent.self)])
            }
        }
    }
    

You can change the size of the bottom sheet not only by dragging but also in a
programmatic way. In this case, you have to pass the _Binding_ to the selected
size among the available sizes.

    
    
    struct ContentView: View {
        @State private var sheetShown = false
        @State private var sheetSize: PresentationDetent = .medium
    
        var body: some View {
            VStack {
                Picker("Size", selection: $sheetSize) {
                    Text("Medium").tag(PresentationDetent.medium)
                    Text("Large").tag(PresentationDetent.large)
                }
                
                Button("Display bottom sheet") {
                    sheetShown = true
                }
                .sheet(isPresented: $sheetShown) {
                    NavigationStack {
                        Text("Sheet content")
                    }
                    .presentationDetents([.medium, .large], selection: $sheetSize)
                }
            }
        }
    }
    

The last thing we can customize is the drag indicator of the bottom sheet. We
can make it always visible, hidden, or allow SwiftUI to decide whether it
should be visible.

    
    
    struct ContentView: View {
        @State private var sheetShown = false
        @State private var query = ""
    
        var body: some View {
            Button("Display bottom sheet") {
                sheetShown = true
            }
            .sheet(isPresented: $sheetShown) {
                NavigationStack {
                    Text("You query: \(query)")
                        .searchable(text: $query)
                        .navigationTitle("Search")
                }
                .presentationDetents([.medium, .large])
                .presentationDragIndicator(.automatic)
            }
        }
    }
    

Today we learned how to use the new bottom sheet API in SwiftUI. I love the
level of customization it provides. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Mastering charts in SwiftUI. Pie and Donut charts.

##  Mastering charts in SwiftUI. Pie and Donut charts.

26 Sep 2023

One of the additions to the Swift Charts framework after WWDC 23 was a brand
new _SectorMark_ type. The _SectorMark_ allows us to build pie and donut
charts in SwiftUI easily. This week, we will learn how to plot the data using
_SectorMark_ .

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The Swift Charts framework provides us with mark types like _BarMark_ ,
_LineMark_ , etc. Mark types allow us to define a piece of data on the chart
declaratively. _SectorMark_ is another mark type we can use to plot a pie or
donut chart.

    
    
    import SwiftUI
    import Charts
    
    struct Product: Identifiable {
        let id = UUID()
        let title: String
        let revenue: Double
    }
    
    struct SectorChartExample: View {
        @State private var products: [Product] = [
            .init(title: "Annual", revenue: 0.7),
            .init(title: "Monthly", revenue: 0.2),
            .init(title: "Lifetime", revenue: 0.1)
        ]
        
        var body: some View {
            Chart(products) { product in
                SectorMark(
                    angle: .value(
                        Text(verbatim: product.title),
                        product.revenue
                    )
                )
                .foregroundStyle(
                    by: .value(
                        Text(verbatim: product.title),
                        product.title
                    )
                )
            }
        }
    }
    

![pie-chart](/public/pie.png)

As you can see in the example above, we use the _SectorMark_ type to plot a
pie chart. We use the _foregroundStyle_ modifier to fill sections with
different colors as we do with other mark types.

> To learn more about mark styling, take a look at my dedicated [ “Mastering
> charts in SwiftUI. Mark styling.” ](/2023/01/18/mastering-charts-in-swiftui-
> mark-styling/) post.

Whenever we create an instance of the _SectorMark_ type, we must pass the
_angle_ parameter. It might be a plottable value defining an angle portion of
the section, or we can pass a range with exact start and end values of the
angle for a particular area.

The second parameter of the _SectorMark_ initializer is the _innerRadius_
value. We can use it to transform our pie chart into a donut chart.

    
    
    struct SectorChartExample: View {
        @State private var products: [Product] = [
            .init(title: "Annual", revenue: 0.7),
            .init(title: "Monthly", revenue: 0.2),
            .init(title: "Lifetime", revenue: 0.1)
        ]
        
        var body: some View {
            Chart(products) { product in
                SectorMark(
                    angle: .value(
                        Text(verbatim: product.title),
                        product.revenue
                    ),
                    innerRadius: .ratio(0.6)
                )
                .foregroundStyle(
                    by: .value(
                        Text(verbatim: product.title),
                        product.title
                    )
                )
            }
        }
    }
    

![donut-chart](/public/donut.png)

As you can see in the example above, we use the _innerRadius_ parameter to
plot a donut chart. The _innerRadius_ parameter accepts _ratio_ , _inset_ ,
and _fixed_ sizes. We can use the _angularInset_ parameter to set the spacing
between sectors of the pie or donut charts.

    
    
    struct SectorChartExample: View {
        @State private var products: [Product] = [
            .init(title: "Annual", revenue: 0.7),
            .init(title: "Monthly", revenue: 0.2),
            .init(title: "Lifetime", revenue: 0.1)
        ]
        
        var body: some View {
            Chart(products) { product in
                SectorMark(
                    angle: .value(
                        Text(verbatim: product.title),
                        product.revenue
                    ),
                    innerRadius: .ratio(0.6),
                    angularInset: 8
                )
                .foregroundStyle(
                    by: .value(
                        Text(verbatim: product.title),
                        product.title
                    )
                )
            }
        }
    }
    

![donut-chart-with-spacing](/public/donut1.png)

As you can see, the _SectorMark_ type is a simple chart mark that supports all
the modifiers we use for other mark types to customize them. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading, and see you next
week!



# Displaying live activities in iOS 16

##  Displaying live activities in iOS 16

21 Sep 2022

One of the most prominent features of iOS 16 is live activity widgets. iOS 16
allows us to display the live state of ongoing activities from our apps on the
lock screen or in the Dynamic Island of the new iPhone 14 Pro. This week we
will learn how to build live activity widgets for our apps using the new
ActivityKit framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

First, we should be aware of the limitations of live activities in iOS 16. It
will allow us to understand use cases where the live activity widget makes
sense. Live activity has eight hours before the system ends it. I hope Apple
will increase the lifetime of live activities by at least 24 hours. In this
case, we can display things like long flights, etc.

Live activity widgets use the WidgetKit framework to display information on
the lock screen or in the Dynamic Island of the iPhone 14 Pro. We can share
the code between home screen widgets and live activity widgets. The only
difference is the lifecycle. Live activity widgets don’t have a timeline
provider and should be managed from the app target using the ActivityKit
framework.

####  Data flow

Every live activity has two parts of data: static and dynamic. Static is not
going to change and is available whenever an activity starts. The dynamic part
is going to change during the live activity. In the case of a football match,
teams are static data because it is not going to change during the game. The
score is a dynamic part of the data and can change during the activity. The
dynamic portion of the data should not exceed 4kb. Let’s model our football
match using the new ActivityKit framework.

    
    
    import ActivityKit
    
    struct FootballMatch: ActivityAttributes {
        typealias ContentState = Score
    
        struct Score: Codable, Hashable {
            let score1: Int
            let score2: Int
        }
        
        let team1: String
        let team2: String
    }
    

The ActivityKit framework requires us to create a type conforming to the
_ActivityAttributes_ protocol. The type conforming to the _ActivityAttributes_
should provide static information about the activity and define the
_ContentState_ type containing the dynamic part of the data.

Your app must be in the foreground to start a live activity, and don’t forget
to add the **Supports Live Activities** key with **YES** value to the app
target’s _Info.plist_ . Now you can start a live activity using the following
code:

    
    
    let activity = try Activity.request(
        attributes: FootballMatch(
            team1: "AJAX",
            team2: "PSV"
        ),
        contentState: .init(
            score1: 0,
            score2: 0
        )
    )
    

As you can see in the example above, we request a live activity by providing
the initial attributes. Now we can hold the result of the live activity
request in the variable and update or end it whenever needed.

    
    
    // Update live activity
    Task {
        await activity.update(using: .init(score1: 1, score2: 0))
    }
    
    // End live activity
    Task {
        await activity.end(
            using: .init(score1: 1, score2: 0),
            dismissalPolicy: .immediate
        )
    }
    
    

You can use the BackgroundTasks framework or push notifications to update or
end your live activity without running the app in the foreground.

> To learn more about the BackgroundTasks framework, take a look at my [
> “Background tasks in SwiftUI” ](/2022/07/06/background-tasks-in-swiftui/)
> post.

####  Live activity presentation

We have to use the WidgetKit framework to display a live activity. WidgetKit
provides us with the particular _ActivityConfiguration_ type allowing us to
define a live activity widget.

    
    
    @available(iOSApplicationExtension 16.1, *)
    struct FastingActivityWidget: Widget {
        var body: some WidgetConfiguration {
            ActivityConfiguration(for: FastingAttributes.self) { context in
                LiveActivityView(context: context)
                    .padding(.horizontal)
            } dynamicIsland: { context in
                DynamicIsland {
                    DynamicIslandExpandedRegion(.center) {
                        LiveActivityView(context: context)
                    }
                } compactLeading: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                } compactTrailing: {
                    Text(verbatim: context.state.progress.formatted(.percent)
                        .foregroundColor(context.state.stage?.color)
                } minimal: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                }
            }
        }
    }
    

You should define the widget type using _ActivityConfiguration_ and add it to
your widget bundle. _ActivityConfiguration_ requires us to provide a view that
represents the activity on the lock screen and the Dynamic Island
configuration to display activity on the iPhone 14 Pro.

    
    
    @main struct FastBotWidgetBundle: WidgetBundle {
        var body: some Widget {
            FastBotWidget()
            
            if #available(iOS 16.1, *) {
                FastingActivityWidget()
            }
        }
    }
    

> Look at my dedicated [ “Building widgets in SwiftUI” ](/2020/09/09/building-
> widgets-in-swiftui/) post to learn more about the WidgetKit framework.

####  Conclusion

Today we learned how to build a live activity widget for iOS 16. In the next
post, I will try to cover the Dynamic Island configuration type allowing us to
layout our content in a few ways. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this article. Thanks for reading, and see you next week!



# Thread safety in Swift with actors

##  Thread safety in Swift with actors

19 Sep 2023

Actors is the new Swift language feature, making your types thread-safe. This
week, we will learn how to use actors and their benefits over locks. We will
also discuss actor reentrancy, the main confusing point of using actors.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In the previous post, we modeled a _Store_ type, allowing us to implement
state management predictably.

    
    
    @dynamicMemberLookup final class Store<State, Action> {
        typealias Reduce = (State, Action) -> State
        
        private var state: State
        private let reduce: Reduce
        
        init(state: State, reduce: @escaping Reduce) {
            self.state = state
            self.reduce = reduce
        }
        
        subscript<T>(dynamicMember keyPath: KeyPath<State, T>) -> T {
            state[keyPath: keyPath]
        }
        
        func send(_ action: Action) {
            state = reduce(state, action)
        }
    }
    

At this point, the _Store_ type is not thread-safe, and using it from multiple
threads may lead to data races and race conditions. We solve the issue by
using an instance of the _NSRecursiveLock_ type.

    
    
    @dynamicMemberLookup final class Store<State, Action> {
        typealias Reduce = (State, Action) -> State
        
        private var state: State
        private let reduce: Reduce
        
        private let lock = NSRecursiveLock()
        
        init(state: State, reduce: @escaping Reduce) {
            self.state = state
            self.reduce = reduce
        }
        
        subscript<T>(dynamicMember keyPath: KeyPath<State, T>) -> T {
            lock.withLock {
                state[keyPath: keyPath]
            }
        }
        
        func send(_ action: Action) {
            lock.withLock {
                state = reduce(state, action)
            }
        }
    }
    

As you can see in the example above, we use an instance of the
_NSRecursiveLock_ type whenever we access the protected part of the store. We
made our store thread-safe, but let me tell you about a few downsides of using
locks.

First, you must wrap every use of the state property with the _withLock_
function. Whenever you miss it accidentally or not, the _Store_ type is not
thread-safe anymore. So, you should be very careful while using locks.

Second, when you call the _lock_ or _withLock_ functions, they completely hang
the current thread until the lock is released, which may lead to performance
issues when many threads access the protected value.

> To learn more about locks in Swift, take a look at my [ “Thread safety in
> Swift with locks” ](/2023/09/05/thread-safety-in-swift-with-locks/) post.

Swift language introduced a feature called actors to solve these complex
issues. Actors like classes are reference types but protect their stored
properties from multithread access.

    
    
    @dynamicMemberLookup actor Store<State, Action> {
        typealias Reduce = (State, Action) -> State
        
        private var state: State
        private let reduce: Reduce
        
        init(state: State, reduce: @escaping Reduce) {
            self.state = state
            self.reduce = reduce
        }
        
        subscript<T>(dynamicMember keyPath: KeyPath<State, T>) -> T {
            state[keyPath: keyPath]
        }
        
        func send(_ action: Action) {
            state = reduce(state, action)
        }
    }
    

As you can see in the example above, we define our Store type by using
**actor** keyword instead of _class_ . That’s all you need to make your
_Store_ thread-safe. Actor isolation guarantees exclusive access to the stored
fields of an actor type. You must use the **await** keyword to access property
or function on an actor type.

    
    
    final class StoreTests: XCTestCase {
        struct State {
            var value = 0
        }
        
        func testThreadSafety() async {
            let store = Store<State, Void>(state: .init()) { state, _ in
                var state = state
                state.value += 1
                return state
            }
            
            await withTaskGroup(of: Void.self) { group in
                for _ in 0..<1_000_000 {
                    group.addTask {
                        await store.send(())
                    }
                }
            }
            
            let value = await store.value
            
            XCTAssertEqual(value, 1_000_000)
        }
    }
    

The _await_ keyword is part of the Swift Concurrency feature, allowing us to
await the results whenever we switch threads. In the example above, we use
_await_ on every touch to the actor because another thread might use the
actor, and we must wait for our exclusive access. Swift Compiler guarantees
exclusive access, and we have compile-time verification on thread safety.

    
    
    @dynamicMemberLookup actor Store<State, Action> {
        typealias Reduce = (State, Action) -> State
        typealias Intercept = (State, Action) async -> Action?
        
        private var state: State
        private let reduce: Reduce
        private let intercept: Intercept
        
        init(
            state: State,
            reduce: @escaping Reduce,
            intercept: @escaping Intercept
        ) {
            self.state = state
            self.reduce = reduce
            self.intercept = intercept
        }
        
        subscript<T>(dynamicMember keyPath: KeyPath<State, T>) -> T {
            state[keyPath: keyPath]
        }
        
        func send(_ action: Action) async {
            state = reduce(state, action)
            
            if let nextAction = await intercept(state, action) {
                await send(nextAction)
            }
        }
    }
    

Now let’s talk about actor reentrancy. What if we run async code on an actor?
In this case, the actor suspends execution and switches threads to run an
async function outside the actor. During this time, the actor allows other
threads access its isolated properties and functions because it doesn’t run
the async code itself. When the async code finishes, the actor switches back
to run actor-isolated code.

Remember that every use of the _await_ keyword inside an actor type is a
possible suspension point where other threads may access or mutate actor-
isolated properties. This situation is called actor reentrancy. You may have
race conditions during actor reentrancy if you assume that actors always run
code atomically.

Today we learned about another great feature of Swift language. In general, I
suggest to use actors by default and switch to locks only when you need thread
safety outside of async context. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and happy multithreading!



# Starting Unit Testing with Model layer

##  Starting Unit Testing with Model layer

24 Apr 2019

Today we are going to touch the completely new topic on my blog, and it is
Unit Testing. Most of us heard about the pros of Unit Testing. I want to show
how easily you can start with Unit Testing by covering your model layer. So
let’s start with the definition.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Unit testing is a software testing method by which individual units of source
code, sets of one or more computer program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use.

#####  In other words, Unit Test is a code which tests individual unit of your
codebase.

I think the model layer is the best place to start writing Unit Tests. Assume
that you are working on the Github client for iOS where you have a bunch of
model structs which represents data fetched from Github API. Let’s take a look
at structs which define repository search results.

    
    
    import Foundation
    
    struct SearchResponse: Codable {
        let totalCount: Int
        let incompleteResults: Bool
        let items: [Repository]
    }
    
    struct Repository: Codable {
        let id: Int
        let name: String
        let owner: User
        let description: String
        let fork: Bool
        let url: String
        let homepage: String
        let stargazersCount: Int
        let watchersCount: Int
        let forksCount: Int
        let openIssuesCount: Int
    }
    
    struct User: Codable {
        let login: String
        let id: Int
        let avatarUrl: String
        let gravatarId: String
        let url String
    }
    

Here we can see three structs: _SearchResponse_ , _Repository_ , and _User_ .
Every field of these structs represents an associated value from JSON which
fetched during the search endpoint request. Next step is fetching and
deserializing downloaded data into these structs.

    
    
    class SearchLoader {
        typealias Handler = (Result<SearchResponse, Error>) -> Void
    
        private let session: URLSession
        private let decoder: JSONDecoder
    
        init(session: URLSession = .shared, decoder: JSONDecoder = .init()) {
            self.session = session
            self.decoder = decoder
        }
    
        func search(with query: String, handler: @escaping Handler) {
            session.dataTask(with: makeRequest(for: query)) { [weak self] data, _, error in
                guard let self = self else {
                    return
                }
    
                do {
                    let response = try self.decoder.decode(SearchResponse.self, from: data ?? Data())
                    handler(.success(response))
                } catch {
                    handler(.failure(error))
                }
            }
        }
    }
    

In the code sample above we have _SearchLoader_ class which make an API
request to Github’s search endpoint and convert the data to _SearchResponse_
struct. First of all, I want to cover with tests these data manipulations.
Let’s start with creating a Unit Test target in Xcode project( _File - > New
-> Target -> iOS Unit Testing bundle _ ). Xcode should create it by default if
you do not disable it during the project forming process.

Now we have to add JSON file with search endpoint response as a content to a
testing target. We will use it to mock network request and speed up our test
by faking real network request.

    
    
    {
      "total_count": 40,
      "incomplete_results": false,
      "items": [
        {
          "id": 3081286,
          "node_id": "MDEwOlJlcG9zaXRvcnkzMDgxMjg2",
          "name": "Tetris",
          "full_name": "dtrupenn/Tetris",
          "owner": {
            "login": "dtrupenn",
            "id": 872147,
            "node_id": "MDQ6VXNlcjg3MjE0Nw==",
            "avatar_url": "https://secure.gravatar.com/avatar/e7956084e75f239de85d3a31bc172ace?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dtrupenn",
            "received_events_url": "https://api.github.com/users/dtrupenn/received_events",
            "type": "User"
          },
          "private": false,
          "html_url": "https://github.com/dtrupenn/Tetris",
          "description": "A C implementation of Tetris using Pennsim through LC4",
          "fork": false,
          "url": "https://api.github.com/repos/dtrupenn/Tetris",
          "created_at": "2012-01-01T00:31:50Z",
          "updated_at": "2013-01-05T17:58:47Z",
          "pushed_at": "2012-01-01T00:37:02Z",
          "homepage": "",
          "size": 524,
          "stargazers_count": 1,
          "watchers_count": 1,
          "language": "Assembly",
          "forks_count": 0,
          "open_issues_count": 0,
          "master_branch": "master",
          "default_branch": "master",
          "score": 10.309712
        }
      ]
    }
    

Finally, it is time to write our first Unit Test for the project. Let’s create
new file from Unit Test template ( _File - > New -> File -> Unit Test Case
Class _ ). Xcode can identify test methods by the name. It should start with
text prefix. Here is a sample Unit Test on _SearchResponse_ .

    
    
    import XCTest
    @testable import Github
    
    class GithubTests: XCTestCase {
        func testSearchResponse() throws {
            guard
                let path = Bundle(for: self).path(forResource: "search", ofType: "json")
                else { fatalError("Can't find search.json file") }
    
            let data = try Data(contentsOf: URL(fileURLWithPath: path))
            let response = try JSONDecoder().decode(SearchResponse.self, from: data)
    
            XCTAssertEqual(response.totalCount, 40)
            XCTAssertTrue(response.incompleteResults)
            XCTAssertEqual(response.items.count, 1)
    
            let repo = response.items.first
    
            XCTAssertEqual(repo.id, 3081286)
            XCTAssertEqual(repo.forksCount, 0)
            XCTAssertEqual(repo.name, "Tetris")
            XCTAssertFalse(repo.fork)
    
            let owner = response.item.first.owner
    
            XCTAssertEqual(owner.login, "dtrupenn")
            XCTAssertEqual(owner.id, 872147)
            XCTAssertEqual(owner.gravatarId, "")
        }
    }
    

The important thing here is _@testable import_ , which makes possible to
access to internal fields of _SearchResponse_ inside the testing target. By
importing XCTest, we get the _XCTestCase_ , which is base class for all of our
tests. XCTest framework also includes a bunch of helper methods to assert
values. I didn’t assert every field to keep it as short as possible, but in
real project it is nice to have all fields covered. Now we can run our tests
by pressing CMD + U and check the result.

####  Conclusion

Today we discussed how to start with Unit Testing in any project which has a
model layer. I think it is the most comfortable place to start. Don’t hesitate
and start today, you will see a lot of benefits like safe refactoring, keeping
codebase stable during adding new features which can break something that you
have working before, and much more.

Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading and see you next week!



# Composable styling in SwiftUI

##  Composable styling in SwiftUI

28 Aug 2019

This week I want to talk about the styling of views in SwiftUI. SwiftUI
provides a pretty composable architecture for building your apps. Every screen
in terms of SwiftUI is a function on some data which returns a view. So let’s
talk today about composable and highly reusable styling options which we have
in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Branding

Whenever I begin a project, I start with defining my brand color for my User
Interface. I use brand color as a tint for my buttons, switches, slider, etc.
We can easily set the tint color on every view in the app by using
_accentColor_ modifier on the root view. Here is a quick example.

    
    
    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
            window = UIWindow(windowScene: scene as! UIWindowScene)
            window?.rootViewController = UIHostingController(
                rootView: RootView()
                    .accentColor(.purple)
            )
    
            window?.makeKeyAndVisible()
        }
    

SwiftUI uses _Environment_ feature to pass the values implicitly inside any
child view. This is how we can give an accent color to every view across the
app. To learn more about _Environment_ feature of SwiftUI, check my dedicated
post [ “The power of Environment in SwiftUI” ](/2019/08/21/the-power-of-
environment-in-swiftui/) .

Another must-have option which I want to enable on every view in my app is
line limit. I want to make every text in my app multi-lined in the case when
it is too long. I also need it when a user enables extra large font size for
Dynamic Type. It is also straightforward to achieve by adding _lineLimit_
modifier to my root view.

    
    
        func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
            window = UIWindow(windowScene: scene as! UIWindowScene)
            window?.rootViewController = UIHostingController(
                rootView: RootView()
                    .accentColor(.purple)
                    .lineLimit(nil)
            )
    
            window?.makeKeyAndVisible()
        }
    

####  Button styles

I often have a few button types which I reuse across the app. Before SwiftUI,
I was using inheritance to apply my styling to _UIButtons_ in _UIKit_ . But
SwiftUI relies on composition instead of inheritance, that’s why it provides
us _ButtonStyle_ protocol which we can implement to reuse our button styles
across the app.

    
    
    import SwiftUI
    
    struct OutlineStyle: ButtonStyle {
        func makeBody(configuration: Configuration) -> some View {
            configuration.label
                .frame(minWidth: 44, minHeight: 44)
                .padding(.horizontal)
                .foregroundColor(Color.accentColor)
                .background(RoundedRectangle(cornerRadius: 8).stroke(Color.accentColor))
        }
    }
    
    struct FillStyle: ButtonStyle {
        func makeBody(configuration: Configuration) -> some View {
            configuration.label
                .frame(minWidth: 44, minHeight: 44)
                .padding(.horizontal)
                .foregroundColor(configuration.isPressed ? .gray : .white)
                .background(Color.accentColor)
                .cornerRadius(8)
        }
    }
    

As you can see in the example above, we implement two button styles:
_OutlinedButton_ and _FilledButton_ . To apply them to a button in SwiftUI, we
have to use button style modifier. Let’s see how we can use them.

    
    
    HStack {
        store.monthly.map { product in
            Button("\(product.localizedPrice) / \(product.localizedPeriod)") {
                self.store.buyProduct(product)
                self.presentation.wrappedValue.dismiss()
            }.buttonStyle(OutlineStyle())
        }
    
        store.annually.map { product in
            Button("\(product.localizedPrice) / \(product.localizedPeriod)") {
                self.store.buyProduct(product)
                self.presentation.wrappedValue.dismiss()
            }.buttonStyle(FillStyle())
        }
    }.padding()
    

**I want to note that you can use _buttonStyle_ modifier on any view in
SwiftUI and it utilizes _Environment_ feature to share the style with any
button inside it. **

####  Text styles

Similar to buttons, I have a few different styling options for my text
representation. Unfortunately, SwiftUI doesn’t provide something like
_TextStyle_ protocol. But instead, it gives us a much more powerful
composition concept, and it is _ViewModifier_ . Let’s take a look at how we
can use _ViewModifiers_ to style our Text views.

    
    
    struct TitleStyle: ViewModifier {
        func body(content: Content) -> some View {
            content
                .font(.title)
                .lineSpacing(8)
                .foregroundColor(.primary)
        }
    }
    
    struct ContentStyle: ViewModifier {
        func body(content: Content) -> some View {
            content
                .font(.body)
                .lineSpacing(4)
                .foregroundColor(.secondary)
        }
    }
    
    extension Text {
        func textStyle<Style: ViewModifier>(_ style: Style) -> some View {
            ModifiedContent(content: self, modifier: style)
        }
    }
    

In the example above, we implement two style modifiers. We also provide an
extension for _Text_ component, which allows us easily apply any modifier to a
_Text_ . Now we can use our styles by adding _textStyle_ modifier to any
_Text_ component.

    
    
    VStack {
        Text("title")
            .textStyle(TitleStyle())
        Text("content")
            .textStyle(ContentStyle())
    }
    

_ViewModifiers_ allow us to encapsulate and reuse any logic across the _Views_
. To learn more about _ViewModifiers_ , take a look at my dedicated post [
“ViewModifiers in SwiftUI” ](/2019/08/07/viewmodifiers-in-swiftui/) .

####  Conclusion

Today we learned how to create highly reusable styling components for SwiftUI
by using features like _ViewModifiers_ and _Environment_ . I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading and see you next
week!



# Functional core Imperative shell in Swift

##  Functional core Imperative shell in Swift

01 Mar 2022

We love value types because they provide us with safety and predictability,
allowing us to reason about the code we write. But we still need objects to
hold and mutate our app’s shared state. This week, we will discuss modeling
our app’s logic by leveraging the value and reference semantics.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Value types are great, and one of the reasons for that is instance isolation.
Whenever you pass a value type as a parameter or assign it to another
variable, you get a new copy with the very same data. You always have a
warranty that there are no side effects across the app while mutating the
local copy of the value type.

    
    
    struct Fasting {
        var goal: Goal
    
        private(set) var start: Date?
        private(set) var end: Date?
    
        init(goal: Goal) {
            self.goal = goal
        }
    
        var progress: Double {
            guard let start = start else {
                return 0.0
            }
    
            return (end ?? .now).timeIntervalSince(start) / goal.duration
        }
    
        mutating func reset() {
            start = nil
            end = nil
        }
    
        mutating func begin() {
            start = .now
        }
    
        mutating func finish() {
            end = .now
        }
    
        struct Goal {
            let duration: TimeInterval
    
            static let trf16 = Goal(duration: 16 * 3600)
            static let trf18 = Goal(duration: 18 * 3600)
            static let trf20 = Goal(duration: 20 * 3600)
            static let omad = Goal(duration: 23 * 3600)
        }
    }
    

Even mutating functions in your value types create a new copy and reassign it
to the current variable. That’s why you can call mutating functions only on
instances defined with the **var** keyword. It means you can easily replace
one sample of value type with another, and it will work the same way. This
feature of value types shines when you write unit tests. Pure functions like
these are easy to test because you only need to verify the function’s output.
There are no side effects.

Isolated value types work great for defining your app’s state and pure actions
around that piece of data. But we still need to share mutable state between
different app screens and make side effects like networking and I/O
operations. Reference types are great for data sharing. Whenever you assign an
instance of a class to a new variable, it shares the reference to the same
object.

We can use objects to store and share the state represented by a value type.
Objects are not pure and have identity. That’s why it is an excellent place
for side effects. The idea is to encapsulate all the app logic using value
types with pure functions and only use objects to store value types and
provide side effects.

    
    
    @MainActor final class TimerStore: ObservableObject {
        struct Dependencies {
            let save: (Fasting) async throws -> Void
            let load: () async throws -> Fasting?
        }
    
        @Published var currentFasting = Fasting(goal: .trf16)
    
        private let dependencies: Dependencies
        init(dependencies: Dependencies) {
            self.dependencies = dependencies
        }
    
        func load() async {
            currentFasting = (try? await dependencies.load()) ?? currentFasting
        }
    
        func save() async {
            try? await dependencies.save(currentFasting)
        }
    }
    

> To learn more about using async closures as dependencies, take a look at my
> [ “Microapps architecture in Swift. Dependency Injection”
> ](/2022/02/02/microapps-architecture-in-swift-dependency-injection/) post.

As you can see in the example above, we have an object holding the state
represented by a value type and providing very few functions to make side
effects possible. We encapsulated all the logic in the value type that we can
easily verify in unit tests. And we can still quickly write integration tests
for the object by mocking only side effects to check its behavior.

    
    
    import SwiftUI
    
    struct TimerView: View {
        @ObservedObject var store: TimerStore
    
        var body: some View {
            VStack {
                if let start = store.currentFasting.start {
                    Text(start, style: .timer)
                    Button("Finish") {
                        store.currentFasting.finish()
                    }
                    Button("Save") {
                        Task { await store.save() }
                    }
                } else {
                    Button("Begin") {
                        store.currentFasting.begin()
                    }
                }
            }
            .task { await store.load() }
        }
    }
    

The idea of functional core and imperative shell fits very well into the world
of mobile development with Swift language, which provides so many language
features allowing us to write expressible and safe code in a very few
keystrokes.

In the next week, we will talk about this approach in the context of
unidirectional flow. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!

####  References

  1. [ “Boundaries”, a talk by Gary Bernhardt from SCNA 2012 ](https://www.destroyallsoftware.com/talks/boundaries)
  2. [ Functional Core Reactive Shell ](https://mokacoding.com/blog/functional-core-reactive-shell/)
  3. [ Writing idiomatic Swift code ](/2021/04/01/writing-idiomatic-swift-code/)



# Modeling app state using Store objects in SwiftUI

##  Modeling app state using Store objects in SwiftUI

04 Sep 2019

This week I want to talk to you about modeling data layer in SwiftUI. I
already finished work on my very first app, which I build entirely with
SwiftUI. And now I can share with you the way of architecting model layer
using store objects which I used during the development of _NapBot_ .

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Store object

Store objects responsible for storing the state and providing actions to
mutate that state. You can have as many store objects as you need to keep them
simple and responsible for a small part of your app state. For example, you
may have _SettingsStore_ to keep a state of user-defined settings and
_TodoStore_ to keep user tasks.

To create a store object, we need a class which conforms to _ObservableObject_
. _ObservableObject_ allows SwiftUI to observe and react to data changes.
Let’s take a look at a simple example of _SettingsStore_ object.

> To learn more about _ObservableObject_ , take a look at [ “Managing Data
> Flow in SwiftUI” ](/2019/07/03/managing-data-flow-in-swiftui/) post.
    
    
    import Foundation
    import Combine
    
    final class SettingsStore: ObservableObject {
        let objectWillChange = PassthroughSubject<Void, Never>()
    
        @UserDefault(Constants.UserDefaults.sleepGoal, defaultValue: 8.0)
        var sleepGoal: Double
    
        @UserDefault(Constants.UserDefaults.notifications, defaultValue: true)
        var isNotificationsEnabled: Bool
    
        private var didChangeCancellable: AnyCancellable?
    
        override init() {
            super.init()
            didChangeCancellable = NotificationCenter.default
                .publisher(for: UserDefaults.didChangeNotification)
                .map { _ in () }
                .receive(on: DispatchQueue.main)
                .subscribe(objectWillChange)
        }
    }
    

In the code sample above, we have _SettingsStore_ class which provides access
to the user-defined settings. We also use _didChangeNotification_ to notify
SwiftUI whenever user defaults changes.

####  Advanced usage

Let’s take a look at another usage of the store object by creating a simple
Todo app. We need to create a store object which stores the list of tasks and
provides actions to mutate them like deleting and filtering.

    
    
    import Foundation
    import Combine
    
    struct Todo: Identifiable, Hashable {
        let id = UUID()
        var title: String
        var date: Date
        var isDone: Bool
        var priority: Int
    }
    
    final class TodosStore: ObservableObject {
        @Published var todos: [Todo] = []
    
        func orderByDate() {
            todos.sort { $0.date < $1.date }
        }
    
        func orderByPriority() {
            todos.sort { $0.priority > $1.priority }
        }
    
        func removeCompleted() {
            todos.removeAll { $0.isDone }
        }
    }
    

Here we have a _TodosStore_ class which conforms to _ObservableObject_
protocol. _TodosStore_ provides few actions to mutate its state, we can use
these methods from our views. By default, SwiftUI updates the views whenever @
_Published_ field changes. That’s why we marked our array of _Todo_ items as @
_Published_ . As soon as we insert or remove items from that array, SwiftUI
will update views subscribed to the _TodosStore_ .

Now, we can create a view which represents the list of tasks and provides
actions like marking a task as completed, deleting, and reordering. Let’s
start by creating a view which shows the title of the task and a toggle to
mark the task as completed.

    
    
    import SwiftUI
    
    struct TodoItemView: View {
        let todo: Binding<Todo>
    
        var body: some View {
            HStack {
                Toggle(isOn: todo.isDone) {
                    Text(todo.title.wrappedValue)
                        .strikethrough(todo.isDone.wrappedValue)
                }
            }
        }
    }
    

In the example above, we use _Binding_ to provide a reference like access to a
value type. In other words, we provide writable access to a todo item.
_TodoItemView_ doesn’t own an instance of _Todo_ struct, but it has writable
access to the _TodoStore_ via _Binding_ .

    
    
    import SwiftUI
    
    struct TodosView: View {
        @EnvironmentObject var store: TodosStore
        @State private var draft: String = ""
    
        var body: some View {
            NavigationView {
                List {
                    TextField("Type something...", text: $draft, onCommit: addTodo)
                    ForEach(store.todos.indexed(), id: \.1.id) { index, _ in
                        TodoItemView(todo: self.$store.todos[index])
                    }
                    .onDelete(perform: delete)
                    .onMove(perform: move)
                }
                .navigationBarItems(trailing: EditButton())
                .navigationBarTitle("Todos")
            }
        }
    
        private func delete(_ indexes: IndexSet) {
            store.todos.remove(atOffsets: indexes)
        }
    
        private func move(_ indexes: IndexSet, to offset: Int) {
            store.todos.move(fromOffsets: indexes, toOffset: offset)
        }
    
        private func addTodo() {
            let newTodo = Todo(title: draft, date: Date(), isDone: false, priority: 0)
            store.todos.insert(newTodo, at: 0)
            draft = ""
        }
    }
    

Here we have a _TodosView_ which uses _List_ component to represent todos.
_List_ component also provides reorder and delete actions. Another interesting
thing here is _indexed_ () function. This function returns a collection of
items with its indexes. We use it to access store items via Binding. Here is a
full source of this extension.

    
    
    import Foundation
    
    struct IndexedCollection<Base: RandomAccessCollection>: RandomAccessCollection {
        typealias Index = Base.Index
        typealias Element = (index: Index, element: Base.Element)
    
        let base: Base
    
        var startIndex: Index { base.startIndex }
    
        var endIndex: Index { base.endIndex }
    
        func index(after i: Index) -> Index {
            base.index(after: i)
        }
    
        func index(before i: Index) -> Index {
            base.index(before: i)
        }
    
        func index(_ i: Index, offsetBy distance: Int) -> Index {
            base.index(i, offsetBy: distance)
        }
    
        subscript(position: Index) -> Element {
            (index: position, element: base[position])
        }
    }
    
    extension RandomAccessCollection {
        func indexed() -> IndexedCollection<Self> {
            IndexedCollection(base: self)
        }
    }
    

The environment is a perfect candidate to keep store objects. Environment can
share it between multiple views without explicit injection via init method.

> To learn more about the benefits of _Environment_ in SwiftUI, take a look at
> [ “The power of Environment in SwiftUI” ](/2019/08/21/the-power-of-
> environment-in-swiftui/) post.

![todos-screenshots](/public/todo.jpeg)

####  Conclusion

Today we talked about the way of modeling app state by using multiple store
objects. I really enjoy the simplicity of this approach and how easily you can
scale your app by injecting more store objects into the environment. I hope
you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# Using UIKit views in SwiftUI

##  Using UIKit views in SwiftUI

29 Jan 2020

A few weeks ago, we talked about building views like [ _PagerView_
](/2019/12/25/building-pager-view-in-swiftui/) and [ _BottomSheetView_
](/2019/12/11/building-bottom-sheet-in-swiftui/) from scratch in SwiftUI.
SwiftUI is pretty young and misses some components that we expect to have out
of the box. But it provides all the needed APIs to build whatever we want.
However, sometimes we need to reuse _UIKit_ views instead of making the
SwiftUI versions. This week I want to talk to you about using _UIKit_ views in
SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  UIViewRepresentable

One of the good examples of _UIKit_ views that we don’t want to recreate in
SwiftUI is _MKMapView_ . Do you have any ideas on how to implement it in
SwiftUI from scratch? Happily, we don’t need to do that. We can easily use
_MKMapView_ in SwiftUI by simply creating a wrapper view.

SwiftUI provides us _UIViewRepresentable_ protocol that allows us to wrap
_UIKit_ views and use them from SwiftUI views. Let’s take a look at how we can
cover _MKMapView_ to use it in SwiftUI.

    
    
    struct MapView: UIViewRepresentable {
        typealias UIViewType = MKMapView
    
        func makeUIView(context: UIViewRepresentableContext<MapView>) -> MKMapView {
            MKMapView()
        }
    
        func updateUIView(_ uiView: MKMapView, context: UIViewRepresentableContext<MapView>) {
        }
    }
    

As you can see in the example above, we create a _MapView_ struct that
conforms to the _UIViewRepresentable_ protocol. _UIViewRepresentable_ protocol
has two requirements: _makeUIView_ and _updateUIView_ methods.

SwiftUI calls _makeUIView_ only one time when it creates a view hierarchy.
Whenever you change the state of the view, SwiftUI calls _updateUIView_ method
to update the view according to state changes.

Let’s ignore state changes for now and just create an empty _MKMapView_ .
Finally, we can use our _MapView_ in SwiftUI.

    
    
    struct RootView: View {
        var body: some View {
            MapView()
                .edgesIgnoringSafeArea(.all)
        }
    }
    

####  State and Binding

_UIViewRepresentable_ view can store a state or has a binding like any other
SwiftUI components. Let’s refactor our _MapView_ to accept a binding for a
center coordinate via init method.

    
    
    struct MapView: UIViewRepresentable {
        typealias UIViewType = MKMapView
    
        @Binding var center: CLLocationCoordinate2D
    
        func makeUIView(context: UIViewRepresentableContext<MapView>) -> MKMapView {
            MKMapView()
        }
    
        func updateUIView(_ uiView: MKMapView, context: UIViewRepresentableContext<MapView>) {
            uiView.setCenter(center, animated: true)
        }
    }
    

As you can see in the example above, we finally implemented _updateUIView_ .
We want to center our map view whenever the binding of the center location
changed.

####  Coordinator

_UIKit_ views usually have delegates that allow us to handle some user
interactions like cell selection in _UITableView_ or visible region changes in
_MKMapView_ . What if we want to handle these actions in SwiftUI? Fortunately,
_UIViewRepresentable_ provides a **Coordinator** object that allows us to deal
with delegates, data sources, and other _UIKit_ stuff. The coordinator is a
bridge between your _UIKit_ and SwiftUI views. Let’s see how we can use it.

    
    
    struct MapView: UIViewRepresentable {
        typealias UIViewType = MKMapView
    
        @Binding var center: CLLocationCoordinate2D
    
        func makeUIView(context: UIViewRepresentableContext<MapView>) -> MKMapView {
            let mapView = MKMapView()
            mapView.delegate = context.coordinator
            return mapView
        }
    
        func updateUIView(_ uiView: MKMapView, context: UIViewRepresentableContext<MapView>) {
            uiView.setCenter(center, animated: true)
        }
    
        func makeCoordinator() -> MapView.Coordinator {
            Coordinator(self)
        }
    
        final class Coordinator: NSObject, MKMapViewDelegate {
            private let mapView: MapView
    
            init(_ mapView: MapView) {
                self.mapView = mapView
            }
    
            func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {
                self.mapView.center = mapView.centerCoordinate
            }
        }
    }
    

_UIViewRepresentable_ has an optional requirement to implement
_makeCoordinator_ method. This method should create and return a coordinator
object. We can fulfill all the needed delegate methods using this object. As
you can see in the example above, we want to update our binding whenever the
user moves the map. We might need to add some pins based on location changes.

####  Conclusion

This week we learned how to use _UIKit_ views in SwiftUI. SwiftUI is a great
framework, but sometimes we need to reuse _UIKit_ classes that we had for
years in _iOS SDK_ . Fortunately, it is very effortless to do with help of
_UIViewRepresentable_ protocol. I hope you enjoy the post. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Mastering Dynamic Island in SwiftUI

##  Mastering Dynamic Island in SwiftUI

28 Sep 2022

In the previous post, we talked about live activity widgets displaying your
app’s ongoing events. Live activity widgets can utilize the dynamic island of
the iPhone 14 Pro. In this post, we will discuss possible configurations and
customization points of the dynamic island feature using the new API available
in the WidgetKit framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The WidgetKit framework provides us with a particular type of configuration
called _ActivityConfiguration_ , allowing us to define a live activity widget.

    
    
    @available(iOSApplicationExtension 16.1, *)
    struct FastingActivityWidget: Widget {
        var body: some WidgetConfiguration {
            ActivityConfiguration(for: FastingAttributes.self) { context in
                LiveActivityView(context: context)
                    .padding(.horizontal)
            } dynamicIsland: { context in
                DynamicIsland {
                    DynamicIslandExpandedRegion(.leading) {
                        LiveActivityView(context: context)
                    }
                } compactLeading: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                } compactTrailing: {
                    Text(verbatim: context.state.progress.formatted(.percent.precision(.fractionLength(0))))
                        .foregroundColor(context.state.stage?.color)
                } minimal: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                }
            }
        }
    }
    

We use the _ActivityConfiguration_ type to define a SwiftUI view to display on
the lock screen. In this case, we will use our custom _LiveActivityView_ . We
also provide a dynamic island layout configuration to display on iPhone 14
Pro.

> To learn about the basics of live activity widgets, take a look at my
> dedicated [ “Displaying live activities in iOS 16” ](/2022/09/21/displaying-
> live-activities-in-ios16/) post.

WidgetKit has a particular _DynamicIsland_ type allowing us to specify how we
want to use the dynamic island layout. The _DynamicIsland_ type is not a
SwiftUI view but requires us to provide views for compact leading and compact
trailing, expanded, and minimal cases.

Whenever your app is the only app running live activity widget at the moment,
the system displays both compact leading and compact trailing views
accordingly.

![dynamic-island-compact](/public/dynamic-island-compact.png)

The system uses minimal view whenever there is more than one live activity
widget at the moment and displays it as detached trailing view.

![dynamic-island-minimal](/public/dynamic-island-minimal.png)

The expanded view is used when the user uses a long press gesture to expand
the dynamic island.

![dynamic-island-expanded](/public/dynamic-island-expanded.png)

The expanded dynamic island divides its space into four areas and allows us to
control where we want to place the content. We also can use the _priority_
parameter to enable the system to prioritize the views while sizing them.

    
    
    @available(iOSApplicationExtension 16.1, *)
    struct FastingActivityWidget: Widget {
        var body: some WidgetConfiguration {
            ActivityConfiguration(for: FastingAttributes.self) { context in
                LiveActivityView(context: context)
            } dynamicIsland: { context in
                DynamicIsland {
                    DynamicIslandExpandedRegion(.leading, priority: 1) {
                        LiveActivityView(context: context)
                    }
                    
                    DynamicIslandExpandedRegion(.trailing) {
                        LiveActivityView(context: context)
                    }
                    
                    DynamicIslandExpandedRegion(.center) {
                        LiveActivityView(context: context)
                    }
                    
                    DynamicIslandExpandedRegion(.bottom) {
                        LiveActivityView(context: context)
                    }
                } compactLeading: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                } compactTrailing: {
                    Text(verbatim: context.state.progress.formatted(.percent.precision(.fractionLength(0))))
                        .foregroundColor(context.state.stage?.color)
                } minimal: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                }
            }
        }
    }
    

Sometimes we might have too wide content in the leading view that doesn’t fit
into the available space. In this case, we can use the _dynamicIsland_ view
modifier to move the leading view below the True Depth camera.

![dynamic-island-expanded-wide](/public/dynamic-island-expanded-wide.png)

    
    
    @available(iOSApplicationExtension 16.1, *)
    struct FastingActivityWidget: Widget {
        var body: some WidgetConfiguration {
            ActivityConfiguration(for: FastingAttributes.self) { context in
                LiveActivityView(context: context)
            } dynamicIsland: { context in
                DynamicIsland {
                    DynamicIslandExpandedRegion(.leading, priority: 1) {
                        LiveActivityView(context: context)
                            .dynamicIsland(verticalPlacement: .belowIfTooWide)
                    }
                } compactLeading: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                } compactTrailing: {
                    Text(verbatim: context.state.progress.formatted(.percent.precision(.fractionLength(0))))
                        .foregroundColor(context.state.stage?.color)
                } minimal: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                }
            }
        }
    }
    

Another customization point is the background color of compact and minimal
views. By default, the system uses black color to fill the compact and minimal
views, but we can use the _keylineTint_ view modifier to change the color.

    
    
    @available(iOSApplicationExtension 16.1, *)
    struct FastingActivityWidget: Widget {
        var body: some WidgetConfiguration {
            ActivityConfiguration(for: FastingAttributes.self) { context in
                LiveActivityView(context: context)
            } dynamicIsland: { context in
                DynamicIsland {
                    DynamicIslandExpandedRegion(.leading, priority: 1) {
                        LiveActivityView(context: context)
                            .dynamicIsland(verticalPlacement: .belowIfTooWide)
                    }
                } compactLeading: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                } compactTrailing: {
                    Text(verbatim: context.state.progress.formatted(.percent.precision(.fractionLength(0))))
                        .foregroundColor(context.state.stage?.color)
                } minimal: {
                    Image(systemName: "circle")
                        .foregroundColor(.green)
                }
                .keylineTint(.white)
            }
        }
    }
    

Today we learned how to use the dynamic island feature to display live
activities from your app on iPhone 14 Pro. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this article. Thanks for reading, and see you next week!



# Dependency Injection in Swift with Protocols

##  Dependency Injection in Swift with Protocols

06 Mar 2019

There are a lot of third-party libraries which provide Dependency Injection
for Swift apps. In my opinion, Swift has a powerful type system which gives us
the ability to make type-safe Dependency Injection easily. Today we will talk
about using Dependency Injection in Swift with the power of protocols.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Protocol Composition

As I said before protocols are one of my favorite language features in Swift,
especially protocol composition, which gives us an opportunity to compose
multiple protocols together in one type. Let’s take a look at the
implementation of the Service Locator pattern in Swift and how we can improve
it with the usage of protocol composition.

    
    
    protocol HasUserDefaults {
        var userDefaults: UserDefaults { get }
    }
    
    protocol HasUrlSession {
        var session: URLSession { get }
    }
    
    protocol HasHealthStore {
        var store: HKHealthStore { get }
    }
    
    struct Dependencies: HasUserDefaults, HasUrlSession, HasHealthStore {
        let userDefaults: UserDefaults
        let session: URLSession
        let store: HKHealthStore
    
        init(
            userDefaults: UserDefaults = .standard,
            session: URLSession = .shared,
            store: HKHealthStore = .init()
        ) {
            self.userDefaults = userDefaults
            self.session = session
            self.store = store
        }
    }
    

Here we have a bunch of protocols which describe our dependencies.
_Dependencies_ struct contains all of our service classes in the app.
Generally, we can create and store an instance of _Dependencies_ struct in
_AppDelegate_ or root coordinator. Now let’s take a look at the usage of our
dependency container.

    
    
    class ViewController: UIViewController {
        typealias Dependencies = HasUserDefaults & HasUrlSession
    
        private let userDefaults: UserDefaults
        private let session: URLSession
    
        init(dependencies: Dependencies) {
            userDefaults = dependencies.userDefaults
            session = dependencies.session
            super.init(nibName: nil, bundle: nil)
        }
    }
    

Here we have _ViewController_ which describes its dependencies via a typealias
and protocol composition. In the _init_ method, we easily extract our
dependencies into field variables. All we need is the passing instance of our
_Dependencies_ struct to _ViewController_ , and _ViewController_ will be able
to access dependencies only defined in typealias.

Next time when your _ViewController_ will need another dependency all you need
to do is add it to typealias and extract it into the variable. You don’t need
to change the creation of _ViewController_ , because you already pass all the
dependencies.

    
    
    extension Dependencies {
        static var mocked: Dependencies {
            return Dependencies(
                userDefaults: UserDefaults(suiteName: #file),
                session: MockedUrlSession(),
                store: MockedHealthStore()
            )
        }
    }
    

The example above shows how we can create the mocked version of dependencies
to use it for Unit-Testing.

####  Abstract Factory

Another option for Dependency Injection is the Abstract Factory pattern. I
love to use it to extract the creation of complex objects like
_ViewControllers_ and its dependencies. Let’s take a look at the Swift version
of the Abstract Factory pattern by using protocols and extensions.

    
    
    protocol DependencyFactory {
        func makeHealthService() -> HealthService
        func makeSettingsSevice() -> SettingsService
    }
    
    struct Dependencies {
        private let healthStore: HKHealthStore
        private let userDefaults: UserDefaults
    
        init(
            healthStore: HKHealthStore = .init(),
            userDefaults: UserDefaults = .standard
        ) {
            self.healthStore = healthStore
            self.userDefaults = userDefaults
        }
    }
    
    extension Dependencies: DependencyFactory {
        func makeHealthService() -> HealthService {
            return HealthService(store: healthStore)
        }
    
        func makeSettingsSevice() -> SettingsService {
            return Settings(defaults: userDefaults)
        }
    }
    

Here we have _DependencyFactory_ protocol which describes factory methods for
every dependency in our app. We also have small _Dependencies_ struct which
stores low-level dependencies. By using the extension, we add
_DependencyFactory_ protocol conformance to _Dependencies_ struct. Now let’s
take a look at _ViewControllerFactory_ , which describes _ViewController_
creation process.

    
    
    protocol ViewControllerFactory {
        func makeCalendarViewController() -> CalendarViewController
        func makeDayViewController() -> DayViewController
        func makeSettingsViewController() -> SettingsViewController
    }
    
    extension Dependencies: ViewControllerFactory {
        func makeCalendarViewController() -> CalendarViewController {
            return CalendarViewController(
                healthService: makeHealthService()
            )
        }
    
        func makeDayViewController() -> DayViewController {
            return DayViewController(
                healthService: makeHealthService(),
                settingsService: makeSettingsSevice()
            )
        }
    
        func makeSettingsViewController() -> SettingsViewController {
            return SettingsViewController(
                settingsService: makeSettingsSevice()
            )
        }
    }
    

We use _ViewControllerFactory_ to create every _ViewController_ in our app,
for more complex apps we can have more than one _ViewController_ factory based
on the user flow. Here we also use an extension to add protocol conformance to
_Dependencies_ struct. It is time to see how we can use these factories while
using Coordinators or Flow Controllers.

    
    
    protocol FlowControllerDelegate {
        func startSettings()
    }
    
    class FlowController: UIViewController {
        private let factory: ViewControllerFactory
        
        init(factory: ViewControllerFactory) {
            self.factory = factory
        }
    
        override func viewDidLoad() {
            super.viewDidLoad()
            add(factory.makeCalendarViewController())
        }
    }
    
    extension FlowController: FlowControllerDelegate {
        func startSettings() {
            show(factory.makeSettingsViewController(), sender: self)
        }
    }
    

We can create an instance of _Dependencies_ struct in _AppDelegate_ and pass
it to the main _Flow Controller_ of the app. By extracting creation of
_ViewControllers_ into factories, we keep our _Flow Controllers_ small and
responsible only for controlling user-flow.

> To learn more about Flow Controllers and Coordinator pattern, take a look at
> my dedicate [ “Navigation with Flow Controllers” ](/2019/02/20/navigation-
> with-flow-controllers/) post.

####  Conclusion

Today we discussed two Dependency Injection techniques. Both of them use Swift
language features without any third-party dependencies. Just take a look at
them and choose which will work better for you. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading and see you next week!



# Commands in SwiftUI

##  Commands in SwiftUI

24 Nov 2020

This week we will talk about another new API that Apple released this year
during WWDC 20. Replacing _AppDelegate_ with the new SwiftUI App Lifecycle
brings us tons of new APIs that we can use to replace old functionality with a
brand new declarative API. One of those APIs is commands, which we will cover
today.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Commands are realized in different ways on different platforms. The main menu
uses the available command menus and groups to organize its main menu items on
macOS. Each menu is represented as a top-level menu bar menu. Each command
group has a corresponding set of menu items in one of the top-level menus,
delimited by separator menu items.

On iPadOS, commands with keyboard shortcuts are exposed in the shortcut
discoverability HUD that users see when they hold down the Command key.

> To learn more about implementing keyboard shortcuts, take a look at my [
> “Keyboard shortcuts in SwiftUI” ](/2020/11/17/keyboard-shortcuts-in-
> swiftui/) post.
    
    
    @main
    struct TestProjectApp: App {
        var body: some Scene {
            WindowGroup {
                ContentView()
            }.commands {
                CommandMenu("First menu") {
                    Button("Print message") {
                        print("Hello World!")
                    }.keyboardShortcut("p")
                }
            }
        }
    }
    

![commands](/public/commands1.png)

As you can see in the example above, you can attach the commands modifier to
any scene in your app and provide a _CommandBuilder_ closure. _CommandBuilder_
is a function builder like _ViewBuilder_ , but instead of views, it builds
commands. You can use primitive command types provided by SwiftUI to compose
them together and build your own unique main menu experience.

> A scene is a part of an app’s user interface with a lifecycle managed by the
> system. To learn more take a look at my [ “Managing scenes in SwiftUI”
> ](/2020/08/26/managing-scenes-in-swiftui/) post.

_CommandMenu_ is a primitive command type that accepts a title for your menu
item and a _ViewBuilder_ closure that will be used to build menu items. You
can use _Button, Picker, Divider, Toggle,_ and other SwiftUI views to build
your command view hierarchy.

    
    
    @main
    struct TestProjectApp: App {
        @State private var filter = 1
    
        var body: some Scene {
            WindowGroup {
                ContentView()
            }.commands {
                CommandMenu("First menu") {
                    Button("Print message") {
                        print("Hello World!")
                    }.keyboardShortcut("p")
    
                    Button("Print second message") {
                        print("Second message!")
                    }
    
                    Divider()
    
                    Button("Print third message") {
                        print("Third message!")
                    }
    
                    Picker(selection: $filter, label: Text("Filter")) {
                        Text("Option 1").tag(1)
                        Text("Option 2").tag(2)
                        Text("Option 3").tag(3)
                    }
                }
            }
        }
    }
    

![commands](/public/commands2.png)

There can be some situations where you need to reuse command types. You can do
that by defining your own commands type by conforming to _Commands_ protocol.
This approach allows you to reuse your commands.

    
    
    struct SortingCommands: Commands {
        @Binding var sorting: Int
    
        var body: some Commands {
            CommandMenu("Sort") {
                Picker(selection: $sorting, label: Text("Sorting")) {
                    Text("Option 1").tag(1)
                    Text("Option 2").tag(2)
                    Text("Option 3").tag(3)
                }
            }
        }
    }
    
    @main
    struct MyApp: App {
        @State private var sorting = 1
    
        var body: some Scene {
            WindowGroup {
                ContentView()
            }.commands {
                SortingCommands(sorting: $sorting)
            }
        }
    }
    

Now we know how to create new command menus. What if we need to add the menu
item to the existing system provided menu or replace it. For this particular
case, SwiftUI provides us _CommandGroup_ type, which allows us to insert new
command items before, after or even replace the system provided item. Let’s
see how we can use it.

    
    
    @main
    struct TestProjectApp: App {
        var body: some Scene {
            WindowGroup {
                ContentView()
            }.commands {
                CommandGroup(before: CommandGroupPlacement.newItem) {
                    Button("before item") {
                        print("before item")
                    }
                }
    
                CommandGroup(replacing: CommandGroupPlacement.appInfo) {
                    Button("Custom app info") {
                        // show custom app info
                    }
                }
    
                CommandGroup(after: CommandGroupPlacement.newItem) {
                    Button("after item") {
                        print("after item")
                    }
                }
            }
        }
    }
    

![commands](/public/commands3.png)

As you can see in the example above, we create _CommandGroup_ and pass it a
_CommandGroupPlacement_ , which will be used as an anchor point for inserted
or replaced items. _CommandGroupPlacement_ provides us with many system
command locations like _newItem, saveItem, printItem, undoRedo, pasteboard,
windowArrangement, help, etc._

SwiftUI also provides us a few ready to use commands for searching, editing
and transforming text that you can enable by using commands modifier and
attaching it to any scene you need.

    
    
    @main
    struct TestProjectApp: App {
        var body: some Scene {
            WindowGroup {
                ContentView()
            }.commands {
                TextEditingCommands()
                TextFormattingCommands()
            }
        }
    }
    

####  Conclusion

This week, we learned about another new declarative API that SwiftUI provides
to build your macOS app’s main menu. I hope you enjoy this declarative API
that allows us to maintain a single codebase for different platforms. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this article. Thanks for reading, and see you next week!



# Inclusive enums with OptionSet

##  Inclusive enums with OptionSet

10 Apr 2019

Enums are one of the most powerful features of Swift language. It forms Value-
Oriented Programming in conjunction with Structs. Enum is the best way to
describe the exclusive state in Swift, but what about the case when you need
an inclusive state. Today we will talk about OptionSet protocol and how we can
achieve inclusive states with it.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Exclusive Enums

Assume that we have some HistoryFetcher class, which can fetch data from a
cache or make a network request or both of them. Let’s start with describing
very simple source enum.

    
    
    enum FetchSource {
        case memory
        case disk
        case remote
        case cache
        case all
    }
    

Now we can work on our history fetch method which will take a source as a
parameter and make request accordingly to the source.

    
    
    class HistoryFetcher {
        func fetch(from source: FetchSource = .all, handler: @escaping Handler<History>) {
            switch source {
            case .memory:
                fetchMemory(handler: handler)
            case .disk:
                fetchDisk(handler: handler)
            case .remote:
                fetchRemote(handler: handler)
            case .cache:
                fetchMemory(handler: handler)
                fetchDisk(handler: handler)
            case .all:
                fetchMemory(handler: handler)
                fetchDisk(handler: handler)
                fetchRemote(handler: handler)
            }
        }
    }
    

There are possible downsides of this approach.

  1. As soon as we increase the count of the sources, we have to add a separated case for that and add it to “all” case handling. 
  2. We can’t easily create some unions of sources, like memory and remote, or disk and remote, etc. We need a lot of additional logic here to make it possible. 

####  OptionSet for the rescue

OptionSet is a protocol which represents bitset types, where individual bits
represent members of a set. Adopting this protocol in your custom types lets
you perform set-related operations such as membership tests, unions, and
intersections on those types.

OptionSet protocol is very straightforward. All we need is rawValue property
which should be a type conforming FixedWidthInteger. So basically in most
cases, we can use Int type. Next, we have to create unique options using the
unique power of two for every case. Here we can use bit shifting operators.
Let’s refactor our FetchSource enum to use OptionSet.

    
    
    struct FetchSource: OptionSet {
        let rawValue: Int
    
        static let memory = FetchSource(rawValue: 1 << 0)
        static let disk = FetchSource(rawValue: 1 << 1)
        static let remote = FetchSource(rawValue: 1 << 2)
    
        static let cache: FetchSource = [.memory, .disk]
        static let all: FetchSource = [.cache, .remote]
    }
    

As you see above, we can create multiple union members, which contains other
members. It brings real power while handling this OptionSets. Here is the
refactored version of our HistoryFetcher class.

    
    
    class HistoryFetcher {
        func fetch(from source: FetchSource = .all, handler: @escaping Handler<History>) {
            if source.contains(.memory) {
                fetchMemory(handler: handler)
            }
    
            if source.contains(.disk) {
                fetchDisk(handler: handler)
            }
    
            if source.contains(.remote) {
                fetchRemote(handler: handler)
            }
        }
    }
    

New implementation of HistoryFetcher class is pretty simple. We handle every
unique case of FetchSource which is also covering all possible unions of our
OptionSet.

####  Conclusion

Today we learn how to use OptionSet protocol and how it can be useful as Enum
replacement with some extra features. We will continue to cover small and
powerful types from the Swift Foundation in future posts. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading and see you next week!



# Mastering images in SwiftUI

##  Mastering images in SwiftUI

27 May 2020

This week I want to talk to you about another view component that we have in
SwiftUI. Today we will deep dive into image view. Image view provides us a lot
of nice features that we don’t have in _UIImageView_ like rendering mode,
resizing options, interpolation, etc.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

As we usually do, let’s start with the basics. I’ve put an image in my asset
catalog to show you some examples.

    
    
    struct RootView: View {
        var body: some View {
            Image("carrot")
        }
    }
    

![image](/public/image1.png)

We create an image by providing the name from the asset catalog. By default,
the image view fits the source image. It means it has the size of its original
bitmap. Let’s add the _frame modifier_ to make our picture bigger.

    
    
    struct RootView: View {
        var body: some View {
            Image("carrot")
                .border(Color.orange)
                .frame(width: 300, height: 300)
                .border(Color.blue)
        }
    }
    

![image](/public/image2.png)

As you can see, the frame modifier doesn’t affect the size of our image. It
happens because image by default chooses its size by measuring source bitmap.
We can change this behavior by adding the _resizable_ modifier to the image.

    
    
    struct RootView: View {
        var body: some View {
            Image("carrot")
                .resizable()
        }
    }
    

![image](/public/image3.png)

The _resizable_ modifier tries to fill the entire available space with the
image without saving aspect ratio. To fix this issue, we can use _scaleToFit_
modifier.

    
    
    struct RootView: View {
        var body: some View {
            Image("carrot")
                .resizable()
                .scaledToFit()
        }
    }
    

![image](/public/image4.png)

####  Image interpolation

As we saw before, the image becomes a bit blurry when we try to resize it and
fill the entire screen. It happens in the result of the interpolation process
that SwiftUI applies to an image when stretching it.

When you stretch the image, SwiftUI replaces every pixel with the nearest
pixel in the output. While upscaling, it means multiple pixels of the same
color will be present. As a result, stretching introduces jaggedness. To solve
the issue, SwiftUI uses blur to make the stretching process invisible. We can
easily control the interpolation process by using the _interpolation modifier_
on the image. For example, this is how we can completely disable it.

    
    
    struct RootView: View {
        var body: some View {
            HStack {
                Image("carrot")
                    .resizable()
                    .scaledToFit()
                Image("carrot")
                    .interpolation(.none)
                    .resizable()
                    .scaledToFit()
            }
        }
    }
    

![image](/public/image5.png)

####  Tiled resizing

SwiftUI provides us two ways of image resizing. The first one is stretching,
and we have already covered it. The second one is tiled resizing. Let’s take a
quick look at the example of tiled resizing.

    
    
    struct RootView: View {
        var body: some View {
            Image("carrot")
                .resizable(resizingMode: .tile)
                .edgesIgnoringSafeArea(.all)
        }
    }
    

![image](/public/image6.png)

SwiftUI tries to fill the entire space with the image by duplicating its
original source. It might be useful when you want to fill the area with the
texture. You can also specify the part of the image that you want to tile. The
_resizable_ modifier accepts the _capInsets_ parameter that allows us to
choose the tiling part of the picture.

    
    
    struct RootView: View {
        var body: some View {
            Image("carrot")
                .resizable(
                    capInsets: .init(
                        top: 30,
                        leading: 30,
                        bottom: 30,
                        trailing: 30
                    ),
                    resizingMode: .tile
            )
        }
    }
    

![image](/public/image7.png)

####  Rendering mode

SwiftUI provides us two ways of rendering an image. The first one is called
the original. It tries to render the image as is without any additional visual
effects. The second one is the template mode. In this case, SwiftUI will fill
all the non-transparent pixels of your bitmap with the accent color. This mode
is beneficial when you use _SF Symbols_ as a button or navigation item icon,
and you want to tint them using your branding color. We can change the
rendering mode of the image by using _renderingMode_ modifier.

    
    
    struct RootView: View {
        var body: some View {
            Image("carrot")
                .renderingMode(.original)
        }
    }
    

SwiftUI automatically sets the rendering mode to template whenever you use it
inside a _NavigationLink_ or _NavigatioBarItem_ . Sometimes it is something
that we don’t except, and we can use _renderingMode_ modifier to change the
default mode.

####  Conclusion

SwiftUI’s image component provides us a really cool set of features out of the
box. I believe we cover today all the hidden gems of the image view. I hope
you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# SwiftUI wishlist for WWDC21

##  SwiftUI wishlist for WWDC21

26 May 2021

WWDC21 is coming pretty soon, and it is a great chance to think about the new
features that I want to see in SwiftUI. This wishlist contains not only the
list of the features I want to use but also possible APIs. Remember that this
post is the result of my imagination, and most of the code examples don’t
exist at the moment.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  List and ScrollView

SwiftUI provides you both _List_ and _ScrollView_ , but under the hood, these
views still use the UIKit implementation of _UITableView_ and _UIScrollView_ .
I love how _UITableView_ works and the API it provides us. But SwiftUI’s
_List_ and _ScrollView_ don’t expose all the powerful features of
_UITableView_ and _UIScrollView_ .

Almost all the screens in my apps use the List view in different styles, and I
hope to see more APIs from _UITableView_ , which allows styling separators,
cell backgrounds using the _ListStyle_ protocol.

    
    
    struct ContentView: View {
        let messages: [String]
    
        var body: some View {
            List {
                ForEach(messages, id: \.self) { message in
                    Text(message)
                }
            }.listStyle(DefaultListStyle(separator: .none, selection: .single))
        }
    }
    

_ScrollView_ is another crucial component for many screens. I usually build my
apps with accessibility in mind and support Dynamic Type out of the box.
_ScrollView_ is must-have root view for every screen where you want Dynamic
Type. _ScrollView_ in SwiftUI is still missing paging and content offset
features that we used to see in _UIScrollView_ .

    
    
    struct RootView: View {
        @State private var offset: CGPoint = .zero
    
        var body: some View {
            ScrollView(.vertical, showsIndicators: false, offset: $offset) {
                Text("Very long text")
                Button("Jump to top") {
                    self.offset = .zero
                }
            }
        }
    }
    

> We can read the content offset of ScrollView using preferences API in
> SwiftUI. To learn more, take a look at my dedicated [ “Mastering ScrollView
> in SwiftUI” ](/2020/09/24/mastering-scrollview-in-swiftui/) post.

####  CompositionalLayout

During the last year, Apple gave us _LazyHGrid_ and _LazyVGrid_ views, which
we can use to build views like calendars or photo grids. Grids work great, and
I love them, but we want to use the power of _CompositionalLayout_ that we
have in UIKit. I don’t think that Apple should get rid of _LazyHGrid_ and
_LazyVGrid_ views, but they can introduce a new _CompositionaView_ that
supports all the features of _CompositionalLayout_ .

    
    
    struct AppStoreView: View {
        let featured: [App]
        let appsWeLove: [App]
    
        var body: some View {
            CompositionaView {
                Section(.groupPagingCentered) {
                    Group(.horizontal, width: .fractionalWidth(0.5), height: .fractionalHeight(0.5)) {
                        ForEach(featured) { app in
                            FeatureAppView(app: app)
                        }
                    }
                }
    
                Section {
                    Group(.vertical, width: .fractionalWidth(0.9), height: .estimated(200)) {
                        ForEach(appsWeLove) { app in
                            SmallAppView(app: app)
                        }
                    }
                }
            }
        }
    }
    

####  Navigation

Navigation is another point of pain in SwiftUI. It works great for simple use
cases but doesn’t provide enough flexibility for complex solutions. What I
want to use is some sort of _RouterView_ that maps destinations to concrete
views.

    
    
    enum Destination {
        case home
        case login
        case profile(UUID)
        case settings
    }
    
    struct RootView: View {
        var body: some View {
            RouterView(initial: Destination.home) { destination in
                switch destination {
                case .home: HomeView()
                case .login: LoginView()
                case let .profile(user): ProfileView(user: user)
                case .settings: SettingsView()
                }
            }
        }
    }
    

We also can have a router in the environment and mutate the state of
navigation using the environment value.

    
    
    struct ProfileView: View {
        let user: UUID
        @Environment(\.router) var router
    
        var body: some View {
            VStack {
                Button("push settings screen") {
                    router.push(.settings)
                }
    
                Button("go home") {
                    router.popToRoot()
                }
            }
        }
    }
    

> To learn more about advanced techniques while building navigation in
> SwiftUI, take a look at my [ “Lazy navigation in SwiftUI”
> ](/2021/01/27/lazy-navigation-in-swiftui/) post.

####  Focus management and text fields

Sign-up form with multiple text fields is what I usually implement using UIKit
and then wrap with _UIViewControllerRepresentable_ . It is literally
impossible to handle the first responder in SwiftUI and move the focus from
one view to another.

    
    
    struct LoginView: View {
        @State private var email = ""
        @State private var password = ""
    
        @State private var hasFilledCredentials = false
        @Namespace private var namespace
    
        @Environment(\.resetFocus) var resetFocus
    
        var body: some View {
            VStack {
                TextField("email", text: $email)
                    .prefersDefaultFocus(!hasFilledCredentials, in: namespace)
    
                SecureField("password", text: $password)
    
                Button("login") {}
                    .prefersDefaultFocus(hasFilledCredentials, in: namespace)
    
                Button("reset credentials") {
                    hasFilledCredentials = false
                    resetFocus(in: namespace)
                }
            }.focusScope(namespace)
        }
    }
    

You might wonder, but this is the real API that we have in SwiftUI at the
moment. Unfortunately, it is available only for tvOS and watchOS, but I wish
to see it for iOS and macOS.

> To learn more about focus management in SwiftUI, take a look at my [ “Focus
> management in SwiftUI” ](/2020/12/02/focus-management-in-swiftui/) post.

####  Conclusion

I didn’t mention small things like _Pull-to-Refresh, SearchBar, TextView_ ,
but I still expect them to appear. SwiftUI has its own set of pros and cons.
But for me, it is the way to go with my projects. I’m so excited about the
upcoming WWDC and hope to see at least a part of the features I mentioned in
this post. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Layout priorities in SwiftUI

##  Layout priorities in SwiftUI

15 Apr 2020

This week we will talk about another core process in SwiftUI. We will learn
the procedure of laying out views. We will understand how SwiftUI calculates
positions and sizes of our views and how we can change that process using
layout priorities.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

You can build regular views without real knowledge of the layout process.
SwiftUI has a declarative nature where you have to describe what you want to
achieve, and SwiftUI will understand it. Let’s start our discussion with the
simple example of a “Hello World” app in SwiftUI.

    
    
    import SwiftUI
    
    struct MessageView: View {
        var body: some View {
            Text("Hello World!!!")
        }
    }
    

Assume that _MessageView_ is the root view of our app.

  1. SwiftUI passes all the available space to _MessageView_ . 
  2. _MessageView_ has only one child, which is the text view. _MessageView_ proposes the available space to the text view and asks it to calculate its size. 
  3. The text view measures the size of its content and passes it back to _MessageView_ . 
  4. _MessageView_ now understands the size of the text view and place it in the center of available space. 

This is how the SwiftUI layout system works. It always applies these four
steps.

####  Layout Priority

Let’s take a look at the more complicated example with multiple sibling views
inside an _HStack_ .

    
    
    import SwiftUI
    
    struct MessageView: View {
        var body: some View {
            HStack(spacing: 16) {
                Text("Hello")
                Text("World")
                Text("!!!")
            }
            .font(.largeTitle)
        }
    }
    

Vertical and horizontal stacks have additional steps in the layout process.

  1. First of all, stack view calculates adaptive spacing between items and deducts it from available space. 
  2. Then stack view divides available space into equal parts and offers one of them to the first child. 
  3. The child view calculates its size and returns it to the parent stack. 
  4. As the next step, stack deducts the size of the first child from available space and divide it into equal portions again. 
  5. Stack view repeats this process as many times as needed to calculate the size of every child. 
  6. It the end, stack view sum the spacing between items and calculated sizes of children to understand its own size and pass it back to the parent. 

One thing that we can adjust in this process is the order of size proposing.
Usually, SwiftUI starts the layout process inside a stack with the least
flexible view. But we can alter this rule by using _layoutPriority_ modifier.

Layout priority defines the order of the size proposing process. By default,
all views have 0 as default priority. SwiftUI allows us to set a custom layout
priority using _layoutPriority_ modifier. SwiftUI uses layout priorities to
sort views in descending order. It means SwiftUI will propose views with
higher priority first.

    
    
    import SwiftUI
    
    struct MessageView: View {
        var body: some View {
            HStack(spacing: 16) {
                Text("Hello")
                Text("World")
                Text("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                    .layoutPriority(1)
            }
            .font(.largeTitle)
            .lineLimit(1)
        }
    }
    

As you can see in the example above, we use _layoutPriority_ modifier to
change the order of the layout process. SwiftUI will start the size proposing
process with the latest view inside the _HStack_ because it has the highest
priority in the view hierarchy. Try to remove _layoutPriority_ modifier to
understand how it works.

####  Conclusion

This week we learned about another exciting feature of SwiftUI. To be honest,
I don’t use layout priorities a lot. Usually, I’m able to build the needed
layout without altering priorities, but it is always good to know that we have
this tool in the toolbox. I hope you enjoy the post. Feel free to follow me on
[ Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Combining multiple Combine publishers in Swift

##  Combining multiple Combine publishers in Swift

12 May 2021

I’ve already covered a few essential topics from the Combine framework story.
We talked about handling errors and chaining operations, but today I want to
talk about running multiple operations in parallel and handing results in a
single place. This week we will learn how to use zip, merge and combine
operators.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Zip

_Zip_ operator is handy when you have a couple of publishers and need to wait
for values from both of them. For example, assume that you are working on some
kind of store app. You have a product screen where you show product details
and the list of related products. In this case, you might want to display
details and associated products at the same time. You can achieve this
behavior using the _Zip_ operator.

    
    
    final class ProductViewModel: ObservableObject {
        @Published private(set) var product: Product?
        @Published private(set) var related: [Product] = []
    
        let service = ProductsService()
        private var cancellable: AnyCancellable?
    
        func fetch(_ product: UUID) {
            cancellable = Publishers.Zip(
                service.fetch(product),
                service.fetchRelatedProducts(for: product)
            )
            .sink(
                receiveCompletion: { print($0) },
                receiveValue: { [weak self] product, related in
                    self?.product = product
                    self?.related = related
                }
            )
        }
    }
    

> To learn more about designing API with Combine publishers, take a look at my
> [ “Designing API using Combine framework” ](/2021/04/07/designing-api-using-
> combine-framework/) post.

As you can see in the example above, we use _Zip_ to fetch product details and
related products. As soon as both publishers emit the value _sink_ subscriber
will assign them to the stored properties.

####  CombineLatest

The main downside of the _Zip_ operator is that it delivers values only when
all the publishers emit. Sometimes we want to obtain all the values even when
some of them change more often than others. For example, assume that you are
working on a signup screen where you have text fields for email, password, and
repeated password. You also have a signup button that should be enabled when
all the text fields contain valid data.

    
    
    final class SignUpViewModel: ObservableObject {
        @Published var email: String = ""
        @Published var password1: String = ""
        @Published var password2: String = ""
    
        var isValid: AnyPublisher<Bool, Never> {
            Publishers
                .CombineLatest3($email, $password1, $password2)
                .allSatisfy { email, password1, password2 in
                    email.contains("@") &&
                        password1.count > 7 &&
                        password1 == password2
                }.eraseToAnyPublisher()
        }
    }
    

Here we have the signup screen’s view model. It contains a few stored
properties which we are going to use in our view. It also has _isValid_
computed property that creates a validation publisher.

As you can see, we use the _CombineLatest_ operator to obtain the latest
values from all the publishers. _CombineLatest_ publisher collects the first
value from all three publishers and emits them as a single tuple.
_CombineLatest_ continues sending new values even when only one publisher
emits a new value.

On the other hand, the _Zip_ operator sends a new value only when all the
publishers emit new values.

####  MergeMany

_Merge_ is another helpful operator provided by the Combine framework that you
can use to join a few different publishers with the same output type. I often
use the _Merge_ operator while fetching locally cached data and fetching new
data from the webserver.

    
    
    final class FavoritesViewModel: ObservableObject {
        @Published private(set) var products: [Product] = []
        let service = ProductsService()
    
        func fetch() {
            Publishers.MergeMany(
                service.fetchCachedFavorites(),
                service.fetchFavorites()
            )
            .replaceError(with: [])
            .assign(to: &$products)
        }
    }
    

As you can see, the _MergeMany_ operator allows me to create a single pipe for
cached and fresh data where the cached information usually appears first and
then replaced by new data.

> To learn about building custom Combine operators, take a look at my [
> “Building custom Combine operators in Swift” ](/2021/04/28/building-custom-
> combine-operators-in-swift/) post.

####  Conclusion

This week we learned about operators of the Combine framework, which allows us
to build complex data pipelines by zipping and merging multiple publishers. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Accessibility rotors in SwiftUI

##  Accessibility rotors in SwiftUI

14 Sep 2021

SwiftUI Release 3 contains many new APIs that we can utilize to improve
accessibility in our apps, and one of them is the new _accessibilityRotor_
view modifier. This week we will learn how to use the _accessibilityRotor_
view modifier to provide custom VoiceOver navigation using rotors.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Usually, we navigate through the app using the left and right swipes while
VoiceOver is on. But sometimes, we need a custom path for navigation through a
specific collection of elements. A particular group of elements is called a
custom rotor. You can create as many as you need custom rotors in your app.

To use the rotor, rotate two fingers on your iOS device’s screen as if you’re
turning a dial. VoiceOver will say the first rotor option. Keep rotating your
fingers to hear more options. Lift your fingers to choose an option. Then
flick your finger up or down on the screen to navigate through it.

####  SwiftUI custom rotors API

Assume that we are working on a screen that provides information about health
trends. There is a long list of different trends, including positive,
negative, and constant results. Negative trends are the things the user should
focus on improving. That’s why we should build a custom rotor to navigate only
through negative trends. Let’s start by introducing the _Trend_ model and the
_TrendsView_ .

    
    
    import SwiftUI
    
    struct Trend: Identifiable {
        let id = UUID()
        let message: String
        let isPositive: Bool
    }
    
    struct TrendView: View {
        let trend: Trend
    
        var body: some View {
            HStack {
                Image(systemName: trend.isPositive ? "chevron.up" : "chevron.down")
                    .accessibilityElement()
                    .accessibilityLabel(trend.isPositive ? "positive" : "negative")
                Text(trend.message)
            }.accessibilityElement(children: .combine)
        }
    }
    

The code above is super simple. Please look at how we use the
_accessibilityElement_ view modifier to make _TrendView_ accessible and
combine all the children’s information.

> To learn about the basics of accessibility in SwiftUI, take a look at my [
> “Accessibility in SwiftUI” ](/2019/09/10/accessibility-in-swiftui/) post.
    
    
    struct TrendsView: View {
        let trends: [Trend]
    
        var body: some View {
            List {
                ForEach(trends, id: \.id) { trend in
                    TrendView(trend: trend)
                }
            }
            .accessibilityRotor("Negative trends") {
                ForEach(trends, id: \.id) { trend in
                    if !trend.isPositive {
                        AccessibilityRotorEntry(trend.message, id: trend.id)
                    }
                }
            }
        }
    }
    

Here we have the _TrendsView_ that displays the list of trends. We use the
_accessibilityRotor_ view modifier to create a custom rotor called “Negative
trends”. As soon as the user focuses on the list, VoiceOver suggests accessing
the negative trends rotor.

The first parameter of _accessibilityRotor_ view modifier is a label. You can
use _String, LocalizedStringKey, or Text_ view as a label. VoiceOver uses the
title to inform a user about a custom rotor.

The second parameter is the _AccessibilityRotorContentBuilder_ closure. The
_AccessibilityRotorContentBuilder_ function builder is very similar to
_ViewBuilder_ , but instead of building views, it creates
_AccessibilityRotorContent_ .

_AccessibilityRotorContent_ is also identical to _View_ protocol, but it
describes the content of the rotor. SwiftUI types like _ForEach_ and _Group_
conform both to _View_ and _AccessibilityRotorContent_ protocols. That’s why
we can use them both inside _ViewBuilder_ and
_AccessibilityRotorContentBuilder_ closures.

The last piece is the _AccessibilityRotorEntry_ conforming to
_AccessibilityRotorContent_ and allowing us to use it inside a _ForEach_ or
_Group_ . We use it to create a rotor entry and bind it to a SwiftUI view
using an ID. This is the point where all the magic takes place. We have two
_ForEach_ instances, and SwiftUI is smart enough to match the IDs inside
_ForEach_ and bind rotor entries to the views with the same IDs.

####  accessibilityRotorEntry view modifier

The approach above works like a charm, but we can gain more control over
binding rotor entry to a view using the _accessibilityRotorEntry_ view
modifier.

    
    
    struct TrendsView: View {
        let trends: [Trend]
    
        @Namespace private var customRotorNamespace
    
        var body: some View {
            List {
                ForEach(trends, id: \.id) { trend in
                    VStack {
                        TrendView(trend: trend)
                            .accessibilityRotorEntry(id: trend.id, in: customRotorNamespace)
                        Text(trend.notes)
                    }
                }
            }
            .accessibilityRotor("Negative trends") {
                ForEach(trends, id: \.id) { trend in
                    if !trend.isPositive {
                        AccessibilityRotorEntry(trend.message, trend.id, in: customRotorNamespace) 
                    }
                }
            }
        }
    }
    

In this case, we use the _accessibilityRotorEntry_ view modifier to bind a
rotor entry id to a view explicitly. It allows us to ignore IDs from _ForEach_
and can be very helpful in situations where we don’t have ForEach or don’t
need to include the whole child of _ForEach_ into the rotor, like in our
example.

####  Preparing rotor entries

As a bonus, the _AccessibilityRotorEntry_ type allows us to provide a closure
to run when the user navigates to a particular rotor entry. For example, we
can scroll to the specific list item if it is not visible when navigating to
that item using rotors.

    
    
    struct TrendsView: View {
        let trends: [Trend]
    
        @Namespace private var customRotorNamespace
    
        var body: some View {
            ScrollViewReader { scrollView in
                List {
                    ForEach(trends, id: \.id) { trend in
                        TrendView(trend: trend)
                            .accessibilityRotorEntry(id: trend.id, in: customRotorNamespace)
                            .id(trend.id)
                    }
                }
                .accessibilityRotor("Negative trends") {
                    ForEach(trends, id: \.id) { trend in
                        if !trend.isPositive {
                            AccessibilityRotorEntry(trend.message, trend.id, in: customRotorNamespace) {
                                scrollView.scrollTo(trend.id)
                            }
                        }
                    }
                }
            }
        }
    }
    

####  TextEditor Rotors

The new accessibility rotors API is robust and allows us to navigate even
through text in _TextEditor_ . We can mark particular parts of our text
content and navigate between them inside the _TextEditor_ .

    
    
    struct ContentEditor: View {
        @Binding var content: Content
    
        var body: some View {
            TextEditor(text: $content.text)
                .accessibilityRotor("Emails", textRanges: content.emailRanges)
                .accessibilityRotor("Links", textRanges: content.linkRanges)
        }
    }
    

####  Conclusion

SwiftUI Release 3 has done great work in the area of accessibility. Now we can
use all these new APIs to build super accessible apps. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# The magic of view preferences in SwiftUI

##  The magic of view preferences in SwiftUI

15 Jan 2020

I took a one week break from SwiftUI topic when we were talking about [
building networking in Swift using functions ](/2020/01/08/building-
networking-layer-using-functions/) . It’s time to go back to SwiftUI. This
week we will talk about view preferences, which is another powerful concept of
SwiftUI views that allows us to pass data through view hierarchy.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Preferences

SwiftUI has the environment concept which we can use to pass data down into a
view hierarchy. Parent views share its environment with child views and
subscribe to the changes. But sometimes we need to pass data up from child
view to the parent view, and this is where preferences shine. Let’s take a
look at the small example.

> To learn more about the benefits of the environment feature take a look at [
> “The power of Environment in SwiftUI” post ](/2019/08/21/the-power-of-
> environment-in-swiftui/) .
    
    
    import SwiftUI
    
    struct ContentView: View {
        let messages: [String]
    
        var body: some View {
            NavigationView {
                List(messages, id: \.self) { message in
                    Text(message)
                }.navigationBarTitle("Messages")
            }
        }
    }
    

Here is an excellent example of preference usage. _navigationBarTitle_
modifier uses the preference feature to pass the data up to the
_NavigationView_ , which renders it in the navigation bar. Let’s take a look
at the possible internal implementation of the _navigationBarTitle_ modifier.

    
    
    import SwiftUI
    
    struct NavigationBarTitleKey: PreferenceKey {
        static var defaultValue: String = ""
    
        static func reduce(value: inout String, nextValue: () -> String) {
            value = nextValue()
        }
    }
    
    extension View {
        func navigationBarTitle(_ title: String) -> some View {
            self.preference(key: NavigationBarTitleKey.self, value: title)
        }
    }
    

In order to use preferences, we need to declare a struct conforming
_PreferenceKey_ protocol. _PreferenceKey_ has two requirements, default value
for preference and reduce method. Reduce method maintains the logic that
combines multiple values into a single one. You might need to replace or
append values. In our case, we need to replace the old title with the current
one. As you can see, we use a preference modifier to set a value.

    
    
    struct ContentView: View {
        let messages: [String]
    
        var body: some View {
            NavigationView {
                List(messages, id: \.self) { message in
                    Text(message)
                }.navigationBarTitle("Messages")
            }.onPreferenceChange(NavigationBarTitleKey.self) { title in
                // you have to set title value in the navigation bar here
                print(title)
            }
        }
    }
    

In the example above, we use the _onPreferenceChange_ modifier to observe
_NavigationBarTitleKey_ . SwiftUI will call this closure whenever view sets a
new value for the preference.

####  Understanding the size of child view

Sometimes we need to get the size of the child view to make some offset, and
it is another excellent example of preference usage in SwiftUI. Let’s take a
look at how we can use preferences to fetch the size of the child view.

    
    
    struct SizePreferenceKey: PreferenceKey {
        static var defaultValue: CGSize = .zero
    
        static func reduce(value: inout CGSize, nextValue: () -> CGSize) {
            value = nextValue()
        }
    }
    
    struct SizeModifier: ViewModifier {
        private var sizeView: some View {
            GeometryReader { geometry in
                Color.clear.preference(key: SizePreferenceKey.self, value: geometry.size)
            }
        }
    
        func body(content: Content) -> some View {
            content.background(sizeView)
        }
    }
    

Here we have a _SizeModifier_ struct, which attaches a geometry reader to a
view as a background to read its size. It is a pretty useful technique that
allows us to calculate the size of the view. Now we can understand the size of
the view using _onPreferenceChange_ modifier.

> To learn more about the benefits of the view modifiers take a look at [
> “ViewModifiers in SwiftUI” post ](/2019/08/07/viewmodifiers-in-swiftui/) .
    
    
    struct ScrollView<Content: View>: View {
        let content: Content
    
        @GestureState private var translation: CGSize = .zero
        @State private var contentSize: CGSize = .zero
        @State private var offset: CGSize = .zero
    
        private var dragGesture: some Gesture {
            DragGesture(minimumDistance: 0)
                .updating($translation) { value, state, _ in
                    state = value.translation
            }.onEnded { value in
                self.offset = value.translation
            }
        }
    
        init(@ViewBuilder content: () -> Content) {
            self.content = content()
        }
    
        var body: some View {
            GeometryReader { geometry in
                self.content
                    .fixedSize()
                    .offset(self.offset)
                    .offset(self.translation)
                    .modifier(SizeModifier())
                    .onPreferenceChange(SizePreferenceKey.self) { self.contentSize = $0 }
                    .gesture(self.isScrollable(geometry.size) ? self.dragGesture : nil)
            }.clipped()
        }
    
        private func isScrollable(_ size: CGSize) -> Bool {
            contentSize.width > size.width || contentSize.height > size.height
        }
    }
    

Here is the possible implementation of _ScrollView_ that uses preferences to
understand the size of its content and enable/disable scrolling based on that
value. I use this implementation only for the demo, please don’t use it in
production.

####  Conclusion

Today we talked about another very great feature of SwiftUI. Preferences
feature has the same power as the environment, but instead, it uses reversed
direction to pass the data. I’m sure you won’t need it very often, but you
should know about it. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Conditional layouts in SwiftUI

##  Conditional layouts in SwiftUI

16 Aug 2022

From the first day of the SwiftUI framework, we have primary layout containers
like _VStack_ , _HStack_ , and _ZStack_ . The current iteration of the SwiftUI
framework brings another layout container allowing us to place views in a
grid. But the most important addition was the _Layout_ protocol that all
layout containers conform to. It also allows us to build our super-custom
layout containers from scratch. This week we will learn the basics of the
_Layout_ protocol in SwiftUI and how to build conditional layouts using
_AnyLayout_ type.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

The way layout works in SwiftUI was always a hidden gem because of private
APIs that Apple doesn’t show us. Nowadays, we have the _Layout_ protocol that
expands the magical world of layout calculations in SwiftUI.

    
    
    @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
    public protocol Layout : Animatable {
        func sizeThatFits(
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Self.Cache
        ) -> CGSize
        
        func placeSubviews(
            in bounds: CGRect,
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Self.Cache
        ) 
    }
    

The _Layout_ protocol has two functions to implement. The first one calculates
the final size of the layout with all children inside. And the second one
places children according to your layout logic.

The current iteration of SwiftUI introduces new layout primitives conforming
to the new _Layout_ protocol. Now we have _HStackLayout_ instead of _HStack_ ,
_VStackLayout_ instead of _VStack_ , _ZStackLayout_ instead of _ZStack_ , and
_GridLayout_ instead of _Grid_ .

    
    
    struct LayoutExample: View {
        var body: some View {
            VStackLayout(alignment: .leading) {
                Text("Hello")
                Text("World")
                Text("!!!")
            }
        }
    }
    

As you can see in the example above, the usage of the _VStackLayout_ is the
same as the _VStack_ . You can replace your _VStack_ with _VStackLayout_ if
you support only the latest platform versions. But keep in mind that Apple
will not remove _VStack_ , _HStack_ , and _ZStack_ anytime soon. Instead, it
recommends we use new layout primitives only when we need conditional layouts.

####  Conditional Layouts

To understand what conditional layout is, let’s take a look at the small
example.

    
    
    struct ConditionalLayoutExample1: View {
        @Environment(\.horizontalSizeClass) private var size
        
        var body: some View {
            if size == .regular {
                HStack {
                    View1()
                    View2()
                }
            } else {
                VStack {
                    View1()
                    View2()
                }
            }
        }
    }
    

As you can see in the example above, we display our views conditionally in a
horizontal or vertical stack. The logic depends on the horizontal size class.
Nothing is wrong with the code above, but there is a hidden issue. Whenever
the size class changes, the SwiftUI framework recreates the views inside the
if statement.

This is how conditions work in the _ViewBuilder_ type. While SwiftUI destroys
your views, it also clears all the state of destroyed views, which might not
be suitable for your app’s user experience. It happens because the structural
identity of your view changes while switching from _HStack_ to _VStack_ .

> I highly encourage you to read my [ “Structural identity in SwiftUI”
> ](/2021/12/09/structural-identity-in-swiftui/) post to understand better how
> SwiftUI identifies your views and the way conditions work in SwiftUI.

SwiftUI provides a new way to keep the structural identity of our view
hierarchy while changing the layout container using the new _AnyLayout_ type.

    
    
    struct ConditionalLayoutExample2: View {
        @Environment(\.horizontalSizeClass) private var size
        
        var body: some View {
            let layout = (size == .regular) ?
            AnyLayout(HStackLayout()) :
            AnyLayout(VStackLayout())
            
            layout {
                View1()
                View2()
            }
        }
    }
    

We use the new _AnyLayout_ type to erase the actual type of the layout that
depends on the current horizontal size class. The structural identity of our
view stays the same. In this case, the SwiftUI doesn’t recreate the views. It
only moves them according to the new layout, and this transition can be easily
animated.

    
    
    struct ConditionalLayoutExample2: View {
        @Environment(\.horizontalSizeClass) private var size
        
        var body: some View {
            let layout = (size == .regular) ?
            AnyLayout(HStackLayout()) :
            AnyLayout(VStackLayout())
            
            layout {
                View1()
                View2()
            }
            .animation(.default, value: size)
        }
    }
    

####  Conclusion

Today we learned about the new _Layout_ protocol and the type-eraser
_AnyLayout_ type. Now we can build more fluid transitions in our apps using
these new tools. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Transactions in SwiftUI

##  Transactions in SwiftUI

07 Oct 2020

Animations play a vital role in SwiftUI. We saw a lot of examples of complex
animations that we can easily implement in SwiftUI. The guidance for building
fluid animations in SwiftUI has the only one step: mutate your state, and
SwiftUI will automatically animate changes in your views. Today we will talk
about transactions, which is a hidden gem of SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Transaction is the context of the current state-processing update. SwiftUI
creates a transaction for every state change. Transaction contains the
animation that SwiftUI will apply during the state change and the property
indicating whenever this transaction disables all the animations defined by
the child views. Let’s take a look at the quick example.

    
    
    import SwiftUI
    
    struct AnimatedView: View {
        let scale: CGFloat
    
        var body: some View {
            Circle()
                .fill(Color.accentColor)
                .scaleEffect(scale)
                .animation(.spring())
        }
    }
    

As we know, animation modifier applies animation to all the child views of the
applied view. Apple suggests us to use this modifier on leaf views rather than
container views. This approach allows us to specify animation only for the
views that we need.

> To learn more about the animation modifier in Swift, look at my [
> “Animations in SwiftUI” ](/2019/06/26/animations-in-swiftui/) post.
    
    
    struct ContentView: View {
        @State private var scale = false
    
        var body: some View {
            AnimatedView(scale: scale ? 0.5 : 1)
                .onTapGesture {
                    scale.toggle()
                }
        }
    }
    

Using an animation modifier on a child view has one downside. We can’t control
that animation. For example, we are not able to replace the spring animation
with a linear one. This is where we can use transactions to override
animations defined in child views.

    
    
    struct ContentView: View {
        @State private var scale = false
    
        var body: some View {
            AnimatedView(scale: scale ? 0.5 : 1)
                .onTapGesture {
                    var transaction = Transaction(animation: .linear)
                    transaction.disablesAnimations = true
    
                    withTransaction(transaction) {
                        scale.toggle()
                    }
                }
        }
    }
    

As you can see in the example above, we use the _withTransaction_ function to
wrap our mutations with a custom transaction. The new transaction disables all
the animations defined inside a view hierarchy and enables a linear animation.

####  Transaction modifier

Now we know how to create a custom transaction for a complete view hierarchy.
There is also a way to modify the current transaction for a concrete view
using the transaction modifier. Let’s see how we can use it.

    
    
    struct ContentView: View {
        @State private var scale = false
    
        var body: some View {
            VStack {
                AnimatedView(scale: scale ? 0.5 : 1)
                    .transaction { transaction in
                        transaction.animation = .spring()
                    }
                AnimatedView(scale: scale ? 0.5 : 1)
                    .transaction { transaction in
                        transaction.disablesAnimations = true
                    }
            }.onTapGesture {
                scale.toggle()
            }
        }
    }
    

The transaction modifier accepts a closure with the _inout_ instance of
_Transaction_ struct. We can modify the current transaction inside this
closure as we need it. In the example above, we completely disable animations
for one view and replace animation for another view.

####  Transactions during gesture updates

You can find the usage of transactions across many APIs in SwiftUI. For
example, you can modify the transaction during gesture updates. It works
similarly to the transaction modifier.

    
    
    struct ContentView: View {
        @GestureState private var offset: CGSize = .zero
    
        var body: some View {
            Circle()
                .frame(width: 100, height: 100)
                .offset(offset)
                .gesture(
                    DragGesture()
                        .updating($offset) { value, state, transaction in
                            state = value.translation
                            transaction.animation = .interactiveSpring()
                        }
                )
        }
    }
    

> To learn more about building interactive views, look at my [ “Gestures in
> SwiftUI” ](/2019/07/10/gestures-in-swiftui/) post.

####  Transactions in bindings

You can also provide a custom transaction during binding updates using the
_transaction function_ on a binding.

    
    
    struct ContentView: View {
        @State private var scale = false
    
        var body: some View {
            // ...
        }
    
        private var animatedBinding: Binding<Bool> {
            var transaction = Transaction(animation: .interactiveSpring())
            transaction.disablesAnimations = true
            return $scale.transaction(transaction)
        }
    }
    

> To learn more about features provided by bindings, look at my [ “Binding in
> SwiftUI” ](/2020/04/08/binding-in-swiftui/) post.

####  Conclusion

Today we learned all about transactions in SwiftUI. Understanding transactions
opens new doors for building powerful and reusable view components in SwiftUI.
I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Mastering charts in SwiftUI. Selection.

##  Mastering charts in SwiftUI. Selection.

18 Jul 2023

Swift Charts provides a lovely API allowing you to tune charts and add custom
interactions within a few lines of code. The following framework iteration
goes further and allows us to track chart selection in a single line of code.
This week we will learn about new APIs allowing us to handle selection in
Swift Charts.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The pre-iOS17 version of Swift Charts provides us with the _chartOverlay_ view
modifier allowing us to build custom overlays, including gestures. It also
provides APIs for converting geometry position into a chart value. Let’s look
at how we can use the _chartOverlay_ view modifier to build selection tracking
in Swift Charts.

    
    
    struct SelectionExample: View {
        @State private var selectedIndex: Int?
        @State private var numbers = (0..<10)
            .map { _ in Double.random(in: 0...10) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
                
                if let selectedIndex {
                    RuleMark(x: .value("Index", selectedIndex))
                        .annotation(position: .bottom) {
                            Text(verbatim: selectedIndex.formatted())
                                .padding()
                                .background(.regularMaterial)
                        }
                }
            }
            .chartOverlay { chart in
                GeometryReader { geometry in
                    Rectangle().fill(.primary.opacity(0.01)).containerShape(.rect)
                        .gesture(
                            DragGesture()
                                .onEnded { _ in
                                    selectedIndex = nil
                                }
                                .onChanged { value in
                                    guard let plotFrame = chart.plotFrame else {
                                        return
                                    }
                                    
                                    let startX = geometry[plotFrame].origin.x
                                    let currentX = value.location.x - startX
                                    
                                    if let index: Int = chart.value(atX: currentX) {
                                        selectedIndex = index
                                    }
                                }
                        )
                }
            }
        }
    }
    

As you can see in the example above, we use the _chartOverlay_ view modifier
to add a transparent overlay with a drag gesture. We use an instance of the
_ChartProxy_ type to convert the drag position to the chart data. We also draw
a _RuleMark_ in the place where the chart is selected.

> To learn more about building interactions with the Swift Charts framework,
> take a look at my [ “Mastering charts in SwiftUI. Interactions.”
> ](/2023/02/06/mastering-charts-in-swiftui-interactions/) post.

The code above is simple, but writing it for every chart that needs a
selection feature is repetitive. Fortunately, the next iteration of the Swift
Charts framework includes the _chartXSelection_ and _chartYSelection_ view
modifiers allowing us to implement the chart selection feature in a single
line.

    
    
    struct SelectionExample: View {
        @State private var selectedIndex: Int?
        @State private var numbers = (0..<10)
            .map { _ in Double.random(in: 0...10) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
                
                if let selectedIndex {
                    RuleMark(x: .value("Index", selectedIndex))
                        .annotation(position: .bottom) {
                            Text(verbatim: selectedIndex.formatted())
                                .padding()
                                .background(.regularMaterial)
                        }
                }
            }
            .chartXSelection(value: $selectedIndex)
        }
    }
    

As you can see, we replaced the whole chart overlay logic with a single line
of code using the _chartXSelection_ view modifier. It does the same thing in a
single line and looks great.

The new version of the Swift Charts framework allows us to select a single
value and a range of values. We can use _chartXSelection_ and
_chartYSelection_ with the binding of _ClosedRange_ type to allow range
selection.

    
    
    struct RangeSelectionExample: View {
        @State private var selectedRange: ClosedRange<Int>?
        @State private var numbers = (0..<10)
            .map { _ in Double.random(in: 0...10) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
                
                if let selectedRange {
                    RectangleMark(
                        xStart: .value("Index", selectedRange.lowerBound),
                        xEnd: .value("Index", selectedRange.upperBound),
                        yStart: .value("Number", 0),
                        yEnd: .value("Number", 10)
                    )
                    .foregroundStyle(.blue.opacity(0.03 ))
                }
            }
            .chartXSelection(range: $selectedRange)
        }
    }
    

In the example above, we use the _chartXSelection_ view modifier with a
binding of _ClosedRange_ type. It allows us to draw a rectangle in the
selected values range.

The Swift Charts framework also allows us to customize the gesture while
selecting by applying the _chartGesture_ view modifier. We can use it to
create our own instance of the _DragGesture_ type and set the minimum distance
to the particular value.

    
    
    struct RangeSelectionExample: View {
        @State private var selectedRange: ClosedRange<Int>?
        @State private var numbers = (0..<10)
            .map { _ in Double.random(in: 0...10) }
        
        var body: some View {
            Chart(Array(zip(numbers.indices, numbers)), id: \.1) { index, number in
                LineMark(
                    x: .value("Index", index),
                    y: .value("Number", number)
                )
                
                if let selectedRange {
                    RectangleMark(
                        xStart: .value("Index", selectedRange.lowerBound),
                        xEnd: .value("Index", selectedRange.upperBound),
                        yStart: .value("Number", 0),
                        yEnd: .value("Number", 10)
                    )
                    .foregroundStyle(.blue.opacity(0.03 ))
                }
            }
            .chartXSelection(range: $selectedRange)
            .chartGesture { chart in
                DragGesture(minimumDistance: 16)
                    .onChanged {
                        chart.selectXRange(
                            from: $0.startLocation.x,
                            to: $0.location.x
                        )
                    }
                    .onEnded { _ in selectedRange = nil }
            }
        }
    }
    

As you can see, we tuned an instance of the _DragGesture_ type to handle
selection in our chart. The _chartGesture_ view modifier provides us access to
an instance of the _ChartProxy_ type that we can use to select values or
ranges in the chart.

This week we learned about the new APIs allowing us to implement chart data
selection easily. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# The power of accessibilityChildren view modifier in SwiftUI

##  The power of accessibilityChildren view modifier in SwiftUI

25 May 2022

SwiftUI provides us with a rich set of view modifiers to manipulate the
accessibility tree of views. I covered many of them, and you can find them in
the blog’s dedicated Accessibility category. This week we will talk about the
_accessibilityChildren_ view modifier and how we can benefit from it.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The _accessibilityChildren_ view modifier allows us to create an accessibility
container for a view and populate it with the elements from a view you provide
using a _ViewBuilder_ closure. Let’s take a look at a quick example.

    
    
    struct BarChartShape: Shape {
        let dataPoints: [DataPoint]
        
        func path(in rect: CGRect) -> Path {
            Path { p in
                let width: CGFloat = rect.size.width / CGFloat(dataPoints.count)
                var x: CGFloat = 0
                
                for point in dataPoints {
                    let pointRect = CGRect(
                        x: x,
                        y: rect.size.height - point.value,
                        width: width,
                        height: rect.size.height
                    )
                    let pointPath = RoundedRectangle(cornerRadius: 8).path(in: pointRect)
                    p.addPath(pointPath)
                    x += width
                }
            }
        }
    }
    

As you can see in the example above, we have the shape-type drawing data
points we pass. We can’t provide accessibility values for every data point
because the shape becomes a single view after stroking or filling it.

> To learn more about accessibility view modifiers available in SwiftUI, take
> a look at the [ Accessibility category ](/categories) on the blog.

Fortunately, SwiftUI gives us the _accessibilityChildren_ view modifier,
especially for this case.

    
    
    struct ContentView: View {
        @State private var dataPoints: [DataPoint] = [
            .init(id: .init(), value: 20),
            .init(id: .init(), value: 30),
            .init(id: .init(), value: 5),
            .init(id: .init(), value: 100),
            .init(id: .init(), value: 80)
        ]
        
        var body: some View {
            BarChartShape(dataPoints: dataPoints)
                .fill(.red)
                .accessibilityLabel("Chart")
                .accessibilityChildren {
                    HStack(alignment: .bottom, spacing: 0) {
                        ForEach(dataPoints) { point in
                            RoundedRectangle(cornerRadius: 8)
                                .accessibilityValue(Text(point.value.formatted()))
                        }
                    }
                }
        }
    }
    

By applying the _accessibilityChildren_ view modifier, we create an
accessibility container and populate it with elements from the view provided
in the _ViewBuilder_ closure. SwiftUI doesn’t render the view that we pass via
_ViewBuilder_ closure. SwiftUI uses it only for populating the accessibility
tree with child elements.

> To learn more about the _ViewBuilder_ type, take a look at my [ “The power
> of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-viewbuilder-in-
> swiftui/) post.

The main difference between the _accessibilityChildren_ and
_accessibilityRepresentation_ view modifiers is that the first one doesn’t
affect the view itself. It only creates an accessibility container for child
elements where the _accessibilityRepresentation_ view modifier completely
replaces the accessibility tree of the current view.

> To learn more about the benefits of the _accessibilityRepresentation_ view
> modifier, look at my [ “The power of accessibilityRepresentation view
> modifier in SwiftUI” ](/2021/09/01/the-power-of-accessibility-
> representation-view-modifier-in-swiftui/) post.

Today we learned about another powerful accessibility view modifier that
SwiftUI provides us. SwiftUI is doing an excellent job by giving us so many
friendly APIs, simplifying the work we have to do to make our apps accessible
for everyone.



# Building Bottom sheet in SwiftUI

##  Building Bottom sheet in SwiftUI

11 Dec 2019

This week I want to start a series of posts about building interactive view
components that Apple heavily uses in its apps but doesn’t include them into
the SDK. Let’s begin with the bottom sheet. I think everybody used Apple Maps,
Shortcut or Apple Music apps. There is a draggable sheet at the bottom of the
screen. It looks like bottom sheet is going to be a must-use component, so
let’s try to implement it in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Usually, when I deal with interactive components, I start with implementing
the component in different states. After that, we can add the gesture which
manipulates the state of the component. In our case, we deal with the bottom
sheet. It has two different states: _open_ and _closed_ . Let’s start by
describing our view and all the needed properties which should be passed by
the parent view.

    
    
    import SwiftUI
    
    struct BottomSheetView<Content: View>: View {
        @Binding var isOpen: Bool
    
        let maxHeight: CGFloat
        let minHeight: CGFloat
        let content: Content
    
        init(isOpen: Binding<Bool>, maxHeight: CGFloat, @ViewBuilder content: () -> Content) {
            self.minHeight = maxHeight * Constants.minHeightRatio
            self.maxHeight = maxHeight
            self.content = content()
            self._isOpen = isOpen
        }
    }
    

As you can see, we started with defining a few properties of _BottomSheetView_
. First of all, it needs a binding to its state. By using binding, we extract
the state from the bottom sheet itself and allow the parent view to open/close
the sheet.

> To learn more about the benefits of _@Binding_ take a look at [
> “Understanding Property Wrappers in SwiftUI” ](/2019/06/12/understanding-
> property-wrappers-in-swiftui/) post.

We also require the maximum height which we will use whenever the sheet is
open, and we calculate the minimum height to use it whenever the sheet is
closed.

The last parameter we need is the content closure with _@ViewBuilder_ function
builder. _@ViewBuilder_ allows us to use closure to build the content view of
our bottom sheet. Other view containers like _VStack, HStack, ZStack_ also use
_@ViewBuilder_ to describe content closure. Let’s make it similar to standard
SwiftUI components.

We already defined all the needed public properties. Let’s place the content
now.

    
    
    private var offset: CGFloat {
        isOpen ? 0 : maxHeight - minHeight
    }
    
    private var indicator: some View {
        RoundedRectangle(cornerRadius: Constants.radius)
            .fill(Color.secondary)
            .frame(
                width: Constants.indicatorWidth,
                height: Constants.indicatorHeight
        )
    }
    
    var body: some View {
        GeometryReader { geometry in
            VStack(spacing: 0) {
                self.indicator.padding()
                self.content
            }
            .frame(width: geometry.size.width, height: self.maxHeight, alignment: .top)
            .background(Color(.secondarySystemBackground))
            .cornerRadius(Constants.radius)
            .frame(height: geometry.size.height, alignment: .bottom)
            .offset(y: self.offset)
        }
    }
    

The vertical stack is all we need to place the dragging indicator and content
of the bottom sheet. We also use _Shape API_ to draw the dragging symbol
programmatically, which is really simple. _GeometryReader_ provides all the
needed information about the size of the parent view that allows us properly
place our view. We use the _offset_ modifier to move our view, depending on
its state.

> To learn more about _Shape API_ and _GeometryReader_ take a look at [
> “Building BarChart with Shape API in SwiftUI” ](/2019/08/14/building-
> barchart-with-shape-api-in-swiftui/) post.

The last step is to attach the drag gesture and move the view whenever the
user drags the finger. Let’s see how we can do that.

    
    
    @GestureState private var translation: CGFloat = 0
    
    var body: some View {
        GeometryReader { geometry in
            VStack(spacing: 0) {
                self.indicator.padding()
                self.content
            }
            .frame(width: geometry.size.width, height: self.maxHeight, alignment: .top)
            .background(Color(.secondarySystemBackground))
            .cornerRadius(Constants.radius)
            .frame(height: geometry.size.height, alignment: .bottom)
            .offset(y: max(self.offset + self.translation, 0))
            .animation(.interactiveSpring(), value: isOpen)
            .animation(.interactiveSpring(), value: translation)
            .gesture(
                DragGesture().updating(self.$translation) { value, state, _ in
                    state = value.translation.height
                }.onEnded { value in
                    let snapDistance = self.maxHeight * Constants.snapRatio
                    guard abs(value.translation.height) > snapDistance else {
                        return
                    }
                    self.isOpen = value.translation.height < 0
                }
            )
        }
    }
    

In the code sample above, we attach the drag gesture to the view and modify
its state as soon as it ends. Besides that, we update the gesture state to
make it interactive. The main benefit of _@GestureState_ is its behavior.
SwiftUI resets the value of the _@GestureState_ to its initial value as soon
as gesture ends. We use the value of _@GestureState_ by adding it to the
offset, which allows us to drive our view interactively.

> To learn more about _gestures_ and _@GestureState_ take a look at [
> “Gestures in SwiftUI” ](/2019/07/10/gestures-in-swiftui/) post.

Let’s finally use our bottom sheet to check how it works.

    
    
    struct ContentView: View {
        @State private var bottomSheetShown = false
    
        var body: some View {
            GeometryReader { geometry in
                Color.green
                BottomSheetView(
                    isOpen: self.$bottomSheetShown,
                    maxHeight: geometry.size.height * 0.7
                ) {
                    Color.blue
                }
            }.edgesIgnoringSafeArea(.all)
        }
    }
    

![bottom-sheet](/public/bottom-sheet.png)

> Full source code available [ here
> ](https://gist.github.com/mecid/78eab34d05498d6c60ae0f162bfd81ee)

####  Conclusion

Today we learned how we could build a draggable bottom sheet component, which
Apple uses a lot in its apps. Building interactive components is really
straightforward in SwiftUI. All you need to do is defining the state and the
gesture which modifies the state. SwiftUI animates all the transitions between
state changes for free for you. I hope you enjoy the post. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Getting started with CloudKit

##  Getting started with CloudKit

22 Mar 2022

CloudKit is an easy way to store data in the cloud, sync between multiple
devices, and share it between the app’s users. This week we will learn how to
start using CloudKit in the app to save and fetch data from the cloud and sync
between multiple user devices.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

First, to start using CloudKit in the app, we need to enable it in the project
Signing and Capabilities section. Here we can create a default container for
the app. A container is a space in the cloud that stores all of your saved
data. You can use a container per application or a single container to share
data between multiple apps.

Every container has a public, private and shared database. The public database
is accessible for any user of the app. Every user of the app has a private
database that lives in the personal iCloud and counts towards iCloud storage.
You can use the shared database to fetch data shared with the user.

    
    
    import CloudKit
    import os
    
    final class CloudKitService {
        private static let logger = Logger(
            subsystem: "com.aaplab.fastbot",
            category: String(describing: CloudKitService.self)
        )
    
        func checkAccountStatus() async throws -> CKAccountStatus {
            try await CKContainer.default().accountStatus()
        }
    }
    
    @MainActor final class OnboardingViewModel: ObservableObject {
        private static let logger = Logger(
            subsystem: "com.aaplab.fastbot",
            category: String(describing: OnboardingViewModel.self)
        )
    
        @Published private(set) var accountStatus: CKAccountStatus = .couldNotDetermine
    
        private let cloudKitService = CloudKitService()
    
        func fetchAccountStatus() async {
            do {
                accountStatus = try await cloudKitService.checkAccountStatus()
            } catch {
                Self.logger.error("\(error.localizedDescription, privacy: .public)")
            }
        }
    }
    

Before saving or fetching data from the CloudKit, we should check if the user
has logged in an Apple ID and enabled iCloud Drive in the settings.

    
    
    import SwiftUI
    
    struct OnboardingView: View {
        @StateObject private var viewModel = OnboardingViewModel()
        @State private var accountStatusAlertShown = false
        @Environment(\.dismiss) var dismiss
    
        var body: some View {
            Button("startUsingApp") {
                if viewModel.accountStatus != .available {
                    accountStatusAlertShown = true
                } else {
                    dismiss()
                }
            }
            .alert("iCloudAccountDisabled", isPresented: $accountStatusAlertShown) {
                Button("cancel", role: .cancel, action: {})
            }
            .task {
                await viewModel.fetchAccountStatus()
            }
        }
    }
    

####  Saving data

We need to define a schema for record types we want to store on CloudKit. Go
to the Signing and Capabilities tab on the project settings page and press the
CloudKit Console button. It should open the browser with CloudKit dashboard,
where you can find schema setup in the navigation menu. Press the record types
button, and create a new one that we want to store and fetch.

    
    
    struct Fasting: Hashable {
        var start: Date
        var end: Date
        var goal: TimeInterval
    }
    
    enum FastingRecordKeys: String {
        case type = "Fasting"
        case start
        case end
        case goal
    }
    
    extension Fasting {
        var record: CKRecord {
            let record = CKRecord(recordType: FastingRecordKeys.type.rawValue)
            record[FastingRecordKeys.goal.rawValue] = goal
            record[FastingRecordKeys.start.rawValue] = start
            record[FastingRecordKeys.end.rawValue] = end
            return record
        }
    }
    

In the example above, you see the simple _Fasting_ value type that I want to
store on CloudKit. CloudKit provides us _CKRecord_ type representing items in
the CloudKit database. Usually, we need to implement a converter from/to
_CKRecord_ for our custom types.

    
    
    extension CloudKitService {
        func save(_ record: CKRecord) async throws {
            try await CKContainer.default().privateCloudDatabase.save(record)
        }
    }
    

And now, we can finally create a form to populate fasting record data and save
it to the private database of the current user on CloudKit.

    
    
    @MainActor final class NewFastingViewModel: ObservableObject {
        private static let logger = Logger(
            subsystem: "com.aaplab.fastbot",
            category: String(describing: NewFastingViewModel.self)
        )
    
        @Published var fasting: Fasting = .init(
            start: .now,
            end: .now,
            goal: 16 * 3600
        )
        @Published private(set) var isSaving = false
    
        private let cloudKitService = CloudKitService()
    
        func save() async {
            isSaving = true
    
            do {
                try await cloudKitService.save(fasting.record)
            } catch {
                Self.logger.error("\(error.localizedDescription, privacy: .public)")
            }
    
            isSaving = false
        }
    }
    
    struct NewFastingRecord: View {
        @StateObject private var viewModel = NewFastingViewModel()
        @Environment(\.dismiss) var dismiss
    
        var body: some View {
            Form {
                Section {
                    DatePicker("start", selection: $viewModel.fasting.start)
                    DatePicker("end", selection: $viewModel.fasting.end)
                }
    
                Section {
                    Picker("goal", selection: $viewModel.fasting.goal) {
                        ForEach([16, 18, 23], id: \.self) { hours in
                            Text(String(hours))
                                .tag(hours * 3600)
                        }
                    }
                }
            }
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button("save") {
                        Task {
                            await viewModel.save()
                            dismiss()
                        }
                    }.disabled(viewModel.isSaving)
                }
            }
            .navigationTitle("newFasting")
        }
    }
    

####  Fetching data

Now we can learn how to fetch data from the CloudKit. First, we should update
our schema by adding indexes marking fields in our records queryable and
sortable. Let’s open the CloudKit dashboard and go to Schema -> Indexes. Here
we should create indexes for all the fields we want to fetch or sort.

    
    
    extension Fasting {
        init?(from record: CKRecord) {
            guard
                let start = record[FastingRecordKeys.start.rawValue] as? Date,
                let end = record[FastingRecordKeys.end.rawValue] as? Date,
                let goal = record[FastingRecordKeys.goal.rawValue] as? TimeInterval
            else { return nil }
            self = .init(start: start, end: end, goal: goal)
        }
    }
    

In the example above, we implemented another converter from an instance of the
_CKRecord_ type. Let’s move forward and implement a method on the
_CloudKitService_ type to fetch the records in the provided date interval.

    
    
    extension CloudKitService {
        func fetchFastingRecords(in interval: DateInterval) async throws -> [Fasting] {
            let predicate = NSPredicate(
                format: "\(FastingRecordKeys.start.rawValue) >= %@ AND \(FastingRecordKeys.end.rawValue) <= %@",
                interval.start as NSDate,
                interval.end as NSDate
            )
    
            let query = CKQuery(
                recordType: FastingRecordKeys.type.rawValue,
                predicate: predicate
            )
    
            query.sortDescriptors = [.init(key: FastingRecordKeys.end.rawValue, ascending: true)]
    
            let result = try await CKContainer.default().privateCloudDatabase.records(matching: query)
            let records = result.matchResults.compactMap { try? $0.1.get() }
            return records.compactMap(Fasting.init)
        }
    }
    

And now we are ready to implement a view showing the fasting history.

    
    
    @MainActor final class FastingHistoryViewModel: ObservableObject {
        private static let logger = Logger(
            subsystem: "com.aaplab.fastbot",
            category: String(describing: FastingHistoryViewModel.self)
        )
    
        @Published var interval: DateInterval = .init(
            start: .now.addingTimeInterval(-30 * 34 * 3600),
            end: .now
        )
    
        @Published private(set) var history: [Fasting] = []
        @Published private(set) var isLoading = false
    
        private let cloudKitService = CloudKitService()
    
        func fetch() async {
            isLoading = true
    
            do {
                history = try await cloudKitService.fetchFastingRecords(in: interval)
            } catch {
                Self.logger.error("\(error.localizedDescription, privacy: .public)")
            }
    
            isLoading = false
        }
    }
    
    struct FastingHistoryView: View {
        @StateObject private var viewModel = FastingHistoryViewModel()
    
        var body: some View {
            List(viewModel.history, id: \.self) { fasting in
                VStack(alignment: .leading) {
                    Text(fasting.start, style: .time)
                    Text(fasting.end, style: .time)
                }
            }
            .redacted(reason: viewModel.isLoading ? .placeholder : [])
            .refreshable {
                await viewModel.fetch()
            }
            .task {
                await viewModel.fetch()
            }
        }
    }
    

####  Conclusion

CloudKit provides us with development and production environments. While
developing an app and running it in the debug mode, you automatically use the
development environment. Before publishing the app on TestFlight or App Store,
you should deploy schema to the production environment in the CloudKit
dashboard.

This week we learned the basics of storing and fetching data in the CloudKit.
Now you know how to sync the data between the user devices. Next week we will
learn how to implement [ data sharing between app users via CloudKit
](/2022/03/29/zone-sharing-in-cloudkit/) . I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Localization in SwiftUI

##  Localization in SwiftUI

16 Oct 2019

This week I want to talk about another crucial feature of any app, which is
_Localization_ . Every user expects that your app correctly uses environment
features like the right-to-left layout or uses system locale to format dates
or currencies. Another vital thing here is translations, and this week, we
will learn which tools SwiftUI provides to add in our apps as many languages
as we can.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  LocalizedStringKey

_LocalizedStringKey_ is a special struct which is provided by the SwiftUI
framework. It conforms _ExpressibleByStringLiteral_ protocol, which allows us
to create this struct by using a _String_ value. _Text_ component, on the
other hand, has an overload that accepts _LocalizedStringKey_ instead of
_String_ . It allows us to use our localization keys in a very transparent
way. Let’s take a look at a quick example.

    
    
    let goal: LocalizedStringKey = "goal"
    let text = Text(goal)
    

_LocalizedStringKey_ looks for a _“goal”_ key in translation files, and as
soon as it finds provided translation for a key _“goal”_ it will replace the
key with a correct translated string. In the case where there is no provided
translation, it will use the key as a dummy string value.

To learn how to create translation files, take a look at the [
“Internationalization and Localization”
](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/LocalizingYourApp/LocalizingYourApp.html#//apple_ref/doc/uid/10000171i-CH5-SW1)
guide provided by Apple.

####  String interpolation

We already know how to localize static text in our apps. But what about the
dynamic text, where we need to inject some data like names or some numeric
values. Fortunately, _LocalizedStringKey_ conforms
_ExpressibleByStringInterpolation_ protocol, which allows us to use _String_
interpolation to pass data into our string values. Let’s take a look at a
small example.

    
    
    let name = "Majid"
    Text("myNameIs \(name)")
    

In the example above, we create a _Text_ component with the _“myNameIs
(name)”_ string value. As you already know, the Text component has an init
method overload, which accepts _LocalizedStringKey_ and _LocalizedStringKey_
conforms _ExpressibleByStringInterpolation_ , and **this is all the magic
behind the localization in SwiftUI** . This piece of code will look for the
_“myNameIs %@”_ key in your translation files. Let’s take a look at how our
translation file should look to make it work.

    
    
    "myNameIs %@" = "My name is %@.";
    

**I have to mention that it doesn’t work in preview canvas. You should run it
on simulator.**

_String_ interpolation is a compelling feature of Swift language. By using
_String_ interpolation, we can also pass stuff like formatters or format
specifiers, which can provide additional presentation logic. Let’s take a look
at a few code examples.

    
    
    let date = Date()
    let formatter = DateFormatter()
    formatter.dateStyle = .medium
    formatter.timeStyle = .none
    Text("birthday \(date, formatter: formatter)")
    

In the code sample above, we pass a _DateFormatter_ , which converts a _Date_
representation into a proper localized string value. This code will run a
localized string lookup and then apply the formatter. Here is how the
translation file should look.

    
    
    "birthday %@" = "My birthday is %@.";
    

Let’s take a look at another quick sample where we inject integer into our
translation.

    
    
    let age = 28
    Text("age \(age)")
    
    "age %lld" = "I'm %lld years old";
    

####  Conclusion

Localization is an essential aspect in the world of user experience. Today we
learned how easily we could localize our apps with the help of
_LocalizedStringKey_ struct provided by SwiftUI. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Managing safe area in SwiftUI

##  Managing safe area in SwiftUI

03 Nov 2021

A safe area defines the area within a view that isn’t covered by a navigation
bar, tab bar, toolbar, or other views. SwiftUI views respect safe areas out of
the box. But there are plenty of situations when you need to customize this
behavior. This week we will learn how to manage the safe area in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Safe areas help us to keep our views inside the visible parts of the screen.
For example, we can easily place our views between the navigation bar and home
indicator using a safe area.

![safe-area](/public/safearea10.png)

By default, SwiftUI place views only inside the safe area. Here is the example
showing that.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationView {
                ZStack {
                    LinearGradient(
                        colors: [.red, .yellow],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                    .navigationTitle("Hello World")
                }
            }
        }
    }
    

![safe-area](/public/safearea1.png)

But we can change this behavior using the _ignoresSafeArea_ view modifier.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationView {
                ZStack {
                    LinearGradient(
                        colors: [.red, .yellow],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                    .ignoresSafeArea()
                    .navigationTitle("Hello World")
                }
            }
        }
    }
    

![safe-area](/public/safearea2.png)

The _ignoresSafeArea_ view modifier expands the view and fills the space by
ignoring the safe area. The _ignoresSafeArea_ view modifier has two parameters
that allow us to set the direction and the region of the ignored safe area.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationView {
                ZStack {
                    LinearGradient(
                        colors: [.red, .yellow],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                    .ignoresSafeArea(.keyboard, edges: .bottom)
                    .ignoresSafeArea(.container, edges: [.top, .horizontal])
                    .navigationTitle("Hello World")
                }
            }
        }
    }
    

Let’s take a deep look at the possible parameters of the _ignoresSafeArea_
view modifier.

  1. The _regions_ parameter allows us to set the ignored safe area type. For example, it might be a parent container, keyboard, or all of them. 
  2. The _edges_ parameter allows us to ignore the safe area in the following direction or set of directions. For example, it could be _top, leading, bottom, trailing, horizontal, vertical, all_ , or any combination of previous options. 

####  safeAreaInset view modifier

The _safeAreaInset_ view modifier is another way to manage the safe area of
the view. The _safeAreaInset_ view modifier allows you to shift the safe area
of the view by placing another view inside the original safe area of the view.

    
    
    struct ContentView: View {
        var body: some View {
            NavigationView {
                LinearGradient(
                    colors: [.red, .yellow],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                .navigationTitle("Hello World")
                .safeAreaInset(edge: .bottom, alignment: .center, spacing: 0) {
                    Color.clear
                        .frame(height: 20)
                        .background(Material.bar)
                }
            }
        }
    }
    

![safe-area](/public/safearea3.png)

As you can see in the example above, the _safeAreaInset_ view modifier has a
bunch of parameters that allow us to control the spacing, alignment, and edge
of the shifted safe area. It also uses the _@ViewBuilder_ closure to build the
content of view that SwiftUI places in the space of the shifted safe area.

  1. _edge_ parameter allows you to set the vertical or horizontal edge of the shifted safe area region. 
  2. _spacing_ parameter allows you to put some space between the shifted safe area and the view itself. 
  3. _alignment_ parameter applies the horizontal or vertical alignment. 
  4. _content_ is the _@ViewBuilder_ closure that defines the content of the shifted safe area. 

> To learn more about materials in SwiftUI, take a look at my dedicated [
> “Blur effect and materials in SwiftUI” ](/2021/10/28/blur-effect-and-
> materials-in-swiftui/) post.

####  Conclusion

Today we learned how to manage the safe area in SwiftUI. Usually, we don’t
need it because SwiftUI handles it automatically. But feel free to customize
the look and feel of your content with an immersive experience using safe area
view modifiers. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# The power of accessibilityRepresentation view modifier in SwiftUI

##  The power of accessibilityRepresentation view modifier in SwiftUI

01 Sep 2021

The SwiftUI Release 3 has a lot of improvements in the area of accessibility.
It provides all the missing APIs like accessibility rotors, but it also gives
us new ways of doing complex things efficiently. This week we will talk about
the _accessibilityRepresentation_ view modifier that allows us to replace
accessibility elements of one view with another.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Assume we are working on a super custom checkmark button that toggles its
state only after a long press. Let’s take a look at the code we could write to
implement this view.

    
    
    import SwiftUI
    
    struct LongPressCheckmark: View {
        @Binding var isSelected: Bool
    
        var body: some View {
            Image(systemName: isSelected ? "checkmark.rectangle" : "rectangle")
                .onLongPressGesture { isSelected.toggle() }
        }
    }
    

The code above looks simple. We have a binding to a boolean value indicating
the selection of the checkmark. We also have an image presenting a checkmark
or empty rectangle depending on the value of the binding. I added a long-press
gesture to the image that toggles the boolean binding.

The main downside of the code above is the accessibility support. VoiceOver
recognizes the image and doesn’t provide information about the selection
state, possible actions, etc. We can improve the accessibility support
manually by using the set of provided accessibility view modifiers in SwiftUI.

    
    
    import SwiftUI
    
    struct LongPressCheckmark: View {
        @Binding var isSelected: Bool
    
        var body: some View {
            Image(systemName: isSelected ? "checkmark.rectangle" : "rectangle")
                .onLongPressGesture { isSelected.toggle() }
                .accessibilityRemoveTraits(.isImage)
                .accessibilityAddTraits(.isButton)
                .accessibilityAddTraits(isSelected ? .isSelected : [])
                .accessibilityLabel(Text("Checkmark"))
                .accessibilityHint("You can toggle the checkmark")
                .accessibilityAction { isSelected.toggle() }
        }
    }
    

> To learn about the basics of accessibility in SwiftUI, take a look at my [
> “Accessibility in SwiftUI” ](/2019/09/10/accessibility-in-swiftui/) post.

Here we add accessibility modifiers to provide information about the current
state of the checkmark, an accessibility action to toggle the state, and the
accessibility label with the hint. We have much more accessibility-related
lines of code than button logic. Fortunately, SwiftUI provides us a way to
simplify the code above by using the _accessibilityRepresentation_ view
modifier.

    
    
    import SwiftUI
    
    struct LongPressCheckmark: View {
        @Binding var isSelected: Bool
    
        var body: some View {
            Image(systemName: isSelected ? "checkmark.rectangle" : "rectangle")
                .onLongPressGesture { isSelected.toggle() }
                .accessibilityRepresentation {
                    Toggle(isOn: $isSelected) {
                        Text("Checkmark")
                    }
                }
        }
    }
    

As you can see, we replace all the accessibility-related lines of code with
the single _accessibilityRepresentation_ view modifier.
_accessibilityRepresentation_ view modifier replaces the accessibility element
of the current view with the accessibility information of the view you provide
in the closure. SwiftUI doesn’t render the view you provide in the closure.
SwiftUI uses it only for generating accessibility information.

Whenever you build a custom view that has logic similar to the view in
SwiftUI, you can use the _accessibilityRepresentation_ view modifier to
generate accessibility behavior for your custom view automatically from that
SwiftUI view.

In the previous example, we used the standard _Toggle_ to extract its
accessibility information. I should mention that the
_accessibilityRepresentation_ view modifier works both with plain views and
complex view hierarchies. In the following example, we will build a custom bar
chart view.

    
    
    struct Bar: Identifiable {
        let id: UUID
        let value: Double
        let label: String
    }
    
    struct BarChartView: View {
        let bars: [Bar]
    
        var body: some View {
            Canvas {
                // custom drawing here
            }.accessibilityRepresentation {
                HStack {
                    ForEach(bars) { bar in
                        Rectangle()
                            .accessibilityLabel(bar.label)
                            .accessibilityValue("\(bar.value)")
                    }
                }
            }
        }
    }
    

Here we use the new _Canvas_ view for custom drawing. _Canvas_ view doesn’t
support accessibility out of the box. Fortunately, we can use the
_accessibilityRepresentation_ view modifier to generate the accessibility
information for our chart from the view hierarchy with _HStack_ .

The new _accessibilityRepresentation_ view modifier drastically simplifies the
accessibility support for custom views. Remember that accessibility isn’t a
feature or a “nice to have”. It’s a necessity. So let’s make your app
accessible for everyone. I hope you enjoy the post. Feel free to follow me on
[ Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Writing idiomatic Swift code

##  Writing idiomatic Swift code

01 Apr 2021

Today is a great day to start learning iOS development. iOS development
evolves every year and brings us new things to learn. This post should be
valuable for the people who move to Swift from another programming language.
This week we will talk about Swift idioms and how to write idiomatic Swift
code.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Swift language encourages you to write safe, fast, and expressive code. It
provides you all the needed programming language features to allow you to
write safe and bug-free code.

####  Reference and Value types

Swift language provides you reference and value types. Reference types are
classes and closures. Classes are fundamental building blocks in Object-
Oriented Programming. Value types are structs and enums. The main difference
between them is the lifecycle. Swift copies value for value types when you
pass it around. On the other hand, Swift copies reference for reference types
when you pass them.

What does it mean for us? Classes allow us to share mutable states by sharing
a reference to the data. For example, if you need to have a piece of data
shared between different components and every component should have an
opportunity to mutate the shared state, class is a way to go. For all other
cases, value types are what you need.

    
    
    class SharedState {
        var a: Int = 0
    
        func increment() {
            a += 1
        }
    }
    
    func foo(reference: SharedState) {
        reference.increment()
    }
    
    var reference = SharedState()
    print(reference.a)
    foo(reference: reference)
    print(reference.a)
    

Here we have a class called _SharedState_ , and we pass it inside a function
and mutate it, then we print it outside the function. We model _SharedState_
as a class because we need a shared state that we can mutate. We can’t do the
same with structs because value types encourage immutability.

####  Enums

Enum is a great way to model an exclusive piece of state. I love enums, and it
is one of my favorite Swift language features that allow us to build a very
type-safe code. Let’s take a look at the example that defines possible sorting
options in my app.

    
    
    enum Sorting {
        case price
        case reviews
        case date
    }
    
    let sorting: Sorting = .price
    
    switch sorting {
    case .price: print("price")
    case .date: print("date")
    case .reviews: print("reviews")
    }
    
    if sorting == .date {
        print("date")
    }
    

Enums are great and even more powerful with associated values for particular
cases.

    
    
    enum Action {
        case updateTimeline
        case sharePost(String)
        case deletePost(UUID)
    }
    
    let action: Action = .updateTimeline
    
    switch action {
    case .updateTimeline:
        print("update timeline...")
    case let .deletePost(id):
        print("deleting post: \(id)")
    case let .sharePost(content):
        print("sharing post with text: \(content)")
    }
    

Now we can use the **switch** with **case let** to extract the associated
values for every case. But remember that we should use enums for mutually
exclusive cases. You can always use structs with static fields for inclusive
cases.

    
    
    // Bad
    enum Regex {
        case email
        case username
        case other(String)
    }
    
    // Good
    struct Regex {
        let pattern: String
    
        static let email = Regex(pattern: "regex for email")
        static let username = Regex(pattern: "regex for username")
    }
    
    let other = Regex(pattern: "another regex")
    

####  Optionals

Another language feature that Swift provides us to write type-safe code is
optionals. Swift types can’t be _nil_ unless you define them as optional. In
this case, the Swift compiler will require to handle all the usages where the
value can be _nil_ .

    
    
    let nonOptionalInteger: Int = 3
    let optionalInteger: Int? = 3
    
    func print(integer: Int) {
        print(integer)
    }
    
    print(integer: optionalInteger ?? 0)
    
    if let value = optionalInteger {
        print(integer: value)
    }
    
    // Compiler error
    // Value of optional type 'Int?' must be unwrapped to a value of type 'Int'
    print(integer: optionalInteger)
    

As you can see, we have to use **?** after the type name in case of optionals.
We can use **??** operator to provide a default value whenever value is not
available, or we can use **if let** expression to extract the optional value
and use it inside the inner scope.

####  Conclusion

Swift programming language evolves very fast. The core team is constantly
considering the feedback that developers provide and add new features to the
Swift language. To write more idiomatic code, you should also learn about
pattern matching, protocols, generics, and functional programming in Swift. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!

  1. [ Using protocols as composable extensions ](/2019/01/17/using-protocols-as-composable-extensions/)
  2. [ Phantom types in Swift ](/2021/02/18/phantom-types-in-swift/)
  3. [ Pattern Matching with case let ](/2019/02/06/pattern-matching-with-case-let/)
  4. [ Building networking layer using functions ](/2020/01/08/building-networking-layer-using-functions/)



# Customizing view content shape in SwiftUI

##  Customizing view content shape in SwiftUI

03 Dec 2021

Usually, SwiftUI uses rectangles to render views, but we can control the shape
of the view by using the _clipShape_ view modifier. This week we will learn
how to modify the interactable shape of the view during hit-testing or
previewing drag and drop by using the brand new _contentShape_ view modifier.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start with a simple view that displays text and an image in a vertical
stack.

    
    
    struct ContentView: View {
        var body: some View {
            VStack {
                Image(systemName: "star")
                Text("Hello World!")
            }
        }
    }
    

Now, we want to make this view tappable and provide the hover effect for the
iPadOS pointer.

> To learn more about implementing the hover effect on iPadOS, take a look at
> my dedicated [ “Hover effect in SwiftUI” ](/2020/03/25/hover-effect-in-
> swiftui/) post.
    
    
    struct ContentView: View {
        var body: some View {
            VStack {
                Image(systemName: "star")
                Text("Hello World!")
            }
            .hoverEffect()
            .onTapGesture {
                print("Super star!")
            }
        }
    }
    

Finally, we can customize the shape of the hover effect by using the
_contentShape_ view modifier.

    
    
    struct ContentView: View {
        var body: some View {
            VStack {
                Image(systemName: "star")
                Text("Hello World!")
            }
            .contentShape(.hoverEffect, Circle())
            .hoverEffect()
            .onTapGesture {
                print("Super star!")
            }
        }
    }
    

The _contentShape_ view modifier changes the shape of the view used for a
particular interaction. We change the content shape only for the hover effect
in our example. But we can do it for different types of interactions, like
drag and drop previews, hit-testing, context menu previews, and hover effect.

The _contentShape_ view modifier accepts the instance of the
_ContentShapeKinds_ option set that defines interactions on a view. SwiftUI
provides us these options to use:

  1. _interaction_ \- this one offers a shape for hit-testing. 
  2. _dragPreview_ \- this type provides an outline for drag and drop previews. 
  3. _contextMenuPreview_ \- this type provides a shape for rendering context menu previews. 
  4. _hoverEffect_ \- this type provides a shape for a hover effect on iPadOS. 

_ContentShapeKinds_ struct conforms to _OptionSet_ protocol which means you
can combine different options together.

    
    
    struct ContentView: View {
        var body: some View {
            VStack {
                Image(systemName: "star")
                Text("Hello World!")
            }
            .contentShape([.hoverEffect, .dragPreview], Circle())
            .hoverEffect()
            .onTapGesture {
                print("Super star!")
            }
        }
    }
    

> If you are not familiar with _OptionSet_ protocol, take a look at my [
> “Inclusive enums with OptionSet” ](/2019/04/10/inclusive-enums-with-
> optionset/) post.

Remember that the _contentShape_ view modifier affects only the interactable
shape of the view. If you need to change the shape while rendering, you should
use the _clipShape_ view modifier.

> To learn more about clipping and masking in SwiftUI, take a look at my [
> “Customizing the shape of views in SwiftUI” ](/2020/02/12/customizing-the-
> shape-of-views-in-swiftui/) post.
    
    
    struct Triangle: Shape {
        func path(in rect: CGRect) -> Path {
            var path = Path()
    
            path.move(to: CGPoint(x: rect.minX, y: rect.maxY))
            path.addLine(to: CGPoint(x: rect.midX, y: rect.minY))
            path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
            path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
    
            return path
        }
    }
    
    struct ContentView: View {
        var body: some View {
            VStack {
                Image(systemName: "star")
                Text("Hello World!")
            }
            .contentShape(.dragPreview, Triangle())
            .hoverEffect()
            .onTapGesture {
                print("Super star!")
            }
        }
    }
    

Keep in mind that you can use any shape you need. As you can see in the
example above, we use a custom shape that clips the view content to a triangle
during drag and drop.

This week we learned how to customize the shape of the view during
interactions via the brand new _contentShape_ view modifier. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading, and see you next
week!



# Mastering MapKit in SwiftUI. Basics.

##  Mastering MapKit in SwiftUI. Basics.

28 Nov 2023

MapKit integration with SwiftUI significantly changed this year. In the
previous version of SwiftUI, we had very basic functionality of _MKMapView_
wrapped into the SwiftUI view named _Map_ . Fortunately, things changed, and
SwiftUI introduced a new API for MapKit integration. This week, we will learn
how to use the new full-featured APIs available in the latest iteration of
SwiftUI to integrate with MapKit.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

As I said before, in the previous versions of the SwiftUI framework, we had a
_Map_ view providing us with basic functionality for MapKit, which is
deprecated now. Using the deprecated Map view still makes sense whenever you
target previous versions of Apple platforms.

> To learn more about the old MapKit integration with SwiftUI, take a look at
> my dedicated [ “Using MapKit with SwiftUI” ](/2020/07/29/using-mapkit-with-
> swiftui/) post.

The new MapKit API introduces the _MapContentBuilder_ result builder that
looks similar to the _ViewBuilder_ but instead uses the types conforming to
the _MapContent_ protocol. Let’s start with the basic example of using the new
MapKit APIs in SwiftUI.

    
    
    import MapKit
    import SwiftUI
    
    extension CLLocationCoordinate2D {
        static let newYork: Self = .init(
            latitude: 40.730610,
            longitude: -73.935242
        )
        
        static let seattle: Self = .init(
            latitude: 47.608013,
            longitude: -122.335167
        )
        
        static let sanFrancisco: Self = .init(
            latitude: 37.733795,
            longitude: -122.446747
        )
    }
    
    struct ContentView: View {
        var body: some View {
            Map {
                Annotation("Seattle", coordinate: .seattle) {
                    Image(systemName: "mappin")
                        .foregroundStyle(.black)
                        .padding()
                        .background(.red)
                        .clipShape(Circle())
                }
                
                Marker(coordinate: .newYork) {
                    Label("New York", systemImage: "mappin")
                }
                
                Marker("San Francisco", monogram: Text("SF"), coordinate: .sanFrancisco)
            }
        }
    }
    

As you can see in the example above, we define the map and place the content
on it by using the _MapContentBuilder_ closure. The _MapContentBuilder_ type
works with any type conforming to the _MapContent_ protocol.

![map-with-markers](/public/map3.png)

In our example, we use _Marker_ and _Annotation_ types. The _Marker_ is the
essential item that allows us to place a predefined pin on the map. The
_Annotation_ type is more advanced and will enable us to place a SwiftUI view
on the map using the latitude and longitude.

SwiftUI provides us with a bunch of types conforming to the _MapContent_
protocol. We already used two of them: _Marker_ and _Annotation_ . Many of
them include _MapCircle_ , _MapPolygon_ , _MapPolyline_ , _UserAnnotation_ ,
etc.

    
    
    struct ContentView: View {
        var body: some View {
            Map {
                Annotation("Seattle", coordinate: .seattle) {
                    Image(systemName: "mappin")
                        .foregroundStyle(.black)
                        .padding()
                        .background(.red)
                        .clipShape(Circle())
                }
                
                Marker(coordinate: .newYork) {
                    Label("New York", systemImage: "mappin")
                }
                
                UserAnnotation()
            }
        }
    }
    

You can control the initial position of the map by using another overload of
the Map initializer that provides the _initialPosition_ parameter.

    
    
    struct ContentView: View {
        let initialPosition: MapCameraPosition = .userLocation(
            fallback: .camera(
                MapCamera(centerCoordinate: .newYork, distance: 0)
            )
        )
        
        var body: some View {
            Map(initialPosition: initialPosition) {
                Annotation("Seattle", coordinate: .seattle) {
                    Image(systemName: "mappin")
                        .foregroundStyle(.black)
                        .padding()
                        .background(.red)
                        .clipShape(Circle())
                }
                
                Marker(coordinate: .newYork) {
                    Label("New York", systemImage: "mappin")
                }
                
                Marker("San Francisco", monogram: Text("SF"), coordinate: .sanFrancisco)
            }
        }
    }
    

The _initialPosition_ parameter takes an instance of the _MapCameraPosition_
type. The _MapCameraPosition_ allows us to define the map position in a few
ways. It can be the user location that we use in our example, or you can point
it to any area on the map using the _camera_ , _region_ , _rect_ , or _item_
static functions. By default, it uses the _automatic_ instance of the
_MapCameraPosition_ type that fits the map content.

Whenever you need constant control over the camera position, you can use
another overload of the _Map_ initializer, allowing you to provide two-way
binding to the map camera position.

    
    
    struct ContentView: View {
        @State private var position: MapCameraPosition = .userLocation(
            fallback: .camera(
                MapCamera(centerCoordinate: .newYork, distance: 0)
            )
        )
        
        var body: some View {
            Map(position: $position) {
                // ...
            }
        }
    }
    

SwiftUI updates the position binding once the user drags the map. It also
updates the map camera position as soon as you update the position property
programmatically.

    
    
    struct ContentView: View {
        @State private var position: MapCameraPosition = .userLocation(
            fallback: .camera(
                MapCamera(centerCoordinate: .newYork, distance: 0)
            )
        )
        
        var body: some View {
            Map(position: $position, interactionModes: .pitch) {
                // ...
            }
        }
    }
    

You can control the types of interactions allowed with the map by using the
_interactionModes_ parameters. The _MapInteractionModes_ type defines a set of
interactions like _pan_ , _pitch_ , _rotate_ and _zoom_ . By default, it
enables all the available interaction types.

Today, we learned the basics of the MapKit integration in SwiftUI. We will
continue the topic in the upcoming weeks by covering camera manipulations, map
controls, and other advanced topics. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!

  1. Mastering MapKit in SwiftUI. Basics. 
  2. [ Mastering MapKit in SwiftUI. Customizations. ](/2023/12/05/mastering-mapkit-in-swiftui-customizations/)
  3. [ Mastering MapKit in SwiftUI. Camera. ](/2023/12/12/mastering-mapkit-in-swiftui-camera/)
  4. [ Mastering MapKit in SwiftUI. Interactions. ](/2023/12/19/mastering-mapkit-in-swiftui-interactions/)



# Scoped animations in SwiftUI

##  Scoped animations in SwiftUI

21 Nov 2023

Animations were the most powerful feature of SwiftUI from day one. You can
quickly build fluid animations in SwiftUI. The only downside was how we
control animations whenever we need to run multi-step animation or scope the
animation to a particular part of the view hierarchy.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start with a simple example showing a few downsides of our old
approaches to drive animations in SwiftUI.

    
    
    struct ContentView: View {
        @State private var isHidden = false
        
        var body: some View {
            VStack {
                Button("Animate") {
                    isHidden.toggle()
                }
                
                HugeView()
                    .opacity(isHidden ? 0.0 : 1.0)
                    
                AnotherHugeView()
            }
            .animation(.default)
        }
    }
    

As you can see in the example above, we have a view hierarchy with a button
and two views placed in the vertical stack. We attach the _animation_ view
modifier to the whole stack to animate any change inside.

When we press the button, the stack animates any changes inside. Still, the
_animation_ view modifier doesn’t connect to the _isHidden_ property, which
means it will animate any change that can happen. Some of these changes can be
unexpected, like environmental value change.

We can eliminate unexpected animations by using another version of the
_animation_ view modifier where we can bind to a particular value and animate
only when the value changes.

    
    
    struct ContentView: View {
        @State private var isHidden = false
        
        var body: some View {
            VStack {
                Button("Animate") {
                    isHidden.toggle()
                }
                
                HugeView()
                    .opacity(isHidden ? 0.0 : 1.0)
                
                AnotherHugeView()
            }
            .animation(.default, value: isHidden)
        }
    }
    

In the example above, we use the _animation_ view modifier with the _value_
parameter. It allows us to scope the animation to a single value and animate
changes only correlated with the particular value. In this case, we don’t have
any unexpected animations.

What if we have more than one animatable property? We must attach an
_animation_ modifier for every animatable property in this case. This solution
works very well but has a downside on the ergonomic side.

    
    
    struct ContentView: View {
        @State private var firstStep = false
        @State private var secondStep = false
        
        var body: some View {
            VStack {
                Button("Animate") {
                    Task {
                        firstStep.toggle()
                        try? await Task.sleep(nanoseconds: 3_000_000_000)
                        secondStep.toggle()
                    }
                }
                
                // other views here
                
                SomeView()
                    .opacity(firstStep ? 1.0 : 0.0)
                    .blur(radius: secondStep ? 0 : 20.0)
            }
            .animation(.default, value: firstStep)
            .animation(.default, value: secondStep)
        }
    }
    

Fortunately, SwiftUI introduced a new variant of the _animation_ view
modifier, allowing us to scope animations using a _ViewBuilder_ closure.

    
    
    struct ContentView: View {
        @State private var firstStep = false
        @State private var secondStep = false
        
        var body: some View {
            VStack {
                Button("Animate") {
                    Task {
                        firstStep.toggle()
                        try? await Task.sleep(nanoseconds: 1_000_000_000)
                        secondStep.toggle()
                    }
                }
                
                // other views here
                
                SomeView()
                    .animation(.default) { content in
                        content
                            .opacity(firstStep ? 1.0 : 0.0)
                            .blur(radius: secondStep ? 0 : 20.0)
                    }
            }
        }
    }
    

As you can see in the example above, we use the _animation_ view modifier by
providing a type of animation we need and a _ViewBuilder_ closure where this
animation applies. The animation works only in the context of the provided
_ViewBuilder_ closure and doesn’t spread anywhere else.

As a starting point, the _ViewBuilder_ closure provides a single parameter,
the placeholder for the view where you have applied the _animation_ view
modifier. It is safe to apply any view modifiers to your view inside the
_ViewBuilder_ closure and expect animation only for this code block.

    
    
    struct ContentView: View {
        @State private var firstStep = false
        @State private var secondStep = false
        
        var body: some View {
            VStack {
                Button("Animate") {
                    Task {
                        firstStep.toggle()
                        try? await Task.sleep(nanoseconds: 1_000_000_000)
                        secondStep.toggle()
                    }
                }
                
                // other views here
                
                SomeView()
                    .transaction { t in
                        t.animation = t.animation?.speed(2)
                    } body: { content in
                        content
                            .opacity(firstStep ? 1.0 : 0.0)
                            .blur(radius: secondStep ? 0 : 20.0)
                    }
            }
        }
    }
    

As you can see, SwiftUI provides a similar way to maintain scoped transactions
in the view hierarchy.

> To learn more about transactions in SwiftUI, take a look at my dedicated [
> “Transactions in SwiftUI” ](/2020/10/07/transactions-in-swiftui/) post.

This week, we have learned about a new approach for building precise and
scoped animations in SwiftUI. Remember that it is available only on the latest
platforms and is not backward compatible. I hope you enjoy the post. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Mastering MVVM on iOS

##  Mastering MVVM on iOS

11 Jan 2018

There are a plenty of posts on the internet about app architectures in the iOS
development world. Today I will show some tips for using MVVM architecture
while developing iOS apps. I am not going to show other architectures if you
need them there is a great [ post ](https://medium.com/ios-os-x-
development/ios-architecture-patterns-ecba4c38de52) . The main problem of
Apple MVC is mixed responsibility, which leads to the appearance of some kinds
of problems such as Massive-View-Controller.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Why MVVM?

We should accept that _UIViewController_ is the main component in Apple’s iOS
SDK and all the actions are started and built across this entity. Despite the
name, it is more view than a classic Controller (or Presenter) from MVC(or
MVP), because of callbacks like _viewDidLoad_ , _viewWillLayoutSubviews_ , and
other view related methods. That is the reason why we should ignore the
**controller** keyword in the name and use it as View, where the role of real
controller takes the view model.

View model is the full data representation of the view. Every view should hold
only one view model instance. Generally, view model uses a manager to fetch
data and transforms it into necessary format. Let’s dive into examples:

    
    
    import Foundation
    
    class ItemsViewModel {
        var items: [Item] = []
        var error: Error?
        var refreshing = false
        
        private let dataManager: DataManager
        init(dataManager: DataManager) {
            self.dataManager = dataManager
        }
        
        func fetch(completion: @escaping () -> Void) {
            refreshing = true
            dataManager.fetchItems { [weak self] (items, error) in
                self?.items = items ?? []
                self?.error = error
                self?.refreshing = false
                completion()
            }
        }
    }
    

Here we have view model that fetches items via _DataManager_ and holds it
inside some variable. It also holds an error and refreshing state, which
brings opportunity to build UI with all required conditions.

    
    
    import UIKit
    
    class ItemsViewController: UIViewController {
        @IBOutlet private weak var tableView: UITableView!
        private var viewModel: ItemsViewModel
        
        init(viewModel: ItemsViewModel) {
            self.viewModel = viewModel
            super.init(nibName: nil, bundle: nil)
        }
        
        override func viewDidLoad() {
            super.viewDidLoad()
            
            viewModel.fetch { [weak self] in
                self?.tableView.reloadData()
            }
        }
    }
    
    extension ItemsViewController: UITableViewDataSource {
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return viewModel.items.count
        }
    }
    

As you can see above we have _ItemsViewController_ that represents a list of
items in _UITableView_ . It holds view model instance and asks it to fetch
data in the _viewDidLoad_ callback. We are also passing closure, which reloads
_UITableView_ as soon as the data is fetched. _UITableViewDataSource_ methods
also use the view model to get the count of cells.

####  Reactive Bindings

Bindings between view and view model is the main idea of MVVM architecture,
where developers can work on view model code and designers can work on view in
Interface Designer. In the first example, we used closures, because there is
no binding ability in iOS SDK out of the box. In real life applications, you
can use some of popular FRP extensions, like ReactiveCocoa, RxSwift or Bond. I
prefer Bond library for its simplicity.

    
    
    import Bond
    
    class ItemsViewModel {
        let items = Observable<[Item]>([])
        let error = Observable<Error?>(nil)
        let refreshing = Observable<Bool>(false)
        
        private let dataManager: DataManager
        init(dataManager: DataManager) {
            self.dataManager = dataManager
        }
        
        func fetch() {
            refreshing.value = false
            dataManager.fetchItems { [weak self] (items, error) in
                self?.items.value = items ?? []
                self?.error.value = error
                self?.refreshing.value = false
            }
        }
    }
    

This is the same _ItemsViewModel_ , but now we use reactive programming to
observe changes.

    
    
    class ItemsViewController: UIViewController {
        @IBOutlet private weak var tableView: UITableView!
        private let activityIndicator = ActivityIndicatorView()
        private var viewModel: ItemsViewModel
        
        init(viewModel: ItemsViewModel) {
            self.viewModel = viewModel
            super.init(nibName: nil, bundle: nil)
        }
        
        override func viewDidLoad() {
            super.viewDidLoad()
            setupUI()
            bindViewModel()
            viewModel.fetch()
        }
        
        func bindViewModel() {
            viewModel.refreshing.bind(to: activityIndicator.reactive.isAnimating)
            viewModel.items.bind(to: self) { strongSelf, _ in
                strongSelf.tableView.reloadData()
            }
        }
        
        func setupUI() {
            view.addSubview(activityIndicator)
        }
    }
    
    extension ItemsViewController: UITableViewDataSource {
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return viewModel.items.value.count
        }
    }
    

Let’s look at _bindViewModel_ method, here we bind view model to view.
Whenever refreshing value changes it sets activityIndicator’s _isAnimating_
property. Or when items are changed, _UITableView_ reloads. As you can see,
reactive bindings simplify code in most cases.

####  ViewModel Composition

Sometimes we have complex views with multiple data sources. For example,
Instagram user profile where we have some information about the user and all
photos related to this user. Good job here is separating this logic into two
or more view models. But we have a rule: every view should have only one view
model. In this case, the best option is using view model composition. Let’s
look at examples:

    
    
    import Bond
    import ReactiveKit
    
    class UserProfileViewModel {
        let refreshing = Observable<Bool>(false)
        let username = Observable<String>("")
        let photos = Observable<[Photos]>([])
        
        private let userViewModel: UserViewModel
        private let photosViewModel: PhotosViewModel
        
        init(userManager: UserManager, photoManager: PhotoManager) {
            userViewModel = UserViewModel(manager: userManager)
            photosViewModel = PhotosViewModel(manager: photoManager)
            
            userViewModel.username.bind(to: username)
            photosViewModel.photos.bind(to: photos)
            combineLatest(userViewModel.refreshing, photosViewModel.refreshing)
                .map { $0 || $1 }
                .bind(to: refreshing)
        }
        
        func fetch() {
            userViewModel.fetch()
            photosViewModel.fetch()
        }
    }
    
    class UserViewModel {
        let refreshing = Observable<Bool>(false)
        let username = Observable<String>("")
        
        func fetch() {
            refreshing.value = true
            manager.fetch(user: id) { [weak self] (user, error) in
                self?.username.value = "@" + user.username
                self?.refreshing.value = false
            }
        }
    }
    
    class PhotosViewModel {
        let refreshing = Observable<Bool>(false)
        let photos = Observable<[Photo]>([])
        
        func fetch() {
            refreshing.value = true
            manager.fetch(for user: id) { [weak self] (photos, error) in
                self?.photos.value = photos ?? []
                self?.refreshing.value = false
            }
        }
    }
    

As you can see, we have _UserProfileViewModel_ which holds two another view
models and collects data from them. We also have the refreshing state which
combines two refreshing states of internal view models. The second important
point on line 36, where view model formats data into the required form. View
just has to bind components to view model and show data as is.

####  Conclusion

View model is really nice and simple way of separating presentation logic into
another entity, which helps us to avoid Massive-View-Controller and keep
things easier to control and covered with Unit Tests. That is where we go,
simple and testable architecture.



# Mastering charts in SwiftUI. Accessibility.

##  Mastering charts in SwiftUI. Accessibility.

28 Feb 2023

The last but not least post in the series is about accessibility. It is
essential to make your app accessible to VoiceOver users. Usually, it is much
harder to make your visual content accessible. Fortunately, Apple provides
audio graph features allowing us to make any chart representable with sound.
This week we will learn how to improve the accessibility of our graphs using
the Swift Charts framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

First of all, I should mention that the Swift Charts framework understands
your data and build an accessibility tree for your chart automatically for
free. You don’t need to do any specific steps to make your chart accessible
with the Swift Charts framework.

> To learn more about the basics of the Charts framework, take a look at my
> dedicated [ “Mastering charts in SwiftUI. Basics.” ](/2023/01/10/mastering-
> charts-in-swiftui-basics/) post.

But remember that you should provide meaningful labels within instances of the
_PlottableValue_ type. The Swift Charts framework will use these labels to
provide information to your VoiceOver users. Let’s take a look at a quick
example.

    
    
    import SwiftUI
    import Charts
    
    enum Gender: String, CaseIterable {
        case male
        case female
        case notSet
    }
    
    extension Gender: Plottable {
        var primitivePlottable: String {
            rawValue
        }
    }
    
    struct Stats {
        let city: String
        let population: Int
        let gender: Gender
    }
    
    struct ContentView: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value(Text(verbatim: "City"), stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender))
                }
            }
        }
    }
    

As you can see in the example above, we use City, Population, and Gender
strings as instances of the _LocalizedStringKey_ type. Fortunately, the
_PlottableValue_ type provides a few overloads allowing us to use _String_ ,
_LocalizedStringKey_ , and _Text_ as its label.

The Swift Charts automatically group accessibility elements for the same
cities, calculate the total population per city and provide it as
accessibility value.

![chart-accessibility-tree](/public/chart16.png)

Whenever you need to provide additional information for your data point, you
can always use the _accessibilityLabel_ and _accessibilityValue_ modifiers on
your mark type.

    
    
    struct ContentView1: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats.filter { $0.gender == .female }, id: \.city) { stat in
                    BarMark(
                        x: .value(Text(verbatim: "City"), stat.city),
                        y: .value("Population", stat.population)
                    )
                    .accessibilityValue("Female population: \(stat.population)")
                }
            }
        }
    }
    

As you can see in the example above, we use the _accessibilityValue_ modifier
on the _BarMark_ type to provide meaningful information about its value.

iOS 15 and later versions have a feature called audio graphs. It allows to
represent any visual information using sounds and works excellently with
charts. Fortunately, we don’t need to do anything to support audio graphs. The
Swift Charts framework extracts valuable information from your data and builds
audio graphs automatically.

Audio graphs are available via the rotors menu. To use the rotor, rotate two
fingers on your iOS device’s screen as if you’re turning a dial. VoiceOver
will say the first rotor option. Keep rotating your fingers to hear more
options. Lift your fingers to choose audio graphs. Then flick your finger up
or down on the screen to navigate to chart details and double-tap to select
it.

![audio-graph](/public/chart17.png)

As you can see, the Swift Charts framework understands your data series,
builds summary and statistics from your data, and displays it in the audio
graph menu automatically.

Accessibility isn’t a feature or a “nice to have”. It’s a necessity. So let’s
make your app accessible for everyone. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Menus in SwiftUI

##  Menus in SwiftUI

05 Aug 2020

This week we got another Xcode Beta that brings menus into SwiftUI world.
Menus are going to replace old action sheets that have been here since iOS 8.
Action sheets don’t play well with huge screens that we have nowadays. This
week we will learn how to use menus to provide secondary actions or selection
options in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Appearance is the main problem of action sheets. An action sheet appears at
the bottom of the screen and sometimes loses the context of the action. For
example, you may press the button in the navigation bar that reveals the
action sheet at the bottom of the screen. Another problem with action sheets
is the space that it needs to display the action list. Action sheets cover the
big part of the screen, even with a small set of options.

> To learn more about action sheets, take a look at my [ “Alerts, Action
> Sheets, Modals and Popovers in SwiftUI” ](/2019/07/24/alerts-actionsheets-
> modals-and-popovers-in-swiftui/) post.

####  Disambiguation

The main reason to use brand new menus is disambiguation. It allows us to
provide additional context around your primary action. Assume that we are
working on a file manager app where the main action is creating new files or
folders. We have a button with the plus sign in the navigation bar to describe
the primary action. It might not be evident for the user what we will do here,
creating a new file or a folder? And this is a perfect use case for a menu to
solve the disambiguation. Let’s see how we can use it.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            Text("Hello World!")
                .toolbar {
                    ToolbarItem(placement: .primaryAction) {
                        Menu {
                            Button(action: {}) {
                                Label("Create a file", systemImage: "doc")
                            }
    
                            Button(action: {}) {
                                Label("Create a folder", systemImage: "folder")
                            }
                        }
                        label: {
                            Label("Add", systemImage: "plus")
                        }
                    }
                }
        }
    }
    

> To learn more about the power of toolbars in SwiftUI, take a look at my [
> “Mastering toolbars in SwiftUI” ](/2020/07/15/mastering-toolbars-in-
> swiftui/) post.

####  Selection

Another excellent use case for a menu might be a selection option. Assume that
you need to provide sorting options in the context of our file manager app.
Multiple selection options fit great into the menu world. You can use the
SwiftUI _Picker_ view to provide various options in a menu. The declarative
nature of the SwiftUI framework allows the picker to adopt the menu and
display it inline. Let’s take a look at the quick example.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var sort: Int = 0
    
        var body: some View {
            Text("Hello World!")
                .toolbar {
                    ToolbarItem(placement: .primaryAction) {
                        Menu {
                            Picker(selection: $sort, label: Text("Sorting options")) {
                                Text("Size").tag(0)
                                Text("Date").tag(1)
                                Text("Location").tag(2)
                            }
                        }
                        label: {
                            Label("Sort", systemImage: "arrow.up.arrow.down")
                        }
                    }
                }
        }
    }
    

![menu](/public/menu.png)

####  Primary action

SwiftUI allows us to set a primary action on menu which is available via
default gesture like press on iOS or mouse click on macOS. Menu content is
available via secondary gesture which is long press on iOS. Menu indicator
provides you access to secondary actions on macOS.

    
    
    struct ContentView: View {
        var body: some View {
            Menu {
                Button("Add reference") {
                    print("Add reference")
                }
                Button("Add folder") {
                    print("Add folder")
                }
            } label: {
                Label("Add", systemImage: "plus")
            } primaryAction: {
                print("Add file")
            }
        }
    }
    

####  Secondary actions

Menu is a great way to provide a bunch of secondary actions on a view in your
app. You can easily group and present actions in your menu by using sections
and dividers.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            Text("Hello World!")
                .toolbar {
                    ToolbarItem(placement: .primaryAction) {
                        Menu {
                            Section {
                                Button(action: {}) {
                                    Label("Create a file", systemImage: "doc")
                                }
    
                                Button(action: {}) {
                                    Label("Create a folder", systemImage: "folder")
                                }
                            }
    
                            Section(header: Text("Secondary actions")) {
                                Button(action: {}) {
                                    Label("Remove old files", systemImage: "trash")
                                        .foregroundColor(.red)
                                }
                            }
                        }
                        label: {
                            Label("Add", systemImage: "plus")
                        }
                    }
                }
        }
    }
    

####  Styling

SwiftUI doesn’t provide us too many customization options on a menu. But
still, it gives us the _MenuStyle_ protocol that we can use to create our
appearances. It works similarly to all style protocols that we have in
SwiftUI. We can set it via the environment to share the styling with the view
hierarchy.

    
    
    import SwiftUI
    
    struct RedMenu: MenuStyle {
        func makeBody(configuration: Configuration) -> some View {
            Menu(configuration)
                .foregroundColor(.red)
        }
    }
    
    struct ContentView: View {
        var body: some View {
            Text("Hello World!")
                .toolbar {
                    ToolbarItem(placement: .primaryAction) {
                        Menu("Add") {
                            Button("File") {}
                            Button("Folder") {}
                        }.menuStyle(RedMenu())
                    }
                }
        }
    }
    

####  Conclusion

As you can see, there are tons of possible use cases for menus. Menus will
play a significant role in a new design language that Apple prepares for us. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Mastering MapKit in SwiftUI. Camera.

##  Mastering MapKit in SwiftUI. Camera.

12 Dec 2023

In this post, we will continue the topic of the new MapKit API in SwiftUI. We
will cover one of the most critical cases of displaying a map. This week, we
will learn about camera position and map bounds.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Map bounds

The new MapKit API introduces the _MapCameraBounds_ type, allowing us to limit
the bounds of the map view. The _MapCameraBounds_ type has a few initializers
that we can use to create camera bounds from the instance of _MKMapRect_ or
_MKCoordinateRegion_ .

    
    
    extension CLLocationCoordinate2D {
        static let newYork: Self = .init(
            latitude: 40.730610,
            longitude: -73.935242
        )
    }
    
    let rect = MKMapRect(
        origin: MKMapPoint(.newYork),
        size: MKMapSize(width: 1, height: 1)
    )
    
    struct ContentView: View {
        var body: some View {
            Map(bounds: MapCameraBounds(centerCoordinateBounds: rect)) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
            }
        }
    }
    

As you can see in the example above, we use the _MKMapRect_ type to define the
visible bounds of the map that user can’t leave by using any interaction.

To create an instance of the _MKMapRect_ type, we should call the initializer
with _origin_ and _size_ parameters. We can use any instance of the
_CLLocationCoordinate2D_ type to define an origin point. The second parameter
must be an instance of the _MKMapSize_ , representing the width and height in
map points.

Now, we can use an instance of the _MKMapRect_ type to pass into the
initializer of the _MapCameraBounds_ type to limit our map to a particular
rectangle. We can also allow users to zoom in or out to a limited amount of
meters using _maximumDistance_ and _minimumDistance_ parameters of the
_MapCameraBounds_ initializer.

    
    
    struct ContentView: View {
        var body: some View {
            Map(
                bounds: MapCameraBounds(
                    centerCoordinateBounds: rect,
                    minimumDistance: 10,
                    maximumDistance: 100
                )
            ) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
            }
        }
    }
    

You may have a set of coordinates you want to zoom in and limit to the
rectangle displaying these markers. In this case, you can create an instance
of the _MKMapRect_ type per coordinate and use the _union_ function on the
_MKMapRect_ type to create a rectangle including all the coordinates.

    
    
    let coordinates: [CLLocationCoordinate2D] = [.newYork, .sanFrancisco, .seattle]
    let rect = coordinates
        .map { MKMapRect(origin: .init($0), size: .init(width: 1, height: 1)) }
        .reduce(MKMapRect.null) { $0.union($1) }
    

We discussed how to use the _MKMapRect_ in pair with the _MapCameraBounds_
type to limit our map to a particular rectangle. The _MKMapRect_ uses map
points to represent a rectangle. _MKMapPoint_ uses the 2D projection of the
map on a flat surface to calculate x and y on the map. You can use _x_ , _y_ ,
and _coordinate_ properties of the _MKMapPoint_ type to convert coordinates to
map points and back.

Whenever you want to use latitude and longitude deltas instead of map points,
you can use the _MKCoordinateRegion_ type. It provides functionality similar
to _MKMapRect_ but operates on other units.

####  Map camera position

The MapKit provides the _MapCameraPosition_ type that we can use for two-way
binding of the recently visible camera position. We can create an instance of
the _MapCameraPosition_ type by passing _MKMapRect_ , _MKCoordinateRegion_ ,
_MKMapItem_ , _CLLocationCoordinate2D_ , etc.

    
    
    struct ContentView: View {
        @State private var position: MapCameraPosition = .camera(
            .init(centerCoordinate: .newYork, distance: 0)
        )
        
        var body: some View {
            Map(
                position: $position,
                bounds: MapCameraBounds(
                    centerCoordinateBounds: rect,
                    minimumDistance: 10,
                    maximumDistance: 100
                )
            ) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
            }
            .onAppear {
                position = .camera(.init(centerCoordinate: .sf, distance: 0))
            }
        }
    }
    

We can also use the _MapCameraPosition_ type to ask for a map view to follow
the user location.

    
    
    struct ContentView: View {
        @State private var position: MapCameraPosition = .userLocation(
            followsHeading: true,
            fallback: .rect(rect)
        )
        
        var body: some View {
            Map(
                position: $position,
                bounds: MapCameraBounds(
                    centerCoordinateBounds: rect,
                    minimumDistance: 10,
                    maximumDistance: 100
                )
            ) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
            }
        }
    }
    

As I said before, we can use _MapCameraPosition_ for two-way binding, which
means we can query an instance of the _MapCameraPosition_ type to read some
data.

    
    
    struct ContentView: View {
        @State private var position: MapCameraPosition = .rect(
            MKMapRect(
                origin: MKMapPoint(.newYork),
                size: MKMapSize(width: 1, height: 1)
            )
        )
        
        var body: some View {
            Map(
                position: $position,
                bounds: MapCameraBounds(
                    centerCoordinateBounds: rect,
                    minimumDistance: 10,
                    maximumDistance: 100
                )
            ) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
            }
            .onChange(of: position) {
                print(position.positionedByUser)
                print(position.camera)
                print(position.region)
                print(position.rect)
            }
            .onAppear {
                position = .camera(.init(centerCoordinate: .newYork, distance: 0))
            }
        }
    }
    

As you can see in the example above, we use an instance of the
_MapCameraPosition_ to access the recent camera, region, rectangle, etc, of
the map. All of the mentioned fields are optional and will be non-nil values
if the particular instance of the _MapCameraPosition_ type is used.

There is also the _positionedByUser_ property. It is a boolean value defining
whenever the camera is positioned by the user or positioned by the developer
programmatically.

Today, we learned how to manage the map camera position using the new
_MapCameraPosition_ type, part of the new rich MapKit API. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading, and see you next
week!

  1. [ Mastering MapKit in SwiftUI. Basics. ](/2023/11/28/mastering-mapkit-in-swiftui-basics/)
  2. [ Mastering MapKit in SwiftUI. Customizations. ](/2023/12/05/mastering-mapkit-in-swiftui-customizations/)
  3. Mastering MapKit in SwiftUI. Camera. 
  4. [ Mastering MapKit in SwiftUI. Interactions. ](/2023/12/19/mastering-mapkit-in-swiftui-interactions/)



# Building custom Combine operators in Swift

##  Building custom Combine operators in Swift

28 Apr 2021

Combine looks like a very sophisticated framework and provides you all the
needed things you might need to process your data. It comes with many valuable
operators like map, filter, and reduce. This week we will learn how to build
new operators that we might miss from the default package.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Rather than implementing the _Publisher_ protocol yourself, you can create
your own operator using composition and several standard operators and
publishers provided by the Combine framework. Let’s start with the simplest
one.

####  Replace error or empty with value

The Combine framework has _replaceEmpty_ and _replaceError_ operators that we
can use to inject the value into an empty publisher or replace the error with
a value. I need both of them very often, and instead of typing these two
operators every time, we can create a new one that combines them.

    
    
    extension Publisher {
        func replaceErrorOrEmpty(with output: Output) -> AnyPublisher<Output, Never> {
            self
                .replaceEmpty(with: output)
                .replaceError(with: output)
                .eraseToAnyPublisher()
        }
    }
    

As you can see in the example above, we can create an extension for
_Publisher_ type in a straightforward way and add the functionality we need by
composing other operators. Now we can use the new operator as we use standard
ones.

    
    
    Reducer { state, action, environment in
        switch action {
        case .fetch:
            return environment.healthService
                .authorize()
                .replaceErrorOrEmpty(with: false)
                .map(AppAction.setAuthStatus)
                .eraseToAnyPublisher()
        }
    }
    

> To learn more about the set of operators that the Combine framework provides
> us, take a look at my [ “Catching errors in Combine” ](/2020/04/22/catching-
> errors-in-combine/) post.

####  Finish on fail

Another helpful operator might be finish on fail. There are different
circumstances where you don’t need to handle the failure and want to finish
silently. There is not standard operator for that in the Combine framework,
but we can quickly achieve it by using the _catch_ operator and _Empty_
publisher.

    
    
    extension Publisher {
        func finishOnFail() -> AnyPublisher<Output, Never> {
            self
                .catch { _ in Empty() }
                .eraseToAnyPublisher()
        }
    }
    

Here we have another extension on _Publisher_ type that adds an opportunity to
finish the publisher without emitting an error. I usually use the
_finishOnFail_ operator in conjunction with the _Merge_ publisher. For
example, on every app launch, I start a network request to fetch the latest
data, but at the same time, I fetch and display locally cached data. In this
case, I don’t worry if my network request fails or not because I have the data
to show.

    
    
    func newsReducer(
        state: State,
        action: Action,
        environment: Environment
    ) -> AnyPublisher<Action, Never> {
        switch action {
        case .fetch:
            return Publishers.Merge(
                environment.newsService.fetchCachedNews(),
                environment.newsService.fetchRemoteNews()
                    .finishOnFail()
            )
            .map(Action.setNews)
            .eraseToAnyPublisher()
        default: 
            return Empty().eraseToAnyPublisher()
        }
    }
    

####  Catch result

OK, we know how to ignore errors, but we should at least handle them. In many
cases, an error can be a part of the app state that why we should not ignore
it. Instead, we have to store and display it correctly. Let’s first build an
operator which we can use to wrap the value and error into a _Result_ type
that the publisher emits instead of plain value.

    
    
    extension Publisher {
        func catchResult() -> AnyPublisher<Result<Output, Failure>, Never> {
            self
                .map(Result.success)
                .catch { Just(Result.failure($0)) }
                .eraseToAnyPublisher()
        }
    }
    

Assume that we have a single state container that stores the whole app state.
There is a dedicated field defining the state of an authorization request as
an instance of _Result_ enum. Let’s see how it might look in code.

    
    
    struct State {
        var auth: Result<Bool, Error>
    }
    
    enum Action {
        case fetchAuth
        case setAuth(Result<Bool, Error>)
    }
    
    func authReducer(
        state: inout State,
        action: Action,
        environment: Environment
    ) -> AnyPublisher<Action, Never> {
        switch action {
        case .fetchAuth:
            return environment.service
                .authorize()
                .catchResult()
                .map(Action.setAuth)
                .eraseToAnyPublisher()
        case .setAuth(let result):
            state.auth = result
            return Empty()
                .eraseToAnyPublisher()
        }
    }
    

Side effects returned by reducers should never fail. Even if it fails under
the hood, it should emit an action that defines a failure. It is a perfect use
case for our new _catchResult_ operator.

> If you are not familiar with the concept of a single source of truth, take a
> look at my dedicated series of [ “Redux-like state container in SwiftUI”
> ](/2019/09/18/redux-like-state-container-in-swiftui/) posts.

####  Conclusion

The Combine framework is a great tool to handle asynchronous operations in
your app. It provides you with tons of operators to transform your data, but
it is also effortless to extend it using the composition of standard operators
that we learned today. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Mastering ScrollView in SwiftUI. Target Behavior

##  Mastering ScrollView in SwiftUI. Target Behavior

20 Jun 2023

This year we have massive additions to the _ScrollView_ functionality in
SwiftUI. Apple has added a bunch of new APIs to work with the _ScrollView_ .
This week we will talk about snapping behavior in _ScrollView_ and how we can
customize the scroll target.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The SwiftUI framework provides the brand-new _scrollTargetBehavior_ view
modifier allowing us to specify a particular snapping behavior. Let’s take a
look at a quick example.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ForEach(0..<100) { number in
                    Text(verbatim: String(number))
                        .font(.largeTitle)
                        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 300)
                        .background(Rectangle().fill(Color.green))
                }
            }
            .scrollTargetBehavior(.paging)
        }
    }
    

Here we use the _scrollTargetBehavior_ view modifier with the _paging_ option
to enable scrolling by pages. In this case, the _ScrollView_ uses containing
size to calculate the next visible target.

The paging instance of the _PagingScrollTargetBehavior_ type conforms to the
_ScrollTargetBehavior_ protocol. Another type conforming to the
_ScrollTargetBehavior_ protocol is _ViewAlignedScrollTargetBehavior_ .

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ForEach(0..<100) { number in
                    Text(verbatim: String(number))
                        .font(.largeTitle)
                        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 300)
                        .background(Rectangle().fill(Color.green))
                        .scrollTarget()
                }
            }
            .scrollTargetBehavior(.viewAligned)
        }
    }
    

As you can see in the example above, we use the _scrollTargetBehavior_ view
modifier with the _viewAligned_ option to enable view snapping. _ScrollView_
automatically decelerates after scrolling to align with the first visible item
in its viewport. The _ScrollView_ looking for the views marked with the
_scrollTarget_ view modifier to align.

Usually, you define the _ScrollView_ with the layout container inside, like
_LazyVGrid_ or _LazyVStack_ . In this case, you should use the
_scrollTargetLayout_ view modifier on an instance of the _LazyVGrid_ or
_LazyVStack_ to allow the _ScrollView_ to target views inside the container.

    
    
    struct ExampleScrollView: View {
        var body: some View {
            ScrollView {
                LazyVStack {
                    ForEach(0..<100) { number in
                        Text(verbatim: String(number))
                            .font(.largeTitle)
                            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 300)
                            .background(Rectangle().fill(Color.green))
                    }
                }
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned)
        }
    }
    

You can also use the _scrollTarget_ and _scrollTargetLayout_ view modifiers in
a single _ScrollView_ to mark individual views as scroll targets in pair with
the items in the layout container.

    
    
    struct AnotherExampleScrollView: View {
        var body: some View {
            ScrollView {
                CustomHeaderView()
                    .scrollTarget()
                
                LazyVStack {
                    // some content here
                }
                .scrollTargetLayout()
                
                CustomFooterView()
                    .scrollTarget()
            }
            .scrollTargetBehavior(.viewAligned)
        }
    }
    

Remember that you can use the _scrollTargetBehavior_ view modifier to set the
horizontal and vertical scrolling target. It depends on how you allow axes on
the _ScrollView_ .

    
    
    struct ExampleScrollView: View {
        var body: some View {
            ScrollView(.horizontal) {
                LazyHStack {
                    ForEach(0..<100) { number in
                        Text(verbatim: String(number))
                            .font(.largeTitle)
                            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 300)
                            .background(Rectangle().fill(Color.green))
                    }
                }
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned)
        }
    }
    

The SwiftUI provides two options for scrolling target behavior: _viewAligned_
and _paging_ . But you can create your types by conforming to the
_ScrollTargetBehavior_ protocol.

    
    
    struct CustomScrollTargetBehavior: ScrollTargetBehavior {
        func updateTarget(_ target: inout ScrollTarget, context: TargetContext) {
            if context.velocity.dy > 0 {
                target.rect.origin.y = context.originalTarget.rect.maxY
            } else if context.velocity.dy < 0 {
                target.rect.origin.y = context.originalTarget.rect.minY
            }
        }
    }
    
    extension ScrollTargetBehavior where Self == CustomScrollTargetBehavior {
        static var custom: CustomScrollTargetBehavior { .init() }
    }
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ForEach(0..<100) { number in
                    Text(verbatim: String(number))
                        .font(.largeTitle)
                        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 300)
                        .background(Rectangle().fill(Color.green))
                }
            }
            .scrollTargetBehavior(.custom)
        }
    }
    

As you can see in the example above, we define the
_CustomScrollTargetBehavior_ type conforming to the _ScrollTargetBehavior_
protocol. It needs to implement the only required function called
_updateTarget_ . The _updateTarget_ function has two parameters _target_ and
_context_ .

The _target_ parameter is an inout instance of the _ScrollTarget_ type and
allows us to set the _rect_ and _anchor_ point for our target inside the
_ScrollView_ .

The _context_ parameter is an instance of the _ScrollTargetBehaviorContext_
type and provides information about the context in which the scroll target
updates. It provides access to enabled axes, velocity, container size, content
size, original target, etc.

> To learn more about additions to the _ScrollView_ , take a look at my [
> “Mastering ScrollView in SwiftUI. Transitions” ](/2023/06/13/mastering-
> scrollview-in-swiftui-transitions/) post.

With these additions, the _ScrollView_ type gains a lot of power and allows us
to build a super-custom experience for our users on all Apple platforms. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Must-have SwiftUI extensions

##  Must-have SwiftUI extensions

04 Dec 2019

Currently, I have three ongoing SwiftUI projects. During my work on these
projects, I find myself in copying some extension files, which are very
helpful in any SwiftUI based project. That’s why I decide to share with you
that small foundation of useful extensions.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  AnyView

_AnyView_ is a type-erased view. It allows us to hide the real type of view
inside the erased box. Usually, we might use it whenever we want to return
different types of views. Let’s take a look at a quick example.

    
    
    import SwiftUI
    
    struct Item: Identifiable {
        enum ItemType {
            case image
            case text
        }
    
        let id = UUID()
        let value: String
        let type: ItemType
    }
    
    struct ContentView: View {
        let items: [Item] = [
            Item(value: "text", type: .text),
            Item(value: "photo", type: .image)
        ]
    
        var body: some View {
            List(items) { item -> AnyView in
                if item.type == .image {
                    return AnyView(Image(systemName: item.value))
                } else {
                    return AnyView(Text(item.value))
                }
            }
        }
    }
    

In the example above, we have a list that shows two types of items, and
because of _@ViewBuilder_ , we can return only the one kind of view. We use
_AnyView_ to erase our views to the single _AnyView_ type. It looks like we
are going to use _AnyView_ a lot of times across the codebase because many
views use _@ViewBuilder_ to build its content. Let’s introduce the extension
on _View_ type, which can erase it to _AnyView_ .

    
    
    extension View {
        func eraseToAnyView() -> AnyView {
            AnyView(self)
        }
    }
    
    struct ContentView: View {
        let items: [Item] = [
            Item(value: "text", type: .text),
            Item(value: "photo", type: .image)
        ]
    
        var body: some View {
            List(items) { item -> AnyView in
                if item.type == .text {
                    return Text(item.value)
                        .eraseToAnyView()
                } else {
                    return Image(systemName: item.value)
                        .eraseToAnyView()
                }
            }
        }
    }
    

Here we use our new extension for erasing views. I think it looks much better,
even with this simple example. But remember that _AnyView_ has an impact on
performance.

> AnyView allows changing the type of view used in a given view hierarchy.
> Whenever the type of view used with AnyView changes, SwiftUI destroys old
> hierarchy and creates a new hierarchy the new type.

To learn more about diffing process in SwiftUI take a look at my [ “You have
to change mindset to use SwiftUI” ](/2019/11/19/you-have-to-change-mindset-to-
use-swiftui/) post. That’s why it is better to avoid usage of _AnyView_ and
replace it with _Group_ whenever it is possible. Let’s see how we can replace
_AnyView_ with the _Group_ component in the previous example.

    
    
    struct ContentView: View {
        let items: [Item] = [
            Item(value: "text", type: .text),
            Item(value: "photo", type: .image)
        ]
    
        var body: some View {
            List(items) { item in
                Group {
                    if item.type == .image {
                        Image(systemName: item.value)
                    } else {
                        Text(item.value)
                    }
                }
            }
        }
    }
    

To learn more about hidden benefits of _Group_ component take a look at [
“View composition in SwiftUI” ](/2019/10/30/view-composition-in-swiftui/)
post.

####  IndexedCollection

Assume that you are working on a note-taking app, you have a store object
where you keep all the notes, you have a notes list screen, and you have a
note editing screen. Let’s try to implement it.

    
    
    import SwiftUI
    
    final class Store: ObservableObject {
        var notes: [String] = ["first", "second"]
    }
    
    struct NotesView: View {
        @ObservedObject var store = Store()
    
        var body: some View {
            NavigationView {
                List(store.notes.indexed(), id: \.self) { note in
                    // Compilation error here, EditView needs a binding, but we pass a String
                    NavigationLink(destination: EditView(note: note)) {
                        Text(note)
                    }
                }.navigationBarTitle("Notes")
            }
        }
    }
    
    struct EditView: View {
        @Binding var note: String
    
        var body: some View {
            TextField("type your note here", text: $note)
        }
    }
    

Here is a straightforward implementation of the idea. It looks simple, but it
doesn’t compile. The problem here is that _EditView_ needs a binding to the
note to alter it, but instead, we pass a copy of the note. We can’t provide
both binding and item while using an array. Let’s introduce the
_IndexedCollection_ type.

    
    
    extension RandomAccessCollection {
        func indexed() -> Array<(offset: Int, element: Element)> {
            Array(enumerated())
        }
    }
    

_IndexedCollection_ is a wrapper for any _RandomAccessCollection_ , and it
provides both index and element via subscript. Now let’s take a look at how we
can use this collection type.

    
    
    struct NotesView: View {
        @ObservedObject var store = Store()
    
        var body: some View {
            NavigationView {
                List(store.notes.indexed(), id: \.1.self) { index, note in
                    NavigationLink(destination: EditView(note: self.$store.notes[index])) {
                        Text(note)
                    }
                }.navigationBarTitle("Notes")
            }
        }
    }
    

As you can see in the example above, we can get both index and element of the
collection. It allows us to provide both Id for the list and binding for the
_EditView_ .

####  Bonus tip

    
    
    extension View {
        func embedInNavigation() -> some View {
            NavigationView { self }
        }
    }
    

####  Conclusion

Today we talked about the most useful SwiftUI extensions from my codebase. I
hope you will find it valuable. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Tabs and pages in SwiftUI

##  Tabs and pages in SwiftUI

16 Sep 2020

This week we will talk about creating tabs and pager views in SwiftUI.
_TabView_ gained superpower during WWDC20. We can now use it across all the
Apple platforms to build tabbed and paged user experiences with SwiftUI out of
the box.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

_TabView_ is a container view that puts children views into separated tabs.
Let’s start with a quick example.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            TabView {
                Text("Hello")
                Text("World")
            }
        }
    }
    

As you can see, we just wrap our views with _TabView_ , and that’s it. SwiftUI
creates a tab-based user interface to switch our views. We can decorate our
tabs with text labels and images using the _tabItem_ modifier by adding it to
_TabView_ children.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            TabView {
                Text("Hello")
                    .tabItem {
                        Image(systemName: "heart.fill")
                        Text("Tab1")
                    }
                Text("World")
                    .tabItem {
                        Text("Tab2")
                    }
            }
        }
    }
    

Remember that we can only use _Image_ and _Text_ views inside _tabItem_
closure to decorate our tabs. Sometimes we need to control the selected tab of
our _TabView_ to switch it during deep linking or while opening a
notification. There is another _TabView_ initializer that we can use to make
programmatic tab switching possible.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var selection = 0
    
        var body: some View {
            TabView(selection: $selection) {
                Text("Hello")
                    .tabItem {
                        Image(systemName: "heart.fill")
                        Text("Tab1")
                    }.tag(0)
                Text("World")
                    .tabItem {
                        Text("Tab2")
                    }.tag(1)
            }
        }
    }
    

As you can see in the example above, we need to provide a selection binding to
a _TabView_ . We can change the value of our state property to switch tabs
programmatically. We also need to use a tag modifier to provide a value
associated with the view. SwiftUI switches tabs using tag value.

####  Pager view

We can easily replace our tabbed user interface with paged one by applying the
_tabViewStyle_ modifier on the view that contains _TabView_ or on _TabView_
itself. Let’s take a look at how we can do that.

    
    
    struct ContentView: View {
        var body: some View {
            TabView {
                Text("Hello")
                Text("World")
            }.tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
        }
    }
    

As you can see in the example above, we set an instance of _PageTabViewStyle_
struct as the style of our _TabView_ . We can also control whenever we want to
show the page indicator using the _indexDisplayMode_ parameter.

_TabView_ ’s selection binding fully supports animations. It means that you
can wrap the binding changes using the _withAnimation_ function and
programmatically animate page transition. You might need it when your designs
contain buttons for the next and previous pages.

    
    
    import SwiftUI
    
    struct ContentView: View {
        @State private var selection = 0
    
        var body: some View {
            ZStack(alignment: .bottom) {
                TabView(selection: $selection) {
                    Text("Hello").tag(0)
                    Text("World").tag(1)
                }.tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
    
                Button("next") {
                    withAnimation {
                        selection = 1
                    }
                }
            }
        }
    }
    

####  Conclusion

I’m happy to see that this year _TabView_ supports all the platforms. You can
use it on watchOS to build a paged user experience or macOS in the settings
scene that will apply the correct styling to match the settings screen that we
used to see on macOS. It also looks great and adapts to tvOS styling when you
use it in a TV app.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Redux-like state container in SwiftUI. Basics.

##  Redux-like state container in SwiftUI. Basics.

18 Sep 2019

This week we will talk about building a state container similar to _Redux_ and
_The Elm Architecture_ that provides a single source of truth for your app. A
single state for the whole app makes it easier to debug and inspect. Single
source of truth eliminates tons of bugs produced by creating multiple states
across the app.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Single source of truth

The main idea here is describing the whole app state by using a single struct
or composition of structs. Assume that we are working on a Github repos search
app where the state is the repos array that we fetch matching some query using
Github API.

    
    
    struct AppState {
        var searchResult: [Repo] = []
    }
    

Next step is passing the read-only app state to every view inside the app. The
best way for doing that is _SwiftUI’s Environment_ feature. We can put an
object holding the whole app state in the _Environment_ of the root view. Root
view will share its _Environment_ with all child views.

> SwiftUI uses environment to pass system-wide and application-related
> information. You can also populate environment with your custom objects. To
> learn more about environment, take a look at my [ “The power of Environment
> in SwiftUI” ](/2019/08/21/the-power-of-environment-in-swiftui/) post.
    
    
    final class Store: ObservableObject {
        @Published private(set) var state: AppState
    }
    

In the example above, we create a store object that stores the app state and
provides read-only access to it. State property uses _@Published_ property
wrapper that notifies SwiftUI during any changes. It allows us to keep up to
date the whole app by deriving it from a single source of truth.

> To learn more you can check [ “Modeling app state using Store objects in
> SwiftUI” ](/2019/09/04/modeling-app-state-using-store-objects-in-swiftui/)
> post.

####  Reducer and Actions

It’s time to talk about user actions which lead to state mutations. _Action_
is a simple enum or composition of enums describing a change of the state. For
example, set loading value during data fetch, assign fetched repositories to
the state property. Let’s take a look at the example code for _Action_ enum.

    
    
    enum AppAction {
        case search(query: String)
        case setSearchResult(repos: [Repo])
    }
    

_Reducer_ is a function that takes current state, applies _Action_ to the
state, and generates a new state. Generally, _reducer_ or _composition of
reducers_ is the single place where your app should mutate the state. The fact
that the only one function can modify the whole app state is super simple,
debuggable, and testable. Here is an example of reduce function.

    
    
    typealias Reducer<State, Action> = (inout State, Action) -> Void
    
    func appReducer(state: inout AppState, action: AppAction) {
        switch action {
        case let .setSearchResults(repos):
            state.searchResult = repos
        case let .search(query):
            break
        }
    }
    

####  Unidirectional flow

Let’s talk about data flow now. Every view has a read-only access to the state
via store object. Views can send _actions_ to the store object. _Reducer_
modifies the state, and then SwiftUI notifies all the views about state
changes. SwiftUI has a super-efficient diffing algorithm that’s why diffing of
the whole app state and updating changed views works so fast. Let’s modify our
store object to support sending _actions_ .

    
    
    final class Store<State, Action>: ObservableObject {
        @Published private(set) var state: State
    
        private let reducer: Reducer<State, Action>
    
        init(initialState: State, reducer: @escaping Reducer<State, Action>) {
            self.state = initialState
            self.reducer = reducer
        }
    
        func send(_ action: Action) {
            reducer(&state, action)
        }
    }
    

_State - > View -> Action -> State -> View _

This architecture revolves around a strict **unidirectional** data flow. It
means that all the data in the application follows the same pattern, making
the logic of your app more predictable and easier to understand.

####  Side effects

We already implemented a _unidirectional_ flow that accepts user actions and
modifies the state, but what about _async actions_ which we usually call _side
effects_ . How to bake a support for async tasks into our store type? I think
it is a good time to introduce the usage of _Combine framework_ that perfectly
fits async task processing.

    
    
    typealias Reducer<State, Action, Environment> =
        (inout State, Action, Environment) -> AnyPublisher<Action, Never>?
    

We add support for _async tasks_ by changing _Reducer_ typealias, it has the
additional parameter called _Environment_ . _Environment_ might be a plain
struct that holds all needed dependencies like service and manager classes.

    
    
    func appReducer(
        state: inout AppState,
        action: AppAction,
        environment: Environment
    ) -> AnyPublisher<AppAction, Never>? {
        switch action {
        case let .setSearchResults(repos):
            state.searchResult = repos
        case let .search(query):
            return environment.service
                .searchPublisher(matching: query)
                .replaceError(with: [])
                .map { AppAction.setSearchResults(repos: $0) }
                .eraseToAnyPublisher()
        }
        return nil
    }
    

Side Effect is a sequence of _Actions_ which we can publish using _Combine_
framework’s _Publisher_ type. It allows us to handle async job and then
publish an _action_ that will be used by _reducer_ to change the current
state.

    
    
    final class Store<State, Action, Environment>: ObservableObject {
        @Published private(set) var state: State
    
        private let environment: Environment
        private let reducer: Reducer<State, Action, Environment>
        private var cancellables: Set<AnyCancellable> = []
    
        init(
            initialState: State,
            reducer: @escaping Reducer<State, Action, Environment>,
            environment: Environment
        ) {
            self.state = initialState
            self.reducer = reducer
            self.environment = environment
        }
    
        func send(_ action: Action) {
            guard let effect = reducer(&state, action, environment) else {
                return
            }
    
            effect
                .receive(on: DispatchQueue.main)
                .sink(receiveValue: send)
                .store(in: &cancellables)
        }
    }
    

As you can see in the example above, we build a _Store_ type that supports
async tasks. Usually, reducer resolves an action by applying it on top of the
state. In case of an async action, reducer returns it as _Combine Publisher_ ,
then _Store_ run it and send result back to the reducer as a plain action.

####  Real usage example

Finally, we can finish our repos search app that calls Github API
asynchronously and fetches repositories matching a query. The full source code
available on [ Github ](https://github.com/mecid/redux-like-state-container-
in-swiftui) .

    
    
    typealias AppStore = Store<AppState, AppAction, AppEnvironment>
    
    struct SearchContainerView: View {
        @EnvironmentObject var store: AppStore
        @State private var query: String = "Swift"
    
        var body: some View {
            SearchView(
                query: $query,
                repos: store.state.searchResult,
                onCommit: fetch
            ).onAppear(perform: fetch)
        }
    
        private func fetch() {
            store.send(.search(query: query))
        }
    }
    
    struct SearchView : View {
        @Binding var query: String
        let repos: [Repo]
        let onCommit: () -> Void
    
        var body: some View {
            NavigationView {
                List {
                    TextField("Type something", text: $query, onCommit: onCommit)
    
                    if repos.isEmpty {
                        Text("Loading...")
                    } else {
                        ForEach(repos) { repo in
                            RepoRow(repo: repo)
                        }
                    }
                }.navigationBarTitle(Text("Search"))
            }
        }
    }
    

We divide our screen into two views: _Container View_ and _Rendering View_ .
_Container View_ handles the actions and retrieves the needed piece of state
from the global state. _Rendering View_ accepts the data and renders it.

> We already talked about _Container Views_ in my previous posts, to learn
> more take a look at [ “Introducing Container views in SwiftUI”
> ](/2019/07/31/introducing-container-views-in-swiftui/) post.

####  Conclusion

Today we learned how to build _Redux-like_ state container with _side-effects_
in mind. To achieve that we used _Combine_ framework. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading and see you next week!

  1. Redux-like state container in SwiftUI. Basics 
  2. [ Redux-like state container in SwiftUI. Best practices ](/2019/09/25/redux-like-state-container-in-swiftui-part2/)
  3. [ Redux-like state container in SwiftUI. Container Views. ](/2019/10/02/redux-like-state-container-in-swiftui-part3/)
  4. [ Redux-like state container in SwiftUI. Connectors. ](/2021/02/03/redux-like-state-container-in-swiftui-part4/)
  5. [ Redux-like state container in SwiftUI. Swift concurrency model. ](/2022/02/17/redux-like-state-container-in-swiftui-part5/)

####  References

The series of posts have built on a foundation of ideas started by other
libraries, particularly Redux, Elm, and TCA.

  1. [ WWDC20 - Data Essentials in SwiftUI ](https://developer.apple.com/videos/play/wwdc2020/10040/)
  2. [ Redux ](https://redux.js.org) \- The JavaScript library that popularized unidirectional data flow. 
  3. [ The Elm Architecture ](https://guide.elm-lang.org/architecture/) \- A purely functional language and runtime that inspired the creation of Redux. 
  4. [ The Composable Architecture ](https://github.com/pointfreeco/swift-composable-architecture) \- A library that bridges concepts from the Elm Architecture and Redux to Swift. It introduced the “environment” and “effect” patterns that this series covers. 



# The power of Closures in SwiftUI

##  The power of Closures in SwiftUI

06 Nov 2019

One of my favorite design patterns in _UIKit_ development was a [ _Delegate
pattern_ ](/2019/05/29/the-power-of-delegate-design-pattern/) . _Delegate
pattern_ is very straightforward, and everybody knows how to use it. In the
_Functional Programming_ world, we usually replace delegates with closures.
This week we will learn how to use closures to make SwiftUI views composable
and decoupled.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Passing closures to child views

I usually build my app screen by implementing one container view which handles
all the data-flow related to the screen and a couple of rendering views, which
simply represent passed data and propagate user actions to the container view.
Let’s take a look at an example.

    
    
    struct PostContainerView: View {
        @EnvironmentObject var store: Store<State, Action>
        @State private var content: String = ""
    
        var body: some View {
            PostContentView(
                content: $content,
                postContent: postContent
            )
        }
    
        private func postContent() {
            store.send(.post(content))
        }
    }
    
    struct PostContentView: View {
        @Binding var content: String
        let postContent: () -> Void
    
        var body: some View {
            VStack {
                TextField("type something...", text: $content)
                Button("post", action: postContent)
            }
        }
    }
    

Here we have a container view that handles user actions by providing a closure
to the child view. _PostContentView_ renders the state provided by a container
view and passes user action to the container view. This technique allows us to
reuse _PostContentView_ across the codebase. We can use it whenever we need to
post a comment or some post.

We already discussed the benefits of using container view in SwiftUI on my
blog multiple times, take a look at [ “Introducing Container views in SwiftUI”
](/2019/07/31/introducing-container-views-in-swiftui/) post if you missed it.

####  Extracting navigation into closures

SwiftUI has a pretty declarative way of building navigation between the
screens. All you need to do is embedding your view into a _NavigationLink_
with a provided destination view. Here is a quick example of using
_NavigationLink_ in SwiftUI apps.

    
    
    struct ItemsView: View {
        let items: [Item]
    
        var body: some View {
            NavigationView {
                List(items) { item in
                    NavigationLink(destination: DetailsView(item: item)) {
                        Text(item.id.uuidString)
                    }
                }
            }
        }
    }
    

As you can see in the example above, we simply wrap our list item into a
_NavigationLink_ , which navigates to the _DetailsView_ after a click on any
list item. The logic here is very straightforward, but it has at least one
downside. _ItemsView_ knows about _DetailsView_ and depends on it, and because
of that, we can’t reuse it somewhere in our app, or we can’t use it with a
different destination in other parts of the app. Let’s see how we can solve
the problem by using closures.

    
    
    struct ItemsView<Destination: View>: View {
        let items: [Item]
        let buildDestination: (Item) -> Destination
    
        var body: some View {
            NavigationView {
                List(items) { item in
                    NavigationLink(destination: self.buildDestination(item)) {
                        Text(item.id.uuidString)
                    }
                }
            }
        }
    }
    

I refactored our _ItemsView_ to accept a closure which maps an item to a
destination view. It allows us to leave the responsibility of creating a
destination view to a parent view. Now we can reuse _ItemsView_ with different
destinations depending on our use case. Here is a code sample demonstrating
the usage of the _ItemsView_ .

    
    
    struct ItemsContainerView: View {
        @State private var items: [Item] = [.init(), .init(), .init()]
        
        var body: some View {
            ItemsView(items: items) { item in
                // build your destination view here
                Text(item.id.uuidString)
            }
        }
    }
    

Here we have _ItemsContainerView_ , which handles data-flow for the screen and
builds the destination view. It feels very natural by using trailing closure
syntax.

Navigation is a crucial topic, and we already covered it in previous posts, to
learn more about navigation in SwiftUI take a look at [ the dedicated post
](/2019/07/17/navigation-in-swiftui/) .

####  Conclusion

This week we learned how to use _closures_ to extract navigation and user
input handling from SwiftUI views. _Closures_ allow us to make our views
decoupled and respecting the single responsibility principle. We can benefit
it to build simple and composable view hierarchies in SwiftUI. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Creating DSL in Swift

##  Creating DSL in Swift

30 Jan 2019

This week we will talk about creating DSL in Swift. Let’s start with the
understanding of DSL acronym. Domain Specific Language is a language hosted by
parent language to solve any specific area. An excellent example of DSL can be
HTML which is DSL for creating web page markup.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

There are some requirements for a language in which you want to create DSL. A
host language should have first-class functions, trailing closures and
operator overloading to make DSL possible. The great news is that Swift has
all of these features.

We are going to simplify User Interface development on iOS by creating UIKit
specific DSL. We have two ways of building UI in iOS. The first one is by
using Interface Builder, and the second one is via code. Both of them have
pros and cons. For instance, building UI by Interface Builder is a high-speed
and visual process, but you have to deal with a problematic code review
process, because of the format of Xibs and Storyboards. In case of building
your UI by code, you get the reusability and clean code review process, but
you deal with the imperative and error-prone codebase, without a visual
understanding of view hierarchy.

Let’s set our goals in building UIKit DSL in Swift:

  1. Visual view hierarchy 
  2. Declarative like HTML 
  3. Type-safe and compile-time guarantee of correctness. 

    
    
    let rootView = stack {
        $0.spacing = 16
        $0.axis = .vertical
        $0.isLayoutMarginsRelativeArrangement = true
    
        $0.stack {
            $0.distribution = .fillEqually
            $0.axis = .horizontal
    
            $0.label {
                $0.textAlignment = .center
                $0.textColor = .white
                $0.text = "Hello"
            }
    
            $0.label {
                $0.textAlignment = .center
                $0.textColor = .white
                $0.text = "World"
            }
    
            $0.customLabel {
                $0.textAlignment = .center
                $0.textColor = .white
                $0.text = "!!!"
            }
        }
    
        let messageButton = $0.button {
            $0.tintColor = .white
            $0.setTitle("Say Hi!", for: .normal)
        }
    
        $0.view {
            $0.backgroundColor = .clear
        }
    }
    

The code above is our target, and this is how we want our DSL to be.
Generally, everything in this example is a function with a trailing closure
parameter. For more details let’s dive into implementation.

####  Root elements

We have to create a function stack which returns _UIStackView_ and accepting
closure which we apply to this new created _UIStackView_ .

    
    
    public func stack(apply closure: (UIStackView) -> Void) -> UIStackView {
        let stack = UIStackView()
        closure(stack)
        return stack
    }
    

These lines give us an opportunity to use stack function similar to HTML tag.

    
    
    stack {
        $0.axis = .vertical
    }
    

As the first parameter of the trailing closure, we get created _UIStackView_
on which we can call customization functions like changing axis, alignment,
etc. Next, we want to call _$0.label_ to configure new _UILabel_ and add to
previous _UIStackView_ . Let’s create an extension for _UIStackView_ which
provides us with label function.

    
    
    extension UIStackView {
        @discardableResult
        public func label(apply closure: (UILabel) -> Void) -> UILabel {
            let label = UILabel()
            addArrangedSubview(label)
            closure(label)
            return label
        }
    }
    

We use _@discardableResult_ annotation to disable swift compiler warning on
ignoring the result of this function because we already added it to
_UIStackView_ . Here is the example of label function usage.

    
    
    stack {
        $0.axis = .vertical
        $0.label {
            $0.adjustsFontForContentSizeCategory = true
        }
    }
    

We have one problem here, and this is the extension on _UIStackView_ , only
_UIStackView_ will have this function. But we need it in any _UIView_
subclass, so let’s move it to _UIView_ extension.

    
    
    extension UIView {
        @discardableResult
        public func label(apply closure: (UILabel) -> Void) -> UILabel {
            let label = UILabel()
            if let stack = self as? UIStackView {
                stack.addArrangedSubview(label)
            } else {
                addSubview(label)
            }
            closure(label)
            return label
        }
    }
    

We try here to cast self to _UIStackView_ , which give us the ability to use
_addArrangedSubview_ in case of _UIStackView_ , if not we add it with the
_addSubview_ method. Next step is populating our _UIView_ extension with
functions for all UIKit components to make above usage possible for every
UIKit component. I’ve added DSL support for all UIKit components. You can
check it out on [ Github ](https://github.com/mecid/UIKitSwiftDSL) .

    
    
    let rootView = stack {
        $0.spacing = 16
        $0.axis = .vertical
        $0.isLayoutMarginsRelativeArrangement = true
    
        $0.stack {
            $0.distribution = .fillEqually
            $0.axis = .horizontal
    
            $0.label {
                $0.textAlignment = .center
                $0.textColor = .white
                $0.text = "Hello"
            }
    
            $0.label {
                $0.textAlignment = .center
                $0.textColor = .white
                $0.text = "World"
            }
    
            $0.customLabel {
                $0.textAlignment = .center
                $0.textColor = .white
                $0.text = "!!!"
            }
        }
    
        let messageButton = $0.button {
            $0.tintColor = .white
            $0.setTitle("Say Hi!", for: .normal)
        }
    
        $0.view {
            $0.backgroundColor = .clear
        }
    }
    

Now we achieve declarative, tree-based and type-safe DSL for building UI for
iOS. [ It is available via CocoaPods and Carthage
](https://github.com/mecid/UIKitSwiftDSL) .

####  Conclusion

Today we learned how powerful is Swift, and how easy we can create DSL for any
specific domain. I suggest you try to develop your DSL for _DispatchQueue_ or
any other area.

Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading and see you next week!



# AnimatableModifier in SwiftUI

##  AnimatableModifier in SwiftUI

11 Jan 2021

I have already talked about animations in SwiftUI many times on this blog. But
still didn’t cover all the opportunities in terms of animation. Today I want
to fill another gap and talk to you about the _AnimatableModifier_ protocol
that opens new horizons for animations.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

We use many modifiers to build a view in SwiftUI like _frame_ ,
_foregroundColor_ , _padding_ , _background_ , etc. The main goal of a
modifier is adding some logic to create a slightly modified view.

> To learn more about modifiers, take a look at my [ “ViewModifiers in
> SwiftUI” ](/2019/08/07/viewmodifiers-in-swiftui/) post.

The single concern that I have about the _ViewModifier_ protocol is the
animation opportunity. You simply can’t animate the behavior inside a
_ViewModifier_ . You may ask about the _Animatable_ protocol to conform to our
custom view modifier, but it doesn’t work. It doesn’t work, but Apple provides
us a way to handle animation in view modifiers, and it is _AnimatableModifier_
.

    
    
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    public protocol AnimatableModifier : Animatable, ViewModifier {
    }
    

_AnimatableModifier_ protocol extends from _Animatable_ and _ViewModifier_
protocols and allows us to animate the changes inside the type that conforms
to it. Let’s take a look at the quick example.

    
    
    struct NumberView: AnimatableModifier {
        var number: Int
    
        var animatableData: CGFloat {
            get { CGFloat(number) }
            set { number = Int(newValue) }
        }
    
        func body(content: Content) -> some View {
            Text(String(number))
        }
    }
    

As you can see in the example above, we create the _NumberView_ type that
conforms to _AnimatableModifier_ . In the _body_ function of our modifier, we
render our number using the _Text_ view. _AnimatableModifier_ runs the _body_
function multiple times during the animation and creates a smooth transition
from one state to another.

Usually, we use the content parameter inside the body and apply additional
modifiers to it. Here we completely ignore the content and instead create a
brand new view. Let’s try to use the new _NumberView_ modifier.

    
    
    struct ContentView: View {
        @State private var number = 0
    
        var body: some View {
            VStack {
                Text(String(number))
                    .modifier(NumberView(number: number))
    
                Button("Animate") {
                    withAnimation(Animation.easeInOut(duration: 2)) {
                        number = 100
                    }
                }
            }
        }
    }
    

In the example above, we animate the number that appears on the screen.
SwiftUI uses _animatableData_ and vector arithmetic to interpolate the value
of the number variable. SwiftUI presents a new text view on every iteration of
the animation.

> If you are not familiar with _Animatable_ protocol and vector arithmetic,
> take a look at my [ “The magic of Animatable values in SwiftUI”
> ](/2020/06/17/the-magic-of-animatable-values-in-swiftui/) post.

![video](/public/am.mp4)

####  Conclusion

Today we learned about another hidden gem of SwiftUI. _AnimatableModifier_
allows us to animate the things that SwiftUI doesn’t allow us to animate out
of the box, like text. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
article. Thanks for reading, and see you next week!



# Customizing the shape of views in SwiftUI

##  Customizing the shape of views in SwiftUI

12 Feb 2020

SwiftUI provides us several exciting ways to change the shape of our views. It
allows clipping, masking, and a few other operations on the shape of views.
This week I want to talk to you about altering view’s shape in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Clipping

Sometimes we use the frame modifier to limit the size of our view. It might be
useful when you want to set the size to the image that should be scaled. In
case when the scaled image bigger than the provided frame, it can exceed it
and overlap other views. To fix this issue, SwiftUI allows us to clip the
content of the view to its frame. Let’s take a look at a quick example.

    
    
    KFImage(recipe.image)
        .resizable()
        .aspectRatio(contentMode: .fill)
        .frame(height: 300)
        .clipped(antialiased: true)
    

As you can see in the example above, we use the _clipped_ modifier. This
modifier lets us cut the content of the view inside its bounds. It also takes
the argument that indicates whenever to apply smoothing to the edges of the
frame.

> _KFImage_ is a part of [ KingFisher ](https://github.com/onevcat/Kingfisher)
> library for loading remote images

####  Clipping the shape

Assume that you are working on the app that presents the avatars. Usually, our
designers want to make avatars in a rounded form. Fortunately, SwiftUI allows
us to clip the view into any shape we can imagine. SwiftUI provides an
exceptional modifier for that called _clipShape_ . Let’s take a look at how we
can use it.

    
    
    KFImage(user.avatar)
        .resizable()
        .aspectRatio(contentMode: .fill)
        .frame(width: 100, height: 100)
        .clipShape(Circle())
    

We can easily apply _clipShape_ to any view by providing the shape we want.
There are plenty of ready to use shapes like _Rectangle, Capsule, Circle, etc_
. provided by SwiftUI. But anytime you want something unique, for example, a
star form, you can quickly implement it by creating a struct conforming
_Shape_ protocol. You can apply any shape you want by doing your math in
_path_ function.

> To learn more about _Shape_ protocol, take a look at my [ “Building BarChart
> with Shape API in SwiftUI” post ](/2019/08/14/building-barchart-with-shape-
> api-in-swiftui/) .

###  Masking

Let’s take a look at more complex examples. Assume that you have a text
component that should use a gradient as the text color. You can’t implement it
by using the _foregroundColor_ modifier because it accepts only colors. It is
the exact case where we might use masking. Let’s take a look at how we can
apply masking to use a gradient as the text color.

    
    
    struct MaskSample: View {
        var body: some View {
            LinearGradient(
                gradient: Gradient(colors: [.blue, .green, .yellow, .orange, .red]),
                startPoint: .leading,
                endPoint: .trailing
            )
                .mask(Text("I love SwiftUI !!!").font(.largeTitle))
                .background(Color.black)
        }
    }
    

As you can see in the example above, we have a gradient that masked with the
text. SwiftUI allows us to cut our gradient into the shape of our text.
Remember that you can mask any view not only gradient. It means you can mask
any image with the text to provide a beautiful look and feel to your users.

![mask](/public/mask.png)

####  Conclusion

This week we learned about clipping and masking views in SwiftUI. Both
clipping and masking allow us to provide nice effects to our users by adding a
few lines of code. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Mastering charts in SwiftUI. Interactions.

##  Mastering charts in SwiftUI. Interactions.

06 Feb 2023

The Swift Charts framework provides excellent functionality for implementing
super custom charts. This week we will learn how to handle user input with
gestures to build interactive charts. The _Chart_ type is a simple SwiftUI
view, which means you can attach gestures and buttons to interact with the
chart.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start with a simple example where we attach a drag gesture and change
the line’s color while the user touches the chart.

    
    
    struct ContentView: View {
        @State private var isDragging = false
        @State private var numbers = (0...10).map { _ in
            Int.random(in: 0...10)
        }
        
        var body: some View {
            Chart {
                ForEach(Array(zip(numbers, numbers.indices)), id: \.0) { number, index in
                    LineMark(
                        x: .value("Index", index),
                        y: .value("Value", number)
                    )
                    .foregroundStyle(isDragging ? .red : .blue)
                }
            }
            .gesture(
                DragGesture()
                    .onChanged { _ in isDragging = true }
                    .onEnded { _ in isDragging = false }
            )
        }
    }
    

As you can see in the example above, we reflect the user input by changing the
foreground color of the line mark. Being a SwiftUI view allows us to update
the chart’s content as soon as the state of the view changes. It is a simple
rule you must keep in mind and interact with the _Chart_ view as you used to
interact with other SwiftUI views.

> To learn more about the basics of the Charts framework, take a look at my
> dedicated [ “Mastering charts in SwiftUI. Basics.” ](/2023/01/10/mastering-
> charts-in-swiftui-basics/) post.

We have looked at the elementary example, but usually, we need to understand
which part of the chart user touches and interacts with the particular mark on
the chart. The Charts framework provides us with the _ChartProxy_ type for
these special cases.

The _ChartProxy_ type allows us to do a few essential calculations. First, we
can get a _Plottable_ value by providing a position on the chart. The second
thing we can do with the instance of the _ChartProxy_ type is to calculate a
position for a particular _Plottable_ value. Both of these operations might be
very helpful for plotting additional content for the points the user interacts
with at the very moment.

The _ChartProxy_ type also provides us with two beneficial properties,
_plotAreaSize_ , and _plotAreaFrame_ , which we can use to convert coordinates
between view space and chart area.

There is no way to create an instance of the _ChartProxy_ type, but we can
access it through the _chartOverlay_ and _chartBackground_ modifiers. Let’s
see how we can use it.

    
    
    struct ContentView1: View {
        @State private var selectedIndex: Int? = nil
        @State private var numbers = (0...10).map { _ in
            Int.random(in: 0...10)
        }
        
        var body: some View {
            Chart {
                // ...
            }
            .chartOverlay { chart in
                GeometryReader { geometry in
                    Rectangle()
                        .fill(Color.clear)
                        .contentShape(Rectangle())
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    let currentX = value.location.x - geometry[chart.plotAreaFrame].origin.x
                                    guard currentX >= 0, currentX < chart.plotAreaSize.width else {
                                        return
                                    }
                                    
                                    guard let index = chart.value(atX: currentX, as: Int.self) else {
                                        return
                                    }
                                    selectedIndex = index
                                }
                                .onEnded { _ in
                                    selectedIndex = nil
                                }
                        )
                }
            }
        }
    }
    

As you can see in the example above, we use the _chartOverlay_ modifier to put
an overlay view over the chart view with the instance of the _GeometryReader_
inside. We need the _GeometryReader_ here because the _plotAreaFrame_ property
provides us an instance of the _Anchor_ type, which we can use only in
conjunction with the instance of _GeometryProxy_ provided by the
_GeometryReader_ .

After converting the location of the drag gesture to the chart coordinate
space, we can use the instance of the _ChartProxy_ type to extract the value
of the X-axis for the position of the drag gesture.

    
    
    struct ContentView1: View {
        @State private var selectedIndex: Int? = nil
        @State private var numbers = (0...10).map { _ in
            Int.random(in: 0...10)
        }
        
        var body: some View {
            Chart {
                ForEach(Array(zip(numbers, numbers.indices)), id: \.0) { number, index in
                    if let selectedIndex, selectedIndex == index {
                        RectangleMark(
                            x: .value("Index", index),
                            yStart: .value("Value", 0),
                            yEnd: .value("Value", number),
                            width: 16
                        )
                        .opacity(0.4)
                    }
    
                    LineMark(
                        x: .value("Index", index),
                        y: .value("Value", number)
                    )
                }
            }
            .chartOverlay { chart in
                // ...
            }
        }
    }
    

Finally, we store the index value of the recent drag gesture in the state
variable and update our chart content to plot the rectangle to cover the
selected area. Remember that you can update your chart as you want to create
interactive charts. For example, you can show annotations, plot additional
content, change colors, etc.

In the recent example, we use the _value(forX:)_ function on the _ChartProxy_
type to read the value by providing the point on the X-axis, but we can also
use _value(forY:)_ to read by Y-axis, or _value(for:)_ to read both by X and
Y.

A few functions also allow us to get the location point on the chart by
providing a _Plottable_ value. Look at the _position(for:)_ function on the
_ChartProxy_ type. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Mastering Swift Foundation Formatter API. Basics

##  Mastering Swift Foundation Formatter API. Basics

30 May 2023

One of the significant additions to the Swift Foundation was the new Formatter
API. After almost two years of using it, I apply it in every project, and even
more, I try to build my data formatting logic around this API. Today we will
learn how to use the new Swift Foundation Formatter APIs.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Old-style formatters

    
    
    let shortDateFormatter = DateFormatter()
    shortDateFormatter.timeStyle = .none
    shortDateFormatter.dateStyle = .short
    shortDateFormatter.string(from: Date.now)
    

The old-style formatters have a few problems that make our lives more
complicated than they should be. First of all, the process of formatter
initializing is a resource-heavy task, and you should cache formatter
instances as much as you can. You should avoid the creation of a formatter
instance per item in your collection.

The second issue is the error-prone class-based API we inherited from the
Objective-C era. You can accidentally override the configuration of the
formatter instance, and it will affect all the places where you are using it.
It is a classical reference type-related issue and why we love Swift value
types.

####  Swift Foundation Formatter API

Many types in Swift Foundation provide the new **formatted** function allowing
us to format the instance in place. You don’t need to initialize any formatter
instance or cache them because the Foundation automatically handles it.

    
    
    Date.now.formatted()
    

As you can see in the example above, we use the _formatted_ function on an
instance of the _Date_ type to format it to a locale-friendly string. The new
Swift Foundation Formatter API also provides a new value-oriented approach for
customizing formatting options.

    
    
    ["Majid", "Fuad"].formatted(.list(type: .and))
    

You can always try to type _.formatted()_ on any instance of the Swift
Foundation types in the Xcode to see if it provides formatting logic. You will
be surprised how many of them offer formatting opportunities. And the new
type-safe and value-oriented format style builders eliminate the need to check
the documentation of a formatter instance because they provide very
predictable usage.

    
    
    Date.now.formatted(.relative(presentation: .named))
    Date.now.formatted(date: .abbreviated, time: .omitted)
    Date.now.formatted(.dateTime.day(.twoDigits).month(.abbreviated).year(.twoDigits))
    Date.now.formatted(.iso8601)
    

As you can see in the example above, there are many options for customization
of the date formatting logic. You can mix and match many of them to display
the needed date in a user-friendly format.

    
    
    1_000_000_000.formatted()
    1.001.formatted(.number.precision(.fractionLength(1)))
    0.1.formatted(.percent)
    0.99.formatted(.currency(code: "USD"))
    

Here is another example of the new Swift Foundation Formatter APIs allowing us
to display numbers in the locale-friendly format and customize it using format
style builders API.

    
    
    Measurement<UnitMass>(value: 1, unit: .kilograms)
        .formatted(.measurement(width: .abbreviated))
    

As you can see in the example above, even the _Measurement_ type supports the
new Formatter API and allows us to present the data in the appropriate format
in a few keystrokes.

Today we learned about the basics of the new Swift Foundation Formatter APIs.
In the following posts, we will continue the topic by implementing custom
format styles for our own types. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# You have to change mindset to use SwiftUI

##  You have to change mindset to use SwiftUI

19 Nov 2019

Last week I saw that the community tries to move _UIKit_ development patterns
to SwiftUI. But I’m sure that the best way to write efficient SwiftUI is to
forget everything about _UIKit_ and entirely change your mindset in terms of
User Interface development. This week we will learn the main differences
between _UIKit_ and SwiftUI development.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Diffing

_UIKit_ is an imperative event-driven framework for building User Interfaces
for iOS platform. It means you have to handle all the state changes during
events like view loaded, button pressed, etc. The big downside of this
approach is the complexity of keeping in sync User Interface with its state.
As soon as state changes, you need to manually add/remove/show/hide the views
and keep it in sync with the current state.

SwiftUI is a declarative framework for building User Interfaces on Apple
platforms. The keyword here is declarative. Declarative means that you need to
declare what you want to achieve, and the framework takes care of it.
Framework knows the best way to render the User Interface.

> ` UI = f(state) `

The User Interface in SwiftUI is a function of its state. It means whenever
the view’s state changes, it recomputes its **body property** and generates a
new view. Let’s take a look at a quick sample.

    
    
    struct ContentView: View {
        @ObservedObject var store: Store
    
        var body: some View {
            Group {
                if store.isLoading {
                    Text("Loading...")
                        .font(.subheadline)
                } else {
                    Image("photo")
                        .font(.largeTitle)
                }
            }
        }
    }
    

As you can see in the example above, we have a view that shows loading text
and image when the loading finishes. _ObserverObject_ here is a state of this
view, and as soon as it changes, SwiftUI recomputes the body property and
assigns a new view. In typical _UIKit_ development, we need manually to
hide/show the elements of the view hierarchy, but in SwiftUI, we don’t need to
add/remove the loading indicator.

> We have a few ways of describing a state of the view in SwiftUI, to learn
> more about them take a look at [ “Understanding Property Wrappers in
> SwiftUI” ](/2019/06/12/understanding-property-wrappers-in-swiftui/) .

Let’s take a more in-depth look at what happens when the view’s state changes.
SwiftUI has a snapshot of the current view hierarchy, and as soon as state
changes, it computes a new view. Finally, SwiftUI applies diffing algorithms
to understand differences and automatically add/remove/update needed views. By
default, SwiftUI uses standard fade in/out transition to show/hide views, but
you can manually change the transition to any animation you want.

> To learn more about transitions and animations in SwiftUI, take a look at my
> [ “Animations in SwiftUI” ](/2019/06/26/animations-in-swiftui/) post.

####  View hierarchy

Let’s talk about view hierarchy now, and how actually SwiftUI renders your
view struct. The very first thing which I want to mention that SwiftUI doesn’t
render your view struct by doing the one-to-one mapping. You can use as many
view containers as you want, but in the end, SwiftUI renders only views that
make sense. It means that you can extract you view logic into small views and
then compose and reuse them across the app. Don’t worry, performance, in this
case, won’t be affected.

The best way to understand the complex view hierarchies in SwiftUI is by
printing its type. SwiftUI uses the static type system of Swift to make
diffing so fast. First of all, it checks the type of the view, and then checks
its values of the view components. I’m not a fan of using reflections in
production code, but it is very helpful during the learning process.

    
    
    print(Mirror(reflecting: ContentView(store: .init()).body))
    // Group<_ConditionalContent<Text, ModifiedContent<Image, _EnvironmentKeyWritingModifier<Optional<Font>>>>>
    

By using _Mirror_ struct, we can print the real type of the _ContentView_ ’s
body and learn how SwiftUI works under the hood.

> To learn more how SwiftUI uses __ConditionalContent_ take a look at my [
> “Structural identity in SwiftUI” ](/2021/12/09/structural-identity-in-
> swiftui/) post.

####  Conclusion

This week we learned the main difference between _UIKit_ and SwiftUI and took
an in-depth look at the diffing algorithm in SwiftUI. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this post. Thanks for reading, and see you next
week!



# Audio graphs in SwiftUI

##  Audio graphs in SwiftUI

29 Sep 2021

Charts and graphs are one of the complicated things in terms of accessibility.
Fortunately, iOS 15 has a new feature called Audio Graphs. This week we will
learn how to build an audio representation for any SwiftUI view presenting a
chart like a custom bar chart view or an image by using the
_accessibilityChartDescriptor_ view modifier.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start by building a simple bar chart view in SwiftUI that displays a set
of data points using vertical bars.

    
    
    struct DataPoint: Identifiable {
        let id = UUID()
        let label: String
        let value: Double
        let color: Color
    }
    

Here we have the _DataPoint_ struct that describes the bar in the bar chart
view. It has id, label, numeric value, and color to fill. Next, we can define
a bar chart view that accepts an array of _DataPoint_ instances and displays
them.

    
    
    struct BarChartView: View {
        let dataPoints: [DataPoint]
    
        var body: some View {
            HStack(alignment: .bottom) {
                ForEach(dataPoints) { point in
                    VStack {
                        RoundedRectangle(cornerRadius: 8, style: .continuous)
                            .fill(point.color)
                            .frame(height: point.value * 50)
                        Text(point.label)
                    }
                }
            }
        }
    }
    

As you can see in the example above, we have the _BarChartView_ that receives
an array of _DataPoint_ instances and display them as rounded rectangles with
different heights in the horizontal stack. I want to appreciate how easily we
were able to build a bar chart view in SwiftUI. Let’s try to use our new
_BarChartView_ with sample data.

    
    
    struct ContentView: View {
        @State private var dataPoints = [
            DataPoint(label: "1", value: 3, color: .red),
            DataPoint(label: "2", value: 5, color: .blue),
            DataPoint(label: "3", value: 2, color: .red),
            DataPoint(label: "4", value: 4, color: .blue),
        ]
    
        var body: some View {
            BarChartView(dataPoints: dataPoints)
                .accessibilityElement()
                .accessibilityLabel("Chart representing some data")
        }
    }
    

Here we create a sample array of _DataPoint_ instances and pass it to the
_BarChartView_ . We also make an accessibility element for the chart and
disable its children’s accessibility information. To improve the accessibility
experience for our chart view, we also added the accessibility label.

> To learn about the basics of accessibility in SwiftUI, take a look at my [
> “Accessibility in SwiftUI” ](/2019/09/10/accessibility-in-swiftui/) post.

Finally, we can start implementing the audio graph feature for our bar chart
view. Audio graphs are available via the rotors menu. To use the rotor, rotate
two fingers on your iOS device’s screen as if you’re turning a dial. VoiceOver
will say the first rotor option. Keep rotating your fingers to hear more
options. Lift your fingers to choose audio graphs. Then flick your finger up
or down on the screen to navigate through it.

Audio graphs allow users to understand and interpret the chart data using
audio components. VoiceOver plays sound with different pitches while moving
through bars in your chart view. VoiceOver uses high pitches for more
significant values and low pitches for small values. These pitches represent
the data in your array.

> To learn about the custom rotor navigation in SwiftUI, take a look at my [
> “Accessibility rotors in SwiftUI” ](/2021/09/14/accessibility-rotors-in-
> swiftui/) post.

Now we can talk about implementing this feature in our _BarChartView_ . First
of all, we have to create a type conforming to the
_AXChartDescriptorRepresentable_ protocol. _AXChartDescriptorRepresentable_
protocol has only one requirement that creates the instance of
_AXChartDescriptor_ type. The instance of the _AXChartDescriptor_ type
represents the data in our chart in the format that VoiceOver can understand
and interact with.

    
    
    extension ContentView: AXChartDescriptorRepresentable {
        func makeChartDescriptor() -> AXChartDescriptor {
            let xAxis = AXCategoricalDataAxisDescriptor(
                title: "Labels",
                categoryOrder: dataPoints.map(\.label)
            )
    
            let min = dataPoints.map(\.value).min() ?? 0.0
            let max = dataPoints.map(\.value).max() ?? 0.0
    
            let yAxis = AXNumericDataAxisDescriptor(
                title: "Values",
                range: min...max,
                gridlinePositions: []
            ) { value in "\(value) points" }
    
            let series = AXDataSeriesDescriptor(
                name: "",
                isContinuous: false,
                dataPoints: dataPoints.map {
                    .init(x: $0.label, y: $0.value)
                }
            )
    
            return AXChartDescriptor(
                title: "Chart representing some data",
                summary: nil,
                xAxis: xAxis,
                yAxis: yAxis,
                additionalAxes: [],
                series: [series]
            )
        }
    }
    
    

All we need to do is conforming to the _AXChartDescriptorRepresentable_
protocol and add the _makeChartDescriptor_ function that returns an instance
of _AXChartDescriptor_ .

First, we define the X and Y axes by using _AXCategoricalDataAxisDescriptor_
and _AXNumericDataAxisDescriptor_ types. We want to use string labels on the
X-axis. That’s why we use the _AXCategoricalDataAxisDescriptor_ type. In the
case of a line chart, we will use the _AXNumericDataAxisDescriptor_ for both
axes.

Next, we use the _AXDataSeriesDescriptor_ type to define points in our chart.
There is the _isContinuous_ parameter that allows us to define different chart
styles. For example, it should be false for bar charts but true for line
charts.

    
    
    struct ContentView: View {
        @State private var dataPoints = [
            DataPoint(label: "1", value: 3, color: .red),
            DataPoint(label: "2", value: 5, color: .blue),
            DataPoint(label: "3", value: 2, color: .red),
            DataPoint(label: "4", value: 4, color: .blue),
        ]
    
        var body: some View {
            BarChartView(dataPoints: dataPoints)
                .accessibilityElement()
                .accessibilityLabel("Chart representing some data")
                .accessibilityChartDescriptor(self)
        }
    }
    

As the last step, we use the _accessibilityChartDescriptor_ view modifier to
set the instance of _AXChartDescriptorRepresentable_ protocol to describe our
chart.

The audio graphs feature is a significant improvement for visually impaired
users. The great thing about the audio graphs feature is that you can use it
with any view you want, even with the image view. All you need is to create
the instance of AXChartDescriptor type. I hope you enjoy the post. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# The power of overlays in SwiftUI

##  The power of overlays in SwiftUI

03 May 2023

An overlay is a view drawing on top of another view. And today, we will talk
about two interesting use cases of using overlays in SwiftUI. One of them
allows us to keep the structural identity of the view, and another one becomes
very handy whenever you build custom navigation transitions.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Keeping structural identity with overlays

Structural identity is the type of identity that SwiftUI uses to understand
your views without an explicit identifier by using your layout description. It
is essential to keep your view hierarchy without unnecessary branches that you
may create using **if** statements in the body of a _ViewBuilder_ closure
because it may hurt the performance of your views and produce state losses.

    
    
    struct ContentView: View {
        @State private var isDownloading = false
        
        var body: some View {
            if isDownloading {
                ProgressView()
            } else {
                DownloadButton("Download") {
                    isDownloading = true
                    // start download here
                    isDownloading = false
                }
            }
        }
    }
    

In the example above, whenever the _isDownloading_ property changes, the
framework creates a new button or new progress view. In the case of our custom
button, it completely loses its state because SwiftUI makes a new one. This
behavior can be unexpected in different scenarios, so avoid branching using
**if** statements in _ViewBuilder_ closures as much as possible.

> To learn more about structural identity in SwiftUI, take a look at my
> dedicated [ “Structural identity in SwiftUI” ](/2021/12/09/structural-
> identity-in-swiftui/) post.

Instead of branching via **if** statements, we can use overlays to keep the
structural identity of the view.

    
    
    struct ContentView: View {
        @State private var isDownloading = false
        
        var body: some View {
            DownloadButton() {
                isDownloading = true
                // start download here
                isDownloading = false
            }
            .disabled(isDownloading)
            .overlay {
                if isDownloading {
                    ProgressView()
                }
            }
        }
    }
    

As you can see in the example above, we use the _overlay_ view modifier to
display the progress view on the top button and disable it by using one of the
inert view modifiers. SwiftUI will never create a new button in this case.

####  Custom transitions with overlays

From the very first day, the SwiftUI framework shows us how easily we can
animate changes in the view hierarchy. Working with SwiftUI to build fluid
animations is super easy. The only downside I can find is the custom
navigation transitions. Unfortunately, there is no way to customize navigation
transitions inside the _NavigationView_ or _NavigationStack_ .

One of the powerful animation tools of the SwiftUI framework, the
_matchedGeomerty_ view modifier, doesn’t support _NavigationView_ and
_NavigationStack_ at the very moment. Fortunately, we can use overlay view
modifiers to build custom navigation transitions without using
_NavigationView_ or _NavigationStack_ .

    
    
    struct ContentView: View {
        @State private var selectedImage: String?
        @Namespace private var hero
    
        let images: [String] = [
            "pencil",
            "trash",
            "lock.doc",
            "person",
            "figure.run"
        ]
    
        var body: some View {
            NavigationStack {
                LazyVGrid(columns: Array(repeating: .init(.flexible()), count: 3)) {
                    ForEach(images, id: \.self) { image in
                        Image(systemName: selectedImage == image ? "" : image)
                            .resizable()
                            .scaledToFit()
                            .background(Material.regular)
                            .matchedGeometryEffect(id: image, in: hero)
                            .onTapGesture {
                                selectedImage = image
                            }
                    }
                }
                .overlay {
                    if let image = selectedImage {
                        Image(systemName: image)
                            .resizable()
                            .scaledToFill()
                            .background(Material.thin)
                            .matchedGeometryEffect(id: image, in: hero)
                            .animation(.easeInOut, value: selectedImage)
                            .onTapGesture {
                                selectedImage = nil
                            }
                    }
                }
            }
            .animation(.default, value: selectedImage)
        }
    }
    

Here is another example where the overlay trick shines. Instead of
_NavigationLink_ , we pair the overlay view modifier with the
_matchedGeomerty_ view modifier. We show the overlay with the matched geometry
animation only when the user makes a selection.

This pair allows us to build super custom navigation transitions like hero
animation. Yes, it adds some work to maintain the navigation state, but it
will enable us to provide an excellent user experience in our apps.

> To learn more about the matchedGeometry view modifier, take a look at my [
> “Hero animations in SwiftUI” ](/2020/12/17/hero-animations-in-swiftui/)
> post.

Today we learned how valuable is the _overlay_ view modifier in SwiftUI, and
with the latest addition allowing us to build overlays by using the
_ViewBuilder_ closure, it became effortless. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Mastering AsyncImage in SwiftUI

##  Mastering AsyncImage in SwiftUI

07 Jul 2021

During our careers, we primarily build apps that work with web services to
retrieve and upload data. Remote image is one type of that data that we need
to download and display. SwiftUI provides us the _AsyncImage_ type, which is a
view that downloads and shows an image via URL. This week we learn how to use
and customize _AsyncImage_ in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s start with a quick example that shows how to use _AsyncImage_ .

    
    
    struct AvatarView: View {
        let url: URL
    
        var body: some View {
            AsyncImage(url: url)
        }
    }
    

As you can see in the example above, _AsyncImage_ is a SwiftUI view that takes
a URL for an image, downloads it, and displays it. There is no need for
additional configuration of the network layer. _AsyncImage_ uses the shared
_URLSession_ to download and cache images. Unfortunately, we can’t provide a
custom _URLCache_ or somehow customize a _URLRequest_ that downloads the
image.

_AsyncImage_ is another SwiftUI view which means you can attach any set of
view modifiers to have the desired look and feel. For example, we can clip the
shape of our image and set the size.

    
    
    struct AvatarView: View {
        let url: URL
    
        var body: some View {
            AsyncImage(url: url)
                .frame(width: 44, height: 44)
                .background(Color.gray)
                .clipShape(Circle())
        }
    }
    

####  Customization

Usually, we need to customize the size of the downloaded image, scaling
options, rendering mode, etc. We can access the instance of underlining image
using another overload of _AsyncImage_ initializer.

    
    
        AsyncImage(url: url) { image in
            image
                .resizable()
                .scaledToFill()
        } placeholder: {
            ProgressView()
        }
        .frame(width: 44, height: 44)
        .background(Color.gray)
        .clipShape(Circle())
    

Here we use another _AsyncImage_ initializer to access the downloaded image,
make it resizable and apply the filling content mode. This initializer also
allows us to provide a placeholder view that SwiftUI displays while
downloading the image.

> To learn more about image rendering options in SwiftUI, take a look at my [
> “Mastering images in SwiftUI” ](/2020/05/27/mastering-images-in-swiftui/)
> post.

Keep in mind that this initializer uses a _ViewBuilder_ closure which means
you can take advantage of any SwiftUI view modifier you need and build a super
custom presentation.

    
    
        AsyncImage(url: url) { image in
            image
                .resizable()
                .scaledToFill()
                .overlay(Material.ultraThin)
        } placeholder: {
            ProgressView()
        }
        .frame(width: 44, height: 44)
        .background(Color.gray)
        .clipShape(Circle())
    

In the example above, we use the _overlay_ view modifier to cover our image
with the ultra-thin material that creates a light blur effect.

> To learn more about the logic behind the ViewBuilder type, take a look at my
> [ “The power of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-
> viewbuilder-in-swiftui/) post.

_AsyncImage_ allows us to take complete control of all the steps of image
presentation using another initializer.

    
    
    struct AvatarView: View {
        let url: URL
    
        var body: some View {
            AsyncImage(
                url: url,
                transaction: Transaction(animation: .easeInOut)
            ) { phase in
                switch phase {
                case .empty:
                    ProgressView()
                case .success(let image):
                    image
                        .resizable()
                        .transition(.scale(scale: 0.1, anchor: .center))
                case .failure:
                    Image(systemName: "wifi.slash")
                @unknown default:
                    EmptyView()
                }
            }
            .frame(width: 44, height: 44)
            .background(Color.gray)
            .clipShape(Circle())
        }
    }
    

As you can see, we use another initializer that accepts a _ViewBuilder_
closure. This closure has only one parameter that is an instance of
_AsyncImagePhase_ enum. _AsyncImagePhase_ enum defines a bunch of image
loading states like _empty, success, and failed_ . You can handle all these
cases to provide super-custom image presentations.

Another parameter of the currently used initializer is the SwiftUI
transaction. By default, _AsyncImage_ creates a new transaction with the
default configuration. In our example, I create a custom transaction with a
particular animation that _AsyncImage_ will use whenever phase changes.

> To learn more about the power of transactions in SwiftUI, take a look at my
> [ “Transactions in SwiftUI” ](/2020/10/07/transactions-in-swiftui/) post.

####  Conclusion

Today we learned how to download and display remote images using _AsyncImage_
view. I’m happy to see that SwiftUI provides us this feature because it is
fundamental for most of the apps we build. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Gradient in SwiftUI

##  Gradient in SwiftUI

13 Nov 2019

One thing which I really enjoy about SwiftUI is the fact that SwiftUI has a
lot of stuff ready to use out of the box. In order to build your app, all you
need to do is composing the building blocks provided by SwiftUI into a fully
functional application. This week we will talk about _Gradient_ , which is
just another type of _View_ in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

As I already said, _Gradient_ is one of the _View_ protocol’s implementations.
You can easily use _Gradient_ anywhere in the app where you can use other
_View_ components like _Text_ or _Button_ . SwiftUI provides three types of
_Gradient_ component. Let’s take a look at them one by one.

####  LinearGradient

_LinearGradient_ is one of the basic types of _Gradient_ . It draws colors
from the start point to the end point. I think the best way to understand
gradients is just writing the code and check the results. Let’s try it.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            LinearGradient(
                gradient: Gradient(colors: [.red, .white]),
                startPoint: .top,
                endPoint: .bottom
            )
        }
    }
    

![example1](/public/l1.png)

As you can see, _LinearGradient_ applies red to white transition from top to
bottom as we pointed it in the code. Start and end points are the cases of
_UnitPoint_ enum. These points can take the following values: _.zero, .center,
leading, trailing, top, bottom, topLeading, topTrailing, bottomLeading,
bottomTrailing_ . SwiftUI uses these unit point values to convert the
declarative description into real coordinates of the view. Let’s check another
unit point values.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            LinearGradient(
                gradient: Gradient(colors: [.red, .white]),
                startPoint: .leading,
                endPoint: .trailing
            )
        }
    }
    

I’ve changed the start and end points to leading and trailing. It will help us
to understand the meaning of unit points better, and here is the result.

![example2](/public/l2.png)

_LinearGradient_ is a commonly used gradient type. You can use it as a
background for a _Text_ component, which you might want to draw ahead of an
_Image_ .

####  RadialGradient

_RadialGradient_ applies color transformation from the defined center point to
its circle edge, which is calculated using the start and end radius. Let’s
take a look at a quick example of _RadialGradient_ .

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            RadialGradient(
                gradient: Gradient(colors: [.orange, .white]),
                center: .center,
                startRadius: 1,
                endRadius: 200
            )
        }
    }
    

![example3](/public/r1.png)

I suggest you play around the _RadialGradient_ with more colors and different
center positions to understand it even better.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            RadialGradient(
                gradient: Gradient(colors: [.orange, .white, .orange, .white]),
                center: .center,
                startRadius: 1,
                endRadius: 200
            )
        }
    }
    

![example4](/public/r2.png)

Sometimes we need to use _RadialGradient_ inside the _GeometryReader_ to
calculate proper radius value relative to the parent’s size. To learn more
about _GeometryReader_ , take a look at [ “Building BarChart with Shape API in
SwiftUI” ](/2019/08/14/building-barchart-with-shape-api-in-swiftui/) post.

####  AngularGradient

The last type of _Gradient_ which we have in SwiftUI is _AngularGradient_ .
I’m not using it very ofter, but it has a very nice color transformation
effect. _AngularGradient_ also is known as the conic _Gradient_ . This
_Gradient_ type applies color transformation as the angle changes, relative to
a center point. Let’s check out the code sample and resulting image.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            AngularGradient(
                gradient: Gradient(colors: [.orange, .white]),
                center: .center
            )
        }
    }
    

![example5](/public/a1.png)

Let’s take a look at a different example by adding more colors to the
_Gradient_ .

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            AngularGradient(
                gradient: Gradient(
                    colors: [
                        .orange, .white, .orange, .white, .orange, .white, .orange, .white, .orange
                    ]
                ),
                center: .center
            )
        }
    }
    

![example6](/public/a2.png)

By default, SwiftUI provides us _AngularGradient_ with start and end angles,
which equal to zero, but you can adjust them by using another overload of the
initializer.

####  Conclusion

This week we learned how to use _Gradients_ in SwiftUI. I usually use only
_LinearGradient_ to cover my images and then put some text on top of them, but
who knows which crazy designs your designer will bring you. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading, and see you next
week!



# Understanding Property Wrappers in SwiftUI

##  Understanding Property Wrappers in SwiftUI

12 Jun 2019

Last week we started a new series of [ posts ](/2019/06/05/swiftui-making-
real-world-app) about SwiftUI framework. Today I want to continue this topic
by covering _Property Wrappers_ provided by SwiftUI. SwiftUI gives us _@State_
, _@Binding_ , _@ObservedObject_ , _@EnvironmentObject_ , and _@Environment_
_Property Wrappers_ . So let’s try to understand the differences between them
and when and why which one we have to use.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Property Wrappers

_Property Wrappers_ feature described in [ SE-0258
](https://github.com/DougGregor/swift-evolution/blob/property-
wrappers/proposals/0258-property-wrappers.md) proposal. The main goal here is
wrapping properties with logic which can be extracted into the separated
struct to reuse it across the codebase.

####  @State

_@State_ is a _Property Wrapper_ which we can use to describe _View_ ’s state.
SwiftUI will store it in special internal memory outside of _View_ struct.
Only the related _View_ can access it. As soon as the value of @ _State_
property changes SwiftUI rebuilds _View_ to respect state changes. Here is a
simple example.

    
    
    struct ProductsView: View {
        let products: [Product]
    
        @State private var showFavorited: Bool = false
    
        var body: some View {
            List {
                Button(
                    action: { self.showFavorited.toggle() },
                    label: { Text("Change filter") }
                )
    
                ForEach(products) { product in
                    if !self.showFavorited || product.isFavorited {
                        Text(product.title)
                    }
                }
            }
        }
    }
    

In the example above we have a straightforward screen with _Button_ and _List_
of products. As soon as we press the button, it changes the value of the state
property, and SwiftUI recreates _View_ .

####  @Binding

@ _Binding_ provides _reference_ like access for a **value** type. Sometimes
we need to make the state of our _View_ accessible for its children. But we
can’t simply pass that value because it is a value type and Swift will pass
the copy of that value. And this is where we can use _@Binding Property
Wrapper_ .

    
    
    struct FilterView: View {
        @Binding var showFavorited: Bool
    
        var body: some View {
            Toggle(isOn: $showFavorited) {
                Text("Change filter")
            }
        }
    }
    
    struct ProductsView: View {
        let products: [Product]
    
        @State private var showFavorited: Bool = false
    
        var body: some View {
            List {
                FilterView(showFavorited: $showFavorited)
    
                ForEach(products) { product in
                    if !self.showFavorited || product.isFavorited {
                        Text(product.title)
                    }
                }
            }
        }
    }
    

We use @ _Binding_ to mark _showFavorited_ property inside the _FilterView_ .
We also use _$_ to pass a binding reference, because without _$_ Swift will
pass a copy of the value instead of passing bindable reference. _FilterView_
can read and write the value of _ProductsView_ ’s _showFavorited_ property. As
soon as _FilterView_ changes value of _showFavorited_ property, SwiftUI will
recreate the _ProductsView_ and _FilterView_ as its child.

> @ _Binding_ provides a _reference_ like access for a ` value ` type. That’s
> why it should be used only with value types. If ` Value ` of Binding is not
> value semantic, the updating behavior for any views that make use of the
> resulting ` Binding ` is unspecified.

####  @ObservedObject

We should use @ _ObservedObject_ to handle data that lives outside of SwiftUI,
like your business logic. We can share it between multiple independent _Views_
which can subscribe and observe changes on that object, and as soon as changes
appear SwiftUI rebuilds all _Views_ bound to this object. Let’s take a look at
an example.

    
    
    import Combine
    
    final class PodcastPlayer: ObservableObject {
        @Published private(set) var isPlaying: Bool = false
    
        func play() {
            isPlaying = true
        }
    
        func pause() {
            isPlaying = false
        }
    }
    

Here we have _PodcastPlayer_ class which we share between the screens of our
app. Every screen has to show floating pause button in the case when the app
is playing a podcast episode. SwiftUI tracks the changes on _ObservableObject_
with the help of _@Published_ property wrapper, and as soon as a property
marked as _@Published_ changes SwiftUI rebuild all _Views_ bound to that
_PodcastPlayer_ object. Here we use _@ObservedObject Property Wrapper_ to bind
our _EpisodesView_ to _PodcastPlayer_ class

    
    
    struct EpisodesView: View {
        @ObservedObject var player: PodcastPlayer
        let episodes: [Episode]
    
        var body: some View {
            List {
                Button(
                    action: {
                        if self.player.isPlaying {
                            self.player.pause()
                        } else {
                            self.player.play()
                        }
                }, label: {
                        Text(player.isPlaying ? "Pause": "Play")
                    }
                )
                ForEach(episodes) { episode in
                    Text(episode.title)
                }
            }
        }
    }
    

> Remember, we can share ` ObservableObject ` between multiple views, that’s
> why it must be a ` reference type/class ` .

####  @EnvironmentObject

Instead of passing _ObservableObject_ via init method of our View we can
implicitly inject it into _Environment_ of our _View_ hierarchy. By doing
this, we create the opportunity for all child _Views_ of current _Environment_
access this _ObservableObject_ .

    
    
    class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    
        var window: UIWindow?
    
        func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
            let window = UIWindow(frame: UIScreen.main.bounds)
            let episodes = [
                Episode(id: 1, title: "First episode"),
                Episode(id: 2, title: "Second episode")
            ]
    
            let player = PodcastPlayer()
            window.rootViewController = UIHostingController(
                rootView: EpisodesView(episodes: episodes)
                    .environmentObject(player)
            )
            self.window = window
            window.makeKeyAndVisible()
        }
    }
    
    struct EpisodesView: View {
        @EnvironmentObject var player: PodcastPlayer
        let episodes: [Episode]
    
        var body: some View {
            List {
                Button(
                    action: {
                        if self.player.isPlaying {
                            self.player.pause()
                        } else {
                            self.player.play()
                        }
                }, label: {
                        Text(player.isPlaying ? "Pause": "Play")
                    }
                )
                ForEach(episodes) { episode in
                    Text(episode.title)
                }
            }
        }
    }
    

As you can see, we can pass _PodcastPlayer_ object via _environmentObject_
modifier of our _View_ . By doing this, we can easily access _PodcastPlayer_
by defining it with _@EnvironmentObject Property Wrapper_ . @
_EnvironmentObject_ uses dynamic member lookup feature to find _PodcastPlayer_
class instance in the _Environment_ , that’s why you don’t need to pass it via
init method of _EpisodesView_ . It works like magic.

####  @Environment

As we discussed in the previous chapter, we can pass custom objects into the
_Environment_ of a _View_ hierarchy inside SwiftUI. But SwiftUI already has an
_Environment_ populated with system-wide settings. We can easily access them
with _@Environment Property Wrapper_ .

    
    
    struct CalendarView: View {
        @Environment(\.calendar) var calendar: Calendar
        @Environment(\.locale) var locale: Locale
        @Environment(\.colorScheme) var colorScheme: ColorScheme
    
        var body: some View {
            return Text(locale.identifier)
        }
    }
    

By marking our properties with _@Environment Property Wrapper_ , we access and
subscribe to changes of system-wide settings. As soon as _Locale_ , _Calendar_
or _ColorScheme_ of the system change, SwiftUI recreates our _CalendarView_ .

> To learn about new property wrappers released during WWDC20, take a look at
> my [ “New property wrappers in SwiftUI”
> ](https://swiftwithmajid.com/2020/06/29/new-property-wrappers-in-swiftui/)
> post.

####  Conclusion

Today we talked about _Property Wrappers_ provided by SwiftUI. _@State,
@Binding, @EnvironmentObject, @Environment and @ObservedObject_ play huge role
in SwiftUI development. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# File importing and exporting in SwiftUI

##  File importing and exporting in SwiftUI

10 May 2023

A few weeks ago, we talked about photo and video picking in SwiftUI. Today we
will continue the topic and learn how to import and export files in SwiftUI
views. Fortunately, it is straightforward to do with the help of new
_fileImporter_ and _fileExporter_ view modifiers.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Import

The SwiftUI framework provides us the _fileImporter_ view modifier allowing us
to enable file-picking user experience easily. It completely handles the
dialog and navigation between folders. Let’s take a look at how we can use it.

    
    
    struct ImportingExampleView: View {
        @State private var importing = false
        
        var body: some View {
            Button("Import") {
                importing = true
            }
            .fileImporter(
                isPresented: $importing,
                allowedContentTypes: [.plainText]
            ) { result in
                switch result {
                case .success(let file):
                    print(file.absoluteString)
                case .failure(let error):
                    print(error.localizedDescription)
                }
            }
        }
    }
    

As you can see in the example above, we attach the _fileImporter_ view
modifier to a button that toggles the _importing_ property, which we use as a
binding to enable the file-picking experience. We also use the
_allowedContentTypes_ parameter on the _fileImporter_ view modifier to pass an
array of allowed file types. In the completion closure, we can handle the
result and extract the URL of the selected file.

####  Export

Exporting files works in a very similar way, but we also should provide a
document that we are going to export. In this case, the document type should
conform to the _FileDocument_ protocol.

    
    
    struct TextDocument: FileDocument {
        static var readableContentTypes: [UTType] {
            [.plainText]
        }
        
        var text = ""
        
        init(text: String) {
            self.text = text
        }
        
        init(configuration: ReadConfiguration) throws {
            if let data = configuration.file.regularFileContents {
                text = String(decoding: data, as: UTF8.self)
            } else {
                text = ""
            }
        }
        
        func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
            FileWrapper(regularFileWithContents: Data(text.utf8))
        }
    }
    

Here we define the _TextDocument_ type conforming to the _FileDocument_
protocol. As you can see, it implements plain string reading from a file and
allows us to export string data to the file. Now we can use the _fileExporter_
view modifier to export an instance of the _TextDocument_ type.

    
    
    struct ExportingExampleView: View {
        @State private var exporting = false
        @State private var document = TextDocument(text: "")
        
        var body: some View {
            TextEditor(text: $document.text)
                .toolbar {
                    Button("Export") {
                        exporting = true
                    }
                    .fileExporter(
                        isPresented: $exporting,
                        document: document,
                        contentType: .plainText
                    ) { result in
                        switch result {
                        case .success(let file):
                            print(file)
                        case .failure(let error):
                            print(error)
                        }
                    }
                }
        }
    }
    

As you can see in the example above, we use the _fileExporter_ view modifier
to enable file exporting user experience. It also needs binding to a boolean
value to present the dialog. We must also pass the document we want to export
and its content type. In the completion closure, we can verify that the
document was exported correctly or check the reason for a failure.

####  File moving

As a bonus, the SwiftUI framework provides us with the _fileMover_ view
modifier, enabling a file-moving experience for our users.

    
    
    struct MovingExampleView: View {
        @State private var moving = false
        let file: URL
        
        var body: some View {
            Button("Move files") {
                moving = true
            }
            .fileMover(isPresented: $moving, file: file) { result in
                switch result {
                case .success(let file):
                    print(file.absoluteString)
                case .failure(let error):
                    print(error.localizedDescription)
                }
            }
        }
    }
    

In the example above, we use the _fileMover_ view modifier to present the
file-moving dialog to the user. We should pass the file URL we want to move
and can verify the result in the completion closure.

> To learn about photo and video picking in SwiftUI, take a look at my [
> “PhotosPicker in SwiftUI” ](/2023/04/25/photospicker-in-swiftui/) post.

Today we learned how to move, export and import files in SwiftUI views using a
set of view modifiers. I enjoy the API it provides and how easy we can enable
file management experience in our apps. I hope you enjoy the post. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Window management in SwiftUI

##  Window management in SwiftUI

02 Nov 2022

One of the significant additions to the current iteration of the SwiftUI
framework was window management APIs. We can open a separate window using the
new environment APIs and create a menu bar app using the new scene APIs. This
week we will learn how to use new window management APIs in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Multiple windows support

You can always check whenever the platform you are running supports multiple
window environments using the _supportsMultipleWindows_ environment value.

    
    
    struct ContentView: View {
        @Environment(\.supportsMultipleWindows)
        private var supportsMultipleWindows
        
        var body: some View {
            if supportsMultipleWindows {
                Text("Supports multiple windows")
            } else {
                Text("Doesn't support multiple windows")
            }
        }
    }
    

####  Single window

SwiftUI provides a new scene type to define a single window on macOS.

    
    
    @main struct MyApp: App {
        var body: some Scene {
            #if os(macOS)
            Window("Statistics", id: "stats") {
                StatisticsView()
            }
            #endif
            
            WindowGroup {
                ContentView()
            }
        }
    }
    
    

As you can see in the example above, we use the new Window scene type to
define a single window assigned to a particular identifier. Now we can use the
_openWindow_ environment value to open a window with the dedicated identifier.

    
    
    struct ContentView: View {
        @Environment(\.openWindow) private var openWindow
        
        var body: some View {        
            Button("Open statistics") {
                openWindow(id: "stats")
            }
        }
    }
    

> To learn more about scenes in SwiftUI, take a look at my dedicated [
> “Managing scenes in SwiftUI” ](/2020/08/26/managing-scenes-in-swiftui/)
> post.

####  Window group

Another addition to the scene API is the new overload of the _WindowGroup_
scene type allowing us to register a window group displaying items by
identifier.

    
    
    @main struct MyApp: App {
        var body: some Scene {
            #if os(macOS)
            WindowGroup(for: Item.ID.self) { $itemId in
                ItemView(itemId: itemId ?? UUID())
            }
            #endif
            
            WindowGroup {
                ContentView()
            }
        }
    }
    

In the example above, we register a window group for a particular identifier
type. Now we can use the same environment value to open a window by providing
an item identifier.

    
    
    struct ContentView: View {
        @Environment(\.openWindow) private var openWindow
        
        let items: [Item]
        
        var body: some View {
            List(items) { item in
                Button("open \(item.title)") {
                    openWindow(id: "item", value: item.id)
                }
            }
        }
    }
    

####  Window styling

The SwiftUI framework provides a few ways of styling windows using view
modifiers. First, we can display or hide the title of the window by applying
the _windowStyle_ view modifier. It accepts _hiddenTitleBar_ or _titleBar_
values. This view modifier should be used on the window itself.

Another option is to use the _presentedWindowStyle_ view modifier on the view
hierarchy, which will set the particular style for windows created by this
view hierarchy.

####  Menubar window

Menu bar apps are very popular on macOS, and now we have a native way to build
them in SwiftUI. There is a new scene type called _MenuBarExtra_ . It appears
in the system menu bar and presents its content in a pull-down menu.

    
    
    @main struct MyApp: App {
        var body: some Scene {
            #if os(macOS)
            MenuBarExtra {
                MenuBarView()
            } label: {
                Label("MyApp", systemImage: "star")
            }
            #endif
            
            WindowGroup {
                ContentView()
            }
        }
    }
    

You can control the visibility of the menu bar icon via another overload
accepting a boolean binding.

    
    
    @main struct MyApp: App {
        @State private var menuBarExtraShown = true
        
        var body: some Scene {
            #if os(macOS)
            MenuBarExtra(isInserted: $menuBarExtraShown) {
                MenuBarView()
            } label: {
                Label("MyApp", systemImage: "star")
            }
            #endif
            
            WindowGroup {
                ContentView()
            }
        }
    }
    
    

Menu bar apps can render their content as a menu or inside a dedicated window.
You can control this behavior using the _menuBarExtraStyle_ view modifier.

    
    
    @main struct MyApp: App {
        @State private var menuBarExtraShown = true
        
        var body: some Scene {
            #if os(macOS)
            MenuBarExtra(isInserted: $menuBarExtraShown) {
                MenuBarView()
            } label: {
                Label("MyApp", systemImage: "star")
            }
            .menuBarExtraStyle(.window)
            #endif
            
            WindowGroup {
                ContentView()
            }
        }
    }
    

####  Conclusion

Today we learned how to use new APIs to manage windows in SwiftUI. The
declarative approach we used to see for views is working for high-level
concepts like windows now. Feel free to use it to build iOS, iPadOS, and macOS
apps in a single codebase. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# SwiftUI wishlist for WWDC20

##  SwiftUI wishlist for WWDC20

10 Jun 2020

We already started collecting our questions for Apple engineers. On the other
hand, I decided to share with you my SwiftUI wishlist for WWDC20. This week we
will talk about possible additions and changes in SwiftUI. I will show you
also _API_ that I expect to see during the next release of SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  ScrollView

_ScrollView_ has a bunch of bugs right now. I believe Apple will fix all of
them, but I also hope for a content offset binding option. There is no way to
get or set the current content offset of _ScrollView_ in SwiftUI. We need a
way to both assign and read the offset, and it is a perfect use-case for a
_Binding_ . Let’s take a look at the quick example.

    
    
    struct RootView: View {
        @State private var offset: CGPoint = .zero
    
        var body: some View {
            ScrollView(.vertical, showsIndicators: false, offset: $offset) {
                Text("Very long text")
                Button("Jump to top") {
                    self.offset = .zero
                }
            }
        }
    }
    

####  CollectionView and CompositionalLayout

Last year Apple released _CompositionLayout_ that provides us a declarative
way of building complex layouts for _UICollectionView_ . The buzzword here is
**declarative** . It feels very natural for SwiftUI to have a similar _API_ ,
I’m not sure why Apple didn’t release it last year, but I expect to see it
soon.

_CompositionalLayout_ introduces a few concepts to manage complex layouts. For
example, it has sections, groups, and items. As you know, we already have
these concepts in SwiftUI. I think SwiftUI views like _Group_ and _Section_
can behave in another way depending on the context. We already saw that views
can behave differently inside a _Form_ or a _List_ . Let’s take a look at how
it might work in SwiftUI.

    
    
    struct AppStoreView: View {
        let featured: [App]
        let appsWeLove: [App]
    
        var body: some View {
            CompositionalLayout {
                Section(.groupPagingCentered) {
                    Group(.horizontal, width: .fractionalWidth(0.5), height: .fractionalHeight(0.5)) {
                        ForEach(featured) { app in
                            FeatureAppView(app: app)
                        }
                    }
                }
    
                Section {
                    Group(.vertical, width: .fractionalWidth(0.9), height: .estimated(200)) {
                        ForEach(appsWeLove) { app in
                            SmallAppView(app: app)
                        }
                    }
                }
            }
        }
    }
    

####  Navigation

As I already said multiple times, _Navigation_ in SwiftUI is really
problematic. The main rule behind the SwiftUI framework is _“view is a
function of some state”_ . SwiftUI doesn’t apply this rule to _Navigation_ .
_Navigation_ in SwiftUI looks like uncontrollable magic. In my opinion, it
also should be a function of a state where the state describes a navigation
stack. Let’s take a look at the example.

    
    
    enum Destination {
        case master
        case details(Post)
    }
    
    struct RootView: View {
        @EnvironmentObject var router: Router<Destination>
    
        var body: some View {
            RouterView(router: router) { destination in
                switch destination {
                case .master:
                    return PostsView()
                case .details(let post):
                    return PostDetails(post: post)
                }
            }
        }
    }
    

As you can see, _RouterView_ accepts an instance of the _Router_ class, which
describes a navigation stack and a _ViewBuilder_ closure that we use to build
a view according to the navigation state.

> To learn more about _@ViewBuilder_ in SwiftUI, take a look at my [ “The
> power of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-viewbuilder-in-
> swiftui/) post.

####  Appearance API

SwiftUI provides us styling options by introducing a bunch of protocols. For
example, _ButtonStyle_ , _ToggleStyle_ , etc. We create a struct that conforms
to the _ButtonStyle_ protocol. After that, we can put it into the environment,
and all views inside the environment gain particular styling. I appreciate the
way styling works in SwiftUI right now, but we need to expand it to support
more views like Form and _NavigationView_ .

> To learn more about styling in SwiftUI, take a look at my [ “Composable
> styling in SwiftUI” ](/2019/08/28/composable-styling-in-swiftui/) post.

####  Missing views

SwiftUI provides us a set of very basic views that we can use to build our
apps. There are a lot of views that we don’t have in SwiftUI. I hope to see a
bunch of new views coming in the next weeks. For example, _SearchBar_ ,
_TextView_ , _RefreshControl_ , etc.

####  Conclusion

This week, I share my vision and expectations with you about the future of the
SwiftUI framework that we hopefully will see later this month. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# FocusedValue and FocusedBinding property wrappers in SwiftUI

##  FocusedValue and FocusedBinding property wrappers in SwiftUI

03 Mar 2021

The last year Apple has done a great job in terms of focus management in
SwiftUI. We got a few new modifiers to set up an entry point for the focus
system and programmatically handle focus changes. We still have some gaps, and
I hope Apple will fill them during WWDC21. This week I want to talk about
_FocusedValue_ , _FocusedObject_ , and _FocusedBinding_ property wrappers.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  FocusedValue

_FocusedValue_ property wrapper allows us to observe the value from the
focused view or one of its ancestors. It works in a very similar way to the
_Environment_ property wrapper, but instead of observing the environment, it
observes the view hierarchy’s focused view.

> To learn more about the basics of focus management in SwiftUI, take a look
> at my dedicated [ post ](/2020/12/02/focus-management-in-swiftui/) .

To start using this feature, you should first create a struct that conforms to
_FocusedValueKey_ to define the type of value you want to observe. Assume that
we are working on the note-taking app, and we want to monitor the content of
the focused note editor. Let’s try to implement this.

    
    
    struct FocusedNoteValue: FocusedValueKey {
        typealias Value = String
    }
    

As you can see in the example above, we create the _FocusedNoteValue_ struct
and conform to the _FocusedValueKey_ protocol. The only thing we need to do is
adding a type alias for the _Value_ type. The _Value_ type here is our content
that we want to observe when a view is focused. In our case, it is _String_
because we want to monitor the note that the user edits at the moment.

    
    
    extension FocusedValues {
        var noteValue: FocusedNoteValue.Value? {
            get { self[FocusedNoteValue.self] }
            set { self[FocusedNoteValue.self] = newValue }
        }
    }
    

Here we provide an extension for _FocusedValues_ where we register a getter
and setter for our custom focused value. Make sure it is optional. SwiftUI set
it to nil when the view is not focused.

> To learn more about providing custom values via SwiftUI’s Environment, take
> a look at my [ “The power of Environment in SwiftUI” ](/2019/08/21/the-
> power-of-environment-in-swiftui/) post.
    
    
    struct ContentView: View {
        var body: some View {
            Group {
                NoteEditor()
                NotePreview()
            }.border(Color.red)
        }
    }
    
    struct NoteEditor: View {
        @State private var note = "text"
    
        var body: some View {
            TextEditor(text: $note)
                .frame(width: 300, height: 300)
                .focusedValue(\.noteValue, note)
        }
    }
    
    struct NotePreview: View {
        @FocusedValue(\.noteValue) var note
    
        var body: some View {
            Text(note ?? "Note is not focused")
        }
    }
    

Here we have the _ContentView_ with _NoteEditor_ that uses a binding from the
view state to store the note content. We use the _focusedValue_ modifier to
save note content into the special memory that SwiftUI control and only assign
when the view is focused.

We also define the _NotePreview_ view. _NotePreview_ uses the _FocusedValue_
property wrapper to monitor the content of the focused note. SwiftUI will set
the value of _FocusedValue_ to _nil_ as soon as the view loses the focus.

You can use the _focusedSceneValue_ view modifier whenever you need to share
focused value between views in different scenes.

####  FocusedObject

The _FocusedValue_ property wrapper and view modifier works great for value
types. But if you need this behavior for a class conforming to the
_ObservableObject_ protocol you can use the pair of the _focusedObject_ view
modifier and _FocusedObject_ property wrapper.

You can use the _focusedSceneObject_ view modifier whenever you need to share
focused object between views in different scenes.

####  FocusedBinding

OK, we learned how to pass a read-only value for a recently focused note. But
what if we want to modify it? For example, we can have a _NoteFormatter_ view
that formats the note’s content and overrides it. We can’t achieve it with the
_FocusedValue_ property wrapper because it provides us a get-only value.

In this case, we can use the _FocusedBinding_ property wrapper. It works in
the very same way, but instead of the read-only value, it provides a binding
that we can use to override the content. Let’s start by extending the
_FocusedValues_ struct with a custom key for note content binding.

    
    
    struct FocusedNoteBinding: FocusedValueKey {
        typealias Value = Binding<String>
    }
    
    extension FocusedValues {
        var noteBinding: FocusedNoteBinding.Value? {
            get { self[FocusedNoteBinding.self] }
            set { self[FocusedNoteBinding.self] = newValue }
        }
    }
    

Now we can create the _NoteFormatter_ view, which uses the _FocusedBinding_
property wrapper, and override the note content using the binding.

    
    
    struct ContentView: View {
        var body: some View {
            Group {
                NoteEditor()
                NoteFormatter()
            }.border(Color.red)
        }
    }
    
    struct NoteEditor: View {
        @State private var note = "text"
    
        var body: some View {
            TextEditor(text: $note)
                .frame(width: 300, height: 300)
                .focusedValue(\.noteBinding, $note)
        }
    }
    
    struct NoteFormatter: View {
        @FocusedBinding(\.noteBinding) var note
    
        var body: some View {
            VStack {
                Text(note ?? "Note is not focused")
                Button("Clear note") {
                    note = ""
                }
            }
        }
    }
    

####  Conclusion

Today we learned how to use _FocusedValue_ , _FocusedObject_ , and
_FocusedBinding_ property wrappers. One of the possible use cases for these
property wrappers is commands that we can use to create the main menu for
macOS apps. You can access the currently focused view’s content and implement
some logic that lives in your macOS app’s main menu.

> To learn more about building the main menu for macOS apps, take a look at my
> [ “Commands in SwiftUI” ](/2020/11/24/commands-in-swiftui/) post.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# How to use GeometryReader without breaking SwiftUI layout

##  How to use GeometryReader without breaking SwiftUI layout

04 Nov 2020

Usually, I try to avoid _GeometryReader_ as much as I can. But sometimes, we
need it to build our custom view. This week we will talk about
_GeometryReader_ . The view that allows us to read its geometry and layout
child views manually.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s start with a quick example of _GeometryReader_ usage.

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            GeometryReader { geometry in
                Text("Hello!")
                    .frame(
                        width: geometry.size.width,
                        height: geometry.size.height
                    ).background(Color.red)
            }
        }
    }
    

Here we have a _GeometryReader_ in the root of our _ContentView_ . By default,
_GeometryReader_ places its children in the top left corner, which is very
unusual for SwiftUI views. Usually, SwiftUI views place content in the center
of its coordinate space.

As you can see, _GeometryReader_ ’s @ _ViewBuilder_ closure has the parameter
called geometry. This parameter is an instance of _GeometryProxy_ struct. You
can use an instance of _GeometryProxy_ to access information about the
coordinate space using the following properties.

  1. _size_ \- The size of space available to _GeometryReader_ . 
  2. _safeAreaInsets_ \- An instance of _EdgeInsets_ struct that provides safe area insets of _GeometryReader_ . 

    
    
    import SwiftUI
    
    struct ContentView: View {
        var body: some View {
            GeometryReader { geometry in
                Text("Hello!")
                    .frame(
                        width: geometry.frame(in: .global).width,
                        height: geometry.frame(in: .global).height
                    ).background(Color.red)
            }
        }
    }
    

_GeometryProxy_ also has a _frame_ function that allows you to access the
frame of the _GeometryReader_ by converting it into a correct coordinate
space. You can also create your own coordinate spaces by using
_coordinateSpace_ modifier on any view.

> Take a look at [ “Building Bottom sheet in SwiftUI” ](/2019/12/11/building-
> bottom-sheet-in-swiftui/) post to learn more about advanced usages of
> _GeometryReader_ .

####  Hints to follow while using GeometryReader

Now we know how to use _GeometryReader_ and its benefits. It is a perfect time
to talk about its disadvantages. _GeometryReader_ fills all the available
space, and usually, it is not something you want to achieve.

If you use _GeometryReader_ as a full-screen view, that is great, and you
don’t need to do anything. In other cases, try to limit the available space of
_GeometryReader_ by using _frame_ or _aspectRatio_ modifiers. These modifiers
allow you to keep _GeometryReader_ under control.

The second tip is to use _GeometryReader_ inside an overlay or background of
any view. SwiftUI keeps overlay and background views in the same size as the
view that you apply them. It limits the size of _GeometryReader_ and doesn’t
allow it to grow and fill all the available space.

> To learn more about this approach, take a look at [ “The magic of view
> preferences in SwiftUI” ](/2020/01/15/the-magic-of-view-preferences-in-
> swiftui/) post.

In case when you need to draw something, you can replace the _GeometryReader_
by using Shape API. Shape API provides you all the needed information about
available space using _Path_ struct.

> To learn more about Shape API, look at [ “Building BarChart with Shape API
> in SwiftUI” ](/2019/08/14/building-barchart-with-shape-api-in-swiftui/)
> post.

####  Conclusion

I suggest you avoid _GeometryReader_ where you can. In the case where you sure
that you need it, try to follow my tips. These tips should save many hours of
debugging the SwiftUI layout. I hope you enjoy the post. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this article. Thanks for reading, and see you next week!



# The many faces of ShapeStyle in SwiftUI

##  The many faces of ShapeStyle in SwiftUI

17 Nov 2021

_ShapeStyle_ is the protocol that we have from the very first release of the
SwiftUI framework. _ShapeStyle_ defines a color or pattern to use when
rendering a shape. This week we will learn the many faces of _ShapeStyle_
protocol and different implementations provided by the SwiftUI framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Colors

Usually, we don’t use the _ShapeStyle_ protocol itself. We use the many
implementations of the protocol that SwiftUI provides us. One of them is the
_Color_ struct. We can use an instance of the _Color_ struct to fill or stroke
a shape in SwiftUI. Let’s take a look at the quick example.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(Color.yellow)
                Circle()
                    .stroke(Color.green, lineWidth: 16)
            }
            .padding(32)
        }
    }
    

![color-shape-style](/public/shapestyle.png)

We can also use a _ShapeStyle_ as a background or overlay for any view.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Text("Hello, World!")
                    .background(Color.red)
            }
            .padding(32)
        }
    }
    

####  Gradients

Another implementation of the _ShapeStyle_ protocol is gradients. You can use
gradients anywhere in SwiftUI to provide an instance of the _ShapeStyle_
protocol.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [.green, .yellow],
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
            }
            .padding(32)
        }
    }
    

![color-shape-style](/public/shapestyle1.png)

> To learn more about gradients, take a look at my dedicated [ “Gradient in
> SwiftUI” ](/2019/11/13/gradient-in-swiftui/) post.

####  Hierarchical

SwiftUI provides us a shape style that maps to one of the numbered content
styles. It has a few static instances: _primary, secondary, tertiary,
quaternary_ . You can use one of them whenever you need to use the
hierarchical styling of the content.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(.quaternary)
            }
            .padding(32)
        }
    }
    

####  Selection

There is a special implementation of the _ShapeStyle_ protocol called
_SelectionShapeStyle_ that defines the platform-oriented selection styling.
You can use it whenever you need to highlight the selected state of the view.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(SelectionShapeStyle())
            }
            .padding(32)
        }
    }
    

####  Tint

_TintShapeStyle_ is another implementation of the _ShapeStyle_ protocol that
uses the tint color. SwiftUI uses the app’s accent color by default, but you
can override it using the _tint_ view modifier.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(TintShapeStyle())
            }
            .tint(Color.yellow)
            .padding(32)
        }
    }
    

####  Background

_BackgroundStyle_ type is the implementation of the _ShapeStyle_ protocol that
defines the background style in the current context. You can use it to adapt
both dark and light themes.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(BackgroundStyle())
            }
            .padding(32)
        }
    }
    

####  Foreground

_ForegroundStyle_ type is similar to the _BackgroundStyle_ type but instead
defines the foreground style of the current context. This one also works both
in dark and light themes.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(ForegroundStyle())
            }
            .padding(32)
        }
    }
    

####  Material

Materials in SwiftUI conform to the _ShapeStyle_ protocol also. It means you
can use provided materials as the instance of _ShapeStyle_ protocol anywhere
in SwiftUI.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(Material.ultraThin)
            }
            .padding(32)
        }
    }
    

> To learn more about materials, take a look at my dedicated [ “Blur effect
> and materials in SwiftUI” ](/2021/10/28/blur-effect-and-materials-in-
> swiftui/) post.

####  ImagePaint

_ImagePaint_ type implements the _ShapeStyle_ protocol and fills a shape by
repeating a region of an image.

    
    
    struct ContentView: View {
        var body: some View {
            ZStack {
                Circle()
                    .fill(ImagePaint(image: Image(systemName: "star")))
            }
            .padding(32)
        }
    }
    

> To learn more about images in SwiftUI, take a look at my dedicated [
> “Mastering images in SwiftUI” ](/2021/11/17/the-many-faces-of-shapestyle-in-
> swiftui/) post.

####  AnyShapeStyle

The last but not least type that conforms to the _ShapeStyle_ protocol is the
_AnyShapeStyle_ type. _AnyShapeStyle_ is the type-erased implementation of the
_ShapeStyle_ protocol that allows us to pass styles without using generics.

    
    
    struct AvatarView: View {
        let style: AnyShapeStyle
    
        var body: some View {
            Circle()
                .fill(style)
        }
    }
    
    let style = AnyShapeStyle(TintShapeStyle())
    let avatarView = AvatarView(style: style)
    

####  Conclusion

Today we learned how to use the _ShapeStyle_ protocol and the many
implementations that SwiftUI provides us. I hope you enjoy the post. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Optimizing views in SwiftUI using EquatableView

##  Optimizing views in SwiftUI using EquatableView

22 Jan 2020

SwiftUI provides us a very fast and easy to use diffing algorithm, but as you
might know, diffing is a linear operation. It means that diffing will be very
fast for simple layouts and can take some time for a complicated layout.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

I have good news for you. SwiftUI allows us to replace the standalone diffing
algorithm with our custom logic. This week we will talk about optimizing our
SwiftUI layouts using the equatable modifier.

####  Diffing in SwiftUI

As you remember, we already talked about diffing in SwiftUI, but let me remind
how it works. Whenever you change the source of truth for your views like
_@State_ or _@ObservableObject_ , SwiftUI runs _body_ property of your view to
generate a new one. As the last step, SwiftUI renders a new view if something
changed. The process of calculating a new _body_ depends on how deep is your
view hierarchy. Happily, we can replace SwiftUI diffing with our simplified
version whenever we know the better way to determine changes.

> To learn more about diffing, take a look at [ “You have to change mindset to
> use SwiftUI” post ](/2019/11/19/you-have-to-change-mindset-to-use-swiftui/)
> .

####  EquatableView

Sometimes we don’t need the true diffing of SwiftUI, or we want to ignore some
changes in data, and this is the exact place where we can use the
_EquatableView_ struct. _EquatableView_ struct is a wrapper for a _View_ , and
it also conforms to _View_ protocol. All you need to do to use _EquatableView_
is conforming your view to _Equatable_ protocol. Let’s take a simple look at a
good example.

    
    
    struct CalendarView: View, Equatable {
        let sleeps: [Date: [Sleep]]
        let dates: [Date]
    
        var body: some View {
            List {
                ForEach(dates, id: \.self) { date in
                    Section(header: Text("\(date, formatter: DateFormatter.mediumDate)")) {
                        ForEach(self.sleeps[date, default: []], id: \.id) { sleep in
                            CalendarRow(sleep: sleep)
                        }
                    }
                }
            }.listStyle(GroupedListStyle())
        }
    }
    

In the example above, you see the code from my NapBot app. It is a calendar
view that represents your sleep per day. I decide to replace SwiftUI diffing
with my own by adding _Equatable_ conformance. As you can see, it is a
straightforward process. You can go further by overriding _== function_ and
adding your custom logic there.

    
    
    struct CalendarView: View, Equatable {
        let sleeps: [Date: [Sleep]]
        let dates: [Date]
    
        var body: some View {
            List {
                ForEach(dates, id: \.self) { date in
                    Section(header: Text("\(date, formatter: DateFormatter.mediumDate)")) {
                        ForEach(self.sleeps[date, default: []], id: \.id) { sleep in
                            CalendarRow(sleep: sleep)
                        }
                    }
                }
            }.listStyle(GroupedListStyle())
        }
    
        static func == (lhs: Self, rhs: Self) -> Bool {
            lhs.sleeps.count == rhs.sleeps.count
        }
    }
    

Now we can wrap our _CalendarView_ with _EquatableView_ .

**Remember, you have to wrap your view with EquatableView to replace
standalone diffing with yours.**

    
    
    struct CalendarContainerView: View {
        @EnvironmentObject var store: CalendarStore
    
        var body: some View {
            EquatableView(
                CalendarView(
                    sleeps: store.sleeps,
                    dates: store.dates
                )
            ).onAppear(perform: store.fetch)
        }
    }
    

####  Equatable modifier

SwiftUI allows us to avoid wrapping with _EquatableView_ by using an equatable
modifier. Basically, it does the same thing but in a short way.

    
    
    struct CalendarContainerView: View {
        @EnvironmentObject var store: CalendarStore
    
        var body: some View {
            CalendarView(sleeps: store.sleeps, dates: store.dates)
                .equatable()
                .onAppear(perform: store.fetch)
        }
    }
    

####  Container views and equatable rendering views

It is so easy to add _Equatable_ conformance to your view when it only renders
some data. You even don’t need to override _== function_ . You can quickly
achieve this behavior by extracting your views into _Container_ and
_Rendering_ views. We already talked multiple times on my blog about
_Container_ and _Rendering_ views. _Rendering_ views simply take some data and
render it. That’s it.

_Rendering_ views should not contain any logic or state manipulations, and it
should delegate them to _Container_ views. This separation allows you to make
your _Rendering_ views conforming _Equatable_ in an effortless way.

> To learn more about _Container and Rendering views_ , take a look at my [
> “Introducing Container views in SwiftUI” post ](/2019/07/31/introducing-
> container-views-in-swiftui/) .

####  Conclusion

SwiftUI allows us to build our apps in a very new way, where the framework
itself applies a lot of magic behind the scene. But I’m delighted that SwiftUI
provides so many capabilities to customize default behavior. _EquatableView_
can boost performance when _body_ computation is longer than your equality
check. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# StoreKit testing in Swift

##  StoreKit testing in Swift

09 Jan 2024

The second iteration of the StoreKit framework was the most significant change
in my apps during the last few years. The recent version of the StoreKit
framework has fully adopted Swift language features like _async_ and _await_ .
This week, we will talk about the StoreKitTest framework, which is not a part
of StoreKit 2 but is tightly coupled with it.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The StoreKitTest framework allows us to write tests for in-app product
purchasing, refunding, and restoring features. You can cover almost every
aspect of the in-app purchase with tests using the StoreKitTest framework.
Before starting, you should create a StoreKit Configuration File.

> To learn more about the basics of the StoreKit 2, take a look at my [
> “Mastering StoreKit 2” ](/2023/08/01/mastering-storekit2/) post.

The StoreKitTest framework provides us with the _SKTestSession_ type. Using an
instance of the _SKTestSession_ type, we can purchase in-app products, manage
transactions, refund and expire subscriptions, etc.

Let’s start by creating a test case for our StoreKit-related features. I
usually have a type called _SettingsStore_ , which defines user configuration
and handles in-app purchases. We will cover the in-app purchase management
part of the _SettingsStore_ with tests by using the StoreKitTest framework.

    
    
    @MainActor final class StoreKitTests: XCTestCase {
        func testProductPurchase() async throws {
            let session = try SKTestSession(configurationFileNamed: "SugarBot Food Calorie Counter")
            session.disableDialogs = true
            session.clearTransactions()
        }
    }
    

As you can see in the example above, we initialize an instance of the
_SKTestSession_ type. Then, we call the _clearTransactions_ function to remove
all the transactions we may have stored from the previous launches. We also
turn off dialogs to automate the purchase confirmation flow easily.

Now, we can use our _SettingsStore_ type to purchase products and process
subscription status. The _SKTestSession_ type also allows us to buy a product
that simulates the purchase outside the app. For example, it might be a
purchased product with family sharing enabled.

    
    
    @MainActor final class StoreKitTests: XCTestCase {
        var store: SettingsStore!
        
        override func setUp() {
            store = SettingsStore()
        }
        
        func testProductPurchase() async throws {
            let session = try SKTestSession(configurationFileNamed: "SugarBot Food Calorie Counter")
            session.disableDialogs = true
            session.clearTransactions()
            
            try await session.buyProduct(identifier: "annual")
            
            guard let product = try await Product.products(for: ["annual"]).first else {
                return XCTFail("Can't load products...")
            }
            
            let status = try await product.subscription?.status ?? []
            await store.processSubscriptionStatus(status)
            
            XCTAssertFalse(store.activeSubscriptions.isEmpty)
        }
    }
    

As you can see in the example above, we use the _buyProduct_ function on an
instance of the _SKTestSession_ type to simulate a purchase. We can also use
the _expireSubscription_ function of the _SKTestSession_ type to expire
ongoing subscriptions and verify how our app processes this data.

    
    
    @MainActor final class StoreKitTests: XCTestCase {
        var store: SettingsStore!
        
        override func setUp() {
            store = SettingsStore()
        }
        
        func testExpiredProduct() async throws {
            let session = try SKTestSession(configurationFileNamed: "SugarBot Food Calorie Counter")
            session.disableDialogs = true
            session.clearTransactions()
            
            let transaction = try await session.buyProduct(identifier: "annual")
            
            let activeProducts = try await Product.products(for: ["annual"])
            let activeStatus = try await activeProducts.first?.subscription?.status ?? []
            await store.processSubscriptionStatus(activeStatus)
            
            XCTAssertFalse(store.activeSubscriptions.isEmpty)
            
            try session.expireSubscription(productIdentifier: "annual")
            
            let expiredProducts = try await Product.products(for: ["annual"])
            let expiredStatus = try await expiredProducts.first?.subscription?.status ?? []
            await store.processSubscriptionStatus(expiredStatus)
            
            XCTAssertTrue(store.activeSubscriptions.isEmpty)
        }
    }
    

The _SKTestSession_ type also allows us to simulate product refunds using the
_refundTransaction_ function. Another exciting option is to test how the app
reacts to transaction updates.

    
    
    let transaction = try await session.buyProduct(identifier: "annual")
    // verify purchase ...
    try session.refundTransaction(identifier: UInt(transaction.id))
    // verify refund ...
    

You can also use the _askToBuyEnabled_ property to enable the ask-to-buy
feature and then use the _approveAskToBuyTransaction_ or
_declineAskToBuyTransaction_ functions to approve or decline purchases. In
this case, the transaction should change from pending to successful.

    
    
    session.askToBuyEnabled = true
    
    await store.purchase("annual")
    // verify purchase ...
    
    let declined = store.pendingTrancations.first?.id ?? 0
    try session.declineAskToBuyTransaction(identifier: UInt(declined.id))
    // verify purchase ...
    
    await store.purchase("annual")
    // verify purchase ...
    
    let approved = store.pendingTrancations.first?.id ?? 0
    try session.approveAskToBuyTransaction(identifier: UInt(approved.id))
    // verify purchase ...
    

As you can see in the example above, we use an instance of the SKTestSession
type to simulate ask-to-buy and verify the behavior of our app while the
purchase is approved or declined.

This week, we learned how to use the StoreKitTest framework to verify how our
app handles in-app purchases and user flows like refunds, ask-to-buy, and
subscription expiration. I hope you enjoy the post. Feel free to follow me on
[ Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!

  1. [ Mastering StoreKit 2 ](/2023/08/01/mastering-storekit2/)
  2. [ Mastering StoreKit 2. ProductView and StoreView in SwiftUI. ](/2023/08/08/mastering-storekit2-productview-in-swiftui/)
  3. [ Mastering StoreKit 2. SubscriptionStoreView in SwiftUI ](/2023/08/23/mastering-storekit2-subscriptionstoreview-in-swiftui/)
  4. [ Mastering StoreKit 2. SwiftUI view modifiers. ](/2023/08/29/mastering-storekit2-swiftui-view-modifiers/)
  5. StoreKit testing in Swift 



# Building Pager view in SwiftUI

##  Building Pager view in SwiftUI

25 Dec 2019

This week I want to continue the series of posts about building custom
interactive views in SwiftUI. Today we will create a pager view. _ScrollView_
in SwiftUI support only scrolling content and doesn’t have paging behavior.
That’s why we will build a pager view that supports paging mode.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start by describing the _PagerView_ and all the needed properties. First
of all, we need the page count, binding to the currently visible page, and the
content of pages.

    
    
    import SwiftUI
    
    struct PagerView<Content: View>: View {
        let pageCount: Int
        @Binding var currentIndex: Int
        let content: Content
    
        init(pageCount: Int, currentIndex: Binding<Int>, @ViewBuilder content: () -> Content) {
            self.pageCount = pageCount
            self._currentIndex = currentIndex
            self.content = content()
        }
    }
    

Again, we use binding to extract the state of the view. It allows us to store
the state in the parent view and react to page changes. We also use
_@ViewBuilder_ for the content closure. _@ViewBuilder_ enables encapsulation
of the presentation logic by keeping content descriptions outside the view. It
is a pretty popular technique for any container view in SwiftUI.

> To learn more about the benefits of @ViewBuilder while building custom
> SwiftUI view take a look at [ my dedicated post ](/2019/12/18/the-power-of-
> viewbuilder-in-swiftui/) .

Now we can build our presentation logic and render the current page. All we
need to do is to place our content inside an _HStack_ and set proper offset.
Let’s see how easily we can achieve that.

    
    
    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                self.content.frame(width: geometry.size.width)
            }
            .frame(width: geometry.size.width, alignment: .leading)
            .offset(x: -CGFloat(self.currentIndex) * geometry.size.width)
        }
    }
    

In the example above, we use _GeometryReader_ to get information about the
parent view’s size and fill the entire place. We also need to set alignment to
leading because, by default, frame place the child view in the center. We also
use _offset_ modifier to place an active page in the visible area.

> To learn more about GeometryReader, take a look at [ “Building BarChart with
> Shape API in SwiftUI” post ](/2019/08/14/building-barchart-with-shape-api-
> in-swiftui/) .

Let’s move to the final step and attach the drag gesture to _HStack_ to swipe
pages interactively. We need to declare a new view-local state for the gesture
to store translation while the gesture is active. We can use translation value
to add offset to the _HStack_ to achieve interactive page dragging.

    
    
    @GestureState private var translation: CGFloat = 0
    
    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                self.content.frame(width: geometry.size.width)
            }
            .frame(width: geometry.size.width, alignment: .leading)
            .offset(x: -CGFloat(self.currentIndex) * geometry.size.width)
            .offset(x: self.translation)
            .animation(.interactiveSpring(), value: currentIndex)
            .animation(.interactiveSpring(), value: translation)
            .gesture(
                DragGesture().updating(self.$translation) { value, state, _ in
                    state = value.translation.width
                }.onEnded { value in
                    let offset = value.translation.width / geometry.size.width
                    let newIndex = (CGFloat(self.currentIndex) - offset).rounded()
                    self.currentIndex = min(max(Int(newIndex), 0), self.pageCount - 1)
                }
            )
        }
    }
    

Whenever drag gesture ends, we need to calculate how big was the translation
and if it is enough to move to the next or previous pages. We can estimate it
straightforwardly by using geometry and some math functions like min, max, and
rounding. Let’s finally see how we can use our _PagerView_ .

    
    
    struct ContentView: View {
        @State private var currentPage = 0
    
        var body: some View {
            PagerView(pageCount: 3, currentIndex: $currentPage) {
                Color.blue
                Color.red
                Color.green
            }
        }
    }
    

> Full source code available on [ GitHub
> ](https://gist.github.com/mecid/e0d4d6652ccc8b5737449a01ee8cbc6f) .

I enjoy the snapping effect which we have in our view, and it is all possible
by using interactive spring. Interactive spring is an animation with a lower
response value, intended for driving interactive animations.

> To learn more about animations and transitions in SwiftUI, take a look at my
> [ “Animations in SwiftUI” post ](/2019/06/26/animations-in-swiftui/) .

####  Conclusion

This week we built another interactive view component in SwiftUI. I feel like
it is so easy to build interactive views, all you need to do is declare your
state, statically render the state and then attach a gesture which modifies
that state. SwiftUI handles all the transitions between states automatically
by adding very fluid animations. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Mastering charts in SwiftUI. Customizations.

##  Mastering charts in SwiftUI. Customizations.

15 Feb 2023

The Swift Charts framework became a huge topic on my blog. But I decided to
continue this subject to cover everything I’ve experienced with the Charts
framework. This week we will learn how to customize the _Chart_ view using a
bunch of chart view modifiers provided by the framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Plot area

The first thing you might need is the tuning plot area of the _Chart_ view.
The Charts framework provides the _chartPlotStyle_ view modifier allowing us
to style the view representing the chart’s plot area. Let’s take a look at how
we can use it.

    
    
    struct ContentView: View {
        var body: some View {
            Chart {
                // ...
            }
            .chartPlotStyle { chartContent in
                chartContent
                    .background(Color.secondary.opacity(0.2))
                    .frame(height: 32)
                
            }
        }
    }
    

As you can see in the example above, we use the _chartPlotStyle_ view modifier
to access the chart’s content view. It is a simple SwiftUI view, meaning we
can apply any view modifiers we need. In our case, we use the _frame_ view
modifier to set a particular height and the _background_ view modifier to fill
the background with a gray color.

![stacked-bar-chart](/public/chart14.png)

As you know, the _Chart_ view is also a SwiftUI view, and we can apply the
_frame_ view modifier to it, but in this case, it will affect the whole chart
view with its legend view, which is not a good idea.

> To learn more about the basics of the Charts framework, take a look at my
> dedicated [ “Mastering charts in SwiftUI. Basics.” ](/2023/01/10/mastering-
> charts-in-swiftui-basics/) post.

####  Axis

The Charts framework provides us _chartXAxis_ and _chartYAxis_ view modifiers
allowing us to control the look and feel of the particular axis completely.
These view modifiers accept _AxisContentBuilder_ closure, where we can define
how we want to build the axis.

    
    
    struct ContentView: View {
        var body: some View {
            Chart {
                // ...
            }
            .chartXAxis {
                AxisMarks(
                    preset: .aligned,
                    position: .bottom,
                    values: .stride(by: 500),
                    stroke: StrokeStyle(
                        lineWidth: 4,
                        lineCap: .butt,
                        lineJoin: .bevel,
                        miterLimit: 1,
                        dash: [],
                        dashPhase: 1
                    )
                )
            }
        }
    }
    

The Charts framework includes _AxisMarks_ type representing the chart’s axes.
We can use it to customize the axis in different ways. In the example above,
we use the example of the _AxisMark_ type, allowing us to configure the axis’s
preset, position, values, and stroke.

The _preset_ parameter provides _automatic, aligned, inset, and extended_
options. They all affect how the framework draws the value on the axis. The
_position_ parameter allows us to choose where to draw axis values. We can use
the _values_ parameter to generate values to draw on the axis. In our example,
we use the _stride_ function to generate values. The last parameter is the
_stroke_ . The framework uses it to draw axis lines.

We can also use another variant of the _AxisMarks_ to fully customize the look
and feel by manually adjusting every axis component per axis value.

    
    
    struct ContentView: View {
        var body: some View {
            Chart {
                // ...
            }
            .chartXAxis {
                AxisMarks(values: .stride(by: 500)) { value in
                    AxisGridLine(
                        centered: true,
                        stroke: StrokeStyle(
                            lineWidth: 4,
                            lineCap: .butt,
                            lineJoin: .bevel,
                            miterLimit: 1,
                            dash: [],
                            dashPhase: 1
                        )
                    )
                    
                    AxisValueLabel(anchor: .topTrailing)
                    
                    if let value = value.as(Int.self), value % 2 == 0 {
                        AxisTick(centered: true, length: 10)
                    }
                }
            }
        }
    }
    

As you can see in the example above, we use another variant of the _AxisMarks_
initializer, allowing us to configure the axis look and feel per value. We use
the concrete value to decide whether to show the tick. The last example
demonstrates how we can use _AxisGridLine_ , _AxisValueLabel_ , and _AxisTick_
types to compose the axis. They provide many customization points, allowing
you to reach the desired look and feel.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Haptic feedback in iOS apps

##  Haptic feedback in iOS apps

09 May 2019

Feedback helps people know what an app is doing, discover what they can do
next, and understand the results of actions. This week I am going to talk
about the Haptic Feedback Engine which provided by Apple in most of the
devices.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

On supported devices, haptics provide a way to physically engage users with
tactile feedback that gets attention and reinforces actions. Some system-
provided interface elements, such as pickers, switches, and sliders,
automatically provide haptic feedback as users interact with them. Your app
can also ask the system to generate different types of haptic feedback. iOS
manages the strength and behavior of this feedback.

Another benefit of the feedback engine is Accessibility. It helps to
understand the result of any action without actually watching the screen.

####  UIFeedbackGenerator

Apple provides us with abstract class _UIFeedbackGenerator_ for all type
haptic feedbacks. We don’t need to subclass it in our apps. Instead, we have
to use Apple provided ready to use subclasses. There are three classes:

  1. [ UIImpactFeedbackGenerator ](https://developer.apple.com/documentation/uikit/uiimpactfeedbackgenerator)
  2. [ UISelectionFeedbackGenerator ](https://developer.apple.com/documentation/uikit/uiselectionfeedbackgenerator)
  3. [ UINotificationFeedbackGenerator ](https://developer.apple.com/documentation/uikit/uinotificationfeedbackgenerator)

All of them have system predefined haptic feedback patterns, so instead of
using custom vibration patterns let’s use well-known haptics. All these
subclasses share the same logic. First, you need to prepare the haptic engine
before using it. The second is the call to the appropriate method to run this
haptic. Let’s take a look at simple usage of _UINotificationFeedbackGenerator_
class.

    
    
    class EpisodeViewController: UIViewController {
        private let episodeModelController: EpisodeModelController
        private let feedback = UINotificationFeedbackGenerator()
    
        init(episodeModelController: EpisodeModelController) {
            self.episodeModelController = episodeModelController
            super.init(nibName: nil, bundle: nil)
        }
    
        @IBAction func markAsWatched() {
            feedback.prepare()
            episodeModelController.markAsWatched { [weak self] outcome in
                switch outcome {
                case .success:
                    self?.feedback.notificationOccurred(.success)
                case .failure:
                    self?.feedback.notificationOccurred(.error)
                }
            }
        }
    }
    

Here we have a TV show tracking apps screen which maintains an episode. We
have a button which should mark the episode as watched on click. As you can
see before the request to our API service, we prepare the feedback generator,
and when the result comes, we run appropriate feedback type.

Another interesting subclass is _UISelectionFeedbackGenerator_ . We can use on
the same screen as a result of selection changes. For example, we can have
buttons which should fetch next or previous episodes after a click.

    
    
        @IBAction func fetchNext() {
            selectionFeedback.prepare()
            episodeModelController.fetchNext { [weak self] outcome in
                switch outcome {
                case .success:
                    self?.selectionFeedback.selectionChanged()
                case .failure:
                    self?.feedback.notificationOccurred(.error)
                }
            }
        }
    

As you can see on the code sample above usage of
_UISelectionFeedbackGenerator_ is very similar to
_UINotificationFeedbackGenerator_ . We prepare and run the haptic engine.

I want to mention that these classes have UI prefix and we should run them on
the main queue. To keep it crash-free I prepared a simple extension which runs
methods on the main queue.

    
    
    import UIKit
    
    extension UINotificationFeedbackGenerator {
        func safePrepare() {
            DispatchQueue.main.async {
                self.prepare()
            }
        }
    
        func safeNotificationOccurred(_ type: UINotificationFeedbackGenerator.FeedbackType) {
            DispatchQueue.main.async {
                self.notificationOccurred(type)
            }
        }
    }
    
    

####  Conclusion

Today we discussed a straightforward and accessible feature of iOS SDK. Haptic
Feedback can be very useful both for accessible part of your user base and for
anyone who engaged in your app. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



# Drag and drop transferable data in SwiftUI

##  Drag and drop transferable data in SwiftUI

05 Apr 2023

Last week we discussed the new _ShareLink_ view and the _Transferable_
protocol powering it. The new _Transferable_ protocol is useful for sharing
your data from the app, but it also powers drag and drop in your app. This
week we will learn how we can drag and drop data conforming to the
_Transferable_ protocol in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Dragging

The new _Transferable_ protocol allows us to implement the drag-and-drop
experience in our apps much more easily. All you need to do is to attach the
_draggable_ view modifier to any view in the view hierarchy and pass the data
you want to drag. The data you pass have to conform to the new _Transferrable_
protocol.

    
    
    struct BookmarksList: View {
        @State private var links: [URL] = [
            URL(string: "https://twitter.com/mecid")!
        ]
        
        var body: some View {
            List {
                ForEach(links, id: \.self) { url in
                    Text(url.absoluteString)
                        .draggable(url) {
                            Text(verbatim: url.absoluteString)
                        }
                }
            }
            .navigationBarTitle("Bookmarks")
        }
    }
    

As you can see in the example above, we use the new _draggable_ view modifier
to enable dragging URLs from the list. The _URL_ type conforms to the new
_Transferable_ protocol out of the box, and you don’t need to do anything here
to implement the conversion of URL data to the transferable format. We also
provide a preview for the draggable content by creating a _Text_ view with the
URL string.

The example above shows how you can enable the drag and drop feature for the
URL item, but you can do it for any type conforming to the _Transferable_
protocol.

> To learn more about the basics of the _Transferable_ protocol, take a look
> at my [ “Sharing content in SwiftUI” ](/2023/03/28/sharing-content-in-
> swiftui/) post.

####  Dropping

The next step is allowing your app to accept transferable content via drops.
All you need to do is to attach the new _dropDestination_ view modifier to any
view you want to take drops.

    
    
    struct BookmarksList: View {
        @State private var links: [URL] = [
            URL(string: "https://twitter.com/mecid")!
        ]
        
        var body: some View {
            List {
                ForEach(links, id: \.self) { url in
                    Text(url.absoluteString)
                        .draggable(url) {
                            Text(verbatim: url.absoluteString)
                        }
                }
                .dropDestination(for: URL.self) { items, location in
                    links.append(contentsOf: items)
                }
            }
            .navigationBarTitle("Bookmarks")
        }
    }
    

As you can see in the example above, we use the _dropDestination_ view
modifier to register an area that takes drops of the _URL_ type. We also use
the _dropDestination_ view modifier to register closure handling drops. It
takes two parameters: _items_ and _location_ . The _items_ parameter defines
an array of transferable data, and the _location_ parameter indicates the drop
position on the screen.

####  Conclusion

As you can see, it is straightforward to support the drag and drop feature in
your apps with the new _draggable_ and _dropDestination_ view modifiers. Both
of them are powered by the brand new CoreTransferable framework. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Building ViewModels with Combine framework

##  Building ViewModels with Combine framework

05 Feb 2020

One of my first posts on this blog was about using the ViewModel pattern in
iOS apps. I’m still using this concept in some old school UIKit projects. But
I think it’s time to remaster that post. This week we will talk about building
reactive ViewModels using Combine framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  What is ViewModel?

ViewModel is a layer between your view and data. ViewModels usually fetch the
data using service objects, format it, and provide a formatted version to your
view.

> You can check [ my old post about MVVM ](/2018/01/11/mastering-mvvm-on-ios/)
> if you need more information about the pattern itself.

####  Apple started promoting MVVM

I noticed an interesting thing when Apple moved the _ObservableObject_
protocol to the Combine framework. It looks like Apple began promoting the
MVVM pattern. Let’s take a look at the _ObservableObject_ protocol to
understand what’s going on there.

    
    
    /// A type of object with a publisher that emits before the object has changed.
    public protocol ObservableObject : AnyObject {
    
        /// The type of publisher that emits before the object has changed.
        associatedtype ObjectWillChangePublisher : Publisher = ObservableObjectPublisher where Self.ObjectWillChangePublisher.Failure == Never
    
        /// A publisher that emits before the object has changed.
        var objectWillChange: Self.ObjectWillChangePublisher { get }
    }
    

_ObservableObject_ protocol has the only one requirement, a publisher that
emits before the object changes. Let’s write our first ViewModel that conforms
to _ObservableObject_ protocol.

    
    
    final class PostsViewModel: ObservableObject {
        let objectWillChange = PassthroughSubject<Void, Never>()
    
        private (set) var posts: [Post] = []
    
        func fetch() {
            // fetch posts
            objectWillChange.send()
            // assign new data to the posts variable
        }
    }
    

Here we have the ViewModel that fetches posts, stores them in the variable,
and emits a notification via _objectWillChange_ publisher. Let’s take a look
at a sample _ViewController_ that uses this ViewModel.

    
    
    final class PostsViewController: UIViewController {
        let viewModel: PostsViewModel
        private var cancellables: Set<AnyCancellable> = []
    
        override func viewDidLoad() {
            super.viewDidLoad()
            bindViewModel()
            viewModel.fetch()
        }
    
        private func bindViewModel() {
            viewModel.objectWillChange.sink { [weak self] in
                guard let self = self else {
                    return
                }
                self.renderPosts(self.viewModel.posts)
            }.store(in: &cancellables)
        }
    }
    

As you can see in the example above, we have _PostsViewController_ that starts
observing changes in ViewModel and then ask ViewModel to fetch data. As soon
as ViewModel fetches data, it emits, and _ViewController_ calls renderPosts
function that displays downloaded posts.

####  Published property wrapper

We can go further by using @ _Published_ property wrapper. @ _Published_
property wrapper allows us to wrap any property with the publisher that emits
the current value whenever the property changes.

Moreover, you even don’t need to define _objectWillChange_ publisher when you
use @ _Published_ property wrapper. Swift compiler will **automatically
synthesize** the _objectWillChange_ , and it will emit whenever any @
_Published_ property changes. Let’s take a look at the refactored version of
our ViewModel that uses @ _Published_ property wrapper.

    
    
    final class PostsViewModel: ObservableObject {
        @Published private(set) var posts: [Post] = []
    
        func fetch() {
            // fetch posts and assign them to `posts` variable
        }
    }
    

As you can see in the example above, we don’t need to send a value manually to
_objectWillChange_ publisher — all the work synthesized by the Swift compiler.
And we can keep the same implementation of _PostsViewController_ .

As I said before, @ _Published_ property wrapper wraps our property with a
publisher. Let’s take a look at how we can use it in our _PostsViewController_
.

    
    
    final class PostsViewController: UIViewController {
        let viewModel: PostsViewModel
        private var cancellables: Set<AnyCancellable> = []
    
        override func viewDidLoad() {
            super.viewDidLoad()
            bindViewModel()
            viewModel.fetch()
        }
    
        private func bindViewModel() {
            viewModel.$posts
                .sink { [weak self] in self?.renderPosts($0) }
                .store(in: &cancellables)
        }
    }
    

Here we have a refactored version of our _PostsViewController_ . Please take a
look at how we changed _bindViewModel_ function. It subscribes to _$posts_
now, and it allows us to update our view only when specific properties change.
You will see the benefits as soon as your ViewModel has more and more fields
which can affect the view.

> Apple also mentioned ViewModels during [ “Mastering Xcode Previews” session
> on WWDC 19 ](https://developer.apple.com/wwdc19/233) .

####  Conclusion

We can easily implement the very same logic using _RxSwift_ , _ReactiveSwift_
, or any other reactive framework like _Bond_ . But I feel like _MVVM_ is
going to be a default choice in architecting iOS apps. At least now, when
Apple provides us all the needed tools to build it out of the box. I hope you
enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Alerts, Action Sheets, Modals and Popovers in SwiftUI

##  Alerts, Action Sheets, Modals and Popovers in SwiftUI

24 Jul 2019

Last week we talked about [ Navigation in SwiftUI ](/2019/07/17/navigation-in-
swiftui/) . This week I want to continue the topic with sheets, alerts, action
sheets, and popovers. SwiftUI has a set of dedicated modifiers for presenting
this kind of stuff. Let’s take a look at how we can use different view
modifiers to display sheets, alerts, action sheets, and popovers.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Alerts and Action Sheets

Both alerts and action sheets use the similar ways of presenting it to the
user. Let’s start with a simpler one. We have to describe a boolean binding
which can be observed by SwiftUI, and as soon as boolean becomes true, SwiftUI
presents the action sheet or alert.

    
    
    struct MasterView: View {
        @State private var showActionSheet = false
    
        var body: some View {
            VStack {
                Button("Show action sheet") {
                    self.showActionSheet = true
                }
            }.actionSheet(isPresented: $showActionSheet) {
                ActionSheet(
                    title: Text("Actions"),
                    message: Text("Available actions"),
                    buttons: [
                        .cancel { print(self.showActionSheet) },
                        .default(Text("Action")),
                        .destructive(Text("Delete"))
                    ]
                )
            }
        }
    }
    

As you can see in the example above to present an action sheet, we use
_actionSheet_ modifier bound to a boolean value and a closure which creates an
action sheet. Alternatively, to display an alert, we have to use _alert_
modifier instead.

> _ActionSheet_ is deprecated now, use confirmation dialogs instead. To learn
> more, take a look at my [ “Confirmation dialogs in SwiftUI”
> ](/2021/07/28/confirmation-dialogs-in-swiftui/) post.

The interesting fact here is that SwiftUI resets the binding to initial value
after _Alert_ or _Action Sheet_ dismissal.

It is a straightforward approach to present alerts or action sheets. But
sometimes it is not enough, because we need some data to show in an alert or
action sheet. For this case, we have another versions of _alert_ and
_actionSheet_ modifiers, which use an optional identifiable binding instead of
boolean binding.

    
    
    struct Message: Identifiable {
        let id = UUID()
        let text: String
    }
    
    struct MasterView: View {
        @State private var message: Message? = nil
    
        var body: some View {
            VStack {
                Button("Show alert") {
                    self.message = Message(text: "Hi!")
                }
            }.alert(item: $message) { message in
                Alert(
                    title: Text(message.text),
                    dismissButton: .cancel()
                )
            }
        }
    }
    

As soon as _message_ is not _nil_ SwiftUI call a closure with _message_ as a
parameter. You can create your alert based on the data passed into the
closure.

####  Sheets

To present modals, SwiftUI provides the special view modifier called _sheet_ .
_Sheet_ view modifier is very similar to _alert_ and _actionSheet_ , it uses
boolean or optional identifiable binding to understand when to present a
sheet. It also needs a closure which returns a content view for a sheet.
Besides that, _sheet_ view modifier has an optional _onDismiss_ closure
parameter, SwiftUI calls this closure after modal dismiss. Like with alerts,
SwiftUI will reset binding to the initial value after modal dismissal.

    
    
    import SwiftUI
    import Combine
    
    struct MasterView: View {
        @State private var showModal = false
    
        var body: some View {
            VStack {
                Button("Show modal") {
                    self.showModal = true
                }
            }.sheet(isPresented: $showModal, onDismiss: {
                print(self.showModal)
            }) {
                ModalView(message: "This is Modal view")
            }
        }
    }
    
    struct ModalView: View {
        @Environment(\.presentationMode) var presentation
        let message: String
    
        var body: some View {
            VStack {
                Text(message)
                Button("Dismiss") {
                    self.presentation.value.dismiss()
                }
            }
        }
    }
    

You can also use _fullScreenCover_ view modifier to present full screen
modals. It works the same way as _sheet_ modifier. _presentationMode_ is an
environment value that represents the current presentation mode of the view.
We can use it to programmatically dismiss the sheet.

####  Popovers

Using popovers in SwiftUI is very similar to alerts and action sheets.
_Popover_ modifier also has two overloads for boolean and optional
identifiable bindings. Another additional parameter in the _popover_ view
modifier is _arrowEdge_ , by providing _Edge_ value you can draw an arrow in a
specified direction. Here is the example of the _popover_ view modifier usage.

    
    
    struct MasterView: View {
        @State private var showPopover: Bool = false
    
        var body: some View {
            VStack {
                Button("Show popover") {
                    self.showPopover = true
                }.popover(
                    isPresented: self.$showPopover,
                    arrowEdge: .bottom
                ) { Text("Popover") }
            }
        }
    }
    

####  Conclusion

As you can see, SwiftUI provides a pretty easy way of presenting context-
related views like alerts, action sheets, sheets, and popoversp by using
bindings. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading and see you next
week!



# Make your app accessible for everyone

##  Make your app accessible for everyone

09 Jul 2018

Last few months I was working on implementing Accessibility support for my
app. During this years WWDC I’ve visited all Accessibility related sessions
and Labs to improve my knowledge and catch some best practices from Apple
Engineers. So now I’m finished my work and finally ready to share with you
story of my Accessibility way.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

First of all, I would like to mention that Apple had done a great job with
Accessibility framework. Most of the things handled by the system without our
action. All the UIKit controls have Accessibility support out of the box.
_UIButton, UILabel, UISegmentedControl, UISwitch,_ etc. are ready to be used
by assistive technologies like VoiceOver, Switch Control, etc. If you’re not
familiar with VoiceOver technology, I suggest watching this [ talk
](https://developer.apple.com/videos/play/wwdc2018/226/) from last WWDC event.

Let’s check out my app called [ CardioBot
](https://cardiobot.swiftwithmajid.com) . It is Heart Rate analyzer for iOS
and watchOS. CardioBot has a massive amount of data presented in charts and
other visual ways, which are custom views and don’t support Accessibility out
of the box. Good news is that it is easy to add Accessibility support to our
custom views.

![CardioBot](/public/cardiobot.jpg)

####  Group elements inside cells

As you can see on the first screen, I have a _UICollectionView_ which
represents the current month with cells for every day. DayCell is a class
which uses two labels to describe daily information: date and average heart
rate. I am also using label background color to express the heart rate zone.
VoiceOver users are moving through the app by using right and left swipe
gestures. These gestures navigate VoiceOver focus on next and previous
elements respectively. So VoiceOver focus will switch from label to label and
read the text content of every label. However, this is not very easy for
users; they have to do many swipes to understand the data. I would like to ask
VoiceOver to focus on cell entire, not on every label inside and read the
specially formatted string as cell content.

    
    
    self.isAccessibilityElement = true
    self.accessibilityLabel = "\(date), \(value) - \(status)"
    self.accessibilityTraits |= UIAccessibilityTraitButton
    

Setting _isAccessibilityElement_ property to true on _UICollectionViewCell_
makes it appear as a single Accessibility element. I am also set a formatted
string to _accessibilityLabel_ property to make it easier to understand data
which presented by this cell. To describe the action which user can do on the
cell, I am using _UIAccessibilityTraitButton_ trait. This trait indicates to
VoiceOver that it is a button and can be selected or activated by the user. So
when VoiceOver focused on the DayCell, it pronounces the phrase like:
“December 1st, 69 — Resting. Button.” When the user swipes right to next
element VoiceOver pronounces: “December 2nd, 78 — High resting. Button.”

####  Charts

On the second screen, you can see that I use a custom view to display a chart
of heart rate zones during the day. To make it accessible just set to true
_isAccessibilityElement_ property, set formatted string as
_accessibilityLabel_ and add _UIAccessibilityTraitStaticText_ trait to
_accessibilityTraits_ property of the custom view. I wrote small Formatter
class which generates a string from heart rate data. So when VoiceOver focuses
on chart view, it pronounces phrase like: “Low — 12%, Resting — 64%, High
Resting — 16%, Elevated — 7%”.

On the third screen, CardioBot displays a detailed heart rate chart with a
4-minute interval. I would like to make it possible to focus VoiceOver on
every bar inside the chart, pronounce the time and value for a selected period
and easily move between the bars. As I say before this is a custom view with
the overridden _drawInRect_ method which handles plotting logic that’s why we
don’t have accessibility support out of the box here. Happily, we have a
particular API for this kind of situations. We can set an array of
Accessibility elements inside a custom view.

    
    
    let elements = statistics.enumerated().map {
        let frame = CGRect(
            x: 0, 
            y: CGFloat($0 * Layout.barHeight), 
            width: bounds.width, 
            height: Layout.barHeight
        )
        
        let element = UIAccessibilityElement(accessibilityContainer: self)
        element.accessibilityLabel = $1.time
        element.accessibilityValue = "\(Int($1.value)), \($1.status)"
        element.accessibilityFrameInContainerSpace = frame
        return element
    }
    
    self.accessibilityElements = elements
    

Pay attention to _accessibilityFrameInContainerSpace_ property which is a
frame inside chart view which used to highlight focused area by VoiceOver.

####  Traits

Accessibility trait is a type of accessibility element which used by VoiceOver
to describe available actions on it. For example,
_UIAccessibilityTraitAdjustable_ trait used to describe adjustable elements
like _UISlider_ . When VoiceOver focused on the adjustable view user can use
swipe up and swipe down gestures to increment or decrement the value of the
component. That’s why you have to implement _accessibilityIncrement_ and
_accessibilityDecrement_ methods of _UIAccessibilityAction_ protocol to handle
these gestures.

Another useful trait is _UIAccessibilityTraitHeader_ . Marking section header
labels with this trait add the opportunity for VoiceOver to recognize sections
and navigate between them by using rotor navigation.

Day details screen has various sections like Summary, HRV, Sleep, Weekly
sleep, Workout. For example every morning I would like to check out how
healthy was my sleep and I don’t need to navigate to the Sleep section through
all these elements. To use the rotor, rotate two fingers on your iOS device’s
screen as if you’re turning a dial. VoiceOver will say the first rotor option.
Keep rotating your fingers to hear more options. Lift your fingers to choose
an option. After selecting the headings option, flick your finger up or down
on the screen to use it.

####  Exit gesture

VoiceOver users use two fingers Z-gesture to go back to the previous screen or
close modal window. Handling of this gesture implemented by default for
_UINavigationController_ and _UIStoryboard_ segues, and you don’t need to do
something to achieve this behavior. However, sometimes we are showing
_UIViewController_ by calling _present()_ method, in this case, we have to
override _accessibilityPerformEscape_ method on presented _UIViewController_
and call _dismiss()_ manually to exit.

####  Hints

Another interesting property on _UIAccessibility_ protocol is
_accessibilityHint_ . This property used by VoiceOver to describe the result
of action on accessibility element. For example, I use it to indicate to users
that activating chart control display the detailed chart. Be careful and don’t
put here some valuable data because the user can disable this feature and
VoiceOver will ignore hint labels. Follow these guidelines to describe your
hints in a clean way.

####  Small things matter

Besides the heart rate analysis CardioBot also shows some activity summary
like total step count, walking distance and calories. I use HealthKit to
calculate all this stuff. Some of my users have motor disabilities and use a
wheelchair to move around. For this users, I apply another query to calculate
wheelchair pushes instead of steps. It takes me about 30 minutes to implement
this feature, but my users were pleased.

####  Conclusion

I suggest you watch this two sessions from WWDC18:

  1. [ VoiceOver: App Testing Beyond The Visuals ](https://developer.apple.com/videos/play/wwdc2018/226/)
  2. [ Deliver an Exceptional Accessibility Experience ](https://developer.apple.com/videos/play/wwdc2018/230/)

Accessibility isn’t a feature or a “nice to have.” **It’s a necessity** . So
let’s make your app accessible for everyone.



# TextField in SwiftUI

##  TextField in SwiftUI

26 Feb 2020

This week I want to talk to you about a _TextField_ component in SwiftUI. It
might look like an elementary tutorial, but _TextField_ has pretty exciting
features like out of the box formatting that we don’t have in _UIKit_ . But
let’s start with the basics of the _TextField_ component.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

As you might know, we can use _TextField_ for user input. All we need to do is
to create a _TextField_ and assign it to any _Binding_ of a _String_ value.
Let’s take a look at a very quick example.

    
    
    struct ContentView: View {
        @State private var text = ""
    
        var body: some View {
            TextField("type something...", text: $text)
        }
    }
    

In the example above, we create a _TextField_ with a placeholder and bind it
to a state variable. Pretty easy, right? _TextField_ also provides callbacks
that we might need to handle during user input.

    
    
    struct ContentView: View {
        @State private var text = ""
    
        var body: some View {
            TextField(
                "type something...",
                text: $text,
                onEditingChanged: { _ in print("changed") },
                onCommit: { print("commit") }
            )
        }
    }
    

As you can see in the example above, _TextField_ allows us to handle
_onEditingChanged_ and _onCommit_ events. Let’s learn what the difference
between them. _TextField_ calls _onEditingChanged_ closure whenever the user
starts or finishes editing text. It also passes a boolean value that describes
a starting or finishing event. Whenever a user performs an action like
pressing the return key, _TextField_ calls _onCommit_ closure.

####  TextField formatters

OK, we learned basics, and now we can move to a more interesting feature of
_TextFields_ . You might be noticed that _TextField_ has a few overloads that
accept _Formatter_ . These overloads allow us to bind a _TextField_ to raw
data and present it after converting to a string by using selected _Formatter_
instance. Let’s take a look at a quick example that will help us to understand
how it works.

    
    
    extension NumberFormatter {
        static var currency: NumberFormatter {
            let formatter = NumberFormatter()
            formatter.numberStyle = .currency
            return formatter
        }
    }
    
    struct ContentView: View {
        @State private var price = 99
    
        var body: some View {
            TextField(
                "type something...",
                value: $price,
                formatter: NumberFormatter.currency
            )
        }
    }
    

_TextField_ uses provided _Formatter_ while converting between the string that
user edits and the underlying raw value. In case when _Formatter_ is unable to
perform a conversion, the value will not be modified. Try to type some letters
that _Formatter_ is not able to convert to see what will happen.

####  New Formatter API

Swift Foundation provides us new Formatter API, which is available on iOS 15
and macOS 12. The new Formatter API allows us quickly build reusable
formatters using the builder design pattern. Fortunately, _TextField_ supports
the new API.

    
    
    @MainActor final class InsightsStore: ObservableObject {
        @Published private(set) var bodyFatUnit = HKUnit.percent()
        @Published var bodyFat: Double?
        
        func save() async {
        // ...
        }
    }
    
    struct BodyFatLoggingView: View {
        @ObservedObject var store: InsightsStore
        @Environment(\.dismiss) private var dismiss
        
        var body: some View {
            Form {
                Section {
                    HStack {
                        Text(store.bodyFatUnit.unitString)
                        TextField(
                            "bodyFat",
                             value: $store.bodyFat,
                             format: .percent.precision(.fractionLength(0...1))
                        )
                            .keyboardType(.numbersAndPunctuation)
                            .multilineTextAlignment(.trailing)
                    }
                }
                
                Section {
                    Button("save") {
                        Task {
                            await store.saveBodyFat()
                            dismiss()
                        }
                    }
                }
            }
        }
    }
    

####  Styling

SwiftUI provides us a few styles and the _textFieldStyle_ modifier that we can
use to apply styles to our _TextFields_ in the app. _textFieldStyle_ modifier
uses the environment to pass the style to every view inside the environment.
It looks very similar to the _buttonStyle_ modifier that discussed in the
previous post.

> To learn more about _buttonStyle_ modifier, take a look at my [ “Mastering
> buttons in SwiftUI post” ](/2020/02/19/mastering-buttons-in-swiftui/) .
    
    
    struct ContentView: View {
        @State private var text = ""
    
        var body: some View {
            TextField("type something...", text: $text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
        }
    }
    

SwiftUI has a _TextFieldStyle_ protocol that we can use to provide styling to
our _TextFields_ . Let’s take a look at how we can use it.

    
    
    struct SuperCustomTextFieldStyle: TextFieldStyle {
        func _body(configuration: TextField<_Label>) -> some View {
            configuration
                .padding()
                .border(Color.accentColor)
        }
    }
    
    struct ContentView: View {
        @State private var text = ""
    
        var body: some View {
            TextField("type something...", text: $text)
                .textFieldStyle(SuperCustomTextFieldStyle())
        }
    }
    

It looks like there is some compiler magic behind this protocol because it
works with __body_ function, which is not a part of _TextFieldStyle_ .

> SwiftUI uses environment to pass system-wide and application-related
> information. You can also populate environment with your custom objects. To
> learn more about environment, take a look at my [ “The power of Environment
> in SwiftUI” ](/2019/08/21/the-power-of-environment-in-swiftui/) post.

####  Conclusion

This week we learned the things behind the _TextField_ component. It provides
us an interesting raw data formatting feature that we don’t have in _UIKit_ .
I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Lock screen widgets in SwiftUI

##  Lock screen widgets in SwiftUI

30 Aug 2022

One of the most requested features for iOS was customizable lock screens. We
can populate our lock screen with glanceable widgets. Implementing a lock
screen widget is straightforward because its API shares the same code with
home screen widgets. This week we will learn how to implement lock screen
widgets for our apps.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Let’s start with a code you might already have in your app for displaying home
screen widgets.

    
    
    struct WidgetView: View {
        let entry: Entry
        
        @Environment(\.widgetFamily) private var family
        
        var body: some View {
            switch family {
            case .systemSmall:
                SmallWidgetView(entry: entry)
            case .systemMedium:
                MediumWidgetView(entry: entry)
            case .systemLarge, .systemExtraLarge:
                LargeWidgetView(entry: entry)
            default:
                EmptyView()
            }
        }
    }
    

In the example above, we have a typical view defining a widget. We use the
environment to understand the widget family and display a properly sized view.
All we need to do to support lock screen widgets is to remove the default
statement and implement all the new cases defining lock screen widgets.

    
    
    struct WidgetView: View {
        let entry: Entry
        
        @Environment(\.widgetFamily) private var family
        
        var body: some View {
            switch family {
            case .systemSmall:
                SmallWidgetView(entry: entry)
            case .systemMedium:
                MediumWidgetView(entry: entry)
            case .systemLarge, .systemExtraLarge:
                LargeWidgetView(entry: entry)
            case .accessoryCircular:
                Gauge(value: entry.goal) {
                    Text(verbatim: entry.label)
                }
                .gaugeStyle(.accessoryCircularCapacity)
            case .accessoryInline:
                Text(verbatim: entry.label)
            case .accessoryRectangular:
                VStack(alignment: .leading) {
                    Text(verbatim: entry.label)
                    Text(entry.date, format: .dateTime)
                }
            default:
                EmptyView()
            }
        }
    }
    

It would be best to remember that the system uses different rendering modes
for lock screen and home screen widgets. The system provides us with three
different rendering modes.

  1. Full-color mode for home screen widgets and watchOS complications supporting colors. And yes, you can also use WidgetKit to implement watchOS complications, starting with watchOS 9. 
  2. Vibrant mode is where the system desaturates text, images, and gauges into monochrome and colors them properly for the Lock Screen background. Vibrant mode is also used in StandBy. 
  3. The accented mode is used only on watchOS, where the system divides the widget into two groups, default and accented. The system colors the accented part of your widget with the tint color the user chooses in the watch face settings. 

> Look at my dedicated [ “Building widgets in SwiftUI” ](/2020/09/09/building-
> widgets-in-swiftui/) post to learn more about home screen widgets.

Rendering mode is available via the SwiftUI environment, so you can always
check which rendering mode is active and reflect it in your design. For
example, you might use different images with different rendering modes.

    
    
    struct WidgetView: View {
        let entry: Entry
        
        @Environment(\.widgetRenderingMode) private var renderingMode
        
        var body: some View {
            switch renderingMode {
            case .accented:
                AccentedWidgetView(entry: entry)
            case .fullColor:
                FullColorWidgetView(entry: entry)
            case .vibrant:
                VibrantWidgetView(entry: entry)
            default:
                EmptyView()
            }
        }
    }
    

As you can see in the example above, we use the _widgetRenderingMode_
environment value to get the actual rendering mode and behave differently. As
I said before, in the accented mode, the system divides your widget into two
parts and colors them specially. You can mark the part of your view hierarchy
with the _widgetAccentable_ view modifier. The system will know which views
apply the tint color in this case.

    
    
    struct AccentedWidgetView: View {
        let entry: Entry
        var body: some View {
            HStack {
                Image(systemName: "moon")
                    .widgetAccentable()
                Text(verbatim: entry.label)
            }
        }
    }
    

Finally, we need to configure our widget with the supported types.

    
    
    @main
    struct MyAppWidget: Widget {
        let kind: String = "Widget"
        
        var body: some WidgetConfiguration {
            StaticConfiguration(kind: kind, provider: Provider()) { entry in
                WidgetView(entry: entry)
                    .containerBackground(.regularMaterial, for: .widget)
            }
            .configurationDisplayName("My app widget")
            .supportedFamilies(
                [
                    .systemSmall,
                    .systemMedium,
                    .systemLarge,
                    .systemExtraLarge,
                    .accessoryInline,
                    .accessoryCircular,
                    .accessoryRectangular
                ]
            )
        }
    }
    

As you can see in the example above, we use the _containerBackground_ view
modifier allowing us to set a removable background for the view. It is
required for all widgets to use the removable background from iOS 17. The
system removes the background in StandBy and in smart stack on watch.

Today we learned how to implement new lock screen widgets in iOS 16. Remember
that we can reuse the same API to build watchOS complications. And you can
easily share the widget codebase by looking into environment values to
understand which rendering mode is active at the very moment. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this article. Thanks for reading, and see you
next week!



# Mastering TimelineView in SwiftUI

##  Mastering TimelineView in SwiftUI

18 May 2022

TimelineView is a SwiftUI view type that updates its body according to a
provided schedule. We used to see SwiftUI views updating its body whenever the
data it presents changes. _TimelineView_ doesn’t follow this rule and allows
us to build a super-custom schedule to update its content in a precise way. We
will learn how to use _TimelineView_ to create time-based views this week.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

_TimelineView_ reevaluates its body on the schedule we provide. Let’s look at
the quick example where we draw an animated circle for a minute.

    
    
    struct ContentView: View {
        var body: some View {
            TimelineView(.animation) { context in
                let value = secondsValue(for: context.date)
    
                Circle()
                    .trim(from: 0, to: value)
                    .stroke()
            }
        }
    
        private func secondsValue(for date: Date) -> Double {
            let seconds = Calendar.current.component(.second, from: date)
            return Double(seconds) / 60
        }
    }
    

In the example above, we use _TimelineView_ with the _animation_ schedule. The
_animation_ schedule is the system-provided scheduler that uses animation
duration on the current platform and reevaluates its body very often to
provide a nice transition. The second parameter is the _ViewBuilder_ closure
defining a view that _TimelineView_ should draw. It also takes the single
parameter called _context_ . The _context_ contains the date from the
scheduler that triggers the update. In our example, we use the _date_ field to
draw the circle.

> To learn more about how SwiftUI updates views, take a look at my [ “You have
> to change mindset to use SwiftUI”
> ](https://swiftwithmajid.com/2019/11/19/you-have-to-change-mindset-to-use-
> swiftui/) post.

####  Cadence

The second field of the _Context_ type is the cadence. The cadence represents
the rate at which _TimelineView_ updates, and it might change many times
during the view’s lifecycle. For example, running the _TimelineView_ on Apple
Watch might decrease cadence while the user lowers the wrist. Fortunately, the
_Cadence_ type conforms to _Comparable_ protocol, and we can easily compare
them.

    
    
    struct ContentView: View {
        var body: some View {
            TimelineView(.animation) { context in
                let date = context.date
                let value = context.cadence <= .live ?
                    nanosValue(for: date): secondsValue(for: date)
    
                Circle()
                    .trim(from: 0, to: value)
                    .stroke()
            }
        }
    
        private func secondsValue(for date: Date) -> Double {
            let seconds = Calendar.current.component(.second, from: date)
            return Double(seconds) / 60
        }
    
        private func nanosValue(for date: Date) -> Double {
            let seconds = Calendar.current.component(.second, from: date)
            let nanos = Calendar.current.component(.nanosecond, from: date)
            return Double(seconds * 1_000_000_000 + nanos) / 60_000_000_000
        }
    }
    

Here we use the cadence parameter to understand how fluid our animation should
be. The _Cadence_ enum provides three cases: _live_ , _seconds_ , and
_minutes_ .

####  Schedulers

We touched on the basics of _TimelineView_ . Let’s move forward and learn
about schedulers provided by SwiftUI and how we can build a custom scheduler.
SwiftUI provides us with another two schedulers: _everyMinute_ and _periodic_
scheduler. The _everyMinute_ scheduler updates the timeline every minute. The
_periodic_ scheduler allows us to give a start date and interval, after which
another update event should be fired.

    
    
    struct ContentView: View {
        var body: some View {
            TimelineView(.periodic(from: .now, by: 5)) { context in
                let value = secondsValue(for: context.date)
    
                Circle()
                    .trim(from: 0, to: value)
                    .stroke()
            }
        }
    
        private func secondsValue(for date: Date) -> Double {
            let seconds = Calendar.current.component(.second, from: date)
            return Double(seconds) / 60
        }
    }
    

The periodic schedule is good enough to cover almost all the needed cases, but
we can also build a custom schedule. We need to create a type conforming to
the _TimelineSchedule_ protocol and implement a single requirement.

    
    
    final class DailySchedule: TimelineSchedule {
        typealias Entries = [Date]
    
        func entries(from startDate: Date, mode: Mode) -> Entries {
            (1...30).map { startDate.addingTimeInterval(Double($0 * 24 * 3600)) }
        }
    }
    
    extension TimelineSchedule where Self == DailySchedule {
        static var daily: Self { .init() }
    }
    
    struct ContentView: View {
        var body: some View {
            TimelineView(.daily) { context in
                let value = dayValue(for: context.date)
    
                Circle()
                    .trim(from: 0, to: value)
                    .stroke()
            }
        }
    
        private func dayValue(for date: Date) -> Double {
            let day = Calendar.current.component(.day, from: date)
            return Double(day) / 30
        }
    }
    

As you can see in the example above, we have a custom schedule that generates
a timeline from the starting point on a daily basis.

####  Conclusion

Today we learned how to use the TimelineView to build views updating with a
specific period. It might be helpful while creating timer apps or custom
animations. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# UI Testing using Page Object pattern in Swift

##  UI Testing using Page Object pattern in Swift

24 Mar 2021

We talked a lot about different design patterns, which help us maintain the
codebase by solving various issues. But what about testing? What can we do to
keep our UI tests in a maintainable and consistent state? This week we will
talk about the Page Object pattern that allows us to build a foundation for
our UI tests.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basic UI test

Let’s start first by tackling the problems of a simple UI test.

    
    
    final class LoginTests: XCTestCase {
        var app: XCUIApplication!
    
        override func setUp() {
            continueAfterFailure = false
            app = XCUIApplication()
            app.launchArguments = ["testing"]
            app.launch()
        }
    
        func testLoginFlow() {
            let email = app.textFields["email"]
            email.tap()
            email.typeText("cmecid@gmail.com")
    
            let pwd = app.secureTextFields["password"]
            pwd.tap()
            pwd.typeText("pwd")
    
            app.buttons["login"].tap()
    
            let message = app.staticTexts["Hello World!"]
            XCTAssertTrue(message.waitForExistence(timeout: 5))
        }
    }
    

Here is an example of a typical UI test where we have a code that runs the
app, propagates some launching arguments, navigates through the app, interacts
with your views, and validates the state of UI.

> To learn more about the basics of UI testing in Swift, take a look at my [
> “UI Testing in Swift with XCTest framework” ](/2021/03/18/ui-testing-in-
> swift-with-xctest-framework/) post.

This code has a few downsides. First of all, it has the app launching logic
that we will use in most of our UI tests. I think it is better to extract it
into the _UITestCase_ class that defines a UI test and handles common logic
like app launching and making screenshots at the end of the UI test.

    
    
    class UITestCase: XCTestCase {
        var app: XCUIApplication!
    
        override func setUp() {
            continueAfterFailure = false
            app = XCUIApplication()
            app.launchArguments = ["testing"]
            app.launch()
        }
    
        override func tearDown() {
            let screenshot = XCUIScreen.main.screenshot()
            let attachment = XCTAttachment(screenshot: screenshot)
            attachment.lifetime = .deleteOnSuccess
            add(attachment)
            app.terminate()
        }
    }
    

Here we have the new _UITestCase_ class that defines a UI test case and
handles typical setup and teardown logic. For example, we have to launch the
app before every test and terminate the app after every test. We also make a
screenshot of the app whenever the test finishes its work. We keep it only for
failing tests. It might be handy to look at the failing test screenshot.
Usually, it helps to understand what is wrong with the state of UI.

    
    
    final class LoginTests: UITestCase {
        func testLoginFlow() {
            let email = app.textFields["email"]
            email.tap()
            email.typeText("cmecid@gmail.com")
    
            let pwd = app.secureTextFields["password"]
            pwd.tap()
            pwd.typeText("pwd")
    
            app.switches["rememberMe"].tap()
            app.buttons["login"].doubleTap()
            app.buttons["login"].twoFingerTap()
    
            let message = app.staticTexts["Hello World!"]
            XCTAssertTrue(message.waitForExistence(timeout: 5))
        }
    }
    

Now it looks much better but still has other problems. The example above mixes
what we do and how we do it. It exposes the things which should be hidden,
like accessibility identifiers and interaction logic.

The code above is not reusable. We might need to use the same login flow in
other UI tests, but we don’t have a way to reuse it. Even if we copy this code
and paste it into another UI test, we will have a classical code duplication
problem. What if the view hierarchy of the login screen will change in the
future? Should I fix all the UI tests that use login flow?

####  Page Object pattern

Page Object is a type that defines all the interactions of the particular
screen and provides you all the needed functions to verify the UI state of
that screen. This term appeared first in web page testing, which is why it is
called [ Page Object ](https://www.martinfowler.com/bliki/PageObject.html) .
Let’s try to introduce this pattern in our codebase.

    
    
    protocol Screen {
        var app: XCUIApplication { get }
    }
    
    struct LoginScreen: Screen {
        let app: XCUIApplication
    
        private enum Identifiers {
            static let email = "email"
            static let password = "password"
            static let login = "login"
            static let error = "error"
        }
    
        func typeEmail(_ email1: String) -> Self {
            let email = app.textFields[Identifiers.email]
            email.tap()
            email.typeText(email1)
            return self
        }
    
        func tapLoginExpectingError() -> Self {
            app.buttons[Identifiers.login].tap()
            let error = app.staticTexts[Identifiers.error]
            XCTAssertTrue(error.waitForExistence(timeout: 5))
            return self
        }
    
        func tapLogin() -> MessageScreen {
            app.buttons[Identifiers.login].tap()
            return MessageScreen(app: app)
        }
    
        func typePassword(_ password: String) -> Self {
            let pwd = app.secureTextFields[Identifiers.password]
            pwd.tap()
            pwd.typeText(password)
            return self
        }
    }
    

In the example above, we have the _LoginScreen_ struct. I decide to use the
word screen because we don’t have pages in iOS apps, and the screen sounds
more familiar.

As you can see, _LoginScreen_ hides all the complexity of the UI test under
the hood and provides you user-friendly functions to interact with the login
screen.

    
    
    struct MessageScreen: Screen {
        let app: XCUIApplication
    
        func verifyMessage(_ message: String) -> Self {
            let message = app.staticTexts[message]
            XCTAssertTrue(message.waitForExistence(timeout: 5))
            return self
        }
    }
    

Methods of a Page Object should return itself or an instance of another Page
Object. It allows us to build readable and chainable UI tests. For example,
the _tapLogin_ method navigates you to another screen. That’s why it is
responsible for creating and returning the _MessageScreen_ Page Object.

    
    
    final class LoginTests: UITestCase {
        func testLoginFlow() {
            LoginScreen(app: app)
                .typeEmail("Cmecid@gmail.com")
                .typePassword("password")
                .tapLoginExpectingError()
                .typeEmail("Cmecid@gmail.com")
                .typePassword("pwd")
                .tapLogin()
                .verifyMessage("Hello World!")
        }
    }
    

Now our test looks in a declarative way where the Page Object pattern hides
all the implementation details. In the future, you might have breaking changes
in the login screen, but you don’t need to change all the UI tests that use
the login screen. You only need to make changes in the Page Object that is
responsible for the login screen.

####  Conclusion

UI tests are expensive and fragile but vital and usable. That’s why you should
take care of them as much as you take care of your main codebase. The Page
Object pattern is a great way to simplify your UI tests and reuse the logic
across the many UI tests. I hope you enjoy the post. Feel free to follow me on
[ Twitter ](https://twitter.com/mecid) and ask your questions related to this
article. Thanks for reading, and see you next week!



# Navigation with Flow Controllers

##  Navigation with Flow Controllers

20 Feb 2019

Last month I started refactoring navigation flow in my pet project. I’ve been
using Coordinator pattern for a while, but now I decide to switch to a more
native and simple approach like Flow Controllers. Today we will talk about
Flow Controllers and why it is more native than Coordinators.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Coordinators

Coordinator is a plain object which handles the navigation flow. It owns
rootViewController, where it pushes next ViewControllers. ViewControllers and
Coordinators talk with each other by delegates. It gives us an opportunity to
keep ViewControllers reusable, by extracting navigation knowledge from them.
More about Coordinator pattern you can read in the original [ post by Soroush
Khanlou ](http://khanlou.com/2015/01/the-coordinator/) .

The one huge problem which I have with Coordinator pattern is keeping it in
sync with ViewController hierarchy. Every Coordinator has a childCoordinators
field which is used to keep navigation sub-flows. Users can finish sub-flow
anytime they want by pressing back button in the navigation bar. Coordinators
by default can’t handle this situation, and our child coordinator will live in
childCoordinators array forever, which leads to huge memory leak.

To fix this problem, we have to implement a navigation controller delegate in
a coordinator to understand when the user finishes flow by pressing back
button and remove child coordinator from the array. This solution described
very well in the original [ post ](http://khanlou.com/2017/05/back-buttons-
and-coordinators/) . I think we can avoid this complexity and boilerplate by
using Flow Controllers.

####  Flow Controllers

Flow Controller is a UIViewController subclass which handles navigation flow
by using ViewController containment feature. Let’s dive into the code example.
Assume that we have Master-Details flow, where our app navigates from product
list screen to product details.

    
    
    import UIKit
    
    class ProductsFlowController: UIViewController {
        private let navigation = UINavigationController()
    
        override func viewDidLoad() {
            super.viewDidLoad()
            let productsVC = ProductListViewController()
            productsVC.delegate = self
            navigation.show(productsVC, sender: self)
            add(navigation)
        }
    }
    
    protocol ProductsFlowControllerDelegate: AnyObject {
        func startDetails(for productId: Int)
    }
    
    extension ProductsFlowController: ProductsFlowControllerDelegate {
        func startDetails(for productId: Int) {
            let productVC = ProductDetailsViewController(productId: productId)
            navigation.show(productVC, sender: self)
        }
    }
    

As you can see, ProductsFlowController creates UINavigationController, add it
as a child, then it pushes ProductListViewController to the
NavigationController which it owns. It also sets delegate to
ProductListViewController which will be used to ask FlowController to show
details of the selected product.

Here is my extension which I use to add child ViewControllers to a parent.

    
    
    extension UIViewController {
        func add(_ child: UIViewController) {
            addChild(child)
            view.addSubview(child.view)
            child.didMove(toParent: self)
        }
    }
    

####  Handling sub-flows with Flow Controllers

Let’s take a look at another example where we have to start sub-flow which
handled by separated Flow Controller.

    
    
    extension ProductsFlowController: ProductsFlowControllerDelegate {
        func startDetails(for productId: Int) {
            let detailsFlow = DetailsFlowController(productId: productId)
            navigation.show(detailsFlow, sender: self)
        }
    }
    

In this example, we start DetailsFlowController which handles another flow. We
don’t need to add it to childs array as we do it with Coordinators. It is
plain UIViewController, as soon as the user presses the back button in the
navigation bar, UINavigationController will remove this Flow Controller both
from the screen and the memory. As you can see by using UIViewController as
FlowControllers, we don’t need to deal with the synchronization between flow
and visible ViewController. It is coming out of the box from iOS SDK.

####  AppFlowController

Very often we are using UITabBarController as a rootViewController in our app.
Let’s extract tab configuration from AppDelegate and wrap inside
AppFlowController. Here is a quick example of this idea.

    
    
    import UIKit
    
    class AppFlowViewController: UIViewController {
        private let tabController = UITabBarController()
    
        override func viewDidLoad() {
            super.viewDidLoad()
            tabController.viewControllers = [ProductsFlowController()]
            add(tabController)
        }
    }
    
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        var window: UIWindow?
    
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
            window = UIWindow(frame: UIScreen.main.bounds)
            window?.rootViewController = AppFlowViewController()
            window?.makeKeyAndVisible()
            return true
        }
    }
    

As you can see in the example above, we create AppFlowController which creates
UITabBarController and populate every tab with separated navigation flow.

####  Conclusion

Today we talked about navigation flow and how we can extract it into Flow
Controllers by using ViewController containment feature. It gives us an
opportunity to reuse our ViewControllers and make them more testable. We will
continue to cover ViewController containment feature in next posts.

Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading and see you next week!



# Building custom layout in SwiftUI. Caching.

##  Building custom layout in SwiftUI. Caching.

29 Nov 2022

In the previous post, we talked about the basics of the new _Layout_ protocol.
Today I’m going to continue the series of posts about the new opportunity to
build super-custom reusable layouts by covering the idea of caching layout
information and tuning its performance.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

SwiftUI calls functions of your custom layout many times across the lifecycle
to measure different sizing options during the layout process. It caches a few
things automatically, but you can also implement your own caching mechanics if
you need to improve your layout performance.

> To learn more about the basics of the _Layout_ protocol, take a look at my
> dedicated [ “Building custom layout in SwiftUI. Basics”
> ](/2022/11/16/building-custom-layout-in-swiftui-basics/) post.

The _Layout_ protocol has an associated type called _Cache_ , which is _Void_
by default. But you can define any type you need instead and implement your
custom caching behavior. The easiest way is to define a nested type with the
name _Cache_ inside your custom layout type.

    
    
    struct FlowLayout: Layout {
        struct Cache {
            var sizes: [CGSize] = []
        }
    }
    

The _Layout_ protocol has the _makeCache_ function, which we can implement to
provide a cache instance and make some initial calculations to store during
layout changes.

    
    
    struct FlowLayout: Layout {
        struct Cache {
            var sizes: [CGSize] = []
        }
        
        func makeCache(subviews: Subviews) -> Cache {
            let sizes = subviews.map { $0.sizeThatFits(.unspecified) }
            return Cache(sizes: sizes)
        }
    }
    

The _Layout_ protocol also provides the _updateCache_ function, which we can
use to update our cache. The SwiftUI framework calls this function as soon as
children of the layout change. You can ignore the updateCache function. In
this case, SwiftUI calls the _makeCache_ function and builds the cache from
scratch.

    
    
    struct FlowLayout: Layout {
        struct Cache {
            var sizes: [CGSize] = []
        }
        
        func makeCache(subviews: Subviews) -> Cache {
            let sizes = subviews.map { $0.sizeThatFits(.unspecified) }
            return Cache(sizes: sizes)
        }
        
        func updateCache(_ cache: inout Cache, subviews: Subviews) {
            cache.sizes = subviews.map { $0.sizeThatFits(.unspecified) }
        }
    }
    

As you can see in the example above, the _updateCache_ function provides cache
instance as the _inout_ parameter allowing us to mutate it during the call.

Keep in mind that both _makeCache_ and _updateCache_ functions provide you
only the instance of the _Subviews_ type, a proxy on the list of children. It
doesn’t provide you with the proposed size and bounds rectangle, which means
we can’t calculate the exact position of the views.

Instead, the _Layout_ protocol allows us to mutate our cache in _sizeThatFits_
and _placeSubviews_ functions where we have the proposed size.

    
    
    struct FlowLayout: Layout {
        // ....
    
        func placeSubviews(
            in bounds: CGRect,
            proposal: ProposedViewSize,
            subviews: Subviews,
            cache: inout Cache
        ) {
            var lineX = bounds.minX
            var lineY = bounds.minY
            var lineHeight: CGFloat = 0
            
            for index in subviews.indices {
                if lineX + cache.sizes[index].width > (proposal.width ?? 0) {
                    lineY += lineHeight
                    lineHeight = 0
                    lineX = bounds.minX
                }
                
                let position = CGPoint(
                    x: lineX + cache.sizes[index].width / 2,
                    y: lineY + cache.sizes[index].height / 2
                )
                
                // you can populate cache
                // with additional information here
                
                lineHeight = max(lineHeight, cache.sizes[index].height)
                lineX += cache.sizes[index].width
                
                subviews[index].place(
                    at: position,
                    anchor: .center,
                    proposal: ProposedViewSize(cache.sizes[index])
                )
            }
        }
    }
    

As you can see in the example above, we populate our cache with the exact
position values during the _placeSubviews_ function. Whenever SwiftUI calls
this function, we can check our cache and place subviews in the cached
position. In the case where our cache is empty, we can populate it with the
correct values.

The _Layout_ protocol provides us with all the necessary APIs for building
performant custom layouts. We will continue learning the massive set of APIs
SwiftUI gives us to create reusable and flexible layouts. Feel free to follow
me on [ Twitter ](https://twitter.com/mecid) and ask your questions related to
this post. Thanks for reading, and see you next week!



# Labels in SwiftUI

##  Labels in SwiftUI

23 Dec 2020

We often underestimate the power of simple things. The same feelings I had
during the first usage of _Label_ view in SwiftUI. It looks straightforward,
but it hides many use cases where it works great. Today we will talk about the
_Label_ view and its customization capabilities.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

_Label_ is a standard component for user interface items, consisting of an
icon with a title. One of the most common and recognizable user interface
components is the combination of an icon and a label. Let’s take a look at how
easily we can use it in code.

    
    
    struct ContentView: View {
        var body: some View {
            // SF Symbol
            Label("Heart Rate", systemImage: "heart.fill")
            
            // Image from app bundle
            Label("ECG", image: "ecg")
        }
    }
    

![label](/public/label.png)

As you can see, we create a label by passing two parameters to the
initializer. The first one is a title that we can pass as a plain string or
_LocalizedStringKey_ . The second one is an image, a system image from the SF
Symbols collection, or your custom image from the app bundle.

> To learn more about _LocalizedStringKey_ , take a look at [ “Localization in
> SwiftUI” ](/2019/10/16/localization-in-swiftui/) post.

Another initializer overload allows you to define a label using two
_@ViewBuilder_ closures to build the _Label_ view.

    
    
    struct ContentView: View {
        var body: some View {
            Label {
                Text("Hello")
            } icon: {
                Image(systemName: "heart")
            }
        }
    }
    

The main thing that I love about the _Label_ view is how it deals with
accessibility. It combines both image and title in a single accessibility
element and uses the title as an accessibility label for the whole view. This
is usually what we want to achieve while using a stack with an image and text
describing that image.

> To learn more about accessibility labels and VoiceOver, take a look at my [
> “Accessibility in SwiftUI” ](/2019/09/10/accessibility-in-swiftui/) post.

####  Styling

SwiftUI provides us _LabelStyle_ protocol to implement different styling
options for our labels. There are already three style options coming with
SwiftUI out of the box. You might be already familiar with style protocols in
SwiftUI, as I already covered it on my blog a few times.

SwiftUI gives us _DefaultLabelStyle_ , _IconOnlyLabelStyle_ and
_TitleOnlyLabelStyle_ style options to use out of the box. The default one is
_DefaultLabelStyle_ that shows both title and image. _IconOnlyLabelStyle_
shows only the image, and _TitleOnlyLabelStyle_ shows the title only.

    
    
    struct ContentView: View {
        var body: some View {
            Label("Heart Rate", systemImage: "heart.fill")
                .labelStyle(IconOnlyLabelStyle())
            Label("ECG", image: "ecg")
                .labelStyle(TitleOnlyLabelStyle())
        }
    }
    

The great thing about style protocols is that you can create your own
implementation and place the items the way you need. Let’s try to build
another style that will place the icon and title in a horizontal or vertical
stack depending on the current accessibility category.

    
    
    struct AccessibleLabelStyle: LabelStyle {
        @Environment(\.sizeCategory) var sizeCategory
    
        @ViewBuilder
        func makeBody(configuration: Configuration) -> some View {
            if sizeCategory.isAccessibilityCategory {
                VStack {
                    configuration.icon
                    configuration.title
                }
            } else {
                HStack {
                    configuration.icon
                    configuration.title
                }
            }
        }
    }
    
    struct ContentView: View {
        var body: some View {
            Button(action: {}) {
                Label("Heart Rate", systemImage: "heart.fill")
            }.labelStyle(AccessibleLabelStyle())
        }
    }
    

As you can see in the example above, we create a custom label style called
_AccessibleLabelStyle_ . It uses the environment to read the size category and
layout items appropriately. We use _labelStyle_ modifier to set and share the
style for labels using the environment.

> To learn more about sharing styles using the environment, take a look at my
> [ “Styling custom SwiftUI views using environment” ](/2020/12/09/styling-
> custom-swiftui-views-using-environment/) post.

####  Conclusion

Today we learned about another great SwiftUI view that provides us a lot of
ways for customization and styling. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this article. Thanks for reading, and see you next week!



# Managing app in SwiftUI

##  Managing app in SwiftUI

19 Aug 2020

One of the most important things that Apple did release this year was the
native app and scene management for SwiftUI apps. This week we will understand
how to manage our apps using _App_ protocol without old _AppDelegate_ . We
will learn how to achieve the same set of features with _App_ protocol.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Entry point

[ SE-0281 ](https://github.com/apple/swift-
evolution/blob/master/proposals/0281-main-attribute.md) introduced type-based
program entry points for Swift language. This proposal provides us _@main_
attribute that allows us to mark the app’s entry point. Swift compiler will
recognize this entry point and launch it by running the static main function.
Let’s take a look at the smallest “Hello World” app example.

    
    
    @main
    struct MyApp: App {
        var body: some Scene {
            WindowGroup {
                Text("Hello World!")
            }
        }
    }
    

As you can see in the example above, we create an app by conforming to _App_
protocol and implementing the single requirement, _body_ property. _Body_
property should return an instance of scene protocol, and we use the
_WindowGroup_ scene here. _WindowGroup_ is a standard scene type provided by
SwiftUI that handles multiple windows on macOS or various scenes on iPadOS. We
will deep dive into scene management in [ another post
](https://swiftwithmajid.com/2020/08/26/managing-scenes-in-swiftui/) .

You may notice that there is no static main function in the code example that
Swift compiler uses as the entry point. _App_ protocol has the extension that
defines the static main function; that’s why we don’t need to care about it.

####  didBecomeActive and didEnterBackground

We have learned the basics of _App_ protocol, and it is time to move forward
to understand how we can replace _AppDelegate_ callbacks like
_didBecomeActive_ or _didEnterBackground_ .

    
    
    import SwiftUI
    
    @main
    struct CardioBotApp: App {
        @Environment(\.scenePhase) var scenePhase
    
        @StateObject var store = Store(
            initialState: AppState(),
            reducer: appReducer,
            environment: AppEnvironment()
        )
    
        var body: some Scene {
            WindowGroup {
                RootView()
                    .environmentObject(store)
                    .onChange(of: scenePhase) { phase in
                        if phase == .active {
                            store.send(.fetch)
                        }
                    }
            }
        }
    }
    

SwiftUI uses the environment to store the phase of the current scene. You can
access it by using the scene phase environment value. The excellent addition
to the new app and scene management API is the _onChange_ modifier. It runs
the provided closure on every change of the value that you pass. In the
example above, we fetch data whenever the scene becomes active.

####  Deep linking

Another thing that we used to do in _AppDelegate_ is deep linking. SwiftUI
provides us a special _onOpenURL_ modifier that allows us to handle links.

    
    
    @main
    struct MyApp: App {
        var body: some Scene {
            WindowGroup {
                Text("Hello World!")
                    .onOpenURL { url in
                        if url.absoluteString.contains("today") {
                            // toggle state to navigate to today screen
                        }
                    }
            }
        }
    }
    

As you can see in the example above, we register a closure that handles URLs.
SwiftUI will run it whenever the app should open the URL. We can extract the
data from a URL and assign it to the state property that enables the
navigation link or switch tabs.

####  Handoff and user activity

Similarly to deep linking, SwiftUI provides us a modifier to handle Handoff
and user activity. We can use _onContinueUserActivity_ modifier in the very
same way as we use _onOpenURL_ modifier. Let’s take a look at another example.

    
    
    import SwiftUI
    
    @main
    struct MyApp: App {
        var body: some Scene {
            WindowGroup {
                Text("Hello World!")
                    .onContinueUserActivity("com.myapp.today") { userActivity in
                        // toggle state to navigate to today screen
                    }
            }
        }
    }
    

We use _onContinueUserActivity_ modifier to set a closure that will parse a
user activity. In the same way, as we did before, we can parse a user activity
and toggle state property that routes the navigation. SwiftUI will run this
closure as soon as the user continues activity.

####  UIApplicationDelegateAdaptor

As you can see, we can implement many _AppDelegate_ callbacks with _App_
protocol and the new set of modifiers that SwiftUI provides us. But there are
still some gaps.

For example, there is no way to register for remote notifications with _App_
protocol. That’s why SwiftUI gives us another type called
_UIApplicationDelegateAdaptor_ . We can merge the functionality of old
_AppDelegate_ with the new App protocol using _UIApplicationDelegateAdaptor_
property wrapper.

    
    
    final class AppDelegate: NSObject, UIApplicationDelegate {
        func applicationDidBecomeActive(_ application: UIApplication) {
            application.registerForRemoteNotifications()
        }
    }
    
    @main
    struct MyApp: App {
        @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate
    
        var body: some Scene {
            WindowGroup {
                Text("Hello World!")
            }
        }
    }
    

####  Conclusion

_App_ protocol is another step towards the declarative approach that Apple
gives us to build our apps. It allows us to replace old _AppDelegate_ with a
simple struct that conforms to _App_ protocol. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this article. Thanks for reading, and see you next week!



# Sharing content in SwiftUI

##  Sharing content in SwiftUI

28 Mar 2023

Apple introduced a brand new CoreTransferable framework and _ShareLink_ view
in SwiftUI, allowing us to share and export content from our apps very
declaratively. This week we will learn how to make data transferable and use
the new _ShareLink_ view in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  ShareLink

The new _ShareLink_ looks like a plain button but integrates the share sheet
and exports data in the provided format. Let’s look at the simple example of
using the _ShareLink_ view in SwiftUI.

    
    
    struct Food: Codable {
        var title: String
        var ingredients: [String]
    }
    
    struct ContentView: View {
        @State private var food = Food(title: "", ingredients: [])
        
        var body: some View {
            Form {
                Section {
                    TextField("title", text: $food.title)
                }
                
                Section {
                    ForEach($food.ingredients, id: \.self) { $item in
                        TextField("item", text: $item)
                    }
                    
                    Button("Add") {
                        food.ingredients.append("")
                    }
                    
                    ShareLink(
                        "Export",
                        item: food.ingredients.joined(separator: ","),
                        preview: SharePreview("Export \(food.title)")
                    )
                }
            }
        }
    }
    

As you can see in the example above, we have the _Food_ struct containing a
title and an array of ingredients. There is a form allowing us to populate the
instance of the _Food_ type with data. At the bottom of the form, we have an
instance of the _ShareLink_ view that exports the content of the food to a
plain string by joining ingredients. The code above is simple but handles a
share sheet presentation and data export.

But what about other data types like images, binary data, or any other custom
format? All the magic here is hidden behind _ShareLink’s_ **item** parameter.
It works with any type conforming to the _Transferable_ protocol. _String_ ,
_Data_ , and many other types conform to the _Transferable_ protocol out of
the box, and you don’t need to do anything to share them.

####  Transferable

Now we know how the _ShareLink_ view works in SwiftUI. It relies on the
_Transferable_ protocol from the CoreTransferable framework. But what if we
want to share our custom type? In this case, we must conform our type to the
_Transferable_ protocol.

    
    
    import CoreTransferable
    
    extension Food: Transferable {
        static var transferRepresentation: some TransferRepresentation {
            CodableRepresentation(contentType: .text)
        }
    }
    

The _Transferable_ protocol is simple and has the only requirement. We must
implement the _transferRepresentation_ property and return some instance of
the _TransferRepresentation_ type. The framework provides ready-to-use
representation types: _CodableRepresentation_ , _DataRepresentation_ ,
_FileRepresentation_ , and _ProxyRepresentation_ .

In the example above, we use the _CodableRepresentation_ because our _Food_
type conforms to the _Codable_ protocol. This conformance allows us to
automatically export any instance of the Food type as a JSON string.

We also can use _DataRepresentation_ if you can convert your value type into
an instance of the _Data_ type, or we can use _FileRepresentation_ whenever
the value represents a file on the disk.

    
    
    import CoreTransferable
    import UniformTypeIdentifiers
    
    extension UTType {
        static var food: UTType {
            UTType(exportedAs: "myapp.food.type")
        }
    }
    
    extension Food: Transferable {
        static var transferRepresentation: some TransferRepresentation {
            CodableRepresentation(contentType: .food)
            CodableRepresentation(contentType: .text)
        }
    }
    

The _transferRepresentation_ property is marked with the
_TransferRepresentationBuilder_ and allows us to combine different
representations. For example, you can define different representations for
different content types. Remember, the order makes sense; you should keep the
most important representations above others.

Today we learned about the new CoreTransferable framework and how to use the
_ShareLink_ view in SwiftUI. The CoreTransferable framework plays a massive
role in exporting your data from the app. But it works also behind the drag
and drop, and I will cover this part next week.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Customizing toolbars in SwiftUI

##  Customizing toolbars in SwiftUI

07 Sep 2022

Toolbars API is one of my favorite APIs in SwiftUI. It allows you to define
the toolbar and its items in a very declarative way behaving differently on
separate platforms. The next generation of the SwiftUI framework brings us
more ways of customizing toolbars. This week we will learn about new Toolbar
APIs in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Toolbar visibility

Let’s start with the new view modifier allowing us to control toolbar
visibility.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                Image("beach")
                    .resizable()
                    .scaledToFit()
            }
            .ignoresSafeArea(.container, edges: .top)
            .navigationTitle("Hello")
            .toolbar(.hidden, for: .navigationBar)
        }
    }
    

As you can see in the example above, the new toolbar view modifier allows us
to hide or show any toolbar controlled by SwiftUI. We can use it to control
the visibility of not only the navigation bar but also the tab and bottom
bars.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                Image("beach")
                    .resizable()
                    .scaledToFit()
            }
            .ignoresSafeArea(.container, edges: .top)
            .navigationTitle("Hello")
            .toolbar(.hidden, for: .tabBar)
        }
    }
    

> Look at my dedicated [ “Mastering toolbars in SwiftUI”
> ](/2020/07/15/mastering-toolbars-in-swiftui/) post to learn about Toolbar
> API basics.

####  Toolbar background visibility

Another new view modifier allows us to control the background visibility of
any bar owned by SwiftUI.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                Image("beach")
                    .resizable()
                    .scaledToFit()
            }
            .ignoresSafeArea(.container, edges: .top)
            .navigationTitle("Hello")
            .toolbarBackground(.hidden, for: .navigationBar)
        }
    }
    

The toolbar background visibility view modifier allows us to create nice
translucent effects whenever we want to show the image under the toolbar.

####  Toolbar color scheme

Another exciting addition to this year’s Toolbar API is the opportunity to
control the color scheme of the particular toolbar. You can set a preferred
color scheme for your toolbar independent of the view hierarchy’s color
scheme.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                Image("beach")
                    .resizable()
                    .scaledToFit()
            }
            .navigationTitle("Hello")
            .toolbarColorScheme(.dark, for: .navigationBar)
        }
    }
    

####  Toolbar title menu

iOS 16 provides a new user experience, allowing us to display a popup menu in
the title of our navigation bar.

    
    
    struct TitleMenuExample: View {
        @State private var date = Date.now
        @State private var datePickerShown = false
        
        var body: some View {
            NavigationStack {
                Text(date, style: .date)
                    .navigationTitle(Text(date, style: .date))
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbarTitleMenu {
                        Button("Pick another date") {
                            datePickerShown = true
                        }
                    }
                    .sheet(isPresented: $datePickerShown) {
                        DatePicker(
                            "Choose date",
                            selection: $date,
                            displayedComponents: .date
                        )
                        .datePickerStyle(.graphical)
                        .presentationDetents([.medium])
                        .presentationDragIndicator(.visible)
                    }
            }
        }
    }
    

![toolbar-title-menu](/public/toolbar-title-menu.png)

The code above displays a little arrow in the navigation bar’s title, allowing
the user to press it. SwiftUI shows a popup menu with a button presenting a
date picker in the modal sheet.

####  Toolbar role

Another new appearance in iPadOS 16 is the editor toolbar. You can set the
role of the toolbar to the editor. In this case, SwiftUI displays toolbar
items in the center of the particular toolbar. It also allows the user to
customize secondary toolbar items by adding and removing them.

    
    
    struct CollapsingToolbarItems: View {
        var body: some View {
            NavigationStack {
                Text("Hello")
                    .toolbar {
                        ToolbarItem(placement: .primaryAction) {
                            Button("Primary action") {}
                        }
                        
                        ToolbarItem(
                            id: "copy",
                            placement: .secondaryAction,
                            showsByDefault: true
                        ) {
                            Button("copy") {}
                        }
                        
                        ToolbarItem(
                            id: "delete",
                            placement: .secondaryAction,
                            showsByDefault: false
                        ) {
                            Button("delete") {}
                        }
                    }
                    .toolbarRole(.editor)
            }
        }
    }
    

In the example above, we set the toolbar role to the editor. We also set
identifiers for every toolbar item. SwiftUI uses identifiers to store the user
configuration of the toolbar setup. Remember that you should provide stable
identifiers for your toolbar items to provide a consistent toolbar
customization experience.

####  Secondary toolbar items

The current generation of the SwiftUI framework introduces the new placement
for secondary toolbar actions. It also automatically collapses them into a
single toolbar item displaying the list of collapsed items via a menu.

    
    
    struct SecondaryToolbarItemsExample: View {
        var body: some View {
            NavigationStack {
                Text("Hello")
                    .toolbar {
                        ToolbarItem(placement: .primaryAction) {
                            Button("Primary action") {}
                        }
                        
                        ToolbarItem(placement: .secondaryAction) {
                            Button("Secondary action 1") {}
                        }
                        
                        ToolbarItem(placement: .secondaryAction) {
                            Button("Secondary action 2") {}
                        }
                    }
                    
            }
        }
    }
    

####  Conclusion

Today we learned a bunch of new APIs allowing us to customize toolbars in
SwiftUI. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this article.
Thanks for reading, and see you next week!



# Using protocols as composable extensions

##  Using protocols as composable extensions

17 Jan 2019

Today we will talk about using protocols as composable pieces for our view
controllers. [ Protocols and Protocol Extensions ](/2019/01/23/maintaining-
state-in-view-controllers) are my second favorite Swift feature after
optionals. It helps us to create highly composable and reusable codebase
without inheritance. For years we were using inheritance as a gold programming
standard. But is it so good? Let’s take a look for simple _BaseViewController_
which we used to have in every project.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

    
    
    import UIKit
    
    class BaseViewController: UIViewController {
        private let activityIndicator = UIActivityIndicatorView(style: .whiteLarge)
    
        override func viewDidLoad() {
            super.viewDidLoad()
            view.addSubview(activityIndicator)
    
            activityIndicator.translatesAutoresizingMaskIntoConstraints = false
            NSLayoutConstraint.activate([
                activityIndicator.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor),
                activityIndicator.centerYAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerYAnchor)
                ])
        }
    
        func presenActivity() {
            activityIndicator.startAnimating()
        }
    
        func dismissActivity() {
            activityIndicator.stopAnimating()
        }
    
        func present(_ error: Error) {
            let alert = UIAlertController(title: error.localizedDescription, message: nil, preferredStyle: .alert)
            alert.addAction(.init(title: "Cancel", style: .cancel))
            present(alert, animated: true)
        }
    }
    

It looks straightforward and usable because most of our view controllers need
activity indicator while downloading data from the internet and error handling
in case of something goes wrong during the data download. But we don’t stop
with this, and we add more features to _BaseViewController_ over a time. It
starts bloating with a lot of general-purpose functions. Here we have at least
two main problems:

  1. Our _BaseViewController_ breaks the Single Responsibility Principle by implementing all these features in one place. Over time it will turn into Massive-View-Controller, which hard to understand and cover with tests. 
  2. Every view controller in our app inherit from _BaseViewController_ to use all these features. In case of a bug in _BaseViewController_ , we will have this bug in all view controllers in our app even if view controller is not using buggy functionality from _BaseViewController_ . 

####  Protocols for the rescue.

Protocol extensions feature was released with Swift 2.0 and bring real power
to protocol types which announce new paradigm of programming: Protocol
Oriented Programming. I recommend you to watch the [ talk
](https://developer.apple.com/videos/play/wwdc2015/408/) from WWDC about
protocols and protocol extensions.

Let’s go back to our topic. How can protocols help us? Let’s start by
declaring _ActivityPresentable_ protocol for presenting and dismissing an
activity indicator.

    
    
    protocol ActivityPresentable {
        func presentActivity()
        func dismissActivity()
    }
    
    extension ActivityPresentable where Self: UIViewController {
        func presentActivity() {
            if let activityIndicator = findActivity() {
                activityIndicator.startAnimating()
            } else {
                let activityIndicator = UIActivityIndicatorView(style: .whiteLarge)
                activityIndicator.startAnimating()
                view.addSubview(activityIndicator)
    
                activityIndicator.translatesAutoresizingMaskIntoConstraints = false
                NSLayoutConstraint.activate([
                    activityIndicator.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor),
                    activityIndicator.centerYAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerYAnchor)
                    ])
            }
        }
    
        func dismissActivity() {
            findActivity()?.stopAnimating()
        }
    
        func findActivity() -> UIActivityIndicatorView? {
            return view.subviews.compactMap { $0 as? UIActivityIndicatorView }.first
        }
    }
    

We extracted _presentActivity_ and _dismissActivity_ methods into the
particular protocol type. We add default implementation via protocol extension
for cases where Type which adopt this protocol is view controller. It gives us
the opportunity of using view controller methods and properties in our
protocol extension.

Let’s do the same for error presenting logic.

    
    
    protocol ErrorPresentable {
        func present(_ error: Error)
    }
    
    extension ErrorPresentable where Self: UIViewController {
        func present(_ error: Error) {
            let alert = UIAlertController(title: error.localizedDescription, message: nil, preferredStyle: .alert)
            alert.addAction(.init(title: "Cancel", style: .cancel))
            present(alert, animated: true)
        }
    }
    

Now we have two reusable protocol types which respect the Single
Responsibility Principle. We can add them as the extension to any view
controller which need this functionality. The nice thing is that we are adding
the only extension which needed in concrete view controller and not inherits
all the stuff from the _BaseViewController_ . Here is the usage example of
these protocols.

    
    
    class ViewController: UIViewController {
        override func viewDidLoad() {
            super.viewDidLoad()
            presentActivity()
        }
    }
    
    extension ViewController: ActivityPresentable, ErrorPresentable {}
    

Another opportunity here is that we can easily ignore default implementation
of the protocol to implement our customized _ActivityIndicator_ for some of
view controllers. Let’s take a look at the example.

    
    
    class CustomViewController: UIViewController {
        override func viewDidLoad() {
            super.viewDidLoad()
            presentActivity()
        }
    }
    
    extension CustomViewController: ActivityPresentable {
        func presentActivity() {
            // Custom activity presenting logic
        }
    
        func dismissActivity() {
    
        }
    }
    

While adopting _CustomViewController_ to _ActivityPresentable_ protocol, we
specify the custom implementation of _presentActivity_ and _dismissActivity_
methods.

####  Conclusion

As you can see, we can use protocols as simple extensions for our view
controller type. In the future posts, we will continue using protocols to
build reusable parts of view controller. We will touch associated type, and
conditional conformance features to develop more generic data based extensions
for view controllers.

Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for the reading and see you next week.



# How to create a property wrapper in Swift

##  How to create a property wrapper in Swift

11 Aug 2021

Property wrapper is a Swift language feature. The main goal here is wrapping
properties with a logic that we extract into a separate type to reuse it
across the codebase. This week, we will learn how to create a property wrapper
to read data in Keychain and be a good citizen in the SwiftUI world by
reacting to data changes.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

SwiftUI provides us _SceneStorage_ and _AppStorage_ property wrappers to
access data in scene memory and user defaults, respectively. Unfortunately, it
doesn’t give us a similar property wrapper to access Keychain, but we can
build it. Let me show you a code example that defines the usage of the
property wrapper we try to make.

    
    
    final class SettingsStore: ObservableObject {
        @SecureStorage(key: Constants.Keychain.useSleepMode)
        var useSleepMode = true
    }
    

As you can see in the example above, we use the _SecureStorage_ property
wrapper that needs a key to read data from Keychain. We also provide a default
value that we can override over time. And now, we can move to the
implementation details of the _SecureStorage_ property wrapper.

> To learn more about property wrappers in SwiftUI, take a look at my
> dedicated [ “Understanding Property Wrappers in SwiftUI”
> ](/2019/06/12/understanding-property-wrappers-in-swiftui/) post.

To create a property wrapper, we have to create a new type annotated with the
**@propertyWrapper** attribute. A property wrapper type must contain a field
named **wrappedValue** . Wrapped value is the heart of any property wrapper.
Swift will transparently access the wrapped value whenever you read or write
to any property that uses a property wrapper.

    
    
    import KeychainAccess
    import Foundation
    
    @propertyWrapper struct SecureStorage<Value: Codable> {
        private let key: String
        private let initialValue: Value
    
        private let decoder = JSONDecoder()
        private let encoder = JSONEncoder()
    
        private let keychain = Keychain(
            service: Constants.sharedGroup,
            accessGroup: Constants.sharedGroup
        )
            .synchronizable(true)
            .accessibility(.always)
    
        init(wrappedValue initialValue: Value, key: String) {
            self.key = key
            self.initialValue = initialValue
        }
    }
    

We declare the _SecureStorage_ property wrapper with generic constraint to
decode/encode the value while writing and reading from the Keychain service.
We also define an initializer that takes a key and an initial value. Swift
automatically calls this initializer when you define a field with a property
wrapper and a default value.

Now, we can implement the calculatable property called _wrappedValue_ to
provide access to the Keychain service.

    
    
    @propertyWrapper struct SecureStorage<Value: Codable> {
    //  ....
        var wrappedValue: Value {
            get {
                guard
                    let data = try? keychain.getData(key),
                    let value = try? decoder.decode(Value.self, from: data)
                else {
                    return initialValue
                }
    
                return value
            }
    
            set {
                guard let data = try? encoder.encode(newValue) else {
                    return
                }
    
                try? keychain.set(data, key: key)
            }
        }
    }
    

Here we hide all the implementation details of using Keychain service inside
the property wrapper type. We also use the third-party [ KeychainAccess
](https://github.com/kishikawakatsumi/KeychainAccess) package to utilize its
nice API.

Another great thing about property wrappers is that you can use them to hide
third-party code. You can easily update the SecureStorage type whenever you
want to change the implementation or migrate to another Swift Package for
Keychain. And this is going to be the only place for changes because the whole
codebase uses the _SecureStorage_ property wrapper and doesn’t know about
implementation details.

####  SwiftUI support

We used to obtain bindings from property wrappers that SwiftUI provides us by
using the **$** sign. We can achieve the same behavior in our custom property
wrappers by implementing the **projectedValue** property on the property
wrapper type.

    
    
    @propertyWrapper struct SecureStorage<Value: Codable> {
    //  ....
        var projectedValue: Binding<Value> {
            .init(
                get: { wrappedValue },
                set: { wrappedValue = $0 }
            )
        }
    }
    

> To learn more about bindings in SwiftUI, take a look at my dedicated [
> “Binding in SwiftUI” ](/2020/04/08/binding-in-swiftui/) post.

Here we create a calculated property that returns the binding to the value
controlled by the property wrapper type. Now we can easily provide that
binding to any SwiftUI view. Keep in mind that you can make _projectedValue_
of any type you need, not only _Binding_ .

Another thing that we expect from SwiftUI is that it updates the view as soon
as data hidden by a property wrapper changes. To achieve that, we should do
two things:

  1. Conform our property wrapper type to the _DynamicProperty_ protocol that SwiftUI gives us. _DynamicProperty_ protocol has only one requirement with a default implementation. 
  2. Use some of SwiftUI provided property wrappers like _@State, @StateObject, etc._ , inside our custom property wrapper type to react to data changes. 

    
    
    private final class KeychainStorage<Value: Codable>: ObservableObject {
        var value: Value {
            set {
                objectWillChange.send()
                save(newValue)
            }
            get { fetch() }
        }
    
        let objectWillChange = PassthroughSubject<Void, Never>()
    
        private let key: String
        private let defaultValue: Value
        private let decoder = JSONDecoder()
        private let encoder = JSONEncoder()
    
        private let keychain = Keychain(
            service: Settings.appGroup,
            accessGroup: Settings.appGroup
        )
            .synchronizable(true)
            .accessibility(.always)
    
        init(defaultValue: Value, for key: String) {
            self.defaultValue = defaultValue
            self.key = key
        }
    
        private func save(_ newValue: Value) {
            guard let data = try? encoder.encode(newValue) else {
                return
            }
    
            try? keychain.set(data, key: key)
        }
    
        private func fetch() -> Value {
            guard
                let data = try? keychain.getData(key),
                let freshValue = try? decoder.decode(Value.self, from: data)
            else {
                return defaultValue 
            }
    
            return freshValue
        }
    }
    

In the current implementation, I’ve created a private class that holds all the
logic of data read/write and conforms to _ObservableObject_ protocol to use
with the _StateObject_ property wrapper. Finally, SwiftUI will update the
corresponded views as soon as the data under the _SecureStorage_ property
wrapper changes.

    
    
    @propertyWrapper struct SecureStorage<Value: Codable>: DynamicProperty {
        @ObservedObject private var storage: KeychainStorage<Value>
    
        var wrappedValue: Value {
            get { storage.value }
    
            nonmutating set {
                storage.value = newValue
            }
        }
    
        init(wrappedValue: Value, _ key: String) {
            self.storage = KeychainStorage(defaultValue: wrappedValue, for: key)
        }
    
        var projectedValue: Binding<Value> {
            .init(
                get: { wrappedValue },
                set: { wrappedValue = $0 }
            )
        }
    }
    
    struct HeartPointsSettings: View {
        @SecureStorage(Settings.heartPoinstWeeklyGoal)
        var goal: Int = 150
    
        var body: some View {
            Section(header: Text("heartMinutesGoal")) {
                Stepper(value: $goal, in: 150...900, step: 10) {
                    Text("\(goal) heartMinutesGoalValue")
                }
            }
        }
    }
    

####  Conclusion

Property wrapper is a great way to extract reusable logic into a separate type
and use it across the codebase. It also has an advantage while hiding the
third-party dependencies by providing a nice API to the client-side code. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering MapKit in SwiftUI. Interactions.

##  Mastering MapKit in SwiftUI. Interactions.

19 Dec 2023

MapKit provides us with a very rich API as part of the next iteration of the
SwiftUI framework. This week, we will continue the topic by learning how to
handle interactions using the new MapKit API in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In the previous post, we discussed the map view’s camera position. Let me
update your memory with the quick code example.

    
    
    struct ContentView: View {
        @State private var position: MapCameraPosition = .camera(
            .init(centerCoordinate: .newYork, distance: 10_000_000)
        )
        
        var body: some View {
            Map(position: $position) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
                Marker("Seattle", monogram: Text("SE"), coordinate: .seattle)
                Marker("San Francisco", monogram: Text("SF"), coordinate: .sanFrancisco)
            }
            .onChange(of: position) {
                print(position.camera?.centerCoordinate)
                print(position.positionedByUser)
            }
        }
    }
    

As you can see in the example above, we use the _onChange_ view modifier to
track changes in the two-way binding of the camera position. Unfortunately, we
can’t get the direct camera position from the binding in the case of user
drag. For this particular case, MapKit API introduces the _onMapCameraChange_
view modifier.

    
    
    struct ContentView: View {
        @State private var position: MapCameraPosition = .camera(
            .init(centerCoordinate: .newYork, distance: 10_000_000)
        )
        
        var body: some View {
            Map(position: $position) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
                Marker("Seattle", monogram: Text("SE"), coordinate: .seattle)
                Marker("San Francisco", monogram: Text("SF"), coordinate: .sanFrancisco)
            }
            .onMapCameraChange(frequency: .continuous) { context in
                print(context.camera)
                print(context.region)
                print(context.rect)
            }
        }
    }
    

In the example above, we use the _onMapCameraChange_ view modifier to track
camera changes as soon as the camera position changes. MapKit API allows us to
set the frequency of the _onMapCameraChange_ listener by passing an instance
of the _MapCameraUpdateFrequency_ type.

The _MapCameraUpdateFrequency_ enum provides us with two options: _continuous_
and _onEnd_ . The first defines nearly real-time changes in the camera
position. The second fires whenever the camera position drags finish.

    
    
    struct ContentView: View {
        @State private var position: MapCameraPosition = .camera(
            .init(centerCoordinate: .newYork, distance: 10_000_000)
        )
        
        var body: some View {
            Map(position: $position) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
                Marker("Seattle", monogram: Text("SE"), coordinate: .seattle)
                Marker("San Francisco", monogram: Text("SF"), coordinate: .sanFrancisco)
            }
            .onMapCameraChange(frequency: .onEnd) { context in
                print(context.camera)
                print(context.region)
                print(context.rect)
            }
        }
    }
    

The second parameter of the _onMapCameraChange_ view modifier is the action
closure, which can handle camera position updates. The action closure provides
us with an instance of the _MapCameraUpdateContext_ type defining the current
map camera, rectangle, and region.

The new MapKit API also introduces the _mapCameraKeyframeAnimator_ view
modifier, allowing us to animate the map camera using a keyframe animator.

    
    
    struct ContentView: View {
        @State private var trigger = false
        @State private var position: MapCameraPosition = .camera(
            .init(centerCoordinate: .newYork, distance: 10_000_000)
        )
        
        var body: some View {
            Map(position: $position) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
                Marker("Seattle", monogram: Text("SE"), coordinate: .seattle)
                Marker("San Francisco", monogram: Text("SF"), coordinate: .sanFrancisco)
            }
            .mapCameraKeyframeAnimator(trigger: trigger) { camera in
                KeyframeTrack(\MapCamera.centerCoordinate) {
                    LinearKeyframe(.newYork, duration: 2)
                    LinearKeyframe(.seattle, duration: 2)
                    LinearKeyframe(.sanFrancisco, duration: 2)
                }
                
                KeyframeTrack(\MapCamera.distance) {
                    LinearKeyframe(camera.distance, duration: 2)
                    LinearKeyframe(camera.distance * 2, duration: 2)
                    LinearKeyframe(camera.distance, duration: 2)
                }
            }
            .task {
                trigger.toggle()
            }
        }
    }
    

As you can see in the example above, we use the _mapCameraKeyframeAnimator_
view modifier to define a trigger value. Trigger value allows us to animate
the map camera whenever the trigger value changes.

The second parameter of the _mapCameraKeyframeAnimator_ view modifier is the
_KeyframesBuilder_ closure, which allows us to define a set of keyframe
tracks. Inside these tracks, we describe the transition states to iterate our
animation.

As you can see, we can animate all the properties of the _MapCamera_ type. In
our example, we animate the map camera’s center location and distance. The
_KeyframesBuilder_ closure also provides us with the initial value of the map
camera, allowing us to read the value of the map camera before animation.

Last, the topic to cover is the map selection feature. The _Map_ view provides
an initializer with a _selection_ parameter, allowing us to offer a two-way
binding for map content selection.

    
    
    struct ContentView: View {
        @State private var selection: Int?
        @State private var position: MapCameraPosition = .camera(
            .init(centerCoordinate: .newYork, distance: 10_000_000)
        )
        
        var body: some View {
            Map(position: $position, selection: $selection) {
                Marker("New York", monogram: Text("NY"), coordinate: .newYork)
                    .tag(1)
                Marker("Seattle", monogram: Text("SE"), coordinate: .seattle)
                    .tag(2)
                Marker("San Francisco", monogram: Text("SF"), coordinate: .sanFrancisco)
                    .tag(3)
            }
            .onChange(of: selection) {
                print("selection changed:", selection)
            }
        }
    }
    

In the example above, we define a state property to store the currently
selected value of the map. We also annotate our markers using the _tag_ view
modifier. Remember that the type of the _selection_ property must be the same
as the _tag_ you provide to the map content.

Today, we learned how to handle interactions on the map using the set of new
view modifiers which is the part of the new rich MapKit API in SwiftUI. I hope
you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!

  1. [ Mastering MapKit in SwiftUI. Basics. ](/2023/11/28/mastering-mapkit-in-swiftui-basics/)
  2. [ Mastering MapKit in SwiftUI. Customizations. ](/2023/12/05/mastering-mapkit-in-swiftui-customizations/)
  3. [ Mastering MapKit in SwiftUI. Camera. ](/2023/12/12/mastering-mapkit-in-swiftui-camera/)
  4. Mastering MapKit in SwiftUI. Interactions. 



# Modeling errors in Swift

##  Modeling errors in Swift

11 May 2022

The new Swift Concurrency feature doesn’t only bring new opportunities for
writing safer and more maintainable async code but also changes the way we
handle errors. I didn’t use _throw-catch_ keywords too much in my legacy code
because usually, I had a completion callback with the _Result_ type handled by
the _switch_ operator. This week we will talk about modeling error types and
how we will address them in Swift with _throw-catch_ keywords.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Let’s look at a small but typical example of error handling in Swift. Here is
the in-memory cache implementation that we can use in our apps to store some
data by key. There is an option to limit the capacity of the in-memory cache
and the list of errors that a cache instance can throw.

We use an enum to define the list of exceptional situations. An enum type has
an excellent fit for mutually exclusive cases. All you need to do to throw an
error in Swift is to call **throw** with an instance of any type conforming to
the _Error_ protocol.

    
    
    actor InMemoryCache<Key: Hashable & Codable, Value: Codable> {
        enum ErrorKind: Error {
            case noValue(Key)
            case outOfMemory(availableBytes: Int)
        }
    
        private var memoryLimit: Int
        init(memoryLimit: Int) {
            self.memoryLimit = memoryLimit
        }
    
        func get(for key: Key) throws -> Value {
            guard contans(key: key) else {
                throw ErrorKind.noValue(key)
            }
    
            // fetch and return value here
        }
    
        func set(value: Value, for key: Key) throws -> Void {
            let size = calculateSize(for: value)
            let availableSpace = calculateAvailableSpace()
    
            guard size <= availableSpace else {
                throw ErrorKind.outOfMemory(availableBytes: availableSpace)
            }
    
            memoryLimit -= size
            // store value here
        }
    
        func deleteValue(for key: Key) throws -> Void {
            guard contans(key: key) else {
                throw ErrorKind.noValue(key)
            }
    
            let value = try get(for: key)
            let size = calculateSize(for: value)
            memoryLimit += size
            // delete value here
        }
    
        // more code here
    }
    

At first glance, the API we have modeled here looks nice, but we will see all
the issues as soon as we start using it.

    
    
    final class APIClient {
        typealias Cache = InMemoryCache<URL, User>
        
        private static let logger = Logger(
            subsystem: Bundle.main.bundleIdentifier!,
            category: String(describing: APIClient.self)
        )
        
        private let cache = Cache(memoryLimit: 1_000)
    
        func fetchUser(from url: URL) async throws -> User {
            do {
                let user = try await cache.get(for: url)
                return user
            } catch Cache.ErrorKind.noValue {
                do {
                    let user = try await fetchRemoteUser(from: url)
                    try await cache.set(value: user, for: url)
                } catch Cache.ErrorKind.outOfMemory {
                    Self.logger.warning("Cache is full")
                } catch {
                    // Catch the errors occuring while
                    // fetching user from the remote server
                }
            }
        }
    
        private func fetchRemoteUser(from url: URL) async throws -> User {
            // ...
        }
    }
    

As you can see in the example above, we implement the _APIClient_ class that
uses our _InMemoryCache_ class to store downloaded users in memory. The code
here really smells, it has a bunch of nested do-catch blocks, and the code
path is confusing. Let’s refactor our _InMemoryCache_ class to make it
friendlier for client code.

> To learn more about logging in Swift, take a look at my [ “Logging in Swift”
> ](/2022/04/06/logging-in-swift/) post.

We will refactor our error modeling code using three principles described in
“A philosophy of software design” book written by John Ousterhout. I enjoyed
reading it and can recommend it to you without any doubt.

####  Define errors out of existence

Sometimes we define too many errors. We define an error as a situation that is
not an error at all. For example, in our case, we have the _noValue_ case.
Instead of throwing the error whenever a value is not available, we can use
optionals and silently return **nil** without disrupting the execution with an
error.

    
    
    func get(for key: Key) -> Value? {
        guard contans(key: key) else {
            return nil
        }
    
        // fetch value here
    }
    

####  Mask exception

We should understand that we do not need to propagate every error to the high-
level client code. Sometimes we can easily catch and solve it on the lower
level, and the client code will not suffer from handling all the possible
error cases.

    
    
    import CloudKit
    
    final class CloudService {
        private static let logger = Logger(
            subsystem: Bundle.main.bundleIdentifier!,
            category: String(describing: CloudService.self)
        )
    
        private let container = CKContainer.default()
        private var pending: Set<CKRecord> = []
    
        func save(_ user: CKRecord) async throws {
            pending.insert(user)
    
            while let user = pending.popFirst() {
                do {
                    try await container.privateCloudDatabase.save(user)
                } catch CKError.networkUnavailable {
                    pending.insert(user)
                    break
                }
            }
        }
    }
    

####  Error aggregation

Not every error has its unique handler. There is a set of errors in our apps
that only can be logged or presented using an alert. There is no need to
create an entire case for every error. Sometimes we can generalize errors by
using a single case with different messages.

    
    
    actor InMemoryCache<Key: Hashable & Codable, Value: Codable> {
        enum ErrorKind: Error {
            case general(String)
            case outOfMemory
        }
    
        private var storage: [Key: Value] = [:]
        private var memoryLimit: Int
        init(memoryLimit: Int) {
            self.memoryLimit = memoryLimit
        }
    
        func swapToDisk() async throws -> Void {
            let encoder = JSONEncoder()
            do {
                try encoder.encode(storage)
            } catch {
                throw ErrorKind.general(error.localizedDescription)
            }
            // ...
        }
    
        func loadFromDisk() async throws -> Void {
            let data: Data = // ...
            let decoder = JSONDecoder()
            do {
                storage = try decoder.decode([Key: Value].self, from: data)
            } catch {
                throw ErrorKind.general(error.localizedDescription)
            }
        }
        
        // more code here
    }
    

####  Conclusion

Today we learned how to model errors in Swift using three different ways.
Error handling is a complex topic, and we should treat it carefully while
designing our APIs. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!



# Mastering StoreKit 2. ProductView and StoreView in SwiftUI.

##  Mastering StoreKit 2. ProductView and StoreView in SwiftUI.

08 Aug 2023

We started a series of posts about StoreKit 2 last week. We learned the basics
of StoreKit 2 and how easily we can monetize our apps. This week, we will
continue the topic by learning about StoreKit views in SwiftUI. The StoreKit 2
introduces SwiftUI views, allowing us to quickly build paywalls or digital
product shop screens.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

StoreKit 2 provides the _ProductView_ type allowing us to display and handle
in-app purchases for a single product easily. All you need to do is to place
an instance of the _ProductView_ with the particular product id in the view
hierarchy.

    
    
    struct ContentView: View {
        var body: some View {
            ProductView(id: "55667744")
        }
    }
    

![storekit-product](/public/storekit-product.png)

As you can see in the example above, we can place an instance of the
_ProductView_ in a single line of code, but this line hides the complexity of
loading and purchasing products from the App Store. StoreKit provides us with
a set of styles to display a product in different appearances. We can use the
_productViewStyle_ view modifier to attach a particular style. StoreKit uses
the _automatic_ style by default, but we can use _large_ , _regular_ , or
_compact_ styles.

    
    
    struct ContentView: View {
        var body: some View {
            ProductView(id: "55667744")
                .productViewStyle(.compact)
        }
    }
    

You can also enable the presentation of the promoted image if uploaded to the
App Store servers. The _ProductView_ ’s initializer has another parameter
called _prefersPromotionalIcon_ . You can use it to display the promoted icon.

    
    
    struct ContentView: View {
        var body: some View {
            ProductView(id: "55667744", prefersPromotionalIcon: true)
        }
    }
    

You might need to draw a custom SwiftUI view instead of promoted image for a
product, and it is possible by using another overload of the _ProductView_
initializer.

    
    
    ProductView(id: "55667744") { _ in
        Image(systemName: "crown")
            .resizable()
            .scaledToFit()
        } placeholderIcon: {
            ProgressView()
        }
        .productViewStyle(.large)
    

As you can see in the example above, you can handle different loading states
of promotional image and replace it with your own SwiftUI view if needed.

Another option is to build a completely custom product presentation by
introducing a custom type of style. In this case, we must create a type
conforming to the _ProductViewStyle_ protocol.

    
    
    struct CustomProductStyle: ProductViewStyle {
        func makeBody(configuration: Configuration) -> some View {
            switch configuration.state {
            case .loading:
                ProgressView()
            case .success(let product):
                Button {
                    configuration.purchase()
                } label: {
                    VStack {
                        Text(verbatim: product.displayName)
                            .font(.headline)
                        Text(verbatim: product.displayPrice)
                    }
                }
                .buttonStyle(.borderedProminent)
            default:
                Text("Something goes wrong...")
            }
        }
    }
    
    struct ContentView: View {
        var body: some View {
            ProductView(id: "55667744")
                .productViewStyle(CustomProductStyle())
        }
    }
    

As you can see in the example above, we define the _CustomProductStyle_ type
conforming to the _ProductViewStyle_ protocol. The _ProductViewStyle_ protocol
has the only requirement, which is the _makeBody_ function. The makeBody
function has the parameter of type _ProductViewStyleConfiguration_ , providing
us with all the needed information about the product, loading state, and
purchase functionality.

We can use different product styles to build the layout we need. Let’s make a
paywall screen displaying subscription options among the lifetime in-app
purchases.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ProductView(id: "55667744") { _ in
                    Image(systemName: "crown")
                        .resizable()
                        .scaledToFit()
                } placeholderIcon: {
                    ProgressView()
                }
                .productViewStyle(.large)
                
                VStack(spacing: 16) {
                    ForEach(["123456789", "987654321"], id: \.self) { id in
                        ProductView(id: id)
                            .productViewStyle(.compact)
                    }
                }
                .padding()
            }
        }
    }
    

![paywall-screen](/public/paywall.png)

As you can see, we use different style options to display the list of
available in-app purchases just in a few lines of code. And the UI we build
supports purchasing and observes refunds automatically. But StoreKit views in
SwiftUI don’t stop here. It provides us with the _StoreView_ view displaying
the collection of products in different layouts depending on the available
space.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ProductView(id: "55667744") { _ in
                    Image(systemName: "crown")
                        .resizable()
                        .scaledToFit()
                } placeholderIcon: {
                    ProgressView()
                }
                .productViewStyle(.large)
                
                StoreView(
                    ids: [
                        "123456789",
                        "987654321"
                    ]
                )
                .productViewStyle(.compact)
            }
        }
    }
    

The _StoreView_ displays the layout of a collection of products. For example,
on tvOS _StoreView_ uses a grid to show the products. You can still customize
the look and feel of the products displayed in the _StoreView_ by applying the
_productViewStyle_ view modifier to the _StoreView_ .

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                ProductView(id: "55667744") { _ in
                    Image(systemName: "crown")
                        .resizable()
                        .scaledToFit()
                } placeholderIcon: {
                    ProgressView()
                }
                .productViewStyle(.large)
                
                StoreView(
                    ids: [
                        "123456789",
                        "987654321"
                    ]
                )
                .productViewStyle(.compact)
                .storeButton(.visible, for: .restorePurchases)
            }
        }
    }
    

The _StoreView_ provides a set of buttons like restore transactions or paywall
cancellation buttons out of the box. You can manipulate the visibility of a
particular button by using the _storeButton_ view modifier.

> To learn more about the basics of the StoreKit 2, take a look at my [
> “Mastering StoreKit 2” ](/2023/08/01/mastering-storekit2/) post.

Today we learned about SwiftUI views that StoreKit 2 provides us to build
paywalls in our apps. I hope you enjoy the post. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading, and see you next week!

  1. [ Mastering StoreKit 2 ](/2023/08/01/mastering-storekit2/)
  2. Mastering StoreKit 2. ProductView and StoreView in SwiftUI. 
  3. [ Mastering StoreKit 2. SubscriptionStoreView in SwiftUI ](/2023/08/23/mastering-storekit2-subscriptionstoreview-in-swiftui/)
  4. [ Mastering StoreKit 2. SwiftUI view modifiers. ](/2023/08/29/mastering-storekit2-swiftui-view-modifiers/)
  5. [ StoreKit testing in Swift ](/2024/01/09/storekit-testing-in-swift/)



# What is new in SwiftUI after WWDC21

##  What is new in SwiftUI after WWDC21

08 Jun 2021

WWDC21 is finally here, and there are many new things in the updated version
of SwiftUI. I’m happy to share with you that many items on my wishlist have
finally arrived. In this post, I will try to give you a summary of the
significant SwiftUI additions of this year.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  List

The _List_ view is the most common view in our apps. The _List_ view managed
_UITableView_ under the hood but didn’t expose all the great features of
_UITableView_ till today. Now we have view modifiers that expose the styling
options for separators and tint colors in sections and cells. Let’s see how we
can use them.

    
    
    struct ContentView: View {
        @State private var messages: [String] = [
            "Hello", "World"
        ]
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(messages, id: \.self) { message in
                        Text(message)
                            .listRowSeparatorTint(Color.red)
                            .listRowSeparator(.visible, edges: .all)
                    }
                }
                .listSectionSeparator(.visible, edges: .all)
                .listSectionSeparatorTint(Color.purple)
                .navigationTitle("Messages")
            }
        }
    }
    

SwiftUI also provides the new _swipeActions_ view modifier that we can use to
attach the swipeable action to views inside a list.

    
    
    struct ContentView: View {
        @State private var messages: [String] = [
            "Hello", "World"
        ]
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(messages, id: \.self) { message in
                        Text(message)
                            .swipeActions(edge: .trailing, allowsFullSwipe: false) {
                                Button("Remove", role: .destructive) {
                                    messages.removeAll { $0 == message }
                                }
                            }
                            .swipeActions(edge: .leading, allowsFullSwipe: true) {
                                Button("Copy") {
                                    messages.append(message)
                                }
                            }
                    }
                }.navigationTitle("Messages")
            }
        }
    }
    

As you can see in the example above, we also have new _ButtonRole_ enum that
allows specifying a role for the button, which can be either _destructive_ or
_cancel_ .

####  Pull-to-Refresh

I used to have the pull-to-refresh gesture in the screens where the content
can be updated or refetched. SwiftUI provides the new _refreshable_ view
modifier that we can use to attach the pull-to-refresh gesture and a callback
that SwiftUI runs as soon as the user enables the gesture.

    
    
    struct ContentView: View {
        @State private var messages: [String] = [
            "Hello", "World"
        ]
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(messages, id: \.self) { message in
                        Text(message)
                    }
                }.refreshable {
                    messages.append("!!!")
                }
                .navigationTitle("Messages")
            }
        }
    }
    

####  Search

Another thing that I really missed in SwiftUI is _SearchBar_ and
_SearchController_ ’s functionality. Fortunately, this iteration of SwiftUI is
packed with a brand new collection of view modifiers that enables powerful
search capabilities.

    
    
    struct ContentView: View {
        @State private var query: String = ""
        @State private var messages: [String] = [
            "Hello", "World"
        ]
    
        var body: some View {
            NavigationView {
                List {
                    ForEach(messages, id: \.self) { message in
                        Text(message)
                    }
                }
                .searchable("Search term", text: $query, placement: .automatic)
                .onChange(of: query) { print($0) }
                .navigationTitle("Messages")
            }
        }
    }
    

####  AsyncImage

The thing I didn’t expect was the new _AsyncImage_ view. _AsyncImage_ view
allows you to download and present remote images using _URLSession_ . It
provides a very lovely API which very easy to use. Let’s take a look at it.

    
    
    struct Post: Hashable {
        let image: URL
        let title: String
        let content: String
    }
    
    struct PostView: View {
        let post: Post
    
        var body: some View {
            HStack {
                AsyncImage(url: post.image)
                VStack {
                    Text(post.title)
                    Text(post.content)
                        .foregroundColor(.secondary)
                }
            }
        }
    }
    

####  Text and AttributedString

Swift Foundation has a new _AttributedString_ type and SwiftUI supports it out
of the box. You can now pass the instances of _AttributedString_ to _Text_
view to display it. An interesting detail here is the ability to display
markdown content using the new _AttributedString_ .

    
    
    struct PostView: View {
        let post: Post
    
        var markdown: AttributedString {
            try! AttributedString(markdown: post.content)
        }
    
        var body: some View {
            HStack {
                AsyncImage(url: post.image)
                VStack {
                    Text(post.title)
                    Text(markdown)
                }
            }
        }
    }
    

As the bonus we gain markdown support everywhere with _Text_ view.

    
    
    struct ContentView: View {
        var body: some View {
            Text("**Happy WWDC21**")
        }
    }
    

####  Focus management

Finally, SwiftUI provides us a way to manage the focus in our views. There are
brand new @ _FocusState_ property wrappers and a _focused_ view modifier that
we can use to toggle first responders.

    
    
    struct LoginForm: View {
        enum Field: Hashable {
            case usernameField
            case passwordField
        }
    
        @State private var username = ""
        @State private var password = ""
        @FocusState private var focusedField: Field?
    
        var body: some View {
            VStack {
                TextField("Username", text: $username)
                    .focused($focusedField, equals: .usernameField)
    
                SecureField("Password", text: $password)
                    .focused($focusedField, equals: .passwordField)
    
                Button("Sign In") {
                    if username.isEmpty {
                        focusedField = .usernameField
                    } else if password.isEmpty {
                        focusedField = .passwordField
                    } else {
                        handleLogin(username, password)
                    }
                }
            }
        }
    }
    

####  Canvas

SwiftUI _Canvas_ is a new way to gain more control over lower-level drawing
primitives. It is a modern, GPU-accelerated equivalent of _drawRect_ . We can
use _Canvas_ to draw shapes using _Path_ . We can also draw images, texts, and
other SwiftUI views.

    
    
    struct ContentView: View {
        var body: some View {
            Canvas { context, size in
                context.fill(
                    Circle().path(in: .init(origin: .zero, size: size)),
                    with: .color(.green)
                )
            }
        }
    }
    

####  Materials

iOS provides materials or blur effects that create a translucent effect you
can use to evoke a sense of depth. The effect of material lets views and
controls hint at background content without distracting from foreground
content. We didn’t have access to materials in previous versions of SwiftUI.
Fortunately, the new version of SwiftUI provides us a whole range of physical
materials from ultra-thin to ultra-thick and semantic bars material.

    
    
    ZStack {
        Color.teal
        Label("Flag", systemImage: "flag.fill")
            .padding()
            .background(.regularMaterial)
    }
    

####  TimelineView

_TimelineView_ is another brand new SwiftUI view. Usually, SwiftUI updates
views only during environment or state changes. In case of _TimelineView_ ,
SwiftUI updates it according to a schedule that you provide. It might be very
useful while building clock or workout apps.

    
    
    TimelineView(PeriodicTimelineSchedule(from: startDate, by: 1)) { context in
        AnalogTimerView(date: context.date)
    }
    

####  Conclusion

There are many other additions worth mentioning, like a brand new
Accessibility Rotors API, the new _SectionedFetchRequest_ property wrapper
that allows you to make sectioned requests to Core Data, and much more.

I hope to cover all these new features of the SwiftUI framework in the
upcoming weeks. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Zone sharing in CloudKit

##  Zone sharing in CloudKit

29 Mar 2022

Last week we talked about the basics of CloudKit. We learned how to save and
fetch data from the storage in the cloud and how to sync the data between
devices. This week I want to cover the only reason why I have chosen CloudKit
instead of Firebase, and it is data sharing between users.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

CloudKit provides you ready to use data sharing API that allows you to
implement collaborative features of your app without much effort. There are
two ways to share data via CloudKit: record sharing and zone sharing. In this
post, we will talk about zone sharing.

> If you are not familiar with CloudKit, please take a look at my [ “Getting
> started with CloudKit” ](/2022/03/22/getting-started-with-cloudkit/) post.

A zone is a defined bucket inside the private database of the current user.
You can create and assign a zone to any record in the database. You share all
the records in the zone by sharing the zone itself. For example, in the todo
app, you can create a zone with the name of the todo list and share it with
your family.

First of all, we need to create and save a zone in the private database of the
current user. Then we have to assign it to a particular record and save or
update it in the private database.

    
    
    private enum FastingRecordKeys {
        static let type = "Fasting"
        static let startDate = "startDate"
        static let endDate = "endDate"
        static let goal = "goal"
    }
    
    private enum SharedZone {
        static let name = "SharedZone"
        static let ID = CKRecordZone.ID(
            zoneName: name,
            ownerName: CKCurrentUserDefaultName
        )
    }
    
    extension Fasting {
        var asRecord: CKRecord {
            let record = CKRecord(
                recordType: FastingRecordKeys.type,
                recordID: .init(zoneID: SharedZone.ID)
            )
            record[FastingRecordKeys.goal] = goal.rawValue
            record[FastingRecordKeys.startDate] = startDate
            record[FastingRecordKeys.endDate] = endDate
            return record
        }
        
        init?(from record: CKRecord) {
            guard
                let startDate = record[FastingRecordKeys.startDate] as? Date,
                let endDate = record[FastingRecordKeys.endDate] as? Date,
                let goalRawValue = record[FastingRecordKeys.goal] as? String,
                let goal = Fasting.Goal(rawValue: goalRawValue)
            else { return nil }
            
            self = .init(
                startDate: startDate,
                endDate: endDate,
                goal: goal,
                name: record.recordID.recordName
            )
        }
    }
    
    final class CloudKitService {
        static let container = CKContainer(
            identifier: "iCloud.com.aaplab.fastbot"
        )
        
        func save(_ fasting: Fasting) async throws {
            _ = try await Self.container.privateCloudDatabase.modifyRecordZones(
                saving: [CKRecordZone(zoneName: SharedZone.name)],
                deleting: []
            )
            _ = try await Self.container.privateCloudDatabase.modifyRecords(
                saving: [fasting.asRecord],
                deleting: []
            )
        }
    }
    

Now we have a zone saved in the private database and associated records. But
to start sharing, we should create an instance of _CKShare_ type and save it
into the private database.

    
    
    extension CloudKitService {
        func shareFastingRecords() async throws -> CKShare {
            _ = try await Self.container.privateCloudDatabase.modifyRecordZones(
                saving: [CKRecordZone(zoneName: SharedZone.name)],
                deleting: []
            )
    
            let share = CKShare(recordZoneID: SharedZone.ID)
            share.publicPermission = .readOnly
            let result = try await Self.container.privateCloudDatabase.save(share)
            return result as! CKShare
        }
    }
    

As you can see in the example above, we create a new _CKShare_ object and set
the public permission to _readOnly_ . The default value is _none_ which blocks
anyone from accessing your data without your approval.

Remember that you can have only one instance of _CKShare_ per zone in the
database. You need to check if you already have one and fetch if it is
available. The next step is to present an instance of
_UICloudSharingController_ with the created _CKShare_ object.

    
    
    struct CloudKitShareView: UIViewControllerRepresentable {
        let share: CKShare
    
        func makeUIViewController(context: Context) -> UICloudSharingController {
            let sharingController = UICloudSharingController(
                share: share,
                container: CloudKitService.container
            )
            
            sharingController.availablePermissions = [.allowReadOnly, .allowPrivate]
            sharingController.modalPresentationStyle = .formSheet
            return sharingController
        }
    
        func updateUIViewController(
            _ uiViewController: UIViewControllerType,
            context: Context
        ) { }
    }
    

_UICloudSharingController_ provides you with all the needed functionality to
add and manage participants of the share. You can also configure available
options of the _UICloudSharingController_ instance by setting the value of the
_availablePermissions_ property to _allowReadOnly, allowPrivate,
allowReadWrite, allowPublic_ . Now let’s talk about how we should implement
share accepting functionality.

Before writing any code, we should add the _CKSharingSupported_ boolean key
with the value _YES_ to the Info.plist. Whenever a user receives and opens a
link shared via _UICloudSharingController_ , the
_userDidAcceptCloudKitShareWith_ delegate method will be called by the system.
Here we can call the _accept_ method to approve the sharing.

    
    
    extension CloudKitService {
        func accept(_ metadata: CKShare.Metadata) async throws {
            try await Self.container.accept(metadata)
        }
    }
    
    private final class SceneDelegate: NSObject, UIWindowSceneDelegate {
        private let logger = Logger(
            subsystem: "com.aaplab.fastbot",
            category: "SceneDelegate"
        )
        
        private let cloudKitService = CloudKitService()
    
        func windowScene(
            _ windowScene: UIWindowScene,
            userDidAcceptCloudKitShareWith cloudKitShareMetadata: CKShare.Metadata
        ) {
            Task {
                do {
                    try await cloudKitService.accept(cloudKitShareMetadata)
                } catch {
                    logger.error("\(error.localizedDescription, privacy: .public)")
                }
            }
        }
    }
    

Finally, we can use the shared database to fetch the content of shared zones.

    
    
    extension CloudKitService {
        func fetchSharedFastingRecords(
            in interval: DateInterval
        ) async throws -> [Fasting] {
            let sharedZones = try await Self.container.sharedCloudDatabase.allRecordZones()
            
            return try await withThrowingTaskGroup(
                of: [Fasting].self,
                returning: [Fasting].self
            ) { group in
                for zone in sharedZones {
                    group.addTask {
                        let predicate = NSPredicate(
                            format: "\(FastingRecordKeys.endDate) > %@ AND \(FastingRecordKeys.endDate) <= %@",
                            interval.start as NSDate,
                            interval.end as NSDate
                        )
    
                        return try await self.fetchFastingRecords(
                            with: predicate,
                            in: zone.zoneID,
                            from: Self.container.sharedCloudDatabase
                        )
                    }
                }
                
                var results: [Fasting] = []
                for try await history in group {
                    results.append(contentsOf: history)
                }
                
                return results
            }
        }
                        
        private func fetchFastingRecords(
            with predicate: NSPredicate,
            in zone: CKRecordZone.ID? = nil,
            from database: CKDatabase
        ) async throws -> [Fasting] {
            let query = CKQuery(recordType: FastingRecordKeys.type, predicate: predicate)
            query.sortDescriptors = [.init(key: FastingRecordKeys.endDate, ascending: true)]
    
            let response = try await database.records(
                matching: query,
                inZoneWith: zone,
                desiredKeys: nil,
                resultsLimit: CKQueryOperation.maximumResults
            )
    
            return response.matchResults
                .compactMap { try? $0.1.get() }
                .compactMap { $0.compactMap(Fasting.init) }
        }
    }
    

Remember that you have to fetch all the zones from the shared database. Even
when they have the same name, they have different owners. We can enumerate all
the shared zones and fetch shared records in every zone.

I think CloudKit data sharing API is one of the best things about this
technology. And today we learned how to use it. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Maintaining State in Your ViewControllers

##  Maintaining State in Your ViewControllers

23 Jan 2019

Last week we talked about [ extracting reusable code samples from view
controllers into protocols and protocol extensions ](/2019/01/17/using-
protocols-as-composable-extensions/) . Today I want to show you another nice
use case of protocols while maintaining the state of view controllers.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Assume that we have a screen for presenting the list of user watched shows —
our app downloads it from the web service like Trakt. We can describe the
state of view controller within three variables:

    
    
    class HistoryViewController: UIViewController {
        var loading: Bool = false {
            didSet {
                renderLoading()
            }
        }
    
        var shows: [Show]? {
            didSet {
                renderShows()
            }
        }
    
        var error: Error? {
            didSet {
                renderError()
            }
        }
    }
    

  1. loading indicates whether the view controller loading the data or already finished the job. 
  2. shows variable stores the actual history of watched TV shows. 
  3. error property reports whether the request ended with an error. 

Here is fetch method, which used to request data from Trakt web service:

    
    
        private func fetch() {
            loading = true
            historyService.fetch { [weak self] result in
                self?.loading = false
                switch result {
                case .success(let shows): self?.shows = shows
                case .failure(let error): self?.error = error
                }
            }
        }
    

Before starting our request to Trakt web service, we set loading to true,
which calls _renderLoading_ method. After that, we initiate the API request to
fetch the history of watched TV shows. In the completion handler, we set shows
or error variables accordingly to the result of the request. At first glance,
it should work pretty well, but here we have a couple of downsides.

  1. We have to reset loading, error, shows variables on every request to avoid an invalid state. For example, in case of the first request fails and user retries it with the successful request, we still have value in the error property. 
  2. We want an exclusive state, at any point, we need only one state of the screen: error or loading or shows. Right now we introduce more state variations than we have, and this can leads to ambiguous situations. 

####  Enums

We want the exclusive state, and this is about enums. Enums give the
opportunity to have only one case at any point in time. Let’s refactor our
code with enum.

    
    
    enum State {
        case loading
        case error(Error)
        case loaded([Show])
    }
    
    class HistoryViewController: UIViewController {
        private var state: State {
            didSet {
                render()
            }
        }
    }
    
    extension HistoryViewController {
        func render() {
            switch state {
            case .loading: // render loading
            case .error(let error): // render error
            case loaded(let shows): // render shows
            }
        }
    }
    

Here we declare _State_ enum which exclusively describes our state cases. As
soon as state variable changes, it calls the _render_ method. Inside the
_render_ method, we switch state to display it. Another positive change here
is clean access to screen state. We don’t need to check all the three
variables to understand what’s happening on the screen right now.

####  Protocols with associated types

We already made nice refactoring, but it is very bounded to current screen,
which presents the list of the shows. Let’s add a generic constraint to
_State_ enum, to make it more usable across the app screens, which also have
loading and error states, but present other data entities.

    
    
    enum State<Data> {
        case loading
        case loaded(Data)
        case error(Error)
    }
    

Let’s go beyond and extract state handling into a generic protocol with
protocol extension, which any view controller can adapt to add this logic.

    
    
    protocol StatePresentable: ActivityPresentable, ErrorPresentable {
        associatedtype Data
    
        var state: State<Data> { get set }
        func render()
        func render(_ data: Data)
    }
    
    extension StatePresentable {
        func render() {
            switch state {
            case .loading:
                setActivityStatus(.visible)
            case .error(let error):
                setActivityStatus(.hidden)
                present(error)
            case .loaded(let data):
                setActivityStatus(.hidden)
                render(data)
            }
        }
    }
    

Here we have _StatePresentable_ protocol which extends from
_ActivityPresentable_ and _ErrorPresentable_ protocols. We described these two
protocols in the previous [ post ](/2019/01/17/using-protocols-as-composable-
extensions/) . _StatePresentable_ protocol has associated type Data, which we
use as generic constraint for _State_ enum, to make it usable for any type of
data. We also added the default implementation for _render_ method which
handles state changes.

Here is the usage example of _StatePresentable_ protocol.

    
    
    class HistoryViewController: UIViewController {
        private var state: State<[Show]> {
            didSet {
                render()
            }
        }
    }
    
    extension HistoryViewController: StatePresentable {
        func render(_ data: [Show]) {
            // render your data here
        }
    }
    

All we need is to conform _StatePresentable_ protocol, add the _didSet_
observer for state property and implement _render_ method, where we add data
presenting logic for the actual screen.

####  Conclusion

Protocol with associated types can be robust by enabling the power of generic
constraints and making codebase more reusable. Feel free to follow me on [
Twitter ](https://twitter.com/mecid) and ask your questions related to this
post. Thanks for reading and see you next week!



# Mastering toolbars in SwiftUI

##  Mastering toolbars in SwiftUI

15 Jul 2020

Toolbar API is another excellent addition to SwiftUI this year. Usually, we
use toolbars to provide available actions. Did you remember the case where you
have a button outside of the navigation bar or bottom bar? This week we will
learn all about the new Toolbar API.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

In the previous version of SwiftUI, we could place buttons in the navigation
bar by using _navigationBarItems_ modifier. Let’s take a quick look at how it
works.

    
    
    import SwiftUI
    
    struct ContentView: View {
        let messages: [String]
    
        var body: some View {
            List(messages, id: \.self) { message in
                Text(message)
            }
            .navigationTitle("Messages")
            .navigationBarItems(trailing: EditButton())
        }
    }
    

The example above looks good, but there is one big issue. It works only with
the navigation bar. For instance, watchOS apps use _NavigationView_ to provide
a navigation stack, but there is no navigation bar to deliver actions. We have
to use 3D touch menus on the watchOS, but then we face another problem. SwitUI
doesn’t provide us API to use 3D touch menus.

Fortunately, Apple released the unified Toolbar API that works on all Apple
platforms. Toolbar API is another example of a declarative API that adapts to
the environment and looks different on different devices. For example, it uses
a navigation bar on iOS, but on watchOS, it inserts a button into the top of
the screen. Let’s take a look at how easily we can use it.

    
    
    import SwiftUI
    
    struct ContentView: View {
        let messages: [String]
    
        var body: some View {
            List(messages, id: \.self) { message in
                Text(message)
            }
            .navigationTitle("Messages")
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button("New") {}
                }
    
                ToolbarItem(placement: .bottomBar) {
                    Button("Filter") {}
                }
            }
        }
    }
    

As you can see in the example above, SwiftUI provides us the _toolbar_
modifier that we can use to build toolbar items. The _toolbar_ modifier
accepts the _ToolbarContentBuilder_ closure, which is very similar to
_ViewBuilder_ function builder, but instead of views, it uses _ToolbarItems_ .

####  ToolbarItem

We use _ToolbarItem_ struct to declare an action. _ToolbarItem_ has two
required parameters. The first one is placement, which is the instance of
_ToolbarItemPlacement_ struct. The second one is _ViewBuilder_ closure that
SwiftUI uses to build the view representation of your action.

SwiftUI hides all the magic of toolbars behind _ToolbarItemPlacement_ struct.
SwiftUI can put your toolbar item in different places, depending on the value
of the placement parameter. There are multiple placement opportunities. Let’s
talk about the essential options.

  1. _automatic_ \- The item is placed in the default section that varies depending on the current platform. 
  2. _primaryAction_ \- The item represents a primary action. Usually, SwiftUI places this item in the navigation bar on iOS or on top of other views on watchOS. 

There are placement options that we can use only in toolbars presented by a
modal view.

  1. _confirmationAction_ \- The item represents a confirmation action for a modal interface. You can use it in your sheets to confirm saving action. 
  2. _cancellationAction_ \- The item represents a cancellation action for a modal interface. 
  3. _destructiveAction_ \- The item represents a destructive action for a modal interface. You can use it in your modal screens that delete some data. 

There are also a bunch of platform-specific placement options.

  1. _principal_ \- The item is placed in the main item section. For example, you can use it to customize the navigation bar’s title view on iOS. 
  2. _bottomBar_ \- The item is placed in the bottom toolbar. It is available only on iOS. 
  3. _keyboard_ \- The item is placed in the keyboard section. On iOS, keyboard items are above the software keyboard when present. On macOS, keyboard items will be placed inside the Touch Bar. 
  4. _navigationBarLeading_ \- The item is placed in the leading area of the navigation bar. It is available only on iOS and macOS. 
  5. _navigationBarTrailing_ \- The item is placed in the trailing area of the navigation bar. It is available only on iOS and macOS. 

![watchOS-toolbar](/public/watchOS.png)

####  ToolbarContent

We can also create a dedicated type defining our toolbar that we can reuse
across the app. SwiftUI provides us the _ToolbarContent_ protocol that allows
us to create a struct representing a reusable toolbar. Let’s take a look at
how we can use it.

    
    
    import SwiftUI
    
    struct ItemsToolbar: ToolbarContent {
        let add: () -> Void
        let sort: () -> Void
    
        var body: some ToolbarContent {
            ToolbarItem(placement: .primaryAction) {
                Button("Add", action: add)
            }
    
            ToolbarItem(placement: .bottomBar) {
                Button("Sort", action: sort)
            }
        }
    }
    

As you can see in the example above, we create _ItemsToolbar_ struct that
conforms to _ToolbarContent_ protocol. We customize it by providing closures
for adding new items and sorting. Now we can reuse it across the app whenever
we need to present a list of actions for an items list.

    
    
    @main
    struct MyApp: App {
        var body: some Scene {
            WindowGroup {
                NavigationView {
                    Text("Hello World!")
                        .toolbar {
                            ItemsToolbar {
                                // add new item here
                            } sort: {
                                // sort items
                            }
    
                        }
                }
            }
        }
    }
    

####  ToolbarItemGroup

Sometimes we might have several toolbar items in the same placement. Creating
a _ToolbarItem_ for every single button in the toolbar can be very repetitive.
That’s why SwiftUI provides us another type called _ToolbarItemGroup_ .
_ToolbarItemGroup_ allows us to fix toolbar items in the specific placement.
Let’s take a look at a very quick example.

    
    
    import SwiftUI
    
    struct ItemsToolbar: ToolbarContent {
        let add: () -> Void
        let sort: () -> Void
        let filter: () -> Void
    
        var body: some ToolbarContent {
            ToolbarItem(placement: .primaryAction) {
                Button("Add", action: add)
            }
    
            ToolbarItemGroup(placement: .bottomBar) {
                Button("Sort", action: sort)
                Button("Filter", action: filter)
            }
        }
    }
    

####  Conclusion

Today we learned how to use the new Toolbar API to present actions in our apps
in a unified way on different platforms. I hope you enjoy the post. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Background tasks in SwiftUI

##  Background tasks in SwiftUI

06 Jul 2022

One of the exciting frameworks released along with iOS 13 was the
BackgroundTasks framework. It allows you to schedule work intelligently in the
background. Finally, we can handle background tasks using the SwiftUI app
lifecycle. This week we will learn how to schedule and handle background tasks
in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

First, you must add background mode to your Xcode project on the capabilities
page. You should choose background fetch in the list of available background
modes to enable your app to make network requests in the background. Let’s see
how we can schedule a background task.

    
    
    import BackgroundTasks
        
    func scheduleAppRefresh() {
        let request = BGAppRefreshTaskRequest(identifier: "myapprefresh")
        try? BGTaskScheduler.shared.submit(request)
    }
    

As you can see in the example above, we have the _scheduleAppRefresh_ function
using the shared instance of _BGTaskScheduler_ to schedule an app refresh
task. An app refresh task should have a unique identifier. We must also define
the list of all the identifiers in the Info.plist file within the “Permitted
background task scheduler identifiers” key. Now we can call the
_scheduleAppRefresh_ function within the SwiftUI app lifecycle.

    
    
    @main
    struct MyApp: App {
        @Environment(\.scenePhase) private var phase
        
        var body: some Scene {
            WindowGroup {
                ContentView()
            }
            .onChange(of: phase) { newPhase in
                switch newPhase {
                case .background: scheduleAppRefresh()
                default: break
                }
            }
        }
    }    
    

Here we schedule a background task as soon as the user leaves our app. We can
tune the timing of the task by using the _earliestBeginDate_ property on the
instance of the _BGAppRefreshTaskRequest_ type. We tell the system to run the
task only after the deadline by providing the earliest beginning date.

    
    
    import BackgroundTasks
        
    func scheduleAppRefresh() {
        let request = BGAppRefreshTaskRequest(identifier: "myapprefresh")
        request.earliestBeginDate = .now.addingTimeInterval(24 * 3600)
        try? BGTaskScheduler.shared.submit(request)
    }
    

####  App refresh tasks

To handle app refresh tasks in SwiftUI, we have the brand new _backgroundTask_
modifier that we can attach to any scene.

    
    
    @main
    struct MyApp: App {
        @Environment(\.scenePhase) private var phase
        
        var body: some Scene {
            WindowGroup {
                ContentView()
            }
            .onChange(of: phase) { newPhase in
                // ..
            }
            .backgroundTask(.appRefresh("myapprefresh")) {
                let request = URLRequest(url: URL(string: "your_backend")!)
                guard let data = try? await URLSession.shared.data(for: request).0 else {
                    return
                }
                
                let decoder = JSONDecoder()
                guard let products = try? decoder.decode([Product].self, from: data) else {
                    return
                }
             
                if !products.isEmpty && !Task.isCancelled {
                    await notifyUser(for: products)
                }
            }
        }
    }    
    

> To learn more about scenes in SwiftUI, take a look at my [ “Managing scenes
> in SwiftUI” ](https://swiftwithmajid.com/2020/08/26/managing-scenes-in-
> swiftui/) post.

As you can see in the example above, we the _backgroundTask_ modifier to
register an app refresh handler for a particular identifier. SwiftUI relies on
the new Swift Concurrency feature and allows us to build complex async jobs
using the async/await syntax. It also fully supports cooperative cancelation,
and you can quickly check if your task is out of background runtime using the
static _isCancelled_ property on the Task type.

####  URLSession tasks

Whenever you need a long-running task like downloading a file, you should use
an instance of _URLSession_ with background configuration. In this case, you
can handle task suspension and continue your work later.

    
    
    func handleFileDownload() async {
        let url = URL(string: "your_backend")!
        
        let config = URLSessionConfiguration.background(withIdentifier: "myurlsession")
        config.sessionSendsLaunchEvents = true
        let session = URLSession(configuration: config)
        
        let data = await withTaskCancellationHandler {
            try? await session.data(for: URLRequest(url: url))
        } onCancel: {
            let task = session.downloadTask(with: URLRequest(url: url))
            task.resume()
        }
    
        if let data {
            await notifyUser()
        }
    }
    

In the example above, we create an instance of _URLSession_ with the
background configuration. We also use the _withTaskCancellationHandler_
function allowing us to handle task cancellation. Whenever our task is
canceled, we create a download task that will be saved by the system and run
later.

    
    
    @main
    struct MyApp: App {
        @Environment(\.scenePhase) private var phase
        
        var body: some Scene {
            WindowGroup {
                ContentView()
            }
            .onChange(of: phase) { newPhase in
                switch newPhase {
                case .background: scheduleAppRefresh()
                default: break
                }
            }
            .backgroundTask(.appRefresh("myapprefresh")) {
                await handleFileDownload()
            }
            .backgroundTask(.urlSession("myurlsession")) {
                // Handle your background url session events here
            }
        }
    }
    

We can handle events from the _URLSession_ with background configuration by
using the _backgroundTask_ modifier with the particular identifier.

####  Debugging

The only way of debugging background tasks is to keep your phone connected to
Xcode debugger, but we don’t know when iOS will decide to run our jobs because
it uses some hidden logic for that. Luckily, Apple provides two private
functions, which we can use in the debugger to start and expire background
tasks. Please remember that you can use it only during development, don’t
include them in release.

For starting background tasks, pause your app and run in the debugger this
code:

    
    
    e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@"TASK_IDENTIFIER"]
    

To force early termination use

    
    
    e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@"TASK_IDENTIFIER"]
    

Don’t forget to replace TASK_IDENTIFIER with the real identifier.

####  Conclusion

Today we learned how to use the BackgroundTasks framework in SwiftUI by
leveraging the power of the new Swift Concurrency feature. I hope you enjoy
the post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and
ask your questions related to this post. Thanks for reading, and see you next
week!



# The magic of redacted modifier in SwiftUI

##  The magic of redacted modifier in SwiftUI

22 Oct 2020

Redacted modifier is the thing that will have a great impact on how iOS apps
handle loading states. During WWDC20, Apple showed us the easy way of hiding
the data from home-screen widgets using the redacted modifier. Today we will
talk about using the redacted modifier to hide sensitive data and handle
loading states.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Redacted modifier

The redacted modifier transforms the view hierarchy into a skeleton view when
added. Don’t worry if you are not familiar with the skeleton view pattern. You
will see how it works very soon. Assume that you are working on the Github
app. You have a view that represents a repo on the list.

    
    
    struct Repo: Hashable, Decodable {
        let name: String
        let description: String
        let stars: Int
    }
    
    struct RepoView: View {
        let repo: Repo
    
        var body: some View {
            HStack {
                VStack(alignment: .center) {
                    Image(systemName: "star.fill")
                        .resizable()
                        .frame(width: 44, height: 44)
                    Text(String(repo.stars))
                        .font(.title)
                }.foregroundColor(.red)
    
                VStack(alignment: .leading) {
                    Text(repo.name)
                        .font(.headline)
                    Text(repo.description)
                        .foregroundColor(.secondary)
                }
            }
        }
    }
    

Let’s create a sample data that we can use to preview our _RepoView_ .

    
    
    extension Repo {
        static let mock = Repo(
            name: "SwiftUICharts",
            description: "A simple line and bar charting library that support accessibility written using SwiftUI. ",
            stars: 579
        )
    }
    

Now we can use our _RepoView_ in preview to see how it looks with or without a
redacted modifier.

    
    
    struct ContentView: View {
        var body: some View {
            HStack {
                RepoView(repo: .mock)
                Divider()
                RepoView1(repo: .mock)
                    .redacted(reason: .placeholder)
            }
        }
    }
    

![redacted](/public/redacted1.png)

As you can see in the example above, we have a plain _RepoView_ on the left
and a redacted version on the right. The redacted modifier transforms images
and text views in the view hierarchy to hide its content using overlays. Let’s
take a look at a more advanced example.

    
    
    final class Store: ObservableObject {
        @Published private(set) var repos: [Repo]
        @Published private(set) var isLoading = false
    
        private let service: GithubService
        init(
            service: GithubService,
            initialState: [Repo] = Array(repeating: .mock, count: 5)
        ) {
            self.repos = initialState
            self.service = service
        }
    
        func fetch() {
            isLoading = true
            service
                .fetchRepos(matching: "SwiftUI")
                .replaceError(with: [])
                .receive(on: DispatchQueue.main)
                .handleEvents(receiveCompletion: { [weak self] _ in self?.isLoading = false})
                .assign(to: &$repos)
        }
    }
    

Here we have a store object that handles the data loading. We will use the
redacted modifier to hide the mock data that we have as our store object’s
initial state.

> To learn more about store objects, take a look at my [ “Modeling app state
> using Store objects in SwiftUI” ](/2019/09/04/modeling-app-state-using-
> store-objects-in-swiftui/) post.
    
    
    struct ContentView: View {
        @StateObject var store = Store(service: .init())
    
        var body: some View {
            List(store.repos, id: \.self) { repo in
                RepoView(repo: repo)
            }
            .onAppear(perform: store.fetch)
            .redacted(reason: store.isLoading ? .placeholder : [])
        }
    }
    

While attaching the redacted modifier, we have to provide an instance of
_RedactionReasons_ struct using the reason parameter. _RedactionReasons_ is an
option set that we can extend with as many reasons as we need.
_RedactionReasons_ struct provides us a ready to use placeholder instance that
we use in the example above.

Remember that the redacted modifier hides the data only visually. It is still
clickable in case of buttons. It is your responsibility to disable buttons
while using the redacted modifier.

####  Unredacted modifier

As we already know, the redacted modifier traverses the view hierarchy and
applies its effect to hide the actual data, but what if we want to keep a
certain part of the view visible? SwiftUI provides us another modifier called
unredacted. Unredacted modifier allows us to keep the view unredacted while
applying the redacted modifier.

    
    
    struct RepoView: View {
        let repo: Repo
    
        var body: some View {
            HStack {
                VStack(alignment: .center) {
                    Image(systemName: "star.fill")
                        .resizable()
                        .frame(width: 44, height: 44)
                        .unredacted()
                    Text(String(repo.stars))
                        .font(.title)
                }.foregroundColor(.red)
    
                VStack(alignment: .leading) {
                    Text(repo.name)
                        .font(.headline)
                    Text(repo.description)
                        .foregroundColor(.secondary)
                }
            }
        }
    }
    

![unredacted](/public/unredacted.png)

####  Reasons

As we learned, the redacted modifier accepts a reason parameter. It’s great
that we can create as many different reasons and hide only the part we need.
SwiftUI provides a special environment value called _redactionReasons_ to get
the redaction reason applied to the current view hierarchy. Let’s start first
with the extending _RedactionReasons_ struct with more options.

    
    
    extension RedactionReasons {
        static let text = RedactionReasons(rawValue: 1 << 2)
        static let images = RedactionReasons(rawValue: 1 << 4)
    }
    

> To learn more about _OptionSet_ protocol in Swift, take a look at my [
> “Inclusive enums with OptionSet” ](/2019/04/10/inclusive-enums-with-
> optionset/) post.

Now we can tune our _RepoView_ to redact the only needed parts of the view.

    
    
    struct RepoView1: View {
        @Environment(\.redactionReasons) var reasons
        let repo: Repo
    
        var body: some View {
            HStack {
                VStack(alignment: .center) {
                    Image(systemName: "star.fill")
                        .resizable()
                        .frame(width: 44, height: 44)
                        .unredacted(when: !reasons.contains(.images))
                    Text(String(repo.stars))
                        .font(.title)
                        .unredacted(when: !reasons.contains(.text))
                }.foregroundColor(.red)
    
                VStack(alignment: .leading) {
                    Text(repo.name)
                        .font(.headline)
                    Text(repo.description)
                        .foregroundColor(.secondary)
                }.unredacted(when: !reasons.contains(.text))
            }
        }
    }
    

Remember that SwiftUI applies skeleton view effect only when we use
placeholder redaction reason. Any other reasons should be handled manually.

    
    
    extension View {
        @ViewBuilder func unredacted(when condition: Bool) -> some View {
            if condition {
                unredacted()
            } else {
                // Use default .placeholder or implement your custom effect
                redacted(reason: .placeholder)
            }
        }
    }
    

####  Conclusion

Today we learned another great feature that SwiftUI provides us for free out
of the box. I really love the skeleton view pattern, and with SwiftUI, I
started using it on every screen that loads some data. I hope you enjoy the
post. Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask
your questions related to this article. Thanks for reading, and see you next
week!



# Making real-world app with SwiftUI

##  Making real-world app with SwiftUI

05 Jun 2019

That is WWDC week: everybody is so excited about so many new things like
SwiftUI, Dark Mode, updateable Core ML models, etc. I will try to cover all
the new stuff during the upcoming weeks. Let’s start with SwiftUI. SwiftUI is
an entirely new approach to building apps for the Apple ecosystem.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

SwiftUI is a declarative Component-Oriented framework. You have to forget
about MVC where you have controllers mediating between view and model. All we
have in SwiftUI is a state and view derived from the state. As soon as your
state changes SwiftUI rebuild UI for that state changes. Apple team did an
excellent job by providing so beautiful [ tutorial page
](https://developer.apple.com/tutorials/swiftui/) for SwiftUI. It covers a lot
of stuff like Layout, Interfacing with UIKit, etc.

I will try to show you real-world app example written entirely in SwiftUI.
Let’s build an app searching for Github repos. We need a screen with a text
field for typing a query and a list of repos which comes from the search
query. I assume that you have already read the SwiftUI documentation because
I’m not going to describe basics, I will try to show something that
documentation didn’t covers.

Let’s start by building the _GithubService_ class, which creates a search
request and Repo struct, which represents a Github repository.

    
    
    struct Repo: Decodable, Identifiable {
        var id: Int
        let name: String
        let description: String
    }
    
    struct SearchResponse: Decodable {
        let items: [Repo]
    }
    
    class GithubService {
        private let session: URLSession
        private let decoder: JSONDecoder
    
        init(session: URLSession = .shared, decoder: JSONDecoder = .init()) {
            self.session = session
            self.decoder = decoder
        }
    
        func search(matching query: String, handler: @escaping (Result<[Repo], Error>) -> Void) {
            guard
                var urlComponents = URLComponents(string: "https://api.github.com/search/repositories")
                else { preconditionFailure("Can't create url components...") }
    
            urlComponents.queryItems = [
                URLQueryItem(name: "q", value: query)
            ]
    
            guard
                let url = urlComponents.url
                else { preconditionFailure("Can't create url from url components...") }
    
            session.dataTask(with: url) { [weak self] data, _, error in
                if let error = error {
                    handler(.failure(error))
                } else {
                    do {
                        let data = data ?? Data()
                        let response = try self?.decoder.decode(SearchResponse.self, from: data)
                        handler(.success(response?.items ?? []))
                    } catch {
                        handler(.failure(error))
                    }
                }
            }.resume()
        }
    }
    

Our _Repo_ struct has only a few fields, but it is enough for our sample. If
we want to use our _Repo_ struct as the model which should be used by SwiftUI
to build a View it has to conform to _Identifiable_ protocol. The only
requirement of _Identifiable_ protocol is id property, which has to be a
_Hashable_ value.

Now we can start implementing view which represents _Repo_ row in our list of
repos. We will use a vertical stack with two text labels.

    
    
    struct RepoRow: View {
        let repo: Repo
    
        var body: some View {
            VStack(alignment: .leading) {
                Text(repo.name)
                    .font(.headline)
                Text(repo.description)
                    .font(.subheadline)
            }
        }
    }
    

Let’s move to our SearchView which describes entire the screen.

    
    
    struct SearchView : View {
        @State private var query: String = "Swift"
        @EnvironmentObject var repoStore: ReposStore
    
        var body: some View {
            NavigationView {
                List {
                    TextField("Type something...", text: $query, onCommit: fetch)
                    ForEach(repoStore.repos) { repo in
                        RepoRow(repo: repo)
                    }
                }.navigationBarTitle(Text("Search"))
            }.onAppear(perform: fetch)
        }
    
        private func fetch() {
            repoStore.fetch(matching: query)
        }
    }
    

Here we have a query field which is marked as _@State_ . It means that this
view is derived from this state, and as soon as state changes, SwiftUI
rebuilds the view. SwiftUI uses diffing algorithm to understand changes and
update only corresponding views. SwiftUI stores all the fields marked as
_@State_ in special separated memory, where only corresponded view can access
and update them. _@State_ is a new Swift feature called Property Wrapper, more
about this feature you can read in [ the proposal
](https://github.com/apple/swift-
evolution/blob/master/proposals/0258-property-delegates.md) . The exciting
aspect is the usage of _$query_ , It means to get a reference for property
wrapper, not value itself. We use it to connect _TextField_ and _query_
variable in two way binding.

Another interesting fact here is _@EnvironmentObject_ . It is a part of
feature called _Environment_ . You can populate your _Environment_ with all
needed service classes and then access them from any view inside that
_Environment_ . The _Environment_ is the right way of Dependency Injection
with SwiftUI.

    
    
    import Foundation
    import Combine
    
    final class ReposStore: ObservableObject {
        @Published private(set) var repos: [Repo] = []
    
        private let service: GithubService
        init(service: GithubService) {
            self.service = service
        }
    
        func fetch(matching query: String) {
            service.search(matching: query) { [weak self] result in
                DispatchQueue.main.async {
                    switch result {
                    case .success(let repos): self?.repos = repos
                    case .failure: self?.repos = []
                    }
                }
            }
        }
    }
    

_ReposStore_ class should conform _ObservableObject_ protocol. It makes
possible to use it inside _Environment_ and rebuild view as soon as any
property marked as _@Published_ changes.

The main difference between _@State_ and _@EnvironmentObject_ is that _@State_
is accessible only to a particular view, in opposite _@EnvironmentObject_
available for every view inside the _Environment_ . But both of them used by
SwiftUI to track changes and rebuild views as soon as changes appear.

    
    
    class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    
        var window: UIWindow?
    
        func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
            let window = UIWindow(frame: UIScreen.main.bounds)
            let store = ReposStore(service: .init())
            window.rootViewController = UIHostingController(
                rootView: SearchView().environmentObject(store)
            )
            self.window = window
            window.makeKeyAndVisible()
        }
    }
    

And this is how we can start our SwiftUI app with defined _Environment_ .

####  Conclusion

This week we talked about an entirely new approach in the iOS development
world. I will try to cover more WWDC topics in the upcoming weeks. Feel free
to follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading and see you next week!



# Catching errors in Combine

##  Catching errors in Combine

22 Apr 2020

The Combine framework provides a declarative _Swift API_ for processing values
over time. It is another excellent framework that released side-by-side with
SwiftUI. I already covered it multiple times on my blog, but today I want to
talk about one of the key aspects of data processing. Today we will learn how
to handle errors during data processing using the Combine framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  The lifecycle of publisher

We use publishers to emit values over time. In the end, the publisher can
finish its work by sending the completion event or fail with an error. Neither
after completion nor after failure, the publisher can not emit new values.
Let’s take a look at the typical use-case that we might have in our apps.

    
    
    import SwiftUI
    
    struct SearchView: View {
        @ObservedObject var store: SearchStore
    
        var body: some View {
            NavigationView {
                List {
                    TextField("type something...", text: $store.query)
                    ForEach(store.repos, id: \.id) { repo in
                        Text(repo.name)
                    }
                }.navigationBarTitle("Search")
            }
        }
    }
    

In the example above, we have a view that allows users to enter a keyword and
the list that renders search results. We use a store object to bind a query
and repos array that holds search results. The main goal of the store object
is fetching repos matching the query using Github API.

    
    
    final class SearchStore: ObservableObject {
        @Published var query: String = ""
        @Published private(set) var repos: [Repo] = []
        private var cancellable: AnyCancellable?
    
        init(service: GithubService) {
            cancellable = $query
                .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
                .flatMap { service.searchPublisher(matching: $0) }
                .subscribe(on: DispatchQueue.global())
                .receive(on: DispatchQueue.main)
                .sink(
                    receiveCompletion: { completion in
                        switch completion {
                        case .failure(let error): print("Error \(error)")
                        case .finished: print("Publisher is finished")
                        }
                },
                    receiveValue: { [weak self] in self?.repos = $0 }
            )
        }
    }
    

I don’t want to produce too many requests as user types a query. That’s why I
debounce it for 500ms. It means the publisher will wait at least 500ms
whenever the user stops typing and then publish a value. Then I can use a
_flatMap_ operator to run a search request using a query. In the end, I use
the _sink_ subscriber to assign search results to a store variable. As soon as
published variables change, SwiftUI will update the view to respect new data.

> To learn more about store concept, take a look at my [ “Modeling app state
> using Store objects in SwiftUI” ](/2019/09/04/modeling-app-state-using-
> store-objects-in-swiftui/) post.

We have one problem here, whenever the publisher fails with an error, nothing
will happen in the view. _Sink_ subscriber will just print the message in the
console.

####  Replace error with the value

Publishers provide us a few ways to handle errors in the chain. Let’s start
with the easiest one. Every publisher that can fail allows us to replace the
error with some default value using _replaceError_ operator. Let’s take a look
at how we can use it.

    
    
    init(service: GithubService) {
        $query
            .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
            .flatMap { service.searchPublisher(matching: $0) }
            .replaceError(with: [])
            .subscribe(on: DispatchQueue.global())
            .receive(on: DispatchQueue.main)
            .assign(to: &$repos)
    }
    

As you can see, I have inserted _replaceError_ operator with an empty array.
Publisher will replace any error that might occur with an empty array and then
terminate. The downside here is that the publisher completes its work after an
error. It means our binding will not process new values. The user will type
further queries, but nothing will happen. Let’s see how we can fix that.

    
    
    init(service: GithubService) {
        $query
            .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
            .flatMap { 
                service
                    .searchPublisher(matching: $0)
                    .replaceError(with: []) 
            }
            .subscribe(on: DispatchQueue.global())
            .receive(on: DispatchQueue.main)
            .assign(to: &$repos)
    }
    

To keep your publisher alive, you have to handle all errors outside of the
main chain. We can fix it by moving _replaceError_ operator inside the
_flatMap_ . As you can see, the publisher inside the _flatMap_ replaces an
error with a value and then terminate its work. The main chain is still alive
and emits new values.

####  Retry operator

Another useful operator that can help to solve an issue during value
processing is _retry_ . _Retry_ operator tries to process the value again and
again as many times as you specify.

    
    
    init(service: GithubService) {
        $query
            .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
            .flatMap {
                service
                    .searchPublisher(matching: $0)
                    .retry(3)
                    .replaceError(with: [])
            }
            .subscribe(on: DispatchQueue.global())
            .receive(on: DispatchQueue.main)
            .assign(to: &$repos)
    }
    

As you can see in the example above, I ask the publisher to retry three times
before replacing an error with an empty array.

####  Catch operator

Both retry and replace error operators are built on top of the _catch_
operator. The _catch_ operator allows us to replace a failed publisher with a
new one. After that, the chain will use the new publisher to emit values.

    
    
    init(service: GithubService) {
        $query
            .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
            .flatMap {
                service
                    .searchPublisher(matching: $0)
                    .catch { error -> AnyPublisher<[Repo], Never> in
                        if error is URLError {
                            return Just([])
                                .eraseToAnyPublisher()
                        } else {
                            return Empty(completeImmediately: true)
                                .eraseToAnyPublisher()
                        }
                }
            }
            .subscribe(on: DispatchQueue.global())
            .receive(on: DispatchQueue.main)
            .assign(to: &$repos)
    }
    

Another great thing about the _catch_ operator is the opportunity to access
the error and return a new publisher after inspecting the error.

####  Conclusion

The Combine is the framework that I use in all of my apps. It has a high
performance and friendly _Swift API_ . Sometimes it is hard to debug errors in
the Combine publisher chains. I hope this post gave you more information on
the publisher’s lifecycle and explained to you how to catch the errors. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# SF Symbols in SwiftUI

##  SF Symbols in SwiftUI

21 Dec 2021

Apple provides us with a set of different icons available across all the
platforms called SF Symbols. SF Symbols package contains more than 3200 icons
that we can use to visualize different states and actions in our apps. This
week we will learn how to utilize the power of SF Symbols in SwiftUI views.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

You can easily display an SF Symbols in SwiftUI by using a particular
initializer of the _Image_ struct. Let’s take a look at a few quick examples.

    
    
    Image(systemName: "doc.on.doc")
    

![sf-symbol](/public/sf1.png)

As you can see in the example above, we define an image with a system name.
SwiftUI uses the _systemName_ parameter for SF Symbol lookup. Keep in mind
that you can use string interpolation to show an SF Symbol as the part of any
text.

    
    
    Text("Super star \(Image(systemName: "star"))")
    

![sf-symbol](/public/sf2.png)

Another SwiftUI view that plays well with SF Symbols is _Label_ . The _Label_
view contains both text and an image and shows them according to the current
context. For example, it hides the text and shows only the image in a toolbar.

    
    
    Button(role: .destructive, action: {}) {
        Label("Remove", systemImage: "trash")
    }
    

![sf-symbol](/public/sf3.png)

> To learn more about the power of the _Label_ view, take a look at my
> dedicated [ “Labels in SwiftUI” ](/2020/12/23/labels-in-swiftui/) post.

####  Styling options

You can easily change the color of an SF Symbol using the _foregroundStyle_ or
_foregroundColor_ view modifiers.

    
    
    VStack(spacing: 8) {
        Image(systemName: "doc.on.doc")
            .foregroundColor(.green)
    
        Text("Super star \(Image(systemName: "star"))")
            .foregroundStyle(.secondary)
    }
    

There are two ways of changing the size of an SF Symbol in SwiftUI view.
First, you can apply the _font_ view modifier to keep the text and the image
size in sync with the selected Dynamic Type category.

    
    
    Button(role: .destructive, action: {}) {
        Label("Remove", systemImage: "trash")
    }
    .font(.title3)
    

Another option is the _imageScale_ view modifier that doesn’t affect the size
of the text and only changes the size of the SF Symbol relatively.

    
    
    Button(role: .destructive, action: {}) {
        Label("Remove", systemImage: "trash")
    }
    .imageScale(.large)
    

####  Variants

SF Symbols package provides us with icons in many different variants. For
example, the trash icon comes with filled, circled, squared, and slashed
versions. You can define the variant you need by providing the dedicated
symbol name.

    
    
    Image(systemName: "doc.on.doc.fill")
    

SwiftUI views are smart enough to display the variant they need without the
concrete name. For example, tab bars use the filled version of SF Symbols, and
you don’t need to specify it manually. SwiftUI picks up the correct version of
the SF Symbol automatically.

    
    
    struct ContentView: View {
        var body: some View {
            TabView {
                Text("Hello")
                    .tabItem {
                        Image(systemName: "trash")
                    }
            }
        }
    }
    

SwiftUI also provides the _symbolVariant_ view modifier that sets the
particular variant in the environment and forces it to use in the view
hierarchy.

    
    
    VStack(spacing: 8) {
        Image(systemName: "doc.on.doc")
            .foregroundColor(.green)
    
        Text("Super star \(Image(systemName: "star"))")
            .foregroundStyle(.secondary)
    
        Button(role: .destructive, action: {}) {
            Label("Remove", systemImage: "trash")
        }
        .imageScale(.large)
    }
    .symbolVariant(.fill)
    

> To learn more about environment in SwiftUI, take a look at my [ “The power
> of Environment in SwiftUI” ](/2019/08/21/the-power-of-environment-in-
> swiftui/) post.

####  Rendering mode

SF Symbols support four rendering modes that allow you to customize the way
SwiftUI colors them. Let’s take a look at them.

  1. _Monochrome_ : A mode that renders symbols as a single layer filled with color. 
  2. _Multicolor_ : This method generates symbols as multiple layers with their inherited styles. 
  3. _Hierarchical_ : A mode renders symbols as various layers, with different opacities applied to the foreground style. 
  4. _Palette_ : A way that renders symbols as numerous layers, with different styles used as the layers. 

You can use the _symbolRenderingMode_ view modifier to set a particular
rendering mode in the environment and apply it across the view hierarchy.

    
    
    struct ContentView: View {
        var body: some View {
            VStack(spacing: 8) {
                Image(systemName: "doc.on.doc.fill")
                    .foregroundColor(.green)
    
                Text("Super star \(Image(systemName: "star"))")
                    .foregroundStyle(.secondary)
    
                Button(role: .destructive, action: {}) {
                    Label("Remove", systemImage: "trash")
                }
                .imageScale(.large)
            }
            .symbolVariant(.fill)
            .symbolRenderingMode(.hierarchical)
        }
    }
    

SwiftUI allows us to set the foreground styles for different layers inside the
SF Symbol in _palette_ mode by using the _foregroundStyle_ view modifier with
multiple levels.

    
    
    struct ContentView: View {
        var body: some View {
           Image(systemName: "doc.on.doc")
                .symbolRenderingMode(.palette)
                .foregroundStyle(.red, .green, .blue)
        }
    }
    

####  Conclusion

It became straightforward to build friendly apps with a well-crafted set of
icons using SF Symbols. Moreover, SwiftUI provides a few ways of customizing
these icons by using dedicated view modifiers that we have learned today. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering charts in SwiftUI. Mark styling.

##  Mastering charts in SwiftUI. Mark styling.

18 Jan 2023

Last week we started a series of posts about the new Charts framework
available on the latest Apple platforms. We talked about basic stuff and
learned how to plot data. This week we will continue mastering the Charts
framework by learning different customization and styling options available.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

As we learned in the previous post, the Charts framework provides different
mark types, allowing us to plot our data differently. _AreaMark_ , _BarMark_ ,
_LineMark_ , _PointMark_ , _RectangleMark_ , and _RuleMark_ , all of these
mark types let us apply modifiers we used to have in SwiftUI views.

> To learn more about the basics of the Charts framework, take a look at my
> dedicated [ “Mastering charts in SwiftUI. Basics.” ](/2023/01/10/mastering-
> charts-in-swiftui-basics/) post.

For example, we can use the _foregroundStyle_ modifier to change the mark’s
color using any _ShapeStyle_ we need or the _opacity_ modifier to change the
alpha of the mark.

    
    
    enum Gender: String {
        case male
        case female
        case notSet
    }
    
    extension Gender: Plottable {
        var primitivePlottable: String {
            rawValue
        }
    }
    
    struct Stats {
        let city: String
        let population: Int
        let gender: Gender
    }
    
    struct ContentView1: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .opacity(0.3)
                    .foregroundStyle(.red)
                }
            }
        }
    }
    

> To learn more about the _ShapeStyle_ protocol, take a look at my [ “The many
> faces of ShapeStyle in SwiftUI” ](/2021/11/17/the-many-faces-of-shapestyle-
> in-swiftui/) post.

![chart-with-opacity-and-color](/public/chart10.png)

The _clipShape_ modifier allows us to change the shape of the bar mark, and
the _position_ modifier will enable us to stack bar marks in a group
differently.

    
    
    struct ContentView1: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender))
                    .clipShape(RoundedRectangle(cornerRadius: 16))
                    .position(by: .value("Gender", stat.gender))
                }
            }
        }
    }
    

![bar-chart-with-custom-stacking](/public/chart6.png)

As you can see in the example above, we use the _clipShape_ modifier to round
the rectangles of our bars. We also use the _position_ modifier to stack them
horizontally. By default, the Charts framework accumulates bars in a single
group vertically.

On the other hand, the _LineMark_ type allows us to use the _lineStyle_
modifier to change the stroke style of the plotted line. We can also use the
_interpolationMethod_ modifier to change how the framework draws the line.

    
    
    struct ContentView: View {
        let numbers: [Double]
        
        var body: some View {
            Chart {
                RuleMark(y: .value("Limit", 50))
                
                ForEach(Array(numbers.enumerated()), id: \.offset) { index, value in
                    LineMark(
                        x: .value("Index", index),
                        y: .value("Value", value)
                    )
                    .interpolationMethod(.catmullRom)
                    .lineStyle(StrokeStyle(lineWidth: 1, dash: [2]))
                    
                    PointMark(
                        x: .value("Index", index),
                        y: .value("Value", value)
                    )
                }
            }
        }
    }
    

![line-chart-with-custom-curve](/public/chart7.png)

In the example above, we use the _lineStyle_ modifier to provide a custom
stroke style. Here we use particular dash values allowing us to draw the
dashed line. We also apply the _interpolationMethod_ modifier with
_catmullRom_ value to draw a curved line instead of a straight one.

The Charts framework has smart defaults and can extract value from your data
to do some stuff automatically without your notice. For example, it can
understand your data and color it or automatically generate a legend for your
chart.

![chart-with-legend](/public/chart11.png)

One of my favorite things about the new Charts framework is how data
annotating works. You can annotate any mark on your chart with a SwiftUI view.
It means you can plot your data and place SwiftUI views inside your chart
close to your data point.

> To learn more about the logic behind the _ViewBuilder_ type, take a look at
> my [ “The power of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-
> viewbuilder-in-swiftui/) post.

Annotating data points with the new Chart framework is easy. Every mark type
provides us with the _annotation_ modifier accepting a _ViewBuilder_ closure
where we can construct our SwiftUI view.

    
    
    struct ContentView1: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .clipShape(RoundedRectangle(cornerRadius: 16))
                    .position(by: .value("Gender", stat.gender))
                    .annotation {
                        Text(verbatim: stat.population.formatted())
                            .font(.caption)
                    }
                }
            }
        }
    }
    

![chart-with-annotation](/public/chart8.png)

As you can see in the example above, we use the _annotation_ modifier to place
the text with the population above the bar mark. The _annotation_ modifier
also accepts the _position_ , _alignment_ , and _spacing_ parameters.

    
    
    struct ContentView1: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .clipShape(RoundedRectangle(cornerRadius: 16))
                    .position(by: .value("Gender", stat.gender))
                    .annotation(position: .bottom, alignment: .trailing, spacing: 16) {
                        Text(verbatim: stat.population.formatted())
                            .font(.caption)
                    }
                }
            }
        }
    }
    

![chart-with-annotation](/public/chart9.png)

We can put an annotation under the bar, above it, or overlay it. Remember that
you can place as many annotations as you need, but try to leave your charts
manageable with annotations.

Today we learned how to style our data points in the new Charts framework. I
hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Mastering charts in SwiftUI. Legends.

##  Mastering charts in SwiftUI. Legends.

22 Feb 2023

Last week we started the topic of the Swift Charts framework customization
options using a bunch of chart view modifiers. It is a vast topic that I
divide into a few small posts. This week we will discuss configuring the
legend view using the new Swift Charts framework.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

The Swift Charts framework is smart enough to infer and display the legend
view for your chart automatically. Let’s take a look at the concrete example.

    
    
    struct ContentView: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender))
                    .position(by: .value("Gender", stat.gender))
                }
            }
        }
    }
    

![gender-chart-with-legend](/public/chart15.png)

> To learn more about the basics of the Charts framework, take a look at my
> dedicated [ “Mastering charts in SwiftUI. Basics.” ](/2023/01/10/mastering-
> charts-in-swiftui-basics/) post.

As you can see in the example above, our chart has a legend view automatically
generated by the Swift Charts framework. We use the _foregroundStyle_ modifier
on the _BarMark_ type, which allows the framework to create a legend view. It
looks good, but what if we don’t need the legend view at all? In this case, we
can use the _chartLegend_ view modifier to control the visibility of the
legend view.

    
    
    struct ContentView: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender))
                    .position(by: .value("Gender", stat.gender))
                }
            }
            .chartLegend(.hidden)
        }
    }
    

The _chartLegend_ modifier allows us to control the visibility of the legend
view by passing one of these three options: _automatic_ , _visible_ , and
_hidden_ . Another overload of the _chartLegend_ modifier allows us to control
the legend view’s position, alignment, and spacing.

    
    
    struct ContentView: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender))
                    .position(by: .value("Gender", stat.gender))
                }
            }
            .chartLegend(position: .top, alignment: .leading, spacing: 8)
        }
    }
    

Let’s move forward and customize the colors for our bars and circles in the
legend view representing them.

    
    
    struct ContentView: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender))
                    .position(by: .value("Gender", stat.gender))
                }
            }
            .chartForegroundStyleScale(
                domain: Gender.allCases,
                range: [.red, .orange, .black]
            )
        }
    }
    

As you can see in the example above, we use the _chartForegroundStyleScale_
modifier to provide both values and colors representing that values. The
_chartForegroundStyleScale_ modifier pairs with the _foregroundStyle_ modifier
and maps values you pass to colors on the chart and in the legend view.

> To learn more about customization options of the Charts framework, take a
> look at my dedicated [ “Mastering charts in SwiftUI. Customizations.”
> ](/2023/02/15/mastering-charts-in-swiftui-customizations/) post.

You might need to provide static data for your legend view in some specific
cases. For that, you can use another overload of the
_chartForegroundStyleScale_ modifier accepting a key-value literal.

    
    
    struct ContentView: View {
        let stats: [Stats]
        
        var body: some View {
            Chart {
                ForEach(stats, id: \.city) { stat in
                    BarMark(
                        x: .value("City", stat.city),
                        y: .value("Population", stat.population)
                    )
                    .foregroundStyle(by: .value("Gender", stat.gender))
                    .position(by: .value("Gender", stat.gender))
                }
            }
            .chartForegroundStyleScale(
                [
                    Gender.notSet: Color.black,
                    .female: Color.orange,
                    .male: Color.red
                ]
            )
        }
    }
    

In the example above, we use the _chartForegroundStyleScale_ and pass the
dictionary with gender-color pairs. Usually, we generate this data dynamically
using some logic, but you can also hardcode these values if needed.

I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Drag and drop in SwiftUI

##  Drag and drop in SwiftUI

01 Apr 2020

Another _iPadOS_ feature released in SwiftUI with Xcode 11.4 was the drag and
drop. Finally, we can use drag and drop API not only with _UIKit_ but also
with SwiftUI. This week we will learn all about drag and drop interactions in
SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

Drag and drop interactions allow users to send data between two apps or two
scenes of the same app. For example, you can run Safari and Notes apps side-
by-side and drag the links from Safari to Notes app. As part of the post, we
will build a bookmarking app that uses drag and drop to save or open links
stored in the app.

####  Drag

SwiftUI provides _onDrag_ modifier that allows us to register a closure that
will create and return _NSItemProvider_ . _NSItemProvider_ is the class that
describes the content and the type of draggable item. Let’s take a look at how
we can use _onDrag_ modifier.

    
    
    struct BookmarksList: View {
        @State private var links: [URL] = [
            URL(string: "https://twitter.com/mecid")!
        ]
    
        var body: some View {
            List {
                ForEach(links, id: \.self) { url in
                    Text(url.absoluteString)
                        .onDrag { NSItemProvider(object: url as NSURL) }
                }
            }
            .navigationBarTitle("Bookmarks")
        }
    }
    

As you can see in the example above, all we need to do is to use _onDrag_
modifier that returns an instance of _NSItemProvider_ . Now you can run the
app on the iPad simulator side-by-side with Safari and try to drag and drop
the link from our app to Safari.

####  Drag preview

Another version of the _onDrag_ view modifier allows you to provide a preview
of the dragging content.

    
    
    struct BookmarksList: View {
        @State private var links: [URL] = [
            URL(string: "https://twitter.com/mecid")!
        ]
    
        var body: some View {
            List {
                ForEach(links, id: \.self) { url in
                    Text(url.absoluteString)
                        .onDrag {
                            NSItemProvider(object: url as NSURL)
                        } preview: {
                            Text(verbatim: url.absoluteString)
                        }
                }
            }
            .navigationBarTitle("Bookmarks")
        }
    }
    

####  Drop

Unlike drag operation, drop interaction is a little bit complicated. SwiftUI
gave us three overloads of _onDrop_ modifier.

    
    
    struct BookmarksList: View {
        @State private var links: [URL] = [
            URL(string: "https://twitter.com/mecid")!
        ]
        
        var body: some View {
            List {
                ForEach(links, id: \.self) { url in
                    Text(url.absoluteString)
                        .onDrag { NSItemProvider(object: url as NSURL) }
                }
                .onDrop(of: ["public.url"], isTargeted: nil) { providers in
                    providers.forEach { provider in
                        _ = provider.loadObject(ofClass: URL.self) { url, _ in
                            if let url {
                                links.append(url)
                            }
                        }
                    }
                    return true
                }
            }
            .navigationBarTitle("Bookmarks")
        }
    }
    

The most interesting one is the overload that accepts _DropDelegate_ .
_DropDelegate_ is the protocol that we can implement to control drop
interaction. Let’s take a look at the quick example.

    
    
    struct BookmarksDropDelegate: DropDelegate {
        @Binding var bookmarks: [URL]
    
        func performDrop(info: DropInfo) -> Bool {
            guard info.hasItemsConforming(to: ["public.url"]) else {
                return false
            }
    
            let items = info.itemProviders(for: ["public.url"])
            for item in items {
                _ = item.loadObject(ofClass: URL.self) { url, _ in
                    if let url = url {
                        DispatchQueue.main.async {
                            self.bookmarks.insert(url, at: 0)
                        }
                    }
                }
            }
    
            return true
        }
    }
    

Here we have a _BookmarksDropDelegate_ struct that conforms to _DropDelegate_
protocol. _DropDelegate_ protocol requires us to implement _performDrop_
function. This function should return _true_ whenever the drop succeeded or
_false_ if it failed. _performDrop_ function has _DropInfo_ parameter, which
provides us the information about items that should be dropped.

Using _DropInfo_ , we can filter items and accept only links. Apple uses
_Uniform Type Identifiers_ to identify the type of data. We want to receive
only URLs that’s why we use **public.link** identifier. _DropInfo_ also
provides us the location of drop using _CGPoint_ instance.

> To learn more about _Uniform Type Identifiers_ , take a look at [ Apple’s
> documentation
> ](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_intro/understand_utis_intro.html)
> .

_DropDelegate_ also has a few not required functions that we can use to
understand when dropping started and ended. Finally, we are ready to register
our _BookmarksDropDelegate_ on the _List_ or _ForEach_ to enable drop
interaction.

    
    
    struct BookmarksList: View {
        @State private var links: [URL] = [
            URL(string: "https://twitter.com/mecid")!
        ]
    
        var body: some View {
            List {
                ForEach(links, id: \.self) { url in
                    Text(url.absoluteString)
                        .onDrag { NSItemProvider(object: url as NSURL) }
                }
                .onDrop(
                    of: ["public.url"],
                    delegate: BookmarksDropDelegate(bookmarks: $links)
                )
            }
            .navigationBarTitle("Bookmarks")
        }
    

Unfortunately, _onDrop_ modifier doesn’t affect the _List_ or any view that
inside a _List_ . It works well with _VStack_ , _ScrollView_ , and other
views. But it doesn’t work with the _List_ .

I hope it is a bug, and Apple will fix it soon. We can replace the _List_ with
_ScrollView_ to make _onDrop_ modifier working. But in this case, we will lose
all the features of the _List_ component.

####  Insert

Gladly, SwiftUI provides us another modifier that we can use on _ForEach_
view. _onInsert_ modifier looks like a simplified version of _onDrop_
modifier, and it works inside _List_ component. Let’s take a look at the quick
usage example of _onInsert_ modifier.

    
    
    struct BookmarksList: View {
        @State private var links: [URL] = [
            URL(string: "https://twitter.com/mecid")!
        ]
    
        var body: some View {
            List {
                ForEach(links, id: \.self) { url in
                    Text(url.absoluteString)
                        .onDrag { NSItemProvider(object: url as NSURL) }
                }
                .onInsert(of: ["public.url"], perform: drop)
            }
            .navigationBarTitle("Bookmarks")
        }
    
        private func drop(at index: Int, _ items: [NSItemProvider]) {
            for item in items {
                _ = item.loadObject(ofClass: URL.self) { url, _ in
                    DispatchQueue.main.async {
                        url.map { self.links.insert($0, at: index) }
                    }
                }
            }
        }
    }
    

As you can see, we use _onInsert_ modifier to accept the insertion of links.
We also pass the drop function that handles the process of loading the URL
object and insertion.

####  Conclusion

Today we learned another new feature that released with Xcode 11.4. Please
note that all drag and drop related modifiers are available as part of iOS
13.4. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Logging in Swift

##  Logging in Swift

06 Apr 2022

We encounter bugs that are very hard to catch in the debugger from time to
time. For example, it might occur only after a few days of app usage. In this
case, running an app in a simulator and testing a feature doesn’t make sense.
We need to understand what the user has done in the application and how it
responds to user actions in this situation. Logging is an excellent technique
to track and understand user actions through the app. This week we will learn
how to implement proper logging functionality in our apps.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Writing logs

Fortunately, Apple provides us with a unified logging system to build a proper
logging using the _Logger_ type. Let’s take a look at how we can use it in
code.

    
    
    import Foundation
    import os
    
    @MainActor final class ProductsViewModel: ObservableObject {
        private static let logger = Logger(
            subsystem: Bundle.main.bundleIdentifier!,
            category: String(describing: ProductsViewModel.self)
        )
    
        @Published private(set) var products: [Product] = []
    
        private let service: ProducsService
        init(service: ProducsService) {
            self.service = service
        }
    
        func fetch() async {
            do {
                Self.logger.trace("Start product list fetching")
                products = try await service.fetch()
                Self.logger.notice("Product list fetching is finished")
            } catch {
                Self.logger.warning("\(error.localizedDescription, privacy: .public)")
            }
        }
    }
    

As you can see in the example above, we have the _ProductsViewModel_ fetching
products from the remote server. Usually, we need only one _Logger_ instance
per feature. That’s why we declare it as a _private_ and _static_ constant. We
can use _subsystem_ and _category_ parameters to filter logs in the future
when we need to extract them. I usually use bundle identifier as subsystem and
type name as a category. This approach allows me easily find logs from the
required part of my app.

_Logger_ type provides us with functions to log a message with different
emergency levels. For example, the _trace_ function works as debug print, and
the system doesn’t store it. The _warning_ function allows us to log errors
that are not fatal for our app, but we still need to know about them.

    
    
    func save(_ object: CKRecord, using container: CKContainer) async {
        do {
            let status = try await container.accountStatus()
        } catch {
            logger.critical("Can't fetch iCloud account status.")
            fatalError()
        }
    }
    

Sometimes we want to crash our app instead of working in an inconsistent
state. We can use the _critical_ function before calling _fatalError_ to save
a meaningful error message.

Remember that the iOS system will store messages logged with _notice, warning,
and critical_ functions up to a storage limit. It doesn’t store trace messages
at all.

####  Reading logs

We learned how to write logs, but how can we read them? All the records appear
in the Xcode’s debug console while running the app through Xcode. Another
option is a device with an already running app that you can connect to your
computer via cable. In this case, you can extract logs by using the Console
app. The console app allows us to quickly filter subsystems and categories to
focus only on required information.

    
    
    import Foundation
    import SwiftUI
    import os
    
    struct ContentView: View {
        @Environment(\.scenePhase) var scenePhase
    
        var body: some View {
            Text("Hello!")
                .onChange(of: scenePhase) { newPhase in
                    logger.trace("Scene phase: \(newPhase)")
                }
        }
    }
    

![console-app-screenshot](/public/console.png)

####  Formatting logs

As you can see in the screenshot above, the Console app hides a part of logged
information. By default, the _Logger_ type shows only static strings, and all
the interpolated content is invisible for the developer. Usually, we need to
see the description of the error. We should use the public as a _privacy_
parameter to make it possible.

    
    
    import Foundation
    import SwiftUI
    import os
    
    struct ContentView: View {
        @State private var counter: UInt = 1_000
        @Environment(\.scenePhase)
        private var scenePhase
    
        var body: some View {
            Text("Hello!")
                .onChange(of: scenePhase) { newPhase in
                    logger.trace("Scene phase: \(newPhase, privacy: .public)")
                    logger.trace("Counter: \(counter, privacy: .private(mask: .hash))")
                    logger.trace("Counter: \(counter, align: .right(columns: 10))")
                    logger.trace("Counter: \(counter, format: .hex, align: .right(columns: 10))")
                }
        }
    }
    

The _Logger_ type uses string interpolation to provide formatting options,
like aligning, hiding, and formatting values.

####  Conclusion

Logging errors and crucial situations in your app is vital. Today we learned
how to build a proper logging flow and how we can leverage the power of the
Console app to filter logged messages. I hope you enjoy the post. Feel free to
follow me on [ Twitter ](https://twitter.com/mecid) and ask your questions
related to this post. Thanks for reading, and see you next week!



# Mastering ControlGroup in SwiftUI

##  Mastering ControlGroup in SwiftUI

21 Oct 2021

One of the new container views delivered in SwiftUI Release 3 was the
_ControlGroup_ view. The _ControlGroup_ view displays semantically-related
controls in a visually appropriate manner for the context. This week we will
learn how to use and customize the appearance of the _ControlGroup_ view in
SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Basics

The _ControlGroup_ view is the simple container view that accepts
_ViewBuilder_ closure and displays it depending on the current environment.
Let’s see how we can use it.

> To learn more about _ViewBuilder_ , take a look at my dedicated [ “The power
> of @ViewBuilder in SwiftUI” ](/2019/12/18/the-power-of-viewbuilder-in-
> swiftui/) post.
    
    
    struct ContentView: View {
        var body: some View {
            ControlGroup {
                Button(action: {}) {
                    Label("Decrease", systemImage: "minus")
                }
    
                Button(action: {}) {
                    Label("Increase", systemImage: "plus")
                }
            }
        }
    }
    

![controlgroup](/public/controlgroup1.png)

As you can see in the example above, we simply put two buttons inside the
_ControlGroup_ view as we do with _VStack_ or _HStack_ . But instead of laying
out views using vertical or horizontal axes, the _ControlGroup_ adds the
semantic look and feel depending on the view’s placement.

####  Styling

The _ControlGroup_ view has a few styling options out of the box. SwiftUI
provides _automatic_ and _navigation_ styles. The _automatic_ style is used by
default, but you can set another style directly using the _controlGroupStyle_
view modifier. SwiftUI uses the _navigation_ style when you place the
_ControlGroup_ view in the toolbar of the _NavigationView_ .

    
    
    struct ContentView: View {
        var body: some View {
            ControlGroup {
                Button(action: {}) {
                    Label("Decrease", systemImage: "minus")
                }
    
                Button(action: {}) {
                    Label("Increase", systemImage: "plus")
                }
            }
            .controlGroupStyle(.navigation)
        }
    }
    

![navigation-styled-controlgroup](/public/controlgroup2.png)

As you can see in the example, we use the _controlGroupStyle_ view modifier to
set the style manually. SwiftUI uses the same approach for many different
views and allows us to create our own style types by conforming to a protocol.
In the case of the _ControlGroup_ view, we should create a type that conforms
to the _ControlGroupStyle_ protocol and implement the single required function
called _makeBody_ .

> To learn more about other styling protocols available in SwiftUI, take a
> look at [ “Mastering buttons in SwiftUI” ](/2020/02/19/mastering-buttons-in-
> swiftui/) post.
    
    
    struct VerticalControlGroupStyle: ControlGroupStyle {
        func makeBody(configuration: Configuration) -> some View {
            VStack {
                configuration.content
            }.foregroundColor(.red)
        }
    }
    
    struct ContentView: View {
        var body: some View {
            ControlGroup {
                Button("Action 1") {}
                Button("Action 2") {}
            }
            .controlGroupStyle(VerticalControlGroupStyle())
        }
    }
    

![custom-styled-controlgroup](/public/controlgroup3.png)

The _makeBody_ function has the single parameter of _Configuration_ type that
you can use to access the content of the _ControlGroup_ passed via
_ViewBuilder_ closure. It allows you to modify the look and feel of the
content in the way you need by applying any view modifiers you want. In the
current example, we place the content in the vertical stack and set the
foreground color to red.

    
    
    struct ControlGroupWithTitle: ControlGroupStyle {
        let title: LocalizedStringKey
    
        func makeBody(configuration: Configuration) -> some View {
            VStack {
                Text(title)
                    .font(.title)
                HStack {
                    configuration.content
                }
            }
        }
    }
    
    struct ContentView: View {
        var body: some View {
            ControlGroup {
                Button("Action 1") {}
                Button("Action 2") {}
            }
            .controlGroupStyle(ControlGroupWithTitle(title: "Actions"))
        }
    }
    

![custom-styled-controlgroup](/public/controlgroup4.png)

We also can change the look and feel by adding new views and wrapping the
content with another container view.

    
    
    extension ControlGroupStyle where Self == ControlGroupWithTitle {
        static func with(title: LocalizedStringKey) -> ControlGroupWithTitle {
            ControlGroupWithTitle(title: title)
        }
    }
    
    struct ContentView: View {
        var body: some View {
            ControlGroup {
                Button("Action 1") {}
                Button("Action 2") {}
            }.controlGroupStyle(.with(title: "Actions"))
        }
    }
    

Swift 5.5 allows us to write extensions for protocols with associated types
and improve the usage of our custom styles provided to the _controlGroupStyle_
view modifier.

####  Conclusion

The _ControlGroup_ view is a new way to group buttons and other controls in a
semantic way. I really love SwiftUI because it uses the same approach across
the many views to provide custom styling options. I hope you enjoy the post.
Feel free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Mastering ScrollView in SwiftUI. Scroll Position

##  Mastering ScrollView in SwiftUI. Scroll Position

27 Jun 2023

This week we will continue the series of posts dedicated to mastering
_ScrollView_ . Today we will talk about a set of new options for controlling
the scroll content position of a _ScrollView_ in SwiftUI.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

####  Initial position

The SwiftUI framework provides us the brand new _scrollPosition_ view modifier
allowing us to set the initial anchor for the content in the _ScrollView_ .
Let’s take a look at a very quick example.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                LazyVStack {
                    ForEach(0..<100) { index in
                        Rectangle()
                            .fill(Color.green.gradient)
                            .frame(height: 300)
                            .id(index)
                    }
                }
            }
            .scrollPosition(initialAnchor: .center)
        }
    }
    

As you can see in the example above, we use the new _scrollPosition_ view
modifier to set the initial anchor to the center of the content. The center
option here is the instance of the _UnitPoint_ type, which has a bunch of
predefined values like _bottom_ , _top_ , _trailing_ , _leading_ , etc. You
can also create your own _UnitPoint_ by providing x and y values which take
normalized values from 0 to 1.

    
    
    struct ContentView: View {
        var body: some View {
            ScrollView {
                LazyVStack {
                    ForEach(0..<100) { index in
                        Rectangle()
                            .fill(Color.green.gradient)
                            .frame(height: 300)
                            .id(index)
                    }
                }
            }
            .scrollPosition(initialAnchor: .init(x: 0, y: 0.9)
        }
    }
    

####  Scroll position

Another variant of the new _scrollPosition_ view modifier takes a binding to
the hashable value allowing us to read and write the scroll content offset.

    
    
    struct ContentView: View {
        @State private var position: Int?
        
        var body: some View {
            ScrollView {
                LazyVStack {
                    ForEach(0..<100) { index in
                        Rectangle()
                            .fill(Color.green.gradient)
                            .frame(height: 300)
                            .id(index)
                    }
                }
                .scrollTargetLayout()
            }
            .scrollPosition(id: $position)
        }
    }
    

As you can see in the example above, we use the _scrollPosition_ view modifier
with the binding to the integer value. We also use the _id_ view modifier to
explicitly set the identifier to the view inside the scroll. You don’t need to
set id manually if you are using _ForEach_ with identifiable types or provide
the _KeyPath_ to _id_ .

Remember that you should always use the _scrollTargetLayout_ or _scrollTarget_
view modifiers to allow the _ScrollView_ to understand where to find the
identifiers for the binding.

> To learn more about the _scrollTargetLayout_ and _scrollTarget_ view
> modifiers, take a look at my [ “Mastering ScrollView in SwiftUI. Target
> Behavior” ](/2023/06/20/mastering-scrollview-in-swiftui-target-behavior/)
> post.

As I said before, you can use the _scrollPosition_ view modifier not only for
reading but also to change the scroll content offset. In the following
example, we will add the button changing the value of the binding, and the
scroll view updates content offset accordingly.

    
    
    struct ContentView: View {
        @State private var position: Int?
        
        var body: some View {
            ScrollView {
                LazyVStack {
                    Button("Jump...") {
                        position = 99
                    }
                    
                    ForEach(0..<100) { index in
                        Rectangle()
                            .fill(Color.green.gradient)
                            .frame(height: 300)
                            .id(index)
                    }
                }
                .scrollTargetLayout()
            }
            .scrollPosition(id: $position)
        }
    }
    

####  Indicator flash

Another brand new view modifier related to the scrolling content is the
_scrollIndicatorsFlash_ view modifier. It allows us to show a scroll indicator
whenever needed. For example, you might need to fade in the scroll indicator
while appending the content in the _ScrollView_ .

    
    
    struct ContentView: View {
        @State private var trigger = false
        
        var body: some View {
            ScrollView {
                LazyVStack {
                    Button("Indicator flash") {
                        trigger.toggle()
                    }
                    
                    ForEach(0..<100) { index in
                        Rectangle()
                            .fill(Color.green.gradient)
                            .frame(height: 300)
                            .id(index)
                    }
                }
            }
            .scrollIndicatorsFlash(trigger: trigger)
        }
    }
    

As you can see, we use the _scrollIndicatorsFlash_ view modifier and pass some
equatable value. The _ScrollView_ blinks the indicator as soon as the passed
value changes. I hope you enjoy the post. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading, and see you next week!



# Building networking layer using functions

##  Building networking layer using functions

08 Jan 2020

This week I want to talk about building a networking layer in Swift using
_Functional programming_ . _Functional programming_ is a way of making
programs using _pure functions and function composition_ . Let’s see how we
can use it to build a flexible and composable network layer.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

Usually, Swift developers use the _Protocol-Oriented_ style of programming to
build any abstractions like the networking layer. In most of the cases,
protocols generate more boilerplate than needed. Let’s instead model our
networking layer using a pure function and function composition.

####  Pure functions

Pure functions calculate output using input and don’t affect or rely on any
state outside itself. It means pure function takes an argument to transform
and return a new value. Here is a very simple example of a pure function that
takes two arguments, sums them, and returns a new value.

    
    
    func add(_ a: Int, _ b: Int) -> Int {
        return a + b
    }
    

We know how to use pure functions. Let’s model our networking layer using a
function. Usually, we need a way of transforming URL request into raw data and
HTTP response.

    
    
    typealias Networking = (URLRequest) ->
        Result<(data: Data, response: URLResponse), Error>
    

Networking function is a function that accepts a request and returns an error
or response. We want to do our networking asynchronously, and we can achieve
it by using the _Combine_ framework. Let’s change our networking function
definition to use _Publisher_ instead of the Result type.

    
    
    typealias Networking = (URLRequest) ->
        AnyPublisher<(data: Data, response: URLResponse), Error>
    

You should be familiar with this type alias. _URLSession_ class has a similar
type for its _dataTaskPublisher_ method. We can create an extension for
_URLSession_ to create a new method that _“conforms”_ to our _Networking_
type.

    
    
    extension URLSession {
        func erasedDataTaskPublisher(
            for request: URLRequest
        ) -> AnyPublisher<(data: Data, response: URLResponse), Error> {
            dataTaskPublisher(for: request)
                .mapError { $0 }
                .eraseToAnyPublisher()
        }
    }
    

Now let’s see how we can inject our networking function into some service
layer objects which use the network to load and decode domain specific
objects.

    
    
    struct FeedService {
        let networking: Networking
    
        func fetchFeed() -> AnyPublisher<Feed, Error> {
            networking(.feed())
                .map { $0.data }
                .decode(type: Feed.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
        }
    }
    
    let feedService = FeedService(networking: URLSession.shared.erasedDataTaskPublisher)
    feedService.fetchFeed()
    

One of the benefits of this approach is the ability to replace our real-world
networking function with any mock implementation. Let’s see how we can do
that.

    
    
    func mockNetworking(
        data: Data = .init(),
        response: URLResponse = .init()
    ) -> Networking {
        return { _ in
            Just((data: data, response: response))
                .setFailureType(to: Error.self)
                .eraseToAnyPublisher()
        }
    }
    
    let mockedFeedService = FeedService(networking: mockNetworking())
    

In the example above, we use one of the powerful techniques from functional
programming called **partial function application** . Partial application
refers to the process of fixing a number of arguments to a function, producing
another function of smaller arity. In other words, we create a function that
returns another function that captures arguments and can use them in its own
body.

####  Function composition

Assume that you need to add an OAuth token header to every request that you
run, but you don’t want to pass it every time while creating a request.

We can use function composition to solve our problem. Function composition is
a way of generating new functions by chaining two or more other functions.

  1. We need a function that will modify our requests by adding OAuth token to the headers. 
  2. We need a new function that composes a header modifier function with our old networking function. 

    
    
    func tokenRequestModifier(_ token: String) -> (URLRequest) -> URLRequest {
        return { request in
            var request = request
            request.addValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
            return request
        }
    }
    

In the example above, we have _tokenRequestModifier_ function. Again, we use
partial application techniques to fix the token parameter and generate a new
request modifier function. Now we can compose it with our networking function
to create a brand new authorized networking function.

    
    
    func compose<A, B, C>(
        _ f: @escaping (A) -> B,
        _ g: @escaping (B) -> C
    ) -> (A) -> C {
        return { g(f($0)) }
    }
    
    let token = UserDefaults.standard.string(forKey: "token") ?? ""
    let authorizedNetworking = compose(
        tokenRequestModifier(token),
        networking
    )
    
    authorizedNetworking(.feed())
    

Here we compose two functions: _tokenRequestModifier_ and _networking_ to
create a brand new authorized networking function. Function composition allows
us to run _tokenRequestModifier_ before every networking request, which we run
via authorized networking function.

####  Conclusion

Today we talked about building a networking layer in a very functional way.
I’m not saying that protocols are bad or something similar. Protocols are
awesome when you need to build a huge hierarchy of types like collections that
we have in Swift standard library.

But usually, we have mocked and production implementation, and this is the
case where functions are more than enough. I hope you enjoy the post. Feel
free to follow me on [ Twitter ](https://twitter.com/mecid) and ask your
questions related to this post. Thanks for reading, and see you next week!



# Building forms with SwiftUI

##  Building forms with SwiftUI

19 Jun 2019

Today we are going to build a form styled layout with SwiftUI. I want to show
you a real-life example of the settings screen built with SwiftUI’s new form
view.

**Enhancing the Xcode Simulators.**  
Compare designs, show rulers, add a grid, quick actions for recent builds.
Create recordings with touches & audio, trim and export them into MP4 or GIF
and share them anywhere using drag & drop. Add bezels to screenshots and
videos. [ Try now ](https://gumroad.com/a/931293139/ftvbh)

I work on a sleep tracking app, which needs settings screen. Settings screen
should contain multiple toggles for enabling and disabling some features,
buttons for in-app purchases, and a picker for tuning sleep tracking
sensitivity level.

Let’s start building our settings screen. We will use _Text_ , _Toggle_ ,
_Stepper_ , _Picker_ , and _Button_ components. Here is the source code of our
_SettingsView_ .

    
    
    import SwiftUI
    
    struct SettingsView: View {
        @AppStorage("isNotificationsEnabled") 
        private var isNotificationEnabled = true
        
        @AppStorage("isSleepTrackingEnabled")
        private var isSleepTrackingEnabled = true
        
        @AppStorage("sleepTrackingMode")
        private var sleepTrackingMode = SleepTrackingMode.moderate.rawValue
        
        @AppStorage("sleepGoal")
        private var sleepGoal = 8
    
        var body: some View {
            NavigationView {
                Form {
                    Section(header: Text("Notifications settings")) {
                        Toggle(isOn: $isNotificationEnabled) {
                            Text("Notification:")
                        }
                    }
    
                    Section(header: Text("Sleep tracking settings")) {
                        Toggle(isOn: $isSleepTrackingEnabled) {
                            Text("Sleep tracking:")
                        }
    
                        Picker(
                            selection: $sleepTrackingMode,
                            label: Text("Sleep tracking mode")
                        ) {
                            ForEach(SleepTrackingMode.allCases, id: \.self) {
                                Text($0.rawValue).tag($0)
                            }
                        }
    
                        Stepper(value: $sleepGoal, in: 6...12) {
                            Text("Sleep goal is \(sleepGoal) hours")
                        }
                    }
                    
                    Section {
                        Button("Unlock PRO") {}
                        Button("Restore purchase") {}
                    }
                }
                .navigationBarTitle(Text("Settings"))
            }
        }
    }
    

As you can see we are wrapping our layout code inside the _Form_ component.
_Form_ component uses grouped _List_ to present every child inside the cell.
By wrapping layout inside the _Form_ , SwiftUI changes the visual appearance
for every element. You can simply replace the _Form_ with _VStack_ to check
the difference between them. Even _Picker_ looks different.

It also uses a separated screen with _List_ to show the items of _Picker_ . We
don’t need to do something, and we have this behavior out of the box. This is
where the real power of declarative programming is coming. Every component has
different adaptive appearances, which we can easily change by wrapping it into
another container. Here is the screenshot of the final result.

![Settings screen](/public/settings.jpg)

####  Styling

The SwiftUI framework provides us the _formStyle_ view modifier allowing to
set one of the three available styles: _automatic_ , _grouped_ and _columns_ .
The _grouped_ style uses a grouped list, _columns_ styles uses grid-based
layout similar to macOS forms, _automatic_ style uses default form style on
the current platform.

    
    
    struct CustomFormStyle: FormStyle {
        func makeBody(configuration: Configuration) -> some View {
            configuration.content
                .border(Color.red)
        }
    }
    
    extension FormStyle where Self == CustomFormStyle {
        static var custom: CustomFormStyle { .init() }
    }
    
    struct ContentView: View {
        var body: some View {
            Form {
                // content
            }
            .formStyle(.custom)
        }
    }
    

You can also create your own form style by creating a type conforming to the
_FormStyle_ protocol. The only requirement is the _makeBody_ function taking
an instance of _FormStyleConfiguration_ as the parameter. You can access the
content of the form by reading _content_ property on _FormStyleConfiguration_
type.

####  Conclusion

I enjoy how easy we can build apps with SwiftUI. You can use _Form_ component
for making complex form layouts with a lot of sections and choices for data
entry. I hope you love SwiftUI as much as me because I’m going to cover more
SwiftUI topics soon. Feel free to follow me on [ Twitter
](https://twitter.com/mecid) and ask your questions related to this post.
Thanks for reading and see you next week!



