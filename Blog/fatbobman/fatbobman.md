# 在 SwiftUI 视图中打开 URL 的若干方法

本文将介绍在 SwiftUI 视图中打开 URL 的若干种方式，其他的内容还包括如何自动识别文本中的内容并为其转换为可点击链接，以及如何自定义打开 URL
前后的行为等。

> 本文的范例代码是在 Swift Playgrounds 4.1 （ macOS 版本 ）中完成的，可在 [ 此处下载
> ](https://github.com/fatbobman/BlogCodes/tree/main/openURLinSwiftUI) 。了解更多有关
> Swift Playgrounds 的内容，可以参阅 [ Swift Playgrounds 4 娱乐还是生产力
> ](/zh/posts/swiftplaygrounds4/) 一文。

![image-20220520182722773](https://cdn.fatbobman.com/image-20220520182722773.png)

## SwiftUI 1.0（ iOS 13、Catalina ）

在视图中，开发者通常需要处理两种不同的打开 URL 的情况：

- 点击一个按钮（ 或类似的部件 ）打开指定的 URL
- 将文本中的部分内容变成可点击区域，点击后打开指定的 URL

遗憾的是，1.0 时代的 SwiftUI 还相当稚嫩，没有提供任何原生的方法来应对上述两种场景。

对于第一种场景，常见的做法为：

    // iOS
    Button("Wikipedia"){
        UIApplication.shared.open(URL(string:"https://www.wikipedia.org")!)
    }

    // macOS
    Button("Wikipedia"){
        NSWorkspace.shared.open(URL(string:"https://www.wikipedia.org")!)
    }

而第二种场景实现起来就相当地麻烦，需要包装 UITextView（ 或 UILabel ）并配合 NSAttributedString 一起来完成，此时
SwiftUI 仅被当作一个布局工具而已。

## SwiftUI 2.0（ iOS 14、Big sur ）

SwiftUI 2.0 为第一个场景提供了相当完美的原生方案，但仍无法通过原生的方式来处理第二种场景。

### openURL

openURL 是 SwiftUI 2.0 中新增的一个环境值（ EnvironmentValue ），它有两个作用：

- 通过调用它的 callFunction 方法，实现打开 URL 的动作

此时在 Button 中，我们可以直接通过 openURL 来完成在 SwiftUI 1.0 版本中通过调用其他框架 API 才能完成的工作。

    struct Demo: View {
        @Environment(\.openURL) private var openURL // 引入环境值

        var body: some View {
            Button {
                if let url = URL(string: "https://www.example.com") {
                    openURL(url) { accepted in  //  通过设置 completion 闭包，可以检查是否已完成 URL 的开启。状态由 OpenURLAction 提供
                        print(accepted ? "Success" : "Failure")
                    }
                }
            } label: {
                Label("Get Help", systemImage: "person.fill.questionmark")
            }
        }
    }

- 通过提供 OpenURLAction ，自定义通过 openURL 打开链接的行为（后文中详细说明）

### Link

SwiftUI 2.0 提供了一个结合 Button 和 openURL 的 Link 控件，帮助开发者进一步简化代码：

    Link(destination: URL(string: "mailto://feedback@fatbobman.com")!, label: {
        Image(systemName: "envelope.fill")
        Text("发邮件")
    })

## SwiftUI 3.0（ iOS 15、Monterey ）

3.0 时代，随着 Text 功能的增强和 AttributedString 的出现，SwiftUI 终于补上了另一个短板 ——
将文本中的部分内容变成可点击区域，点击后打开指定的 URL。

### Text 用例 1 ：自动识别 LocalizedStringKey 中的 URL

通过支持 LocalizedStringKey 的构造方法创建的 Text ，会自动识别文本中的 **网址** （
开发者无须做任何设定），点击后会打开对应的 URL 。

    Text("www.wikipedia.org 13900000000 feedback@fatbobman.com") // 默认使用参数类型为 LocalizedStringKey 的构造器

![image-20220520141225595](https://cdn.fatbobman.com/image-20220520141225595.png)

此种方法只能识别网络地址（ 网页地址、邮件地址等 ），因此代码中的电话号码无法自动识别。

请注意，下面的代码使用的是参数类型为 String 的构造器，因此 Text 将无法自动识别内容中的 URL ：

    let text = "www.wikipedia.org 13900000000 feedback@fatbobman.com" // 类型为 String
    Text(text) // 参数类型为 String 的构造器不支持自动识别

### Text 用例 2 ：识别 Markdown 语法中的 URL 标记

SwiftUI 3.0 的 Text ，当内容类型为 LocalizedStringKey 时，Text 可以对部分 Markdown 语法标记进行解析 ：

    Text("[Wikipedia](https://www.wikipedia.org) ~~Hi~~ [13900000000](tel://13900000000)")

在这种方式下，我们可以使用任何种类的 URI （不限于网络），比如代码中的拨打电话。

![image-20220522085352243](https://cdn.fatbobman.com/image-20220522085352243.png)

### Text 用例 3 ：包含 link 信息的 AttributedString

在 WWDC 2021 上，苹果推出了 NSAttributedString 的值类型版本 AttributedString，并且可以直接使用在 Text
中。通过在 AttributedString 中为不同位置的文字设置不同的属性，从而实现在 Text 中打开 URL 的功能。

    let attributedString:AttributedString = {
        var fatbobman = AttributedString("肘子的 Swift 记事本")
        fatbobman.link = URL(string: "https://fatbobman.com")!
        fatbobman.font = .title
        fatbobman.foregroundColor = .green // link 不为 nil 的 Run，将自动屏蔽自定义的前景色和下划线
        var tel = AttributedString("电话号码")
        tel.link = URL(string:"tel://13900000000")
        tel.backgroundColor = .yellow
        var and = AttributedString(" and ")
        and.foregroundColor = .red
        return fatbobman + and + tel
    }()

    Text(attributedString)

![image-20220520144103395](https://cdn.fatbobman.com/image-20220520144103395.png)

> 更多有关 AttributedString 的内容，请参阅 [ AttributedString——不仅仅让文字更漂亮
> ](/zh/posts/attributedstring/)

### Text 用例 4 ：识别字符串中的 URL 信息，并转换成 AttributedString

上述 3 个用例中，除了 **用例 1** 可以自动识别文字中的网络地址外，其他两个用例都需要开发者通过某种方式显式添加 URL 信息。

开发者可以通过使用 NSDataDetector + AttributedString 的组合，从而实现类似系统信息、邮件、微信 app
那样，对文字中的不同类型的内容进行自动识别，并设置对应的 URL。

[ NSDataDetector
](https://developer.apple.com/documentation/foundation/nsdatadetector) 是
NSRegularExpression
的子类，它可以检测自然语言文本中的半结构化信息，如日期、地址、链接、电话号码、交通信息等内容，它被广泛应用于苹果提供的各种系统应用中。

    let text = "https://www.wikipedia.org 13900000000 feedback@fatbobman.com"
    // 设定需要识别的类型
    let types = NSTextCheckingResult.CheckingType.link.rawValue | NSTextCheckingResult.CheckingType.phoneNumber.rawValue
    // 创建识别器
    let detector = try! NSDataDetector(types: types)
    // 获取识别结果
    let matches = detector.matches(in: text, options: [], range: NSRange(location: 0, length: text.count))
    // 逐个处理检查结果
    for match in matches {
        if match.resultType == .date {
            ...
        }
    }

> 你可以将 NSDataDetector 视为拥有极高复杂度的正则表达式封装套件。

完整的代码如下：

    extension String {
        func toDetectedAttributedString() -> AttributedString {

            var attributedString = AttributedString(self)

            let types = NSTextCheckingResult.CheckingType.link.rawValue | NSTextCheckingResult.CheckingType.phoneNumber.rawValue

            guard let detector = try? NSDataDetector(types: types) else {
                return attributedString
            }

            let matches = detector.matches(in: self, options: [], range: NSRange(location: 0, length: count))

            for match in matches {
                let range = match.range
                let startIndex = attributedString.index(attributedString.startIndex, offsetByCharacters: range.lowerBound)
                let endIndex = attributedString.index(startIndex, offsetByCharacters: range.length)
                // 为 link 设置 url
                if match.resultType == .link, let url = match.url {
                    attributedString[startIndex..<endIndex].link = url
                    // 如果是邮件，设置背景色
                    if url.scheme == "mailto" {
                    attributedString[startIndex..<endIndex].backgroundColor = .red.opacity(0.3)
                    }
                }
                // 为 电话号码 设置 url
                if match.resultType == .phoneNumber, let phoneNumber = match.phoneNumber {
                    let url = URL(string: "tel:\(phoneNumber)")
                    attributedString[startIndex..<endIndex].link = url
                }
            }
            return attributedString
        }
    }

    Text("https://www.wikipedia.org 13900000000 feedback@fatbobman.com".toDetectedAttributedString())

![image-20220520150754052](https://cdn.fatbobman.com/image-20220520150754052.png)

## 自定义 Text 中链接的颜色

遗憾的是，即使我们已经为 AttributedString 设置了前景色，但当某段文字的 link 属性非 nil 时，Text
将自动忽略它的前景色和下划线设定，使用系统默认的 link 渲染设定来显示。

目前可以通过设置着色来改变 Text 中全部的 link 颜色：

    Text("www.wikipedia.org 13900000000 feedback@fatbobman.com")
        .tint(.green)

    Link("Wikipedia", destination: URL(string: "https://www.wikipedia.org")!)
        .tint(.pink)

![image-20220520151737202](https://cdn.fatbobman.com/image-20220520151737202.png)

相较 Text 中链接的固定样式，可以用 Button 或 Link 创建可以自由定制外观的链接按钮：

    Button(action: {
        openURL(URL(string: "https://www.wikipedia.org")!)
    }, label: {
        Circle().fill(.angularGradient(.init(colors: [.red,.orange,.pink]), center: .center, startAngle: .degrees(0), endAngle: .degrees(360)))
    })

![image-20220520164125700](https://cdn.fatbobman.com/image-20220520164125700.png)

## 自定义 openURL 的行为

在 Button 中，我们可以通过在闭包中添加逻辑代码，自定义开启 URL 之前与之后的行为。

    Button("打开网页") {
                if let url = URL(string: "https://www.example.com") {
                    // 开启 URL 前的行为
                    print(url)
                    openURL(url) { accepted in  //  通过设置 completion 闭包，定义点击 URL 后的行为
                        print(accepted ? "Open success" : "Open failure")
                    }
                }
    }

但在 Link 和 Text 中，我们则需要通过为环境值 openURL 提供 OpenURLAction 处理代码的方式来实现自定义打开链接的行为。

    Text("Visit [Example Company](https://www.example.com) for details.")
        .environment(\.openURL, OpenURLAction { url in
            handleURL(url)
            return .handled
        })

OpenURLAction 的结构如下：

    public struct OpenURLAction {
        @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
        public init(handler: @escaping (URL) -> OpenURLAction.Result)

        public struct Result {
            public static let handled: OpenURLAction.Result  // 当前的代码已处理该 URL ，调用行为不会再向下传递
            public static let discarded: OpenURLAction.Result  // 当前的处理代码将丢弃该 URL ，调用行为不会再向下传递
            public static let systemAction: OpenURLAction.Result  // 当前代码不处理，调用行为向下传递（ 如果外层没有用户的自定义 OpenURLAction ，则使用系统默认的实现）
            public static func systemAction(_ url: URL) -> OpenURLAction.Result  // 当前代码不处理，将新的 URL 向下传递（ 如果外层没有用户的自定义 OpenURLAction ，则使用系统默认的实现）
        }
    }

比如：

    Text("fatbobman.com feedback@fatbobman.com 13900000000".toDetectedAttributedString()) // 创建三个链接 https mailto tel
        .environment(\.openURL, OpenURLAction { url in
            switch url.scheme {
            case "mailto":
                return .discarded // 邮件将直接丢弃，不处理
            default:
                return .systemAction // 其他类型的 URI 传递到下一层（外层）
            }
        })
        .environment(\.openURL, OpenURLAction { url in
            switch url.scheme {
            case "tel":
                print("call number \(url.absoluteString)") // 打印电话号码
                return .handled  // 告知已经处理完毕，将不会继续传递到下一层
            default:
                return .systemAction // 其他类型的 URI 当前代码不处理，直接传递到下一层
            }
        })
        .environment(\.openURL, OpenURLAction { _ in
            .systemAction(URL(string: "https://www.apple.com")!) // 由于在本层之后我们没有继续设定 OpenURLAction , 因此最终会调用系统的实现打开苹果官网
        })

这种通过环境值层层设定的处理方式，给了开发者非常大的自由度。在 SwiftUI 中，采用类似逻辑的还有 onSubmit ，有关 onSubmit
的信息，请参阅 [ SwiftUI TextField 进阶 —— 事件、焦点、键盘 ](/zh/posts/textfield-event-focus-
keyboard/) 。

handler 的返回结果 `handled` 和 `discarded` 都将阻止 url 继续向下传递，它们之间的不同只有在显式调用
openURL 时才会表现出来。

    // callAsFunction 的定义
    public struct OpenURLAction {
      public func callAsFunction(_ url: URL, completion: @escaping (_ accepted: Bool) -> Void)
    }

    // handled 时  accepted 为 true ， discarded 时 accepted 为 false
    openURL(url) { accepted in
          print(accepted ? "Success" : "Failure")
    }

结合上面的介绍，下面的代码将实现：在点击链接后，用户可以选择是打开链接还是将链接复制在粘贴板上：

    struct ContentView: View {
        @Environment(\.openURL) var openURL
        @State var url:URL?
        var show:Binding<Bool>{
            Binding<Bool>(get: { url != nil }, set: {_ in url = nil})
        }

        let attributedString:AttributedString = {
            var fatbobman = AttributedString("肘子的 Swift 记事本")
            fatbobman.link = URL(string: "https://fatbobman.com")!
            fatbobman.font = .title
            var tel = AttributedString("电话号码")
            tel.link = URL(string:"tel://13900000000")
            tel.backgroundColor = .yellow
            var and = AttributedString(" and ")
            and.foregroundColor = .red
            return fatbobman + and + tel
        }()

        var body: some View {
            Form {
                Section("NSDataDetector + AttributedString"){
                    // 使用 NSDataDetector 进行转换
                    Text("https://fatbobman.com 13900000000 feedback@fatbobman.com".toDetectedAttributedString())
                }
            }
            .environment(\.openURL, .init(handler: { url in
                switch url.scheme {
                case "tel","http","https","mailto":
                    self.url = url
                    return .handled
                default:
                    return .systemAction
                }
            }))
            .confirmationDialog("", isPresented: show){
                if let url = url {
                    Button("复制到剪贴板"){
                        let str:String
                        switch url.scheme {
                        case "tel":
                            str = url.absoluteString.replacingOccurrences(of: "tel://", with: "")
                        default:
                            str = url.absoluteString
                        }
                        UIPasteboard.general.string = str
                    }
                    Button("打开 URL"){openURL(url)}
                }
            }
            .tint(.cyan)
        }
    }

![openURL_Demo_Recording_iPhone_13_mini_2022-05-20_18.00.15.2022-05-20
18_03_18](https://cdn.fatbobman.com/openURL_Demo_Recording_iPhone_13_mini_2022-05-20_18.00.15.2022-05-20%2018_03_18.gif)

## 总结

虽说本文的主要目的是介绍在 SwiftUI 视图中打开 URL 的几种方法，不过读者应该也能从中感受到 SwiftUI 三年来的不断进步，相信不久后的
WWDC 2022 会为开发者带来更多的惊喜。

# 在 SwiftUI 中使用 UIKit 视图

已迈入第三个年头的 SwiftUI 相较诞生初始已经提供了更多的原生功能，但仍有大量的事情是无法直接通过原生 SwiftUI
代码来完成的。在相当长的时间中开发者仍需在 SwiftUI 中依赖 UIKit（AppKit）代码。好在，SwiftUI 为开发者提供了便捷的方式将
UIKit（AppKit）视图（或控制器）包装成 SwiftUI 视图。

本文将通过对 UITextField 的包装来讲解以下几点：

- 如何在 SwiftUI 中使用 UIKit 视图
- 如何让你的 UIKit 包装视图具有 SwiftUI 风格
- 在 SwiftUI 使用 UIKit 视图需要注意的地方

> **如果你已经对如何使用`UIViewRepresentable` 有所掌握，可以直接从 `SwiftUI 风格化` 部分阅读 **

## 基础

在具体演示包装代码之前，我们先介绍一些与在 SwiftUI 中使用 UIKit 视图有关的基础知识。

> 无需担心是否能立即理解下述内容，在后续的演示中会有更多的内容帮助你掌握相关知识。

### 生命周期

SwiftUI 同 UIKit 和 AppKit 的主要区别之一是，SwiftUI 的视图（View）是值类型，并不是对屏幕上绘制内容的具体引用。在
SwiftUI 中，开发者为视图创建描述，而并不实际渲染它们。

在 UIKit（或 AppKit）中，视图（或视图控制器）有明确的生命周期节点，比如 `vidwDidload` 、 `loadView` 、 `viewWillAppear` 、 `didAddSubView` 、 `didMoveToSuperview`
等方法，它们本质上充当了钩子的角色，让开发者能够通过执行一段逻辑来响应系统给定的事件。

SwiftUI 的视图，本身没有清晰（可适当描述）的生命周期，它们是值、是声明。SwiftUI 提供了几个修改器（modifier）来实现类似 UIKit
中钩子方法的行为。比如 `onAppear` 同 `viewWillAppear` 的表现很类似。同 UIKit 的钩子方法的位置有很大的不同， `onAppear` 和 `onDisappear` 是在当前视图的父视图上声明的。

将 UIKit 视图包装成 SwiftUI 的视图时，我们需要了解两者生命周期之间的不同，不要强行试图找到完全对应的方法，要从 SwiftUI
的角度来思考如何调用 UIKit 视图。

### UIViewRepresentable 协议

在 SwiftUI 中包装 UIView 非常简单，只需要创建一个遵守 `UIViewRepresentable` 协议的结构体就行了。

> `UIViewControllerRepresentable` 对应 `UIViewController` ， `NSViewRepresentable` 对应 `NSView` ， `NSViewControllerRepresentable` 对应 `NSViewController` 。内部的结构和实现逻辑都一致。

`UIViewrepresentable` 的协议并不复杂，只包含： `makeUIView` 、 `updateUIView` 、 `dismantleUIView` 和 `makeCoordinator` 四个方法。 `makeUIView` 和 `updateUIView` 为必须提供实现的方法。

`UIViewRepresentable` 本身遵守 `View` 协议，因此 SwiftUI 会将任何符合该协议的结构体都当作一般的
SwiftUI 视图来对待。不过由于 `UIViewRepresentable` 的特殊的用途，其内部的生命周期又同标准的 SwiftUI
视图有所不同。

![UIViewRepresentableLifeCycle](https://cdn.fatbobman.com/UIViewRepresentableLifeCycle-9614888.png)

- makeCoordinator

如果我们声明了 Coordinator（协调器）, `UIViewRepresentable`
视图会在初始化后首先创建它的实例，以便在其他的方法中调用。Coordinator 默认为 `Void` ，该方法在 `UIViewRepresentable` 的生命周期中只会调用一次，因此只会创建一个协调器实例。

- makeUIView

创建一个用来包装的 UIKit 视图实例。该方法在 `UIViewRepresentable` 的生命周期中只会调用一次。

- updateUIView

SwiftUI 会在应用程序的状态（State）发生变化时更新受这些变化影响的界面部分。当 `UIViewRepresentable`
视图中的注入依赖发生变化时，SwiftUI 会调用 `updateUIView` 。其调用时机同标准 SwiftUI 视图的 `body`
一致，最大的不同为，调用 `body` 为计算值，而调用 `updateview` 仅为通知 `UIViewRepresentable`
视图依赖有变化，至于是否需要根据这些变化来做反应，则由开发者来自行处理。

该方法在 `UIViewRepresentable`
的生命周期中会多次调用，直到视图被移出视图树（更准确地描述是切换到另一个不包含该视图的视图树分支）。

**在 makeUIVIew 执行后，updateUIVew 必然会执行一次**

- dismantleUIView

在 `UIViewRepresentable` 视图被移出视图树之前，SwiftUI 会调用 `dismantleUIView`
，通常在此方法中可以执行 u 删除观察器等善后操作。 `dismantleUIView` 为类型方法。

下面的代码将创建一个同 ProgressView 一样的转圈菊花：

    struct MyProgrssView: UIViewRepresentable {
        func makeUIView(context: Context) -> UIActivityIndicatorView {
            let view = UIActivityIndicatorView()
            view.startAnimating()
            return view
        }

        func updateUIView(_ uiView: UIActivityIndicatorView, context: Context) {}
    }

    struct Demo: View {
        var body: some View {
                MyProgrssView()
        }
    }

### 黑匣子

SwiftUI 在绘制屏幕时，会从视图树的顶端开始对视图的 `body` 求值，如果其中还包含子视图则将递归求值，直到获得最终的结果。但 SwiftUI
无法真正进行无限量的调用来绘制视图，因此它必须以某种方式缩短递归。为了结束递归，SwiftUI 包含了很多的原始类型（primitive types）。当
SwiftUI 递归到这些原始类型时，将结束递归，它将不再关心原始类型的 `body` ，而让原始类型自行对其管理的区域进行处理。

SwiftUI 框架通过将 `body` 定义为 `Never` 来标记该 `View` 为原始类型。 `UIViewRepresentable` 恰巧也为其中之一（ `Text` 、 `ZStack` 、 `Color` 、 `List`
等也都是所谓的原始类型）。

    public protocol UIViewRepresentable : View where Self.Body == Never

事实上几乎所有的原始类型都是对 UIKit 或 AppKit 的底层包装。

`UIViewRepresentable` 作为原始类型，SwiftUI 对其内部所知甚少（因为无需关心）。通常需要开发者在 `UIViewRepresentable` 视图的 Coordinator（协调器）中做一些的工作，从而保证两个框架（SwiftUI 同
UIKit）代码之间的沟通和联系。

### 协调器

苹果框架很喜欢使用协调器（Coordinator）这个名词，UIKit 开发中有协调器设计模式、Core Data 中有持久化存储协调器。在 `UIViewRepresentable` 中协调器同它们的概念完全不同，主要起到以下几个方面的作用：

- 实现 UIKit 视图的代理

UIKit 组件通常依赖代理（delegate）来实现一些功能，“代理”是响应其他地方发生的事件的对象。例如，UIKit 中我们将一个代理对象附加到 `Text field` 视图上，当用户输入时，当用户按下 `return` 键时，该代理对象中对应的方法将被调用。通过将协调器声明为 UIKit
视图对应的代理对象，我们就可以在其中实现所需的代理方法。

- 同 SwiftUI 框架保持沟通

上文中，我们提到 `UIViewRepresentable` 作为原始类型，需要主动承担更多的同 SwiftUI
框架或其他视图之间的沟通工作。在协调器中，我们可以通过双向绑定（ `Binding` ），通知中心（ `notificationCenter`
）或其他例如 `Redux` 模式的单项数据流等方式，将 UIKit 视图内部的状态报告给 SwiftUI
框架或其他需要的模块。同样也可以通过注册观察器、订阅 Publisher 等方式获取所需的信息。

- 处理 UIKit 视图中的复杂逻辑

在 UIKit 开发中，通常会将业务逻辑放置在 UIViewController 中，SwiftUI 没有 Controller
这个概念，视图仅是状态的呈现。对于一些实现复杂功能的 UIKit 模组，如果完全按照 SwiftUI
的模式将其业务逻辑彻底剥离是非常困难的。因此将无法剥离的业务逻辑的实现代码放入协调器中，靠近代理方法，便于相互之间的协调和管理。

## 包装 UITextField

本节中我们将利用上面的知识实现一个具有简单功能的 `UITextField` 包装视图—— `TextFieldWrapper` 。

### 版本 1.0

在第一个版本中，我们要实现一个类似如下原生代码的功能：

    TextField("name:",text:$name)

![image-20210822184949860](https://cdn.fatbobman.com/image-20210822184949860-9629391.png)

查看 [ 源代码 ](https://gist.github.com/733f3c8ef4c69a1e4ed4bd81bf4750e3.git)

我们在 `makeUIView` 中创建了 `UITextField` 的实例，并对其 placeholder 和 text
进行了设定。在右侧的预览中，我们可以看到 placeholder 可以正常显示，如果你在其中输入文字，表现的状态也同 `TextField` 完全一致。

通过 `.border` ，我们看到 TextFieldWrapper 的视图尺寸没有符合预期，这是由于 UITextField
在不进行约束的情况下会默认占据全部可用空间。上文关于 `UIActivityIndicatorView` 的演示代码并没有出现这个情况。因此对于不同的
UIKit 组件，我们需要了解其默认设置，酌情对其进行约束设定。

在 `makeUIView` 中添加如下语句，此时文本输入框的尺寸就和预期一致了：

            textfield.setContentHuggingPriority(.defaultHigh, for: .vertical)
            textfield.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)

稍微调整一下 `Demo` 视图，在 `.padding()` 下添加 `Text("name:\(name)")` 。如果按照 `TextField` 的正常行为，当我们在其中输入任何文本时，下方的 `Text`
中应该显示出对应的内容，不过在我们当前的代码版本中，并没有表现出预期的行为。

![image-20210822190605447](https://cdn.fatbobman.com/image-20210822190605447-9630366.png)

让我们再次来分析一下代码。

尽管我们声明了一个 `Binding<String>` 类型的 `text` ，并且在 `makeUIView` 中将其赋值给了 `textfield` ，不过 `UITextField` 并不会将我们录入的内容自动回传给 `Binding<String>` 的 `text` ，这导致 `Demo` 视图中的 `name` 并不会因为文字录入而发生改变。

`UITextfield` 在每次录入文字时，都会自动调用 `func textField(_ textField: UITextField,
shouldChangeCharactersIn range: NSRange, replacementString string: String) ->
Bool` 的代理方法。因此我们需要创建协调器，并在协调器中实现该方法，将录入的内容传递给 `Demo` 视图中的 `name` 变量。

创建协调器：

    extension TextFieldWrapper{
        class Coordinator:NSObject,UITextFieldDelegate{
            @Binding var text:String
            init(text:Binding<String>){
                self._text = text
            }

            func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
                if let text = textField.text as NSString? {
                    let finaltext = text.replacingCharacters(in: range, with: string)
                    self.text = finaltext as String
                }
                return true
            }
        }
    }

我们需要在 `textField` 方法中回传数据，因此在 `Coordinator` 中同样需要使用到 `Binding<String>`
，如此对 `text` 的操作即为对 `Demo` 视图中 `name` 的操作。

如果 `UIViewRepresentable` 视图中的 `Coordinator` 不为 `Void` ，则必须通过 `makeCoordinator` 来创建它的实例。在 `TextFieldWrapper` 中添加如下代码：

        func makeCoordinator() -> Coordinator {
            .init(text: $text)
        }

最后在 `makeUIView` 中添加：

        textfield.delegate = context.coordinator

UITextField 在发生特定事件后将在协调器中查找并调用对应的代理方法。

![image-20210822191834883](https://cdn.fatbobman.com/image-20210822191834883-9631115.png)

查看 [ 源代码 ](https://gist.github.com/cb34b4f96525ac49193a36cd1d5fc135.git)

至此，我们创建的 `UITextField` 包装已经同原生的 `TextField` 的表现行为一致了。

**你确定？**

再度修改一下 `Demo` 视图，将其修改为：

    struct Demo: View {
        @State var name: String = ""
        var body: some View {
            VStack {
                TextFieldWrapper("name:", text: $name)
                    .border(.blue)
                    .padding()
                Text("name:\(name)")
                Button("Random Name"){
                    name = String(Int.random(in: 0...100))
                }
            }
        }
    }

按照对原生 `TextField` 的表现预期，当我们按下 `Random Name` 按钮时， `Text` 同 `TextFieldWrapper` 中的文字都应该变成由 `String(Int.random(in: 0...100))`
产生的随机数字，但是如果你使用上述代码进行测试， `TextFieldWrapper` 中的文字并没有变化。

在 `makeUIView` 中，我们使用 `textfield.text = text` 获取了 `Demo` 视图中 `name`
的值，但 `makeUIView` 只会执行一次。当点击 `Random Name` 引起 `name` 变化时，SwiftUI 将会调用 `updateUIView` ，而我们并没有在其中做任何的处理。只需要在 `updateUIVIew` 中添加如下代码即可：

        func updateUIView(_ uiView: UIViewType, context: Context) {
            DispatchQueue.main.async {
                uiView.text = text
            }
        }

> `makeUIView` 方法的参数中有一个 `context: Context` ，通过这个上下文，我们可以访问到 `Coordinator` （自定义协调器）、 `transaction` （如何处理状态更新，动画模式）以及 `environment`
> （当前视图的环境值集合）。我们之后将通过实例演示其用法。该 `context` 同样可以在 `updateUIVIew` 和 `dismantleUIView` 中访问。 `updataUIView` 的参数 `_ uiView:UIViewType` 为我们在 `makeUIVIew` 中创建的 UIKit 视图实例。

查看 [ 源代码 ](https://gist.github.com/69fb1ff4462192ed318048166aeb9eaf.git)

现在，我们的 `TextFieldWrapper` 的表现已经确实同 `TextField` 一致了。

![textFieldWrappertest](https://cdn.fatbobman.com/textFieldWrappertest-9634034.gif)

### 版本 2.0——添加设定

在第一个版本的基础上，我们将为 `TextFieldWrapper` 添加 `color` 、 `font` 、 `clearButtonMode` 、 `onCommit` 以及 `onEditingChanged` 的配置设定。

> 考虑到尽量不将例程复杂化，我们使用 `UIColor` 、 `UIFont` 作为配置类型。将 SwiftUI 的 `Color` 和 `Font` 转换成 UIKit 版本将增加不小的代码量。

`color` 、 `font` 以及我们新增加的 `clearButtonMode` 并不需要双向数据流，因此无需采用 `Binding`
方式，仅需在 `updateView` 中及时响应它们的变化既可。

`onCommit` 和 `onEditingChanged` 分别对应着 UITextField 代理的 `textFieldShouldReturn` 、 `textFieldDidBeginEditing` 以及 `textFieldDidEndEditing` 方法，我们需要在协调器中分别实现这些方法，并调用对应的 `Block` 。

首先修改协调器：

    extension TextFieldWrapper {
        class Coordinator: NSObject, UITextFieldDelegate {
            @Binding var text: String
            var onCommit: () -> Void
            var onEditingChanged: (Bool) -> Void
            init(text: Binding<String>,
                 onCommit: @escaping () -> Void,
                 onEditingChanged: @escaping (Bool) -> Void) {
                self._text = text
                self.onCommit = onCommit
                self.onEditingChanged = onEditingChanged
            }

            func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
                if let text = textField.text as NSString? {
                    let finaltext = text.replacingCharacters(in: range, with: string)
                    self.text = finaltext as String
                }
                return true
            }

            func textFieldShouldReturn(_ textField: UITextField) -> Bool {
                onCommit()
                return true
            }

            func textFieldDidBeginEditing(_ textField: UITextField) {
                onEditingChanged(true)
            }

            func textFieldDidEndEditing(_ textField: UITextField, reason: UITextField.DidEndEditingReason) {
                onEditingChanged(false)
            }

        }
    }

对 `TextFieldWrapper` 进行修改：

    struct TextFieldWrapper: UIViewRepresentable {
        init(_ placeholder: String,
             text: Binding<String>,
             color: UIColor = .label,
             font: UIFont = .preferredFont(forTextStyle: .body),
             clearButtonMode:UITextField.ViewMode = .whileEditing,
             onCommit: @escaping () -> Void = {},
             onEditingChanged: @escaping (Bool) -> Void = { _ in }
        )
        {
            self.placeholder = placeholder
            self._text = text
            self.color = color
            self.font = font
            self.clearButtonMode = clearButtonMode
            self.onCommit = onCommit
            self.onEditingChanged = onEditingChanged
        }

        let placeholder: String
        @Binding var text: String
        let color: UIColor
        let font: UIFont
        let clearButtonMode: UITextField.ViewMode
        var onCommit: () -> Void
        var onEditingChanged: (Bool) -> Void

        typealias UIViewType = UITextField
        func makeUIView(context: Context) -> UIViewType {
            let textfield = UITextField()
            textfield.setContentHuggingPriority(.defaultHigh, for: .vertical)
            textfield.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)
            textfield.placeholder = placeholder
            textfield.delegate = context.coordinator
            return textfield
        }

        func updateUIView(_ uiView: UIViewType, context: Context) {
            DispatchQueue.main.async {
                uiView.text = text
                uiView.textColor = color
                uiView.font = font
                uiView.clearButtonMode = clearButtonMode
            }
        }

        func makeCoordinator() -> Coordinator {
            .init(text: $text,onCommit: onCommit,onEditingChanged: onEditingChanged)
        }
    }

修改 `Demo` 视图：

    struct Demo: View {
        @State var name: String = ""
        @State var color: UIColor = .red
        var body: some View {
            VStack {
                TextFieldWrapper("name:",
                                 text: $name,
                                 color: color,
                                 font: .preferredFont(forTextStyle: .title1),
                                 clearButtonMode: .whileEditing,
                                 onCommit: { print("return") },
                                 onEditingChanged: { editing in print("isEditing \(editing)") })
                    .border(.blue)
                    .padding()
                Text("name:\(name)")
                Button("Random Name") {
                    name = String(Int.random(in: 0...100))
                }
                Button("Change Color") {
                    color = color == .red ? .label : .red
                }
            }
        }
    }

    struct TextFieldWrapperPreview: PreviewProvider {
        static var previews: some View {
            Demo()
        }
    }

查看 [ 源代码 ](https://gist.github.com/5604d7bee11a44c2cbdcba12cfe1eda0.git)

![textfieldwrapperdemo2](https://cdn.fatbobman.com/textfieldwrapperdemo2-9639150-9639151.gif)

## SwiftUI 风格化

我们不仅实现了对字体、色彩的设定，而且增加了原生 `TextField` 没有的 `clearButtonMode`
设置。按照上述的方法，可以逐步为其添加更多的设置，让 `TextFieldWrapper` 获得更多的功能。

**代码好像有点不太对劲？！**

随着功能配置的增加，上面代码在使用中会愈发的不方便。如何实现类似原生 `TextFiled` 的链式调用呢？譬如：

            TextFieldWrapper("name:",text:$name)
                .clearMode(.whileEditing)
                .onCommit{print("commit")}
                .foregroundColor(.red)
                .font(.title)
                .disabled(allowEdit)

本节中，我们将重写配置代码，实现 UIKit 包装风格 SwiftUI 化。

> 本节以版本 1.0 结束时的代码为基础。

所谓的 SwfitUI 风格化，更确切地说应该是函数式编程的链式调用。将多个操作通过点号（.）链接在一起，增加可读性。作为将函数视为一等公民的
Swift，实现上述的链式调用非常方便。不过有以下几点需要注意：

- 如何改变 View 内的的值（View 是结构）
- 如何处理返回的类型（保证调用链继续有效）
- 如何利用 SwiftUI 框架现有的数据并与之交互逻辑

> 为了更全面的演示，下面的例子，采用了不同的处理方式。在实际使用中，可根据实际需求选择适当的方案。

### foregroundColor

我们在 SwiftUI 中经常会用到 `foregroundColor` 来设置前景色，比如下面的代码：

                VStack{
                    Text("hello world")
                        .foregroundColor(.red)
                }
                .foregroundColor(.blue)

不知道大家是否知道上面的两个 `foregroundColor` 有什么不同。

    extension Text{
        public func foregroundColor(_ color: Color?) -> Text
    }

    extension View{
        public func foregroundColor(_ color: Color?) -> some View
    }

方法名一样，但作用的对象不同。 `Text` 只有在针对本身的 `foregroundColor` 没有设置的时候，才会尝试从当前环境中获取 `foregroundColor` （针对 View）的设定。原生的 `TextFiled` 没有针对本身的 `foregroundColor`
，不过我们目前也没有办法获取到 SwiftUI 针对 View 的 `foregroundColor` 设定的环境值（估计是），因此我们可以使用 `Text` 的方式，为 `TextFieldWrapper` 创建一个专属的 `foregroundColor` 。

为 `TextFieldWrapper` 添加一个变量

    private var color:UIColor = .label

在 `updateUIView` 中增加

    uiView.textColor = color

设置配置方法：

    extension TextFieldWrapper {
        func foregroundColor(_ color:UIColor) -> Self{
            var view = self
            view.color = color
            return view
        }
    }

查看 [ 源代码 ](https://gist.github.com/56f426b29a551c6490062f6daf3e342a.git)

就这么简单。现在我们就可以使用 `.foreground(.red)` 来设置 `TextFieldWrapper` 的文字颜色了。

这种写法是为特定视图类型添加扩展的常用写法。有以下两个优点：

- 使用 `private` ，无需暴露配置变量
- 仍返回特定类型的视图，有利于维持链式稳定

我们几乎可以使用这种方式完成全部的链式扩展。如果扩展较多时，可以采用下面的方式，进一步清晰、简化代码：

        extension View {
            func then(_ body: (inout Self) -> Void) -> Self {
                var result = self
                body(&result)
                return result
            }
        }

        func foregroundColor(_ color:UIColor) -> Self{
            then{
                $0.color = color
            }
        }

### disabled

SwiftUI 针对 View 预设了非常多的扩展，其中有相当的部分都是通过环境值 `EnvironmentValue`
来逐级传递的。通过直接响应该环境值的变化，我们可以在不编写特定 `TextFieldWrapper` 扩展的情况下，即可为其增加配置功能。

例如， `View` 有一个扩展 `.disabled` ，通常我们会用它来控制交互控件的可操作性（ `.disable` 对应的 `EnviromentValue` 为 `isEnabled` ）。

在 `TextFieldWrapper` 中添加：

    @Environment(\.isEnabled) var isEnabled

在 `updateUIView` 中添加：

    uiView.isEnabled = isEnabled

只需要两条语句， `TextFieldWrapper` 便可以直接使用 `View` 的 `disable` 扩展来控制其是否可以录入数据。

还记得上文中介绍的 `context` 吗？我们可以直接通过 `context` 获取上下文中的环境值。因此支持原生的 `View`
扩展将一步简化。

**无需** 添加 `@Environemnt` ，只需要在 `updateUIView` 中添加一条语句既可：

    uiView.isEnabled = context.environment.isEnabled

查看 [ 源代码 ](https://gist.github.com/e749322c1add66b2f9b8732c62463c89.git)

> 在写本文时，在 iOS 15 beta 下运行该代码，会出现 `AttributeGraph: cycle detected through
attribute` 的警告，这个应该是 iOS 15 的 Bug，请自行忽略。

通过环境值来设置是一种十分便捷的方式，唯一需要注意的是，它会改变链式结构的返回值。因此，在该节点后的链式方法只能是针对 `View`
设置的，像之前我们创建的 `foregroundColor` 就只能放置在这个节点之前。

### font

我们也可以自己创建环境值来实现对 `TextFieldWrapper` 的配置。比如，SwiftUI 提供的 `font` 环境值的类型为 `Font` ，本例中我们将创建一个针对 `UIFont` 的环境值设定。

创建环境值 `myFont` ：

    struct MyFontKey:EnvironmentKey{
        static var defaultValue: UIFont?
    }

    extension EnvironmentValues{
        var myFont:UIFont?{
            get{self[MyFontKey.self]}
            set{self[MyFontKey.self] = newValue}
        }
    }

在 `updateUIVIew` 中添加：

    uiView.font = context.environment.myFont

`font` 方法可以有多种写法：

- 同 `forgroundColor` 一样的对 `TextFieldWrapper` 进行扩展

      func font(_ font:UIFont) -> some View{
          environment(\.myFont, font)
      }

- 对 `View` 进行扩展

  extension View {
  func font(\_ font:UIFont?) -> some View{
  environment(\.myFont, font)
  }
  }

两种方式的链式节点的返回值都不再是 `TextFieldWrapper` ，后面应该接针对 `View` 的扩展。

查看 [ 源代码 ](https://gist.github.com/c9602681774540dbca929e21c99827c7.git)

### onCommit

在版本 2 的代码中，我们为 `TextFieldWrapper` 添加了 `onCommit` 设置，在用户输入 `return`
时会触发该段代码。本例中，我们将为 `onCommit` 添加一个可修改版本，且不需要通过协调器构造函数传递。

本例中的技巧在之前都出现过，唯一需要提醒的是在 `updateUIView` 中，可以通过

    context.coordinator.onCommit = onCommit
    context.coordinator.onEditingChanged = onEditingChanged

改变协调器内的变量。这是一种非常有效的在 SwiftUI 和协调器之间进行沟通的手段。

![image-20210823091321562](https://cdn.fatbobman.com/image-20210823091321562.png)

查看 [ 源代码 ](https://gist.github.com/716b08616fa6ecbd28589ac94b635706.git)

## 避免滥用 UIKit 包装

尽管在 SwiftUI 中使用 UIKit 或 AppKit 并不麻烦，但是当你打算包装一个 UIKit 控件时（尤其是已有 SwiftUI
官方原生解决方案），请务必三思。

苹果对 SwiftUI 的野心非常大，不仅为开发者带来了声明+响应式的编程体验，同时苹果对 SwiftUI
在跨设备、跨平台上（苹果生态）也做出了巨大的投入了。

苹果为每一个原生控件（比如 `TextField`
），针对不同的平台（iOS、macOS、tvOS、watchOS）做了大量的优化。这是其他任何人都很难自己完成的。因此，在你打算为了某个特定功能重新包装一个系统控件时，请先考虑以下几点。

### 官方的原生方案

SwiftUI 这几年发展的很快，每个版本都增加了不少新功能，或许你需要的功能已经被添加。苹果最近两年对 SwiftUI
的文档支持提高了不少，但还没到令人满意的地步。作为 SwiftUI 的开发者，我推荐大家最好购买一份 javier 开发的 [ A Companion
for SwiftUI ](https://swiftui-lab.com/companion/) 。该 app 提供了远比官方丰富、清晰的 SwiftUI
API 指南。使用该 app 你会发现原来 SwiftUI 提供了如此多的功能。

### 用原生方法组合解决

在 SwiftUI 3.0 版本之前，SwiftUI 并不提供 `searchbar` ，此时会出现两种路线，一种是自己包装一个 UIKit 的 `UISearchbar` ，另外就是通过使用 SwiftUI 的原生方法来组合一个 `searchbar`
。在多数情况下，两种方式都能取得满意的效果。不过用原生方法创建的 `searchbar` 在构图上更灵活，同时支持使用 `LocalizedString` 作为 placeholder。我个人会更倾向于使用组合的方案。

> SwiftUI 中很多数据类型官方并不提供转换到其他框架类型的方案。比如 `Color` 、 `Font`
> 。不过这两个多写点代码还是可以转换的。 `LocalizedString` 目前只能通过非正常的手段来转换（使用 `Mirror` ）,
> 很难保证可以长久使用该转换方式。

### Introspect for SwiftUI

在版本 2 代码中，我们为 `TextFieldWrapper` 添加了 `clearButtonMode` 的设置，也是我们唯一增加的目前 `TextField` 尚不支持的设定。不过，如果我们仅仅是为了添加这个功能就自己包装 `UITextField` 那就大错特错了。

[ Introspect ](https://github.com/siteline/SwiftUI-Introspect)
通过自省的方法来尝试查找原生控件背后包装的 UIKit（或 AppKit）组件。目前官方尚未在 SwiftUI
中开放的功能多数可以通过此扩展库提供的方法来解决。

比如：下面的代码将为原生的 `TextField` 添加 `clearButtonMode` 设置

            import Introspect
            extension TextField {
                func clearButtonMode(_ mode:UITextField.ViewMode) -> some View{
                    introspectTextField{ tf in
                        tf.clearButtonMode = mode
                    }
                }
            }

            TextField("name:",text:$name)
               .clearButtonMode(.whileEditing)

## 总结

SwiftUI 与 UIKit 和 AppKit 之间的互操作性为开发者提供了强大的灵活性。学会使用很容易，但想用好确实有一定的难度。在 UIKit 视图和
SwiftUI 视图之间共享可变状态和复杂的交互通常相当复杂，需要我们在这两种框架之间构建各种桥接层。

本文并没有涉及包装具有复杂逻辑代码的协调器同 SwiftUI 或 Redux 模式沟通交互的话题，里面包含的内容过多，或许需要通过另一篇文章来探讨。

# Ask Apple 2022 与 SwiftUI 有关的问答（下）

Ask Apple 为开发者与苹果工程师创造了在 WWDC 之外进行直接交流的机会。本文对本次活动中与 SwiftUI
有关的一些问答进行了整理，并添加了一点个人见解。本文为下篇。

## Q&A

### Form vs List

Q：这可能是一个非常愚蠢的问题，但我一直对 Form 和 List 感到困惑。它们之间有什么区别，什么时候应该使用 Form ，什么时候应该使用 List
？谢谢！

A：Form 是一种将许多相关控件组合在一起的方式。虽然 Form 和 List 在 iOS 上看起来差不多，但如果你看一下
macOS，就会发现它们之间的不少差异。与 macOS 上的 List 相比，许多控件在 Form 中的外观和行为都有所不同。与 Form
不同的是，List 内置了对编辑模式（ Edit Mode ）的支持。因此，如果你正在创建一个视图来显示可滚动的内容，并可能进行选择操作，那么在 iOS 和
macOS 上使用 List 将有最好的体验。如果你要渲染许多相关的控件，使用 Form 会在 iOS 和 macOS 上有最好的默认体验。

> 除了早期的 SwiftUI 版本，Form、List、LazyStack 以及 LazyGrid
> 之间在执行效率和子视图的生命周期方面的表现都相当接近。SwiftUI 4.0 的 Form 在 Ventura
> 上的表现与以往版本有很大的不同。形式上更接近 iOS 的状态，同时也对 mac 进行了更多的适配。

![image-20221031081829661](https://cdn.fatbobman.com/image-20221031081829661.png)

### 在辅助状态隐藏图像

Q：对于辅助功能，Image (decorative:) 和 .accessibilityHidden 之间是否有区别？

A：没有区别，使用这两种方法可以适当地隐藏图像，使其不被辅助技术所发现！

> accessibilityHidden 支持任意符合 View 协议的元素，同时可以动态调整它的隐藏状态。

### Table 中上下文菜单

Q：如果我在 TABLE 上添加了一个上下文菜单，我如何确定哪一行导致了菜单的显示（无需选择该行）？

A：在 TABLE 外使用 contextMenu (forSelectionType:) 。

> 在 [ 上篇第一个问题中 ](/zh/posts/swiftui-of-ask-apple-2022-1/#contextaction) 已经介绍了 `contextMenu(forSelectionType:)` 的使用方式。同经常使用的 `contextMenu` 不同， `contextMenu(forSelectionType:)` 是针对整个 List 或 Table 使用的（ 非单元格 ）。阅读 [ 用 Table
> 在 SwiftUI 下创建表格 ](/zh/posts/table_in_swiftui/) ，了解 Table 的具体用法。

### 视图的性能优化

Q：面对复杂的用户界面时，控制视图中的更新范围的最佳做法是什么（ 以避免不需要的转发以及重复计算 ）。在更复杂的 UI 中，由于视图的更新速度过快，性能（
至少在 macOS 上 ）迅速下降。

A：有不同的策略。

- ObservableObject 是使视图或视图层次结构的失效（ 引发重新计算 ）的单元。你可以使用符合 ObservableObject 协议的不同对象来分割失效的范围
- 有时，不依赖 @Published 而获得一些手动控制并直接向 objectWillChange 发布变化是很有用的
- 添加一个中间视图，只提取你需要的属性，并依靠 SwiftUI 的 equality 检查来提前中止无效计算

> 苹果工程师给出的答案与 [ 避免 SwiftUI 视图的重复计算
> ](/zh/posts/avoid_repeated_calculations_of_swiftui_views/)
> 一文中的很多建议都一致。视图的性能优化是一个系统工程，在对其运作机制、注入原理、更新时机等方面有了综合认识后，可以更好地做出有针对性的解决方案。

### 快速检索数组元素

Q：为什么没有简单的方法将 TABLE 选择的行映射到提供表内容的数组元素上？似乎唯一的方法是在数组中搜索匹配的 id 值，这对于大表来说似乎效率很低。

A：用数组索引来存储选择是很脆弱的：如果数组发生了突变，选择就会变得不同步。 [ Swift Collections
](https://github.com/apple/swift-collections) 有一个 OrderedDictionary，可能会对你有所帮助。

> 这正是 [ Swift Identified Collections ](https://github.com/pointfreeco/swift-
> identified-collections) 项目存在的意义。Swift Identified Collections 是基于
> OrderedDictionary 实现的一个拥有键属性的类数组。它的唯一要求是元素必须符合 Identifiable 协议。

    struct Todo: Identifiable {
      var description = ""
      let id: UUID
      var isComplete = false
    }

    class TodosViewModel: ObservableObject {
      @Published var todos: IdentifiedArrayOf<Todo> = []
      ...
    }

    // 可以用类似字典的方式对元素进行操作，快速定位，同时在更新 IdentifiedArray 时，也不容易引发 ForEach 的异常
    todos[id:id] = newTodo

### 自定义布局

Q：在实现自定义布局时，处理非常小或非常大的可用空间的边缘情况有多重要？

A：和很多事情一样，这个问题的答案是取决于你的使用情况（ 无论这个答案多么不令人满意：sweat_smile: ）。如果容器对 zero 和
infinite
的可用空间提出要求，需要用以确定最小和最大的尺寸，至少应该考虑这些情况。除此以外，当你试图实现一个可以在各种情况下使用通用的布局时，一定要考虑！但是，如果你只是自己使用它，并且条件可控，那么不处理这些情况也是合理的。

> 创建一个考虑到所有情况的通用布局（ 例如：VStack、HStack
> ）是一项相当艰巨的工作。开发者即使无法实现这样的布局容器，也应对各种尺寸需求的定义有清晰的理解。在 [ SwiftUI 布局 —— 尺寸（ 上 ）
> ](/zh/posts/layout-dimensions-1/) 一文中，对建议尺寸的几种模式都进行了介绍。

### 如何减少主线程的负担

Q：如何避免所有操作都被放置在主线上？任何标记 @Published 的变量都应该在主线上被修改，所以应该使用 @MainActor
。但任何触及该属性的代码都将被影响。是否有建议的标准模式或方法来改善这一点？

A：一般来说，你确实需要在主线程上与 UI 框架互动。在使用引用类型时，这一点尤其重要，因为你必须确保总是有对它进行序列化的读取。实际上，我们有一个非常棒的
WWDC [ 演讲 ](https://developer.apple.com/videos/play/wwdc2021/10019/)
，详细介绍了并发性和 SwiftUI ，特别提到了有关使用 ObservableObject 的情况。一般来说，性能瓶颈不在写入 @Published
属性的周围。我建议的方法是在主线程之外做任何昂贵的或阻塞的工作，然后只在需要写入 ObservableObject 上的属性时再跳回主线程。

> @State 是线程安全的，@StateObject 会自动将 wrappedValue（ 符合 ObservableObject 协议的引用类型
> ）标注为 @MainActor 。

### 自定义布局

Q：我经常想根据列表中最长或最短的文字来布置各种小组件。鉴于动态文本大小在应用程序运行时可能会发生变化，衡量给定字体的文本大小的最佳方法是什么？

A：你好！我们新的布局协议支持这个功能。任何自定义布局的完整实现都比我在这里的帖子中快速勾勒出来的要长，但总体思路是，你可以创建一个布局来查询其子级的理想大小并相应地对它们进行排序。然后，您可以使用垂直或水平堆栈布局来组合它，这样您就不需要自己完成所有的实现工作。

> Jane 的 [ 自动根据宽度排版 ](https://www.youtube.com/watch?v=du_Bl7Br9DM&t=107s)
> 视频与该问题十分契合。阅读 [ The SwiftUI Layout Protocol ](https://swiftui-
> lab.com/layout-protocol-part-1/) 了解如何创建自定义布局。

### 创建从底部开始的滚动视图

Q：我如何实现一个在底部对齐的滚动视图，在 macOS
上会不会有糟糕的性能？我采用了常见的解决方案，即旋转滚动视图和里面的每个单元格，以获得预期的倒置列表，在 iOS 上，这很有效。但在 macOS 上，它使
CPU 使用率保持在 100%。

A：你最好的选择是使用 ScrollView 和 ScrollViewReader，并在 onAppear
或新内容进来时滚动到最底部的视图。我不建议尝试旋转滚动视图。

> [ Swiftcord ](https://github.com/SwiftcordApp/Swiftcord) 的代码展示了如何在 SwiftUI
> 下实现倒置列表。阅读 [ 优化在 SwiftUI List 中显示大数据集的响应效率
> ](/zh/posts/optimize_the_response_efficiency_of_list/)
> 一文，了解苹果工程师推荐的方法。在两种方案中，如果在数据量很大的情况下，我更倾向于第一种方式，这样可以按需求读取数据。

### 定制 List

Q：是否有办法以完全可定制的方式使用 List ，这样我就可以实现删除缩进、分隔线，甚至更改整个列表的背景等操作？ 目前，我总是去找 LazyVStack
来代替。

A：有多种修饰器可以实现这个功能：listRowSeparator, listRowInsets。不支持整个列表填充，请对此提出反馈。

> 在 SwiftUI 4 中，可以使用 `.scrollContentBackground(.hidden)` 隐藏列表的默认背景

### searchable

Q：是否有办法在 `.searchable()` 修饰器中以编程方式设置搜索字段的焦点？

A：你可以使用 dismissSearch 环境属性以编程方式取消搜索字段。目前还没有 API 可以程序化地将焦点转至搜索字段。

### TextField 内容验证

Q：如何实现一个只接受数字的 SwiftUI TextField，小数是允许的。

A：向文本字段提供 FormatStyle 以实现自动将文本转换为各种数字。但是，此转换仅在文本字段完成编辑时才会发生，并且不会阻止输入非数字字符。目前
SwiftUI 没有 API 可以限制用户在字段中输入的字符。

> 很希望苹果能够继续扩展基于 FormatStyle 的解决方案，让其可以实时对输入内容进行校验。阅读 [ SwiftUI TextField 进阶 ——
> 格式与校验 ](/zh/posts/textfield-1/) 一文了解其他的验证手段，以及如何通过 onChange
> 实现近乎实时地限制输入字符的方法。

### 将背景扩展到安全区域

Q：如果我有一个自定义的容器类型，可以接受一个顶部和底部的视图，是否有办法让 API 的调用者将所提供的视图的背景扩展到安全区域内，同时将内容（
如文本或按钮 ）保留在安全区域内？

A：你可以尝试使用 `safeAreaInset(edge: .top) { ... }` 或 `safeAreaInset(edge:
.bottom) { ... }` 修饰器来放置你的顶部和底部视图。然后让顶部/底部视图忽略安全区域。我不确定这是否能满足你的用例，但值得一试。

> 在 background 修饰器中，可以通过 ignoresSafeAreaEdges
> 参数设置是否忽略安全区域。这个技巧对于处于屏幕的顶部或底部的视图十分有用。详情请参阅 [ 推文
> ](https://twitter.com/fatbobman/status/1564054945891921921?s=61&t=DOfEKfprtvzQFXuJJkmBXA)
> 。

### 动画转场

Q：为什么下面的代码没有显示动画转场。

    struct ContentView: View {
        @State var isPresented = false
        var body: some View {
            VStack {
                Button("Toggle") {
                    isPresented.toggle()
                }
                if isPresented {
                    Text("Hello world!")
                        .transition(.move(edge: .top).animation(.default))
                }
            }
        }
    }

A：尝试将动画修饰器移到 transition 参数之外。

    struct ContentView: View {
        @State var isPresented = false
        var body: some View {
            VStack {
                Button("Toggle") {
                    withAnimation {
                        isPresented.toggle()
                    }
                }
                if isPresented {
                    Text("Hello world!")
                        .transition(.move(edge: .top))
                        .animation(.default, value: isPresented)
                }
            }
        }
    }

> 在上面苹果工程师给出的修改代码中。 `.animation(.default, value: isPresented)`
> 是多余的。转场的动画事件是通过 withAnimation 来显式添加的。对于类似的情况，也可以不使用显式动画驱动（ 不使用 withAnimation
> ），只需将 `.animation(.default, value: isPresented)` 移动到 VStack 之外即可。阅读 [
> SwiftUI 的动画机制 ](/zh/posts/the_animation_mechanism_of_swiftui/)
> 一文，了解更多有关动画的内容。

### 在 NavigationSplitView 的边栏中使用 LazyVStack

Q：iOS 16 的新 NavigationSplitView 当前只与主（ master ）列中的 List 一起工作。这意味着我们不能使用
LazyVStack，或任何其他将选择与详细视图绑定的自定义视图。有扩展这个功能的计划吗？

A：在 iOS 16.1 中，你可以在侧边栏里放一个。navigationDestination，这样侧边栏里的 NavigationLink
就会取代详细栏的根视图。

    NavigationSplitView {
        LazyVStack {
            NavigationLink("link", value: 213)
        }
        .navigationDestination(for: Int.self) { i in
            Text("The value is \(value)")
        }
    } detail: {
        Text("Click an item")
    }

> 这是一个相当重要的改进！解决了之前的一大遗憾。如此一来，边栏视图的样式自由度获得了极大的提高。

### 软弃用

Q：最近，我注意到新的 @ViewBuilder 函数在以前的版本中是不可用的，弃用信息提示我使用新的方法取代老方法，这是 SwiftUI 的 API
设计缺陷还是我错过了什么？

     @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use `overlay(alignment:content:)` instead.")
     @inlinable public func overlay<Overlay>(_ overlay: Overlay, alignment: Alignment = .center) -> some View

A：100000.0 的 deprecated 版本是 Swift 框架作者的一种沟通方式，即一个 API
不应该在新项目中使用，但在现有项目中继续使用也无妨。这种 “软弃用” 的 API
不会在代码自动补全中提供，而且通常处在文档中单独的一个部分。但编译器不会对现有的使用发出警告。因为这些使用并不有害，我们不希望开发者因为使用了新的编译器版本而处理一堆的警告。

### macOS API

Q：对于运行 Monterey 的 Mac，能否如何在 SwiftUI 中实现下面需求的建议：

1. 打开一个窗口
2. 在该窗口中初始化数据
3. 找到所有打开的窗口
4. 确定一个窗口是否打开
5. 从不在该窗口的视图中关闭一个窗口

A：我想说的是，如果可以，将 macOS Ventura 作为目标平台会对其中的一些操作更有帮助。特别是，我们在 WindowGroup 上添加了新的
OpenWindowAction 和新的初始化方法，这将同时满足 1 和 2 。如果您无法做到这一点，则可以使用 URL 和
handleExternalEvents 来模仿其中的一些行为，但它的局限性要大得多。关于其他点，目前没有合适的 API 。

### 连锁动画

Q：在 SwiftUI 中，如何实现连锁动画？例如，我想先给一个视图做动画，当动画完成后立即启动另一个动画。

A：不幸的是，目前不可能实现连锁动画。根据你的问题，你可以使用 animation. delay (…)
将动画的后半部分延迟到前半部分完成之后。如果你能将你的用例的细节反馈给我们，我们将非常感激。

> SwiftUI 当前缺乏动画完成后的回调机制。在动画不复杂的情况下，可以通过创建一个符合 Animatable 协议的 ViewModifier
> 来同步观察动画的进程。详情请参阅 [ 推文
> ](https://twitter.com/fatbobman/status/1567310429600243712?s=61&t=M-TT_ssTFvXutwDlPdWjbg)
> 、 [ 代码 ](https://gist.github.com/fatbobman/205f221e078af96a3c11716c5d7cbcd3)
> 。

### Too complex to type check

Q：我在 iOS 14 SwiftUI 中遇到一个问题，我试图有条件地显示 3 个符合 Shape 协议的对象中的一个。其中 2 个是自定义形状（
基本上是圆角矩形，只有两个角是圆的 ），其中一个是矩形。编译器抛出一个错误，说它花了太多时间来检查视图的类型。

A：是的，不幸的是，像这样的大型构造器表达式有时会让 Swift
编译器难以处理。遇到这种错误的解决办法是把表达式拆成更小的子表达式，特别是如果这些小的子表达式被赋予了明确的类型。

> 当视图的结构过于复杂时，除了难以阅读外，还会出现无法使用代码自动补全以及上文提到的无法编译（ too complex to type check
> ）的情况。将视图的功能分散到函数、更小的视图结构以及视图修饰器当中是很好的解决方法。

### Text 与 TextField 在编辑模式下的切换

Q：在 editMode 的文档中建议，在非编辑模式下，可以选择将 Text 视图换成 TextField
。然而，两个内容相同的视图之间的交换并不能使视图顺利地产生动画，因为两者的文本也被动画化了。我正在使用仅禁用 TextField
的替代方法，但有没有办法引导动画以使用文档中的方法？

A：解决办法：保留 TextField ，但当它不能被编辑时，有条件地设置 disabled (true)，当它可以编辑时使用 disabled
(false) 。

> 设置正确的转场形式，可以避免非必要的闪烁或动画。

    struct ContentView: View {
        var body: some View{
            VStack {
                EditButton()
                List{
                    Cell()
                }
            }
        }
    }

    struct Cell:View {
        @State var text = "Hello"
        @Environment(\.editMode) var editMode
        var body: some View{
            ZStack {
                if editMode?.wrappedValue == .active {
                    TextField("",text: $text).transition(.identity)
                } else {
                    Text(text).transition(.identity)
                }
            }
        }
    }

### 分离代码

Q：我注意到我的视图代码变大了，但原因并非来自实际的视图内容，而是由于 sheet、toolbar 等修饰器中的代码造成的。我当前设法在一个标注
@ToolbarContentBuilder 的函数中单独提取 toolbar 的内容，是否有好的方法来提取掉大量的 shee 和 alert 中的代码。

A：你可以通过创建自定义 ViewModifier 来封装其中的一些代码。另外，sheet 和 alert 的内容都采用了
ViewBuilders，所以你可以以类似于处理 toolbar 内容的方式将其提取到函数或计算属性中。

## Q&A （ 集锦 - 简体中文 ）

> 下文中的问题来自开发者与苹果工程师在【 集锦 - 简体中文 】频道进行的中文讨论（ 没有出现在英文 SwiftUI 频道中
> ）。我直接对其进行了复制粘贴。

### 加载 Core Data 图片

Q：我的 CoreData 内使用 BinaryData with extern storage 存储图片。然后用 SwiftUI Image
来加载，data 还挺大的，当多个图同时加载，会卡顿和内存占用，请问这种情况下怎么改善

A：首先尽量保证采用异步加载的方式加载和创建图片，比如 SwiftUI 中的 AsyncImage 就可以从 URL
中异步加载图片，也可以根据需要实现自己的异步加载器完成异步加载。对于内存占用问题，首先尽量只在内存中保留需要显示的图片，对于预先加载的图片也适度，建议参看
WWDC 18 的 [ Image and Graphic Best Practices
](https://developer.apple.com/wwdc18/219) , 有很多图片内存优化上的很好的建议。

> 异步 + 缩率图。对于可能造成卡顿的图片数据，放弃从托管对象的图片关系中直接获取的方式。在 Cell 视图中，通过创建 request
> 从私有上下文中提取数据并转换成图片。另外，可以考虑为原始图片创建缩略图，进一步提高显示的效率。

### TextField 中文输入的问题

Q：请问 SwiftUI 的 TextField 在中文输入时，会在字母选择阶段就直接上屏，造成输入内容错误的问题是已知问题吗？会在 16.1 RC
修复吗？

A：我们没能在 iOS 16.0.3 上重现你说的问题，你是否可以提供相关的代码段方便我们重现问题和调查？如果通过 Feedback Assistant
提交过此问题，请告诉我们 Feedback ID。

> 这是一个在多个版本中都出现过的奇怪问题。在 SwiftUI 早期版本中，当在 iOS
> 中使用系统中文输入法时，很容易触发这种情况。但后期逐步得到了修复。近期，在聊天室中我也看到了类似的讨论（ 我本人尚未在 iOS 16 上遇到
> ）。贴一个临时的解决方案。

![image-20221023171100484](https://cdn.fatbobman.com/image-20221023171100484.png)

### 滚动速度

Q：有好的方式在 `List` 和 `ScrollView` 滑动时监听滑动的 velocity 值么？截止 SwiftUI
目前的版本，可以通过以下步骤获取到滑动的距离：

1. 自定义 struct, 让它实现 `PreferenceKey` 协议，其自定义结构体，是需要收集的 gemmetry data （视图坐标信息）
2. 调用 `transformAnchorPreference(key:_, value:_, transform:_)` or `preference(key:_,value:_)` 来在 SwiftUI 更新视图时收集坐标信息
3. 调用 `onPreferenceChange(:_,perform:_)` 来获取收集的坐标信息但是这样的实现方式，无法获取到 velocity

A：请问你需要这个速度值做什么用途？因为通常情况下并不需要这个值，如果是要检测滚动掉帧，可以在 Xcode Organizer 里查看，或者用
MetricKit 生成报告，开发环境也可以使用 Instruments
。所以更想知道你需要这个速度值有什么特定的用途。可以尝试在获取位置改变的同时记录时间变化来计算速度。不过如果是涉及到用户交互，建议衡量一下用户对速度的敏感程度和交互效果本身，是否可以用更便捷的方式实现。

> 在 SwiftUI 中，有一个从第一版开始就存在但尚未公开的纯 SwiftUI 实现的滚动容器 —— \_ScrollView 。该滚动容器提供了不少标准
> ScrollView 无法提供的 API
> 接口，例如对手势的加强控制、容器内视图的位移、反弹控制等。但这个滚动有两大问题，1、是一个未公开的半成品，有可能会被从 SwiftUI
> 框架中移除；2、不支持懒加载，即使和 Lazy 视图一起使用也会一次性加载全部的视图。更多内容可以查看一个对其进行二次包装的 [ SolidScroll
> ](https://github.com/edudnyk/SolidScroll) 库。

## 总结

我忽略掉了没有获得结论的问题。希望上述的整理能够对你有所帮助。

# 在 SwiftUI 中创建自适应的程序化导航方案

随着苹果对 iPadOS 的不断投入，越来越多的开发者都希望自己的应用能够在 iPad 中有更好的表现。尤其当用户开启了台前调度（ Stage
Manager ）功能后，应用对不同视觉大小模式的兼容能力就越发显得重要。本文将就如何创建可自适应不同尺寸模式的程序化导航方案这一内容进行探讨。

![iShot_2022-11-13_09.30.17.2022-11-13
09_35_46](https://cdn.fatbobman.com/iShot_2022-11-13_09.30.17.2022-11-13%2009_35_46-8387178.gif)

## 程序化导航与状态驱动

顾名思义，“程序化导航”就是开发者可以通过代码感知应用当前的导航状态并设置导航目标的方式。从 4.0 版本开始，苹果对之前 SwiftUI
有限的程序化导航能力进行了大幅度的增强，通过引入 NavigationStack 和
NavigationSplitView，开发者基本上具备了全程掌握应用的导航状态的能力，并可在视图内外的代码中实现任意位置的跳转。

与 UIKit 使用的命令式导航方式不同，SwiftUI
作为一个声明式框架，感知与设置两者之间是二位一体的关系。读取状态即可获知当前的导航位置，更改状态便可调整导航路径。因此在 SwiftUI
中，掌握两种导航容器的状态表述差异是实现自适应导航方案的关键。

## NavigationStack vs NavigationSplitView

> 本节仅对 NavigationStack 和 NavigationSplitView 之间的状态表述进行说明，想了解两者具体用法，请参阅 [
> SwiftUI 4.0 的全新导航系统 ](/zh/posts/new_navigator_of_swiftui_4/) 一文。

与视觉表现一致， NavigationStack 用“栈”作为导航的状态表述。使用数组（ NavigationPath 也是对 Hashable
数组的一种包装
）作为状态的表现形式。在栈中推送和弹出数据的过程对应了导航容器中添加和移除视图的操作。弹出全部数据相当于返回根视图，推送多个数据相当于一次性添加多个视图并直接跳转到最后数据所代表的视图。需要特别注意的是，在
NavigationStack 中，根视图是直接通过代码声明的，并不存在于“栈”中。

我们可以将 NavigationSplitView 视为具备一些预置能力的
HStack，通过在其中声明两个或三个视图从而创建两列或三列的导航界面。在不少情况下，NavigationSplitView 与拥有多个视图的 HStack
之间的状态表述十分类似。但是，因为 NavigationSplitView 的某些特性，从而对状态的表述有更多的要求和限制：

- 在需要的状况下（ iPhone 或 compact 模式下 ）可以自动转换成 NavigationStack 的视觉状态

对于一些简单的两列或三列的导航布局，SwiftUI 可以自动将其转换成 NavigationStack
表现形式。下文中的方案一和方案二便是对这种能力的体现。但并非所有的状态表述都可在转换后实现程序化导航。

- 与 List 进行了深度的绑定

对于一个包含三列（ A、B、C ）的 NavigationSplitView ，我们可以使用任意的方式让这些视图之间产生联动。例如：在 A 中修改状态
b，B 响应 b 状态；在 B 中修改状态 c，C 视图响应状态 c。不过仅有在前两列中通过 `List(selection:)`
来修改状态时，才能在自动转换的 NavigationStack 表现形式中具备程序化导航的能力。方案一对此有进一步的说明。

- 列中可以进一步嵌入 NavigationStack

我们可以在 NavigationSplitView 的任意列中嵌入 NavigationStack
从而实现更加复杂的导航机制。但如此一来，自动转换将无法应对这类的场景。开发者需要自行对两种导航逻辑的状态进行转换。方案三将演示如何进行这一过程。

## 最易用的方案 —— NavigationSplitView + List

![navigationSplitView-
three_38_14](https://cdn.fatbobman.com/navigationSplitView-three_38_14.gif)

    struct ThreeColumnsView: View {
        @StateObject var store = ThreeStore()
        @State var visible = NavigationSplitViewVisibility.all
        var body: some View {
            VStack {
                NavigationSplitView(columnVisibility: $visible, sidebar: {
                    List(selection: Binding<Int?>(get: { store.contentID }, set: {
                        store.contentID = $0
                        store.detailID = nil
                    })) {
                        ForEach(0..<100) { i in
                            Text("SideBar \(i)")
                        }
                    }
                    .id(store.deselectSeed)
                }, content: {
                    List(selection: $store.detailID) {
                        if let contentID = store.contentID {
                            ForEach(0..<100) { i in
                                Text("\(contentID):\(i)")
                            }
                        }
                    }
                    .overlay {
                        if store.contentID == nil {
                            Text("Empty")
                        }
                    }
                }, detail: {
                    if let detailID = store.detailID {
                        Text("\(detailID)")
                    } else {
                        Text("Empty")
                    }
                })
                .navigationSplitViewStyle(.balanced)
                HStack {
                    Button("Back Root") {
                        store.backRoot()
                    }
                    Button("Back Parent") {
                        store.backParent()
                    }
                }
                .buttonStyle(.bordered)
            }
        }
    }

    class ThreeStore: ObservableObject {
        @Published var contentID: Int?
        @Published var detailID: Int?
        @Published var deselectSeed = 0

        func backParent() {
            if detailID != nil {
                detailID = nil
            } else if contentID != nil {
                contentID = nil
            }
        }

        func backRoot() {
            detailID = nil
            contentID = nil
            // 改善 compact 模式下返回根目录后的表现。取消选中高亮
            // 可以用类似的方式，改善当 contentID 变化后，content 列仍会有灰色选择提示的问题
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                withAnimation {
                    self.deselectSeed += 1
                }
            }
        }
    }

代码很简单，我仅就几点进行提醒：

- List 必须出现在列代码的最上层

为了保证在自动转换后仍具备程序化导航的能力，NavigationSplitView 对嵌入的 List 有严格的要求，List
代码必须出现在列代码中的最上层。比如在本例的 Content 列代码中，为了维持这个限定，只能通过 overlay
来定义占位视图。如果将代码调整成如下样式，则会在转换后丧失程序化导航的能力（ 无法通过修改状态，返回上层视图 ）。

    if store.detailID != nil {
        List(selection: $store.detailID)
    } else {
        Text("Empty")
    }

- 修改状态后，List 仍会用灰色显示上次选中的项目

即使取消了状态（ 例如修改 contentID ），List 仍会将上次选中的状态用灰色的选中框进行表示。为了避免使用者产生误解，代码中分别使用了两个 id
修饰器在状态变化后对列视图进行了刷新。

## 有得必有失 —— NavigationSplitView + LazyVStack

尽管 List 使用起来很简单，但也有一些不足之处，其中最重要的是无法自定义选中的状态。那么能否在导航列中使用 VStack 或 LazyVStack
实现程序化导航呢？

在不久前的 [ Ask Apple ](/zh/posts/swiftui-of-ask-apple-2022-2/) 中，苹果工程师介绍了如下的方法：

![image-20221114135939796](https://cdn.fatbobman.com/image-20221114135939796.png)

很遗憾，由于没有暴露 path 接口，问答中的 `navigationDestination(for:)`
无法实现程序化的回退。不过我们可以通过使用另一个 `navigationDestination(isPresented:)`
修饰器来达到类似的目的。俗话说，有得必有失，暂时这种方式只能支持两列，尚未找到可以在中间列中继续使用程序化导航的方式。

![navigationSplitView-two-_52](https://cdn.fatbobman.com/navigationSplitView-
two-\_52.gif)

    class TwoStore: ObservableObject {
        @Published var detailID: Int?

        func backParent() {
            detailID = nil
        }
    }

    struct TowColumnsView: View {
        @StateObject var store = TwoStore()
        @State var visible = NavigationSplitViewVisibility.all
        var body: some View {
            VStack {
                NavigationSplitView(columnVisibility: $visible, sidebar: {
                    ScrollView {
                        LazyVStack {
                            ForEach(0..<100) { i in
                                Text("SideBar \(i)")
                                    .padding(5)
                                    .padding(.leading, 10)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(store.detailID == i ? Color.blue : .clear)
                                    .contentShape(Rectangle())
                                    .onTapGesture {
                                        store.detailID = i
                                    }
                            }
                        }
                    }
                    .navigationDestination(
                        isPresented: Binding<Bool>(
                            get: { store.detailID != nil },
                            set: { if !$0 { store.detailID = nil }}
                        ),
                        destination: {
                            // 需要使用独立的 struct 来构造视图
                            DetailView(store: store)
                        }
                    )
                }, detail: {
                    Text("Empty")
                })
                Button("Back Parent") {
                    store.backParent()
                }
                .buttonStyle(.bordered)
            }
        }
    }

    struct DetailView: View {
        @ObservedObject var store: TwoStore
        var body: some View {
            if let detailID = store.detailID {
                Text("\(detailID)")
            }
        }
    }

需要特别提醒的是，由于处在不同的上下文中，在 navigationDestination 的 destination 中，必须用单独的 struct
来创建视图。否则视图无法响应状态的变化。

## 麻烦但最能打 —— NavigationSplitView + NavigationStack

如果上述两个方案仍无法满足你的需求，那么便需要根据当前的视觉大小模式选择性调用 NavigatoinStack 或 NavigationSplitView。

例如，下面的代码实现了一个具备两列的 NavigationSplitView ，Detail 列中包含一个 NavigationStack。在
InterfaceSizeClass 发生改变后，需要对导航状态进行调整，以匹配 NavigationStack
的需求。反之亦然。演示图片见本文第一个动图。

    class AdaptiveStore: ObservableObject {
        @Published var detailPath = [DetailInfo]() {
            didSet {
                if sizeClass == .compact, detailPath.isEmpty {
                    rootID = nil
                }
            }
        }

        @Published var rootID: Int?
        var sizeClass: UserInterfaceSizeClass? {
            didSet {
                if oldValue != nil, oldValue != sizeClass, let oldValue, let sizeClass {
                    rebuild(from: oldValue, to: sizeClass)
                }
            }
        }

        func backRoot() {
            detailPath.removeAll()
        }

        func backParent() {
            if !detailPath.isEmpty {
                detailPath.removeLast()
            }
        }

        func selectRootID(rootID: Int) {
            if sizeClass == .regular {
                self.rootID = rootID
                detailPath.removeAll()
            } else {
                self.rootID = rootID
                detailPath.append(.init(level: 1, rootID: rootID))
            }
        }

        func rebuild(from: UserInterfaceSizeClass, to: UserInterfaceSizeClass) {
            guard let rootID else { return }
            if to == .regular {
                if !detailPath.isEmpty {
                    detailPath.removeFirst()
                }
            } else {
                detailPath = [.init(level: 1, rootID: rootID)] + detailPath
            }
        }
    }

    struct DetailInfo: Hashable, Identifiable {
        let id = UUID()
        let level: Int
        let rootID: Int
    }

    struct AdaptiveNavigatorView: View {
        @StateObject var store = AdaptiveStore()
        @Environment(\.horizontalSizeClass) var sizeClass
        var body: some View {
            VStack {
                if sizeClass == .regular {
                    SplitView(store: store)
                        .task {
                            store.sizeClass = sizeClass
                        }
                } else {
                    StackView(store: store)
                        .task {
                            store.sizeClass = sizeClass
                        }
                }
                HStack {
                    Button("Back Root") { store.backRoot() }
                    Button("Back Parent") { store.backParent() }
                }
                .buttonStyle(.bordered)
            }
        }
    }

    struct SplitView: View {
        @ObservedObject var store: AdaptiveStore
        var body: some View {
            NavigationSplitView {
                SideBarView(store: store)
            } detail: {
                if let rootID = store.rootID {
                    NavigationStack(path: $store.detailPath) {
                        DetailInfoView(store: store, info: .init(level: 1, rootID: rootID))
                            .navigationTitle("Root \(rootID), Level:\(store.detailPath.count + 1)")
                            .navigationDestination(for: DetailInfo.self) { info in
                                DetailInfoView(store: store, info: info)
                                    .navigationTitle("Root \(info.rootID), Level \(info.level)")
                            }
                    }
                } else {
                    Text("Empty")
                }
            }
        }
    }

    struct StackView: View {
        @ObservedObject var store: AdaptiveStore
        var body: some View {
            NavigationStack(path: $store.detailPath) {
                SideBarView(store: store)
                    .navigationDestination(for: DetailInfo.self) { info in
                        DetailInfoView(store: store, info: info)
                            .navigationTitle("Root \(info.rootID), Level \(info.level)")
                    }
            }
        }
    }

    struct DetailInfoView: View {
        @ObservedObject var store: AdaptiveStore
        let info: DetailInfo
        var body: some View {
            List {
                Text("RootID:\(info.rootID)")
                Text("Current Level:\(info.level)")
                NavigationLink("Goto Next Level", value: DetailInfo(level: info.level + 1, rootID: info.rootID))
                    .foregroundColor(.blue)
            }
        }
    }

    struct SideBarView: View {
        @ObservedObject var store: AdaptiveStore
        var body: some View {
            ScrollView {
                LazyVStack {
                    ForEach(0..<30) { rootID in
                        Button {
                            store.selectRootID(rootID: rootID)
                        }
                    label: {
                            Text("RootID \(rootID)")
                                .padding(5)
                                .padding(.leading, 10)
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .contentShape(Rectangle())
                                .background(store.rootID == rootID ? .cyan : .clear)
                        }
                    }
                }
                .buttonStyle(.plain)
            }
            .navigationTitle("Root")
        }
    }

请注意如下几点：

- 以导航容器所在的视图的 horizontalSizeClass 为判断标准

InterfaceSizeClass 对应的是当前视图的视觉大小。最好以导航容器所在视图的 sizeClass 作为判断标准。例如，在 Side
列视图中，无论在任何环境下，horizontalSizeClass 始终为 compact 。

- 以导航容器的出现时机（ onAppear ）作为重新构建状态的起始点

sizeClass 在变化的过程中，其中的值可能会出现重复变化的情况。因此，不应将 sizeClass 的值是否发生变化作为重构状态的判断标准。

- 不要忘记 NavigationStack 的根视图不在它的“栈”数据中

在本例中，转换至 NavigationStack 时，需要将 Detail 列中声明的视图添加到“栈”的底端。反过来则将其移除。

本着“一案一议”的原则，当前方案可以实现对任意的导航逻辑进行转换。

## 总结

可以在 [ 此处
](https://github.com/fatbobman/BlogCodes/tree/main/DynamicNavigationContainer)
获取本文的全部代码。

一次编写便可对应多种设备，这本就是 SwiftUI 的一个重要特点。尽管仍存在一些不足，但新的导航机制已经在这一方面取得了长足的进步。唯一遗憾的是，仅支持
iOS 16+。

# Ask Apple 2022 与 SwiftUI 有关的问答（上）

Ask Apple 为开发者与苹果工程师创造了在 WWDC 之外进行直接交流的机会。本文对本次活动中与 SwiftUI
有关的一些问答进行了整理，并添加了一点个人见解。本文为上篇。

## Q&A

### UIActivityViewController

Q：是否有计划为 iOS 系统的 UIActivityViewController 添加 “原生” 的 SwiftUI 支持？

A：现在已经可以使用了！请查看 [ ShareLink
](https://developer.apple.com/documentation/swiftui/sharelink/)

### contextAction

Q：在早期的 iOS 16 和 macOS 13 测试版中，我们看到一个新的 `.contextAction`
修改器，后来被删除了。是否有任何建议用来检测列表中的行选择，类似于 “NavigationLink”，但不导航到另一个视图（例如，显示 Sheet
或从列表中选择一个选项 ）？对 iOS 和 iPadOS 来说，一个按钮或许有效，但对 macOS 就不太适合了。另外， `.contextAction` 支持多选。它还会回来吗？

A：看一下上下文菜单修饰器（ contextMenu ）的 primaryAction 参数。该 API 也有一个 forSelectionType
参数，支持多选。

> 在 SwiftUI 4.0 中，contextMenu 的功能获得了不小的提高。例如一个上下文菜单中可以有多个选项、支持
> primaryAction、以及可定制预览视图。上文中提到的带 primaryAction 参数的 contextMenu 不仅可以用于 List
> ，而且也可以用于 Table。

![contextMenu_2022-10-26_14.01.21.2022-10-26
14_02_29](https://cdn.fatbobman.com/contextMenu_2022-10-26_14.01.21.2022-10-26%2014_02_29.gif)

### 如何对 @State 变量进行测试

Q：对于测试 SwiftUI 视图中的 @State 变量是否有推荐的方式？只有将这些变量重构到视图模型中去这一种方式？

A：如果在同一个视图中，有多个相互关联的 @State 属性，将他们提取到一个结构中或许是好的选择。将他们提取到 view model
中也是一种策略，但不是必须的。

> 在单元测试中，很难对 SwiftUI 视图中的依赖（ 符合 DynamicProperty 协议 ）进行测试。这也是 Redux-like
> 框架的优势之一（ 将状态从视图中抽离出来，方便测试 ）。请阅读 [ Writing testable code when using SwiftUI
>
> > ](https://www.swiftbysundell.com/articles/writing-testable-code-when-using-
> > swiftui/) 一文，了解如何编写对测试友好的视图代码。

### 创建与 IM 应用类似的底部文字输入栏

Q：你好，我的问题是关于 TextField 的。假设我们想创建一个类似于 iMessage
的视图，在那里你可以看到一个信息列表（与本例无关），在视图的底部有一个文本框。当用户点击文本字段时，键盘会在其工具栏中出现一个文本字段。我试着在
ToolbarItemGroup (place: .bottomBar) 中添加一个 TextFiled ，在 ToolbarItemGroup
(place: .keyboard) 中添加第二个，然后在 @FocusState
变量的帮助下，我可以隐藏一个并将焦点转移到键盘上。这有点笨拙，我不认为有两个文本框是正确的做法。另外，按照这种方法，@FocusState
变量会变得没有反应，而且它不能被设置为 nil（ 返回到以前的视图并没有移除键盘 ）。是否可以在纯 SwiftUI 中完成（ 不使用 UIKit
）？给我一些方向来完成它吗？

A：一般来说，我建议使用 `.safeAreaInset(edge: .bottom)`
来实现底部文本字段。然后根据它的焦点状态来定制它的显示样式。希望这对你的设计有用。

> 自从 SwiftUI 3.0 提供了 safeAreaInset 视图修饰器之后，实现问题中的案例将不再是难事。详情请参阅 [ 掌握 SwiftUI 的
> Safe Area ](/zh/posts/safearea/) 一文。

### 在使用 environmentObject 的情况下，如何避免创建实例的视图被重新计算

Q：如何在避免重新计算顶层视图 body 的情况下，在不同子树的两个子视图之间共享状态（ 例如 ObservableObject
）？比如说我可以在父级视图中拥有 StateObject，并通过 EnvironmentObject 传递该对象。然而，如果里面的 @Published
属性改变了，父视图和它的子树也都被重新计算。

A：EnvironmentObject 是一个很好的工具。如果你不想让父视图也被更新，可以在创建对象时不使用 @StateObject 或
@ObservedObject 。

> 对于苹果工程师给予的建议有一点请注意，那就是如果有在父视图中修改该环境对象实例的需求，须确保父视图不会被反复重构（ SwiftUI
> 重新创建视图类型的实例 ）。详情请参阅 [ StateObject 与 ObservedObject
> ](/zh/posts/stateobject_and_observedobject/) 。

### NavigationPath

Q：很高兴看到新的 NavigationStack/NavigationPath，对我来说它们运行良好。我想知道我是否可以通过观察（ inspect
）NavigationPath 以判断我的 SearchView 是否进入了某个视图（ 仅是举例 ）。我已经有了使用 NavigationPath.
CodableRepresentation 的想法，但我担心这可能不是观察 NavigationPath 最佳或最可持续的方式。谢谢！

A：没有办法对 NavigationPath 进行内省。如果你需要知道路径的内容，一个好的方法是使用一个同质（ 同一类型 ）的 PATH，比如 `@State private var path: [MyEnum]` ，然后使用 navigationDestination 在该枚举类型上切换。

> NavigationPath 会创建一个完全类型擦除的数据集合，它仅要求元素符合 Hashable 协议。NavigationPath
> 具备一个有趣且强大的特点，它能够在所有元素的类型信息都已被抹除的情况下，提供将自身编解码到 JSON 的能力。阅读 [ Reverse
>
> > Engineering SwiftUI’s NavigationPath Codability
> > ](https://www.pointfree.co/blog/posts/78-reverse-engineering-swiftui-s-
> > navigationpath-codability) 一文，以了解它的实现原理。

### 锁定 Charts 纵轴刻度

Q：我有一个 Swift 图表，通过监听拖动事件实现在拖动过程中显示一个 RuleMark。在拖动过程中，Y 轴的刻度会变大。在我的例子中，不拖动时从 0
到 75，拖动时从 0 到 100。有什么办法可以阻止这种情况吗？

A：你可以用 `.chartYScale(domain: 0 ... 75)` 锁定 Y 轴的刻度域。

### 隐式动画和显式动画

Q：你好！是否有其他方法可以直接根据状态的变化对视图进行动画处理而不使用 onChange 修饰器？我的代码是这样的。

    .onChange(of: modle.state.aChange { value in
        withAnimation(...) {
            self.isAnimated = value
        }
       }
    )

A：你可以通过使用 `.animation(.easeInOut, value: model.state)`
，直接对特定状态的变化进行动画。model. state 的任何变动都将引起动画。

> 通过使用与某个特定状态绑定的 animation 修饰器（ 老版本的 animation 修饰器已被软弃用 ），可以实现更加精确的动画效果。阅读 [
> SwiftUI 的动画机制 ](/zh/posts/the_animation_mechanism_of_swiftui/)
> 一文，了解更多有关动画的内容。

### 自适应高度 Sheet

Q：如何在 iOS 16 中呈现与动态内容高度相匹配的 Sheet？我想在 presentationDetents 中使用视图高度。

A：谢谢你的问题。这在目前是不可能的，但也是我们感兴趣的事情。

> 估计苹果的工程师比较忙，没有认真考虑这个问题。在 iOS 16 中，通过 presentationDetents 同 GeometryReader
> 的配合，可以创建与内容高度一致的 Sheet。此处查看 [ 完整代码
> ](https://gist.github.com/fatbobman/5feab313dbade52cfc66c4f1fd101f66) 。

![adaptiveSheet_2022-10-22_08.50.29](https://cdn.fatbobman.com/adaptiveSheet_2022-10-22_08.50.29.gif)

### ToolbarContentBuilder

Q：我希望看到 @ToolbarBuilder 或对 `if condition { ToolbarItem(a) } else {
ToolbarItem(b) }` 这类的代码有更好的支持。

A：你永远不会看到 @ToolbarBuilder 了，因为 @ToolbarContentBuilder 在 iOS 16 中得到了功能增强。
@ToolbarContentBuilder 已经提供了对 `if else` 的支持，而且可以在符合 ToolbarContent 的自定义类型中使用
@Environment / @EnvironmentObject 等动态属性。

### WindowGroup

Q：早上好！我是 SwiftUI 新手。我的问题是关于场景的。几乎所有教程和示例代码库中，只使用了一个 WindowGroup 场景，所有内容都嵌套在
ContentView 中。是否关于如何使用多个场景的指导或例子？或者大多数应用程序只需要一个 WindowGroup ？

A：多场景对于建立复杂的应用程序是很有用的，特别是在 macOS 上。例如，你可能希望有一个同时定义了 “窗口组” 和 “文档组” 的应用程序，或者有一个
“窗口组” 和一个辅助的 “窗口” 场景的应用程序。场景的内容视图定义了场景创建的窗口中的视图内容，但场景本身定义了应用程序的整体结构。

> SwiftUI 4.0 中，WindowGroup 获得了相当大的更新，真正具备了开发 macOS 应用的能力。详细的内容请阅读 [ Bringing
> multiple windows to your SwiftUI app
> ](https://developer.apple.com/documentation/swiftui/bringing_multiple_windows_to_your_swiftui_app)
> 以及 [ WWDC 2022 Session
> ](https://developer.apple.com/videos/play/wwdc2022/10061/) 。

### DocumentGroup

Q：在 macOS 上使用 SwiftUI 应用生命周期和 DocumentGroup 时，如果应用仅为数据阅读器，是否可以禁止创建新文件？

A：DocumentGroup 提供一个 [初始化器]( [
https://developer.apple.com/documentation/swiftui/documentgroup/init
](https://developer.apple.com/documentation/swiftui/documentgroup/init)
(viewing:viewer:)-6 dq 9 n)，用于创建一个阅读器类型的应用程序。只允许打开该内容类型的文件，但不能进行编辑。

### MVVM

Q：在 UIKit 时代，MVVM 是一种常见的架构，视图显示的数据来自一个单独的 viewModel 类。这在 SwiftUI 中仍适用，还是说
struct 本身现在被视为 viewModel ？

A：SwiftUI 试图与应用程序的整体架构无关。不过，在传统的 viewModel 意义上，我不建议将视图（ 结构本身
）作为视图模型。这可能会导致一些不好的后果，例如使视图的可重用性降低，并将业务逻辑与 SwiftUI
视图的生命周期挂钩，这将使处理业务逻辑变得更加困难。简而言之，我们不建议使用视图作为视图模型。但 SwiftUI 确实提供了实现经典 MVVM
架构的工具（例如 StateObjects、ObservedObjects ）。

### onAppear、init、viewDidLoad

Q：在我的应用程序中，我在 UIHostingController 中托管了 SwiftUI 视图，这些视图都处于一个 UITabBarController
中。最近，我注意到 SwiftUI 视图的 onAppear 在意想不到的时间启动，比如当 UITabBarController
被创建时，而不是当视图本身出现时。我在想：1、对于像这样的 UITabBarController 中的 SwiftUI 视图，onAppear
到底应该在什么时候被调用？2、当视图出现在 UITabBarController 中时，推荐的执行代码的方法是什么？

A：当在其他类型的 UIViewControllers 中使用 UIHostingController
时，你可能会通过调用托管控制器的方法来触发视图加载提前发生。对于非惰性视图（如 LazyVStack ），一旦 hosting controller
的视图被初始化，onAppear 将被调用。对于惰性视图，当在 hosting controller 视图上调用 layoutSubviews 或
sizeThatFits 方法时，会初始化视图。所以，如果你看到视图在你的 UITabBarController 的 init 方法中被初始化，就需要看看在
init 中到底做了什么。可以试着把 init 中的工作转移到 UITabBarController 的 viewDidLoad 中。

> 惰性容器中的视图，会根据其是否出现在可视区域而反复调用 onAppear 和 onDisapper。但 onAppear 和 onDisappear
> 并非为视图存续期起点和终点。事实上，这些视图（ 惰性容器中的视图 ）一旦被创建，其存续期将持续到惰性容器被销毁为止。请阅读 [ SwiftUI
> 视图的生命周期研究 ](/zh/posts/swiftuilifecycle/) 了解更多内容。

### 通用导航模型

Q：我们正在使用带有路径参数的 NavigationStack，但当用户在 stage manager 中把窗口的大小从 Regular 调整为
Compact 时，我们在 “转换”
路径方面遇到了麻烦。在常规宽度下，我们在详细视图中有一个带有导航堆栈的侧边栏。在紧凑宽度下，我们有一个标签栏，每个标签都有一个导航堆栈。

A：目前最好的方法是建立一个导航状态模型对象，它持有导航状态的规范表示，它可以为你的正常和紧凑显示提供专门的程序绑定。例如，在你的模型中，有多个路径，每个标签都有一个，但在
split view 中，只投射其中一个路径的细节。使用一个共同的底层数据源，并将其投射到 UI
的需求上，这样就可以对该模型进行单元测试，以确保常规和紧凑的投影是一致的。

> 在 SwiftUI 4 中，紧凑和常规分别对应着 NavigationStack 和 NavigationSplitView
> 两种不同的控件。两者有着完全不同的驱动模式。开发者目前仍在尝试创建一个可优雅地同时为两种模式提供路径的模型。阅读 [ SwiftUI 4.0
> 的全新导航系统 ](/zh/posts/new_navigator_of_swiftui_4/) ，了解它们之间的不同。

### 位置偏移的方法与效率

Q：在非线性位置（ 有 2 个轴 ）渲染带有圆形图像最好方法是什么？我目前使用的是 ZStack，图像通过 offset
进行偏移，这样就可以把它们放在我想要的地方，但我不知道这是否是最有效的方法。

A：只要性能足够好，能够满足你的用例那就是可取的方法。对我来说，这似乎是一个完全合理的实现。如果你遇到了性能问题或者希望大幅扩展你所绘制的图片数量，可以试一下
.drawingGroup 和 Canvas APIs ，它们都可以用于更密集地绘制。

> 在 SwiftUI 中，能够实现偏移的手段有很多，例如：offset、alignmentGuide、padding、position
> 等。除了使用习惯外，还应考虑偏移后的视图是否需要会对周边的视图产生影响（ 布局层面 ）。详情请阅读 [ 在 SwiftUI 中实现视图居中的若干种方法
> ](/zh/posts/centering_the_view_in_swiftui/) 。

### NavigationSplitView 的尺寸规则

Q：你好！我已经开始采用 NavigationSplitView，并且非常喜欢它。在有些情况下，我想根据视图是否折叠来做决定（
例如，如果展开，在详细视图中显示一条信息，如果折叠，则显示一个警告或其他指示 ）。我是否可以认为，如果水平尺寸类是紧凑（ compact
）的，它就是折叠的？还是有一个更可靠的判断方法？

A：紧凑（ compact ）确实对应于一个折叠的导航分割视图。

### 如何改善一个包含大量 UITextField 的视图效率

Q：我有一个包含 132 个 UITextField 的 SwiftUI
视图。我知道这个数量很大，但这是由业务逻辑决定的。与内存泄漏进行了大量的较量后，我设法让它工作起来。但是从一个文本字段到下一个文本字段的聚焦感觉不够流畅，而且每当我在一个文本字段中输入一个字母时，我的
CPU 使用率似乎会飙升到 70% — 100%。另外，用 UIKit 实现同样功能的视图，它没有任何的性能问题。

A：如果你在 iOS 上使用 UITextField 遇到性能问题，你可以尝试避免每个视图都是 UITextField ，默认渲染为 Text
，当文本被点击时动态切换为 UITextField 。

### 跨视图层次共享

Q：在数据来自 API 响应的情况下，在多个视图之间共享数据的最佳方式是什么？ 我在 ContentView 中使用了 enviromentObject
作为所有视图的封装器，在每个视图中，我使用 @EnviromentObject 来访问这些数据，对于这种情况，这是最好的方法吗？
这种方法的唯一问题是，当我添加新数据时，内存使用量增加。

A：@EnvironmentObject / environmentObject
可能是跨视图层次共享同一模型的最佳工具。使用它们应该只创建一个实例，然后可以在子视图中读取。这应该不会增加内存的使用（ 如果有的话，请提出反馈
）。如果你向你的模型对象追加越来越多的数据，你可能会增加内存的使用，这是很正常的。如果发生这种情况，克服这种情况的技术是在外部存储上保存一些数据，只在内存中保留最相关的数据和一个标识符，以便能够完全取回其余的数据。

### task vs onAppear

Q：如果同步操作， `.task` 和 `.onAppear` 之间有什么区别吗？换句话说，如果我写 `Color.green.task {
self.someState += }` ，是否能保证在视图第一次出现之前状态一定会改变？我问这个问题是因为我喜欢用 `.task(id:...)`
来代替 `.onAppear` 与 `.onChange(of:)` 。

A：onAppear 和 task 都是在我们第一次在视图上运行 body 之前调用的。对于你的用例，它们在行为上是等同的。

> 阅读 [ 掌握 SwiftUI 的 task 修饰器 ](/zh/posts/mastering_swiftui_task_modifier/)
> 了解更多有关 task 的内容。

### WindowGroup 和 OpenWindowAction

Q：在 macOS
上是否可以在创建新窗口时附加参数？我在同一个子上下文中创建一个新的托管对象，并希望将这个对象发送到一个新的窗口。目前我的做法是在一个单例中保存对子上下文和托管对象的引用，然后用一个
URL 打开一个新窗口，这个 URL 在单例中检查上下文和托管对象。如果我们能用自定义参数启动新窗口，那就更好了。

A：在 macOS Ventura 中，我们在 [ WindowGroup 上引入了新的 API
](https://developer.apple.com/documentation/swiftui/windowgroup/init "for:content:") ，可以让你在打开窗口时向其传递数据。这也可以和 [ OpenWindowAction
](https://developer.apple.com/documentation/swiftui/openwindowaction/)
一起使用。请注意，你的数据需要是可选的，或者指定一个默认值，因为在某些情况下，框架自身也会创建窗口（ 例如，当选择新窗口菜单项 ）。它也可以在 iPadOS
上工作，将创建一个新的场景，即 2/3 或 1/3 分割。

### 在构造函数中初始化 @StateObject

Q：是否有办法在视图中用该视图结构参数初始化一个 @StateObject ？

A：可以通过在 init 方法中手动初始化 @StateObject 来实现。 `self._store =
StateObject(wrappedValue: Store(id: id))`
。澄清一下。下划线会让它看起来有点诡异，但访问底层存储并没有错。官方文档主要试图指出人们最常见的用法，这样他们就不会一开始就试图直接初始化他们的属性包装器。顺便提一下，试图通过底层存储来初始化
@State 是我们在过去警告过的事情。不是因为它不能工作，而是因为如果你不深入了解 @State 和身份（ identity
）的工作原理，它的行为就会相当混乱。

> 属性包装器（ property wrapper ）类型在编译的时候，首先会对用户自定义的属性包装类型代码进行转译。有关下划线的含义和用法，请参阅 [
>
> > 为自定义属性包装类型添加类 @Published 的能力 ](/zh/posts/adding-published-ability-to-custom-
> > property-wrapper-types/) 。

![image-20221022135326560](https://cdn.fatbobman.com/image-20221022135326560.png)

### San Francisco 宽度风格

Q：如何在 SwiftUI 中如何使用 SF 字体家族新增的三种宽度风格（ Compressed、Condensed、Expanded ）？

A：你可以使用 fontWidth 修饰器来进行调整。

> 很遗憾，仅支持 SF，对中文没有效果。阅读 [ How to change SwiftUI Font Width
> ](https://sarunw.com/posts/swiftui-font-width/) 一文，了解具体用法。

![image-20221022135907441](https://cdn.fatbobman.com/image-20221022135907441.png)

### 为 Stepper 添加快捷键

Q：我们如何为 SwiftUI 的 Stepper（ 在 MacOS 上 ）添加增量和减量操作的快捷键？

A：实现近似行为的方法是在菜单中使用命令来提供相同的操作。通常情况下，应该有列表让人们知道有哪些键盘快捷键可用。但是，如果这不适合你的使用情况，我们会对这方面的增强请求反馈感兴趣。

> 可以通过将包含快捷键的 Button 隐藏起来实现类似的需求

    struct ContentView: View {
        @State var value = 10
        var body: some View {
            Form {
                Stepper(value: $value, in: 0...100, label: { Text("Value:\(value)") })
                    .background(
                        VStack {
                            Button("+") { value += value < 100 ? 1 : 0 }.keyboardShortcut("+",modifiers: [])
                            Button("-") { value -= value > 1 ? 1 : 0 }.keyboardShortcut("-",modifiers: [])
                        }.frame(width: 0).opacity(0)
                    )
            }
        }
    }

### LabeledContent

Q：Label 有时被（ 误 ）用来为一个值提供文字说明（ 例如，账户余额为 10 美元 ），但一些开发人员没有意识到这个说明在 VoiceOver
中无法被读取。除了我们创建一个 LabeledValue 组件外，SwiftUI 是否提供了其他的解决方案？

A：SwiftUI 现在有一个 [ LabeledContent
](https://developer.apple.com/documentation/swiftui/labeledcontent)
视图，你可以用它来给一些内容加上标签。LabeledContent 包含内置的格式化支持！例如 `LabeledContent("Age", value:
person.age, format: .number)` 。

> 阅读 [ Mastering LabeledContent in SwiftUI
>
> > ](https://swiftwithmajid.com/2022/07/13/mastering-labeledcontent-in-
> > swiftui/) ，了解有关 LabeledContent 的更多用例。

### ViewBuilder 中的 if 语句

Q：我知道 SwiftUI 是基于 ResultBuilder 的。所以 if 语句通过树状结构与 buildEither 进行操作。那么在 SwiftUI
中使 if 语句是否有什么注意事项？

A：关于 if/else 需要注意的是，它们如何影响视图的身份，我们在 WWDC 上有一个很好的 [ 演讲
](https://developer.apple.com/videos/play/wwdc2021/10022/) 。

> 在某些情况下，利用惰性视图修饰器，不仅可以保持视图身份的稳定，同时也能获得 SwiftUI 更多的优化。例如用 `.opacity(value <
10 ? 1 : 0.5)` 代替 `if value < 10 {} else {}`

### @State 的初始化

Q：在启动时设置 @State var 值的正确方法是什么？我知道 @State 应该是一个内部值，但在某些情况下，我们需要从外部传入一个值，这对于
onAppear 似乎并不可行。下面的方法由于某种原因并不总是有效。

    init(id: UUID) {
        self._store = StateObject(wrappedValue: Store(id: id))
    }

> 开发人员应该是没理解提问者的疑问，给出了同上面 StateObject 一样的回答。提问者应该是想通过在父视图中不断修改 id 的参数值，来重新初始化
> State 的值。这就涉及到了所有符合 DynamicProperty
> 协议的属性包装器的一个特点：在视图的生存期内仅有第一次初始化的实例会与视图创建关联。详细请阅读 [ 避免 SwiftUI 视图的重复计算
> ](/zh/posts/avoid_repeated_calculations_of_swiftui_views/)
> 。从父视图通过环境值进行传递应该可以满足提问者当前的需求：父视图可以传入新值，当前视图也可以在视图范围内改变该值。

## 总结

我忽略掉了没有获得结论的问题。希望上述的整理能够对你有所帮助。

# SwiftData 中的并发编程

在 Core Data 中进行并发编程可能并不困难，但是充满了陷阱。即使对 Core Data
有充分的经验，稍有疏忽也可能在代码中埋下隐患，从而使应用程序变得不安全。SwiftData 作为 Core Data
的继任者，提供了一种更加优雅、更加安全的并发编程机制。本文将介绍 SwiftData 是如何解决这些问题的，并为开发者提供更好的并发编程体验。

> 本文的内容中将涉及 Swift 中的 async/await、Task、Actor 等并发处理功能。读者需要具备一定的 Swift 并发编程经验。

## 用串行队列来避免数据竞争

我们经常说，Core Data
中的托管对象实例（NSManagedObject）和托管对象上下文（NSManagedObjectContext）不是线程安全的。那么，为什么会出现不安全的问题？Core
Data 解决这个问题的方式又是什么呢？

其实，主要的不安全点就出在数据竞争上（在多线程环境中同时对同一个数据进行修改操作）。Core Data
通过在串行队列中对托管对象实例和托管对象上下文实例进行操作，从而避免数据竞争问题。这也是为什么我们需要将操作代码放置在 `perform` 或 `performAndWait` 的闭包中。

对于视图上下文（viewContext）和其中注册的托管对象实例，开发者应该在主线程队列中进行操作。同样，对于私有上下文和其中注册的托管对象，我们应该在私有上下文所创建的串行队列中进行操作。
`perform` 方法将保证所有的操作都在正确的队列中进行。

> 阅读 [ 关于 Core Data 并发编程的几点提示 ](/zh/posts/concurrencyofcoredata/)
> 一文，详细了解不同类型的托管对象上下文、串行队列、 `perform` 的使用方法以及其他在 Core Data 中进行并发编程的注意事项。

从理论上讲，只要我们严格按照上述要求进行编程，就可以在 Core Data 中避免大多数并发问题。因此，开发者经常会编写类似以下的代码：

    func updateItem(_ item: Item, timestamp: Date?) async throws {
        guard let context = item.managedObjectContext else { throw MyError.noContext }
        try await context.perform {
            item.timestamp = timestamp
            try context.save()
        }
    }

当代码中存在大量的 perform 方法时，会降低代码的可读性。这也是许多开发者所抱怨的问题。

## 如何创建使用私有队列的 ModelContext

在 Core Data 中，开发者可以使用一种十分明确的方式来创建不同类型的托管对象上下文：

    // view context - main queue concurrency type
    let viewContext = container.viewContext
    let mainContext = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)

    // private context - private queue concurrency type
    let privateContext = container.newBackgroundContext()

    let privateContext = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType)

甚至可以在私有上下文中直接进行操作，而无需显式创建。

    container.performBackgroundTask{ context in
        ...
    }

然而，SwiftData 对 ModelContext（ NSManagedObjectContext 的包装版本
）的创建逻辑进行了调整。新创建的上下文的类型取决于其所处的队列。换句话说，在主线程上创建的 ModelContext 将自动使用主线程队列（ com.
apple. main-thread ），而在其他线程（ 非主线程 ）上创建的 ModelContext 将使用私有队列。

    Task.detached {
        let privateContext = ModelContext(container)
    }

特别需要注意的是，当通过 Task. init 创建一个新的任务时，它会继承创建它的父任务或 Actor
的执行上下文。这意味着，通过下面的代码，并不能创建出使用私有队列的 ModelContext：

    // In SwiftUI View
    Button("Create New Context"){
        let container = modelContext.container
        Task{
            // Using main queue, not background context
            let privateContext = ModelContext(container)
        }
    }

    SomeView()
        .task {
            // Using main queue, not background context
            let privateContext = ModelContext(modelContext.container)
        }

这是因为在 SwiftUI 中，视图的 body 被标注为 `@MainActor` ，因此建议使用 `Task.detached`
来确保在非主线程上创建使用私有队列的 ModelContext。

> 在主线程上创建的 ModelContext 是一个独立的实例，与 ModelContainer 实例的 mainContext
> 属性提供的上下文实例并不相同。尽管它们都在主队列上进行操作，但它们分别管理着独立的注册对象。

## Actor：串行队列更优雅的实现

从 5.5 版本开始，Swift 引入了 Actor 的概念。与串行队列一样，它们可以用于解决数据竞争问题，并确保数据的一致性。与通过 `perform` 方法运行在特定串行队列上的方式相比，Actor 提供了一种更高级和更优雅的实现方式。

> 每个 Actor 都有一个关联的串行队列，用于执行其方法和任务。这个队列基于 GCD，由 GCD 负责底层线程管理和任务调度。这样可以确保 Actor
> 的方法和任务以串行方式执行，即同一时间只能有一个任务在执行。这保证了 Actor 内部的状态和数据在任何时候都是线程安全的，避免了并发访问的问题。

尽管从理论上来说，可以使用 Actor 来限制代码对托管对象上下文和托管对象的操作，但由于之前的 Swift 版本并没有提供自定义 Actor
执行者（Executor）的能力，这种方式并没有被采用。好在，Swift 5.9 版本弥补了之前的遗憾，让 SwiftData 通过 Actor
提供了更加优雅的并发编程体验。

> [ Custom Actor Executors ](https://github.com/apple/swift-
> evolution/blob/main/proposals/0392-custom-actor-executors.md#custom-actor-
> executors) : 该提案介绍了一种自定义 Swift Actor 执行器的基本机制。通过提供执行器的实例，Actor
> 可以影响它们运行任务的执行位置，同时保持 Actor 模型所保证的互斥性和隔离性。

得益于 Swift 的新功能 “宏”，在 SwiftData 中，创建一个对应特定串行队列的 Actor 十分容易：

    @ModelActor
    actor DataHandler {}

通过为该 Actor 添加更多数据操作逻辑代码，开发者可以安全地使用该 Actor 实例来操作数据。

    extension DataHandler {
        func updateItem(_ item: Item, timestamp: Date) throws {
            item.timestamp = timestamp
            try modelContext.save()
        }

        func newItem(timestamp: Date) throws -> Item {
            let item = Item(timestamp: timestamp)
            modelContext.insert(item)
            try modelContext.save()
            return item
        }
    }

你可以使用以下方式调用上述代码：

    let handler = DataHandler(modelContainer: container)
    let item = try await handler.newItem(timestamp: .now)

之后，无论在哪个线程中调用 `DataHandler` 的方法，这些操作都将在一个特定的串行队列中进行。开发者再也不用为编写大量包含 `perform` 的代码而苦恼了。

还记得上一节讨论的创建 ModelContext 应注意的事项吗？在创建一个通过 ModelActor 宏构建的实例时，所采用的规则也是一样的。新创建的
Actor 实例所采用的串行队列类型取决于创建它的线程。

    Task.detached {
        // Using private queue
        let handler = DataHandler(modelContainer: container)
        let item = try await handler.newItem(timestamp: .now)
    }

## ModelActor 宏的秘密

ModelActor 宏到底有什么魔法？而 SwiftData 又是如何确保 Actor 的执行序列与 ModelContext 使用的串行队列保持一致呢？

通过在 Xcode 中展开 ModelActor 宏，我们可以看到生成的完整代码：

    actor DataHandler {
        nonisolated let modelExecutor: any SwiftData.ModelExecutor
        nonisolated let modelContainer: SwiftData.ModelContainer
        init(modelContainer: SwiftData.ModelContainer) {
            let modelContext = ModelContext(modelContainer)
            modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)
            self.modelContainer = modelContainer
        }
    }

    extension DataHandler: SwiftData.ModelActor {}

    // The code below is not generated by ModelActor
    public protocol ModelActor : Actor {

        /// The ModelContainer for the ModelActor
        /// The container that manages the app’s schema and model storage configuration
        nonisolated var modelContainer: ModelContainer { get }

        /// The executor that coordinates access to the model actor.
        ///
        /// - Important: Don't use the executor to access the model context. Instead, use the
        /// ``context`` property.
        nonisolated var modelExecutor: ModelExecutor { get }

        /// The optimized, unonwned reference to the model actor's executor.
        nonisolated public var unownedExecutor: UnownedSerialExecutor { get }

        /// The context that serializes any code running on the model actor.
        public var modelContext: ModelContext { get }

        /// Returns the model for the specified identifier, downcast to the appropriate class.
        public subscript<T>(id: PersistentIdentifier, as as: T.Type) -> T? where T : PersistentModel { get }
    }

通过代码可以看出，在构造过程中主要会进行两个操作：

- 使用传入的 ModelContainer 创建一个 ModelContext 实例。

构造方法运行在哪个线程，决定了创建的 ModelContext 所采用的串行队列，从而也影响了 Actor 的执行队列。

- 根据新创建的 ModelContext，创建一个 DefaultSerialModelExecutor（自定义的 Actor 执行者）。

DefaultSerialModelExecutor 是 SwiftData 声明的 Actor 执行者。它的主要职责是将传入的 ModelContext
实例使用的串行队列作为当前 Actor 实例的执行队列。

为了判断 DefaultSerialModelExecutor 的作用是否和我们预期的一样，我们可以通过下面的代码进行验证：

    import SwiftDataKit

    actor DataHandler {
        nonisolated let modelExecutor: any SwiftData.ModelExecutor
        nonisolated let modelContainer: SwiftData.ModelContainer
        init(modelContainer: SwiftData.ModelContainer) {
            let modelContext = ModelContext(modelContainer)
            modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)
            self.modelContainer = modelContainer
        }

        func checkQueueInfo() {
            // Get Actor run queue label
            let actorQueueLabel = DispatchQueue.currentLabel
            print("Actor queue:",actorQueueLabel)
            modelContext.managedObjectContext?.perform {
                // Get context queue label
                let contextQueueLabel = DispatchQueue.currentLabel
                print("Context queue:",contextQueueLabel)
            }
        }
    }

    extension DataHandler: SwiftData.ModelActor {}

    // get current dispatch queue label
    extension DispatchQueue {
        static var currentLabel: String {
            return String(validatingUTF8: __dispatch_queue_get_label(nil)) ?? "unknown"
        }
    }

> [ SwiftDataKit ](/zh/posts/use-core-data-features-in-swiftdata-by-
> swiftdatakit/) 将让开发者能够访问 SwiftData 元素底层的 Core Data 对象。

在 `checkQueueInfo` 方法中，我们分别获取并打印了当前 actor 的执行序列和托管对象上下文对应的队列的名称。

    Task.detached {
        // create handler in non-main thread
        let handler = DataHandler(modelContainer: container)
        await handler.checkQueueInfo()
    }

    // Output
    Actor queue: NSManagedObjectContext 0x600003903b50
    Context queue: NSManagedObjectContext 0x600003903b50

当在非主线程上创建 DataHandler 实例时，托管对象上下文将创建一个名为 NSManagedObjectContext +
地址的私有串行队列，Actor 的执行队列与其一致。

    Task { @MainActor in
        // create handler in main thread
        let handler = DataHandler(modelContainer: container)
        await handler.checkQueueInfo()
    }

    // Output
    Actor queue: com.apple.main-thread
    Context queue: com.apple.main-thread

在主线程上创建 DataHandler 实例时，托管对象上下文和 Actor 均为主线程队列。

根据输出可以看到，Actor 的执行队列与上下文所使用的队列完全一致，证实了我们之前的猜测。

SwiftData 通过使用 Actor 来确保操作在正确的队列上运行，这也可以给 Core Data 开发者提供启示。可以考虑在 Core Data
中通过自定义的 Actor 执行者来实现类似的功能。

## 通过 PersistentIdentifier 获取数据

在 Core Data 的并发编程中，除了要在正确的队列上进行操作外，另一个重要的原则是不要在上下文之间传递 NSManagedObject
实例。这个规则同样适用于 SwiftData。

如果想在另一个 ModelContext 中对某个 PersistentModel 对应的存储数据进行操作，可以通过传递该对象的
PersistentIdentifier 来解决。PersistentIdentifier 可以被视为 NSManagedObjectId 的
SwiftData 实现。

下面的代码将尝试通过传递进来的 PersistentIdentifier 获取对应的数据并进行修改：

    extension DataHandler {
        func updateItem(identifier: PersistentIdentifier, timestamp: Date) throws {
            guard let item = self[identifier, as: Item.self] else {
                throw MyError.objectNotExist
            }
            item.timestamp = timestamp
            try modelContext.save()
        }
    }

    let handler = DataHandler(container:container)
    try await handler.updateItem(identifier: item.id, timestamp: .now )

在代码中，我们使用了一个 ModelActor 协议提供的下标方法。该方法首先尝试从当前 actor 持有的 ModelContext 中查找是否有对应的
PersistentModel。如果没有的话，它将尝试从行缓存以及持久化存储中获取。可以将其视为 Core Data
NSManagedObjectContext 的 `existingObject(with:)`
方法的对应版本。有趣的是，这个直接穿透到持久化存储的方法只在 ModelActor 协议中提供了实现。从这个角度来看，SwiftData
的开发团队也在有意识地引导开发者使用这种（ ModelActor ）数据操作逻辑。

另外，ModelContext 还提供了两种通过 PersistentIdentifier 获取 PersistentModel 的方法。 `registeredModel(for:)` 对应于 NSManagedObjectContext 的 `registeredObject(for:)` 方法； `model(for:)` 对应于 NSManagedObjectContext 的 `object(with:)` 方法。

    func updateItemInContext(identifier: PersistentIdentifier, timestamp: Date) throws {
        guard let item = modelContext.registeredModel(for: identifier) as Item? else {
            throw MyError.objectNotInContext
        }
        item.timestamp = timestamp
        try modelContext.save()
    }

    func updateItemInContextAndRowCache(identifier: PersistentIdentifier,timestamp: Date) throws {
        if let item = modelContext.model(for: identifier) as? Item {
            item.timestamp = timestamp
            try modelContext.save()
        }
    }

这三种方式的区别如下：

- `existingObject(with:)`

如果上下文识别到了指定的对象，该方法会返回该对象。否则，上下文会从持久化存储中获取并返回一个完全实例化的对象。与 `object(with:)`
方法不同，该方法永远不会返回一个惰值状态的对象。如果对象既不在上下文中，也不在持久化存储中，该方法会抛出一个错误。简单来说，除非该数据在持久化存储上并不存在，否则必然会返回一个非惰值状态的对象。

- `registeredModel(for:)`

此方法只能返回在当前上下文中已注册的对象（标识符相同）。如果找不到，则返回 nil。当返回值为 nil
时，并不表示该对象一定不存在于持久化存储中，只表示该对象未在当前上下文中注册。

- `model(for:)`

即使对象没有在当前上下文中注册，该方法仍会返回一个空的惰值对象——一个占位对象。当用户实际访问该占位对象时，上下文将尝试从持久化存储中获取数据。如果数据不存在，可能会导致应用崩溃。

## 第二道防线

并非每个开发者都会严格按照 SwiftData 所期望的方式（ModelActor）进行并发编程。在代码逐步复杂后，或许会不小心出现访问或设置其他队列上的
PerisistentModel 属性的情况。根据 Core Data 的经验，在开启调试参数 `com.apple.CoreData.ConcurrencyDebug 1` 的情况下，这种访问将必然导致应用崩溃。

> 更多调试参数，请阅读 [ Core Data with CloudKit（四）—— 调试、测试、迁移及其他
> ](/zh/posts/coredatawithcloudkit-4/) 一文。

但是，在 SwiftData 中，尽管我们会收到一些警告信息（ `Capture non-sendable`
），上述操作并不会出现问题，可以正常进行数据访问和修改。这是为什么呢？

下面的代码将在一个非主线程中修改主线程上的 Item 对象属性。点击按钮后，属性修改成功。

    Button("Modify in Wrong Thread") {
        let item = items.first!
        DispatchQueue.global().async {
            print(Thread.current)
            item.timestamp = .now
        }
    }

![modify-in-wrong-thread-demo1_2023-10-09_08.43.38.2023-10-09
08_44_44](https://cdn.fatbobman.com/modify-in-wrong-thread-
demo1_2023-10-09_08.43.38.2023-10-09%2008_44_44.gif)

如果你看过上一篇文章 [ 揭秘 SwiftData 的数据建模原理 ](/zh/posts/unveiling-the-data-modeling-
principles-of-swiftdata/) ，或许会记得其中提到 SwiftData 为 PersistentModel 和 BackingData
提供的 Get 和 Set
方法不仅可以读取和设置属性，还具备队列调度的能力（确保线程安全）。换句话说，即使我们在错误的线程（队列）对属性进行修改，这些方法会自动将操作切换到正确的队列中进行。通过进一步尝试，我们发现这种调度能力至少存在于
BackingData 协议的实现层面。

    Button("Modify in Wrong Thread") {
        let item = items.first!
        DispatchQueue.global().async {
            item.persistentBackingData.setValue(forKey: \.timestamp, to: Date.now)
        }
    }

本节内容并非鼓励大家绕过 ModelActor 的方式进行数据操作，但通过这些细节，我们可以看出 SwiftData
团队为了避免出现线程安全问题而做出了很多努力。

## 总结

或许有人会和我一样，在了解了 SwiftData 新的并发编程方式后，在欣喜之余会有一种说不出来的感觉。经过了一段时间的思考，我似乎找到了这种异样感觉的原因
—— 代码风格。显然，之前在 Core Data 中常用的数据处理逻辑并不完全适用于 SwiftData。那么如何写出更具备 SwiftData
味道的代码呢？如何让数据处理代码与 SwiftUI 更加契合？这是我们今后要研究的课题。

# 如何为 SwiftData 动态的构建复杂的谓词

`NSCompoundPredicate` 让开发者能够将多个 `NSPredicate`
对象组合成一个复合谓词。这一机制特别适用于那些需要基于多重判断标准进行数据过滤的场景。然而，在 Swift 重构的新 Foundation 框架中，缺失了与
`NSCompoundPredicate` 相对应的直接功能，这一变化对希望利用 SwiftData
构建应用的开发者造成了不小的挑战。本文旨在探索如何在当前的技术条件下，利用 `PredicateExpression` ，动态地构建出符合
SwiftData 需求的复杂谓词。

> 2024 年 3 月 11 日更新：在本文发布不到一周的时间里，Noah Kamara 已经开发出了一个与 SwiftData 兼容的谓词合并方案 ——
> [ CompoundPredicate ](https://github.com/NoahKamara/CompoundPredicate)
> 。我在文章末尾提供了对此方案的介绍和说明。

## 挑战：实现灵活的数据筛选功能

在开发新版的 [ 健康笔记 ](/healthnotes/) 应用时，我决定使用 SwiftData 替换传统的 Core Data，以便利用 Swift
语言的现代特性。这个以数据管理为中心的应用的核心之一是提供给用户一个灵活且强大的数据筛选功能。在这个过程中，我面临着一个关键的挑战：如何为用户检索数据构建多样化的筛选方案。这里是一些用于检索
Memo 实例的谓词：

    extension Memo {
      public static func predicateFor(_ filter: MemoPredicate) -> Predicate<Memo>? {
        var result: Predicate<Memo>?
        switch filter {
        case .filterAllMemo:
          // nil
          break
        case .filterAllGlobalMemo:
          result = #Predicate<Memo> { $0.itemData == nil }
        case let .filterAllMemoOfRootNote(noteID):
          result = #Predicate<Memo> {
            if let itemData = $0.itemData, let item = itemData.item, let note = item.note {
              return note.persistentModelID == noteID || note.parent?.persistentModelID == noteID
            } else {
              return false
            }
          }
        case .filterMemoWithImage:
          result = #Predicate<Memo> { $0.hasImages }
        case .filterMemoWithStar:
          result = #Predicate<Memo> { $0.star }
        case let .filterMemoContainsKeyword(keyword):
          result = #Predicate<Memo> {
            if let content = $0.content {
              return content.localizedStandardContains(keyword)
            } else {
              return false
            }
          }
        }
        return result
      }
    }

在应用的早期版本中，用户能够灵活组合筛选条件，比如结合是否包含星标与图片，或是按特定笔记和关键词进行筛选。过去，这种动态组合的需求可以通过 `NSCompoundPredicate` 轻松实现，它允许开发者动态地组合多个谓词，并将结果用作 Core Data 的检索条件。然而，使用
SwiftData 后，我发现缺少了相应的功能来动态地组合 Swift
Predicate，这对于应用的核心功能是一个重大的制约。解决这一问题对于保持应用的功能性和用户满意度至关重要。

## 组合 NSPredicate 的方法

`NSCompoundPredicate` 提供了一种强大的方式，使开发者能够动态地将多个 `NSPredicate`
实例组合成一个复合谓词。以下是一个示例，演示了如何使用 `AND` 逻辑操作符将两个独立的谓词 `a` 和 `b` 组合成一个新的谓词：

    let a = NSPredicate(format: "name = %@", "fat")
    let b = NSPredicate(format: "age < %d", 100)
    let result = NSCompoundPredicate(type: .and, subpredicates: [a,b])

此外，由于 `NSPredicate` 允许通过字符串来构建谓词，开发者可以利用这一特性通过组合 `predicateFormat`
属性来手动构建新的谓词表达式。这种方法提供了额外的灵活性，允许开发者直接操作和组合已存在谓词的字符串表示形式：

    let a = NSPredicate(format: "name = %@", "fat")
    let b = NSPredicate(format: "age < %d", 100)
    let andFormatString = a.predicateFormat + " AND " + b.predicateFormat // name == "fat" AND age < 100
    let result = NSPredicate(format: andFormatString)

不幸的是，尽管这些方法在使用 `NSPredicate` 时非常有效和灵活，但它们不适用于 Swift Predicate。这意味着在转向使用
SwiftData 时，我们需要探索新的方法来实现类似的动态谓词组合功能。

## 组合 Swift Predicate 的挑战

在之前的文章“ [ Swift Predicate: 用法、构成及注意事项 ](/zh/posts/swift-predicate-usage-
composition-and-considerations/) ”中，我们详细探讨了 Swift Predicate
的结构和构成。简而言之，开发者通过声明满足 `PredicateExpression` 协议的类型，进而构建 `Predicate`
结构体。由于这个过程可能相当复杂，Foundation 为此提供了 `#Predicate` 宏，以简化这一操作。

当我们构建 Swift Predicate 时， `#Predicate` 宏会自动转换这些运算符为相应的谓词表达式：

    let predicate = #Predicate<People> { $0.name == "fat" && $0.age < 100 }

宏展开后，我们可以看到谓词表达式的详细构成：

    Foundation.Predicate<People>({
        PredicateExpressions.build_Conjunction(
            lhs: PredicateExpressions.build_Equal(
                lhs: PredicateExpressions.build_KeyPath(
                    root: PredicateExpressions.build_Arg($0),
                    keyPath: \.name
                ),
                rhs: PredicateExpressions.build_Arg("fat")
            ),
            rhs: PredicateExpressions.build_Comparison(
                lhs: PredicateExpressions.build_KeyPath(
                    root: PredicateExpressions.build_Arg($0),
                    keyPath: \.age
                ),
                rhs: PredicateExpressions.build_Arg(100),
                op: .lessThan
            )
        )
    })

在这里， `PredicateExpressions.build_Conjunction` 创建一个对应 `&&` 操作符的 `PredicateExpressions.Conjunction`
表达式。它将两个布尔返回值的表达式连接，形成一个完整的表达式。如果我们能够单独提取并组合 Swift Predicate
中的表达式，理论上就可以动态组合基于 `AND` 逻辑的谓词。

> `||` 和 `!` 对应的表达式类型分别是 `PredicateExpressions.Disjunction` 和 `PredicateExpressions.Negation` 。

考虑到 Swift Predicate 提供了一个 `expression` 属性，自然地，我们会考虑利用该属性来实现这种动态组合：

    let a = #Predicate<People1> { $0.name == "fat"}
    let b = #Predicate<People1> { $0.age < 10 }
    let combineExpression = PredicateExpressions.build_Conjunction(lhs: a.expression, rhs: b.expression)

然而，尝试上述代码会遇到编译错误：

    Type 'any StandardPredicateExpression<Bool>' cannot conform to 'PredicateExpression'

深入探究 `Predicate` 结构体和 `PredicateExpressions.Conjunction` 的实现，我们发现了其中的制约因素：

    public struct Predicate<each Input> : Sendable {
        public let expression : any StandardPredicateExpression<Bool>
        public let variable: (repeat PredicateExpressions.Variable<each Input>)

        public init(_ builder: (repeat PredicateExpressions.Variable<each Input>) -> any StandardPredicateExpression<Bool>) {
            self.variable = (repeat PredicateExpressions.Variable<each Input>())
            self.expression = builder(repeat each variable)
        }

        public func evaluate(_ input: repeat each Input) throws -> Bool {
            try expression.evaluate(
                .init(repeat (each variable, each input))
            )
        }
    }

    extension PredicateExpressions {
        public struct Conjunction<
            LHS : PredicateExpression,
            RHS : PredicateExpression
        > : PredicateExpression
        where
            LHS.Output == Bool,
            RHS.Output == Bool
        {
            public typealias Output = Bool

            public let lhs: LHS
            public let rhs: RHS

            public init(lhs: LHS, rhs: RHS) {
                self.lhs = lhs
                self.rhs = rhs
            }

            public func evaluate(_ bindings: PredicateBindings) throws -> Bool {
                try lhs.evaluate(bindings) && rhs.evaluate(bindings)
            }
        }

        public static func build_Conjunction<LHS, RHS>(lhs: LHS, rhs: RHS) -> Conjunction<LHS, RHS> {
            Conjunction(lhs: lhs, rhs: rhs)
        }
    }

问题在于 `expression` 属性类型为 `any StandardPredicateExpression<Bool>`
，它不包含足够的信息来标识具体的 `PredicateExpression` 实现类型。由于 `Conjunction`
需要具体的左右子表达式类型来初始化，因此我们就无法直接使用 `expression` 属性来动态构建新的组合表达式。

## 动态构建 Predicate 的策略

虽然无法直接利用 Swift Predicate 的 `expression`
属性，我们仍有其他途径来实现动态构建谓词的目标。关键在于理解如何从现有的谓词中提取或独立创建表达式，并利用如 `build_Conjunction` 或
`build_Disjunction` 这样的表达式构建器来生成新的谓词表达式。

### 利用 `#Predicate` 宏构建表达式

直接基于表达式类型构建谓词可能非常繁琐。一个更实用的方法是利用 `#Predicate`
宏，这样开发者可以间接地构建和提取谓词表达式。这种方法的灵感来源于社区成员 [ nOk
](https://stackoverflow.com/users/11450810/nok) 在 [ stackoverflow
](https://stackoverflow.com/a/76861465/12260342) 的贡献。

例如，我们有以下使用 `#Predicate` 宏构建的谓词：

    let filterByName = #Predicate<People> { $0.name == "fat" }

通过查看宏展开后的代码，我们可以提取出构成谓词的表达式部分：

![image-20240304161732812](https://cdn.fatbobman.com/image-20240304161732812-zipic.png)

由于在构建表达式（PredicateExpression）实例时，还要根据表达式的类型为其提供不同的参数，因此，使用下面的方式无法生成正确的表达式：

    let expression = PredicateExpressions.build_Equal(
      lhs: PredicateExpressions.build_KeyPath(
          root: PredicateExpressions.build_Arg($0), // error: Anonymous closure argument not contained in a closure
          keyPath: \.name
      ),
      rhs: PredicateExpressions.build_Arg("fat")
    )

尽管我们不能直接复制表达式来创建新的 `PredicateExpression` 实例，但我们可以通过定义一个闭包来重新创建相同的表达式：

    let expression = { (people: PredicateExpressions.Variable<People>) in
      PredicateExpressions.build_Equal(
          lhs: PredicateExpressions.build_KeyPath(
              root: PredicateExpressions.build_Arg(people),
              keyPath: \.name
          ),
          rhs: PredicateExpressions.build_Arg("fat")
      )
    }

### 创建参数化的表达式闭包

由于表达式的右侧值（如 `"fat"` ）可能需要动态赋值，我们可以设计一个返回表达式闭包的闭包，这样可以在运行时确定要比较的名字：

    let filterByNameExpression = { (name: String) in
      { (people: PredicateExpressions.Variable<People>) in
        PredicateExpressions.build_Equal(
          lhs: PredicateExpressions.build_KeyPath(
            root: PredicateExpressions.build_Arg(people),
            keyPath: \.name
          ),
          rhs: PredicateExpressions.build_Arg(name)
        )
      }
    }

使用这个返回表达式的闭包，我们可以动态构建谓词：

    let name = "fat"
    let predicate = Predicate<People>(filterByNameExpression(name))

### 组合表达式以构建新的谓词

一旦我们声明了返回表达式的闭包，就可以结合使用 `PredicateExpressions.build_Conjunction`
或其他逻辑构建器来创建包含复杂逻辑的新谓词：

    // #Predicate<People> { $0.age < 10 }
    let filterByAgeExpression = { (age: Int) in
      { (people: PredicateExpressions.Variable<People>) in
        PredicateExpressions.build_Comparison(
            lhs: PredicateExpressions.build_KeyPath(
                root: PredicateExpressions.build_Arg(people),
                keyPath: \.age
            ),
            rhs: PredicateExpressions.build_Arg(age),
            op: .lessThan
        )
      }
    }

    // Combine new Predicate
    let predicate = Predicate<People> {
      PredicateExpressions.Conjunction(
        lhs: filterByNameExpression(name)($0),
        rhs: filterByAgeExpression(age)($0)
      )
    }

完整流程如下：

1. 使用 `#Predicate` 宏构建初始谓词。
2. 从宏展开的代码中提取表达式，创建生成表达式的闭包。
3. 结合布尔逻辑表达式（例如 `Conjunction` ）将两个表达式组合成一个新的表达式，进而构建新的谓词实例。
4. 如需组合多个表达式，重复以上步骤。

这种方法虽然需要一些额外的步骤来手动创建和组合表达式，但它为动态构建复杂的 Swift Predicate 提供了可能。

### 动态组合表达式

掌握了从谓词到表达式，再从表达式回到谓词的完整流程后，我现在需要创建一个方法，该方法能够根据需求动态组合表达式并生成谓词，以满足我当前项目的具体需求。

参考了 Jeremy Schonfeld 在 [ Swift Forums ](https://forums.swift.org/t/pitch-
swift-predicates/62000/50) 提供的示例，我们可以构建一个动态合成用于检索 Memo 数据的谓词的方法，如下所示：

    extension Memo {
      static func combinePredicate(_ filters: [MemoPredicate]) -> Predicate<Memo> {
        func buildConjunction(lhs: some StandardPredicateExpression<Bool>, rhs: some StandardPredicateExpression<Bool>) -> any StandardPredicateExpression<Bool> {
          PredicateExpressions.Conjunction(lhs: lhs, rhs: rhs)
        }

        return Predicate<Memo>({ memo in
          var conditions: [any StandardPredicateExpression<Bool>] = []
          for filter in filters {
            switch filter {
            case .filterAllMemo:
              conditions.append(Self.Expressions.allMemos(memo))
            case .filterAllGlobalMemo:
              conditions.append(Self.Expressions.allGlobalMemos(memo))
            case let .filterAllMemoOfRootNote(noteID):
              conditions.append(Self.Expressions.memosOfRootNote(noteID)(memo))
            case .filterMemoWithImage:
              conditions.append(Self.Expressions.memoWithImage(memo))
            case .filterMemoWithStar:
              conditions.append(Self.Expressions.memosWithStar(memo))
            case let .filterMemoContainsKeyword(keyword):
              conditions.append(Self.Expressions.memosContainersKeyword(keyword)(memo))
            }
          }
          guard let first = conditions.first else {
            return PredicateExpressions.Value(true)
          }

          let closure: (any StandardPredicateExpression<Bool>, any StandardPredicateExpression<Bool>) -> any StandardPredicateExpression<Bool> = {
            buildConjunction(lhs: $0, rhs: $1)
          }

          return conditions.dropFirst().reduce(first, closure)
        })
      }
    }

使用示例：

    let predicate = Memo.combinePredicate([.filterMemoWithImage,.filterMemoContainsKeyword(keyword: "fat")])

在当前的实现中，由于 Swift 的强类型系统（每种筛选逻辑对应着特定的谓词表达式类型），构建一个与 `NSCompoundPredicate`
相似的灵活且通用的组合机制显得相对复杂。我们面临的挑战在于如何在保持类型安全的同时，实现足够灵活的表达式组合策略。

对于我的应用场景，主要需求是处理 `Conjunction` （逻辑与）类型的组合，这种情况相对简单直接。如果未来的需求扩展到包括 `Disjunction`
（逻辑或）的情况，我们就必须在组合过程中引入额外的逻辑判断和标识，以确保可以灵活地应对不同的逻辑组合需求，同时保持代码的可读性和可维护性。这可能需要更细致的设计，以适应多变的组合逻辑，同时确保不牺牲
Swift 的类型安全特性。

> [ 在此 ](https://gist.github.com/fatbobman/8e10c7a811c6cd384b943d1a25206b7b)
> 可查看完整代码。

## 一个无法应用于 SwiftData 的组合实现

> Noah Kamara 提供的更新后的解决方案，请参阅下一节内容。

Noah Kamara 在其 [ Gist
](https://gist.github.com/NoahKamara/d8660881b2ef8d6be18b8e26ed349bb7)
中展示了一段代码，提供了类似于 `NSCompoundPredicate` 能力，使得组合 Swift Predicate
变得简便快捷。这种方法看起来是一个直观且强大的解决方案：

    let people = People(name: "fat", age: 50)
    let filterByName = #Predicate<People> { $0.name == "fat" }
    let filterByAge = #Predicate<People> { $0.age < 10 }
    let combinedPredicate = [filterByName, filterByAge].conjunction()
    try XCTAssertFalse(combinedPredicate.evaluate(people)) // return false

尽管这种方法极具吸引力，我们却不能在 SwiftData 中采用。为什么这种表面上完美的解决方案会在 SwiftData 中遇到障碍呢？

Noah Kamara 在代码中引入了一个名为 `VariableWrappingExpression` 的自定义类型，这个类型实现了 `StandardPredicateExpression` 协议，用以封装从 Predicate 的 `expression`
属性中提取的表达式。这种封装方法并不涉及到表达式的具体类型，它在评估谓词时仅调用被封装表达式的评估方法。

    struct VariableWrappingExpression<T>: StandardPredicateExpression {
        let predicate: Predicate<T>
        let variable: PredicateExpressions.Variable<T>

        func evaluate(_ bindings: PredicateBindings) throws -> Bool {
            // resolve the variable
            let value = try variable.evaluate(bindings)

            // create bindings for the expression of the predicate
            let innerBindings = bindings.binding(predicate.variable, to: value)

            return try predicate.expression.evaluate(innerBindings)
        }
    }

在非 SwiftData 环境下，这种动态组合的谓词可以正常工作，因为它直接依赖于 Swift Predicate 的评估逻辑。然而，SwiftData
的工作机制有所不同。在使用 SwiftData 筛选数据时，并不会直接调用 Swift Predicate 的评估方法。相反，SwiftData 会解析
Predicate 的 `expression` 属性中表达式树，并将这些表达式转换为 SQL 语句，以便在 SQLite
数据库中执行数据检索。这意味着评估过程实际上是通过生成并执行 SQL 指令来完成的，完全在数据库层面上操作。

因此，当 SwiftData 尝试将这种动态组合的谓词转换为 SQL 指令时，由于无法识别自定义的 `VariableWrappingExpression` 类型，就会导致出现 `unSupport Predicate` 的运行时错误。

如果你的场景不涉及在 SwiftData 中使用谓词，那么 Noah Kamara 的方案可能是一个很好的选择。如果你的需求是在 SwiftData
环境中构建动态组合的谓词，可能仍需要依赖于本文介绍的策略。

## CompoundPredicate：可用于 SwiftData 的谓词合并方案

在之前的讨论中，我们揭示了一个主要障碍，即开发者无法直接利用 Predicate 的 `expression`
属性来合成复杂谓词，因为缺少了具体的谓词表达式类型。本文发布几天后，Noah Kamara 推出了一个创新的方案—— [ CompoundPredicate
](https://github.com/NoahKamara/CompoundPredicate/) ，这一新策略放弃了之前依赖自定义 `StandardPredicateExpression` 的实现方法，转而采用类型转换的策略，有效地将 `expression`
的信息具体化。这一改进意味着开发者可以避免手动提取和组合表达式的繁琐过程。

Noah Kamara 设计了 `VariableReplacing` 协议，并为 PredicateExpression
的每种类型实现了这一协议，如下所示：

    public protocol VariableReplacing<Output>: PredicateExpression {
        associatedtype Output
        typealias Variable<T> = PredicateExpressions.Variable<T>
        func replacing<T>(_ variable: Variable<T>, with replacement: Variable<T>) -> Self
    }

    extension PredicateExpressions.Variable: VariableReplacing {
        public func replacing<T>(_ variable: Variable<T>, with replacement: Variable<T>) -> Self {
            if let replacement = replacement as? Self, variable.key == key {
                return replacement
            } else {
                return self
            }
        }
    }

这种方法使得在谓词组合过程中能自动获得 Predicate 内部表达式的确切类型，实现了谓词组合的自动化和高效化。

    let notTooShort = #Predicate<Book> {
        $0.pages > 50
    }

    let notTooLong = #Predicate<Book> {
        $0.pages <= 350
    }

    let lengthFilter = [notTooShort, notTooShort].conjunction()

    // Match Books that are just the right length
    let titleFilter = #Predicate<Book> {
        $0.title.contains("Swift")
    }

    // Match Books that contain "Swift" in the title or
    // are just the right length
    let filter = [lengthFilter, titleFilter].disjunction()

重要的是，这种方案不会引入 SwiftData 不能识别的表达式，因此合并后的谓词能够直接被 SwiftData
使用。这一方案可谓是在官方发布更加完善的解决方案前，为开发者提供的一种最理想的临时策略。

## 优化 Swift Predicate 表达式的编译效率

构建复杂的 Swift Predicate 表达式可能会对编译效率产生显著影响。Swift
编译器在处理这些表达式时，需要解析并生成复杂的类型信息。当表达式过于复杂时，编译器所需的类型推断时间可能会急剧增加，导致编译过程变慢。

考虑以下谓词示例：

    let result = #Predicate<Memo> {
      if let itemData = $0.itemData, let item = itemData.item, let note = item.note {
        return note.persistentModelID == noteID || note.parent?.persistentModelID == noteID
      } else {
        return false
      }
    }

在这个例子中，即使是微小的代码更改也可能导致该文件的编译时间超过 10 秒。这种延迟在使用闭包生成表达式时也会出现。为了缓解这一问题，我们可以利用
Xcode 的辅助功能来明确表达式的类型。在闭包上使用 Option + 点击，可以揭示表达式的确切类型，进而允许我们为闭包的返回值提供明确的类型注解。

![image-20240304183427052](https://cdn.fatbobman.com/image-20240304183427052-zipic.png)

    let memosWithStar = { (memo: PredicateExpressions.Variable<Memo>) -> PredicateExpressions.KeyPath<PredicateExpressions.Variable<Memo>, Bool> in
      PredicateExpressions.build_KeyPath(
        root: PredicateExpressions.build_Arg(memo),
        keyPath: \.star
      )
    }

上述复杂谓词中的表达式具体类型如下所示：

![image-20240304202411294](https://cdn.fatbobman.com/image-20240304202411294-zipic.png)

明确表达式的类型可以帮助编译器更快地处理代码，能显著提高整体的编译效率，因为它避免了编译器在类型推断上所花费的时间。

> 本策略不仅适用于需要组合谓词的情况，即使是不涉及谓词组合但逻辑复杂的谓词也会面临同样的编译挑战。通过提取表达式、明确标注类型，开发者可以显著改善复杂谓词的编译时间，确保更高效的开发体验。

## 总结

本文探讨了在 SwiftData 环境中动态构建复杂谓词的方法。虽然当前的解决方案可能不如我们期望的那样优雅直接，但它们确实提供了一种可行的方式，使得依赖
SwiftData 的应用能够实现灵活的数据查询功能，而不会因缺少某些特性而受限。

尽管我们已经找到了在当前技术限制下工作的方法，但仍然希望未来的 Foundation 和 SwiftData
版本能够提供内置的支持，使得构建动态复杂谓词变得更加简单和直观。完善这些功能将进一步增强 Swift Predicate 和 SwiftData
的实用性，让开发者能够更高效地实现复杂的数据处理逻辑。

# 在 SwiftUI 中用 zIndex 调整视图显示顺序

本文将对 SwiftUI 的 zIndex 修饰符做以介绍，包括：使用方法、zIndex 的作用域、通过 zIndex 避免动画异常、为什么 zIndex
需要设置稳定的值以及在多种布局容器内使用 zIndex 等内容。

## zIndex 修饰符

在 SwiftUI 中，开发者使用 zIndex 修饰符来控制重叠视图间的显示顺序，具有较大 zIndex 值的视图将显示在具有较小 zIndex
值的视图之上。在没有指定 zIndex 值的时候，SwiftUI 默认会给视图一个为 0 的 zIndex 值。

    ZStack {
        Text("Hello") // 默认 zIndex 值为 0 ，显示在最后面

        Text("World")
            .zIndex(3.5)  // 显示在最前面

        Text("Hi")
            .zIndex(3.0)

        Text("Fat")
            .zIndex(3.0) // 显示在 Hi 之前， 相同 zIndex 值，按布局顺序显示
    }

> 可以在 [ 此处获取本文的全部代码
> ](https://github.com/fatbobman/BlogCodes/tree/main/ZIndexDemo)

## zIndex 的作用域

- zIndex 作用范围被限定在布局容器内

视图的 zIndex 值仅限于在同一个布局容器之间进行比较（ Group 不是布局容器）。处于不同的布局容器或父子容器之间的视图无法直接比较。

- 当一个视图有多个 zIndex 修饰符时，视图将使用最内层的 zIndex 值

  struct ScopeDemo: View {
  var body: some View {
  ZStack {
  // zIndex = 1
  Color.red
  .zIndex(1)

              // zIndex = 0.5
              SubView()
                  .zIndex(0.5)

              // zIndex = 0.5, 使用最内层的 zIndex 值
              Text("abc")
                  .padding()
                  .zIndex(0.5)
                  .foregroundColor(.green)
                  .overlay(
                      Rectangle().fill(.green.opacity(0.5))
                  )
                  .padding(.top, 100)
                  .zIndex(1.3)

              // zIndex = 1.5 ，Group 不是布局容器，使用最内层的 zIndex 值
              Group {
                  Text("Hello world")
                      .zIndex(1.5)
              }
              .zIndex(0.5)
          }
          .ignoresSafeArea()
      }

  }

  struct SubView: View {
  var body: some View {
  ZStack {
  Text("Sub View1")
  .zIndex(3) // zIndex = 3 ，仅在本 ZStack 中比较

              Text("Sub View2") // zIndex = 3.5 ，仅在本 ZStack 中比较
                  .zIndex(3.5)
          }
          .padding(.top, 100)
      }

  }

执行上面的代码，最终只能看到 `Color` 和 `Group`

![image-20220409170346551](https://cdn.fatbobman.com/image-20220409170346551.png)

## 设定 zIndex 避免动画异常

如果视图的 zIndex 值相同（比如全部使用默认值 0 ），SwiftUI 会按照布局容器的布局方向（ 视图代码在闭包中的出现顺序
）对视图进行绘制。在视图没有增减变化的需求时，可以不必显式设置 zIndex 。但如果有动态的视图增减需求，如不显式设置 zIndex
，某些情况下会出现显示异常，例如：

    struct AnimationWithoutZIndex: View {
        @State var show = true
        var body: some View {
            ZStack {
                Color.red
                if show {
                    Color.yellow
                }
                Button(show ? "Hide" : "Show") {
                    withAnimation {
                        show.toggle()
                    }
                }
                .buttonStyle(.bordered)
                .padding(.top, 100)
            }
            .ignoresSafeArea()
        }
    }

点击按钮，红色出现时没有渐变过场，隐藏时有渐变过场。

![animationException20220409](https://cdn.fatbobman.com/animationException20220409.gif)

如果我们显式地给每个视图设置了 zIndex 值，就可以解决这个显示异常。

    struct AnimationWithZIndex: View {
        @State var show = true
        var body: some View {
            ZStack {
                Color.red
                    .zIndex(1) // 按顺序设置 zIndex 值
                if show {
                    Color.yellow
                        .zIndex(2) // 取消或显示时，SwiftUI 将明确知道该视图在 Color 和 Button 之间
                }
                Button(show ? "Hide" : "Show") {
                    withAnimation {
                        show.toggle()
                    }
                }
                .buttonStyle(.bordered)
                .padding(.top, 100)
                .zIndex(3) // 最上层视图
            }
            .ignoresSafeArea()
        }
    }

![zIndexAnimation2022-04-09 17.15.18.2022-04-09
17_17_08](https://cdn.fatbobman.com/zIndexAnimation2022-04-09%2017.15.18.2022-04-09%2017_17_08.gif)

## zIndex 是不可动画的

同 `offset` 、 `rotationEffect` 、 `opacity` 等修饰符不同， zIndex 是不可动画的 （ 其内部对应的
\_TraitWritingModifier 并不符合 Animatable 协议）。这意味着即使我们使用例如 `withAnimation`
之类的显式动画手段来改变视图的 zIndex 值，并不会出现预期中的平滑过渡，例如：

    struct SwapByZIndex: View {
        @State var current: Current = .page1
        var body: some View {
            ZStack {
                SubText(text: Current.page1.rawValue, color: .red)
                    .onTapGesture { swap() }
                    .zIndex(current == .page1 ? 1 : 0)

                SubText(text: Current.page2.rawValue, color: .green)
                    .onTapGesture { swap() }
                    .zIndex(current == .page2 ? 1 : 0)

                SubText(text: Current.page3.rawValue, color: .cyan)
                    .onTapGesture { swap() }
                    .zIndex(current == .page3 ? 1 : 0)
            }
        }

        func swap() {
            withAnimation {
                switch current {
                case .page1:
                    current = .page2
                case .page2:
                    current = .page3
                case .page3:
                    current = .page1
                }
            }
        }
    }

    enum Current: String, Hashable, Equatable {
        case page1 = "Page 1 tap to Page 2"
        case page2 = "Page 2 tap to Page 3"
        case page3 = "Page 3 tap to Page 1"
    }

    struct SubText: View {
        let text: String
        let color: Color
        var body: some View {
            ZStack {
                color
                Text(text)
            }
            .ignoresSafeArea()
        }
    }

![swapWithzIndex2022-04-09 17.31.01.2022-04-09
17_33_07](https://cdn.fatbobman.com/swapWithzIndex2022-04-09%2017.31.01.2022-04-09%2017_33_07.gif)

因此在进行视图的显示切换时，最好通过 `opacity` 或 `transition` 等方式来处理（参阅下面的代码）。

    // 使用 opacity
    ZStack {
        SubText(text: Current.page1.rawValue, color: .red)
            .onTapGesture { swap() }
            .opacity(current == .page1 ? 1 : 0)

        SubText(text: Current.page2.rawValue, color: .green)
            .onTapGesture { swap() }
            .opacity(current == .page2 ? 1 : 0)

        SubText(text: Current.page3.rawValue, color: .cyan)
            .onTapGesture { swap() }
            .opacity(current == .page3 ? 1 : 0)
    }

    // 通过 transition
    VStack {
        switch current {
        case .page1:
            SubText(text: Current.page1.rawValue, color: .red)
                .onTapGesture { swap() }
        case .page2:
            SubText(text: Current.page2.rawValue, color: .green)
                .onTapGesture { swap() }
        case .page3:
            SubText(text: Current.page3.rawValue, color: .cyan)
                .onTapGesture { swap() }
        }
    }

![swapWithTransition2022-04-09 17.36.08.2022-04-09
17_38_34](https://cdn.fatbobman.com/swapWithTransition2022-04-09%2017.36.08.2022-04-09%2017_38_34.gif)

## 为 zIndex 设置稳定的值

由于 zIndex 是不可动画的，所以应尽量为视图设置稳定的 zIndex 值。

对于固定数量的视图，可以手动在代码中进行标注。对于 **可变数量** 的视图（例如使用了 ForEach），需要在数据中找到 **可作为 zIndex
值参考依据的稳定标识** 。

例如下面的代码，尽管我们利用了 `enumerated` 为每个视图添加序号，并以此序号作为视图的 zIndex
值，但当视图发生增减时，由于序号的重组，就会有几率出现动画异常的情况。

    struct IndexDemo1: View {
        @State var backgrounds = (0...10).map { _ in BackgroundWithoutIndex() }
        var body: some View {
            ZStack {
                ForEach(Array(backgrounds.enumerated()), id: \.element.id) { item in
                    let background = item.element
                    background.color
                        .offset(background.offset)
                        .frame(width: 200, height: 200)
                        .onTapGesture {
                            withAnimation {
                                if let index = backgrounds.firstIndex(where: { $0.id == background.id }) {
                                    backgrounds.remove(at: index)
                                }
                            }
                        }
                        .zIndex(Double(item.offset))
                }
            }
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)
            .ignoresSafeArea()
        }
    }

    struct BackgroundWithoutIndex: Identifiable {
        let id = UUID()
        let color: Color = {
            [Color.orange, .green, .yellow, .blue, .cyan, .indigo, .gray, .pink].randomElement() ?? .red.opacity(Double.random(in: 0.8...0.95))
        }()

        let offset: CGSize = .init(width: CGFloat.random(in: -200...200), height: CGFloat.random(in: -200...200))
    }

![unStablezIndex2022-04-09 17.47.49.2022-04-09
17_49_14](https://cdn.fatbobman.com/unStablezIndex2022-04-09%2017.47.49.2022-04-09%2017_49_14.gif)

删除第四个色块（紫色）时，显示异常。

通过为视图指定稳定的 zIndex 值，可以避免上述问题。下面的代码，为每个视图添加了稳定的 zIndex 值，该值并不会因为有视图被删除就发生变化。

    struct IndexDemo: View {
        // 在创建时添加固定的 zIndex 值
        @State var backgrounds = (0...10).map { i in BackgroundWithIndex(index: Double(i)) }
        var body: some View {
            ZStack {
                ForEach(backgrounds) { background in
                    background.color
                        .offset(background.offset)
                        .frame(width: 200, height: 200)
                        .onTapGesture {
                            withAnimation {
                                if let index = backgrounds.firstIndex(where: { $0.id == background.id }) {
                                    backgrounds.remove(at: index)
                                }
                            }
                        }
                        .zIndex(background.index)
                }
            }
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)
            .ignoresSafeArea()
        }
    }

    struct BackgroundWithIndex: Identifiable {
        let id = UUID()
        let index: Double // zIndex 值
        let color: Color = {
            [Color.orange, .green, .yellow, .blue, .cyan, .indigo, .gray, .pink].randomElement() ?? .red.opacity(Double.random(in: 0.8...0.95))
        }()

        let offset: CGSize = .init(width: CGFloat.random(in: -200...200), height: CGFloat.random(in: -200...200))
    }

![stableZindex2022-04-09 18.07.18.2022-04-09
18_09_12](https://cdn.fatbobman.com/stableZindex2022-04-09%2018.07.18.2022-04-09%2018_09_12.gif)

并非一定要在数据结构中为 zIndex 预留独立的属性，下节中的范例代码则是利用了数据中的时间戳属性作为 zIndex 值的参照依据。

## zIndex 并非 ZStack 的专利

尽管大多数人都是在 ZStack 中使用 zIndex ，但 zIndex 也同样可以使用在 VStack 和 HStack 中，且通过和 spacing
的配合，可以非常方便的实现某些特殊的效果。

    struct ZIndexInVStack: View {
        @State var cells: [Cell] = []
        @State var spacing: CGFloat = -95
        @State var toggle = true
        var body: some View {
            VStack {
                Button("New Cell") {
                    newCell()
                }
                .buttonStyle(.bordered)
                Slider(value: $spacing, in: -150...20)
                    .padding()
                Toggle("新视图显示在最上面", isOn: $toggle)
                    .padding()
                    .onChange(of: toggle, perform: { _ in
                        withAnimation {
                            cells.removeAll()
                            spacing = -95
                        }
                    })
                VStack(spacing: spacing) {
                    Spacer()
                    ForEach(cells) { cell in
                        cell
                            .onTapGesture { delCell(id: cell.id) }
                            .zIndex(zIndex(cell.timeStamp))
                    }
                }
            }
            .padding()
        }

        // 利用时间戳计算 zIndex 值
        func zIndex(_ timeStamp: Date) -> Double {
            if toggle {
                return timeStamp.timeIntervalSince1970
            } else {
                return Date.distantFuture.timeIntervalSince1970 - timeStamp.timeIntervalSince1970
            }
        }

        func newCell() {
            let cell = Cell(
                color: ([Color.orange, .green, .yellow, .blue, .cyan, .indigo, .gray, .pink].randomElement() ?? .red).opacity(Double.random(in: 0.9...0.95)),
                text: String(Int.random(in: 0...1000)),
                timeStamp: Date()
            )
            withAnimation {
                cells.append(cell)
            }
        }

        func delCell(id: UUID) {
            guard let index = cells.firstIndex(where: { $0.id == id }) else { return }
            withAnimation {
                let _ = cells.remove(at: index)
            }
        }
    }

    struct Cell: View, Identifiable {
        let id = UUID()
        let color: Color
        let text: String
        let timeStamp: Date
        var body: some View {
            RoundedRectangle(cornerRadius: 15)
                .fill(color)
                .frame(width: 300, height: 100)
                .overlay(Text(text))
                .compositingGroup()
                .shadow(radius: 3)
                .transition(.move(edge: .bottom).combined(with: .opacity))
        }
    }

在上面的代码中，我们无需更改数据源，只需调整每个视图的 zIndex 值，便可以实现对新增视图是出现在最上面还是最下面的控制。

![zIndexInVStack2022-04-09 19.18.42.2022-04-09
19_20_20](https://cdn.fatbobman.com/zIndexInVStack2022-04-09%2019.18.42.2022-04-09%2019_20_20.gif)

> [ SwiftUI Overlay Container
> ](https://github.com/fatbobman/SwiftUIOverlayContainer)
> 即是通过上述方式实现了在不改变数据源的情况下调整视图的显示顺序

## 总结

zIndex 使用简单，效果明显，为我们提供了从另一个维度来调度、组织视图的能力。

# 掌握 TipKit：进阶

在上文中，我们介绍了 TipKit 的基础用法。在本文中，我们将讨论一些与 TipKit 相关的进阶问题，例如如何完全自定义 Tip 视图（不使用
TipView 和 popoverTip）、如何在 UIKit 中使用 TipKit，以及 TipKit
如何在不同的应用程序之间共享数据。最后，我们将尝试解答一些与 TipKit 相关的疑惑。

> 如果你对 TipKit 框架还不太了解，请先阅读 [ 掌握 TipKit：基础 ](/zh/posts/mastering-tipkit-basic/)
> 这篇文章。

## 透过现象看本质

TipKit 框架极大地简化了在应用程序中添加提示的难度。通过使用像 `TipView` 和 `popoverTip`
这样现成的提示视图，开发者可以专注于提示的内容，而不必过多关心视觉效果的实现。

然而，这些预制的提示视图仅仅是 TipKit 提供的辅助工具。TipKit 的真正精髓在于它采用了“契约式设计”的理念。换句话说，TipKit
允许你用代码的形式定义提示的内容和显示规则，而不需要考虑具体的实现。这些规则和内容构成了你和 TipKit 之间的一个契约。TipKit
会根据这个契约动态决定是否需要显示提示，开发者只需关注状态或事件的变化。

所以，TipKit 的精髓不在于外在的视觉效果，而在于内在的逻辑表达。它帮助开发者以声明的方式描述提示生成的规则，而提示的具体实现完全可以自定义。我们可以把
TipKit 想象成一个判断提示显示需求的规则引擎，至于如何可视化这些规则，则取决于开发者自己。

## 如何观察 Tip 的状态

既然我们将 TipKit 视作一个判断提示显示需求的规则引擎，那么 TipKit 是否为开发者提供了观察某个 Tip 状态的 API 呢？答案是肯定的。

TipKit 为 Tip 的实例提供了两个方法： `statusUpdates` 和 `shouldDisplayUpdates`
，它们分别返回了两个 AsyncStream，用于提供该 Tip 类型的状态变化和显示与否的信息。

`statusUpdates` 会返回 Tip 的三种状态： `pending` （不符合显示条件）、 `available`
（符合显示条件）、 `invalidated` （失效及失效原因）。

而 `shouldDisplayUpdates` 则简化了上述内容，仅通过 `true` 和 `false` 来表示是否可以显示 Tip 视图。

其中， `pending` 对应 `false` ， `available` 对应 `true` 。当一个 Tip
被设置为失效后，TipKit 在发送最后一个状态变化信息（ `invalidated` ）后，将不再观察该 Tip
的参数和事件的变化，停止继续提供状态信息。

让我们使用以下代码来演示观察某个 Tip 状态的过程：

    struct DemoTip: Tip {
        var title: Text = .init("Hello World")

        @Parameter
        static var show: Bool = false

        var rules: [Rule] {
            #Rule(Self.$show) {
                $0
            }
        }
    }

    struct TipStatusView: View {
        let tip = DemoTip()
        var body: some View {
            List {
                Button("Show Toggle") {
                    DemoTip.show.toggle()
                }
                Button("Invalidate") {
                    tip.invalidate(reason: .actionPerformed)
                }
            }
            .task {
                for await status in tip.statusUpdates {
                    print("Status:", status)
                }
            }
            .task {
                for await shouldDisplay in tip.shouldDisplayUpdates {
                    print("Display:", shouldDisplay)
                }
            }
        }
    }

点击 “Show Toggle” 按钮，将改变 `DemoTip.show` 的值，从而影响 TipKit 根据 rules 进行判断的结果。点击
“Invalidate” 将使该 Tip 失效。

![https://cdn.fatbobman.com/tipkit-status-stream-
demo_2023-10-18_15.57.18.2023-10-18%2015_59_07.gif](https://cdn.fatbobman.com/tipkit-
status-stream-demo_2023-10-18_15.57.18.2023-10-18%2015_59_07.gif)

也许你已经注意到了，在当前的视图中我们没有添加 `TipView` 或 `popoverTip`
，这完全验证了上文中提到的“规则引擎”概念。是否展示 Tip 视图完全取决于开发者。

> TipKit 为 Tip 还提供了两个属性， `status` 和 `shouldDisplay` ，考虑到 Tip
> 的状态会经常变化，而这两个属性并不具备良好的观察方式，因此不建议完全依赖这两个属性来判断当前 Tip 的状态。

## 根据状态展示自定义 Tip 视图

一旦开发者掌握了观察 Tip 状态的方式，就可以轻松在应用中根据状态展示任何形式和样式的提示视图。

    struct TipStatusView: View {
        let tip = DemoTip()
        @State var shouldDisplay = DemoTip.show
        var body: some View {
            List {
                if shouldDisplay {
                    tip.title
                }
                Button("Show Toggle") {
                    DemoTip.show.toggle()
                }
                Button("Invalidate") {
                    tip.invalidate(reason: .actionPerformed)
                }
            }
            .task {
                for await shouldDisplay in tip.shouldDisplayUpdates {
                    withAnimation(.smooth) {
                        self.shouldDisplay = shouldDisplay
                    }
                }
            }
        }
    }

![https://cdn.fatbobman.com/tipkit-show-tip-by-status-
demo_2023-10-18_16.55.40.2023-10-18%2016_56_22.gif](https://cdn.fatbobman.com/tipkit-
show-tip-by-status-demo_2023-10-18_16.55.40.2023-10-18%2016_56_22.gif)

## 在 UIKit 和 AppKit 中使用 TipKit

由于 UIKit 和 AppKit 并非响应式的框架，即使使用 TipKit 提供的预制 Tip 视图（ [ TipUIView
](https://developer.apple.com/documentation/tipkit/tipuiview) 、 [
TipUIPopoverViewController
](https://developer.apple.com/documentation/tipkit/tipuipopoverviewcontroller)
、 [ TipUICollectionViewCell
](https://developer.apple.com/documentation/tipkit/tipuicollectionviewcell) 、
[ TipNSView ](https://developer.apple.com/documentation/tipkit/tipnsview) 、 [
TipNSPopover ](https://developer.apple.com/documentation/tipkit/tipnspopover)
），开发者也需要显式地跟踪 Tip 的状态，然后根据状态显示 Tip 视图。

以下代码摘自苹果的官方文档：

    import TipKit
    import UIKit

    struct CatTracksFeatureTip: Tip {
        var title: Text { Text("Sample tip title")}
        var message: Text? { Text("Sample tip message")}
        var image: Image? { Image(systemName: "globe")}
    }

    class CatTracksViewController: UIViewController {
        private var catTracksFeatureTip = CatTracksFeatureTip()
        private var tipObservationTask: Task<Void, Never>?
        private weak var tipView: TipUIView?

        override func viewDidAppear(_ animated: Bool) {
            super.viewDidAppear(animated)
            tipObservationTask = tipObservationTask ?? Task { @MainActor in
                for await shouldDisplay in catTracksFeatureTip.shouldDisplayUpdates {
                    if shouldDisplay {
                        let tipHostingView = TipUIView(catTracksFeatureTip)
                        tipHostingView.translatesAutoresizingMaskIntoConstraints = false

                        view.addSubview(tipHostingView)

                        view.addConstraints([
                            tipHostingView.centerYAnchor.constraint(equalTo: view.centerYAnchor),
                            tipHostingView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20.0),
                            tipHostingView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20.0)
                        ])

                        tipView = tipHostingView
                    }
                    else {
                        tipView?.removeFromSuperview()
                        tipView = nil
                    }
                }
            }
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        tipObservationTask?.cancel()
        tipObservationTask = nil
    }

需要提醒一下，因为在 Tip 协议中， `title` 、 `message` 、 `image` 等属性类型均为 SwiftUI
特有的类型，因此如果想在 UIKit 或 AppKit 中实现完全自定义视图，最好在声明 Tip 类型时为其添加其他的附加信息，以方便使用。

## 关于 TipKit 的几个疑问

TipKit 通过代码的形式让开发者定义 Tip 的内容、显示规则以及影响规则的参数和事件。那么 TipKit
是如何理解用户定义的“Tip”呢？是将一个符合 Tip 协议的类型视为一个 Tip，还是将一个用该类型创建的实例视为一个 Tip？

从接触 TipKit 开始，一直有几个疑问困扰着我：

- 在一个应用中，是否可以在多个视图中使用同一个 Tip 类型？
- 同一个 Tip 类型的不同实例是否可以返回不一样的属性值（比如 `title` 、 `rules` ）？
- 在不同的应用之间（ AppGroup ），是否可以使用同一个 Tip 定义？Tip 的状态是否可以同步？
- 怎样才算是同一个 Tip 的定义？是指完全相同的代码吗？
- TipKit 会持久化哪些 Tip 状态？共享 Tip 间状态同步的机制是什么？
- `@Parameter` 是否有类型限制？

对于上述疑问，无论是在 TipKit 的文档还是 WWDC 有关 TipKit 的 [ Session
](https://developer.apple.com/videos/play/wwdc2023/10229/)
中，都没有给出清晰的解释。幸好，TipKit 采用了我们熟悉的数据持久化机制，我们可以从中找到我们想要的答案。

在进一步寻找答案之前，我们首先需要了解以下几点：

- Tip 中的参数（Parameter）和事件（Event）是以静态属性的形式声明的。
- 对参数的修改以及对事件的触发和查询无需通过实例。
- TipView 和 popoverTip 需要使用 Tip 实例作为参数。
- 观察 Tip 的状态需要通过实例。

## 从 TipKit 的持久化数据中找寻答案

考虑到 TipKit 需要保存的数据量和数据类型的多样性，UserDefaults 显然不是一个好的选择。最终，我们在应用的 `Application
Support` 目录中找到了 TipKit 的持久化数据（在未指定目录和设置 AppGroupIdentifier 的情况下）。TipKit
将数据保存在名为 `.tipkit` 的目录中的 `tips-store.db` 文件里。

打开数据库文件后，我们就能看到熟悉的 Core Data 数据格式的身影。

> 请阅读 [ Core Data 是如何在 SQLite 中保存数据的
> ](/zh/posts/tables_and_fields_of_coredata/) 一文，了解 Core Data 的持久化数据格式。

![https://cdn.fatbobman.com/image-20231019105146293.png](https://cdn.fatbobman.com/image-20231019105146293.png)

TipKit 一共创建了 5 个实体（ Entity
），分别是：CoreTipRecord、CoreParameterRecord、CoreEventRecord、CoreDonationRecord 和
CoreRuleRecord。了解了这五个实体的构成，对解答上面的疑问很有帮助。

### CoreTipRecord

保存与 Tip 相关的信息，包括显示日期、次数、Option 设定等。大致的定义如下：

    class CoreTipRecord {
        // Tip Type Name , for example : MyTip
        var id: String
        // pending , available , invalidated
        var statusValue: Int
        // Reason of invalidated
        var invalidationReasonValue: Int
        // The lost display date
        var lastDisplayed: Date?
        // Unclear
        var content: ConstellationContent?
        // Some info of Tip , including : display count, options setting, etc
        var tipInfo: [String: Any]

        var rules: Set<CoreRuleRecord>
        var events: Set<CoreEventRecord>
    }

> 为了方便阅读，我们将不再使用 NSManagedObject 的方式来进行类型的定义。

其中 `id` 为 Tip 的类型名称，也就是说，下面的代码对应的 CoreTipRecord 的 `id` 值为 `MyTip` ：

    struct MyTip: Tip {}

无论创建多少个 MyTip 实例，它们都对应着同一个 CoreTipRecord 记录。而且，对于通过 App Group 进行 TipKit
数据共享的应用来说，只要是类型名称为 `MyTip` ，它们都对应着同一个 CoreTipRecord 数据。

`tipInfo` 中保存了与该提示相关的其他一些信息，例如：

- 显示记录：所有的显示日期，无论在哪个应用（ App Group ）中对该 Tip 进行显示
- 已显示次数
- 最大显示次数设定（ Option ）
- 是否忽略显示频次策略（ Option ）

只要显示 Tip，显示日期都将被记录。同样，最大显示次数设定适用于 App Group 中的所有成员，并且显示状态在不同成员之间共享。

由于 Tip 的 Option 也被进行了持久化，因此应在不同的应用中（App Group）采用相同的 Option 设置。

> 实践发现，如果在不同的应用中采用了不同的 Option 设置，后启动的会覆盖之前的设置，不推荐这种做法。

### CoreParameterRecord

CoreParameterRecord 大致的定义如下：

    class CoreParameterRecord {
        // Composite name of a paramter property
        var id: String
        // The name of the paramter property type
        var valueType: String
        // Encoded default value
        var valueData: Data?

        var rules: Set<CoreRuleRecord>
    }

从 CoreParameterRecord 的命名上很容易看出，这个对象用于保存 Tip 中的参数（ Parameter ）信息。

    struct MyTip: Tip {
      @Parameter
      static var show:Bool = false
    }

上面的代码中，对应 CoreParameterRecord 的数据为：

- id： `Bool.MyTip+show` ，属性类型 + Tip 类型名称 + 属性名称
- valueType：字符串 `Bool`
- valueData: Bool. false 的 Encode 数据

从中我们可以看出，TipKit 并没有对 `@Parameter` 所能支持的数据类型做出太多的限制，类型只需符合 Encodable 协议即可。

    struct MyData: Codable {
      var id: String
      var count: Int
    }

    struct MyTip: Tip {
      @Parameter
      static var data: MyData = MyData(id:"1", count: 1)
    }

很遗憾，受限于当前 Predicate 的问题，我们还无法使用以下规则（该规则将在运行时会导致应用崩溃）：

    var rules: [Rule] {
        #Rule(Self.$data){
            $0.count > 3
        }
    }

### CoreEventRecord

下面是 CoreEventRecord 的大致定义，它用于记录与 Event 定义相关的信息。

    class CoreEventRecord {
        // event property name
        var id: String
        // No data recorded yet
        var eventInfo: [String: Any]

        var donations: Set<CoreDonationRecord>
        var rules: Set<CoreRuleRecord>

        var tip: CoreTipRecord?
    }

在多个应用（AppGroup）甚至多个设备上（iCloud 同步）触发同一个事件时，所有的触发数据都是共享的。

    static let didTriggerControlEvent = Event(id: "didTriggerControlEvent")

CoreEventRecord 中 `id` 为 `didTriggerControlEvent` 。

### CoreDonationRecord

CoreDonationRecord 的定义如下：

    class CoreDonationRecord {
        var date: Date
        var donationInfo: DonationInfo?

        var event: CoreEventRecord
    }

用来记录 Donation 的日期，每次触发都会记录一条数据。

    MyTip.didTriggerControlEvent.sendDonation()

![https://cdn.fatbobman.com/image-20231019184513075.png](https://cdn.fatbobman.com/image-20231019184513075.png)

由于 TipKit 尚未公开 DonationInfo，所以我们无法在触发事件时附带自定义的信息。如果未来开放了自定义 EventInfo
的能力，就可以创建更加灵活的规则。

### CoreRuleRecord

CoreRuleRecord 的定义如下，用于记录 Tip 的 Rule 设定：

    class CoreRuleRecord {
        var id: String
        var categoryValue: Int
        var statusValue: Int
        var predicate: Predicate
        var ruleInfo: [String: Any]

        var event: CoreEventRecord?
        var parameter: CoreParameterRecord?
        var parent: CoreRuleRecord?

        var subrules: Set<CoreRuleRecord>
        var tip: CoreTipRecord?
    }

其中，id 是最有意思的属性，它 Rule 中 Predicate 的自定义版本的字符串表述。

    var rules: [Rule] {
        #Rule(Self.didTriggerControlEvent){
            $0.donations.count > 3
        }
    }

`id` 为：

    MyTip.event.didTriggerControlEvent.count(donationsCount) > Optional(3)

每个 Rule 保存为一条 CoreRuleRecord 记录。在验证时，它们之间是 `AND` 的关系。

        var rules: [Rule] {
            #Rule(Self.didTriggerControlEvent){
                $0.donations.count > 3
            }
            #Rule(Self.$show){
                $0
            }
        }

![https://cdn.fatbobman.com/image-20231019193739995.png](https://cdn.fatbobman.com/image-20231019193739995.png)

## 释疑

通过对 TipKit 持久化数据的分析并结合我做的另外一些测试，我们基本上可以得出以下结论：

- TipKit 的数据是通过 Core Data 来管理并保存的
- 因为 Core Data 的关系，TipKit 的数据可以在不同的应用（AppGroup）或不同的设备间（iCloud）进行共享和同步
- TipKit 根据 Tip 的类型名称来标识 Tip。在不同的应用（AppGroup）之间，相同的 Tip 类型名称将使用同一个 Tip 数据源。
- 在不同的应用（AppGroup）之间，对于同一个 Tip 类型，如果不复用代码，所有的持久化属性（包括静态属性）应该保持一致，包括：Parameter、Event、rules、options。
- 与外观有关的属性可以在创建实例时根据需要进行修改和调整，比如：标题（title）、消息（message）、图片（image）、操作（action）。
- 同一个 Tip 的失效状态、显示状态、点击次数、允许的最大展示量等都是共享的。
- 同一个 Tip 的事件触发数据也是共享的。

> 无论是在 WWDC 的演讲中，还是在 tipInfo 的信息中，都表明 TipKit 支持通过 iCloud
> 进行同步。然而，我尚未找到正确的开启方式。如果有人成功实现了，请告诉我一下。

## 最后

在本文中，我们从“规则引擎”的角度对 TipKit 进行了分析。尽管分析显示开发团队预留了一些升级空间，但 TipKit 的设计主旨是为了方便在应用中展示
Tip 信息，因此在数据筛选效率和规则制定灵活性方面，并没有过度增加不必要的能力。即便如此，TipKit
还是为我们提供了一个实现可共享数据的微型“规则引擎”的良好范例。

# 在 Core Data 中查询和使用 count 的若干方法

在 Core Data 中，开发者经常需要面对查询记录数量（count），使用 count 作为谓词或排序条件等需求。本文将介绍在 Core Data
下查询和使用 count 的多种方法，适用于不同的场景。

## 一、通过 countResultType 查询 count 数据

本方法为最直接的查询记录条数的方式。通过将 NSFetchQuest 的 resultType 设置为 countResultType，可以直接获取到数据的
count 结果。

    let fetchRequest = NSFetchRequest<NSNumber>(entityName: "Item")
    fetchRequest.resultType = .countResultType
    let count = (try? viewContext.fetch(fetchRequest).first)?.intValue ?? 0
    print(count)
    /*
     CoreData: sql: SELECT COUNT(*) FROM ZITEM
     CoreData: annotation: total count request execution time: 0.0002s for count of 190.
     190
     */

> 上文代码中的注释部分，为 Core Data 语句对应的 SQL 命令（使用 `-com.apple.CoreData.SQLDebug 1`
> 生成）。具体的设置方法，请参阅 [ Core Data with CloudKit（四）—— 调试、测试、迁移及其他
> ](/zh/posts/coredatawithcloudkit-4/)

## 二、使用托管对象上下文的 count 方法查询 count 数据

方法一的便捷版本。调用托管对象上下文提供的 count 方法，返回值类型为 Int。

    let fetchRequest = NSFetchRequest<Item>(entityName: "Item")
    let count = (try? viewContext.count(for: fetchRequest)) ?? 0
    print(count)
    /*
     CoreData: sql: SELECT COUNT(*) FROM ZITEM
     CoreData: annotation: total count request execution time: 0.0002s for count of 190.
     190
     */

方法二和方法一对应着完全一致的 SQL 命令。

> 在仅需获取 count 的情况下（不关心数据的具体内容），方法一和方法二是很好的选择。

## 三、从结果集合中获取 count 数据

有时在获取数据集之后想同时查看数据集的 count，可以直接利用集合的 count 方法来实现。

    let fetchRequest = NSFetchRequest<Item>(entityName: "Item")
    fetchRequest.predicate = NSPredicate(format: "%K > %@", #keyPath(Item.timestamp), Date.now as CVarArg)
    let items = (try? viewContext.fetch(fetchRequest)) ?? []
    let count = items.count
    print(count)
    /*
     CoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZTIMESTAMP FROM ZITEM t0 WHERE  t0.ZTIMESTAMP > ?
     CoreData: annotation: sql connection fetch time: 0.0001s
     CoreData: annotation: total fetch execution time: 0.0002s for 0 rows.
     */

调用 count 并不会出发导致数据的惰值填充。

在 SwiftUI 下，使用@FetchRequest 获取的结果集，也可以使用上述方式。

> 如果设置了 fetchLimit ，可能无法获得正确的 count 结果。设置 fetchLimit 后将只返回不超过设定数量的结果。

## 四、获取单条记录某对多关系的 count 数据

如果你的对象模型中设置了对多关系，调用关系属性的 count 方法，可以获取单条记录某对多关系的对象数量。

    let fetchRequest = NSFetchRequest<Item>(entityName: "Item")
    let items = (try? viewContext.fetch(fetchRequest)) ?? []
    let firstItemTagsCount = items.first?.attachments?.count ?? 0 // 统计关系的数量，将导致本条记录被填充
    print(firstItemTagsCount)
    /*
     CoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZTIMESTAMP FROM ZITEM t0
     CoreData: annotation: sql connection fetch time: 0.0002s
     CoreData: annotation: total fetch execution time: 0.0004s for 190 rows.
     CoreData: sql: SELECT 0, t0.Z_PK FROM Z_1TAGS t1 JOIN ZTAG t0 ON t0.Z_PK = t1.Z_2TAGS WHERE t1.Z_1ITEMS = ?
     CoreData: annotation: sql connection fetch time: 0.0001s
     CoreData: annotation: total fetch execution time: 0.0001s for 0 rows.
     CoreData: annotation: to-many relationship fault "tags" for objectID 0xa7ab2d44ebb9106e <x-coredata://0783522F-1851-4BC7-AE0D-AB4C83489E8B/Item/p1> fulfilled from database.  Got 0 rows
     0
     */

上面的代码将获取第一条记录中对多关系 attachments 的 count 数据。此例中，调用 count 方法将会导致 Core Data
为第一条记录填充数据，从而脱离惰值状态。

可以通过设置 relationshipKeyPathsForPrefetching 来调整填充时机。下面的代码，即使调用 count
方法，也并不会对数据进行填充。

    let fetchRequest = NSFetchRequest<Item>(entityName: "Item")
    fetchRequest.relationshipKeyPathsForPrefetching = ["attachments"]
    let items = (try? viewContext.fetch(fetchRequest)) ?? []
    let firstItemTagsCount = items.first?.attachments?.count ?? 0 // 统计关系的数量，提前加载 relationship，将不会导致本条记录被填充。
    print(firstItemTagsCount)
    /*
     CoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZATTACHMENTCOUNT, t0.ZBIRTHOFYEAR, t0.ZTIMESTAMP FROM ZITEM t0
     CoreData: annotation: sql connection fetch time: 0.0003s
     CoreData: annotation: Bound intarray _Z_intarray0
     CoreData: annotation: Bound intarray values.
     CoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZTITLE, t0.ZITEM FROM ZATTACHMENT t0 WHERE  t0.ZITEM IN (SELECT * FROM _Z_intarray0)  ORDER BY t0.ZITEM
     CoreData: annotation: sql connection fetch time: 0.0021s
     CoreData: annotation: total fetch execution time: 0.0024s for 1581 rows.
     CoreData: annotation: Prefetching with key 'attachments'.  Got 1581 rows.
     CoreData: annotation: total fetch execution time: 0.0053s for 190 rows.
     */

因为在 fetch 的过程中，通过 relationshipKeyPathsForPrefetching 中指定的关系数据的
NSManagedObjectID 已被一并提取。

## 五、使用对多关系的 count 设置谓词

对多关系的 count 也经常被用来作为谓词的条件使用。下面的代码将只返回 attachments（对多关系） count 大于 2 的结果。

    let fetchquest = NSFetchRequest<Item>(entityName: "Item")
    fetchquest.predicate = NSPredicate(format: "attachments.@count > 2")
    let results = try? viewContext.fetch(fetchquest)
    print(results?.count)
    /*
     CoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZTIMESTAMP FROM ZITEM t0 WHERE (SELECT COUNT(t1.Z_PK) FROM ZATTACHMENT t1 WHERE (t0.Z_PK = t1.ZITEM) ) > ?
     CoreData: annotation: sql connection fetch time: 0.0003s
     CoreData: annotation: total fetch execution time: 0.0006s for 144 rows.
     Optional(144)
     */

类似 `attachments.@count` 的方式只适用于谓词，无法将其作为排序条件。

## 六、通过派生属性记录对多关系的 count 数据

派生属性提供了对多关系 count 结果的预存能力。派生属性将在数据变化时（创建、更新、删除）按照设置，自动填充数据。在对 count
读取需求频繁的情况下，是极为优秀的解决方案

![derived](https://cdn.fatbobman.com/image-20211025183247335.png)

> 完整的派生属性使用方法，请参阅 [ 如何在 Core Data 中使用 Derived 和 Transient 属性
> ](/zh/posts/derivedandtransient/) 。

## 七、利用派生属性记录的 count 进行排序

下面的代码中的 attachmentCount，是 Item 的派生属性，记录的是对多关系 attachments 的 count 数据。

    let fetchquest = NSFetchRequest<Item>(entityName: "Item")
    fetchquest.sortDescriptors = [NSSortDescriptor(keyPath: \Item.attachmentCount, ascending: true)]
    let items = (try? viewContext.fetch(fetchquest)) ?? []
    print(items.count)
    /*
     CoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZATTACHMENTCOUNT, t0.ZBIRTHOFYEAR, t0.ZTIMESTAMP FROM ZITEM t0 ORDER BY t0.ZATTACHMENTCOUNT
     CoreData: annotation: sql connection fetch time: 0.0002s
     CoreData: annotation: total fetch execution time: 0.0004s for 190 rows.
     190
     */

在通过派生属性预存了 count 数据的情况下，实现方法四的需求将更加简单。

## 八、使用 willSave 记录 count 数据

派生属性使用起来非常方便，但预置的方法有限。重写托管对象的 willSave 方法，可以获得更多的控制力。

比如下面的代码将只记录 attachment 中 title 长度大于 10 的 count 值

    extension Item{
        public override func willSave() {
            super.willSave()
            let count = attachments?.allObjects.filter{
                (($0 as! Attachment).title?.count ?? 0 ) > 10
            }.count ?? 0
            setPrimitiveValue(Int32(count), forKey: "manualCount")
        }
    }

在 willSave 中，我们可以根据业务的需要对数据进行调整或记录。复杂的逻辑将对数据更改的效率产生一定的影响。

> 为已经上线使用的 CoreData 数据库添加派生属性或 willSave 方法时，需通过 mapping 或迁移代码处理原有数据的新增属性。

## 九、查询某对多关系所有记录的 count 数据

当我们想统计全部记录（符合设定谓词）的某个对多关系的合计值时，在没有使用派生属性或 willSave 的情况下，可以使用下面的代码：

    let fetchquest = NSFetchRequest<NSFetchRequestResult>(entityName: "Item")
    let expressDescription = NSExpressionDescription()
    fetchquest.resultType = .dictionaryResultType

    let name = "totalAttachment"
    expressDescription.name = name
    expressDescription.resultType = .integer32

    let attachmentCount = NSExpression(format: "attachments")
    let express = NSExpression(forFunction: "count:", arguments: [attachmentCount])

    expressDescription.expression = express
    fetchquest.propertiesToFetch = [expressDescription]
    let result = (try? viewContext.fetch(fetchquest).first as? [String: Int32]) ?? [:]
    print(result[name] ?? 0)

    /*
     也可以直接从 Attachment 一侧进行查询
     CoreData: sql: SELECT COUNT( t1.Z_PK) FROM ZITEM t0 LEFT OUTER JOIN ZATTACHMENT t1 ON t0.Z_PK = t1.ZITEM
     CoreData: annotation: sql connection fetch time: 0.0002s
     CoreData: annotation: total fetch execution time: 0.0002s for 1 rows.
     Optional([{
         totalAttachment = 839;
     }])

     */

上述代码的要点描述：

- 设置 resultType 为 dictionaryResultType
- NSExpressionDescription 将被用在 propertiesToFetch 中，它的名称和结果将出现在返回字典中
- NSExpression 在 Core Data 中使用的场景很多，例如在 Data Model Editor 中，很多的设定都是通过 NSExpression 完成的
- 此方法中 NSExpression 使用的是 count 方法
- 返回的结果是一个字典数组。需根据 propertiesToFetch，对字典的 Value 进行类型转换

使用此方法，SQLite 将在内部对 attachement 进行计数。

## 十、利用派生属性查询某对多关系所有记录的 count 数据

如果已经为对多关系设置了预存 count 的派生属性，可以使用下面的代码实现方法九的需求。

    let fetchquest = NSFetchRequest<NSFetchRequestResult>(entityName: "Item")
    fetchquest.resultType = .dictionaryResultType
    let expressDescription = NSExpressionDescription()
    let name = "totalAttachment"
    expressDescription.name = name
    expressDescription.resultType = .integer32

    let attachmentCount = NSExpression(format: "%K", #keyPath(Item.attachmentCount))
    let express = NSExpression(forFunction: "sum:", arguments: [attachmentCount])

    expressDescription.expression = express
    fetchquest.propertiesToFetch = [expressDescription]
    let result = (try? viewContext.fetch(fetchquest).first as? [String: Int32]) ?? [:]
    print(result[name] ?? 0)
    /*
     oreData: sql: SELECT total( t0.ZATTACHMENTCOUNT) FROM ZITEM t0
     CoreData: annotation: sql connection fetch time: 0.0001s
     CoreData: annotation: total fetch execution time: 0.0002s for 1 rows.
     1581
     速度快于上面的求和方式
     */

因为已经有了预存的 count 值，所以在 NSExpression 中使用的是 sum 方法。

相较于方法九，方法十的查询效率更高。

## 十一、查询分组后的 count 数据

某些场合下，我们需要对数据进行分组，然后获取每组数据的 count。通过设置 propertiesToGroupBy，让 SQLite 为我们完成这个工作。

例如，Item 有一个 birthOfYear 属性，该属性为年份数据（ Int ）。下面的代码，将数据按照 birthOfYear 进行分组，并返回每组的
count 数据：

    let fetchquest = NSFetchRequest<NSFetchRequestResult>(entityName: "Item")
    fetchquest.propertiesToGroupBy = ["birthOfYear"]
    fetchquest.sortDescriptors = [NSSortDescriptor(keyPath: \Item.birthOfYear, ascending: false)]
    fetchquest.resultType = .dictionaryResultType
    let expressDescription = NSExpressionDescription()
    expressDescription.resultType = .integer32
    let name = "count"
    expressDescription.name = name
    let year = NSExpression(forKeyPath:\Item.birthOfYear)
    let express = NSExpression(forFunction: "count:", arguments: [year])
    expressDescription.expression = express
    fetchquest.propertiesToFetch = ["birthOfYear",expressDescription]
    let results = (try? viewContext.fetch(fetchquest) as? [[String:Any]]) ?? []
    print(results)
    /*
     CoreData: sql: SELECT t0.ZBIRTHOFYEAR, COUNT( t0.ZBIRTHOFYEAR) FROM ZITEM t0 GROUP BY  t0.ZBIRTHOFYEAR
     CoreData: annotation: sql connection fetch time: 0.0002s
     CoreData: annotation: total fetch execution time: 0.0003s for 5 rows.

     [["birthOfYear": 2000, "count": 32], ["birthOfYear": 2001, "count": 36], ["count": 42, "birthOfYear": 2002], ["birthOfYear": 2003, "count": 44], ["birthOfYear": 2004, "count": 36]]
     */

由于此实现依赖的是 SQLite 的内部实现，因此将非常高效。

当业务逻辑中有类似的需求时，可以考虑为托管对象预设适合分组的属性。属性的内容也可以通过派生或 willSave 来处理。

## 十二、将分组后的 count 数据用作筛选条件

如果想对方法十一中获取的结果集进行筛选，除了通过代码操作结果数组外，利用 Core Data 对 having 的支持，直接在 SQLite
中进行将更加的高效。下面的代码将只返回 count 大于 40 的结果。

    let fetchquest = NSFetchRequest<NSFetchRequestResult>(entityName: "Item")
    fetchquest.propertiesToGroupBy = ["birthOfYear"]
    fetchquest.resultType = .dictionaryResultType

    let expressDescription = NSExpressionDescription()
    expressDescription.resultType = .integer32
    let name = "count"
    expressDescription.name = name
    let year = NSExpression(forKeyPath:\Item.birthOfYear)
    let express = NSExpression(forFunction: "count:", arguments: [year])
    expressDescription.expression = express

    fetchquest.propertiesToFetch = ["birthOfYear",expressDescription]
    // 创建变量
    let countVariableExpr = NSExpression(forVariable: "count")
    // 对 groupby 后的结果再度筛选
    fetchquest.havingPredicate = NSPredicate(format: "%@ > 40",countVariableExpr)
    let results = (try? viewContext.fetch(fetchquest) as? [[String:Any]]) ?? []
    print(results)
    /*
     CoreData: sql: SELECT t0.ZBIRTHOFYEAR, COUNT( t0.ZBIRTHOFYEAR) AS __var0 FROM ZITEM t0 GROUP BY  t0.ZBIRTHOFYEAR HAVING __var0 > ?
     CoreData: annotation: sql connection fetch time: 0.0002s
     CoreData: annotation: total fetch execution time: 0.0002s for 2 rows.
     [["birthOfYear": 2002, "count": 42], ["birthOfYear": 2003, "count": 44]]
     */

由于结果集中的 count 并非托管对象的属性，无法直接将其使用在 NSPredicate 中。通过 `NSExpression(forVariable:
"count")` 可解决该问题。

直接在 SQLite 中处理，效率将高于在代码中对方法十一的结果集数组进行操作。

## 总结

本文介绍的方法，无所谓孰优孰劣，每种方法都有其适合的场景。掌握更多的基础知识、通盘考量，方可实现高效的解决方案。

# 掌握 SwiftUI 的 Safe Area

Safe Area（安全区域）是指不与导航栏、标签栏、工具栏或其他视图控制器提供的视图重叠的内容空间。

在 UIKit 中，开发者需要利用 safeAreaInsets 或 safeAreaLayoutGuide ，才能确保将视图放置在界面中的可见部分。

SwiftUI 对上述过程进行了彻底的简化。除非开发者明确要求视图突破安全区域的限制，否则 SwfitUI
将尽力确保开发者创建的视图都被布局到安全区域当中。SwiftUI 同时提供了一些方法和工具让开发者对安全区域有所控制。

本文将探讨如何在 SwiftUI 中获取 SafeAreaInsets、将视图绘制到安全区域之外、修改视图的安全区域等内容。

## 如何获取 SafeAreaInsets

### 什么是 SafeAreaInsets

SafeAreaInsets 是用来确定视图安全区域的插入值。

对于根视图来说，safeAreaInsets 反映的是状态栏、导航栏、主页提示器以及 TabBar
等在各个边的占用数值。对于视图层次上的其他视图，safeAreaInesets
只反映视图中被覆盖的部分。如果一个视图可以完整地放置在父视图的安全区域中，该视图的 safeAreaInsets 为 0。当视图尚未在屏幕上可见时，该视图的
safeAreaInset 也为 0 。

在 SwiftUI 中，开发者通常只有在需要获取 StatusBar + NavBar 的高度或 HomeIndeicator + TabBar
的高度时才会使用到 safeAreaInsets 。

### 使用 GeometryReader 获取

GeometryProxy 提供了 safeAreaInsets 属性，开发者可以通过 GeometryReader 获取视图的
safeAreaInsets。

    struct SafeAreaInsetsKey: PreferenceKey {
        static var defaultValue = EdgeInsets()
        static func reduce(value: inout EdgeInsets, nextValue: () -> EdgeInsets) {
            value = nextValue()
        }
    }

    extension View {
        func getSafeAreaInsets(_ safeInsets: Binding<EdgeInsets>) -> some View {
            background(
                GeometryReader { proxy in
                    Color.clear
                        .preference(key: SafeAreaInsetsKey.self, value: proxy.safeAreaInsets)
                }
                .onPreferenceChange(SafeAreaInsetsKey.self) { value in
                    safeInsets.wrappedValue = value
                }
            )
        }
    }

使用方式：

    struct GetSafeArea: View {
        @State var safeAreaInsets: EdgeInsets = .init()
        var body: some View {
            NavigationView {
                VStack {
                    Color.blue
                }
            }
            .getSafeAreaInsets($safeAreaInsets)
        }
    }

    // iphone 13
    // EdgeInsets(top: 47.0, leading: 0.0, bottom: 34.0, trailing: 0.0)

从获得的 insets 可以得知 HomeIndeicator 的高度为 34。

也可以使用下面的代码，进一步了解 safeAreaInsets 在各个层级视图中的状况。

    extension View {
        func printSafeAreaInsets(id: String) -> some View {
            background(
                GeometryReader { proxy in
                    Color.clear
                        .preference(key: SafeAreaInsetsKey.self, value: proxy.safeAreaInsets)
                }
                .onPreferenceChange(SafeAreaInsetsKey.self) { value in
                    print("\(id) insets:\(value)")
                }
            )
        }
    }

例如：

    struct GetSafeArea: View {
        var body: some View {
            NavigationView {
                VStack {
                    Text("Hello world")
                        .printSafeAreaInsets(id: "Text")
                }
            }
            .printSafeAreaInsets(id: "NavigationView")
        }
    }

    // iPhone 13 pro
    // NavigationView insets:EdgeInsets(top: 47.0, leading: 0.0, bottom: 34.0, trailing: 0.0)
    // Text insets:EdgeInsets(top: 0.0, leading: 0.0, bottom: 0.0, trailing: 0.0)

### 从 KeyWindow 中获取

如果只需要获取根视图的 safeAreaInsets ，我们也可以使用更加直接的方式。

> 下面代码取自 [ StackOverFlow ](https://stackoverflow.com/a/68709575/12260342) 网友
> Mirko 的答案

    extension UIApplication {
        var currentWindow: UIWindow? {
            connectedScenes
                .compactMap {
                    $0 as? UIWindowScene
                }
                .flatMap {
                    $0.windows
                }
                .first {
                    $0.isKeyWindow
                }
        }
    }

    private struct SafeAreaInsetsKey: EnvironmentKey {
        static var defaultValue: EdgeInsets {
            UIApplication.shared.currentWindow?.safeAreaInsets.swiftUiInsets ?? EdgeInsets()
        }
    }

    extension EnvironmentValues {
        var safeAreaInsets: EdgeInsets {
            self[SafeAreaInsetsKey.self]
        }
    }

    private extension UIEdgeInsets {
        var swiftUiInsets: EdgeInsets {
            EdgeInsets(top: top, leading: left, bottom: bottom, trailing: right)
        }
    }

可以通过环境值获取到根视图的 safeAreaInsets ：

    @Environment(\.safeAreaInsets) private var safeAreaInsets

## 使用 ignoresSafeArea 忽略安全区域

在开发 iOS 应用时，经常会碰到需要让视图可以扩展到非安全区域的情况。例如，希望让背景颜色充满整个屏幕。

    struct FullScreenView: View {
        var body: some View {
            ZStack {
                Color.blue
                Text("Hello world").foregroundColor(.white)
            }
        }
    }

由于 SwiftUI 在默认的情况下会将用户视图置于安全区之内，因此我们只能得到如下的结果：

![image-20211120141245282](https://cdn.fatbobman.com/image-20211120141245282.png)

为了让视图能够突破安全区域的限制，SwiftUI 提供了 ignoresSafeArea 修饰器。

    struct FullScreenView: View {
        var body: some View {
            ZStack {
                Color.blue
                Text("Hello world").foregroundColor(.white)
            }
            .ignoresSafeArea() // 全方向忽略安全区域
        }
    }

![image-20211120141804145](https://cdn.fatbobman.com/image-20211120141804145.png)

> iOS 13 提供的 edgesIgnoringSafeArea 修饰器已经在 iOS 14.5 中弃用。

ignoresSafeArea 的定义如下：

    @inlinable public func ignoresSafeArea(_ regions: SafeAreaRegions = .all, edges: Edge.Set = .all) -> some View

在默认情况下， `.ignoresSafeArea()` 代表着在全部方向，忽略全部的安全区域划分（SafeAreaRegions）。

通过指定 edges，我们可以让某个或某几个边突破安全区域的限制。

    // 只扩展到底部
    .ignoresSafeArea(edges: .bottom)

    // 扩展到顶部和底部
    .ignoresSafeArea(edges: [.bottom, .trailing])

    // 横向扩展
    .ignoresSafeArea(edges:.horizontal)

使用起来非常直观、方便，但为什么视图会在有键盘输入时出现不符合预期的行为？这是因为，我们并没有正确的设置 ignoresSafeArea 另一个重要的参数
`regions` 。

ignoresSafeArea 相较于 SwiftUI 1.0 提供的 edgesIgnoringSafeArea 最大的提升便是允许我们设置
SafeAreaRegions 。

SafeAreaRegions 定义了三种安全区域划分：

- container

由设备和用户界面内的容器所定义的安全区域，包括诸如顶部和底部栏等元素。

- keyboard

与显示在视图内容上的任何软键盘的当前范围相匹配的安全区域。

- all（默认）

上述两种安全区域划分的合集

iOS 13 并没有提供键盘自动避让功能，开发者需要编写一些额外的代码来解决软键盘不恰当遮盖视图（如 TextField ）的问题。

从 iOS 14 开始，SwiftUI 计算视图的安全区域时，将软键盘在屏幕上的覆盖区域（iPadOS
下，将软键盘缩小后键盘的覆盖区域将被忽略）也一并进行考虑。因此，无需使用任何额外的代码，视图便自动获得了键盘避让的能力。但有时，并非所有的视图都需要将软键盘的覆盖区域从安全区域中去除，因此需要正确地设置
SafeAreaRegions 。

    struct IgnoresSafeAreaTest: View {
        var body: some View {
            ZStack {
                // 渐变背景
                Rectangle()
                    .fill(.linearGradient(.init(colors: [.red, .blue, .orange]), startPoint: .topLeading, endPoint: .bottomTrailing))
                VStack {
                    // Logo
                    Circle().fill(.regularMaterial).frame(width: 100, height: 100).padding(.vertical, 100)
                    // 文本输入
                    TextField("name", text: .constant(""))
                        .textFieldStyle(.roundedBorder)
                        .padding()
                }
            }
        }
    }

![ignoresDemo1](https://cdn.fatbobman.com/ignoresDemo1.gif)

上面的代码尽管实现了键盘的自动避让，但并不完全符合预期行为。首先，背景并没有充满全部屏幕，其次在软键盘弹出时，我们并不希望背景因为安全区域的变化而发生改变。尽管通过
ignoresSafeArea 可以解决上述问题，但在什么位置添加、如何设定还是有一点讲究的。

我们将 ignoresSafeArea 添加到 ZStack 之后：

    ZStack {
        ...
    }
    .ignoresSafeArea()

此时，背景充满了屏幕，也不受软键盘弹出的影响了。但前景的内容失去了键盘自动避让的能力。

![ignoresDemo2](https://cdn.fatbobman.com/ignoresDemo2.gif)

如果将代码修改成：

    ZStack {
        ...
    }
    .ignoresSafeArea(.container)

此时，背景充满了屏幕，前景支持了键盘避让，但背景会在键盘出现时，发生了不该有的变化。

![ignoresDemo3](https://cdn.fatbobman.com/ignoresDemo3.gif)

正确的处理方式是，只让背景忽略安全区域：

    struct IgnoresSafeAreaTest: View {
        var body: some View {
            ZStack {
                Rectangle()
                    .fill(.linearGradient(.init(colors: [.red, .blue, .orange]), startPoint: .topLeading, endPoint: .bottomTrailing))
                    .ignoresSafeArea(.all) // 只让背景忽略安全区域
                VStack {
                    Circle().fill(.regularMaterial).frame(width: 100, height: 100).padding(.vertical, 100)
                    TextField("name", text: .constant(""))
                        .textFieldStyle(.roundedBorder)
                        .padding()
                }
            }
        }
    }

![ignoresDemo4](https://cdn.fatbobman.com/ignoresDemo4.gif)

除了需要对正确的视图设定正确的 ignoresSafeArea 参数外，有时为了获得满意的结果，适当地调整视图的组织形式也是不错的选择。

## 使用 safeAreaInset 扩展安全区域

在 SwiftUI 中，所有基于 UIScrollView
的组件（ScrollView、List、Form），在默认情况下都会充满整个屏幕，但仍可确保我们可以在安全区域内看到所有的内容。

    List(0..<100){ id in
        Text("id\(id)")
    }

![safeAreInsetList1](https://cdn.fatbobman.com/safeAreInsetList1.png)

当被嵌入到 TabView 时，TabView 会调整其内部的安全区域。

![safeAreaInsetList2](https://cdn.fatbobman.com/safeAreaInsetList2.png)

遗憾的是，在 iOS 15 之前，SwiftUI 并没有提供调整视图安全区的手段，如果我们想通过 SwiftUI 的手段创建一个自定义 Tabbar
时，列表中最后的内容将被 Tabbar 遮挡。

safeAreaInset 修饰符的出现解决了上述的问题。通过 safeAreaInset，我们可以缩小视图的安全区域，以确保所有内容都可以按预期显示。

例如：

    struct AddSafeAreaDemo: View {
        var body: some View {
            ZStack {
                Color.yellow.border(.red, width: 10)
            }
            .safeAreaInset(edge: .bottom, alignment: .center, spacing: 0) {
                Rectangle().fill(.blue)
                    .frame(height: 100)
            }
            .ignoresSafeArea()
        }
    }

我们使用了 safeAreaInset，将 ZStack 内部的安全区从底边缩小了 100，并在此处显示了一个蓝色的矩形。

![image-20211120165303239](https://cdn.fatbobman.com/image-20211120165303239.png)

利用 safeAreaInset，可以让 List 在自定义的 TabBar 中表现同系统 TabBar 一致的行为。

    struct AddSafeAreaDemo: View {
        var body: some View {
            NavigationView {
                List(0..<100) { i in
                    Text("id:\(i)")
                }
                .safeAreaInset(edge: .bottom, spacing: 0) {
                    Text("底部状态条")
                        .font(.title3)
                        .foregroundColor(.indigo)
                        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: 40)
                        .padding()
                        .background(.green.opacity(0.6))

                }
            }
        }
    }

在 iPhone 13 下的表现

![safeAreaTabbarDemo1](https://cdn.fatbobman.com/safeAreaTabbarDemo1-7400021.gif)

我们只调整了安全区域， SwiftUI 会自动在不同的设备上进行适配（在 iPhone 13 上，状态条的高度为 40 + HomeIndeicator
区域高度）。

> 自动适配只对 **background** 有效。

相同的代码，在 iPhone 8 下的表现

![image-20211120172325088](https://cdn.fatbobman.com/image-20211120172325088.png)

> iOS 15.2 之前的版本，safeAreaInset 对 List 和 Form 的支持有问题（ScrollView
> 表现正常），无法将列表最后的内容全部显示完整。该 Bug 已在 iOS 15.2 中得到了修复。本文中的代码，在 Xcode 13.2 beta (13
> C 5066 c) 之后的版本都可以获得符合预期的表现。

![image-20211120170839227](https://cdn.fatbobman.com/image-20211120170839227.png)

safeAreaInset 可以叠加，这样我们可以在多个边对安全区域进行调整，例如：

    ZStack {
        Color.yellow.border(.red, width: 10)
    }
    .safeAreaInset(edge: .bottom, alignment: .center, spacing: 0) {
        Rectangle().fill(.blue)
            .frame(height: 100)
    }
    .safeAreaInset(edge: .trailing, alignment: .center, spacing: 0) {
        Rectangle().fill(.blue)
            .frame(width: 50)
    }

我们也可以通过 aligmnet 为安全区域插入内容设置对齐方式，用 spacing 在想要显示的内容和安全区域添加内容之间添加额外的空间。

尽管使用 safeAreaInset 为列表在底部添加状态栏或自定义 TabBar 非常方便， **但如果你的列表中使用了
TextField，情况将变得很麻烦** 。

比如，下面是一个很极端的例子：

    struct AddSafeAreaDemo: View {
        var body: some View {
            ScrollView {
                ForEach(0..<100) { i in
                    TextField("input text for id:\(i)",text:.constant(""))
                }
            }
            .safeAreaInset(edge: .bottom, spacing: 0) {
                Text("底部状态条")
                    .font(.title3)
                    .foregroundColor(.indigo)
                    .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: 40)
                    .padding()
                    .background(.green.opacity(0.6))
                    .ignoresSafeArea(.all)
            }
        }
    }

![safeAreaStatusBarWithTextField](https://cdn.fatbobman.com/safeAreaStatusBarWithTextField.gif)

我们是无法通过使用 ignoresSafeArea，让 TextField
在保持对键盘自动避让的情况下，固定底部的状态条。此时，底部状态条的表现肯定不符合设计的初衷。

如果想让底部状态条固定，同时又保持 TextField 的自动避让能力，需要通过监控键盘的状态，做一点额外的操作。

    final class KeyboardMonitor: ObservableObject {
        @Published var willShow: Bool = false
        private var cancellables = Set<AnyCancellable>()
        init() {
            NotificationCenter.default.publisher(for: UIResponder.keyboardWillShowNotification, object: nil)
                .sink { _ in
                    self.willShow = true
                }
                .store(in: &cancellables)
            NotificationCenter.default.publisher(for: UIResponder.keyboardWillHideNotification, object: nil)
                .sink { _ in
                    self.willShow = false
                }
                .store(in: &cancellables)
        }
    }

    struct AddSafeAreaDemo: View {
        @StateObject var monitor = KeyboardMonitor()
        var body: some View {
            ScrollView {
                ForEach(0..<100) { i in
                    TextField("input text for id:\(i)", text: .constant(""))
                }
            }
            .safeAreaInset(edge: .bottom, spacing: 0) {
                if !monitor.willShow { // 在键盘即将弹出时隐藏
                    Text("底部状态条")
                        .font(.title3)
                        .foregroundColor(.indigo)
                        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: 40)
                        .padding()
                        .background(.green.opacity(0.6))
                        .ignoresSafeArea(.all)
                }
            }
        }
    }

![safeAreaStatusBarWithTextFieldKeyMonitor](https://cdn.fatbobman.com/safeAreaStatusBarWithTextFieldKeyMonitor.gif)

> 如果上述的代码被放置在 NavigationView 中，还需要对底部状态条动画做更加精细地处理。

### 实战：用 safeAreaInset 实现类似微信的对话页面

使用 safeAreaInset，我们只需很少的代码便可以实现一个类似微信的对话页面。

![safeAreaChatDemo](https://cdn.fatbobman.com/safeAreaChatDemo.gif)

    struct ChatBarDemo: View {
        @State var messages: [Message] = (0...60).map { Message(text: "message:\($0)") }
        @State var text = ""
        @FocusState var focused: Bool
        @State var bottomTrigger = false
        var body: some View {
            NavigationView {
                ScrollViewReader { proxy in
                    List {
                        ForEach(messages) { message in
                            Text(message.text)
                                .id(message.id)
                        }
                    }
                    .listStyle(.inset)
                    .safeAreaInset(edge: .bottom) {
                        ZStack(alignment: .top) {
                            Color.clear
                            Rectangle().fill(.secondary).opacity(0.3).frame(height: 0.6) // 上部线条
                            HStack(alignment: .firstTextBaseline) {
                                // 输入框
                                TextField("输入", text: $text)
                                    .focused($focused)
                                    .textFieldStyle(.roundedBorder)
                                    .padding(.horizontal, 10)
                                    .padding(.top, 10)
                                    .onSubmit {
                                        addMessage()
                                        scrollToBottom()
                                    }
                                    .onChange(of: focused) { value in
                                        if value {
                                            scrollToBottom()
                                        }
                                    }
                                // 回复按钮
                                Button("回复") {
                                    addMessage()
                                    scrollToBottom()
                                    focused = false
                                }
                                .buttonStyle(.bordered)
                                .controlSize(.small)
                                .tint(.green)
                            }
                            .padding(.horizontal, 30)
                        }
                        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: 53)
                        .background(.regularMaterial)
                    }
                    .onChange(of: bottomTrigger) { _ in
                        withAnimation(.spring()) {
                            if let last = messages.last {
                                proxy.scrollTo(last.id, anchor: .bottom)
                            }
                        }
                    }
                    .onAppear {
                        if let last = messages.last {
                            proxy.scrollTo(last.id, anchor: .bottom)
                        }
                    }
                }
                .navigationBarTitle("SafeArea Chat Demo")
            }
        }

        func scrollToBottom() {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.25) {
                bottomTrigger.toggle()
            }
        }

        func addMessage() {
            if !text.isEmpty {
                withAnimation {
                    messages.append(Message(text: text))
                }
                text = ""
            }
        }
    }

    struct Message: Identifiable, Hashable {
        let id = UUID()
        let text: String
    }

## 总结

在 SwiftUI 中，有不少的功能都属于看一眼就会，但用起来就废的情况。即使表面上平平无奇的功能，仔细深挖仍可获得不少收获。

# HowTo —— SwiftUI2.0 使用 ProgressView 显示进度条

SwiftUI 2.0 新增了一些便捷的内置控件，比如说 Label、ProgressView 等。其基本形态都很普通，不过都支持自定义
style。官方的意图也比较明显，通过内置控件，规范代码、提高原型编写速度，如需要更精细控制可通过扩展 style 来完成。

## 经典小菊花

    ProgressView()

![progress1](https://cdn.fatbobman.com/howto-swiftui-progressView-
progress1.png)

## 线性进度条

    ProgressView("完成量", value: 50, total: 100)

![截屏 2020-07-11 下午 4.09.34](https://cdn.fatbobman.com/howto-swiftui-
progressView-progress2.png)

## 代码示例

    import SwiftUI

    struct ProgressTest: View {
        @State var timer = Timer.TimerPublisher(interval: 0.03, runLoop: .main, mode: .common).autoconnect()
        @State var value:Double = 0.0
        var body: some View {
            List{
                //无法定义颜色
                ProgressView()

                //无法隐藏 Label
                ProgressView("完成量", value: value, total: 100)
                    .accentColor(.red)
                //自定义 Style
                ProgressView("工程进度",value: value, total: 100)
                    .progressViewStyle(MyProgressViewStyle())
            }
            .onAppear {
                timer = Timer.TimerPublisher(interval: 0.03, runLoop: .main, mode: .common).autoconnect()
            }
            .onReceive(timer) { _ in
                if value < 100 {
                    value += 2
                }
            }
        }
    }

    //定义方法都大同小异。
    struct MyProgressViewStyle:ProgressViewStyle{
        let foregroundColor:Color
        let backgroundColor:Color
        init(foregroundColor:Color = .blue,backgroundColor:Color = .orange){
            self.foregroundColor = foregroundColor
            self.backgroundColor = backgroundColor
        }
        func makeBody(configuration: Configuration) -> some View {
            GeometryReader{ proxy in
                ZStack(alignment:.topLeading){
                backgroundColor
                Rectangle()
                    .fill(foregroundColor)
                    .frame(width:proxy.size.width * CGFloat(configuration.fractionCompleted ?? 0.0))
                }.clipShape(RoundedRectangle(cornerRadius: 10))
                .overlay(
                        configuration.label
                            .foregroundColor(.white)
                )
            }
        }
    }

你的浏览器不支持本视频

# WWDC 2023 Core Data 有哪些新变化

虽然在 WWDC 2023 上，苹果将主要精力放在介绍新的数据框架 SwiftData 上，但作为 SwiftData 的基石，Core Data
也得到了一定程度上的功能增强。本文将介绍今年 Core Data 获得的新功能。

## 复合属性（ Composite attributes）

复合属性是 Core Data
为实体（Entity）提供的一种新的自定义属性（Attribute）。通过它，开发者可以将复杂的数据类型通过自定义的方式封装在一起。

举个例子，我们有一个餐厅（Restaurant）实体：

    public class Restaurant:NSManagedObject {
        @NSManaged public var address: String?
        @NSManaged public var name: String?
        @NSManaged public var phoneNumber: String?
        @NSManaged public var rating: Double
    }

在复合属性出现之前，我们有三种可选方案来为该餐厅添加其经纬度信息：

1. 分别创建经度和纬度属性，并创建一个计算属性 location 以改善代码的可读性。
2. 创建一个 Location 实体，包含经度和纬度两个属性，并在 Restaurant 实体与 Location 实体之间创建一对一关系。
3. 创建一个 Location 结构，在 Restaurant 实体中将其声明为 Transformable 属性。

这三种方案都有各自的优缺点：

- 方案一：性能最佳，经纬度属性都可以单独作为谓词的判断条件。但当有多个实体都有相同的需求时，需要为每个实体进行重复的设置工作。复合类型（例如：Location）越复杂，需要进行的重复操作也越多。
- 方案二：经纬度属性都可以单独作为谓词的判断条件，但相对于第一种方案，在检索时性能稍有下降。
- 方案三：经纬度不能作为谓词的判断条件（数据已转换为不可检索的状态），在保存和读取数据时，会因编解码而有一定的性能损失。

Composite attributes 为开发者提供了一个全新的选择。

首先我们需要在 Xcode 的 Data Model Editor 中自定义一个 Composite Attributes。

![add-composite-attributes-2023-07-03](https://cdn.fatbobman.com/add-
composite-attributes-2023-07-03.png)

然后，采用与定义 Entity 类似的方式，在自定义的 Composite Attributes 中添加属性。

![add-attributes-in-composite-
attributes-2023-07-03](https://cdn.fatbobman.com/add-attributes-in-composite-
attributes-2023-07-03.png)

在定义 Composite Attributes 时，我们可以使用 Core Data 为 Entity 提供的任意属性，例如
String、Double、Date 等，同时也可以使用其他已经定义好的 Composite Attributes。支持嵌套也是 Composite
Attributes 的一个非常显著的特点。

最后，我们便可以在 Entity 中，像使用其他 Core Data 提供的预置属性一样，使用自定义的 Composite Attributes 了。

![use-composite-attributes-in-enity-2023-07-03](https://cdn.fatbobman.com/use-
composite-attributes-in-enity-2023-07-03.png)

需要注意的是，自定义的 Composite Attributes 只是一种对 Entity 属性类型的抽象描述，Core Data
并不会在代码中为其生成对应的类型。在 SQLite 中，Composite Attributes 采用了与方案一相同的存储模式（在 Entity
对应的表中，将 Composite Attributes 的所有属性展开，并为其创建独立的字段）。

![composite-attribues-in-
sqlite-2023-07-03](https://cdn.fatbobman.com/composite-attribues-in-
sqlite-2023-07-03.png)

在代码中 Composite Attributes 被声明为 `[String:Any]?` 类型：

    public class Restaurant:NSManagedObject {
        @NSManaged public var address: String?
        @NSManaged public var name: String?
        @NSManaged public var phoneNumber: String?
        @NSManaged public var rating: Double

        @NSManaged public var location: [String: Any]?
    }

目前，我们仍需通过字典的方式在托管对象中设置和读取该属性的内容：

    let newRestaurant = Restaurant(context: viewContext)
    newRestaurant.address = address
    newRestaurant.name = name
    newRestaurant.phoneNumber = phoneNumber
    newRestaurant.rating = rating
    newRestaurant.location = [
        "latitude": 39.90469,
        "longitude": 116.40528,
    ]

然而，在设置谓词时，可以直接使用带有命名空间的 keyPath 方式进行访问：

    let predicate = NSPredicate(format:"location.latitude > %f AND location.latitude < %f",31.3,40.0)

> **提示** ：在官方有关 Composite Attributes 的 [ 文档
> ](https://developer.apple.com/documentation/coredata/nscompositeattributedescription?changes=_3)
> 中，出现了如下的演示代码。我们希望在之后的更新中，可以通过这种方式直接访问 Composite Attributes 中的子属性。

    // Use property-like setters and getters to manage the underlying attributes directly.
    quake.magnitude.richter = 4.6
    print(quake.magnitude.richter)

## 在 Core Data 中使用新的 Predicate

长久以来，Core Data 开发人员一直希望能够以更加 Swift 的方式创建安全易懂的 Predicate。在今年，这个愿望终于因 Foundation
的 Swift 化得以实现。

开发人员可以通过以下方式为 SwiftData 创建谓词：

    let today = Date()
    let tripPredicate = #Predicate<Trip> {
        $0.destination == "New York" &&
        $0.name.contains("birthday") &&
        $0.startDate > today
    }

庆幸的是，在这次 Predicate 的更新中，Core Data 没有被抛弃。开发者可以通过新的 NSPredicate 构建方法，将 Predicate
转换为 NSPredicate。

例如：

    let p = #Predicate<Restaurant>{
        $0.rating > 3.5
    }

    let predicate = NSPredicate(p)

需要注意两点：

- 只有为 NSObject 的子类创建的 Predicate 才能转换为 NSPredicate，也就是说，为 SwiftData 创建的 Predicate 是无法转换成 Core Data 对应的托管对象可用的谓词。
- 目前还无法在 Predicate 中直接通过 keyPath 的方式访问 Composite Attributes 的属性。

## VersionChecksum

在今年，NSManagedObjectModel 增加了一个新的属性 `versionChecksum` 。该属性对应该数据模型的 Base 64
编码的 128 位模型版本哈希值。

> 此值也可在版本化模型的 `VersionInfo.plist` 文件和 Xcode 的构建日志中找到。

这个值有两个作用：

- 用于在阶段式迁移中，为不同版本的数据模型创建 `NSManagedObjectModelReference` ，下文中有更多说明。
- 在 SwiftData 与 Core Data 并行的项目中，用于比对两者是否使用相同版本的数据模型。

例如，我们可以通过下面的代码获取 SwiftData 当前使用的模型 versionChecksum 值，然后在 CoreDataStack
中，通过与该值进行比较，就可以知道两者是否使用相同的数据模型。

    @main
    struct PredicateTestApp: App {
        let container = try! ModelContainer(
            for: Item.self
        )
        var body: some Scene {
            WindowGroup {
                ContentView()
                    .onAppear {
                        if let versionChecksum = container.schema.makeManagedObjectModel()?.versionChecksum {
                            print(versionChecksum)
                        }
                    }
            }
            .modelContainer(container)
        }
    }

## 延迟迁移（Deferred migration）

在 Core Data 进行数据模型迁移的过程中，如果数据量很大，迁移操作很复杂，应用会出现 UI 无法响应的情况，给用户带来不好的用户体验。

在本次 Core Data 的更新中，苹果为 Core Data 添加了延迟迁移（Deferred
migration）的功能，可以在某种程度上缓解因上述原因导致的使用者不适。

注意事项：

- 延迟迁移只能针对轻量级迁移过程中的部分操作。
- 任何可能导致数据模型不兼容的操作都不能被延迟。
- 延迟迁移仅适用于 SQLite 存储类型。
- 延迟迁移具备向后兼容性，可追溯到 iOS 14 以及 Big Sur。
- 延迟迁移同样适用于今年新增的阶段式迁移。

用更容易理解的方式来说：在开启延迟迁移功能后，Core Data
会从轻量级迁移的操作中判断哪些操作即使在迁移的过程中暂不进行，也不会影响应用对最终完成的数据模型版本数据库的操作（例如，更新索引、删除已经不需要的属性，从有序关系更改为非有序关系等操作）。Core
Data 将先跳过这些操作，直到开发者在应用中找到合适的时机，通过代码显式地执行这些“善后”操作。

要开启延迟迁移功能，需要在存储选项中将 NSPersistentStoreDeferredLightweightMigrationOptionKey 设置为
true。

    let options = [
        NSPersistentStoreDeferredLightweightMigrationOptionKey: true,
        NSMigratePersistentStoresAutomaticallyOption: true,
        NSInferMappingModelAutomaticallyOption: true
    ]

    let store = try coordinator.addPersistentStore(
        ofType: NSSQLiteStoreType,
        configurationName: nil,
        at: storeURL,
        options: options
    )

在必要的迁移操作完成后，开发者可以在适当的时机通过调用 `finishDeferredLightweightMigration`
方法执行”清理”工作（苹果建议在 `BGProcessingTask` 中进行）：

    let metadata = coordinator.metadata(for: store)
    if (metadata[NSPersistentStoreDeferredLightweightMigrationOptionKey] == true) {
        coordinator.finishDeferredLightweightMigration()
    }

## 阶段式迁移（ Staged migration ）

在当前版本的 Core Data 中，开发者最常使用以下三种数据迁移方式：

- 轻量级迁移

如果两个数据模型版本之间的更改很简单，Core Data 可以自行推断映射模型，那么无需开发者提供更多的信息，Core Data
将自动在两个版本中进行数据迁移。

- 自定义映射模型

如果开发者对数据模型做了更深层次的调整，导致 Core Data 无法自动推断映射模型，此时，开发者可以通过 Xcode Model Editor
创建一个针对两个特定版本之间的映射模型（ Mapping Model），通过自定义映射模型中提供的额外信息，帮助 Core Data
完成在两个版本间的数据迁移操作。

- 自定义实体映射策略

如果自定义映射模型提供的表达式仍无法满足迁移的需求，开发者则需要创建自定义实体映射策略（NSEntityMigrationPolicy
的子类），NSEntityMigrationPolicy 提供了一些方法，用于覆盖默认的数据迁移操作。

> 虽然 Core Data 本身提供了一种高度可控的渐进式迁移方法，但由于其对开发人员不太友好，需要编写大量代码，因此在实际开发中很少使用。

由于 SwiftData 并不使用 Xcode 的 Model Editor，因此苹果需要为其提供一种不依赖 Mapping Model
文件的迁移方式。同时原有的编写自定义实体映射策略的方式对开发者也不太友好。为此，SwiftData 使用了基于阶段式迁移（Stage
migration）的数据迁移方式。作为 SwiftData 的基础，Core Data 自然也新增了该迁移模式。

> 本文不会对阶段式迁移进行详尽的说明，未来会通过其他文章对其进行深入探讨。

阶段式迁移包含两种迁移模式：轻量级迁移（NSLightweightMigrationStage）和自定义迁移（NSCustomMigrationStage）。它鼓励开发者将非轻量级迁移的迁移任务分解一系列的轻量级迁移的步骤。通过创建多个阶段，用最少的代码量，将数据模型迁移到最新版本。

一般来说，阶段性迁移分为以下几个步骤：

### 描述数据模型版本的承诺。

通过为分阶段迁移声明多个 NSManagedObjectModelReference 类，描述特定版本的 NSManagedObjectModel
承诺。在迁移期间，Core Data 将实现此承诺。

    let v1ModelChecksum = "kk8XL4OkE7gYLFHTrH6W+EhTw8w14uq1klkVRPiuiAk="
    let v1ModelReference = NSManagedObjectModelReference(
        modelName: "modelV1"
        in: NSBundle.mainBundle
        versionChecksum: v1ModelChecksum
    )

    let v2ModelChecksum = "PA0Gbxs46liWKg7/aZMCBtu9vVIF6MlskbhhjrCd7ms="
    let v2ModelReference = NSManagedObjectModelReference(
        modelName: "modelV2"
        in: NSBundle.mainBundle
        versionChecksum: v2ModelChecksum
    )

    let v3ModelChecksum = "iWKg7bxs46g7liWkk8XL4OkE7gYL/FHTrH6WF23Jhhs="
    let v3ModelReference = NSManagedObjectModelReference(
        modelName: "modelV3"
        in: NSBundle.mainBundle
        versionChecksum: v3ModelChecksum
    )

上述代码为三个不同版本的数据模型创建了承诺。Core Data 会通过检查 versionChecksum 来确保数据版本的正确性。

Core Data 的阶段式迁移（ Staged migration ）功能，旨在为 SwiftData
迁移提供底层支持，因此在获取模型文件时，采用了比较晦涩的方式。建议开发者在进行迁移时，通过直接访问不同版本模型的 mom
文件来构建模型实例，从而确保准确获取模型数据。

例如，我们创建了两个模型版本，对应的版本名称分别为 `Model` 和 `Model 2` ：

![image-20240224091208428](https://cdn.fatbobman.com/image-20240224091208428.webp)

可以用如下的方式来构建对应的 `NSManagedObjectModelReference` 实例：

    guard let momdURL = Bundle.main.url(forResource: "Model", withExtension: "momd") else { fatalError() }
    let model1URL = momdURL.appending(component: "Model.mom")
    let model2URL = momdURL.appending(component: "Model 2.mom")
    guard let model1 = NSManagedObjectModel(contentsOf: model1URL) else { fatalError() }
    guard let model2 = NSManagedObjectModel(contentsOf: model2URL) else { fatalError() }

    let v1ModelChecksum = model1.versionChecksum
    let v1ModelReference = NSManagedObjectModelReference(model: model1, versionChecksum: v1ModelChecksum)

    let v2ModelChecksum = model2.versionChecksum
    let v2ModelReference = NSManagedObjectModelReference(model: model2, versionChecksum: v2ModelChecksum)

由于 SwiftData 并不依赖数模模型文件，因此在 SwiftData 中，承诺的方式略有不同（通过代码将每个版本的模型表述出来）。

    enum SampleTripsSchemaV1: VersionedSchema {
        static var models: [any PersistentModel.Type] {
            [Trip.self, BucketListItem.self, LivingAccommodation.self]
        }

        @Model
        final class Trip {
            var name: String
            var destination: String
            var start_date: Date
            var end_date: Date

            var bucketList: [BucketListItem]? = []
            var livingAccommodation: LivingAccommodation?
        }

        // Define the other models in this version...
    }

    enum SampleTripsSchemaV2: VersionedSchema {
        static var models: [any PersistentModel.Type] {
            [Trip.self, BucketListItem.self, LivingAccommodation.self]
        }

        @Model
        final class Trip {
            @Attribute(.unique) var name: String
            var destination: String
            var start_date: Date
            var end_date: Date

            var bucketList: [BucketListItem]? = []
            var livingAccommodation: LivingAccommodation?
        }

        // Define the other models in this version...
    }

    enum SampleTripsSchemaV3: VersionedSchema {
        static var models: [any PersistentModel.Type] {
            [Trip.self, BucketListItem.self, LivingAccommodation.self]
        }

        @Model
        final class Trip {
            @Attribute(.unique) var name: String
            var destination: String
            @Attribute(originalName: "start_date") var startDate: Date
            @Attribute(originalName: "end_date") var endDate: Date

            var bucketList: [BucketListItem]? = []
            var livingAccommodation: LivingAccommodation?
        }

        // Define the other models in this version...
    }

### 描述所需的迁移阶段

在上文中，我们创建了用于 Core Data 阶段式迁移的三个版本承诺：V 1、V 2、V 3。因此，我们需要描述两个迁移阶段：V 1 → V 2，V 2
→ V 3。

    let lightweightStage = NSLightweightMigrationStage([v1ModelChecksum])
    lightweightStage.label = "V1 to V2: Add flightData attribute"

    let customStage = NSCustomMigrationStage(
        migratingFrom: v2ModelReference,
        to: v3ModelReference
    )

    customStage.label = "V2 to V3: Denormalize model with FlightData entity"

在从 V 1 迁移到 V 2 时，我们认为自动迁移已经可以满足需求，因此不需要提供其他辅助代码。但是在从 V 2 迁移到 V 3
时，我们考虑到自动迁移无法满足要求，因此需要通过自定义代码来进行迁移。

    customStage.willMigrateHandler = { migrationManager, currentStage in
        guard let container = migrationManager.container else {
            return
        }

        let context = container.newBackgroundContext()
        try context.performAndWait {
            let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "Aircraft")
            fetchRequest.predicate = NSPredicate(format: "flightData != nil")

            do {
               var fetchedResults: [NSManagedObject]
               fetchedResults = try viewContext.fetch(fetchRequest)

               for airplane in fetchedResults {
                    let fdEntity = NSEntityDescription.insertNewObject(
                        forEntityName: "FlightData",
                        into: context
                    )

                    let flightData = airplane.value(forKey: "flightData")
                    fdEntity.setValue(flightData, forKey: “data”)
                    fdEntity.setValue(airplane, forKey: "aircraft")
                    airplane.setValue(nil, forKey: "flightData")
                }
                try context.save()
            } catch {
                // Handle any errors that may occur
            }
        }
    }

在上述代码中，通过调用开发者提供的 willMigrateHandler 闭包，在执行从 V 2 版本迁移到 V 3 版本的操作前读取了原有数据的
airplane 属性（该属性为 Transformable 类型）。我们使用 airplane 中的数据创建了新的 FlightData 实体（该实体与
Aircraft 是一对一的关系）。

SwiftData 中也有类似的对应操作：

    enum SampleTripsMigrationPlan: SchemaMigrationPlan {
        static var schemas: [any VersionedSchema.Type] {
            [SampleTripsSchemaV1.self, SampleTripsSchemaV2.self, SampleTripsSchemaV3.self]
        }

        static var stages: [MigrationStage] {
            [migrateV1toV2, migrateV2toV3]
        }

        static let migrateV1toV2 = MigrationStage.custom(
            fromVersion: SampleTripsSchemaV1.self,
            toVersion: SampleTripsSchemaV2.self,
            willMigrate: { context in
                let trips = try? context.fetch(FetchDescriptor<SampleTripsSchemaV1.Trip>())

                // De-duplicate Trip instances here...

                try? context.save()
            }, didMigrate: nil
        )

        static let migrateV2toV3 = MigrationStage.lightweight(
            fromVersion: SampleTripsSchemaV2.self,
            toVersion: SampleTripsSchemaV3.self
        )
    }

### 启用阶段式迁移操作

创建一个带有轻量级迁移阶段和自定义迁移阶段的 NSStagedMigrationManager，并将其添加到
NSPersistentStoreDescription 选项中，从而让 Core Data 开启阶段式迁移操作。

    let migrationStages = [lightweightStage, customStage]
    let migrationManager = NSStagedMigrationManager(migrationStages)

    let persistentContainer = NSPersistentContainer(
        path: "/path/to/store.sqlite",
        managedObjectModel: myModel
    )

    var storeDescription = persistentContainer?.persistentStoreDescriptions.first

    storeDescription?.setOption(
        migrationManager,
        forKey: NSPersistentStoreStagedMigrationManagerOptionKey
    )

    persistentContainer?.loadPersistentStores { storeDescription, error in
        if let error = error {
            // Handle any errors that may occur
        }
    }

在 SwiftData 中设置阶段式迁移的代码：

    struct TripsApp: App {
        let container = ModelContainer(
            for: Trip.self,
            migrationPlan: SampleTripsMigrationPlan.self
        )

        var body: some Scene {
            WindowGroup {
                ContentView()
            }
            .modelContainer(container)
        }
    }

相较于之前的迁移方式，阶段式迁移具有更清晰的条理；实现自定义迁移操作的代码量更少，难度也更低。然而，从另一个方面来说，这也需要开发者对迁移过程有更多的了解，并根据需要及时创建数据模型（将非轻量级迁移的迁移任务及时分解成一系列轻量级迁移步骤）。

## 最后

作为 SwiftData 的基石，苹果在未来的几年中不论是有意还是无意，仍会持续为 Core Data 添加一些新的 API。考虑到 SwiftData
还需要几年的成熟时间，因此在未来的日子里，许多开发者都需要在一个项目中同时使用 SwiftData 和 Core Data。因此，及时了解 Core
Data 的新功能和新动向仍有相当的价值。

# 实时切换 Core Data 的云同步状态

在 WWDC 2019 上，苹果推出了 Core Data with CloudKit API ，极大地降低了 Core Data
数据的云同步门槛。由于该服务对于开发者来说几乎是免费的，因此在之后的几年中，越来越多的开发者在应用中集成了该服务，并为用户带来了良好的跨设备、跨平台的使用体验。本文将对实时切换
Core Data 云同步状态的实现原理、操作细节以及注意事项进行探讨和说明。

> 如果你对 Core Data with CloudKit 尚不了解，请阅读我写的 [ 有关 Core Data with CloudKit 的系列文章
> ](/zh/posts/coredatawithcloudkit-1/)

## 非实时切换

所谓非实时切换是指：对 Core Data
云同步状态的修改并不能立即生效，同步状态只有在应用再次冷启动后才会发生改变。如果对同步状态切换的实时性没有迫切的需求，那么应该以此种切换方式为首选。

### 不设置 cloudKitContainerOptions

开发者通过对 NSPersistentStoreDescription 的 cloudKitContainerOptions 属性进行设置，让
NSPersistentStoreDescription（ 在 Data Model Editor 中通过 Configuration 创建 ）
中的持久化存储与某个 CloudKit container 关联起来。如果我们不对 cloudKitContainerOptions 进行设置（ 或设置为
nil ），那么 NSPersistentCloudKitContainer 将不会在此 NSPersistentStoreDescription
上启用网络同步功能。我们可以利用这一点来设置 NSPersistentCloudKitContainer 的同步状态。

> 由于对 NSPersistentStoreDescription 的设置必须在 loadPersistentStores
> 之前完成，因此使用此种方式进行的状态设置，通常会在应用的下次冷启动后生效（ 理论上，也可以通过创建新的
> NSPersistentCloudKitContainer 实例来实现，但在单 container
> 的情况下，为了保证托管对象上下文中数据的完整性，需要照顾太多的可能性，难度较高 ）。

    lazy var container:NSPersistentCloudKitContainer = {
        let container = NSPersistentCloudKitContainer(name: "Model")
        let enableMirror = UserDefaults.standard.bool(forKey: "enableMirror")
        if enableMirror {
            container.persistentStoreDescriptions.first?.cloudKitContainerOptions = .init(containerIdentifier: "YourCloudKitContainerID")
        }
        // 其他设定
        container.loadPersistentStores{ desc,error in
            // ..
        }
        // 其他设定
        return container
    }()

### 统一成 NSPersistentContainer

如果你的应用只使用了同步私有数据库的功能，那么也可以利用 NSPersistentCloudKitContainer 是
NSPersistentContainer 的子类这一事实，来达到类似的目的：

    lazy var container1:NSPersistentContainer = {
        let container:NSPersistentContainer
        let enableMirror = UserDefaults.standard.bool(forKey: "enableMirror")
        if enableMirror {
            container = NSPersistentCloudKitContainer(name: "Model")
            container.persistentStoreDescriptions.first?.cloudKitContainerOptions = .init(containerIdentifier: "YourCloudKitContainerID")
        } else {
            container = NSPersistentContainer(name: "Model")
        }
        // 其他设定
        container.loadPersistentStores{ desc,error in
            // ..
        }
        // 其他设定
        return container
    }()

## NSPersistentCloudKitContainer 是如何运作的

在介绍如何实现实时切换同步状态之前，我们首先需要对 NSPersistentCloudKitContainer 的构成和工作机制有所了解。

NSPersistentCloudKitContainer 由如下几个功能模块所构成：

### NSPersistentContainer

NSPersistentCloudKitContainer 是 NSPersistentContainer 的子类，拥有
NSPersistentContainer 的全部能力。除了少量用于共享和公共数据鉴权 API 之外，开发者几乎百分百地只与
NSPersistentCloudKitContainer 中 NSPersistentContainer
部分打交道。因此从大的角度划分，NSPersistentCloudKitContainer 就是 NSPersistentContainer
加上网络处理部分。

### Persistent History Tracking 处理 + 格式转换模块

通过默认启用 Persistent History Tracking 支持，NSPersistentCloudKitContainer 可以获知应用在
SQLite 上的所有操作，然后将数据转换成 CloudKit 对应的格式，并保存在 SQLite 上的特定表中（
ANSCKEXPORT…、ANSCKMIRROREDRELATIONSHIP 等 ），待网络同步模块将其同步（ Export ）到云上。

同样对于从云上同步（ Import ）过来的数据，该模块会将其转换成 Core Data 对应的格式，并修改在 SQLite
中对应的数据。全部的修改操作将以 NSCloudKitMirroringDelegate. import（ Transaction author
）的身份记录在 Persistent History Tracking 的 Transaction 数据中。

> 由于该过程是在由 NSPersistentContainer 上创建的私有上下文中进行的，因此只需要将 `viewContext.automaticallyMergesChangesFromParent` 设置为 true
> ，即可实现数据在视图上下文中的自动合并，而无需对 Persistent History Tracking 创建的 Transaction 做处理。

通过使用 Persistent History Tracking 这一支持跨进程级别的数据修改提醒机制，让 NSPersistentContainer
与网络同步功能之间形成了解耦。

> 有关 Persistent History Tracking 方面的内容，请参阅 [ 在 CoreData 中使用持久化历史跟踪
> ](/zh/posts/persistenthistorytracking/) 一文。想了解 Core Data 是如何在 SQLite
> 上组织数据的，请参阅 [ Core Data 是如何在 SQLite 中保存数据的
> ](/zh/posts/tables_and_fields_of_coredata/) 一文

### 网络同步模块

对于 Export 数据，该模块将择机（ 视网络状况、数据更新频率等 ）将转换后的数据上传到 iCloud 上。

对于 Import 数据，该模块在获得云端数据变更通知后（ 通过开启 Remote notifications ），会将网络端的变更数据保存到 SQLite
中，供转换模块使用。

所有的网络同步操作都将以日志的形式保存在 SQLite 中。在 iCloud 账户状态发生变动后，NSPersistentCloudKitContainer
将使用这些同步记录作为数据重置的凭据。

### 数据权限模块

在开启 NSPersistentCloudKitContainer
的同步共享数据库或公共数据库功能后，为了提高数据操作权限的验证效率，该模块会将共享或公共数据库在 iCloud 上对应的原始数据（
CKRecordType、记录令牌等 ）备份在本地的 SQLite 中，并提供鉴权 API 供开发者调用。

## 实时切换的原理

NSPersistentCloudKitContainer 这种模块化的构成方式，为实现实时切换同步状态提供了基础。

通过创建双 container （ NSPersistentContainer + NSPersistentCloudKitContainer
），我们将应用程序中对于 Core Data 的操作同网络同步功能分离开来。

两个 Container 都使用相同的 Data Model，并均开启 Persistent History Tracking 功能以感知对方在
SQLite 上的数据修改操作。程序中有关数据业务逻辑的操作在 NSPersistentContainer 实例上进行，而
NSPersistentCloudKitContainer 实例仅负责数据的网络同步服务。

如此一来，通过启用或禁用负责网络同步的 NSPersistentCloudKitContainer
实例，便可实现对网络同步状态的实时切换。由于应用中所有的数据操作仅在 NSPersistentContainer
上进行，因此在运行中实时切换同步状态并不会对数据的安全性和稳定性造成影响。

> 理论上，使用一个未配置 cloudKitContainerOptions 的 NSPersistentCloudKitContainer 替代
> NSPersistentContainer 也是可以的。但由于尚未经过充分测试，本文中仍将使用 NSPersistentContainer +
> NSPersistentCloudKitContainer 的组合

## 实现细节提醒

> 可在此处获取基于以上分析创建的 [ 演示代码
> ](https://github.com/fatbobman/BlogCodes/tree/main/SyncManager)

本节将根据演示代码对部分实现细节进行说明

### 多个 Container 使用同一个 Data Model

在一个应用程序中，Core Data 的 Data Model（ 使用数据模型编辑器创建的模型文件 ）只能被加载一次。因此我们需要在创建 container
前率先加载该文件并创建为 NSManageObjectModel 实例以供多个 container 使用。

    private let model: NSManagedObjectModel
    private let modelName: String

    init(modelName: String) {
        self.modelName = modelName
        // load Data Model
        guard let url = Bundle.main.url(forResource: modelName, withExtension: "momd"),
              let model = NSManagedObjectModel(contentsOf: url) else {
            fatalError("Can't get \(modelName).momd in Bundle")
        }
        self.model = model

        ...
    }

    lazy var container: NSPersistentContainer = {
        // 使用 NSManagedObjectModel 来创建 container
        let container = NSPersistentContainer(name: modelName, managedObjectModel: model)
        ...
        return container
    }()

> 这种方法在 [ 掌握 Core Data Stack ](/zh/posts/masteringofcoredatastack/)
> 一文的内存模式章节中也有应用

### 将 NSPersistentCloudKitContainer 声明为可选值

通过将用于网络同步的 container 声明为可选值，即可轻松实现开启和关闭同步功能：

    final class CoreDataStack {
        var cloudContainer: NSPersistentCloudKitContainer?
        lazy var container: NSPersistentContainer = {
            let container = NSPersistentContainer(name: modelName, managedObjectModel: model)
            ...
            return container
        }

        init(modelName: String) {
            ....

            // 判断是否创建同步 container
            if UserDefaults.standard.bool(forKey: enableCloudMirrorKey) {
                setCloudContainer()
            } else {
                print("Cloud Mirror is closed")
            }
        }
        // 创建用于同步的 container
        func setCloudContainer() {
            if cloudContainer != nil {
                removeCloudContainer()
            }
            let container = NSPersistentCloudKitContainer(name: modelName, managedObjectModel: model)
            ....
            cloudContainer = container
        }

        // 删除用于同步的 container
        func removeCloudContainer() {
            guard cloudContainer != nil else { return }
            cloudContainer = nil
            print("Turn off the cloud mirror")
        }
    }

### 两个 Container 上均需启用持久化历史跟踪

只有在两个 container 均开启 Persistent History Tracking 功能的情况下，它们才能感知到另一方对 Core Data
数据的修改行为，并进行处理。

    container.persistentStoreDescriptions.first?.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
    container.persistentStoreDescriptions.first?.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)

同时为了能够解决合并冲突，两者都要设置正确的合并策略：

    container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy

### 在 NSPersistentContainer 实例中响应持久化历史跟踪通知

当 NSPersistentCloudKitContainer 实例从网络上获取到数据并更新到 SQLite 后，会在 SQLite 中创建
Transaction 并通过 NotificationCenter 发送 NSPersistentStoreRemoteChange 通知。我们需要在
NSPersistentContainer 实例中对该通知进行响应，并将同步数据合并到当前的视图上下文中。

> 如果像本文例程中一样使用 [ Persistent History Tracking Kit
> ](https://github.com/fatbobman/PersistentHistoryTrackingKit) 处理 Transaction
> 的话，需要开启 includingCloudKitMirroring 选项以合并由 NSPersistentCloudKitContainer
> 从网络上获取的变更数据：

    persistentHistoryKit = .init(container: container,
                                 currentAuthor: AppActor.app.rawValue,
                                 allAuthors: [AppActor.app.rawValue],
                                 includingCloudKitMirroring: true, // 合并网络同步数据
                                 userDefaults: UserDefaults.standard,
                                 cleanStrategy: .none)

> 请参阅 [ 在 CoreData 中使用持久化历史跟踪 ](/zh/posts/persistenthistorytracking/) 一文了解
> Persistent History Tracking 的详细用法。有关 Persistent History Tracking Kit
> 的内容请参阅其附带的 ReadMe 文档

### 不要清除 Transaction 记录

与仅在 App group 成员中使用 Persistent History Tracking 不同，在网络同步状态可以随时切换的情况下，最好 **不要清除
Persistent History Tracking 功能创建的 Transaction 记录** 。

这是因为 NSPersistentCloudKitContainer 是根据 Transaction
来判断哪些数据发生了变化，假设我们在关闭了网络同步状态的情况下删除了
Transaction，开启同步后，NSPersistentCloudKitContainer
将无法获知在关闭期间本地数据发生的变化，从而会造成本地和云端数据的永久不同步。

> 之所以仅在 App group 成员间使用 Persistent History Tracking 可以删除 Transaction
> 记录，那是因为每个成员都会在合并数据后，更新其对应的时间戳。当进行 Transaction
> 删除操作时，我们可以只删除已经被所有成员合并过的记录。由于无法通过简单的方式得知 NSPersistentCloudKitContainer
> 的最后更新时间以及已同步的数据位置，因此保留 Transaction 记录是最佳的选择

在本文的例程中，通过将 PersistentHistoryTrackingKit 的 cleanStrategy（ 清除策略 ）设置为 none ，禁止了对
Transaction 的清除操作：

    persistentHistoryKit = .init(container: container,
                                 currentAuthor: AppActor.app.rawValue,
                                 allAuthors: [AppActor.app.rawValue],
                                 includingCloudKitMirroring: true,
                                 userDefaults: UserDefaults.standard,
                                 cleanStrategy: .none) // 不清除 transaction

如果你的应用只会切换一次同步状态（ 从关闭切换到开启，并且之后不再关闭 ），那么可以在开启同步状态后，对由你的 App group 成员产生的
Transaction 进行清除。

## 如何处理共享数据库和公共数据库的同步

鉴于 NSPersistentContainer 并没有提供数据鉴权方面的
API，在你的应用使用了共享数据库或公共数据库同步功能时，可以采用类似如下的方式来处理：

    import CloudKit

    final class CoreDataStack {
        let localContainer:NSPersistentContainer
        let cloudContainer:NSPersistentCloudKitContainer?
        var container:NSPersistentContainer {
            guard let cloudContainer else {
                return localContainer
            }
            return cloudContainer
        }

        // 某些权限检查工作，仅用于举例
        func checkPermission(id:NSManagedObjectID) -> Bool {
            guard enableMirror,let container = self.container as? NSPersistentCloudKitContainer else { return false}
            return container.canUpdateRecord(forManagedObjectWith:id)
        }
    }

强烈建议在关闭网络同步状态的情况下，屏蔽掉应用中可能导致共享数据库和公共数据库进行修改操作的功能。

## iCloud 账号状态变化的处理

> 本节介绍的内容会更改苹果有关 iCloud 数据一致性的预设行为，除非你清楚自己在做什么，也确实有这方面的特别需求，否则不要轻易尝试！

对于采用了 NSPersistentCloudKitContainer 进行数据同步的应用，当使用者在设备上退出 iCloud 账户、切换账户或者关闭应用的
iCloud 同步功能后，NSPersistentCloudKitContainer 会在重启后（ 在应用运行中进行如上操作，iOS 应用会自动重启
）对所有的与账户关联的数据在设备上进行清除（ 并不会清除云端的数据，当账户恢复或开启同步功能后仍可同步回本地 ）。该清除操作属于一种预设行为，是正常的现象。

> 某些系统应用提供了在 iCloud 账户退出后保留本地数据的能力。但 NSPersistentCloudKitContainer
> 默认并不提供保留数据的设计。

在重新启动后，NSPersistentCloudKitContainer 通过查询 CKContainer 的 accountStatus 获得
noAccount 状态，从而激活数据删除操作。删除操作是以上文中提到的网络同步模块中保存的数据同步日志为依据进行的。

如果，你想修改 NSPersistentCloudKitContainer 默认的数据处理行为，可以在创建
NSPersistentCloudKitContainer 实例之前，首先判断 CloudKit container 的
accountStatus，只在其不为 noAccount 状态时创建实例。例如：

    import CloudKit

    func setCloudContainerWhenOtherStatus() {
        let container = CKContainer(identifier: "YourCloudKitContainerID")
        container.accountStatus{ status,error in
            if status != .noAccount {
                self.setCloudContainer()
            }
        }
    }

或者，在 accountStatus 为 noAccount 状态时，将 NSPersistentCloudKitContainer 的
NSPersistentStoreDescription 的 cloudKitContainerOptions 设置为 nil，从而屏蔽它的自动清除行为。

> 如果我们将本该自动清除的数据保留在本地，且用户切换了 iCloud 账户，如果不做妥善处理的话，很可能会造成数据在多个账户之间的混乱

## 总结

俗话说有得必有失，使用了双 container 以及不清除 transaction
的方式实现对同步状态的实时切换，势必会带来些许的性能损失以及资源占用。不过，如果你的应用确有这方面的需求，这点付出还是非常值得的。

Persistent History Tracking 现在已经越来越多地出现于各种场合，除了感知 App group 成员间数据变动外，还被应用于 [
数据批处理 ](/zh/posts/batchprocessingincoredata/) 、数据云同步、 [ Spotlight
](/zh/posts/spotlight/) 等多个环节。建议 Core Data 的使用者应该对其有充分的了解，并尽早将其应用于你的程序之中。

# 聊一聊可组装框架（ TCA ）

本文将聊聊一个与创建复杂的 SwiftUI 应用很契合的框架 —— The Composable Architecture（ 可组装框架，简称 TCA
）。包括它的特点和优势、最新的进展、使用中的注意事项以及学习路径等问题。

> [ iOS 开发配饭吃: SwiftUI + TCA 系列
> ](https://www.youtube.com/playlist?list=PL_ISTqHGWkNyN2qbc5wVDRyE6baEQ-BqU)
> : [ 13 ](https://twitter.com/ethanhuang13) 在油管上以视频的方式分享这几年来他和他的团队通过 TCA
> 进行开发的点滴，是不可多得的精品。

## TCA 简介

> 本节的内容来自 TCA 官网说明的中文版本

The Composable Architecture ( 简写为 TCA )
让你用统一、便于理解的方式来搭建应用程序，它兼顾了组装，测试，以及功效。你可以在 SwiftUI，UIKit，以及其他框架，和任何苹果的平台（
iOS、macOS、tvOS、和 watchOS ）上使用 TCA。

TCA 提供了用于搭建适用于各种目的、复杂度的 app 的一些核心工具，你可以一步步地跟随它去解决很多你在日常开发中时常会碰到的问题，比如：

- **状态管理（State Management）** 用简单的值类型来管理应用的状态，以及在不同界面调用这些状态，使一个界面内的变化可以立刻反映在另一个界面中。
- **组装（Composition）** 将庞大的功能拆散为小的可以独立运行的组件，然后再将它们重新组装成原来的功能。
- **副作用（Side Effects）** 用最可测试和便于理解的方式来让 app 的某些部分与外界沟通。
- **测试（Testing）** 除了测试某个功能，还能集成测试它与其他功能组合成为的更复杂的功能，以及用端到端测试来了解副作用如何影响你的应用。这样就可以有力地保证业务逻辑和预期相符。
- **工效（Ergnomics）** 用一个有最少概念和可动部分，且简单的 API 来做到上面的一切。

> 本文将不对 State、Action、Reducer、Store 这些概念做进一步的说明

## TCA 的特点和优势

### 强大的组装能力

既然框架被命名为可组装框架（ The Composable Architecture ），那么必然在组装能力上有其独到之处。

TCA
鼓励开发者将大型功能分解成采用同样开发逻辑的小组件。每个小组件均可进行单元测试、视图预览乃至真机调试，并通过将组件代码提取到独立模块的方式来进一步改善项目的编译速度。

所谓的组装，便是将这些独立的组件按预设的层级、逻辑粘合到一起组成更加完整功能的过程。

组装这一概念在多数的状态管理框架中都存在，而且仅需少量的代码便可以提供一些基础的组装能力。但有限的组装能力限制并影响了开发者对复杂功能的切分意愿，组装的初衷并没有被彻底执行。

TCA
提供了大量的工具来丰富其组装手段，当开发者发现组装已不是难事时，在开发的初始阶段便会从更小的粒度来思考功能的构成，从而创建出更加强壮、易读、易扩展的应用。

TCA 提供的部分用于组装的工具：

#### CasePaths

可以将其理解为 KeyPath 的枚举版本。

在其他 Redux-like 框架中，在组装上下级组件时需要提供两个独立的闭包来映射不同组件之间的 Action ，例如：

    func lift<LiftedState, LiftedAction, LiftedEnvironment>(
        keyPath: WritableKeyPath<LiftedState, AppState>,
        extractAction: @escaping (LiftedAction) -> AppAction?, // 将下级组件的 Action 转换为上级组件的 Action
        embedAction: @escaping (AppAction) -> LiftedAction, // 将上级 Action 转换为下级的 Action
        extractEnvironment: @escaping (LiftedEnvironment) -> AppEnvironment
    ) -> Reducer<LiftedState, LiftedAction, LiftedEnvironment> {
        .init { state, action, environment in
            let environment = extractEnvironment(environment)
            guard let action = extractAction(action) else {
                return Empty(completeImmediately: true).eraseToAnyPublisher()
            }
            let effect = self(&state[keyPath: keyPath], action, environment)
            return effect.map(embedAction).eraseToAnyPublisher()
        }
    }

    let appReducer = Reducer<AppState,AppAction,AppEnvironment>.combine(
        childReducer.lift(keyPath: \.childState, extractAction: {
            switch $0 {  // 需要为每个子组件的 Action 分别映射
                case .childAction(.increment):
                    return .increment
                case .childAction(.decrement):
                    return .decrement
                default:
                    return .noop
            }
        }, embedAction: {
            switch $0 {
                case .increment:
                    return .childAction(.increment)
                case .decrement:
                    return .childAction(.decrement)
                default:
                    return .noop
            }
        }, extractEnvironment: {$0}),
        parentReducer
    )

[ CasePaths ](https://github.com/pointfreeco/swift-case-paths)
为这一转换过程提供了自动处理的能力，我们仅需在上级组件的 Action 中定义一个包含下级 Action 的 case 即可：

    enum ParentAction {
        case ...
        case childAction(ChildAction)
    }

    let appReducer = Reducer<AppState,AppAction,AppEnvironment>.combine(
      counterReducer.pullback(
        state: \.childState,
        action: /ParentAction.childAction, // 通过 CasePaths 直接完成映射
        environment: { $0 }
      ),
      parentReducer
    )

#### IdentifiedArray

[ IdentifiedArray ](https://github.com/pointfreeco/swift-identified-
collections) 是一个具备字典特征的类数组类型。它具备数组的全部功能和接近的性能，要求其中的元素必须符合 Identifiable 协议，且 id
在 identifiedArray 唯一。如此一来，开发者就可以不依赖 index ，直接以字典的方式，通过元素的 id 访问数据。

IdentifiedArray 确保了将父组件中状态（ State ）中的某个序列属性切分成独立的子组件状态时的系统稳定性。避免出现因使用 index
修改元素而导致的异常甚至应用崩溃的情况。

如此一来，开发者在对序列状态进行拆分时将更有信心，操作也更加方便。

例如：

    struct ParentState:Equatable {
        var cells: IdentifiedArrayOf<CellState> = []
    }

    enum ParentAction:Equatable {
        case cellAction(id:UUID,action:CellAction) // 在父级组件上创建用于映射子 Action 的 case，使用元素的 id 作为标识
        case delete(id:UUID)
    }

    struct CellState:Equatable,Identifiable { // 元素符合 Idntifiable 协议
        var id:UUID
        var count:Int
        var name:String
    }

    enum CellAction:Equatable{
        case increment
        case decrement
    }

    let parentReducer = Reducer<ParentState,ParentAction,Void>{ state,action,_ in
        switch action {
            case .cellAction:
                return .none
            case .delete(id: let id):
                state.cells.remove(id:id) // 使用类似字典的方式操作 IdentifiedArray ，避免出现 index 对应错误或超出范围的情况
                return .none
        }
    }

    let childReducer = Reducer<CellState,CellAction,Void>{ state,action,_ in
        switch action {
            case .increment:
                state.count += 1
                return .none
            case .decrement:
                state.count -= 1
                return .none
        }
    }

    lazy var appReducer = Reducer<ParentState,ParentAction,Void>.combine(
        //
        childReducer.forEach(state: \.cells, action: /ParentAction.cellAction(id:action:), environment: { _ in () }),
        parentReducer
    )

    // 在视图中，可以直接采用 ForEachStore 来进行切分
    ForEachStore(store.scope(state: \.cells,action: ParentAction.cellAction(id: action:))){ store in
        CellVeiw(store:store)
    }

#### WithViewStore

除了应用于 Reducer、Store 上的各种组装、切分方法外，TCA 还特别针对 SwiftUI 提供了在视图内进行进一步细分的工具 ——
WithViewStore 。

通过 WithViewStore
，开发者可以在视图中进一步控制当前视图所要关注的状态以及操作，不仅改善了视图中代码的纯粹性，也在一定程度减少了不必要的视图刷新，提高了性能。例如：

    struct TestCellView:View {
        let store:Store<CellState,CellAction>
        var body: some View {
            VStack {
                WithViewStore(store,observe: \.count){ viewState in // 只关注 count 的变化，即使 cellState 中的 name 属性发生变化，本视图也不会重新刷新
                    HStack {
                        Button("-"){viewState.send(.decrement)}
                        Text(viewState.state,format: .number)
                        Button("-"){viewState.send(.increment)}
                    }
                }
            }
        }
    }

> 类似的工具还有不少，更多资料请阅读 TCA 的官方文档

### 完善的副作用管理机制

在现实的应用中，不可能要求所有的 Reducer 都是纯函数，对于保存数据、获取数据、网络连接、记录日志等等操作都将被视为副作用（ TCA 中称之为
Effect ）。

对于副作用，框架主要提供两种服务：

- **依赖注入**

在 [ 0.41.0 ](https://github.com/pointfreeco/swift-composable-
architecture/releases/tag/0.41.0) 版本之前，TCA
对于外部环境的注入方式与大多其他的框架类似，并没有什么特别之处，但在新版本中，依赖注入的方式有了巨大的变动，下文中会有更详细的说明。

- **副作用的包装和管理**

在 TCA 中，Reducer 处理任何一个 Action 之后都需要返回一个 Effect，开发者可以通过在 Effect 中生成或返回新的 Action
从而形成一个 Action 链路。

在 [ 0.40.0 ](https://github.com/pointfreeco/swift-composable-
architecture/releases/tag/0.40.0) 版本之前，开发者需要将副作用的处理代码包装成 Publisher ，从而转换成 TCA
可接受的 Effect。从 0.40.0 版本开始，我们可以通过一些预设的 Effect 方法（ run、task、fireAndForget 等
）直接使用基于 async/await 语法的异步代码，极大地降低了副作用的包装成本。

另外，TCA 还提供了不少预设的 Effect
，以方便开发者应对包含复杂且大量副作用的使用场景，例如：timer、cancel、debounce、merge、concatenate 等。

总之，TCA 提供了完善的副作用管理机制，仅需少量的代码，便可以在 Reducer 中应对不同的场景需求。

### 便利的测试工具

相较其在组装方面的表现，TCA 对测试方面的关注与支持也是它另一大特点。这方面它拥有了其他中小框架所不具备的能力。

在 TCA 或类似的框架中，副作用都是以异步的方式运行的。这意味着，如果我们想测试一个组件的完整功能，通常无法避免都要涉及异步操作的测试。

而对于 Redux-like 类型的框架来说，开发者通常无需在测试功能逻辑时进行真正的副作用操作，只需让 Action -> Reducer ->
State 的逻辑准确地运行即可。

为此，TCA 提供了一个专门用于测试的 TestStore 类型以及对应的 DispatchQueue 扩展，通过 TestStore
，开发者可以在一条虚拟的时间线上，进行发送 Action，接收 mock Action，比对 State
变化等操作。不仅稳定了测试环境，而且在某些情况下，可以将异步测试转换为同步测试，从而极大地缩短了测试的时间。例如（ 下面的代码采用 0.41.0 版本的
Protocol 方式编写 ）：

    struct DemoReducer: ReducerProtocol {
        struct State: Equatable {
            var count: Int
        }

        enum Action: Equatable {
            case onAppear
            case timerTick
        }

        @Dependency(\.mainQueue) var mainQueue // 注入依赖

        var body: some ReducerProtocol<State, Action> {
            Reduce { state, action in
                switch action {
                case .onAppear:
                    return .run { send in
                        while !Task.isCancelled {
                            try await mainQueue.sleep(for: .seconds(1)) // 使用依赖提供的 queue，方便测试
                            await send(.timerTick)
                        }
                    }
                case .timerTick:
                    state.count += 1
                    return .none
                }
            }
        }
    }

    @MainActor
    final class TCA_DemoReducerTests: XCTestCase {
        func testDemoStore() async {
            // 创建 TestStore
            let testStore = TestStore(initialState: DemoReducer.State(count: 0), reducer: DemoReducer())
            // 创建测试 queue ，TestSchedulerOf<DispatchQueue> 是 TCA 为了方便单元测试编写的 DispatchQueue 扩展，支持时间调整功能
            let queue = DispatchQueue.test
            testStore.dependencies.mainQueue = queue.eraseToAnyScheduler() // 修改成测试用的依赖
            let task = await testStore.send(.onAppear) // 发送 onAppear Action
            await queue.advance(by:.seconds(3))  // 时间向前推移 3 秒中（ 测试中并不会占用 3 秒的时间，会以同步的方式进行）
            _ = await testStore.receive(.timerTick){ $0.count = 1} // 收到 3 次 timerTick Action，并比对 State 的变化
            _ = await testStore.receive(.timerTick){ $0.count = 2}
            _ = await testStore.receive(.timerTick){ $0.count = 3}
            await task.cancel() // 结束任务
        }
    }

上述代码，让我们无需等待，便可以测试一个本来需要执行三秒才能获得结果的单元测试。

除了 TestStore 外，TCA 还为测试提供了 XCTUnimplemented（ 声明未实现的依赖方法
）、若干用于测试的新断言以及方便开发者创建截图的 [ SnapshotTesting
](https://github.com/pointfreeco/swift-snapshot-testing) 工具。

如此一来，开发者将可以通过 TCA 构建更加复杂、稳定的应用。

### 活跃的社区与详尽的资料

TCA 目前应该是受欢迎程度最高的基于 Swift 语言开发的该类型框架。截至本文写作时， [ TCA
](https://github.com/pointfreeco/swift-composable-architecture) 在 GitHub 上的
Star 已经达到了 7.2 K 。它拥有一个相当活跃的社区，问题的反馈和解答都十分迅速。

TCA 是从 [ Point Free ](https://www.pointfree.co) 的视频课程中走出来的，Point Free
中有相当多的视频内容都与 TCA
有关，涉及当前开发中所面对的问题、解决思路、规划方案、实施细节等等方面。几乎没有其他的框架会有如此多详尽的伴生内容。这些内容可以除了起到了推广 TCA
的作用外，也让广大开发者逐步了解并掌握了 TCA 的各个环节，更加容易投入到 TCA 的社区贡献中。两者之间起到了非常好的相互促进作用。

## TCA 的最新变化（ from 0.40.0 ）

最近一段时间，TCA 进行了两次拥有重大意义的升级（ 0.40.0、0.41.0 ），本节将对部分的升级内容做以介绍。

### 更好的异步支持

在 0.40.0 之前的版本中，开发者需要将副作用的包装成 Publisher ，如此一来不仅代码量较多，也不利于使用目前日益增多的基于
async/await 机制的 API。本次更新后，开发者将可以在 Reducer 的 Effect 中直接使用这些新式的 API
，在减少了代码量的同时，也可以享受到 Swift 语言提供的更好的线程协调机制。

通过使用 SwiftUI 的 task 修饰器，TCA 实现了对需要长时间运行的 Effect 的生命周期进行自动管理。

> 由于 onAppear 和 onDisappear 在某些场合会在视图的存续期中多处出现，因此使用 task 保持的 Effect
> 生命周期并不一定与视图一致

例如，下面的代码，在 0.40.0 版本之后，将更加地清晰和自然：

    // 老版本
    switch action {
      case .userDidTakeScreenshotNotification:
        state.screenshotCount += 1
        return .none

      case .onAppear:
        return environment.notificationCenter
          .publisher(for: UIApplication.userDidTakeScreenshotNotification)
          .map { _ in LongLivingEffectsAction.userDidTakeScreenshotNotification }
          .eraseToEffect()
          .cancellable(id: UserDidTakeScreenshotNotificationId.self)

      case .onDisappear:
        return .cancel(id: UserDidTakeScreenshotNotificationId.self)
      }

    // in View

    Text("Hello")
        .onAppear { viewStore.send(.onAppear) }
        .onDisappear { viewStore.send(.onDisappear) }

使用 Task 模式：

     switch action {
        case .task:
          return .run { send in
            for await _ in await NotificationCenter.default.notifications(named: UIApplication.userDidTakeScreenshotNotification).values { // 从 AsyncStream 中读取
              await send(.userDidTakeScreenshotNotification)
            }
          }

        case .userDidTakeScreenshotNotification:
          state.screenshotCount += 1
          return .none
        }
      }

    // in View
    Text("Hello")
        .task { await viewStore.send(.task).finish() } // 在 onDisappear 的时候自动结束

另一方面，通过新的 TaskResult（ 类似 Result 的机制 ）类型，TCA 对 Task 的返回结果进行了巧妙地包装，让用户无需在
Reducer 中使用以前 Catch 的方式来处理错误。

### Reducer Protocol —— 用声明视图的方式来编写 Reducer

从 0.41.0 开始，开发者可以用全新的 ReducerProtocol 的方式来声明 Reducer（ 上文中介绍测试工具中展示的代码 ），并可通过
Dependency 的方式，跨层级的在 Reducer 中引入依赖。

Reducer Protocol 将带来如下优势：

- **更容易理解的定义逻辑**

每个 Feature 都拥有自己的命名空间，其中包含它所需的 State、Action 以及引入的依赖，代码的组织更加合理。

- **更加友好的 IDE 支持**

在未使用 Protocol 模式之前，Reducer 是通过一个拥有三个泛型参数的闭包生成的，在此种模式下，Xcode
的代码补全功能将不起作用，开发者只能通过记忆来编写代码，效率相当低下。使用了 ReducerProtocol
后，由于所有的需要用到的类型都声明在一个命名空间中，开发者将可以充分利用 Xcode 的自动补全高效地进行开发

- **与 SwiftUI 视图类似的定义模式**

通过使用 [ result builder ](/zh/posts/viewbuilder1/) 重构了 Reducer 的组装机制，开发者将采用与声明
SwiftUI 视图一样的方式来声明 Reducer，更加地简洁和直观。由于调整了 Reducer 组装的构成角度，将从子 Reducer pullback
至父 Reducer 的方式修改为从父 Reducer 上 scope 子 Reducer 的逻辑。不仅更加易懂，而且也避免了一些容易出现的组装错误（
因父子 Reducer 组装时错误的摆放顺序所导致 ）

- **更好的 Reducer 性能**

新的声明方式，对 Swift 语言编译器更加地友好，将享受到更多的性能优化。在实践中，对同一个 Action 的调用，采用 Reducer Protocol
的方式所创建的调用栈更浅

- **更加完善的依赖管理**

采用了全新的 DependencyKey 方式来声明依赖（ 与 SwiftUI 的 EnvironmentKey 非常相似），从而实现了同
EnvironmentValue 一样的可以跨 Reducer 层级的依赖引入。并且，在 DependencyKey 中，开发者可以同时定义用于
live、test、preview 三种场景分别对应的实现，进一步简化了在不同场景下调整依赖的需求

## 注意事项

### 学习成本

同其他具备强大功能的框架一样，TCA 的学习成本是不低的。尽管了解 TCA
的用法并不需要太多的时间，但如果开发者无法真正地掌握其内在的组装逻辑，很难写出让人满意的代码。

貌似 TCA 为开发者提供了一种从下至上的开发途径，但如果没有对完整功能进行良好地构思，到最后会发现无法组装出预想的效果。

TCA 对开发者的抽象和规划能力要求较高，切记不要简单学习后就投入到开发具备复杂需求的生产实践中。

### 性能

在 TCA 中，State、Action 都被要求符合 Equatable 协议，并且同很多 Redux like 解决方案一样，TCA
无法提供对引用值类型状态的支持。这意味着，在必须使用引用类型的一些场景，如果仍想保持单一 State
的逻辑，需要对引用类型进行值转换，在此种情况下，将有一定的性能损失。

另外，采用 WithViewStore 关注特定属性的机制在内部都是通过 Combine 来进行的。当 Reducer 的层级较多时，TCA
也需要付出不小的成本进行切分和比对的工作。一旦其所付出的代价超出了优化的结果，便会出现性能问题。

最后，TCA 目前仍无法应对高频次的 Action 调用，如果你的应用可能会产生高频次的 Action （ 每秒几十次
），那么就需要对事件源进行一定的限制或调整。否则就会出现状态不同步的情况。

## 如何学习 TCA

尽管 TCA 在很大程度上减少了在视图中使用其他依赖项（ 符合 DynamicProperty 协议 ）的机会，但开发者仍应对 SwiftUI
提供的原生依赖方案有深刻的认识和掌握。一方面在很多轻量开发中，我们不需要使用如此重量级的框架，另一方面，即使在使用 TCA
的时候，开发者仍需要利用这些原生依赖作为 TCA 的补充。在 TCA 提供的 CaseStudies 代码中，已经充分地展示了这一点。

如果你是 SwiftUI 的初学者，并且对 Redux 或 Elm 也没有多少了解，可以先尝试使用一些比较轻量级的 Redux-like
框架。在对这种开发模式有了一定的熟悉后，再学习 TCA 。我推荐大家可以阅读 Majid 创作的有关 Redux-like 的 [ 系列文章
](https://swiftwithmajid.com/2019/09/18/redux-like-state-container-in-
swiftui/) 。

王巍有关 TCA 的系列文章 —— [ TCA - SwiftUI 的救星？ ](https://onevcat.com/2021/12/tca-1/)
也是极好的入门资料，建议对 TCA 感兴趣的开发者进行阅读。

TCA 项目中提供了不少的范例代码，从最简单的 [ Reducer 创建 ](https://github.com/pointfreeco/swift-
composable-architecture/tree/0.35.0/Examples) 到功能完善的 [ 上架应用
](https://github.com/pointfreeco/isowords) 。这些范例代码也随着 TCA 的版本更新而不断变化，其中不少已经使用
Reducer Protocol 进行了重构。

当然，想了解有关 TCA 最新、最深入的内容还是需要观看 Point Free
网站上的视频课程。这些视频课程都提供了完整的文字版本以及对应的代码，即使你的听力有限也能通过文字版本掌握所有的内容。

## 总结

按照计划，TCA 在不久之后将使用 async/await 代码替换掉当前剩余的 Combine 代码（ Apple 的闭源代码
）。这样它将可以成为一个支持多平台的框架。没准届时 TCA 将有机会被移植到其他语言。

# HowTO —— SwiftUI2.0 原生的 Grid

SwiftUI 的第一版中，官方并没有提供 UICollectionView 的对应功能。开发者需要自行包装或者依赖很多第三方库。SwiftUI 2.0
中，苹果通过 LazyVGrid、LazyHGrid 提供了 Grid 控件。该控件的实现很有 SwiftUI 的风格，和众多的第三方库有显著的区别。

## 基本用法

    struct GridTest1: View {

        let columns = [
            GridItem(.adaptive(minimum: 50))
            //adaptive 自适应，在一行或一列中放入尽可能多的 Item
            //fixed 完全固定的尺寸 GridItem(.fixed(50)), 需显式设置每行或每列中放入的 item 数量
            //flexible 用法类似 fixed，不过每个 item 的尺寸可以弹性调整，同样需要显式设置 item 数量
            //可以混用
        ]

        var body: some View {
            ScrollView{
                LazyVGrid(columns: columns, //行列设置数据
                          alignment: .center,
                          spacing: 20,  //item 行或列宽
                          pinnedViews: [.sectionHeaders]
                          //如果有 section, 将 header 或 footer 在滚动中固定
                ){
                    Section(header:Text("Header")){
                        ForEach(0...1000,id:\.self){ id in
                            Text(String(id))
                                .foregroundColor(.white)
                                .padding(.all, 10)
                                .background(Rectangle().fill(Color.orange))
                        }
                    }
                }
            }
        }
    }

![image-20200709202554829](https://cdn.fatbobman.com/howto-swiftui-grid1.png)

## LazyVGrid 和 LazyHGrid 混合使用

    struct CombineGrid: View {

        var body: some View {
            ScrollView{
                LazyVGrid(columns: [GridItem(.adaptive(minimum:40))], alignment: .center, spacing: 10){
                    ForEach(0...40,id:\.self){ id in
                        cell(id:id,color:.red)
                    }
                }
                //横向滚动
                ScrollView(.horizontal) {
                    LazyHGrid(rows: [GridItem(.fixed(50)),GridItem(.fixed(50))]){
                        ForEach(0...100,id:\.self){id in
                            cell(id:id,color:.green)
                        }
                    }
                }
                .frame(height: 240, alignment: .center)
                LazyVGrid(columns: [GridItem(.adaptive(minimum:40))], alignment: .center, spacing: 10){
                    ForEach(0...100,id:\.self){ id in
                        cell(id:id,color:.blue)
                    }
                }
            }
        }

        func cell(id:Int,color:Color) -> some View{
            RoundedRectangle(cornerRadius: 10)
                .fill(color)
                .frame(width: 50, height: 50)
                .overlay(Text("\(id)").foregroundColor(.white))
        }
    }

![image-20200709205047655](https://cdn.fatbobman.com/howto-swiftui-grid2.png)

> **这段代码快速向上滚动时显示正常，如果向上滚动速度较慢，中部的 LazyHGrid 会显示异常。应该是 bug。当前环境 Xcode Version
> 12.0 beta 2 (12 A 6163 b)**

## 各种参数混合的例子

    import SwiftUI

    struct GridTest: View {
        @State var data = (1...1000).map{i in CellView(item:i, width: CGFloat(Int.random(in: 30...100)), height: CGFloat(Int.random(in: 40...80)))}

        let column1 = [
            GridItem(.adaptive(minimum: 40, maximum: 80))
        ]
        let column2 = [
            GridItem(.flexible()),
        ]
        let column3 = [
            GridItem(.fixed(100)),
        ]

        @State var selection = 1
        @State var alignment:HorizontalAlignment = .leading
        @State var alignmentSelection = 0
        @State var spacing:CGFloat = 10
        var body: some View {
            VStack{
                Picker("", selection: $selection){
                    Text("adaptive").tag(0)
                    Text("flexible").tag(1)
                    Text("fixed").tag(2)
                }
                .pickerStyle(SegmentedPickerStyle())
                .labelsHidden()
                Picker("",selection:$alignmentSelection){
                    Text("leading").tag(0)
                    Text("center").tag(1)
                    Text("trailing").tag(2)
                }
                .pickerStyle(SegmentedPickerStyle())
                .labelsHidden()
                Slider(value: $spacing, in: -100...100){Text("spacing")}
                Text("\(spacing)")
                    .onChange(of: alignmentSelection) { value in
                        switch value{
                        case 0:
                            alignment = .leading
                        case 1:
                            alignment = .center
                        case 2:
                            alignment = .trailing
                        default:
                            break
                        }
                    }
                Button("shuffle"){
                    withAnimation(Animation.easeInOut){
                        data.shuffle()
                    }
                }
                ScrollView{
                    let colums = [column1,column2,column3]
                    LazyVGrid(columns: colums[selection], alignment: alignment, spacing: spacing, pinnedViews: [.sectionHeaders]){
                        Section(header: Text("header")){
                            ForEach(data,id:\.id){ view in
                                view
                            }
                        }
                    }
                }
            }
        }
    }

    struct CellView:View,Identifiable{
        let id = UUID()
        let item:Int
        let width:CGFloat
        let height:CGFloat
        let colors:[Color] = [.red,.blue,.yellow,.purple,.pink,.green]
        var body: some View{
            Rectangle()
                .fill(colors.randomElement() ?? Color.gray)
                .frame(width: width, height: height, alignment: .center)
                .overlay(Text("\(item)").font(.caption2))
        }
    }

> \*\*由于是 Lazy 显示，所以如果没有将全部 cell 滚动显示出来便进行 shuffle 操作，没有创建的 cell 将不会以动画的方式进行移动。

你的浏览器不支持本视频

目前 LazyGrid 没有自动避碰的能力，也无法实现 Waterfall Grid 的效果。

# HowTo —— SwiftUI2.0 使用 ScrollViewReader 定位滚动位置

SwiftUI 2.0 增加了滚动定位功能，已经可以较轻松的适应大多数场景的应用。实现手段完全不同于之前民间的各种解决方案，并不是通过设置具体的
offset 来进行定位，而是使用 id 来进行位置标记。

## 基本用法——实现从右向左滚动

    struct ScrollReaderTest: View {
        var body: some View {
            ScrollView(.horizontal) {
                //类似 GeometryReader 的使用方式，设定滚动定位区域
                ScrollViewReader{ proxy in
                    Rectangle()
                        .fill(LinearGradient(
                          gradient: Gradient(colors: [.blue,.red]),
                          startPoint: .leading,
                          endPoint: .trailing))
                        .frame(width: 1000, height: 300, alignment: .center)
                        .id("rec") //为 ScrollView 中需要定位的 View 设置 id
                        .onAppear {
                            //滚动到指定 id 的位置，按照 anchor 的设置来对齐
                            proxy.scrollTo("rec",anchor:.trailing)
                      }
                }
            }
        }
    }

## 通过按钮来滚动到指定位置

    import SwiftUI

    struct ScrollReadeTest: View {
        private var list = ScrollItem.items(300)
        @State private var position:Int = 0
        var body: some View {
          NavigationView{
            ScrollView{
                ScrollViewReader{ proxy in
                    LazyVStack{
                        ForEach(list,id:\.id){ item in
                            Text(item.title).id(item.id)
                        }
                    }
                    .onChange(of: position) { positon in
                        switch position{
                        case 1:
                            let id = list.first!.id
                            withAnimation(Animation.easeInOut){
                                proxy.scrollTo(id,anchor:.top)
                            }
                        case 2:

                            let id = list[Int(list.count / 2)].id
                            withAnimation(Animation.easeInOut){
                                proxy.scrollTo(id,anchor:.center)
                            }
                        case 3:
                            let id = list.last!.id
                            withAnimation(Animation.easeInOut){
                                proxy.scrollTo(id,anchor:.bottom)
                            }
                        default:
                            break
                        }
                    }
                }
            }
            .navigationTitle("滚动定位")

            .toolbar {
                ToolbarItem(placement:.automatic) {
                    HStack{
                        Button("top"){
                            position = 1
                        }
                        Button("mid"){
                            position = 2
                        }
                        Button("end"){
                            position = 3
                        }
                    }
                }
             }
          }
       }
    }

    struct ScrollItem:Identifiable{
        var id = UUID()
        var title:String

        static func items(_ count:Int) -> [ScrollItem]{
            var result:[ScrollItem] = []
            for i in 0..<count{
                result.append(ScrollItem(title:String("index:\(i) title:\(Int.random(in: 1000...5000))")))
            }
            return result
        }
    }

你的浏览器不支持本视频

## 遗憾

没有简单的手段记录当前的滚动位置。

# SwiftUI 2.0 —— Commands（macOS 菜单）

> 本文介绍了 SwiftUI 2.0 中，如何为 macOS 平台添加菜单。
>
> 当前运行环境为 Xcode Version 12.0 beta (12 A 6159), macOS Big Sur 11.0 Beta 版 (20 A
> 4299 v)。

苹果在 SwiftUI 2.0 中增加了 Multiplatform 项目模板，使得同一套代码，仅需少量的适配便可以同时满足 iOS 以及 macOS
的需要。对于 macOS 上运行的 app, 拥有自定义的菜单是一个十分重要的平台特征。对于没有 macOS
开发经验的我来说，学习如何设计开发菜单变得十分有趣且必要。

## 基础

在 SwiftUI 下为 app 添加菜单十分方便，下面的代码便可以为 app 添加一个最基础的菜单。

    @main
    struct CommandExampleApp: App {
        var body: some Scene {
            WindowGroup {
               ContentView()
            }
            .commands{
               Menu()
            }
        }
    }

    struct Menu:Commands{
        var body: some Commands{
            CommandMenu("My Menu"){
                Button("menu1"){
                    print("menu1")
                }
            }
        }
    }

通过创建一个符合 Commands 协议的结构来描述你要在 app 中添加的自定义菜单项

![test1](https://cdn.fatbobman.com/swiftui2-commands-test1.png)

## 几个概念

- @CommandBuilder

SwiftUI 2.0 中，苹果为我来带来了很多新的 function builder。Menu 中的
body，其实就是一个@CommandsBuilder。我们可以通过使用内置的语句通过 DSL 的方式，方便的定义自己所需的菜单。DSL
的好处是简单明了，不过功能也有所限定，目前@CommandsBuilder 支持的方法比较少，并不支持逻辑判断。

      struct MyCommand:Commands{
          //如果需要多个菜单列，需在 body 前显式注明@CommandsBuilder，或者使用 Group，这一方法，同样使用与其他 functionBuilder 的描述。
          @CommandsBuilder var body: some Commands{
              //每个 CommandMenu 都是一个菜单列
              CommandMenu("Menu1"){
                  Button("Test1"){
                    print("test2")
                  }
                    Button("Test2"){
                    print("test2")
                  }
              }

              CommandMenu("Menu2"){
                  Button(action: test1{
                      Text("😃Button")
                  }
              }
          }

          private func test1(){
              print("test command")
          }

      }

- CommandMenu

CommandMenu 是一个菜单列，在同一个 CommandMenu 中，你可以定义多个 Button。CommandMenu 中的 Content
是符合 View 协议的，也就是说，View 中不少手段、控件都可以被用来描述菜单的具体呈现。我们可以像编写 View
一样来编写菜单（比如设置字体、颜色、循环、判断等等）。

      CommandMenu("Menu"){
        Button("test1"){}
        Divider()
        Button(action:{}){Text("test2").foregroundColor(.red)}
      }

- Button

菜单中单个选项的实现方法。

        Button(action: {}){
          HStack{
              Text("🎱").foregroundColor(.blue)
              Divider().padding(.leading,10)
              Text("Button")
          }

- MenuButton

子菜单的实现方法。

      CommandMenu("Test"){
                 Button(action:{test1()}){
                      Text("test1").foregroundColor(.black)
                 }

                  #if os(macOS)
                  MenuButton("Switch Selection"){
                      Button("one"){
                          store.changeState(.one)
                      }
                      Button("two"){
                          store.changeState(.two)
                      }
                      Button("three"){
                          store.changeState(.three)
                      }
                  }
                  #endif
              }

- .commands

Scene 的方法，为场景添加菜单。commands 中允许添加多个符合 Commands 协议的菜单定义。所有定义的菜单都会一并显示。

              WindowGroup {
                  RootView()
                      .environmentObject(store)
              }
              .commands{
                  OtherMenu()
                  Menu()
              }

- keyboardShortcut

为菜单上的选项添加快捷键。通过 modifiers 设置需要配合的按键，. help 为选项添加悬停帮助

      Button(action:{test1()})
             {
                Text("test1").foregroundColor(.black)
              }
               .keyboardShortcut("1", modifiers: [.command,.shift])
               .help("help test1")

      Button("test2", action: test2)
               .keyboardShortcut("2", modifiers: .command)

- CommandGroup

在系统提供的默认菜单选项上添加自定义功能。通过 replacing, before, after 来决定是替换原选项还是设置在指定选项位置之后或之前。

      //在系统预置的帮助菜单栏下，添加一个自己的选项
      CommandGroup(replacing: CommandGroupPlacement.appInfo, addition: {Button("replace"){}})
      CommandGroup(before: CommandGroupPlacement.help, addition: {Button("before"){}})
      CommandGroup(after: CommandGroupPlacement.newItem, addition: {Button("after"){}})

## 例子

这里简单的例程展示了如何在 menu 如何通过调用 store 来影响 app 的行为。并做了简单的多平台适配。在 macOS
平台下，通过选择子菜单中不同的选项来影响显示文本。在 iOS 下通过 picker 来实现。

[ 可在此处下载完成代码 ](https://github.com/fatbobman/CommandExample)

    @main
    struct CommandExampleApp: App {
        @StateObject var store = Store()
        var body: some Scene {
            WindowGroup {
                RootView()
                    .environmentObject(store)
            }
            .commands{
              #if os(macOS)
                MyCommand(store: store)
                OtherMenu()
              #endif
            }
        }
    }

    #if os(macOS)
    struct MyCommand:Commands{
        @ObservedObject var store:Store
        @CommandsBuilder var body: some Commands{
            CommandMenu("Test"){
                Section{
                    Button(action:{test1()}){
                        Text("test1").foregroundColor(.black)
                    }
                    .keyboardShortcut("1", modifiers: [.command,.shift])
                    .help("help test1")

                    Button("test2", action: test2)
                        .keyboardShortcut("2", modifiers: .command)
                }

                switch store.selection{
                case .one:
                    Text("one")
                case .two:
                    Text("two")
                case .three:
                    Text("three")
                }

                Divider().padding(.horizontal, 10)

                Button("other"){
                    print("other command")
                }

                ForEach(0..<3){ i in
                    Button("button\(i)"){
                        print("button\(i)")
                    }
                }

                MenuButton("Switch Selection"){
                    Button("one"){
                        store.changeState(.one)
                    }
                    Button("two"){
                        store.changeState(.two)
                    }
                    Button("three"){
                        store.changeState(.three)
                    }
                }
            }

            CommandMenu("Menu2"){
                Button(action: {}){
                    Text("😃Button")
                }
            }

            //向现有的菜单项中增加功能
            CommandGroup(after: CommandGroupPlacement.help, addition: {
                Button("new help button"){
                    print("new help")
                }
            })


        }

        private func test1(){
            print("test1 command")
        }

        private func test2(){
            print("test2 command")
        }
    }
    #endif

    struct OtherMenu:Commands{
        var body: some Commands{
            CommandMenu("otherMenu"){
                Button("abc"){
                    print("abc")
                }
            }
        }
    }

    class Store:ObservableObject{
        enum Selection{
            case one,two,three
        }
        @Published var selection:Selection = .one

        func changeState(_ selection:Selection){
            self.selection = selection
        }
    }

## 补充（打开新窗口）

我尝试在菜单按钮中打开新的 View，不过并没有找到原生的 SwiftUI 式的方法。我更希望@SceneBuilder 能够支持逻辑判断，这样可以任意在
WindowGroup 组织我想显示的 View 了。

    //打开新的 View
    Button("other window"){
        print("other command")
        let contentView =
            VStack{
                Text("New Window").padding(.all, 10)
            }.frame(minWidth: 200, minHeight: 200, alignment: .center)


        var window: NSWindow!
        // Create the window and set the content view.
        window = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 480, height: 300),
            styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView],
            backing: .buffered, defer: false)
        window.isReleasedWhenClosed = false
        window.center()
        window.setFrameAutosaveName("Main Window")
        window.contentView = NSHostingView(rootView: contentView)
        window.makeKeyAndOrderFront(nil)
    }

    //打开系统文件选择面板
    Button("open panel"){
        let panel = NSOpenPanel()
              panel.nameFieldLabel = "open test:"
              panel.begin { response in
                  if response == NSApplication.ModalResponse.OK, let fileUrl = panel.url {
                      print(fileUrl)
                  }
              }
    }

## 当前的问题

由于目前还处在早期的测试阶段，菜单的实现和功能上还有些不足之处，以下是我现在比较在意的：

- Button 文本的缺省颜色和系统的菜单选项颜色不同。需要手工设置
- ShortCut 的颜色和系统菜单的颜色不同
- Divider 的颜色和系统菜单不同
- MenuButton 在多平台开发时，必须添加编译注释。而其他比如创建 Commands，. commands 等都不需要
- @CommandBuilder 和 @SceneBuilder 目前都不支持判断。因此无法通过程序动态的添加或减少一个菜单列。不过从。command 中可以添加多个 Commands 结构来看，后续应该是有这样的打算的。

# 如何通过 Persistent History Tracking 观察 SwiftData 的数据变化

在数据库发生变化时 Persistent History Tracking（ 持久化历史跟踪
）会向订阅者发送提醒，开发者可以借此机会对同一数据库进行的修改做出响应，包括其他应用、组件（同一个 App Group）和批处理任务。由于
SwiftData 集成了对持久化历史跟踪功能的支持，无需编写额外的代码，订阅通知、合并事务等工作都会由 SwiftData 自动完成。

然而，在某些情况下，开发者可能希望自行响应持久化历史跟踪的事务，以获得更多的灵活性。本文将介绍如何在 SwiftData
中通过持久化历史跟踪观察特定数据变化的方法。

## 为什么要自行响应持久化历史跟踪事务

SwiftData
中集成了对持久化历史跟踪的支持，使视图能够及时正确地响应数据变化，这对于来自网络、其他应用或小组件对数据的修改很有帮助。但是，在某些情况下，开发者需要自行响应持久化历史跟踪事务，而不仅仅停留在视图层面。

自行响应持久化历史跟踪事务的原因如下：

1. 处理与其他功能的集成：SwiftData 可能无法与某些功能或框架完全集成，例如 [ NSCoreDataCoreSpotlightDelegate ](/zh/posts/spotlight/) ，这时需要自行处理事务来调整 Spotlight 中的展示。
2. 对特定数据变化执行操作：当数据变化时，开发者可能需要执行额外逻辑或操作，自行响应可以仅针对变化的数据执行，从而降低操作成本。
3. 扩展功能：自行响应可以给开发者更大的灵活性和扩展性，根据需要实现 SwiftData 现在无法完成的功能。

总之，自行响应持久化历史跟踪事务可以为开发者提供更多操作空间，来处理集成问题、特定数据变化、以及扩展功能。这能让开发者更好地利用持久化历史跟踪，以满足各种需求。

## Persistent History Tracking 在 Core Data 中的处理逻辑

在 Core Data 中处理持久化历史跟踪涉及以下步骤：

1. 为不同的数据操作者（应用、小组件）设置不同的事务作者：可以使用 `transactionAuthor` 属性为每个数据操作者（应用、小组件）分配唯一的名称。这样可以区分不同的数据操作者，使每个操作者的事务可以被正确地标识。

2. 在共享容器中保存每个数据操作者的最后获取事务的时间戳：可以使用 `UserDefaults` 将每个数据操作者的最后获取事务的时间戳保存在 App Group 的共享容器中的某个位置。这样可以在后续的处理中，根据时间戳来获取从上次合并后新产生的所有持久化历史跟踪事务。

3. 开启持久化历史跟踪功能并响应通知：在 Core Data Stack 中，需要启用持久化历史跟踪功能，并注册对持久化历史跟踪通知的观察者。

4. 获取新产生的持久化历史跟踪事务：在接收到持久化历史跟踪通知后，可以根据上一次获取事务的时间戳，从持久化历史跟踪存储中获取新产生的事务。通常，只需要获取非当前数据操作者（应用、小组件）产生的事务。

5. 处理事务：对获取的持久化历史跟踪事务进行处理，例如将变化合并到当前的视图上下文中。

6. 更新最后获取时间戳：在处理完事务后，将本次获取的最新事务的时间戳设置为最后获取时间戳，以便下次获取时只获取新的事务。

7. 清除已合并的事务：在确保所有数据操作者都已处理完事务后，可以根据需要清除已合并的事务。

NSPersistentCloudContainer 会自动合并来自网络的同步事务，开发者无需自行处理。

> 阅读 [ 在 CoreData 中使用持久化历史跟踪 ](/zh/posts/persistenthistorytracking/)
> 一文，了解完整的实现细节。

## Persistent History Tracking 在 SwiftData 中的特别之处

在 SwiftData 中使用持久化历史跟踪与 Core Data 类似，但也有一些特别之处：

1. 视图层面的数据合并：SwiftData 能够自动处理视图层面的数据合并，因此开发者无需手动处理事务的合并操作。

2. 事务清除：为了保证在同一个 App Group 中的其他使用 SwiftData 的成员都能正确获取到事务，不对已经处理过的事务进行清除。

3. 时间戳的保存：每个使用 SwiftData 的 App Group 成员只需自行保存其最后获取的时间戳，无需统一保存在共享容器中。

4. 事务处理逻辑：由于 SwiftData 采用了完全不同的并发编程方式，事务处理逻辑会放置在一个 `ModelActor` 中。该实例负责处理持久化历史跟踪事务的获取和处理。

5. `NSPersistentHistoryChangeRequest` 中的 `fetchRequest` 为 `nil` ：在 SwiftData 中，通过 `fetchHistory` 创建的 `NSPersistentHistoryChangeRequest` 中的 `fetchRequest` 为 `nil` ，因此无法通过谓词的方式对事务进行筛选。筛选过程将在内存中进行。

6. 数据信息转换：持久化历史跟踪事务中包含的数据信息为 `NSManagedObjectID` ，需要使用 [ SwiftDataKit ](/zh/posts/use-core-data-features-in-swiftdata-by-swiftdatakit/) 将其转换为 `PersistentIdentifier` ，以便在 SwiftData 中进行进一步处理。

在下面的具体实现中会对部分注意事项进行更详细的说明。

## 具体实现

> 你可以在 [ 此处
> ](https://github.com/fatbobman/BlogCodes/tree/main/SwiftDataChangeMonitor)
> 获得完整的演示代码。

### 声明 DataProvider

首先我们将先声明一个 DataProvider，其中包含了 ModelContainer 以及用来处理持久化历史跟踪的 ModelActor：

    import Foundation
    import SwiftData
    import SwiftDataKit

    public final class DataProvider: @unchecked Sendable {
        public var container: ModelContainer
        // a model actor to handle persistent history tracking transaction
        private var monitor: DBMonitor?

        public static let share = DataProvider(inMemory: false, enableMonitor: true)
        public static let preview = DataProvider(inMemory: true, enableMonitor: false)

        init(inMemory: Bool = false, enableMonitor: Bool = false) {
            let schema = Schema([
                Item.self,
            ])
            let modelConfiguration: ModelConfiguration
            modelConfiguration = ModelConfiguration(schema: schema, isStoredInMemoryOnly: inMemory)
            do {
                let container = try ModelContainer(for: schema, configurations: [modelConfiguration])
                self.container = container
            } catch {
                fatalError("Could not create ModelContainer: \(error)")
            }
        }
    }

由于 DataProvider 中仅有的两个存储属性的类型都符合 `Sendable` 协议，因此我将 DataProvider 也声明为 `Sendable` 。

### 为 ModelContext 的 transactionAuthor 命名

在演示中，为了只处理不由当前应用的 `mainContext` 所产生的事务，我们需要为 ModelContext 的
transactionAuthor 命名。

    extension DataProvider {
        @MainActor
        private func setAuthor(container: ModelContainer, authorName: String) {
            container.mainContext.managedObjectContext?.transactionAuthor = authorName
        }
    }

    // in init
    do {
        let container = try ModelContainer(for: schema, configurations: [modelConfiguration])
        self.container = container
        // 设置 mainContext 的 transactionAuthor 为 mainApp
        Task {
            await setAuthor(container: container, authorName: "mainApp")
        }
    } catch {
        fatalError("Could not create ModelContainer: \(error)")
    }

### 声明处理持久历史跟踪的 ModelActor

SwiftData 采用了更加安全、优雅的并发编程方式，我们将所有与持久化历史跟踪有关的代码放置到一个 ModelActor 中。

> 阅读 [ SwiftData 中的并发编程 ](/zh/posts/concurret-programming-in-swiftdata/)
> 一文，掌握并发编程的新方法。

    import Foundation
    import SwiftData
    import SwiftDataKit
    import Combine
    import CoreData

    @ModelActor
    public actor DBMonitor {
        private var cancellable: AnyCancellable?
        // 最后历史事务时间戳
        private var lastHistoryTransactionTimestamp: Date {
            get {
                UserDefaults.standard.object(forKey: "lastHistoryTransactionTimestamp") as? Date ?? Date.distantPast
            }
            set {
                UserDefaults.standard.setValue(newValue, forKey: "lastHistoryTransactionTimestamp")
            }
        }
    }

    extension DBMonitor {
        // 响应持久历史跟踪通知
        public func register(excludeAuthors: [String] = []) {
            guard let coordinator = modelContext.coordinator else { return }
            cancellable = NotificationCenter.default.publisher(
                for: .NSPersistentStoreRemoteChange,
                object: coordinator
            )
            .map { _ in () }
            .prepend(())
            .sink { _ in
                self.processor(excludeAuthors: excludeAuthors)
            }
        }

        // 收到通知后，处理交易
        private func processor(excludeAuthors: [String]) {
            // 获取自上次时间戳后的所有事务
            let transactions = fetchTransaction()
            // 保存最新的时间戳
            lastHistoryTransactionTimestamp = transactions.max { $1.timestamp > $0.timestamp }?.timestamp ?? .now
            // 筛选事务，排除所有由 excludeAuthors 产生的事务
            for transaction in transactions where !excludeAuthors.contains([transaction.author ?? ""]) {
                for change in transaction.changes ?? [] {
                    // 将事务的 change 发送给处理单元
                    changeHandler(change)
                }
            }
        }

        // 获取自上次处理以来所有新生成的事务
        private func fetchTransaction() -> [NSPersistentHistoryTransaction] {
            let timestamp = lastHistoryTransactionTimestamp
            let fetchRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: timestamp)
            // 在 SwiftData 中，fetchHistory 创建的 fetchRequest.fetchRequest 为 nil，无法设置 predicate
            guard let historyResult = try? modelContext.managedObjectContext?.execute(fetchRequest) as? NSPersistentHistoryResult,
                  let transactions = historyResult.result as? [NSPersistentHistoryTransaction]
            else {
                return []
            }
            return transactions
        }

        // Process filtered transactions
        private func changeHandler(_ change: NSPersistentHistoryChange) {
            // 通过 SwiftDataKit ，将 NSManagedObjectID 转换为 PersistentIdentifier
            if let id = change.changedObjectID.persistentIdentifier {
                let author = change.transaction?.author ?? "unknown"
                let changeType = change.changeType
                print("author:\(author)  changeType:\(changeType)")
                print(id)
            }
        }
    }

在 DBMonitor 中，我们只处理不是由 excludeAuthors 列表中成员所产生的事务。你可以根据需要设置
excludeAuthors，比如将当前 App 的所有 modelContext 的 transactionAuthor 都添加进去。

在 DataProvider 启用 DBMonitor：

    // DataProvider init
    do {
        let container = try ModelContainer(for: schema, configurations: [modelConfiguration])
        self.container = container
        Task {
            await setAuthor(container: container, authorName: "mainApp")
        }
        // 创建 DBMonitor，处理持久化历史跟踪事务
        if enableMonitor {
            Task.detached {
                self.monitor = DBMonitor(modelContainer: container)
                await self.monitor?.register(excludeAuthors: ["mainApp"])
            }
        }
    } catch {
        fatalError("Could not create ModelContainer: \(error)")
    }

在 Xcode 的 `Strict Concurrency Checking` 设置为 Complete 的情况下（ 为 Swift 6
做准备，对并发代码做严格审查），如果 DataProvider 不符合 Sendable ，会获得如下的警告信息：

    Capture of 'self' with non-sendable type 'DataProvider' in a `@Sendable` closure

### 测试

至此，我们已经完成了在 SwiftData 中对持久化历史跟踪的响应工作。为了验证成果，我们将创建一个新的 ModelActor，通过它来创建新的数据（
不使用 mainContext ）。

    @ModelActor
    actor PrivateDataHandler {
        func setAuthorName(name: String) {
            modelContext.managedObjectContext?.transactionAuthor = name
        }

        func newItem() {
            let item = Item(timestamp: .now)
            modelContext.insert(item)
            try? modelContext.save()
        }
    }

在 ContentView 中，添加通过 PrivateDataHandler 创建数据的按钮：

    ToolbarItem(placement: .topBarLeading) {
        Button {
            let container = modelContext.container
            Task.detached {
                let handler = PrivateDataHandler(modelContainer: container)
                // 将 PrivateDataHandler 的 modelContext 的 transactionAuthor 设置为 Private，也可以不设置
                await handler.setAuthorName(name: "Private")
                await handler.newItem()
            }
        } label: {
            Text("New Item")
        }
    }

运行应用后，点击右上角的 `+` 按钮，由于新数据是通过 mainContext 创建的（ mainApp 在 excludeAuthors 名单中
），因此，对应的事务并不会发送给 `changeHandler` 。而通过左上角 “New Item” 按钮创建的数据，其对应的
modelContext 并不在 excludeAuthors 名单中， `changeHandler` 会打印对应的信息。

![swiftData-persistent-history-tracking-demo_2023-10-27_21.50.55.2023-10-27
21_52_22](https://cdn.fatbobman.com/swiftData-persistent-history-tracking-
demo_2023-10-27_21.50.55.2023-10-27%2021_52_22.gif)

## 总结

自行处理持久化历史跟踪事务，可以让我们在 SwiftData 正在积极发展的今天实现更多高级功能，这也许能帮助那些想使用 SwiftData
但又对功能受限仍有顾虑的开发者。

# 博客更新记：用新博客迎接 2024

一个多月前，我启动了一个大胆的计划：在人工智能的协助下，彻底重塑我的博客站点。如今，在 2024
年的钟声即将敲响之际，这个全新的博客版本终于面世。这篇文章将简要回顾这次博客更新的旅程，记录下其中的关键步骤和个人感悟。

## AI 的作用

在文章“ [ 与 AI 结对编程 ](/zh/posts/pari-programming-with-ai/)
”中，我曾详细介绍了这次博客重建的核心目标：在掌握一门全新的编程语言和新框架的同时，完成博客的彻底重构。回顾整个项目，我可以自信地说，这些目标都已经成功实现。

在这个过程中，AI 扮演了多重角色，包括合作伙伴、导师、助理和设计师。可以肯定地说，若无 AI
的协助，我不可能在短短一个多月内完成这样一个全新的博客平台。此次重构不仅让我了解了当今的前端技术，还让我掌握了更多知识与经验。

AI 展现了其在帮助我们轻松进入之前未知领域的强大能力，加速了我们的学习和开发过程。尽管 AI
的功能非常强大，但它尚未达到可以完全取代开发者的程度。当前，开发者与 AI 之间更多的是一种合作而非竞争的关系。

## Astro

为了更好地体验和了解新的前端开发技术，我故意没有选择目前主流博客平台所采用的静态网站生成框架，而是转向了 [ Astro
](https://astro.build/) 。

Astro 是一个现代化的前端框架，其设计初衷便是为了打造更加快速且高效的网站。我选择 Astro 的理由主要包括：

- Astro 是一个具有丰富文档和活跃社区的现代前端框架。

- 它对静态站点有良好的支持，这意味着我无需对我的服务器配置进行升级。

- 它对 Markdown 文件有较好的集成。

- Astro 能与其他任何前端框架结合使用，为未来的开发提供了广阔的可能性。

- 相较于其他框架，Astro 在数据流管理和交互性方面的简化使其更易于上手。

- 提供了先进的开发工具和构建优化，满足我体验当前前端开发技术的需求。

总结来说，Astro
提供了一个高效、灵活且性能卓越的解决方案，非常适合用于创建静态博客。它巧妙地融合了静态网站生成器的优势和现代前端框架的灵活性，我对这次的选择感到非常满意。

## 从零开始

尽管社区中有众多基于 Astro 的出色模板，但出于对框架深入学习和体验的考虑，我依然决定从零开始构建博客。

在这一重构过程中，AI 的辅助、Astro 的官方文档，以及 [ AstroWind ](https://astrowind.vercel.app/)
模板代码，对我帮助极大。Astro 提供了非常全面的官方文档（包括中文在内的多种语言版本），这不仅便于开发者学习，同时也为 AI
提供了丰富的语料资源。因此，在学习和开发阶段，AI 在解答与 Astro 相关的问题上表现出较高的成功率。这也表明了在与 AI
合作时，选择它熟悉的框架的重要性。

AstroWind 是一个基于 Astro 框架的全功能网站模板，通过研究其代码，让我能迅速理解一个完整且成熟的 Astro 项目的结构和功能实现。

当然，从零开始构建项目无疑是一个富有挑战性的过程，尤其是在采用全新的语言和框架的情况下。经过 20 多天构建足够的基础代码之后，博客的开发工作才真正进入了快速发展阶段。

![image-20231227141744629](https://cdn.fatbobman.com/image-20231227141744629.webp)

![image-20231227141837829](https://cdn.fatbobman.com/image-20231227141837829.webp)

## 实现博客的国际化（i18n）

鉴于我的博客需要同时支持中文和英文两种语言，我初步希望选用的框架能提供原生的国际化（i18n）支持。然而，当我开始着手于本次博客重构项目时，我发现
Astro 3.5 版本中只提供了一个功能有限的 i18n 支持的实验性版本。更重要的是，它对于不同语言路径的处理方式并不符合我的预期。因此，我最终决定在
Astro 框架中自行实现这一功能。

幸运的是，这部分工作的实现难度并不大。它主要涉及到路由配置、日期格式化、本地化字符串获取等几个关键方面。目前的实现已经能够满足我的需求。

## TailwindCSS

在前端开发领域，TailwindCSS 似乎引起了不同的声音。一些开发者赞扬其提高了开发效率，而另一些人则认为它过于非传统。作为一个主要使用 SwiftUI
的开发者，我发现自己对 TailwindCSS 所采用的结构与风格统一的方法相当习惯和喜欢。

特别是在进行页面细节构建的过程中，我发现可以非常方便地从其他 TailwindCSS
模板库中直接提取代码，而无需单独处理风格文件。这使我能够迅速看到页面的初步雏形，随后进行必要的修改或重构。

我的新博客中的许多组件的原型都是从 [ Flowbite ](https://flowbite.com/docs/components/navbar/) 和
[ Mamba UI ](https://mambaui.com/components/blog) 中获得的，并且我还使用了一部分 Flowbite
提供的交互性 JS 代码。

此外， [ @tailwindcss/typography ](https://tailwindcss.com/docs/typography-
plugin) 插件为 Markdown 内容提供了优雅的基本样式。我只需进行简单的调整，就能满足我的设计需求。对于以 Markdown
内容为主的博客网站来说，这极大地提升了设计效率。

## MDX

在本次博客重构之后，我决定不再在其他平台同步发布文章。这一决策的一部分原因是为了更方便地维护现有文章，另一方面，我也希望在未来的文章创作中利用一些超出常规
Markdown 功能的能力。为此，我将之前的文章格式全部转换为以 `.mdx` 为后缀的文件。

在这一转换过程中，我发现 Astro 对于构建时的 `.mdx` 文件内容有较高的要求。许多之前未引起注意的细节（主要是某些可能被 MDX
视为指令的字符）会导致构建失败。这个过程确实让我花费了不少努力，尤其是因为编译器提示的位置和实际错误位置往往有一定的差异。

转换为 MDX 格式之后，一些在上一个使用 Publish
创建的博客中难以实现的问题现在变得简单许多。例如，在文章中自动添加特定内容。在之前的版本中，我需要创建一个 Ink 插件来实现一个自定义的 Markdown
指令。而现在，改用 MDX 后，我通过在文件中添加一个 JSX 指令并编写一个 remark 插件，就能实现更高的自由度和功能性。

## TypeScript

基于我对强类型语言的偏好，在构建 Astro 项目时，我选择了 TypeScript
的最严格检查模式。虽然这在很多情况下确实为我提供了更清晰的错误提示，但它也相应地增加了从零开始创建项目的难度。

在编写服务端代码方面，TypeScript 为我提供了与 Swift 相似的编程体验，这是我非常欣赏的。然而，在与前端代码，特别是某些 JavaScript
代码协作时，强类型的要求和 Astro 对 `.astro` 文件中代码的特殊处理，确实在项目初期带来了一些挑战。

虽然在开发过程中也遇到了一些异常（主要通过清除项目缓存来解决），但总体来说，在 VSCode 中使用 TypeScript
进行开发和调试的过程还是相当顺畅且高效的。

## 站内搜索

为静态博客站点提供有效的静态搜索功能一直是一个挑战。在我之前的版本中，我通过在构建静态页面时创建一个检索字典来解决这个问题。当用户进行搜索时，实际上是通过下载该字典到本地，并利用
JavaScript 完成搜索的。然而，随着博客内容的增多，字典文件逐渐变大，导致用户初次搜索体验不佳。

在本次更新中，我决定尝试基于网络的检索服务。 [ Algolia ](https://www.algolia.com/)
是一个面向企业的搜索解决方案提供商，它为技术分享类网站提供免费的文件检索服务。我的博客符合他们的要求，因此申请过程相当顺利。

虽然在博客中集成 Algolia 的 DocSearch
服务相对简单，但要达到理想的搜索效果却不是一件轻松的事。目前的搜索结果显示过于碎片化，我还需要进一步调整服务器端爬虫的设置，以提供更有效的搜索结果。

## 部署、CDN 与 SEO

为了简化每次发布新文章时的工作流程，我决定实现自动化部署。由于 Astro 在构建过程中会生成全新且完整的输出版本（不进行差异比较），我利用 AI
开发了一系列小型工具代码。这些工具帮助我自动完成了一系列任务，从自动化部署到生成用于 CDN 更新的差异化文件列表，再到向搜索引擎提交新 URL。

由于新版本中目录结构和文件名（Astro 自动生成全部小写文件名）的变更，我还利用 AI 生成了一个用于 Nginx 的路径 Map 转换列表。这个列表通过
301 重定向确保了 SEO 的稳定性。

总的来说，AI 在这一部分发挥了巨大作用，显著提高了工作效率。值得一提的是，将任务细分并让 AI 为每个具体操作生成相应的工具代码，这样做可以提高 AI
代码生成的成功率。

## 2024 年见

随着 2024 年的脚步越来越近，我在这篇文章的尾声想向每位读者致以最诚挚的祝福。愿您在新的一年中身体健康，万事如意。让我们携手迎接充满希望和机遇的
2024 年。

如果您对博客的新版本有任何建议或想法，请在下方留言分享您的看法。

# Ask Apple 2022 中与 Core Data 有关的问答 (下）

Ask Apple 为开发者与苹果工程师创造了在 WWDC 之外进行直接交流的机会。本文对本次活动中与 Core Data
有关的一些问答进行了整理，并添加了一点个人见解。本文为下篇。

## Q&A

### 派生属性（ Derived Attributes ）

Q：嗨，能否分享除 `.@count` 之外的“派生属性”的更多语法示例，提前致谢。

A：NSDerivedAttributeDescription 的文档中有一些 [ 说明
](https://developer.apple.com/documentation/coredata/nsderivedattributedescription)
。

> 派生属性的值是从一个或多个其他的属性的值派生而来。通俗地说，就是在创建或修改托管对象实例时，Core Data
> 将自动为派生属性生成值。值依据预设的派生表达式（ Derived Expression ）并通过其他的属性值计算而来。详细内容请参阅 [ 如何在
> Core Data 中使用 Derived 和 Transient 属性 ](/zh/posts/derivedandtransient/) 一文。

### 主程序与扩展程序数据同步

Q：我有一个主应用程序和一个扩展程序，它们都读取相同的 Core Data
数据库。但是，当我在主应用程序中进行更改时，我的扩展程序在重新启动之前不会看到更改。我是通过简单地调用 `NSManagedObjectContext.refreshAllObjects` 来解决这个问题，还是必须用较困难的方法 ——
启用历史跟踪、检测远程更改、合并来自事务的更改、清理事务历史？

A：你应该使用 NSPersistentStore 上的
NSPersistentStoreRemoteChangeNotificationOptionKey 选项启用远程更改通知这一方法。该方法的
Persistent History 部分有助于确保你不会大量重复地从数据库中获取数据，并且仅在你需要的数据发生更改时才刷新。

> 又是一个有关持久化历史跟踪的问题。苹果真应该为该功能提供一个更加清晰的文档。使用 [ Persistent History Tracking Kit
> ](https://github.com/fatbobman/PersistentHistoryTrackingKit/blob/main/READMECN.md)
> 可以减少你的开发工作量。

### 如何更新通过文件系统删除的 Core Data 数据的 Spotlight 索引

Q：在使用 Spotlight 索引 Core Data 中的内容时，是否可以指定 Spotlight 索引的存储位置？我有一个基于文档的应用程序（
document based app ），一些文件以及 Core Data 创建的 sqlite 文件被制作成了一个包（ package bundle
）。如果用户在应用程序之外删除文档，例如在 Finder 中，我希望 Spotlight
中的索引与它一起被删除。所以我想如果索引可以存储在包文件夹中，那就可以解决这种情况。有没有办法正确处理这种情况？

A：听起来这是一个有价值的功能建议，鼓励你提交反馈请求！当前，从应用程序中调用 API 是从索引中删除项目的唯一方法。

> 当前 Spotlight 确实无法处理类似的状况。如果用户通过文件系统删除了这些文档（ 不经过应用程序
> ），那么除非应用程序可以了解哪个文档被删除了，然后通过 CSSearchableIndex. default ().
> deleteSearchableItems (withDomainIdentifiers:) 删除属于该文档的索引，否则只能等待这些索引到期后自动从
> Spotlight 中消失。参阅 [ 在 Spotlight 中展示应用中的 Core Data 数据 ](/zh/posts/spotlight/)
> 了解更多内容。

### @FetchRequest 的性能如何

Q：@FetchRequest 在性能方面是否优于在 ViewModel 的构造方法中通过 fetchRequest 获取数据的方式？

A：在初始数据获取完成后，@FetchRequest 的成本与结果变化的多少有关，而手动重新获取的成本与结果的总数有关。@FetchRequest
包装了一个 NSFetchedResultsController，它没有自己的特殊逻辑。

### 获取数据的方式

Q：我想知道哪种是比较好的方式？

1. 在应用程序中一次性加载 CoreData 数据并将其保存在局部变量中
2. 使用多个 FetchRequests

我目前在 SwiftUI 中使用 UICalendarView 并从 CoreData 中获取数据。可以在 `calendarView(_:decorationFor:)` 方法中通过 fetchRequest 来为日历中的每个日期加载数据吗（ 应该是指第二种方式
）？还是只使用一个 fetchRequest，然后将数据保存在本地，并通过上述方法访问它（ 应该是指第一种方式 ）？我想知道这里的最佳做法是什么。谢谢！

A：一般来说，不同的视图经常使用不同的获取请求。对于日期范围之类的内容，你可能希望一次获取一批。过长的 I/O 会使您的视图绘图停滞。太短的 I/O
会导致你发出太多的单独请求，这会大大降低效率。 Instruments 的 Core Data 性能工具可以帮助调查什么才是最适合您的方案。

> UICalendarView 是 iOS 16 新增的控件，MultiDatePicker 只实现了它的部分功能。UICalendarView
> 允许开发者为特定日期添加装饰，使用方法可以参阅 [ Getting UIKit’s UICalendarView from iOS 16 fully
> functioning in a SwiftUI app
> ](http://chriswu.com/posts/swiftui/uicalendarview/) 一文。

### 检索 NSAttributedString

Q：我需要将 NSAttributedString
存储在数据库中，并且可以对属性字符串中的任何文本进行搜索。通过创建两个单独的属性，一个包含纯文本字符串，另一个包含属性字符串的 Transformable
数据是否为最好的方法？是否有另一种更好的方式可以不通过两个属性来减少存储的数据量？

A：你使用的正是当前推荐的方式。此外，纯文本属性可以被 Spotlight 索引，方便它们被系统搜索。

> 生成对应数据的纯文本以进行检索，是一种很常见的方式。在某些情况下，即使属性的原始内容为纯文本，也可以通过为其生成标准化版本（
> 忽略大小写以及变音符号的版本 ）以提高检索效率。

### 私有上下文

Q：如何配置 Core Data Stack，以便在后台保存更改时，用户可以继续使用应用程序。

A：NSPersistentContainer 可以满足你的需求，你可以使用 viewContext 来驱动与用户交互的 UI，同时通过
newBackgroundContext 方法创建私有上下文，并在其上完成数据的保存。请确保在 viewContext 上开启自动合并更改，以便
backgroundContext 上的更改可以在 viewContext 中自动更新。

> 无论是通过 newBackgroundContext 显式地创建一个私有上下文，还是通过 performBackgroundTask
> 在一个临时私有上下文中进行操作，都不能在私有上下文中使用从 viewContext
> 中获取到的托管对象。托管对象是线程绑定的。即使都来自于私有上下文但分属于不同的上下文，它也只能在其对应的上下文中使用。

### 如何从 UserDefaults 转换至 Core Data

Q：目前，我的应用程序使用 @AppStorage 进行数据持久化。我有三个主要的模型对象，它们被存储在当前设备上。我想切换成 Core Data +
CloudKit 的方式。当现有用户打开新应用程序时，如何确保现有的本地 @AppStorage 数据被安全地转换到 Core Data +
CloudKit 中？

A：启动时检测 UserDefaults 是否为空，如果不是，则导入 Core Data，然后删除本地的 UserDefaults。

### 异步保存

Q：嗨，将照片数据保存到 Core Data 时使用异步是否有必要？谢谢！

A：你是在问是否应该使用 perform 或 performAndWait？我认为这取决于你的要求和所需的 UX 体验。

> perform 和 performAndWait 分别对应的是在上下文中进行异步/同步操作。对于私有上下文，即使使用 performAndWait
> 通常也不会对 UI 造成影响。

### 数据模型源文件（ Class/Category/Manual ）

Q：我希望获得与 Core Data 模型实体生成（ Codegen ）种类有关的指导。例如，什么情况下应该使用手动？我也不确定
Category/Extension 的作用以及如何在它和 Class 之间进行选择？

A：大多数人会使用
Class，并在他们自己的托管对象扩展中添加他们需要的任何自定义方法。但是在极少数情况下，例如你需要添加必须在类定义中声明的属性，此时应使用
Category/Extension 使你可以控制所需的类声明。

> 在早期的 Xcode 版本中，使用 Class 模式会生成两个文件，xxx+CoreDataClass. swift 和
> xxx+CoreDataProperties. swift 。xxx+CoreDataProperties. swift 中是通过扩展为 Entity
> 的属性创建的声明，xxx+CoreDataClass. swift 是类的定义。而 Category/Extension 模式只会生成
> xxx+CoreDataProperties. swift ，也就是说用户需要自己来写类的定义。不过在新版的 Xcode（ 至少从版本 13 起
> ）中，两者之间已经没有区别了。都会生成两个文件，而且如果用户在类的定义中添加了自定义属性，Xcode
> 也不会在重新生成的代码中对其进行覆盖。当生成文件后，需要将 Entity 切换成 Manual /None 模式，否则 Xcode
> 会出现类型重复声明的错误（ Xcode 中还会有另一份 Entity 定义保存在项目内部 ），如果仍无法编译，应清空编译缓存。

### 通过 CloudKit Dashboard 删除数据

Q：一个与 Core Data 与 CloudKit 同步的问题。我注意到，当我使用 Safari 客户端从 CloudKit 数据库中删除一条记录时（
通过 CloudKit Dashboard ），该对象仍会保留在设备上的 Core Data 数据存储中。这是有意为之的吗？如何在 CloudKit
管理器与设备之间同步这些更改？谢谢！

A：尚不清楚此工作流程是否会向 NSPersistentCloudKitContainer 生成推送通知。如果你重新启动应用程序，应该会看到更改。

### 如何确定是否已同步完成

Q：我正在使用 NSPersistentCloudKitContainer，并想改善设备初次从 iCloud
上下载数据时的用户体验。有没有办法告诉用户数据已完成同步？我知道 NSPersistentCloudKitContainer.
eventChangedNotification，但它似乎没有真正的方式来告诉应用同步何时完成。

A：其他设备总是可能做出无穷无尽的新变化，你能做的是查看哪些导入已启动及其完成状态。欢迎向我们提交功能需求的 FB。（ The theoretical is
intractable, the other devices can always be making an infinite stream of new
changes, Seeing which imports have been kicked off and their completion status
is the best you can do, But you could file a feedback for an enhancement for
an approximate answer ）

> 苹果的工程师没有对此进行正面回答。有关同步进度的问题，无论是 WWDC、开发者论坛还是在本次 Ask Apple
> 上都被多次提及，但直到目前，尚没有好的解决方案。我的建议是，在应用中（ 尤其是首次启动时 ），在同步处于 import 状态时（ 通过
> eventChangedNotification 获得 ）应对用户给予提示（ 使用 ProgressView 之类的动态元素 ）。Core Data
> with CloudKit 的同步机制会将同步过程分多次进行。也就是说，对于首次同步来说，import 状态很可能会多次出现（ 无法通过 import
> 状态发生转变来判断导入结束 ）。通过导入状态提示，可以在一定程度上减轻用户的疑惑。另外可以考虑使用 CloudKit API
> 查询云端的数据条数，然后与已经同步到本地的记录数进行比对，获得大致的同步进度（ 此方式仅适用于数据模型简单，关系不太复杂的情况 ）。

### 实体属性的可选性

Q：Core Data
中实体属性的可选性表现与预期不一致。如果我将某个属性标记为可选，则该属性不应具有默认值，并且托管属性应始终为可选属性。如果我将其标记为非可选，则它应该需要默认值，并且托管属性应始终是非可选的。我们是否可以期待将来（
至少在新项目中 ）做出这样的修正？

A：Core Data 的可选性理念早于 Swift 的存在，允许属性暂时无效。例如，当你创建一个带有字符串属性的新对象时，初始值（ 在没有默认值的情况下
）是 nil，这在对象被验证之前（ 通常在 save 时 ）是没有问题的。在可选标量的情况下，Core Data 受限于 Objective-C
中可表达的类型限制（ 例如没有 Int 64 这样的类型，可选的类型只能表达为 NSNumber ）。就这一想法提交反馈报告可能是你最好的选择。

> 实体属性的可选性对于 Core Data 的初学者来说是一个容易困惑的地方。即使你在模型编辑器中将属性（ 例如字符串 ）标记为非可选（ 设定了默认值
> ），但在从托管对象获取属性值的时候，返回值仍会是 `Optional<String>`
> 类型。对于上面的问题，可以考虑如下的解决方法：1、对于某些类型的属性来说，可以通过手动定义（ 或修改 Xcode 生成的 subclass 源文件
> ），将生成代码中的类型 String? 改成
> String；2、声明一个非可选值的计算属性，并在其中对可选值属性值进行处理；3、将托管对象实例整体转换成对 SwiftUI 视图更加友好的值类型。

### 数据手动排序

Q：在我的应用程序中，用户可以在表视图中通过拖放来重新排列项目。我的数据模型中有一个 Int 16 类型的 userOrder
属性，在表视图的行被重新排序后，有什么好的方法来保存数据的新顺序？

A：与其使用 userorder == 0 存储第一个对象，使用 userOrder == 1 存储第二个对象，使用 userOrder == 2
存储第三个对象，或许将其建模为一种有序的关系（ ordered ）是更好的选择。让 Core Data 为你做这件事。为了管理有序的关系，Core Data
在 UInt 16 空间中计算一个对象的索引，正好在前一个和后一个对象的中间。当整数空间用完时，将在任何一个方向上跨出一个对象，并均匀地重新分配这些对象。

> 很遗憾，有序关系无法在开启 Core Data 云同步的状态下使用，在此种情况下，提问者当前的做法应该是正确的选择。

### 筛选关系数据

Q：我发现在 SwiftUI 中使用 @FetchRequest 是将用户界面与 Core Data
数据绑定很好的手段。然而，在使用关系来获得同样的无缝绑定时，我碰到了一个小问题。由于 NSManagedObjects 以 NSSet
的形式表示一对多的关系，我必须在它自己的 @FetchRequest 中重新获取 “子女”（ 多方的数据 ），从而失去 Core Data
关系属性的好处。我的方法有什么问题？

A：这听起来与另一个问题相似，我在这个问题中建议使用谓词来过滤只具有某种关系的对象。我想同样的方法应该对你有用？让 Core Data
通过构建一个谓词来完成过滤工作会更快，比如 `NSPredicate(format: "country = %@", country)` 。

> NSManagedObject 符合 ObservableObject 协议，这意味着当它的属性值发生变化时将会通过 Publisher
> 通知订阅者。遗憾的是，可监控的变化中并不包括关系对象中的属性值变化。通过谓词重新获取关系对象列表可能是目前最好的方式。另外，Antoine van
> der Lee 曾写过一篇通过扩展 NSFetchedResultsController 来实现监控关系对象属性变化的文章 [
>
> > NSFetchedResultsController extension to observe relationship changes
> > ](https://www.avanderlee.com/swift/nsfetchedresultscontroller-observe-
> > relationship-changes/) 。

### 在持久化历史中如何体现有序对象的变化状态

Q：持久化历史中是如何体现 “有序” 关系中的对象的顺序发生了改变？NSPersistentHistoryChange
是否包含父实体或子实体？updatedProperties 中有哪些属性？

A：对于排序的改变，关系的两边都会显示为 NSPersistentHistoryChange，并在 updatedProperties 中列出关系。

### 通过 navigationDestination 传递托管对象的需求

Q：我有一个与 SwiftUI 的 navigationDestination (for: myCoreDataClass) 有关的问题，需要让我的
NSManagedObjects 中符合 Codable 协议（ 猜测是想对 Path 进行持久化 ）。我手动生成了 NSManagedObject
代码并实现了 Codable 协议来实现这一目标。有什么更好的处理方法吗？谢谢。

A：Codable 无法准确地对对象图中的对象进行单独编码。相反，你应该创建一个适合于此处需求的数据子集的可编码转换。或许可以使用
URIRepresentation 。

> 当 NSManagedObject 包含关系时，对其进行编码是极为困难的。navigationDestination 对传入数据的唯一要求是符合
> Hashable 协议，因此传入托管对象 ID 对应的 URL 应该是最佳的选择（ 通过 `objectID.uriRepresentation`
> ，URL 符合 Codable 协议，满足对 Path 进行持久化的需求 ）。

## 总结

在上下两篇问答汇总中，我忽略掉了没有获得结论的问题。希望上述的整理能够对你有所帮助。

# SheetKit —— SwiftUI 模态视图扩展库

## SheetKit 是什么

[ SheetKit ](https://github.com/fatbobman/SheetKit) 是一个 SwiftUI
模态视图的扩展库。提供了数个用于模态视图的便捷展示、取消方法，以及几个用于模态视图的 View Extension。

开发 SheetKit 的主要原因：

- 便于 Deep link 的调用

SwiftUI 提供了 `onOpenURL` 方法让应用程序可以非常轻松的响应 Deep Link。但在实际使用中，情况并不如预期。主要因为
SwiftUI 中重要的视图展示模式：NavigationView、Sheet
等都没有迅捷、简便的重置能力。很难通过一两句代码将应用程序立即设置成我们想要的视图状态。

- 模态视图的集中管理

SwiftUI 通常采用 `.sheet`
来创建模态视图，对于简单的应用来说，这种形式非常直观，但如果应用程序的逻辑比较复杂、需要的模态视图众多，则上述方式就会让代码显得十分混乱，不易整理。因此，在此种情况下，通常我们会将所有的模态视图集中管理起来，统一调用。请参阅我之前的文章——
[ 在 SwiftUI 中，根据需求弹出不同的 Sheet ](/zh/posts/swiftui-multisheet/) 。

- 新的半高模态视图

在 WWDC 2021 中，苹果为大家带来了期待已久的半高模态视图。或许推出的比较仓促，这种很受欢迎的交互方式并没有提供 SwiftUI 版本，仅支持
UIKit。SheetKit 暂时弥补了这个遗憾。无论 sheet、fullScreenCover 还是
bottomSheet（半高模态视图）都得到充分的支持和统一的管理。

## 系统要求

- iOS 15
- Swift 5.5
- XCode 13.0 +

> 只需剥离模态视图的支持，SheetKit 将支持 iOS 14。

## 安装

SheetKit 支持 SPM 安装。

[ 源地址 ](https://github.com/fatbobman/SheetKit.git)

SheetKit 中每个功能的代码都集中在一到两个文件中。如果只需要其中部分的功能，直接在项目中添加对应的文件或许是不错的选择。

## SheetKit 功能详解

### present

#### SheetKit 调用

![image-20210916185555507](https://cdn.fatbobman.com/image-20210916185555507.png)

在代码中使用 SheetKit 十分容易。支持两种方式：直接使用 SheetKit 的实例、在视图中使用环境值。比如下面的两段代码都将显示一个标准
Sheet：

    Button("show sheet"){
       SheetKit().present{
         Text("Hello world")
       }
    }

或者

    @Environment(\.sheetKit) var sheetKit

    Button("show sheet"){
       sheetKit.present{
         Text("Hello world")
       }
    }

SheetKit 支持多层次的 Sheet 展示，下面代码将展示两层 Sheet

    @Environment(\.sheetKit) var sheetKit

    Button("show sheet"){
       sheetKit.present{
         Button("show full sheet"){
           sheetKit.present(with:.fullScreenCover){
             Text("Hello world")
           }
         }
       }
    }

#### 动画

SheetKit 中 present 和 dismiss 的动画都是可以关闭的（尤其适合于 Deep link 场景）。使用下面语句将关闭显示动画

    SheetKit().present(animated: false)

#### Sheet 类型

目前 SheetKit 支持三种模态视图类型：sheet、fullScreenCover、bottomSheet。

![image-20210916190606032](https://cdn.fatbobman.com/image-20210916190606032.png)

下面的代码将展示一个预设的 bottomSheet 视图：

    sheetKit.present(with: .bottomSheet){
      Text("Hello world")
    }

![bottomSheet1](https://cdn.fatbobman.com/bottomSheet1-1778528.gif)

bottomSheet 可以自定义配置。

![image-20210916190453672](https://cdn.fatbobman.com/image-20210916190453672.png)

下面的代码将创建一个自定义的 bottomSheet

    let configuration = SheetKit.BottomSheetConfiguration(  detents: [.medium(),.large()],
                                                            largestUndimmedDetentIdentifier: .medium,
                                                            prefersGrabberVisible: true,
                                                            prefersScrollingExpandsWhenScrolledToEdge: false,
                                                            prefersEdgeAttachedInCompactHeight: false,
                                                            widthFollowsPreferredContentSizeWhenEdgeAttached: true,
                                                            preferredCornerRadius: 100)

    sheetKit.present(with: .customBottomSheet,configuration: configuration) {
      Text("Hello world")
    }

![Simulator Screen Shot - iPhone 13 Pro Max - 2021-09-16 at
16.15.08](https://cdn.fatbobman.com/Simulator%20Screen%20Shot%20-%20iPhone%2013%20Pro%20Max%20-%202021-09-16%20at%2016.15.08.png)

#### 模态视图高度变化提醒

当 bottomSheet 在不同高度变化时，有两种方式可以获得提醒。

方法 1：

    @State var detent:UISheetPresentationController.Detent.Identifier = .medium

    Button("Show"){
      sheetKit.present(with: .bottomSheet,detentIdentifier: $detent){
        Text("Hello worl")
      }
    }
    .onChange(of: detent){ value in
        print(value)
    }

方法 2：

    @State var publisher = NotificationCenter.default.publisher(for: .bottomSheetDetentIdentifierDidChanged, object: nil)

    .onReceive(publisher){ notification in
           guard let obj = notification.object else {return}
           print(obj)
    }

> 当采用方法 2 时，如果需要展示多层 bottomSheet，请为不同层次的视图定义不同名称的 Notification. Name

### dismissAllSheets

![image-20210916190651604](https://cdn.fatbobman.com/image-20210916190651604.png)

SheetKit 支持快速取消全部正在显示的模态视图（无论该模态视图是否由 SheetKit 展示）。使用下面的代码

    SheetKit().dismissAllSheets()

支持动画控制及 onDisappear

        SheetKit().dismissAllSheets(animated: false, completion: {
            print("sheet has dismiss")
        })

### dismiss

如果只想取消最上层的模态视图，可以使用 dismiss

        SheetKit().dismiss()

同样支持动画控制

> 如果在视图外执行 SheetKit 方法，请务必保证代码运行在主线程上。可以使用例如 DispatchQueue. main. async 或者
> MainActor. run 等形式。

### interactiveDismissDisabled

SwiftUI 3.0 的 interactiveDismissDisabled
加强版，在通过代码控制是否允许手势取消的基础上，增加了当用户使用手势取消时可以获得通知的能力。

更多信息请参阅 [ 如何在 SwiftUI 中实现 interactiveDismissDisabled
](/zh/posts/newinteractivedismissdiabled/)

> SheetKit 中的 interactiveDismissDisabled 为了兼容 bottomSheet 做了一定的改动，具体改动请参见源代码。

    struct ContentView: View {
        @State var sheet = false
        var body: some View {
            VStack {
                Button("show sheet") {
                    sheet.toggle()
                }
            }
            .sheet(isPresented: $sheet) {
                SheetView()
            }
        }
    }

    struct SheetView: View {
        @State var disable = false
        @State var attempToDismiss = UUID()
        var body: some View {
            VStack {
                Button("disable: \(disable ? "true" : "false")") {
                    disable.toggle()
                }
                .interactiveDismissDisabled(disable, attempToDismiss: $attempToDismiss)
            }
            .onChange(of: attempToDismiss) { _ in
                print("try to dismiss sheet")
            }
        }
    }

![dismissSheet](https://cdn.fatbobman.com/dismissSheet.gif)

### clearBackground

将模态视图的背景设置为透明。在 SwiftUI 3.0 中，已经可以使用原生 API
生成各种毛玻璃效果了。但只有将模态视图的背景设置为透明，毛玻璃效果才能显现出来。

在模态视图中：

    .clearBackground()

例如：

            ZStack {
                Rectangle().fill(LinearGradient(colors: [.red, .green, .pink, .blue, .yellow, .cyan, .gray], startPoint: .topLeading, endPoint: .bottomTrailing))
                Button("Show bottomSheet") {
                    sheetKit.present(with: .bottomSheet, afterPresent: { print("presented") }, onDisappear: { print("disappear") }, detentIdentifier: $detent) {
                        ZStack {
                            Rectangle()
                                .fill(.ultraThinMaterial)
                            VStack {
                                Text("Hello world")
                                Button("dismiss all") {
                                    SheetKit().dismissAllSheets(animated: true, completion: {
                                        print("sheet has dismiss")
                                    })
                                }
                            }
                        }
                        .clearBackground()
                        .ignoresSafeArea()
                    }
                }
                .foregroundColor(.white)
                .buttonStyle(.bordered)
                .controlSize(.large)
                .tint(.green)
            }
            .ignoresSafeArea()

![Simulator Screen Shot - iPhone 13 Pro Max - 2021-09-16 at
19.19.34](https://cdn.fatbobman.com/Simulator%20Screen%20Shot%20-%20iPhone%2013%20Pro%20Max%20-%202021-09-16%20at%2019.19.34-1791208.png)

## 总结

无论是 [ SheetKit ](https://github.com/fatbobman/SheetKit) 还是 [ NavigationViewKit
](/zh/posts/navigationviewkit/) 都是我为开发新版的 [ 健康笔记 ](/healthnotes/)
准备的扩展库。功能都是以我个人的需求为主。如果有什么其他的功能要求，请通过 [ twitter
](https://www.twitter.com/fatbobman) 、博客留言或者 Issues 等方式告诉我。

# 在 SwiftUI 下对 iPad 进行适配

SwiftUI 创建初衷之一便是可以高效、可靠的适配多个苹果的硬件平台。在健康笔记 2.0 开发初始，适配 iPad
便是我本次的设计目标之一。本文并非教程，只是我在进行本次开发中，对于适配 iPad 的一些教训和心得。

## 我是谁

app 中的代码必须能高效、清晰的了解当前设备的状况，时刻搞清楚我是谁，我在哪，在干啥等等。因此在项目开始之初我便做了不少的准备并创建了一系列的代码。

比如，当前的运行设备：

    enum Device {
        //MARK: 当前设备类型 iphone ipad mac
        enum Devicetype{
            case iphone,ipad,mac
        }

        static var deviceType:Devicetype{
            #if os(macOS)
            return .mac
            #else
            if  UIDevice.current.userInterfaceIdiom == .pad {
                return .ipad
            }
            else {
                return .iphone
            }
            #endif
     }

如果想要具体了解当前运行设备的型号，Github 上有人提供了代码可以返回更精准的信息。

为了能够在 View 中方便的利用这些状态信息应对不同的情况，还需要继续做些准备。

    extension View {
        @ViewBuilder func ifIs<T>(_ condition: Bool, transform: (Self) -> T) -> some View where T: View {
            if condition {
                transform(self)
            } else {
                self
            }
        }

        @ViewBuilder func ifElse<T:View,V:View>( _ condition:Bool,isTransform:(Self) -> T,elseTransform:(Self) -> V) -> some View {
            if condition {
                isTransform(self)
            } else {
                elseTransform(self)
            }
        }
    }

这两段是我使用非常频繁的代码，在 SwiftUI 下，利用类似的代码可以非常容易的利用同一段代码应对各种不同的状况。

例如：

    VStack{
         Text("hello world")
    }
    .ifIs(Deivce.deviceType == .iphone){
      $0.frame(width:150)
    }
    .ifIs(Device.deviceType == .ipad){
      $0.frame(width:300)
    }
    .ifIs(Device.deviceType == .mac){
      $0.frmae(minWidth:200,maxWidth:600)
    }

只有解决了我是谁的问题，后面的工作才能更好的展开

## 躺着还是站着

因为健康笔记以列表被主要表现形式的 app，最初所以我希望在 iphone 上始终保持 Portrait，在 ipad 上保持 Landscape
的形式。不过最终还是决定让其在 ipad 上同时支持 Portrait 和 Landscape。

![ipadiphone](https://cdn.fatbobman.com/swiftui-ipad-ipadiPhone.png)

为了更灵活的处理，我没有选择在 info. plist 中对其进行设定，而是通过在 delegate 中，针对不同的情况作出响应。

![xcode](https://cdn.fatbobman.com/swiftui-ipad-xcode.png)

因为无需支持多窗口，所以关闭了 multiple windows。另外需要激活 Requires full screen 才能让 delegate 作出响应

    class AppDelegate:NSObject,UIApplicationDelegate{
      func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask {
            return Device.deviceType == .ipad
                ? UIInterfaceOrientationMask.all
                : UIInterfaceOrientationMask.portrait
        }
    }

在 SwiftUI 下如何设置 Delegate 请查看 [ SwiftUI2.0 —— App、Scene 及新的代码结构
](/zh/posts/swiftui2-new-feature-1/)

如此便可以方便的控制自己想要的 app 呈现形态了。

## 难以控制的 NavigationView

SwiftUI 的 NavigationView 本身为了适配做了不少的工作，但效果并不好。

目前它支持两种 style：
StackNavigationView、DoubleColumnNavigationViewStyle，三种表现形式：单列、双列、以及三列（sidebar）。虽然看似覆盖了多数的应用，但由于没有提供更多的控制选项，因此用起来并不顺手。

比如，DoubleColumnNavigationViewStyle，在 ipad
上的竖屏和横屏时的呈现是不同的。左上角的隐藏按钮不可更改，不可取消。在包含 sidebar
的三列模式下，逻辑又有不同，不过按钮同样不提供任何替换、取消的能力。

NavigationLink 只能在当前列中响应，另外并不提供控制列宽的能力。

如果想调整双列 NavigationView 的列宽，可以使用 Introspect，参见 [ 介绍几个我在开发健康笔记 2 用到的 Swift 或
SwiftUI 第三方库 ](/zh/posts/healthnote2-3rd-package/)

    NavigationView{
      Text("hello")
    }
    .introspectNavigationController{ navigation in
        navigation.splitViewController?.maximumPrimaryColumnWidth = 360
        navigation.splitViewController?.preferredPrimaryColumnWidth = 500.0
    }

为了能够让 ipad
在竖屏或横屏状态下都固定呈现双列的模式，并且左侧列不可折叠同时也不能出现我想要的折叠按钮，我使用了一个不得已的手段。伪造了一个双列显示的
NavigationView。

针对不同的设备进入不同的 rootView

    struct HealthNotesApp:APP{
      var body: some Scene{
         rootView()
      }

      func rootView()-> some View{
            switch Device.deviceType {
            case .ipad:
                return AnyView(ContentView_iPad())
            default:
                return AnyView(ContentView_iPhone())
            }
        }
    }

在 ContentView_iPad 中，使用类似代码伪造一个双列形式

    HStack(spacing:0){
          ItemRootView(item: $item)
               .frame(width:height)
           Divider()
           ItemDataRootView()
                .navigationContent()
            }
    .edgesIgnoringSafeArea(.all)

如此一来便拥有了上面图片中 iPad 的显示效果。状态基本上同 DoubleColumnNavigationViewStyle
的形式是完全一致的。分别都可以设置 Toolbar，并且分割线也可以贯穿屏幕。

    extension View{
        func navigationContent() -> some View{
            NavigationView{
                self
            }
            .navigationViewStyle(StackNavigationViewStyle())
        }
    }

由于在 Ipad 下右侧列的视图同时被用在 iphone 下，在 iPhone 下它是由 NavigationLink 激活的，所以仍在
NavigationView 中，但在 iPad 下，需要明确的将在放置在 NavigationView 中。通过
.navigationContent，结合上面的 isIf，便可以灵活的控制形态了。

另外需要针对 iPhone 和 ipad 的二级 View 激活进行分别处理，比如

    if Device.deviceType  == .iphone {
                        NavigationLink("", destination: ItemDataRootView(), isActive: $gotoDataList).frame(width:0,height:0)
                }

    //在 link 的 button 中
    Button("Item1"){
       store.item = item
       if Devie.deviceType == .iphone {
           gotoDataList.toggle()
       }
    }

    //在 ItemDataRootView 中直接响应 store.item 即可

## Bug 还是特别设计？

某些 SwiftUI 的默认控件在 iPad 和 iPhone 下的运行效果和预期有较大差别，

比如 ActionSheet:

当前 AlertSheet 在运行 iOS 14 的 ipad
上的显示位置是几乎不可控的。箭头的位置，内容的显示，和预期都有巨大的差别。我不知道以后都会是这样还是目前的 Bug。

个人不推荐当前在 iPad 上使用 ActionSheet。最终只能在 iPad 下使用 Alert 替代了 ActionSheet。如果一定要使用
ActionSheet，popover 或许是更好的选择。

ContextMenu 目前在 iPad 上有响应上的问题，同样的指令在 iPhone 上没有问题，在 iPad 上会出现无法获取值的状况。同样不清楚是
Bug 还是其他原因。

比如

    Text("click")
    .contextMenu{
      Button("del"){
         delItem = item
         ShowActionSheet.toggle()
      }
    }
    .ActionSheet(isPresented:showActionSheet){
        delSheet(item:delItem)
    }

这段代码在 iphone 上执行没有任何问题，不过在 ipad 上，delsheet 很有可能会无法获取 item。为了避免这个情况，目前只能做些特殊处理

    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5){
                      showActionSheet.wrappedValue = true
    }

类似上述的问题还有一些，只有当代码在 ipad 上跑起来多做测试才会发现其中的问题。

## 布局优化

由于健康笔记 2.0 在 iPad 上显示的左右两列，所以本来在 iphone 下运行没有问题 View, 在 iPad
下就会出现左右不对齐，不对称等问题。所以只要多调试，采用 isIf 多做处理，问题基本上都会比较容易获得解决。

仅举一例：

    List{
       ...
    }
    .listStyle(InsetGroupedListStyle())

当它在 iphone 上作为独占屏幕的 View 时，显示很完美，但当它显示在 IPad 的右侧列时，Group 上方的留空和左侧列的就不对齐，做点处理就
ok 了。

## 结尾

总之使用 SwiftUI 适配 iPhone 和 iPad 总体来说还是比较容易的。能否充分利用好各自设备的特点主要还是要在交互逻辑和 UI
设计上多下功夫，代码上的难度不大。

# 用 Table 在 SwiftUI 下创建表格

Table 是 SwiftUI 3.0 中为 macOS 平台提供的表格控件，开发者通过它可以快捷地创建可交互的多列表格。在 WWDC 2022
中，Table 被拓展到 iPadOS 平台，让其拥有了更大的施展空间。本文将介绍 Table 的用法、分析 Table
的特点以及如何在其他的平台上实现类似的功能。

## 具有列（ Row ）特征的 List

在 Table 的定义中，具备明确的行（ Row ）与列（ Column ）的概念。但相较于 SwiftUI 中的网格容器（ LazyVGrid、Grid
）来说，Table 本质上更接近于 List 。开发者可以将 Table 视为具备列特征的 List 。

![image-20220620142551830](https://cdn.fatbobman.com/image-20220620142551830.png)

上图是我们使用 List 创建一个有关 Locale 信息的表格，每行都显示一个与 Locale 有关的数据。创建代码如下：

    struct LocaleInfoList: View {
        @State var localeInfos: [LocaleInfo] = []
        let titles = ["标识符", "语言", "价格", "货币代码", "货币符号"]
        var body: some View {
            List {
                HStack {
                    ForEach(titles, id: \.self) { title in
                        Text(title)
                            .frame(minWidth: 0, maxWidth: .infinity, alignment: .leading)
                        Divider()
                    }
                }

                ForEach(localeInfos) { localeInfo in
                    HStack {
                        Group {
                            Text(localeInfo.identifier)
                            Text(localeInfo.language)
                            Text(localeInfo.price.formatted())
                                .foregroundColor(localeInfo.price > 4 ? .red : .green)
                            Text(localeInfo.currencyCode)
                            Text(localeInfo.currencySymbol)
                        }
                        .lineLimit(1)
                        .frame(minWidth: 0, maxWidth: .infinity, alignment: .leading)
                    }
                }
            }
            .task {
                localeInfos = prepareData()
            }
        }
    }

    struct LocaleInfo: Identifiable, Hashable {
        var id: String {
            identifier
        }

        let identifier: String
        let language: String
        let currencyCode: String
        let currencySymbol: String
        let price: Int = .random(in: 3...6)
        let updateDate = Date.now.addingTimeInterval(.random(in: -100000...100000))
        var supported: Bool = .random()

        func hash(into hasher: inout Hasher) {
            hasher.combine(id)
        }
    }

    // 生成演示数据
    func prepareData() -> [LocaleInfo] {
        Locale.availableIdentifiers
            .map {
                let cnLocale = Locale(identifier: "zh-cn")
                let locale = Locale(identifier: $0)
                return LocaleInfo(
                    identifier: $0,
                    language: cnLocale.localizedString(forIdentifier: $0) ?? "",
                    currencyCode: locale.currencyCode ?? "",
                    currencySymbol: locale.currencySymbol ?? ""
                )
            }
            .filter {
                !($0.currencySymbol.isEmpty || $0.currencySymbol.isEmpty || $0.currencyCode.isEmpty)
            }
    }

下面的是使用 Table 创建同样表格的代码：

    struct TableDemo: View {
        @State var localeInfos = [LocaleInfo]()
        var body: some View {
            Table {
                TableColumn("标识符", value: \.identifier)
                TableColumn("语言", value: \.language)
                TableColumn("价格") {
                    Text("\($0.price)")
                        .foregroundColor($0.price > 4 ? .red : .green)
                }
                TableColumn("货币代码", value: \.currencyCode)
                TableColumn("货币符号", value: \.currencySymbol)
            } rows: {
                ForEach(localeInfos) {
                    TableRow($0)
                }
            }
            .task {
                localeInfos = prepareData()
            }
        }
    }

![image-20220620142510240](https://cdn.fatbobman.com/image-20220620142510240.png)

相较于 List 的版本，不仅代码量更少、表述更加清晰，而且我们还可以获得可固定的标题栏。同 List 一样，Table
也拥有直接引用数据的构造方法，上面的代码还可以进一步地简化为：

    struct TableDemo: View {
        @State var localeInfos = [LocaleInfo]()
        var body: some View {
            Table(localeInfos) { // 直接引用数据源
                TableColumn("标识符", value: \.identifier)
                TableColumn("语言", value: \.language)
                TableColumn("价格") {
                    Text("\($0.price)")
                        .foregroundColor($0.price > 4 ? .red : .green)
                }
                TableColumn("货币代码", value: \.currencyCode)
                TableColumn("货币符号", value: \.currencySymbol)
            }
            .task {
                localeInfos = prepareData()
            }
        }
    }

> 在 SwiftUI 4.0 的第一个测试版本中（ Xcode 14.0 beta (14 A 5228 q) ），Table 在 iPad OS
> 上的表现不佳，存在不少的 Bug 。例如：标题行与数据行（ 首行 ）重叠；标题行第一列不显示；滚动不顺畅以及某些表现（ 行高 ）与 macOS
> 版本不一致等情况。

Table 与 List 的近似点：

- 声明逻辑接近
- 与 LazyVGrid（ LazyHGrid ）和 Grid 倾向于将数据元素放置于一个单元格（ Cell ）中不同，在 Table 与 List 中，更习惯于将数据元素以行（ Row ）的形式进行展示（ 在一行中显示数据的不同属性内容 ）
- 在 Table 中数据是懒加载的，行视图（ TableColumn ）的 onAppear 和 onDisappear 的行为也与 List 一致
- Table 与 List 并非真正意义上的布局容器，它们并不像 LazyVGrid、Grid、VStack 等布局容器那样支持视图渲染功能（ ImageRenderer ）

## 列宽与行高

### 列宽

在 Table 中，我们可以在列设定中设置列宽：

    Table(localeInfos) {
        TableColumn("标识符", value: \.identifier)
        TableColumn("语言", value: \.language)
            .width(min: 200, max: 300)  // 设置宽度范围
        TableColumn("价格") {
            Text("\($0.price)")
                .foregroundColor($0.price > 4 ? .red : .green)
        }
        .width(50) // 设置具体宽度
        TableColumn("货币代码", value: \.currencyCode)
        TableColumn("货币符号", value: \.currencySymbol)
    }

![image-20220620150114288](https://cdn.fatbobman.com/image-20220620150114288.png)

其他未指定列宽的列（ 标识符、货币代码、货币符号），将会根据 Table 中剩余的横向尺寸进行平分。在 macOS
上，使用者可以通过鼠标拖动列间隔线来改变列间距。

与 List 一样，Table 内置了纵向的滚动支持。在 macOS 上，如果 Table 中的内容（ 行宽度 ）超过了 Table 的宽度，Table
将自动开启横向滚动支持。

如果数据量较小能够完整展示，开发者可以使用 `scrollDisabled(true)` 屏蔽内置的滚动支持。

### 行高

在 macOS 下，Table 的行高是锁定的。无论单元格中内容的实际高度需求有多大，Table 始终将保持系统给定的默认行高。

    TableColumn("价格") {
        Text("\($0.price)")
            .foregroundColor($0.price > 4 ? .red : .green)
            .font(.system(size: 64))
            .frame(height:100)

![image-20220620181736770](https://cdn.fatbobman.com/image-20220620181736770.png)

在 iPadOS 下，Table 将根据单元格的高度，自动调整行高。

![image-20220620181923446](https://cdn.fatbobman.com/image-20220620181923446.png)

> 目前无法确定这种情况是有意的设计还是 Bug

## 间隔与对齐

由于 Table 并非真正意义上的网格布局容器，因此并没有提供行列间隔或行列对齐方面的设定。

开发者可以通过 frame 修饰符来更改单元格中内容的对齐方式（ 暂时无法更改标题的对齐方式 ）：

    TableColumn("货币代码") {
        Text($0.currencyCode)
            .frame(minWidth: 0, maxWidth: .infinity, alignment: .trailing)
    }

![image-20220620182615838](https://cdn.fatbobman.com/image-20220620182615838.png)

在 Table 中，如果该列显示的属性类型为 String，且无须添加其他设定，可以使用基于 KeyPath 的精简写法：

    TableColumn("货币代码", value:\.currencyCode)

但是，如果属性类型不为 String，或者需要添加其他的设定（ 字体、颜色等 ），只能采用尾随闭包的方式来定义 TableColumn （ 如上方的货币代码
）。

## 样式

SwiftUI 为 Table 提供了几种样式选择，遗憾的是目前只有 `.inset` 可以用于 iPadOS 。

    Table(localeInfos) {
       // 定义 TableColumn ...
    }
    .tableStyle(.inset(alternatesRowBackgrounds:false))

- inset

默认样式（ 本文之前的截图均为 inset 样式 ），可用于 macOS 和 iPadOS。在 mac 下等同于 `inset(alternatesRowBackgrounds: true)` ，在 iPadOS 下等同于 `inset(alternatesRowBackgrounds: false)`

- inset (alternatesRowBackgrounds: Bool)

仅用于 macOS，可以设置是否开启行交错背景，便于视觉区分

- bordered

仅用于 macOS，为 Table 添加边框

![image-20220620183823794](https://cdn.fatbobman.com/image-20220620183823794.png)

- bordered (alternatesRowBackgrounds: Bool)

仅用于 macOS，可以设置是否开启行交错背景，便于视觉区分

> 或许在之后的测试版中，SwiftUI 会扩展更多的样式到 iPadOS 平台

## 行选择

在 Table 中启用行选择与 List 中的方式十分类似：

    struct TableDemo: View {
        @State var localeInfos = [LocaleInfo]()
        @State var selection: String?
        var body: some View {
            Table(localeInfos, selection: $selection) {
               // 定义 TableColumn ...
            }
        }
    }

需要注意的是，Table 要求绑定的变量类型与数据（ 数据需要遵循 Identifier 协议 ）的 id 类型一致。比如本例中，LocaleInfo 的
id 类型为 String。

    @State var selection: String?  // 单选
    @State var selections: Set<String> = []  // 多选，需要 LocaleInfo 遵循 Hashable 协议

下图为开启多选后的场景：

![image-20220620184638673](https://cdn.fatbobman.com/image-20220620184638673.png)

## 排序

Table 另一大核心功能是可以高效地实现多属性排序。

    struct TableDemo: View {
        @State var localeInfos = [LocaleInfo]()
        @State var order: [KeyPathComparator<LocaleInfo>] = [.init(\.identifier, order: .forward)] // 排序条件
        var body: some View {
            Table(localeInfos, sortOrder: $order) { // 绑定排序条件
                TableColumn("标识符", value: \.identifier)
                TableColumn("语言", value: \.language)
                    .width(min: 200, max: 300)
                TableColumn("价格",value: \.price) {
                    Text("\($0.price)")
                        .foregroundColor($0.price > 4 ? .red : .green)
                }
                .width(50)
                TableColumn("货币代码", value: \.currencyCode)
                TableColumn("货币符号", value: \.currencySymbol)
            }
            .onChange(of: order) { newOrder in
                withAnimation {
                    localeInfos.sort(using: newOrder) // 排序条件改变时对数据重排序
                }
            }
            .task {
                localeInfos = prepareData()
                localeInfos.sort(using: order) // 初始化排序
            }
            .scenePadding()
        }
    }

![table_sort_demo1_2022-06-20_18.55.16.2022-06-20
18_57_13](https://cdn.fatbobman.com/table_sort_demo1_2022-06-20_18.55.16.2022-06-20%2018_57_13.gif)

Table 本身并不会修改数据源，当 Table 绑定了排序变量后，点击支持排序的列标题，Table
会自动更改排序变量的内容。开发者仍需监控排序变量的变化进行排序。

Table 要求排序变量的类型为遵循 SortComparator 的数组，本例中我们直接使用了 Swift 提供的 KeyPathComparator
类型。

如果不想让某个列支持排序，只需要不使用含有 value 参数的 TableColumn 构造方法即可，例如：

    TableColumn("货币代码", value: \.currencyCode) // 启用以该属性为依据的排序
    TableColumn("货币代码"){ Text($0.currencyCode) } // 不启用以该属性为依据的排序

    // 切勿在不绑定排序变量时，使用如下的写法。应用程序将无法编译（ 并且几乎不会获得错误提示 ）
    TableColumn("价格",value: \.currencyCode) {
        Text("\($0.price)")
            .foregroundColor($0.price > 4 ? .red : .green)
    }

> 目前的测试版 14 A 5228 q ，当属性类型为 Bool 时，在该列上启用排序会导致应用无法编译

尽管在点击可排序列标题后，仅有一个列标题显示了排序方向，但事实上 Table
将按照用户的点击顺序添加或整理排序变量的排序顺序。下面的代码可以清晰地体现这一点：

    struct TableDemo: View {
        @State var localeInfos = [LocaleInfo]()
        @State var order: [KeyPathComparator<LocaleInfo>] = [.init(\.identifier, order: .forward)]
        var body: some View {
            VStack {
                sortKeyPathView() // 显示当前的排序顺序
                    .frame(minWidth: 0, maxWidth: .infinity, alignment: .trailing)
                Table(localeInfos, sortOrder: $order) {
                    TableColumn("标识符", value: \.identifier)
                    TableColumn("语言", value: \.language)
                        .width(min: 200, max: 300)
                    TableColumn("价格", value: \.price) {
                        Text("\($0.price)")
                            .foregroundColor($0.price > 4 ? .red : .green)
                    }
                    .width(50)
                    TableColumn("货币代码", value: \.currencyCode)
                    TableColumn("货币符号", value: \.currencySymbol)
                }
            }
            .onChange(of: order) { newOrder in
                withAnimation {
                    localeInfos.sort(using: newOrder)
                }
            }
            .task {
                localeInfos = prepareData()
                localeInfos.sort(using: order)
            }
            .scenePadding()
        }

        func sortKeyPath() -> [String] {
            order
                .map {
                    let keyPath = $0.keyPath
                    let sortOrder = $0.order
                    var keyPathString = ""
                    switch keyPath {
                    case \LocaleInfo.identifier:
                        keyPathString = "标识符"
                    case \LocaleInfo.language:
                        keyPathString = "语言"
                    case \LocaleInfo.price:
                        keyPathString = "价格"
                    case \LocaleInfo.currencyCode:
                        keyPathString = "货币代码"
                    case \LocaleInfo.currencySymbol:
                        keyPathString = "货币符号"
                    case \LocaleInfo.supported:
                        keyPathString = "已支持"
                    case \LocaleInfo.updateDate:
                        keyPathString = "日期"
                    default:
                        break
                    }

                    return keyPathString + (sortOrder == .reverse ? "↓" : "↑")
                }
        }

        @ViewBuilder
        func sortKeyPathView() -> some View {
            HStack {
                ForEach(sortKeyPath(), id: \.self) { sortKeyPath in
                    Text(sortKeyPath)
                }
            }
        }
    }

![table_sort_demo2_2022-06-20_19.11.48.2022-06-20
19_13_16](https://cdn.fatbobman.com/table_sort_demo2_2022-06-20_19.11.48.2022-06-20%2019_13_16.gif)

如果担心基于多属性的排序方式有性能方面的问题（ 在数据量很大时 ），可以只使用最后创建的排序条件：

    .onChange(of: order) { newOrder in
        if let singleOrder = newOrder.first {
            withAnimation {
                localeInfos.sort(using: singleOrder)
            }
        }
    }

在将 SortComparator 转换成 SortDescription（ 或 NSSortDescription ） 用于 Core Data
时，请不要使用 Core Data 无法支持的 Compare 算法。

## 拖拽

Table 支持以行为单位进行 Drag&Drop 。启用 Drag 支持时，将无法使用 Table 的简化版定义：

    Table {
        TableColumn("标识符", value: \.identifier)
        TableColumn("语言", value: \.language)
            .width(min: 200, max: 300)
        TableColumn("价格", value: \.price) {
            Text("\($0.price)")
                .foregroundColor($0.price > 4 ? .red : .green)
        }
        .width(50)
        TableColumn("货币代码", value: \.currencyCode)
        TableColumn("货币符号", value: \.currencySymbol)
    } rows: {
        ForEach(localeInfos){ localeInfo in
            TableRow(localeInfo)
                .itemProvider {  // enable Drap
                    NSItemProvider(object: localeInfo.identifier as NSString)
                }
        }
    }

![table_drag_demo_2022-06-20_19.36.09.2022-06-20
19_37_28](https://cdn.fatbobman.com/table_drag_demo_2022-06-20_19.36.09.2022-06-20%2019_37_28.gif)

## 交互

除了行选择和行拖拽外，Table 还支持对行设置上下文菜单（ macOS 13+、iPadOS 16+ ）：

    ForEach(localeInfos) { localeInfo in
        TableRow(localeInfo)
            .contextMenu{
                Button("编辑"){}
                Button("删除"){}
                Button("共享"){}
            }
    }

![image-20220620194057400](https://cdn.fatbobman.com/image-20220620194057400.png)

创建可交互的单元格，将极大地提升表格的用户体验。

    struct TableDemo: View {
        @State var localeInfos = [LocaleInfo]()
        var body: some View {
            VStack {
                Table(localeInfos) {
                    TableColumn("标识符", value: \.identifier)
                    TableColumn("语言", value: \.language)
                        .width(min: 200, max: 300)
                    TableColumn("价格") {
                        Text("\($0.price)")
                            .foregroundColor($0.price > 4 ? .red : .green)
                    }
                    .width(50)
                    TableColumn("货币代码", value: \.currencyCode)
                    TableColumn("货币符号", value: \.currencySymbol)
                    TableColumn("已支持") {
                        supportedToggle(identifier: $0.identifier, supported: $0.supported)
                    }
                }
            }
            .lineLimit(1)
            .task {
                localeInfos = prepareData()
            }
            .scenePadding()
        }

        @ViewBuilder
        func supportedToggle(identifier: String, supported: Bool) -> some View {
            let binding = Binding<Bool>(
                get: { supported },
                set: {
                    if let id = localeInfos.firstIndex(where: { $0.identifier == identifier }) {
                        self.localeInfos[id].supported = $0
                    }
                }
            )
            Toggle(isOn: binding, label: { Text("") })
        }
    }

![image-20220620194359218](https://cdn.fatbobman.com/image-20220620194359218.png)

## 先驱还是先烈？

如果你在 Xcode 中编写使用 Table 的代码，大概率会碰到自动提示无法工作的情况。甚至还会出现应用程序无法编译，但没有明确的错误提示（ 错误发生在
Table 内部）。

出现上述问题的主要原因是，苹果没有采用其他 SwiftUI 控件常用的编写方式（ 原生的 SwiftUI 容器或包装 UIKit 控件），开创性地使用了
result builder 为 Table 编写了自己的 DSL 。

或许由于 Table 的 DSL 效率不佳的缘故（ 过多的泛型、过多的构造方法、一个 Table 中有两个 Builder ），当前版本的 Xcode
在处理 Table 代码时相当吃力。

另外，由于 Table DSL 的定义并不完整（ 缺少类似 Group 的容器 ），目前至多只能支持十列数据（ 原因请参阅 [ ViewBuilder
研究（下） —— 从模仿中学习
](/zh/posts/viewbuilder2/#%E5%88%9B%E5%BB%BA%E6%9B%B4%E5%A4%9A%E7%9A%84-buildblock)
）。

也许苹果是吸取了 Table DSL 的教训，WWDC 2022 中推出的 SwiftUI Charts（ 也是基于 result builder ）在
Xcode 下的性能表现明显地好于 Table 。

希望苹果能将 Charts 中获取的经验反哺给 Table ，避免让先驱变成了先烈。

## 在其他平台上创建表格

虽然 Table 可以在按照 iOS 16 的 iPhone 上运行，但由于只能显示首列数据，因此并不具备实际的意义。

如果想在 Table 尚不支持或支持不完善的平台（譬如 iPhone）上实现表格功能，请根据你的需求选择合适的替代方案：

- 数据量较大，需要懒加载

List、LazyVGrid

- 基于行的交互操作（ 拖拽、上下文菜单、选择 ）

List（ Grid 中的 GridRow 并非真正意义上的行 ）

- 需要视图可渲染（ 保存成图片 ）

LazyVGrid、Grid

- 可固定的标题行

List、LazyVGrid、Grid（ 比如使用 matchedGeometryEffect ）

## 总结

如果你想在 SwiftUI 中用更少的代码、更清晰的表达方式创建可交互的表格，不妨试试 Table 。同时也盼望苹果能在接下来的版本中改善 Table 在
Xcode 中的开发效率，并为 Table 添加更多的原生功能。

# @State 研究

> 本文试图探讨并分析 SwiftUI 中 @State 的实现方式和运行特征；最后提供了一个有关扩展@State 功能的思路及例程。读者需要对
> SwiftUI 的响应式编程有基本概念。

## 研究的意义何在

我在去年底使用了 SwiftUI 写了第一个 iOS App **健康笔记**
，这是我第一次接触响应式编程概念。在有了些基本的认识和尝试后，深深的被这种编程的思路所打动。不过，我在使用中也发现了一些奇怪的问题。就像之前在 [ 老人新兵
](/zh/posts/healthnote_development_log_2020/)
中说的那样，我发现在视图（View）数量达到一定程度，随着数据量的增加，整个 App 的响应有些开始迟钝，变得有粘滞感、不跟手。App
响应出现了问题一方面肯定和我的代码效率、数据结构设计欠佳有关；不过随着继续分析，发现其中也有很大部分原因来自于 SwiftUI
中所使用的响应式的实现方式。不恰当的使用，可能导致响应速度会随着数据量及 View
量的增加而大幅下降。通过一段时间的研究和分析，我打算用两篇文章来阐述这方面的问题，并尝试提供一个现阶段的使用思路。

## 数据（状态）驱动

在 SwiftUI 中，视图是由数据（状态）驱动的。按照苹果的说法，视图是状态的函数，而不是事件的序列（The views are a function
of state, not a sequence of
events）。每当视图在创建或解析时，都会为该视图和与该视图中使用的状态数据之间创建一个依赖关系，每当状态的信息发生变化是，有依赖关系的视图则会马上反应出这些变化并重绘。SwiftUI
中提供了诸如 @State @ObservedObject @EnvironmentObject 等来创建应对不同类型、不同作用域的状态形式。

![类型及作用域](https://cdn.fatbobman.com/state-study-image.jpg)

图片来自于 SwiftUI for Absoloute Beginners

其中 @State 只能用于当前视图，并且其对应的数据类型为值类型（如果非要对应引用类型的话则必须在每次赋值时重新创建新的实例才可以）。

    struct DemoView:View{
      @State var name = "肘子"
      var body:some View{
        VStack{
          Text(name)
          Button("改名"){
            self.name = "大肘子"
          }
        }
      }
    }

通过执行上面代码，我们可以发现两个情况：

1. 通过使用 @State，我们可以在未使用 mutating 的情况下修改结构中的值

2. 当状态值发生变化后，视图会自动重绘以反应状态的变化。

## @State 如何工作的

在分析 @State 如何工作之前，我们需要先了解几个知识点

### 属性包装器

作为 swift 5.1 的新增功能之一， [ 属性包装器在管理属性如何存储和定义属性的代码之间添加了一个分割层
](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/10_properties#property-
wrappers) 。通过该特性，可以在对值校验、持久化、编解码等多个方面获得收益。

它的实现也很简单，下面的例子定义了一个包装器用来确保它包装的值始终小于等于 12。如果要求它存储一个更大的数字，它则会存储 12
这个数字。呈现值（投射值）则返回当前包装值是否为偶数

    @propertyWrapper
    struct TwelveOrLess {
        private var number: Int
        init() { self.number = 0 }
        var wrappedValue: Int {
            get { return number }
            set { number = min(newValue, 12) }
        }
        var projectedValue: Bool {
            self.number % 2 == 0
        }
    }

更多的具体资料请查阅 [ 官方文档 ](https://swiftgg.gitbook.io/swift/swift-jiao-
cheng/10_properties#property-wrappers)

### Binding

Binding 是数据的一级引用，在 SwiftUI
中作为数据（状态）双向绑定的桥梁，允许在不拥有数据的情况下对数据进行读写操作。我们可以绑定到多种类型，包括 State ObservedObject
等，甚至还可以绑定到另一个 Binding 上面。Binding 本身就是一个 Getter 和 Setter 的封装。

### State 的定义

    @frozen @propertyWrapper public struct State<Value> : DynamicProperty {

        /// Initialize with the provided initial value.
        public init(wrappedValue value: Value)

        /// Initialize with the provided initial value.
        public init(initialValue value: Value)

        /// The current state value.
        public var wrappedValue: Value { get nonmutating set }

        /// Produces the binding referencing this state value
        public var projectedValue: Binding<Value> { get }
    }

### DynamicProperty 的定义

    public protocol DynamicProperty {

        /// Called immediately before the view's body() function is
        /// executed, after updating the values of any dynamic properties
        /// stored in `self`.
        mutating func update()
    }

### 工作原理

前面我们说过 @State 有两个作用

1. 通过使用 @State 我们可以在未使用 mutating 的情况下修改结构中的值

2. 当状态值发生变化后，视图会自动重绘以反应状态的变化。

让我们根据上面的知识点来分析如何才能实现以上功能。

- @State 本身包含 @propertyWrapper, 意味着他是一个属性包装器。

- `public var wrappedValue: Value { get nonmutating set }` 意味着他的包装值并没有保存在本地。

- 它的呈现值（投射值）为 Binding 类型。也就是只是一个管道，对包装数据的引用

- 遵循 DynamicProperty 协议，该协议完成了创建数据（状态）和视图的依赖操作所需接口。现在只暴露了很少的接口，我们暂时无法完全使用它。

在了解了以上几点后，我们来尝试使用自己的代码来构建一个 @State 的 _**半成品** _

    @propertyWrapper
    struct MyStates:DynamicProperty{
        init(wrappedValue:String){
            UserDefaults.standard.set(wrappedValue, forKey: "myString")
        }

        var wrappedValue:String{
            nonmutating set{UserDefaults.standard.set(newValue, forKey: "myString")}
            get{UserDefaults.standard.string(forKey: "myString") ?? ""}
        }

        var projectedValue:Binding<String>{
            Binding<String>(
                get:{String(self.wrappedValue)},
                set:{
                    self.wrappedValue = $0
            }
            )
        }

        func update() {
            print("重绘视图")
        }
    }

这是一个可以用来包装 String 类型的 State。

我们使用 UserDefault 将数据包装后保存到本地。读取包装数据也是从本地的 UserDefault 里读取的。

为了能够包装其他的类型的数据，同时也为了能够提高存储效率，进一步的可以修改成如下代码：

    @propertyWrapper
    struct MyState<Value>:DynamicProperty{
        private var _value:Value
        private var _location:AnyLocation<Value>?

        init(wrappedValue:Value){
            self._value = wrappedValue
            self._location = AnyLocation(value: wrappedValue)
        }

        var wrappedValue:Value{
            get{ _location?._value.pointee ?? _value}
            nonmutating set{ _location?._value.pointee = newValue}
        }

        var projectedValue:Binding<Value>{
            Binding<Value>(
                get:{self.wrappedValue},
                set:{self._location?._value.pointee = $0}
            )
        }

        func update() {
            print("重绘视图")
        }
    }

    class AnyLocation<Value>{
        let _value = UnsafeMutablePointer<Value>.allocate(capacity: 1)
        init(value:Value){
            self._value.pointee = value
        }
    }

至此，我们完成了这个 @MyState 的半成品。

之所以说是半成品，因为尽管我们也遵循了 DynamicProperty 协议，但我们自己编写的这段代码并不能和视图建立依赖。我们可以和使用 @State
一样来使用 @MyState，同样支持绑定、修改，除了视图不会自动刷新 😂。

但至少我们可以大概了解 @State 是如何让我们在视图中修改、绑定数据的。

### 什么时候建立的依赖？

我目前无法找到任何关于 SwiftUI 建立依赖的更具体的资料或实现线索。不过我们可以通过下面两段代码来猜测编译器是如何处理数据和视图之间的依赖关联时机的。

    struct MainView: View {
        @State var date: String = Date().description
        var body: some View {
            print("mainView")
            return Form {
                SubView(date: $date)
                Button("修改日期") {
                    self.date = Date().description
                }
            }
        }
    }

    struct SubView: View {
        @Binding var date: String
        var body: some View {
            print("subView")
            return Text(date)
        }
    }

执行这段代码，我们点击 **修改日期** ，我们会得到如下输出

    mainView
    subView
    ...

虽然我们在 MainView 中使用 @State 声明了 date，并且在 MainView 中修改了 date 的值，但由于我们并没有在
MainView 中使用 date 的值来进行显示或者判断，所以无论我们如何修改 date 值，MainView 都不会重绘。我推测 @State
同视图的依赖是在 ViewBuilder 解析时进行的。编译器在解析我们的 body 时，会判断 date
的数据变化是否会对当前视图造成改变。如果没有则不建立依赖关联。

我们可以用另一段代码来分析编译器对 ObservedObject 的反应。

    struct MainView: View {
        @ObservedObject var store = AppStore()

        var body: some View {
            print("mainView")
            return Form {
                SubView(date: $store.date)
                Button("修改日期") {
                    self.store.date = Date().description
                }
            }
        }
    }

    struct SubView: View {
        @Binding var date: String
        var body: some View {
            print("subView")
            return Text(date)
        }
    }

    class AppStore:ObservableObject{
        @Published var date:String = Date().description
    }

执行后输出如下：

    mainView
    subView
    mainView
    subView
    ...

我们把 @State 换成了 @ObservedObject ，同样在 MainView 中并没有显示 `store.date`
的值或者用其来做判断，但是只要我们改变了 store 里的 date 值，MainView 便会刷新重绘。由此可以推测，SwiftUI 对于
ObservedObject 采用了不同的依赖创建时机，只要声明，无论 body 里是否有需要，在 ObservableObject 的
objectWillChange 产生 send 后，都会进行重绘。因此 ObservedObject 很可能是在初始化 MainView
的时候建立的依赖关系。

之所以花气力来判断这个问题， **因为这两种创建依赖的时机的不同会导致 View 更新效率的巨大差异。这个差异也正是我下一篇文章要重点探讨的地方** 。

## 打造适合自己的增强型 @State

@State 使用属性包装器这个特性来实现了它既定的功能，不过属性包装器还被广泛用于数据验证、副作用等众多领域，我们能否将众多功能属性集于一身？

本文我们自己通过代码打造的 @State 半成品并不能创建和视图的依赖，我们如何才能完成这种依赖关联的创建？

@State 不仅可以被用于对属性的包装，同时 State 本身也是一个标准的结构体。它通过内部没有暴露的功能接口完成了同视图的依赖创建。

以下两种使用方式是等效的：

    @State var name = ""
    self.name = "肘子"
    var name = State<String>(wrappedValue:"")
    self.name.wrappedValue = "肘子"

因此我们可以通过将 State 作为包装值类型，创建新的属性包装器，来实现我们的最终目标 —— 完整功能、可任意扩展的增强型 @State。

    @propertyWrapper
    struct MyState<Value>:DynamicProperty{
        typealias Action = (Value) -> Void

        private var _value:State<Value>
        private var _toAction:Action?

        init(wrappedValue value:Value){
            self._value = State<Value>(wrappedValue: value)
        }

        init(wrappedValue value:Value,toAction:@escaping Action){
            self._value = State<Value>(wrappedValue: value)
            self._toAction = toAction
        }

        public var wrappedValue: Value {
            get {self._value.wrappedValue}
            nonmutating set {self._value.wrappedValue = newValue}
        }

        public var projectedValue: Binding<Value>{
            Binding<Value>(
                get: {self._value.wrappedValue},
                set: {
                    self._value.wrappedValue = $0
                    self._toAction?($0)
            }
            )
        }

        public func update() {
           print("视图重绘")
        }

    }

这段代码仅作为一个例子，可以根据自己的需求任意创建自己所需的功能。

    @MyState var name = "hello"  //实现和标准@State 一样的功能
    @MyState<String>(
      wrappedValue: "hello",
      toAction: {print($0)}
    ) var name
    //在每次赋值后（包括通过 Binding 修改）执行 toAction 定义的函数

## 接下来？

在响应式编程开始流行的今天，越来越多的人都在使用单一数据源（Single Souce of Truth）的构架方式进行设计和开发。如何使用 @State
这种作用域范围仅限于当前视图的特性？仅从命名来看，苹果给了他最本质的名称——State。State 属于 SwiftUI
架构，ObservableObject 属于 Combine 架构，SwiftUI 明显对于 State 的优化要好于
ObservableObject。如何在满足单一数据源的情况下最大限度享受 SwiftUI 的优化便利？我将在下一篇文章中进行进一步探讨。

# 用 SwiftUI 实现 iOS mail 程序的侧滑菜单

> 随着 SwiftUI 2.0 的不断完善，我觉得是时候将我的 App 做一个较大的升级了。之前一直想在 App 中实现类似 iOS
> 邮件程序那样优雅的侧滑菜单效果，在网上也找了一下，实现的较好的是适用于 UIKit 的，基本上没有能够很好的适配 SwiftUI 的项目库。最终自己在
> Xcode 12 实现了一个。

SwipeCell 是一个用 Swift 5.3 开发的 SwiftUI 库。目标是为了实现类似 iOS Mail
程序实现的左右滑动菜单功能。SwipeCell 需要 XCode 12 ,iOS 14

[ SwipeCell GitHub ](https://github.com/fatbobman/SwipeCell)

## 配置 Button

    let button1 = SwipeCellButton(buttonStyle: .titleAndImage,
                    title: "Mark",
                    systemImage: "bookmark",
                    titleColor: .white,
                    imageColor: .white,
                    view: nil,
                    backgroundColor: .green,
                    action: {bookmark.toggle()},
                    feedback:true
                    )
    //你可以将按钮设置成任意 View 从而实现更复杂的设计以及动态效果
    let button3 = SwipeCellButton(buttonStyle: .view, title:"",systemImage: "", view: {
        AnyView(
            Group{
                if unread {
                    Image(systemName: "envelope.badge")
                        .foregroundColor(.white)
                        .font(.title)
                }
                else {
                    Image(systemName: "envelope.open")
                        .foregroundColor(.white)
                        .font(.title)
                }
            }
        )
    }, backgroundColor: .orange, action: {unread.toggle()}, feedback: false)

## 配置 Slot

    let slot1 = SwipeCellSlot(slots: [button2,button1])
    let slot2 = SwipeCellSlot(slots: [button4], slotStyle: .destructive, buttonWidth: 60)
    let slot3 = SwipeCellSlot(slots: [button2,button1],slotStyle: .destructiveDelay)

## 装配

    cellView()
        .swipeCell(cellPosition: .left, leftSlot: slot4, rightSlot: nil)

更多的配置选项

    cellView()
        .swipeCell(cellPosition: .both,
                    leftSlot: slot1,
                    rightSlot: slot1 ,
                    swipeCellStyle: SwipeCellStyle(
                                alignment: .leading,
                                dismissWidth: 20,
                                appearWidth: 20,
                                destructiveWidth: 240,
                                vibrationForButton: .error,
                                vibrationForDestructive: .heavy,
                                autoResetTime: 3)
                                )

## 滚动列表自动消除

For List

    List{
        ...
        }
        .dismissSwipeCell()
    }

For single cell in ScrollView

    ScrollView{
        VStack{
            Text("Mail Title")
                .dismissSwipeCellForScrollView()
            Text("Mail Content")
            ....
        }
        .frame(maxWidth:.infinity,maxHeight: .infinity)
    }
    .swipeCell(cellPosition: .both, leftSlot: leftSlot, rightSlot: rightSlot,clip: false)

For LazyVStack in ScrollView

    ScrollView{
        LazyVStack{
        ForEach(lists,id:\.self){ item in
           Text("Swipe in scrollView:\(item)")
            .frame(height:80)
            .swipeCell(cellPosition: .both, leftSlot:slot, rightSlot: slot)
            .dismissSwipeCellForScrollViewForLazyVStack()
        }
    }

- `dismissSwipeCell` 在 editmode 下支持选择
- `dismissSwipeCellForScrollView` 用于 ScrollView, 通常用于只有一个 Cell 的场景，比如说 Mail 中的邮件内容显示。参看 Demo 中的演示
- `dismissSwipeCellForScrollViewForLazyVStack` 用于 ScrollView 中使用 LazyVStack 场景。个别时候会打断滑动菜单出现动画。个人觉得如无特别需要还是使用 List 代替 LazyVStack 比较好。

由于 SwiftUI 没有很好的方案能够获取滚动状态，所以采用了 [ Introspect
](https://github.com/siteline/SwiftUI-Introspect.git) 实现的上述功能。

`destructiveDelay` 形式的 button，需要在 action 中添加 dismissDestructiveDelayButton
() 已保证在 alter 执行后，Cell 复位。

## 当前问题

- 动画细节仍然不足
- EditMode 模式下仍有不足

## 欢迎多提宝贵意见

SwipeCell is available under the [ MIT license
](https://github.com/fatbobman/SwipeCell/blob/main/LICENSE.md) .

# ViewBuilder 研究（上）—— 掌握 Result builders

作为一个严重依赖 SwiftUI 的开发者，同视图打交道是最平常不过的事情了。从第一次接触 SwiftUI
的声明式编程方式开始，我便喜欢上了这种写代码的感觉。但接触地越多，碰到的问题也越多。起初，我单纯地将很多问题称之为灵异现象，认为大概率是由于 SwiftUI
的不成熟导致的。随着不断地学习和探索，发现其中有相当部分的问题还是因为自己的认知不够所导致的，完全可以改善或避免。

我将通过上下两篇博文，对构建 SwiftUI 视图的 ViewBuilder 进行探讨。上篇将介绍 ViewBuilder 背后的实现者 —— result
builders ; 下篇将通过对 ViewBuilder 的仿制，进一步地探寻 SwiftUI 视图的秘密。

## 本文希望达成的目标

希望在阅读完两篇文章后能消除或减轻你对下列疑问的困惑：

- 如何让自定义视图、方法支持 ViewBuilder
- 为什么复杂的 SwiftUI 视图容易在 Xcode 上卡死或出现编译超时
- 为什么会出现 “Extra arguments” 的错误提示（仅能在同一层次放置有限数量的视图）
- 为什么要谨慎使用 AnyView
- 如何避免使用 AnyView
- 为什么无论显示与否，视图都会包含所有选择分支的类型信息
- 为什么绝大多数的官方视图类型的 body 都是 Never
- ViewModifier 同特定视图类型的 modifier 之间的区别

## 什么是 Result builders

### 介绍

result builders
允许某些函数通过一系列组件中隐式构建结果值，按照开发者设定的构建规则对组件进行排列。通过对函数语句应用构建器进行转译，result builders
提供了在 Swift 中创建新的领域特定语言（ DSL ）的能力（为了保留原始代码的动态语义，Swift 有意地限制了这些构建器的能力）。

与常见的使用点语法实现的类 DSL 相比，使用 result builders 创建的 DSL
使用更简单、无效内容更少、代码更容易理解（在表述具有选择、循环等逻辑内容时尤为明显），例如：

使用点语法（ [ Plot ](https://github.com/JohnSundell/Plot) ）：

    .div(
        .div(
            .forEach(archiveItems.keys.sorted(by: >)) { absoluteMonth in
                .group(
                    .ul(
                        .forEach(archiveItems[absoluteMonth]) { item in
                            .li(
                                .a(
                                    .href(item.path),
                                    .text(item.title)
                                )
                            )
                        }
                    ),
                    .if( show,
                        .text("hello"),
                      else: .text("wrold")
                     ),
                )
            }
        )
    )

通过 result builders 创建的构建器 ( [ swift-html
](https://github.com/BinaryBirds/swift-html) )：

    Div {
        Div {
            for i in 0..<100 {
                Ul {
                    for item in archiveItems[i] {
                        li {
                            A(item.title)
                                .href(item.path)
                        }
                    }
                }
                if show {
                    Text("hello")
                } else {
                    Text("world")
                }
            }
        }
    }

### 历史与发展

自 Swift 5.1 开始，result builders 便随着 SwiftUI 的推出隐藏在 Swift 语言之中（当时名为 function
builder）。随着 Swift 与 SwiftUI 的不断进化，最终被正式纳入到 Swift 5.4 版本之中。目前苹果在 SwiftUI
框架中大量地使用了该功能，除了最常见的视图构建器（ViewBuilder）外，其他还包括：AccessibilityRotorContentBuilder、CommandsBuilder、LibraryContentBuilder、SceneBuilder、TableColumnBuilder、TableRowBuilder、ToolbarContentBuilder、WidgetBundleBuilder
等。另外，在最新的 Swift 提案中，已出现了 [ Regex builder DSL
](https://forums.swift.org/t/pitch-regex-builder-dsl/56007)
的身影。其他的开发者利用该功能也创建了不少的 [ 第三方库 ](https://github.com/carson-katri/awesome-
result-builders#html) 。

### 基本用法

#### 定义构建器类型

一个结果构建器类型必须满足两个基本要求。

- 它必须通过 `@resultBuilder` 进行标注，这表明它打算作为一个结果构建器类型使用，并允许它作为一个自定义属性使用。

- 它必须至少实现一个名为 `buildBlock` 的类型方法

例如：

    @resultBuilder
    struct StringBuilder {
        static func buildBlock(_ parts: String...) -> String {
            parts.map{"⭐️" + $0 + "🌈"}.joined(separator: " ")
        }
    }

通过上面的代码，我们便创建了一个具有最基本功能的结果构建器。使用方法如下：

    @StringBuilder
    func getStrings() -> String {
        "喜羊羊"
        "美羊羊"
        "灰太狼"
    }

    // ⭐️喜羊羊🌈 ⭐️美羊羊🌈 ⭐️灰太狼🌈

#### 为构建器类型提供足够的结果构建方法子集

- `buildBlock(_ components: Component...) -> Component`

用来构建语句块的组合结果。每个结果构建器至少要提供一个它的具体实现。

- `buildOptional(_ component: Component?) -> Component`

用于处理在特定执行中可能或不可能出现的部分结果。当一个结果构建器提供了 `buildOptional(_:)` 时，转译后的函数可以使用没有 `else` 的 `if` 语句，同时也提供了对 `if let` 的支持。

- `buildEither(first: Component) -> Component` 和 `buildEither(second: Component) -> Component`

用于在选择语句的不同路径下建立部分结果。当一个结果构建器提供这两个方法的实现时，转译后的函数可以使用带有 `else` 的 `if` 语句以及 `switch` 语句。

- `buildArray(_ components: [Component]) -> Component`

用来从一个循环的所有迭代中收集的部分结果。在一个结果构建器提供了 `buildArray(_:)` 的实现后，转译后的函数可以使用 `for...in` 语句。

- `buildExpression(_ expression: Expression) -> Component`

它允许结果构建器区分 `表达式` 类型和 `组件` 类型，为语句表达式提供上下文类型信息。

- `buildFinalResult(_ component: Component) -> FinalResult`

用于对最外层的 `buildBlock` 结果的再包装。例如，让结果构建器隐藏一些它并不想对外的类型（转换成可对外的类型）。

- `buildLimitedAvailability(_ component: Component) -> Component`

用于将 `buildBlock` 在受限环境下（例如 `if #available` ）产生的部分结果转化为可适合任何环境的结果，以提高 API
的兼容性。

> 结果构建器采用 ad hoc
> 协议，这意味着我们可以更灵活的重载上述方法。然而，在某些情况下，结果构建器的转译过程会根据结果构建器类型是否实现了某个方法来改变其行为。

之后会通过示例对上述的方法逐一做详尽介绍。下文中，会将“结果构建器”简称为“构建器”。

## 范例一：AttributedStringBuilder

本例中，我们将创建一个用于声明 AttributedString 的构建器。对 AttributedString 不太熟悉的朋友，可以阅读我的另一篇博文 [
AttributedString——不仅仅让文字更漂亮 ](/zh/posts/attributedstring/) 。

> 范例一的完整代码可以在 [ 此处
> ](https://github.com/fatbobman/BlogCodes/tree/main/AttributedStringBuilder/AttributedStringBuilderDemo.playground)
> 获取（ Demo 1 ）

本例结束后，我们将可以用如下的方式来声明 AttributedString ：

    @AttributedStringBuilder
    var text: Text {
        "_*Hello*_"
            .localized()
            .color(.green)

        if case .male = gender {
            " Boy!"
                .color(.blue)
                .bold()

        } else {
            " Girl!"
                .color(.pink)
                .bold()
        }
    }

![image-20220331202541444](https://cdn.fatbobman.com/image-20220331202541444.png)

### 创建构建器类型

    @resultBuilder
    public enum AttributedStringBuilder {
        // 对应 block 中没有走 component 的情况
        public static func buildBlock() -> AttributedString {
            .init("")
        }

        // 对应 block 中有 n 个 component 的情况（ n 为正整数 ）
        public static func buildBlock(_ components: AttributedString...) -> AttributedString {
            components.reduce(into: AttributedString("")) { result, next in
                result.append(next)
            }
        }
    }

我们首先创建了一个名为 AttributedStringBuilder 的构建器，并为其实现了两个 `buildBlock`
方法。构建器在转译时会自动地选择对应的方法。

现在，可以为 block 提供任意数量的 component （ AttributedString ） ， `buildBlock`
会将其转换成指定的结果（AttributedString）。

在实现 `buildBlock` 方法时，components 与 block 的返回数据类型应根据实际需求定义，无需一致。

### 使用构建器转译 Block

可以采用显式的方式来调用构建器，例如：

    @AttributedStringBuilder // 明确标注
    var myFirstText: AttributedString {
        AttributedString("Hello")
        AttributedString("World")
    }
    // "HelloWorld"

    @AttributedStringBuilder
    func mySecondText() -> AttributedString {} // 空 block ，将调用 buildBlock() -> AttributedString
    // ""

也可以采用隐式的方式调用构建器：

    // 在 API 端标注
    func generateText(@AttributedStringBuilder _ content: () -> AttributedString) -> Text {
        Text(content())
    }

    // 在客户端隐式调用
    VStack {
        generateText {
            AttributedString("Hello")
            AttributedString(" World")
        }
    }

    struct MyTest {
        var content: AttributedString
        // 在构造方法中标注
        init(@AttributedStringBuilder _ content: () -> AttributedString) {
            self.content = content()
        }
    }

    // 隐式调用
    let attributedString = MyTest {
        AttributedString("ABC")
        AttributedString("BBC")
    }.content

无论以何种方式，如果在 block 的最后使用了 `return` 关键字来返回结果，则构建器将自动忽略转译过程。例如：

    @AttributedStringBuilder
    var myFirstText: AttributedString {
        AttributedString("Hello") // 该语句将被忽略
        return AttributedString("World") // 仅返回 World
    }
    // "World"

> 为了在 block 中使用构建器不支持的语法，开发者会尝试使用 `return`
> 来返回结果值，应避免出现这种情况。因为这会导致开发者将失去通过构建器进行转译所带来的灵活性。

下面的代码在使用构建器转译时和不使用构建器转译时的状态完全不同：

    // 构建器自动转译，block 只返回最终的合成结果，代码可正常执行
    @ViewBuilder
    func blockTest() -> some View {
        if name.isEmpty {
            Text("Hello anonymous!")
        } else {
            Rectangle()
                .overlay(Text("Hello \(name)"))
        }
    }

    // 构建器的转译行为因 return 而被忽略。 block 中的选择语句两个分支返回了两种不同的类型，无法满足必须返回同一类型的要求（some View），编译无法通过。
    @ViewBuilder
    func blockTest() -> some View {
        if name.isEmpty {
            return Text("Hello anonymous!")
        } else {
            return Rectangle()
                .overlay(Text("Hello \(name)"))
        }
    }

在 block 中使用如下的方式调用代码，可以在不影响构建器转译过程的情况下完成其他的工作：

    @AttributedStringBuilder
    var myFirstText: AttributedString {
        let _ = print("update") // 声明语句不会影响构建器的转译
        AttributedString("Hello")
        AttributedString("World")
    }

### 添加 modifier

在继续完善构建器其他的方法之前，我们先为 AttributedStringBuilder 添加一些类似 SwiftUI 的 ViewModifier
功能，从而像 SwiftUI 那样方便的修改 AttributedString 的样式。添加下面的代码：

    public extension AttributedString {
        func color(_ color: Color) -> AttributedString {
            then {
                $0.foregroundColor = color
            }
        }

        func bold() -> AttributedString {
            return then {
                if var inlinePresentationIntent = $0.inlinePresentationIntent {
                    var container = AttributeContainer()
                    inlinePresentationIntent.insert(.stronglyEmphasized)
                    container.inlinePresentationIntent = inlinePresentationIntent
                    let _ = $0.mergeAttributes(container)
                } else {
                    $0.inlinePresentationIntent = .stronglyEmphasized
                }
            }
        }

        func italic() -> AttributedString {
            return then {
                if var inlinePresentationIntent = $0.inlinePresentationIntent {
                    var container = AttributeContainer()
                    inlinePresentationIntent.insert(.emphasized)
                    container.inlinePresentationIntent = inlinePresentationIntent
                    let _ = $0.mergeAttributes(container)
                } else {
                    $0.inlinePresentationIntent = .emphasized
                }
            }
        }

        func then(_ perform: (inout Self) -> Void) -> Self {
            var result = self
            perform(&result)
            return result
        }
    }

由于 AttributedString 是值类型，因此我们需要创建一个新的拷贝，并在其上修改属性。modifier 的使用方法如下：

    @AttributedStringBuilder
    var myFirstText: AttributedString {
        AttributedString("Hello")
             .color(.red)
        AttributedString("World")
             .color(.blue)
             .bold()
    }

虽然只编写了很少的代码，但目前已经逐渐有了点 DSL 的感觉了。

### 简化表达

由于 block 只能接收特定类型的 component （ AttributedString ），因此每行代码都需要添加 AttributedString
的类型前缀，导致工作量大，同时也影响了阅读体验。通过使用 `buildExpression` 可以简化这一过程。

添加下面的代码：

    public static func buildExpression(_ string: String) -> AttributedString {
        AttributedString(string)
    }

构建器会将 String 首先转换成 AttributedString，然后再将其传入到 buildBlock 中。添加上述代码后，我们直接使用
String 替换掉 AttributedString：

    @AttributedStringBuilder
    var myFirstText: AttributedString {
        "Hello"
        "World"
    }

不过，现在我们又面临了新问题 —— 无法在 block 中混合使用 String 和 AttributedString。这是因为，如果我们不提供自定义的 `buildExpression` 实现，构建器会通过 `buildBlock` 推断出 component 的类型是 AttributedString
。一旦我们提供了自定义的 `buildExpression` ，构建器将不再使用自动推断。解决的方法就是为 AttributedString 也创建一个
`buildExpression` :

    public static func buildExpression(_ attributedString: AttributedString) -> AttributedString {
        attributedString
    }

现在就可以在 block 中混用两者了。

    @AttributedStringBuilder
    var myFirstText: AttributedString {
        "Hello"
        AttributedString("World")
    }

另一个问题是，我们无法直接在 String 下使用我们之前创建的 modifier 。因为之前的 modifier 是针对 AttributedString
的，点语法将只能使用针对 String 的方法。解决方式有两种：一是扩展 String ，将其转换成 AttributedString，二是为 String
添加上 modifier 转换器。我们暂时先采用第二种较繁琐的方式：

    public extension String {
        func color(_ color: Color) -> AttributedString {
            AttributedString(self)
                .color(color)
        }

        func bold() -> AttributedString {
            AttributedString(self)
                .bold()
        }

        func italic() -> AttributedString {
            AttributedString(self)
                .italic()
        }
    }

现在，我们已经可以快速、清晰地进行声明了。

    @AttributedStringBuilder
    var myFirstText: AttributedString {
        "Hello"
             .color(.red)
        "World"
             .color(.blue)
             .bold()
    }

AttributedString 提供了对本地化字符串以及部分 Markdown 语法的支持，但仅适用于通过 String.
LocalizationValue 类型构造的 AttributedString ，可以通过如下的方式来解决这个问题：

    public extension String {
        func localized() -> AttributedString {
            .init(localized: LocalizationValue(self))
        }
    }

将字符串转换成采用 String. LocalizationValue 构造的 AttributedString，转换后将可直接使用为
AttributedString 编写的 modifier（你也可以对 String 采用类似的方式，从而避免为 String 重复编写
modifier）。

    @AttributedStringBuilder
    var myFirstText: AttributedString {
        "Hello"
             .color(.red)
        "~**World**~"
             .localized()
             .color(.blue)
             //.bold()    通过 Markdown 语法来描述粗体。当前在使用 Markdown 语法的情况下，直接对 inlinePresentationIntent 进行设置会有冲突。
    }

![image-20220401090042983](https://cdn.fatbobman.com/image-20220401090042983.png)

### 构建器转译的逻辑

了解构建器是如何转译的，将有助于之后的学习。

    @AttributedStringBuilder
    var myFirstText: AttributedString {
        "Hello"
        AttributedString("World")
             .color(.red)
    }

构建器在处理上面的代码时，将会转译成下面的代码：

    var myFirstText: AttributedString {
        let _a = AttributedStringBuilder.buildExpression("Hello")  // 调用针对 String 的 buildExpression
        let _b = AttributedStringBuilder.buildExpression(AttributedString("World").color(.red)) // 调用针对 AtributedString 的 buildExpression
        return AttributedStringBuilder.buildBlock(_a,_b) // 调用支持多参数的 buildBloack
    }

上下两段代码完全等价，Swift 会在幕后自动帮我们完成了这个过程。

> 在学习创建构建器时，通过在构建器方法的实现内部添加打印命令，有助于更好地掌握每个方法的调用时机。

### 添加选择语句支持（ 不带 else 的 if ）

result builders 在处理 `包含` 和 `不包含` else 的选择语句时，采用了完全不同的内部处理机制。对于不包含 `else`
的 `if` 只需要实现下面的方法即可：

    public static func buildOptional(_ component: AttributedString?) -> AttributedString {
        component ?? .init("")
    }

构建器在调用该方法时，将视条件是否达成传入不同的参数。条件未达成时，传入 `nil` 。使用方法为：

    var show = true
    @AttributedStringBuilder
    var myFirstText: AttributedString {
        "Hello"
        if show {
            "World"
        }
    }

在添加了 `buildOptional` 的实现后，构建器也将同时支持 `if let` 语法，例如：

    var name:String? = "fat"
    @AttributedStringBuilder
    var myFirstText: AttributedString {
        "Hello"
        if let name = name {
            " \(name)"
        }
    }

`buildOptional` 对应的转译代码为：

    // 上面的 if 代码对应的逻辑
    var myFirstText: AttributedString {
        let _a = AttributedStringBuilder.buildExpression("Hello")
        var vCase0: AttributedString?
        if show == true {
            vCase0 = AttributedStringBuilder.buildExpression("World")
        }
        let _b = AttributedStringBuilder.buildOptional(vCase0)
        return AttributedStringBuilder.buildBlock(_a, _b)
    }

    // 上面的 if let 代码对应的逻辑
    var myFirstText: AttributedString {
        let _a = AttributedStringBuilder.buildExpression("Hello")
        var vCase0:AttributedString?
        if let name = name {
            vCase0 = AttributedStringBuilder.buildExpression(name)
        }
        let _b = AttributedStringBuilder.buildOptional(vCase0)
        return AttributedStringBuilder.buildBlock(_a,_b)
    }

这就是为什么只需要实现 `buildOptional` 即可同时支持 `if` ( 不包含 `else` ) 和 `if let` 的原因。

### 添加对多分支选择的支持

对于 `if else` 以及 `switch` 语法，则需要实现 `buildEither(first:)` 和 `buildEither(second:)` 两个方法:

    // 对条件为真的分支调用 （左侧分支）
    public static func buildEither(first component: AttributedString) -> AttributedString {
        component
    }

    // 对条件为否的分支调用 （右侧分支）
    public static func buildEither(second component: AttributedString) -> AttributedString {
        component
    }

使用方法如下：

    var show = true
    @AttributedStringBuilder
    var myFirstText: AttributedString {
        if show {
            "Hello"
        } else {
            "World"
        }
    }

对应的转译代码为：

    var myFirstText: AttributedString {
        let vMerged: AttributedString
        if show {
            vMerged = AttributedStringBuilder.buildEither(first: AttributedStringBuilder.buildExpression("Hello"))
        } else {
            vMerged = AttributedStringBuilder.buildEither(second: AttributedStringBuilder.buildExpression("World"))
        }
        return AttributedStringBuilder.buildBlock(vMerged)
    }

在包含 `else` 语句时，构建器在转译时将产生一个二叉树，每个结果都被分配到其中的一个叶子上。对于在 `if else` 中出现的不使用 `else` 的分支部分，构建器仍将通过 `buildOptional` 来处理，例如：

    var show = true
    var name = "fatbobman"
    @AttributedStringBuilder
    var myFirstText: Text {
        if show {
            "Hello"
        } else if name.count > 5 {
            name
        }
    }

转译后的代码为：

    // 转译后的代码
    var myFirstText: AttributedString {
        let vMerged: AttributedString
        if show {
            vMerged = AttributedStringBuilder.buildEither(first: AttributedStringBuilder.buildExpression("Hello"))
        } else {
            // 首先使用 buildOptional 处理不包含 else 的情况
            var vCase0: AttributedString?
            if name.count > 5 {
                vCase0 = AttributedStringBuilder.buildExpression(name)
            }
            let _a = AttributedStringBuilder.buildOptional(vCase0)
            // 右侧分支最终汇总到 vMerged 上
            vMerged = AttributedStringBuilder.buildEither(second: _a)
        }
        return AttributedStringBuilder.buildBlock(vMerged)
    }

对于 `switch` 的支持也是采用同样的方式。构建器在转译时，将递归地应用上述规则。

> 或许大家会奇怪， `buildEither` 的实现如此简单，并没有太大的意义。在 result builders
> 提案过程中也有不少人有这个疑问。其实 Swift 的这种设计有其相当合适的应用领域。在下一篇【 复制 ViewBuilder 】中，我们将看到
> ViewBuilder 是如何通过 `buildEither` 来保存所有分支的类型信息。

### 支持 for… in 循环

`for...in` 语句将所有迭代的结果一并收集到一个数组中，并传递给 `buildArray` 。提供 `buildArray`
的实现即可让构建器支持循环语句。

    // 本例中，我们将所有的迭代结果直接连接起来，生成一个 AttributedString
    public static func buildArray(_ components: [AttributedString]) -> AttributedString {
        components.reduce(into: AttributedString("")) { result, next in
            result.append(next)
        }
    }

使用方式：

    @AttributedStringBuilder
    func test(count: Int) -> Text {
        for i in 0..<count {
            " \(i) "
        }
    }

对应的转译代码：

    func test(count: Int) -> AttributedString {
        var vArray = [AttributedString]()
        for i in 0..<count {
            vArray.append(AttributedStringBuilder.buildExpression(" \(i)"))
        }
        let _a = AttributedStringBuilder.buildArray(vArray)
        return AttributedStringBuilder.buildBlock(_a)
    }

### 提高版本兼容性

如果提供了 `buildLimitedAvailability` 的实现，构建器提供了对 API 可用性检查（如 `if #available(..)` ）的支持。这种情况在 SwiftUI 中很常见，例如某些 View 或 modifier 仅支持较新的平台，我们需要为不支持的平台提供其他的内容。

    public static func buildLimitedAvailability(_ component: AttributedString) -> AttributedString {
        component
    }

该方法并不会独立存在，它会和 `buildOptional` 或 `buildEither` 一并使用。当 API 可用性检查满足条件后，
result builders 会调用该实现。在 SwiftUI 中，为了固定类型，使用了 AnyView 对类型进行了抹除。

使用方法：

    // 创建一个当前平台不支持的方法
    @available(macOS 13.0, iOS 16.0,*)
    public extension AttributedString {
        func futureMethod() -> AttributedString {
            self
        }
    }

    @AttributedStringBuilder
    var text: AttributedString {
        if #available(macOS 13.0, iOS 16.0, *) {
            AttributedString("Hello macOS 13")
                .futureMethod()
        } else {
            AttributedString("Hi Monterey")
        }
    }

对应的转译逻辑为：

    var text: AttributedString {
        let vMerge: AttributedString
        if #available(macOS 13.0, iOS 16.0, *) {
            let _temp = AttributedStringBuilder
                .buildLimitedAvailability( // 对类型或方法进行抹除
                    AttributedStringBuilder.buildExpression(AttributedString("Hello macOS 13").futureMethod())
                )
            vMerge = AttributedStringBuilder.buildEither(first: _temp)
        } else {
            let _temp = AttributedStringBuilder.buildExpression(AttributedString("Hi Monterey"))
            vMerge = AttributedStringBuilder.buildEither(second: _temp)
        }
        return = AttributedStringBuilder.buildBlock(vMerge)
    }

### 对结果再包装

如果我们提供了 `buildFinalResult` 的实现，构建器将在转译的最后，对结果使用 `buildFinalResult` 再度转换，并以
`buildFinalResult` 的返回值为最终的结果。

绝大多数情况下，我们无需实现 `buildFinalResult` ，构建器会将 `buildBlock` 的返回作为最终的结果。

    public static func buildFinalResult(_ component: AttributedString) -> Text {
        Text(component)
    }

为了演示，本例中我们将 AttributedString 通过 `buildFinalResult` 转换为 Text ，使用方法：

    @AttributedStringBuilder
    var text: Text {  // 最终的结果类型已转译为 Text
        "Hello world"
    }

对应的转译逻辑：

    var text: Text {
        let _a = AttributedStringBuilder.buildExpression("Hello world")
        let _blockResult = AttributedStringBuilder.buildBlock(_a)
        return AttributedStringBuilder.buildFinalResult(_blockResult)
    }

至此，我们已经实现了本节开始设定的目标。不过当前的实现仍无法为我们提供创建例如 SwiftUI 各种容器的可能性，这个问题将在范例二中得以解决。

## 范例二：AttributedTextBuilder

> 范例二的完整代码可以在 [ 此处
> ](https://github.com/fatbobman/BlogCodes/tree/main/AttributedStringBuilder/AttributedStringBuilderDemo.playground)
> 获取（ Demo 2 ）

### 版本一的不足

- 只能对 component（AttributedString、String）逐个添加 modifier，无法统一配置
- 无法动态布局， `buildBlock` 将所有的内容连接起来，想换行也只能通过单独添加 `\n` 来实现

### 使用协议代替类型

上述问题产生的主要原因为：上面的 `buildBlock` 的 component 是特定的 AttributedString
类型，限制了我们创建容器（其他的 component ）的能力。可以参照 SwiftUI View 的方案来解决上述不足，使用协议取代特定的类型，同时让
AttributedString 也符合该协议。

首先，我们将创建一个新的协议 —— AttributedText ：

    public protocol AttributedText {
        var content: AttributedString { get }
        init(_ attributed: AttributedString)
    }

    extension AttributedString: AttributedText {
        public var content: AttributedString {
            self
        }

        public init(_ attributed: AttributedString) {
            self = attributed
        }
    }

让 AttributedString 符合该协议：

    extension AttributedString: AttributedText {
        public var content: AttributedString {
            self
        }

        public init(_ attributed: AttributedString) {
            self = attributed
        }
    }

创建一个新的构建器 —— AttributedTextBuilder，它的最大变化就是将所有 component 的类型都改成了
AttributedText 。

    @resultBuilder
    public enum AttributedTextBuilder {
        public static func buildBlock() -> AttributedString {
            AttributedString("")
        }

        public static func buildBlock(_ components: AttributedText...) -> AttributedString {
            let result = components.map { $0.content }.reduce(into: AttributedString("")) { result, next in
                result.append(next)
            }
            return result.content
        }

        public static func buildExpression(_ attributedString: AttributedText) -> AttributedString {
            attributedString.content
        }

        public static func buildExpression(_ string: String) -> AttributedString {
            AttributedString(string)
        }

        public static func buildOptional(_ component: AttributedText?) -> AttributedString {
            component?.content ?? .init("")
        }

        public static func buildEither(first component: AttributedText) -> AttributedString {
            component.content
        }

        public static func buildEither(second component: AttributedText) -> AttributedString {
            component.content
        }

        public static func buildArray(_ components: [AttributedText]) -> AttributedString {
            let result = components.map { $0.content }.reduce(into: AttributedString("")) { result, next in
                result.append(next)
            }
            return result.content
        }

        public static func buildLimitedAvailability(_ component: AttributedText) -> AttributedString {
            .init("")
        }
    }

为 AttributedText 创建 modifier ：

    public extension AttributedText {
        func transform(_ perform: (inout AttributedString) -> Void) -> Self {
            var attributedString = self.content
            perform(&attributedString)
            return Self(attributedString)
        }

        func color(_ color: Color) -> AttributedText {
            transform {
                $0 = $0.color(color)
            }
        }

        func bold() -> AttributedText {
            transform {
                $0 = $0.bold()
            }
        }

        func italic() -> AttributedText {
            transform {
                $0 = $0.italic()
            }
        }
    }

至此我们便拥有了类似在 SwiftUI 中创建自定义视图控件的能力。

### 创建 Container

Container 类似 SwiftUI 中的 Group ，不改变布局，方便对 Container 内的元素统一设置 modifier。

    public struct Container: AttributedText {
        public var content: AttributedString

        public init(_ attributed: AttributedString) {
            content = attributed
        }

        public init(@AttributedTextBuilder _ attributedText: () -> AttributedText) {
            self.content = attributedText().content
        }
    }

由于 Container 也符合 AttributedText 协议，因此将被视为 component，并且可以对其应用 modifier 。使用方法：

    @AttributedTextBuilder
    var attributedText: AttributedText {
        Container {
            "Hello "
                .localized()
                .color(.red)
                .bold()

            "~World~"
                .localized()
        }
        .color(.green)
        .italic()
    }

此时执行上面的代码，你会发现，原来红色的 Hello 也变成了绿色的，这与我们预期的不一样。在 SwiftUI
中，内层的设定应优先于外层的设定。为了解决这个问题，我们需要对 AttributedString 的 modifier 做一些修改。

    public extension AttributedString {
        func color(_ color: Color) -> AttributedString {
            var container = AttributeContainer()
            container.foregroundColor = color
            return then {
                for run in $0.runs {
                    $0[run.range].mergeAttributes(container, mergePolicy: .keepCurrent)
                }
            }
        }

        func bold() -> AttributedString {
            return then {
                for run in $0.runs {
                    if var inlinePresentationIntent = run.inlinePresentationIntent {
                        var container = AttributeContainer()
                        inlinePresentationIntent.insert(.stronglyEmphasized)
                        container.inlinePresentationIntent = inlinePresentationIntent
                        let _ = $0[run.range].mergeAttributes(container)
                    } else {
                        $0[run.range].inlinePresentationIntent = .stronglyEmphasized
                    }
                }
            }
        }

        func italic() -> AttributedString {
            return then {
                for run in $0.runs {
                    if var inlinePresentationIntent = run.inlinePresentationIntent {
                        var container = AttributeContainer()
                        inlinePresentationIntent.insert(.emphasized)
                        container.inlinePresentationIntent = inlinePresentationIntent
                        let _ = $0[run.range].mergeAttributes(container)
                    } else {
                        $0[run.range].inlinePresentationIntent = .emphasized
                    }
                }
            }
        }

        func then(_ perform: (inout Self) -> Void) -> Self {
            var result = self
            perform(&result)
            return result
        }
    }

通过遍历 AttributedString 的 run 视图，我们实现了同一属性的内层设定优先于外层设定。

### 创建 Paragraph

Paragraph 会在其中内容的首尾创建换行。

    public struct Paragraph: AttributedText {
        public var content: AttributedString
        public init(_ attributed: AttributedString) {
            content = attributed
        }

        public init(@AttributedTextBuilder _ attributedText: () -> AttributedText) {
            self.content = "\n" + attributedText().content + "\n"
        }
    }

通过将协议作为 component ，为构建器提供了更多的可能性。

## Result builders 的改进与不足

### 已完成的改进

从 Swift 5.1 开始，result builders 已经过几个版本的改进，增加了部分功能同时也解决了部分的性能问题：

- 添加了 `buildOptional` 并取消了 `buildeIf` ，在保留了对 `if` （不包含 `else` ）支持的同时，增加了对 `if let` 的支持
- 从 SwiftUI 2.0 版本开始支持了 `switch` 关键字
- 修改了 Swift 5.1 版本的 `buildBlock` 的语法转译机制。禁止了参数类型的“向后”传播。这是导致早期 SwiftUI 视图代码总出现“ expression too complex to be solved in a reasonable time ” 编译错误的首要原因

### 当前的不足

- 欠缺部分选择和控制能力，如： guard 、break 、continue

- 缺乏将命名限制在构建器上下文内能力

对于 DSL 来说，引入速记词是很常见的情况，当前为构建器创建 component
，只能采用创建新的数据类型（例如上文中的：Container、Paragraph
）或全局函数的形式。希望将来可以让这些命名仅限制在上下文之内，不将其引入全局范围。

## 后续

Result builders 的基本功能非常简单，上文中，我们仅有少量的代码是有关构建器方法的。但想创建一个好用、易用的 DSL
则需要付出巨大的工作量，开发者应根据自己的实际需求来衡量使用 result builders 的得失。

在下篇中，我们将尝试复制一个与 ViewBuilder 基本形态一致的构建器，相信复制的过程能让你对 ViewBuilder 以及 SwiftUI
视图有更深的理解和认识。

# SwiftUI 2.0 —— App、Scene、新的代码结构（一）

> 本文简单介绍了 SwiftUI 2.0 中全新提供的 App 协议、Scene 协议，浅谈了在全新的代码结构下如何组织 Data Flow，并提供了
> SwiftUI 2.0 中预置的 Scene 的一些使用示例。
>
> 当前运行环境为 Xcode Version 12.0 beta (12 A 6159), macOS Big Sur 11.0 Beta 版 (20 A
> 4299 v)。

WWDC 20 中，苹果为开发者带来了基于 SwiftUI 的全新项目模板。使用该模板，将使项目代码变得异常简洁、清晰。

    @main
    struct NewAllApp: App {
        var body: some Scene {
            WindowGroup {
                Text("Hello world")
            }
        }
    }

上述代码可以在屏幕上完成 Hello world 的显示，且能够运行于 iOS 和 macOS 平台下。

## 基本概念

### App

SwiftUI 2.0 提供的全新协议。通过声明一个符合 App 协议的结构来创建一个程序，并通过计算属性 body 来实现程序的内容。

- 通过@main ( Swift 5.3 新特性）设定程序的入口，每个项目只能有一个进入点

- 管理整个 App 的生命周期

- 在这个作用域下声明的常量、变量其生命周期与整个 App 是完全一致的。

### Scene

场景是视图（View）层次结构的容器。通过在 App 实例的 body 中组合一个或多个符合 Scene 协议的实例来呈现具体程序。

- 生命周期由系统管理
- 系统会根据运行平台的不同而调整场景的展示行为（比如相同的代码在 iOS 和 macOS 下的呈现不同，或者某些场景仅能运行于特定的平台）
- SwiftUI 2.0 提供了几个预置的场景，用户也可以自己编写符合 Scene 协议的场景。上述代码中便是使用的一个预置场景 WindowGroup

通过 App 和 Scene
的加入，绝不是仅仅减少代码量这么简单。通过这个明确的层级设定，我们可以更好的掌握在不同作用域下各个部分的生命周期、更精准数据传递、以及更便利的多平台代码共享。本文后面会用具体代码来逐个阐述。

_App 和 Scene 都是通过各自的 functionBuilder 来解析的，也就是说，新的模板从程序的入口开始便是使用 DSL 来描述的。_

## 程序系统事件响应

由于去除了 AppDelegate. swift 和 SceneDelegate. swift，SwiftUI 2.0 提供了新的方法来让程序响应系统事件。

### 针对 AppDelegate. swift

在 iOS 系统下，通过使用@UIApplicationDelegateAdaptor 可以方便的实现之前 AppDelegate. swfit
中提供的功能：

    @main
    struct NewAllApp: App {
       @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
        var body: some Scene {
            WindowGroup {
                Text("Hello world")
            }
        }
    }

    class AppDelegate:NSObject,UIApplicationDelegate{
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
            print("launch")
            return true
        }
    }

由于目前还是测试版，虽然很多的事件已经定义，但现在并没有响应。估计很快会增加修改过来

### 针对 SceneDelegate. swift

通过新增添的 EnvironmentKey `scenePhase` 和新的 `onChange` 方法，SwiftUI
提供了一个更加有趣的场景事件解决方案：

    @main
    struct NewAllApp: App {
        @Environment(\.scenePhase) var phase
        var body: some Scene {
            WindowGroup {
               ContentView()
            }
            .onChange(of: phase){phase in
                    switch phase{
                    case .active:
                        print("active")
                    case .inactive:
                        print("inactive")
                    case .background:
                        print("background")
                    @unknown default:
                        print("for future")
                    }

              }
        }
    }

同样是由于测试版的原因，该响应目前并没有完成。不过这段代码目前来看是 iOS 和 macOS 都通用的

### 更新

目前发现如果在 View 中，可以获取 scenePhase 的状态更新。下来代码目前可以正常执行

    struct ContentView:View{
      @Environment(\.scenePhase) private var scenePhase
     var body: some Scene {
      WindowGroup {
       ContentView()
      }
      .onChange(of: phase){phase in
                    switch phase{
                    case .active:
                        print("active")
                    case .inactive:
                        print("inactive")
                    case .background:
                        print("background")
                    @unknown default:
                        print("for future")
                    }
             }
       }
    }

## 预置场景

- **WKNotificationScene** 仅适用于 watchOS 7.0，用于响应指定类别的远程或本地通知。目前还没有研究。

- **WindowGroup**

最常用的场景，可以呈现一组结构相同的窗口。使用该场景，我们无需在代码上做修改，只需要在项目中设定是否支持多窗口，系统将会按照运行平台的特性自动管理。

在 iOS 中，只能呈现一个运行窗口。

在 PadOS 中（如打开多窗口支持），最多可以打开两个运行窗口，可以分屏显示，也可以全屏独立显示。

在 macOS 中，可以打开多个窗口，并通过程序菜单中的窗口菜单来进行多窗口管理。

最开始的代码在三个平台下的状态：

![windowGroup](https://cdn.fatbobman.com/swiftui2-new-
feature-1-windowGroup.png) 如果在一个 WindowGroup 里加入多个 View, 呈现状态有点类似 VStack。

在一个 Scene 中加入多个 WindowGroup，只有最前面的可以被显示。

- **DocumentGroup**

创建一个可处理指定文件类型的窗口。在 iOS 和 PadOS 下都首先会呈现文件管理器，点击文件，进入对应的 View 来处理。macOS
下，通过菜单中的文件操作来选择或创建文件。

通过创建一个符合 FileDocument 的结构来定义支持哪种格式，以及打开和保存的工作。

      //纯文本格式文件。write 的方法用于描述如何写入文件，如果不需写入可为空。
      struct TextFile: FileDocument {
          static var readableContentTypes = [UTType.plainText]
          var text = ""
          init(initialText: String = "") {
              text = initialText
          }
          init(fileWrapper: FileWrapper, contentType: UTType) throws {
              if let data = fileWrapper.regularFileContents {
                  text = String(decoding: data, as: UTF8.self)
              }
          }
          func write(to fileWrapper: inout FileWrapper, contentType: UTType) throws {
              let data = Data(text.utf8)
              let file = FileWrapper(regularFileWithContents: data)
              fileWrapper = file
          }
      }
      //图片文件，由于需要转换成 UIImage，该代码只支持 iOS 或 PadOS
      #if os(iOS)
      struct ImageFile: FileDocument {
          static var readableContentTypes = [UTType.image]
          var image = UIImage()
          init(initialImage: UIImage = UIImage()) {
              image = initialImage
          }

          init(fileWrapper: FileWrapper, contentType: UTType) throws {
              if let data = fileWrapper.regularFileContents {
                  image =   UIImage(data: data) ?? UIImage()
              }
          }

          func write(to fileWrapper: inout FileWrapper, contentType: UTType) throws { }
      }
      #endif

调用

      import SwiftUI
      #if os(iOS)
      import UIKit
      #endif
      import UniformTypeIdentifiers

      @main
      struct NewAllApp: App {
         @SceneBuilder var body: some Scene {
              //可读写
              DocumentGroup(newDocument: TextFile()) { file in
                      TextEditorView(document: file.$document)
              }

              #if os(iOS)
              //只读
              DocumentGroup(viewing: ImageFile.self) { file in
                      ImageViewerView(file: file.$document)
                }
              #endif
          }
      }

      struct TextEditorView: View {
          @Binding var document: TextFile
          @State var name = ""
          var body: some View {
              VStack{
              TextEditor(text: $document.text)
                  .padding()
              }
              .background(Color.gray)
          }
      }

      #if os(iOS)
      struct ImageViewerView:View{
          @Binding var document:ImageFile
          var body: some View{
              Image(uiImage: document.image)
                  .resizable(resizingMode: .stretch)
                  .aspectRatio(contentMode: .fit)
          }
      }
      #endif

![DocumentGroup](https://cdn.fatbobman.com/swiftui2-new-
feature-1-documentGroup.png) 可以将多个 DocumentGroup 放入 Scene 中，程序将会一并支持每个
DocumentGroup 所定义的文件类型。上述代码使程序可以创建、编辑纯文本文件，并且可以浏览图片文件。

在 macOS 上，需要在 macOS. entitlements 中设置 com. apple. security. files. user-
selected. read-write 为真才能完成写入。

当在 Scene 中加入多个场景时，需要使用@SceneBuilder 或用 Group 将多个场景涵盖起来。

macOS 下当同时加入 WindowGroup 和 DocumentGroup 时，两个功能都可以正常运行。iOS 或 PadOS
下，只有顺序在最前面的被显示。

由于测试版的原因，目前仍有大量的功能无法实现或有问题。比如仍无法在 iOS 上通过 fileDocument 提供的 filename
来设置文件名，或者无法在创建新文件时选择格式等

- **Settings**

只用于 macOS, 用于编写程序的偏好设置窗口。

      #if os(macOS)
          Settings{
            Text("偏好设置").padding(.all, 50)
          }
      #endif

![Settings](https://cdn.fatbobman.com/swiftui2-new-feature-1-settings.jpg)

## 其他

- **onChange** 监视指定的值，在值改变时执行指定的 action。在 scenePhase 的用法介绍中有使用的范例

- **onCommands** 在 macOS 下设置程序的菜单。具体的使用方法请查看 [ SwiftUI2.0 —— Commands（macOS 菜单） ](/zh/posts/swiftui2-commands/)

- **defaultAppStorage** 如果不想使用系统缺省 UserDefault. standard，可以自行设置存储位置，使用的几率不高。

## 小结

至此，本文简单介绍了 SwiftUI 2.0 新增的 App 和 Scene，下篇文章我们将探讨在新的层次结构下如何组织我们代码的 Data Flow。

当前的 @AppBuilder 和 @SceneBuilder
的功能都十分的基础，不包含任何的逻辑判断功能，因此目前我还没有办法实现根据条件来选择性的展示所需的 Scene。相信苹果应该会在未来增加这样的能力

_本文的代码为了能够在多平台使用，所以增加了不少编译判断，如果你只是在 iOS, 或 macOS 下开发 SwiftUI，则可根据各自平台简化代码。另外
Xcode 12 中的代码补全对于 Target 的设定很敏感，如果你发现无法对某些平台的特定语句进行补全，请查看是否将 Scheme 设置到对应的平台。_

# 我在北京参加 SwiftUI 技术沙龙

4 月 18 日和 20 日，苹果分别在上海和北京举办了两场“SwiftUI
技术沙龙”活动。由于近几年类似的线下活动举办得极少（疫情原因），因此报名的开发者众多，早早地将参会名额预定一空。

我很荣幸能够作为分享嘉宾参加了北京的活动。在这次交流中，我学习了不少新知识，与很多之前只在网上沟通的朋友见了面，并结交了不少新朋友。

最近一两年，苹果上海加速器举办的线上交流有相当部分的主题都与 SwiftUI 有关。我相信，无论是苹果官方还是广大开发者都希望能够拥有一个更加活跃的
SwiftUI 开发者社区。

为此，苹果方面的组织者在活动举办的两个月前便与参会嘉宾对分享的方向、内容、形式、节奏等进行了协商和演练。所有的参与者都希望通过本次技术沙龙为沉寂已久的线下交流注入新的活力，并尽早地让
SwiftUI 开发者社区活跃起来。

北京的活动共有四名分享嘉宾，他们从不同的角度与其他开发者分享了各自对 SwiftUI 的应用心得。

- 戴铭 —— 使用 SwiftUI 开发一个 RSS 阅读器

戴老师从框架选择、实现难点、技术细节、开发体会等方面和大家分享了使用 SwiftUI + Core Data 开发 RSS
阅读器的过程。秉持一贯的风格，手绘二次元图片贯穿于整个课件中，为技术交流带来了青春与可爱的氛围。可在 [ 此处
](https://ming1016.github.io/2023/04/24/swiftui-rss-reader/) 阅读戴老师自己的交流总结。

- 胡思华 —— SwiftUI 自定义布局技术实践

思华是抖音基础技术团队的成员，他给大家分享的内容是 SwiftUI 4.0 的 Layout 协议详解以及实际用例。如果大家关注过去年的 D2
大会，字节在其中介绍了开发中的 DanceUI 框架。作为一个 iOS 平台下与 SwiftUI 高度兼容的声明式框架，旨在解决当前 SwiftUI
对平台的最低版本要求过高的问题。该框架有相当的可能会在今年开源，届时或许能为不少企业开发者提供另一个使用 Swift
语言进行声明式开发的契机，待条件成熟时，再完全并入到 SwiftUI 中。作为 DanceUI 框架开发团队的一员，思华对 SwiftUI
底层的一些机制了解得很透彻，在交流中让我获益匪浅。

- 东坡肘子 —— 打造可适配多平台的 SwiftUI 应用

我通过了一个 Demo 应用（ [ 电影猎手 ](https://github.com/fatbobman/MovieHunter) ）探讨了使用
SwiftUI 创建多平台应用时应注意的问题。着重讨论了两个我认为比较重要但又容易忽视的点：兼容性和数据源。可在 [ 此处
](/zh/posts/building-multiple-platforms-swiftui-app/) 阅读我在本次技术沙龙的交流全内容。

- 吴卓强（ Harry ）—— SwiftUI 与 UIKit 的互通技巧

从台中远道赶来的 [ Harry ](https://twitter.com/harryworld) 是日程应用 [ Sorted
](https://www.sortedapp.com/) 的主要开发者之一。作为一个在全球拥有众多用户的知名应用，Sorted 打算基于 SwiftUI
来构建新的版本。在实践中，通过融入基于 UIKit 的解决方案来突破当前 SwiftUI
在文本录入以及复杂交互等方面的功能限制，并取得了不错的成效。在交流中，Harry
也就某些具体问题给出了思路和体会。遗憾的是，由于与会开发者参与热情很高，导致了前面的进程有些拖延，最后留给 Harry 兄的时间有限。

原计划于 17:30 结束的交流活动直到 19:00
仍有参加者未离去。与会者的热情出乎不少人的意料，大家都希望今后能有更多类似的活动，逐步扩大规模，让更多的开发者有机会参与。

随着生活秩序回归正轨，今年已有不少苹果生态的开发社区正在准备各种线下活动，例如不久后的 SwiftGG 举办的一起看 WWDC、台湾开发者社群将在 11
月上旬举办的 iPlayground 2023 等。

希望大家能够共同创建一个富有生机的开发者社区，享受交流的乐趣，共同成长。

# 探讨 SwiftUI 中的关键属性包装器：@State、@Binding、@StateObject、@ObservedObject、@EnvironmentObject 和 @Environment

在这篇文章中，我们将探讨几个在 SwiftUI
开发中经常使用且至关重要的属性包装器。本文旨在提供对这些属性包装器的主要功能和使用注意事项的概述，而非详尽的使用指南。

> 本文应几位朋友之邀而写，旨在帮助已经熟悉通用编程但对 SwiftUI 相对陌生的开发者，快速理解这些属性包装器的核心作用和适用场景。

- [ @AppStorage、@SceneStorage、@FocusState、@GestureState、@ScaledMetric ](/zh/posts/exploring-swiftui-property-wrappers-2/)
- [ @FetchRequest、@SectionedFetchRequest、@Query、@Namespace、@Bindable ](/zh/posts/exploring-swiftui-property-wrappers-3/)
- [ @UIApplicationDelegateAdaptor, @AccessibilityFocusState, @FocusedObject, @FocusedValue, @FocusedBinding ](/zh/posts/exploring-swiftui-property-wrappers-4/)

## 1 @State

`@State` 是 SwiftUI
中最常用的属性包装器之一，主要用于在视图内部管理私有数据。它特别适合存储值类型数据，如字符串、整数、枚举或结构体实例。

- `@State` 用于管理视图的私有状态。
- 它主要用于存储值类型数据（与视图的生命周期一致）。

### 1.1 典型应用场景

- 当需要因视图内的数据变化而触发视图更新时， `@State` 是理想的选择。
- 它常用于简单的 UI 组件状态管理，如开关状态、文本输入等。
- 如果数据不需要复杂的跨视图共享，使用 `@State` 可以简化状态管理。

### 1.2 注意事项

- 尽量仅在视图的内部使用 `@State` ，即使未显式标记为 `private` ，也应当将其视为视图的私有属性。

- `@State` 为包装数据同时提供了双向数据绑定管道，可以通过 `$` 前缀来访问。

- `@State` 不适合用于存储大量数据或复杂数据模型，这种情况下更适合使用 `@StateObject` 或其他状态管理方案。

- 属性包装器本质上是一个结构体。使用 `@` 前缀时，它用于包装其他数据；而不带 `@` 时，表示其自身类型。更多细节参考 [ John Sundell ](https://www.swiftbysundell.com/articles/property-wrappers-in-swift/) 和 [ Antoine van der Lee ](https://www.avanderlee.com/swift/property-wrappers/) ，或阅读 [ @State 研究 ](/zh/posts/swiftui-state/) 。

- 在构造方法中赋值时，需通过 `_` 下划线访问 `@State` 的原始值并进行赋值。

  @State var name: String
  init(text: String) {
  // 给下划线版本赋值，需要用 State 类型本身进行包装
  \_name = State(wrappedValue: text)
  }

- `@State` 变量在视图的构造函数中只能赋值一次，后续的调整需要在视图的 `body` 内进行。详见 [ 避免 SwiftUI 视图的重复计算 ](/zh/posts/avoid_repeated_calculations_of_swiftui_views/) 。

- 如果不需要在当前视图或在子视图中（通过 `@Binding` ）修改值，无需使用 `@State` 。

- 在某些情况下， `@State` 也被用来存储非值类型数据，比如引用类型以保证其唯一性和生命周期。

  @State var textField: UITextField?
  TextField("", text: $text)
  .introspect(.textField, on: .iOS(.v17)) {
  // 持有 UITextField 实例
  self.textField = $0
  }

- `@State` 在 Observation 框架中用于确保 `@Observable` 实例的生命周期不短于视图本身。详细信息见 [ 深度解读 Observation ](/zh/posts/mastering-observation/) 。
- `@State` 是线程的安全，可以在非主线程中进行修改。

  @State var text: String = ""
  Button("Change") {
  // 无需切换回主线程
  Task.detached {
  text = "hi"
  }
  }

## 2 @Binding

`@Binding` 是 SwiftUI 中用于实现双向数据绑定的属性包装器。它创建了值（如 Bool）与显示及修改这些值的 UI 元素之间的双向连接。

- `@Binding` 不直接持有数据，而是提供了对其他数据源的读写访问的包装。
- 它允许 UI 元素直接修改数据，并反映这些数据的变化。

### 2.1 典型应用场景

- `@Binding` 主要用于与支持双向数据绑定的 UI 组件，如和 `TextField` 、 `Stepper` 、 `Sheet` 和 `Slider` 等配合使用。
- 它适用于需要在子视图中直接修改父视图中的数据情况。

### 2.2 注意事项

- 应当谨慎使用 `@Binding` ，当子视图只需响应数据变化而无需修改时，无需使用 `@Binding` 。

- 在复杂的视图层级中，逐级传递 @Binding 可能导致数据流难以追踪，此时应考虑使用其他状态管理方法。

- 确保 `@Binding` 的数据源是可信的，错误的数据源可能导致数据不一致或应用崩溃。由于 `@Binding` 只是一个管道，它并不保证对应的数据源在调用时必然存在。

- 开发者可以通过提供 `get` 和 `set` 的方式来自定义 Binding。

  let binding = Binding<String>(
  get: { text },
  // 限制字符串的长度
  set: { text = String($0.prefix(10)) }
  )

- 通过为 `Binding` 类型创建扩展，可以极大地提高开发的效率和灵活性。相关内容请阅读： [ SwiftUI Binding Extensions ](https://betterprogramming.pub/swiftui-binding-extensions-b6a9f27d2858) 。

  // 将一个 Binding<V?> 转换为 Binding<Bool>
  extension Binding {
  static func isPresented<V>(\_ value: Binding<V?>) -> Binding<Bool> {
  Binding<Bool>(
  get: { value.wrappedValue != nil },
  set: {
  if !$0 { value.wrappedValue = nil }
  }
  )
  }
  }

- 在 Observation 框架中，可以使用 `@Bindable` 为 `@Observable` 实例创建对应的 `Binding` 接口，详细信息见 [ 深度解读 Observation ](/zh/posts/mastering-observation/) 。。

- 在声明构造参数时，需要明确指定 `Binding` 的包装值类型（ `get` 方法的返回值类型），如 `Binding<String>` 。

- `@Binding` 并不是独立的数据源。实际上，它只是对已存在数据的引用。只有能够引发视图更新的值被 `get` 方法读取时，才会触发视图更新（ 比如 @State、@StateObject ），这点对于自定义 `Binding` 尤为重要。

  struct Test: View {
  let a = A()
  var body: some View {
  let binding = Binding<String>(
  get: { a.name },
  set: { a.name = $0 }
  )
  // 尽管 A 符合 ObservableObject 协议，但是由于没有使用 StateObject 与视图关联，因此为其属性创建的 Binding 也同样不会引发视图更新
  Text(binding.wrappedValue)
  TextField("input:", text: binding)
  }

      class A: ObservableObject {
          @Published var name: String = ""
      }

  }

## 3 @StateObject

`@StateObject` 是 SwiftUI 中用于管理符合 ObservableObject
协议的对象实例的属性包装器，以确保这些实例的生命周期与当前视图一致（ 不短于）。

- `@StateObject` 专门用于管理符合 ObservableObject 协议的实例。
- 标注的对象实例在视图的整个生命周期中保持唯一，即使视图更新，对象实例也不会重新创建。

### 3.1 典型应用场景

- `@StateObject` 通常在视图树中最顶层使用，用于创建和维护 ObservableObject 实例。
- 常用于需要在视图的整个生命周期中持续存在的数据模型或业务逻辑。
- 相较 `@State` 而言， `@StateObject` 更适合管理复杂的数据模型及其执行逻辑

### 3.2 注意事项

- `@StateObject` 触发视图更新的条件包括使用 `@Published` 标注的属性被赋值（ 无论新旧值是否一致 ）和调用 `objectWillChange` 发布者。

- 只在必须响应实例属性变化的视图中使用 `@StateObject` ，如果仅需读取数据而不需要观察变化，可考虑其他选项。

- 引入 `@StateObject` 意味着所有相关操作都在主线程上进行（ SwiftUI 会隐式为视图添加 `@MainActor` ），包括异步操作。应将需要在非主线程上运行的代码应该从视图代码中剥离。

  struct B:View {
  // 使用 StateObject 后，相当于为当前的视图添加了 @MainActor
  @StateObject var store = Store()
  var body: some View {
  Button("Main Thread"){
  Task.detached{
  await printThradName()
  // output <\_NSMainThread: 0x60000170c000>{number = 1, name = main}
  }
  }
  }

      func printThradName() async {
          print(Thread.current)
      }

  }

- 如果在视图存续期有保障的地方创建实例（ 比如说 App 层级），且在当前层级也无需响应该实例中属性的变化，可以不使用 `@StateObject`

  struct DemoApp: App {
  // 因为当前层级的视图的存续期与应用一致，如果当前层级无需响应 store 变化，可以不用 StateObject
  let store = Store()

      var body: some Scene {
          WindowGroup {
              Test()
                  .environmentObject(store)
          }
      }

  }

## 4 @ObservedObject

`@ObservedObject` 是 SwiftUI 中用于为视图与 ObservableObject
实例之间创建关联的属性包装器，主要用于在视图存续期内引入外部的 ObservableObject 实例。

- `@ObservedObject` 不持有被观察的实例，不保证其生存期。
- `@ObservedObject` 可以在视图存续期内切换其所关联的实例。

### 4.1 典型应用场景

- 通常与 `@StateObject` 配合使用，父视图使用 `@StateObject` 创建实例，子视图通过 `@ObservedObject` 引入该实例，响应实例变化。

- 需要动态切换实例的场景。比如在 NavigationSplitView 中，sidebar 中选择不同的实例，detail 视图动态更换数据源。详情请阅读 [ StateObject 与 ObservedObject ](/zh/posts/stateobject_and_observedobject/) 。

  // 定义一个符合 ObservableObject 协议的数据模型
  class DataModel: ObservableObject, Identifiable {
  let id = UUID()
  }

  struct MyView: View {
  @State private var items = [DataModel(), DataModel()]

      var body: some View {
          VStack {
              // 切换 MySubView 关联的 DataModel 实例
              Button("Replace Model") {
                  items.reverse()
              }
              MySubView(model: items.first!)
          }
      }

  }

  // 子视图
  struct MySubView: View {
  // 使用 @ObservedObject 引入外部的 ObservableObject 实例
  @ObservedObject var model: DataModel

      var body: some View {
          VStack {
              // 显示当前 DataModel 实例的 UUID
              // 当 MyView 中的 'items' 数组改变时，这里显示的 UUID 会更新，展示了 @ObservedObject 的动态切换能力
              Text(model.id.uuidString)
          }
      }

  }

- 在视图中引入由外部框架或代码来保证存续期的 ObservableObject 实例时使用，例如引入 Core Data 的 NSManagedObject 实例。

### 4.2 注意事项

- 在 iOS 13 中，由于没有提供 `@StateObject` ，此时 `@ObservedObject` 是唯一选择，可能会因为无法保证实例的存续期而产生 [ 意想不到的结果 ](/zh/posts/stateobject/) ，为了避免类似问题，可以在更高层级的视图中（ 稳定性没有问题的地方 ），通过 `@State` 来持有该实例，然后在使用的视图中通过 `@ObservedObject` 来引入。
- 在引入第三方提供的符合 ObservableObject 实例时，应确保 `@ObservedObject` 引用的对象在整个视图的生命周期中都是可用的，否则可能导致运行时错误。

## 5 @EnvironmentObject

`@EnvironmentObject` 是用于在当前视图中与上层视图经环境传递的 ObservableObject
实例之间创建关联的属性包装器。它提供了一种便捷的方式在不同的视图层级中引入共享数据，而无需显式地通过每个视图的构造器传递。

### 5.1 典型应用场景

- 当需要在多个视图间共享同一个数据模型时，如用户设置、主题或应用状态。
- 适用于构建复杂的视图层级，其中多个视图需要访问同一个 ObservableObject 实例。

### 5.2 注意事项

- 使用 `@EnvironmentObject` 前，必须确保已在视图层级的上游提供了相应的实例（ 通过 `.environmentObject` 修饰器 ），否则将导致运行时错误。
- 它对视图的更新触发条件与 `@StateObject` 和 `@ObservedObject 一样` 。

- 与 `@ObservedObject` 一样， `@EnvriomentObject` 支持动态切换关联的实例。

  struct MyView: View {
  @State private var items = [DataModel(), DataModel()]
  var body: some View {
  VStack {
  Button("Replace Model") {
  // 切换子视图 MySubView 关联的实例
  items.reverse()
  }
  MySubView()
  .environmentObject(items.first!)
  }
  }
  }

  struct MySubView: View {
  @EnvironmentObject var model: DataModel // 动态切换关联的实例
  var body: some View {
  VStack {
  Text(model.id.uuidString)
  }
  }
  }

- 只在必要时引入 `@EnvironmentObject` ，否则会引发视图不必要的视图更新。通常情况下，会有多个视图从不同层级观察并响应同一个实例，必须合理优化才能避免应用性能劣化。这也是很多开发者不喜欢 `@EnviromentObject` 的原因。
- 在一个视图层次中，同一个类型的环境对象只有一个实例有效。

  @StateObject var a = DataModel()
  @StateObject var b = DataModel()

  MySubView()
  .environmentObject(a) // 靠近视图的有效
  .environmentObject(b)

## 6 @Environment

`@Environment` 是视图用于从环境中读取、响应、调用特定值的属性包装器。它允许视图访问由 SwiftUI 或应用环境提供的数据、实例或方法。

### 6.1 典型应用场景

- 当需要访问和响应如界面样式（暗模式/亮模式）、设备方向、字体大小等由系统或上层视图提供的环境值时（ 通常对应值类型）。
- 当需要访问和调用 SwiftData 的 ModelContext 时（对应引用类型）。
- 当需要使用系统提供的一些方法时，比如 `dismiss` 、 `openURL` （ 通过 struct 的 `callAsFunction` 封装的方法 ）。

### 6.2 注意事项

- 相较于由 `@EnvironmentObject` 提供的实例所应对的复杂逻辑， `@Environment` 引入的数据通常的功能更加的专一。
- 开发者可以通过自定义 `EnvironmentKey` 的方式来创建自定义环境值，与系统提供的环境值一样，可以定义各种类型（ 值类型、Binding、引用类型、方法的 ），详情请参阅 [ Custom SwiftUI Environment Values Cheatsheet ](https://www.fivestars.blog/articles/custom-environment-values-cheatsheet/) 。

  public struct ContainerEnvironmentKey: EnvironmentKey {
  // 示例环境键的默认值
  public static var defaultValue = ContainerEnvironment(containerName: "Default")
  }

  public extension EnvironmentValues {
  var overlayContainer: ContainerEnvironment {
  get { self[ContainerEnvironmentKey.self] }
  set { self[ContainerEnvironmentKey.self] = newValue }
  }
  }

- 在 SwiftUI 中，与 `EnvironmentKey` 类似的定义方式用途很多，掌握了一种很容易掌握其他的。比如： `PreferenceKey` （ 子视图传递给父视图 ）、 `FocusedValueKey` （ 基于焦点传递的值 ）、 `LayoutValueKey` （ 子视图传递给布局容器 ）。
- 由于默认值的存在， `@Environment` 不会因缺少值而导致应用崩溃，但由此也容易产生开发者忘记注入值的情况。
- 与 `@EnvironmentObject` 不同，低层级视图不能修改由祖先视图传递下来的 `EnvironmentValue` 的值。
- 可以通过定义不同的 `EnvironmentKey` ，在 `EnvironmentValue` 中创建多个相同类型的不同名称的属性。

## 总结

- `@StateObject` 、 `@ObservedObject` 和 `@EnvironmentObject` 专用于关联符合 ObservableObject 协议的实例。
- 虽然在某些情形下 `@StateObject` 可以替代 `@ObservedObject` 并提供相似的功能，但它们各自有独特的使用场景。 `@StateObject` 通常用于创建和维护实例，而 `@ObservedObject` 用于引入和响应已存在的实例。
- 在 iOS 17+ 的环境中，如果应用主要依赖于 Observation 和 SwiftData 框架，那么这三个属性包装器的使用频率可能会相对较低。
- `@State` 和 `@Environment` 不限于只能存储值类型，但也可用于其他类型。
- `@Environment` 提供了一种相对更安全的方法来引入环境数据，因为它可以通过 `EnvironmentValue` 提供默认值。这减少了因遗漏数据注入而导致的应用崩溃风险。
- 在 Observation 框架的背景下， `@State` 和 `@Environment` 成为了最主要的属性包装器。无论是值类型还是 `@Observable` 实例，都可以通过这两种包装器引入视图。
- 自定义 Binding 提供了强大的灵活性，允许开发者在数据源和依赖于 Binding 的 UI 组件之间以简洁的代码实现复杂逻辑。

每个属性包装器都有其独特的应用场景和优势。选择正确的工具对于构建高效、可维护的 SwiftUI
应用是至关重要的。正如在软件开发中经常提到的，没有一种工具是万能的，但恰当地使用它们可以大大提高我们的开发效率和应用质量。

# 健康笔记 2.0 开发随笔（四）

经过 2
周的治疗，我父亲终于脱离的生命危险。疫情的原因，医院只允许一个护工在身边照顾，病人长时间无法见到家属而导致了较严重的心理问题。综合考虑，周末已接回家。回家
2 天后，整个状况有了非常好的转变。在这次的治疗中，我提供给医院的我父亲这几年来的各方面身体指标数据起到了很重要的作用。

本周没有太多的精力和情绪用来写代码。这两天在原来统一 sheet 管理和实时 Form 的基础上，完成了可以控制取消手势的 Sheet。这个是
SwiftUI 中一直以来的一个重要的缺失功能。 [ 在 SwiftUI 中制作可以控制取消手势的 Sheet ](/zh/posts/swiftui-
dismiss-sheet/)

Xcode 12 beta 6 的 bug 还是不少，这两天我竟然见到了 3 次四国画面。 SwiftUI 2.0 的 List 问题也很多，甚至感觉比
1.0 更不稳定，而且效率有明显的问题。目前已将所有使用 List 的地方都暂时替换成了 LazyVStack。

# 用 Publish 创建博客（一）—— 入门

[ Publish ](https://github.com/JohnSundell/Publish) 是一款专门为 Swift
开发者打造的静态网站生成器。它使用 Swift 构建整个网站，并支持主题、插件和其他大量的定制选项。

## 开篇

### 开发者 John Sundell

Publish 的开发者 John Sundell 这些年一直致力于发表关于 Swift 的高质量文章、播客和视频。他的作品大多都发布在其独立运营的 [
Swift by Sundell ](https://swiftbysundell.com/) 上。他开发了 [ Publish
](https://github.com/JohnSundell/Publish) 用以创建并管理自己的站点。

在开发 Publish 的过程中，他还开源了其他大量的基本库，比如 [ Ink ](https://github.com/JohnSundell/Ink)
（高效的 Markdown 解析器）、 [ Plot ](https://github.com/JohnSundell/Plot) （创建
HTML、XML、RSS 的 DSL）、 [ Sweep ](https://github.com/JohnSundell/Sweep)
（高效的字符串扫描库）、 [ Codextended ](https://github.com/JohnSundell/Codextended)
（Codable 增强）等。它们不仅一起构建了强大的 Publish，并且在各自的领域也是极为出色的开源库。

### 我为什么使用 Publish

我在一年前恢复自己的这个博客时使用的是 `Hexo` 。Hexo
在国内有非常好的群众基础，网上有大量优秀的教程，也有非常多的开发者贡献了自己创作的各种主题和插件。尽管 Hexo 让我相当满意，但由于我主要使用的语言是
Swift，且对 JavaScript 非常不熟悉，因此想要对 Hexo 做更深入的定制或修改很困难。

作为开发者（即使是业余的），总希望对自己的项目有更全面的掌控，因此完全由 Swift 开发的 Publish 就成为了我的首选。

随着使用 Publish 对 [ 肘子的 Swift 记事本 ](https://fatbobman.com)
重建过程的深入，我感觉自己做出了正确的选择。Publish 让我可以用开发普通 app 的思路和逻辑来创建站点，高效地完成我想要的各种定制和改动。

### 写本文的原因

截至落笔时，Publish 已经在 Github 上获得了 3.1 K 的好评。但网络上对 Publish
的介绍并不多，尤其欠缺关于模板定制、插件开发方面的资料和交流。在 Github 上搜索相关的插件和模板的结果数量也非常有限。

造成上述的情况固然有 Publish 诞生时间较短、使用量不大，Swift
圈子较小等原因，但我认为下面的情况也加剧了这一局面的形成：由于不同于其他的静态网站生成器，在 Publish
项目中，开发者可以用短小的代码实现各种功能。这种碎片化的代码其实是不利于分享且并不容易被搜索；另外，由于 Publish
中的模板和网站的功能具体实现绑定的较深，单独分享的模板的利用度也较低。

> 但 Publish 的这种特质也恰恰是其吸引人之处。

有鉴于此，我将用三篇文章（入门、如何写模板、如何写插件）完成对 Publish 的简绍，也希望国内的 Swift
开发者或爱好者们可以更多的了解和使用这个优秀的工具。

为了让大家能够快速上手，我已将本站点所用的代码（包括模板、自定义插件等）放置在 [ Github
](https://github.com/fatbobman/PublishThemeForFatbobmanBlog)
上，方便大家通过代码更快的了解和掌握 Publish。

## 快速使用入门

### 如何安装 Publish

同大量的其他静态网站生成器一样，Publish 提供了 CLI。你可以通过命令行快速的完成创建模板、内容更新、远程发布等一系列操作。Publish
目前可以运行在 Mac 和 Linux 上，由于其代码对操作系统的依存度极低，估计其后也出现在 Windows 平台上。

#### Mac 下通过 brew 安装

    $brew install publish

#### 源代码安装

    $git clone https://github.com/JohnSundell/Publish.git
    $cd Publish
    $make

### 创建你的第一个项目

让我们来创建一个新的 Blog 项目

    $mkdir myblog
    $cd myblog
    $publish new

Publish 将在 myblog 目录中创建我们所需的项目模板。它的基本构成大概如下：

    |-- myblog
    |   |-- Content
    |           |–– posts
    |                 |–– first-post.md
    |                 |–– index.md
    |           |–– index.md
    |   |-- Resources
    |   |-- Sources
    |           |–– Myblog
    |                  |–– main.swift

- Content

在此放入你要在网站发布的文章、页面等使用 markdown 编写的文件。

- Resources

项目主题需要的一些资源，比如 css，图片等，目前为空。在你进行第一发布后，可以看到它包含了默认的 FoundationTheme 的 styles.
css 文件。

- Source

描述网站的代码。在 `main.swift` 中定义了网站的基本属性、创建工作流等。

### 编译及运行

Swift 是编译型语言，因此你的站点的代码在每次修改之后，都需在本机编译并运行才能完成内容的生成工作，好在这一切都只需要一条命令。

我们让 Publish 完成上述工作并启动内置的 Web Server 供我们浏览新创建的项目。

    $publish run

第一次运行，Publish 会自动从 Github 上获取所需的其他库，请稍等几分钟。

    $ publish run
    ............
    Publishing Myblog (6 steps)
    [1/6] Copy 'Resources' files
    [2/6] Add Markdown files from 'Content' folder
    [3/6] Sort items
    [4/6] Generate HTML
    [5/6] Generate RSS feed
    [6/6] Generate site map
    ✅ Successfully published Myblog
    🌍 Starting web server at http://localhost:8000

    Press ENTER to stop the server and exit

现在你就可以用浏览器访问 [ http://localhost:8000 ](http://localhost:8000) 来访问你的新站点了。

网站的全部内容都被生成并放置在了 `Output` 目录下。你只需要将其中的内容上传到你的服务器，或者通过简单的配置，比如：

    .unwrap(.gitHub("fatbobman/fatbobman.github.io", useSSH: true), PublishingStep.deploy)

然后使用

    $publish deploy

便可将内容发布到你的 github. io 上（具体配置后面说明）。

此时你在 `Content` \- `posts` 中添加如下文件 `second-post.md`

    ---
    date: 2021-01-29 19:58
    description: 我的第二篇文章
    tags: publish,swift
    ---
    # Hello Wolrd

再度执行 `publish run` 便可以看到新文章已经出现在页面上了。

### 使用我提供的模板快速上手

首先要确保已经安装了 Publish CLI

    $git clone https://github.com/fatbobman/PublishThemeForFatbobmanBlog.git
    $cd PublishThemeForFatbobmanBlog
    $publish run

## 更多关于 Publish 的知识

本节的内容将介绍几个 Publish 中的概念，对于后面了解模板定制和功能扩展十分重要。

### Site

当你使用 Publish 来创建项目时，Publish 会自动生成一个 `Swift Package`
。网站的生成和部署配置都是通过该包完成的，使用的都是原生的且类型安全的 Swift 代码。

下面的代码便是使用 `publish new myblog` 生成的 `main.swift` （包的入口文件）中内容。

    //Site 的定义
    struct Myblog: Website {
        enum SectionID: String, WebsiteSectionID {
            // 添加你需要的 Section
            case posts
        }

        struct ItemMetadata: WebsiteItemMetadata {
            // 在这里添加任何您想使用的特定站点元数据
        }

        // 你网站的一些配置 xn'xi
        var url = URL(string: "https://your-website-url.com")!
        var name = "Myblog"
        var description = "A description of Myblog"
        var language: Language { .english }
        var imagePath: Path? { nil }
    }
    //可以在模板或插件等位置访问 Site 中的属性信息

    // 执行入口。当前使用的是默认的模板，且使用的是 Publish 预置的生成、导出、发布流程。
    // 工作流的定义，更多内容见 Step
    try Myblog().publish(withTheme: .foundation)

`Site` 不仅定义了网站项目的基础配置信息，而且定义了网站从生成到发布的工作流程。

### Section

每个 Section 都会在 `Output` 下生成的一个子目录。在 main. swift 中，通过枚举的方式对 `Section`
进行定义。你可以把 Section 可以作为一组 `Item` （文章）的容器，也可以仅指向某个 `Page` （非 Item
的自有页面）。当需要使用 `Section` 管理一组文章时，只需要在 `Content` 目录下创建同该 `Section`
名字相同的子目录即可，具体可以查看范例中 `Content` 下的 `posts` 和 `project` 。

`Section` 的定义

    enum SectionID: String, WebsiteSectionID {
         case posts //新创建的项目缺省只有这个，对应 content-posts 目录
         case links //可以自己添加，将属于该 section 的文章放置到对应的目录即可
         case about
    }

在 [ 肘子的 Swift 记事本 ](https://fatbobman.com) 中，每个 Section 同时也对应着上方导航区的一个选项。 `Section` 可以有多种用途，在模板定制章节会做更多探讨。

### Item

保存在 `Content--对应 Sectioin` 目录中的文章。每个 `Item` 都对应一个 `Section`
，无需特别设置，其保存在哪个 `Section` 的目录中，就属于哪个 `Section` 。如果该 `Section`
不需要作为文件容器，可以直接在 `Content` 中创建和 `Section` 同名的 md 文件。我提供的范例模板中， `about`
就是这种形式。

### Page

不归属于任何 `Section` 的文章。 `Page` 不会出现在 `Section` 的 `item` 列表中，通常也不会出现在
index（首页）列表中。在 `content` 下的不属于任何 `Section` 的目录中按如下结构添加文件即可创建 `Page` 。注意
`Page` 的创建路径和访问路径的关系。

    | content -- 404
    |             | -- index.md

你可以通过访问 [ http://localhost:8000/404/index/查看
](http://localhost:8000/404/index/%E6%9F%A5%E7%9C%8B)

Page 为我们提供一种构建自由页面的方法。比如你可以用它来创建不需要显示在列表中的文章，或者像范例模板的演示一样创建 404😅。

### Content

在此特指 `Item` 、 `Page` 中的 `content` 属性。作为内容集，其范围包括文本（如标题和描述）、所属标签（tag）、转换后
HTML 代码、音频、视频等各种元数据。元数据需要在 Markdonw 文章的头部注明。

`Section` 也有 `Content` ，它的内容对应着你在该 `Section` 对应的 `Content` 子目录中创建的
index. md（如果有必要的话）。

在代码中将来还会碰到另一种 `Content` , 确切的说是 `PublishingContext`
。里面包含着整个项目的所有信息（Site、Sections、Items、Tags 等），通过将它的实例传递给 `Step` 或者 `Plugin`
来完成修改或配置网站的各种工作。

### Metadata

Markdown 文件的元数据，在文章（Markdown）文件的头部做出标识。分为两类，一种是 Publish 预置的。另一种是通过在 `Site` 中
`ItemMetadata` 自定义的。

    ---
    date: 2021-01-29 19:58
    description: A description of my first post.
    tags: first, article
    author: fat
    image: https://cdn.fatbobman.com/first-post.png
    ---

#### 预设

- **title** 文字标题

如果没有设置，Publish 会直接查找文章正文中第一个 Top-level Head `#` 作为标题

- **description** 文章简介

- **date** 文章创作日期

如果没设置则直接使用文件的 modificationDate

- **tags** 文章标签，每篇文章可以设置多个标签，为文章的组织多一个维度

- **image** 图片地址比如可以用来在 Item 列表中显示一个文章的主题图片（需在模板中定义）

- **audio** 音频数据

- **video** 视频数据

音视频的定义过于复杂，如果确实需要可以自行定义。

#### 自定义

    struct ItemMetadata: WebsiteItemMetadata {
        // Add any site-specific metadata that you want to use here.
        var author:String
    }

如果预置的 `metadata` 不足以满足你的需求，可以在 `ItemMetadata` 中自行定义。

#### 两种 metadata 的区别

预设的 `metadata` 在 Publish 中是作为的属性存在的。

    for item in content.allItems(sortedBy: \.date){
             print(item.title)
     }

自定义的 `metadata` 需通过如下方式获取

    let author = (item.metadata as! Myblog.ItemMetadata).author

在模板中使用更方便

    .text(item.metadata.author)

Publish 中预设的 `metadata` ， `Item` 并不要求必须填写。但是对于自定义的 `metadata` 则必须在 `markdown` 文档中添加。 `index.md` 、 `Page` 可以没有 `metadata` （无论是否为自定义）

### Theme

Publish 使用 [ Plot ](https://github.com/fatbobman/PublishThemeForFatbobmanBlog)
作为其 HTML 主题的描述引擎，开发者可以用非常 Swift 的方式来定义页面。如果使用过 DSL 类型的开发方式，会感觉非常亲切。比如下面的代码定义了
Section List 的布局呈现

    func makeSectionHTML(
            for section: Section<Site>,
            context: PublishingContext<Site>
        ) throws -> HTML {
            HTML(
                .lang(context.site.language), //网页语言
                .head(for: section, on: context.site), //头文件，metadata、css 等
                .body(
                    .header(for: context, selectedSection: section.id), //网站的上部区域，范例中包括了 Logo，以及导航条
                    .wrapper(
                        .itemList(for: section.items, on: context.site) // 文章列表
                    ),
                    .footer(for: context.site) //最下方的版权区域
                )
            )
        }

在 Theme 中定义的布局细节仍需要在 css 中进行进一步设置。

上面代码中 `header` 、 `wrapper` 等在 Plot 中都被称作 `Node` , 除了使用 Publish 中预置的大量 `Node` 外，我们可以使用自己编写的 `Node` 。

更多关于 Theme 的内容，将在用 Publish 创建博客（二）中做详细介绍。

### Step

Publish 采用工作流（Pipeline）的方式来明确定义各个环节的操作过程。从文件读取、markdown 解析、HTML 生成、RSS 导出等等。通过
`publish new` 生成的 `main.swift` 中，尽管只使用了一条语句

    try Myblog().publish(withTheme: .foundation)

但其背后对应着下面一系列操作步骤：

    using: [
          .group(plugins.map(PublishingStep.installPlugin)),
          .optional(.copyResources()),
          .addMarkdownFiles(),
          .sortItems(by: \.date, order: .descending),
          .group(additionalSteps),
          .generateHTML(withTheme: theme, indentation: indentation),
          .unwrap(rssFeedConfig) { config in
          .generateRSSFeed(
                   including: rssFeedSections,
                          config: config
                        )
              },
           .generateSiteMap(indentedBy: indentation),
           .unwrap(deploymentMethod, PublishingStep.deploy)
             ]

在多数的情况下，我们都会显式的将每一个操作步骤标明出来。每个步骤在 Publish 中被称为 `Step` 。Publish 已经预置了不少 `Step` 供开发者使用。我么也可以将自己创建的 `Step` 注入到工作流中合适的位置以实现更多功能。

每个 `Step` 都会被传递一个 `PublishContent` 实例，该实例可用于更改网站中的各种元素（包括文件、文件夹、Item、Page
等）。关于 `PublishContent` 同 `Content` 的不同，请见上文。

### Plugin

    .installPlugin(.highlightJS()), //语法高亮

上面的代码在 Publish 工作流中通过名为 `installPlugin` 的 `Step` 来完成插件 `highlightJS`
的安装。

`Plugin` 的开发和 `Step` 非常类似，都会获得一个 `PublishContent` 实例，并通过其完成相关工作。

比如说，你可以用 `Step` 来完成某些具有副作用的操作；用 `Plugin` 来完成类如 `Modifier` （markdown
的定制化解析）注入的工作。

对于自定义代码，从功能角度讲，两者都能实现对方的工作。因此在创建功能扩展时，采用 `Step` 还是 `Plugin` 取决于个人的偏好。

关于如何定制 `Step` 和 `Plugin` 将在用 Publish 创建博客（三）中做详细说明。

## Publish 适合什么人

Publish 同当前主流的静态网站生成器相比还略有不足，如社区活跃度较低、开发时间较短、Swift 语言用户量较小等。当前 Publish
较适合符合如下状况的朋友：

- 使用 Swift 语言的开发者或 Swift 的爱好者
- 欠缺 Javascripte 的经验，或者喜欢 Javascripte free 的风格
- 追求高效、简洁的网页呈现方式
- 希望能够完整掌握网站的各个环节并通过自己的双手逐步实现各项功能
- 善于尝鲜者

## Next

我将在用 Publish 创建博客（二）中探讨 Theme 的开发，在（三）中了解如何通过多种手段扩展 Publish 的功能。

如果你已经开始感兴趣，马上在 Github 上开通你的 github. io 站点，用 Publish 一键 deploy 属于自己的博客吧。

# 在 SwiftUI 下定制手势

不同于众多的内置控件，SwiftUI 没有采用对 UIGestureRecognizer（或
NSGestureRecognizer）进行包装的形式，而是重构了自己的手势体系。SwiftUI 手势在某种程度上降低了使用门槛，但由于缺乏提供底层数据的
API，严重制约了开发者的深度定制能力。在 SwiftUI 下，我们无法拥有类似构建全新 UIGestureRecongnizer
的能力。所谓的自定义手势，其实只是对系统预置手势的重构而已。本文将通过几个示例，演示如何使用 SwiftUI 提供的原生手段定制所需手势。

## 基础

### 预置手势

SwiftUI 目前提供了 5 种预置手势，分别为点击、长按、拖拽、缩放和旋转。像 `onTapGesture`
之类的调用方式，实际上是为了便捷而创建的视图扩展。

- 点击（TapGesture）

可设定点击次数（单击、双击）。是使用频率最高的手势之一。

- 长按（LongPressGesture）

当按压满足了设定时长后，可触发指定闭包。

- 拖拽（DragGesture）

SwiftUI 将 Pan 和 Swipe 合二为一，位置变化时，提供拖动数据。

- 缩放（MagnificationGesture）

两指缩放。

- 旋转（RotationGesture）

两指旋转。

点击、长按、拖拽仅支持单指。SwiftUI 没有提供手指数设定功能。

除了上述提供给开发者使用的手势外，SwiftUI
其实还有大量的内部（非公开）手势给系统控件使用，例如：ScrollGesture、\_ButtonGesture 等。

> Button 内置手势的实现比 TapGesture 更复杂。除了提供了更多的调用时机外，而且支持了对按压区域尺寸的智能处理（提高手指触击成功率）。

### Value

SwiftUI 会依据手势的类型提供不同的数据内容。

- 点击：数据类型为 Void（ SwiftUI 4.0 中，数据类型为 CGPoint，指示了在特定坐标空间中的点击位置 ）
- 长按：数据类型为 Bool，开始按压后提供 true
- 拖拽：提供了最全面的数据信息，包含当前位置、偏移量、事件时间、预测终点、预测偏移量等内容
- 缩放：数据类型为 CGFloat，缩放量
- 旋转：数据类型为 Angle，旋转角度

使用 `map` 方法，可以将手势提供的数据转换成其他的类型，方便之后的调用。

### 时机

SwiftUI 手势内部没有状态一说，通过设置与指定时机对应的闭包，手势会在适当的时机自动进行调用。

- onEnded

在手势结束时执行的操作

- onChanged

当手势提供的值发生变化时执行的操作。只在 Value 符合 Equatable 时提供，因此 TapGesture 不支持。

- updating

执行时机同 onChanged 相同。对 Value 没有特别约定，相较 onChanged ，增加了更新手势属性（GestureState）和获取
Transaction 的能力。

不同的手势，对时机的关注点有所区别。点击通常只关注 onEnded；onChanged（或
updating）在拖拽、缩放、旋转中作用更大；长按只有在满足了设定时长的情况下，才会调用 onEnded。

### GestureState

专门为 SwiftUI 手势开发的属性包装器类型，可作为依赖项驱动视图更新。相较 State 有如下不同：

- 只能在手势的 updating 方法中修改，在视图其它的地方为只读
- 在手势结束时，与之关联（使用 updating 进行关联）的手势会自动将其内容恢复到它的初始值
- 通过 resetTransaction 可以设置恢复初始数据时的动画状态

### 组合手势的手段

SwiftUI 提供了几个用于手势的组合方法，可以将多个手势连接起来，重构成其他用途的手势。

- simltaneously（同时识别）

将一个手势与另一个手势相结合，创建一个同时识别两个手势的新手势。例如将缩放手势与旋转手势组合，实现同时对图片进行缩放和旋转。

- sequenced（序列识别）

将两个手势连接起来，只有在第一个手势成功后，才会执行第二个手势。譬如，将长按和拖拽连接起来，实现只有当按压满足一定时间后才允许拖拽。

- exclusively（排他性识别）

合并两个手势，但只有其中一种手势可以被识别。系统会优先考虑第一个手势。

组合后的手势，Value 类型也将发生变化。仍可使用 `map` 将其转换成更加易用的数据类型。

### 手势的定义形式

通常开发者会在视图内部创建自定义手势，如此代码量较少，且容易与视图中其它数据结合。例如，下面的代码在视图中创建了一个可同时支持缩放和旋转的手势：

    struct GestureDemo: View {
        @GestureState(resetTransaction: .init(animation: .easeInOut)) var gestureValue = RotateAndMagnify()

        var body: some View {
            let rotateAndMagnifyGesture = MagnificationGesture()
                .simultaneously(with: RotationGesture())
                .updating($gestureValue) { value, state, _ in
                    state.angle = value.second ?? .zero
                    state.scale = value.first ?? 0
                }

            return Rectangle()
                .fill(LinearGradient(colors: [.blue, .green, .pink], startPoint: .top, endPoint: .bottom))
                .frame(width: 100, height: 100)
                .shadow(radius: 8)
                .rotationEffect(gestureValue.angle)
                .scaleEffect(gestureValue.scale)
                .gesture(rotateAndMagnifyGesture)
        }

        struct RotateAndMagnify {
            var scale: CGFloat = 1.0
            var angle: Angle = .zero
        }
    }

另外，也可以将手势创建成符合 Gesture 协议的结构体，如此定义的手势，非常适合被反复使用。

通过将手势或手势处理逻辑封装成视图扩展可进一步简化使用难度。

> 为了突显某些方面的功能，下文中提供的演示代码或许看起来比较繁琐。实际使用时，可自行简化。

## 示例一：轻扫

### 1.1 目标

创建一个轻扫（Swipe）手势，着重演示如何创建符合 Gesture 协议的结构体，并对手势数据进行转换。

### 1.2 思路

在 SwiftUI 预置手势中，仅有 DragGesture 提供了可用于判断移动方向的数据。根据偏移量来确定轻扫方向，使用 map
将繁杂的数据转换成简单的方向数据。

### 1.3 实现

    public struct SwipeGesture: Gesture {
        public enum Direction: String {
            case left, right, up, down
        }

        public typealias Value = Direction

        private let minimumDistance: CGFloat
        private let coordinateSpace: CoordinateSpace

        public init(minimumDistance: CGFloat = 10, coordinateSpace: CoordinateSpace = .local) {
            self.minimumDistance = minimumDistance
            self.coordinateSpace = coordinateSpace
        }

        public var body: AnyGesture<Value> {
            AnyGesture(
                DragGesture(minimumDistance: minimumDistance, coordinateSpace: coordinateSpace)
                    .map { value in
                        let horizontalAmount = value.translation.width
                        let verticalAmount = value.translation.height

                        if abs(horizontalAmount) > abs(verticalAmount) {
                            if horizontalAmount < 0 { return .left } else { return .right }
                        } else {
                            if verticalAmount < 0 { return .up } else { return .down }
                        }
                    }
            )
        }
    }

    public extension View {
        func onSwipe(minimumDistance: CGFloat = 10,
                     coordinateSpace: CoordinateSpace = .local,
                     perform: @escaping (SwipeGesture.Direction) -> Void) -> some View {
            gesture(
                SwipeGesture(minimumDistance: minimumDistance, coordinateSpace: coordinateSpace)
                    .onEnded(perform)
            )
        }
    }

### 1.4 演示

    struct SwipeTestView: View {
        @State var direction = ""
        var body: some View {
            Rectangle()
                .fill(.blue)
                .frame(width: 200, height: 200)
                .overlay(Text(direction))
                .onSwipe { direction in
                    self.direction = direction.rawValue
                }
        }
    }

![swipeGestureDemo2](https://cdn.fatbobman.com/swipeGestureDemo2.gif)

### 1.5 说明

- 为什么使用 AnyGesture

在 Gesture 协议中，需要实现一个隐藏的类型方法： `_makeGesture` 。苹果目前并没有提供应该如何实现它的文档，好在 SwiftUI
提供了一个含有约束的默认实现。当我们不在结构体中使用自定义的 Value 类型时，SwiftUI 可以推断出 `Self.Body.Value`
，此时可以将 body 声明为 `some Gesture` 。但由于本例中使用了自定义 Value 类型，因此必须将 body 声明为 `AnyGesture<Value>` ，方可满足启用 `_makeGesture` 默认实现的条件。

      extension Gesture where Self.Value == Self.Body.Value {
        public static func _makeGesture(gesture: SwiftUI._GraphValue<Self>, inputs: SwiftUI._GestureInputs) -> SwiftUI._GestureOutputs<Self.Body.Value>
      }

### 1.6 不足与改善方法

本例中并没有对手势的持续时间、移动速度等因素进行综合考量，当前的实现严格意义上并不能算是真正轻扫。如果想实现严格意义上的轻扫可以采用如下的实现方法：

- 改成示例 2 的方式，用 ViewModifier 来包装 DragGesture
- 用 State 记录滑动时间
- 在 onEnded 中，只有满足速度、距离、偏差等要求的情况下，才回调用户的闭包，并传递方向

## 示例二：计时按压

### 2.1 目标

实现一个可以记录时长的按压手势。手势在按压过程中，可以根据指定的时间间隔进行类似 onChanged
的回调。本例程着重演示如何通过视图修饰器包装手势的方法以及 GestureState 的使用。

### 2.2 思路

通过计时器在指定时间间隔后向闭包传递当前按压的持续时间。使用 GestureState 保存点击开始的时间，按压结束后，上次按压的起始时间会被手势自动清除。

### 2.3 实现

    public struct PressGestureViewModifier: ViewModifier {
        @GestureState private var startTimestamp: Date?
        @State private var timePublisher: Publishers.Autoconnect<Timer.TimerPublisher>
        private var onPressing: (TimeInterval) -> Void
        private var onEnded: () -> Void

        public init(interval: TimeInterval = 0.016, onPressing: @escaping (TimeInterval) -> Void, onEnded: @escaping () -> Void) {
            _timePublisher = State(wrappedValue: Timer.publish(every: interval, tolerance: nil, on: .current, in: .common).autoconnect())
            self.onPressing = onPressing
            self.onEnded = onEnded
        }

        public func body(content: Content) -> some View {
            content
                .gesture(
                    DragGesture(minimumDistance: 0, coordinateSpace: .local)
                        .updating($startTimestamp, body: { _, current, _ in
                            if current == nil {
                                current = Date()
                            }
                        })
                        .onEnded { _ in
                            onEnded()
                        }
                )
                .onReceive(timePublisher, perform: { timer in
                    if let startTimestamp = startTimestamp {
                        let duration = timer.timeIntervalSince(startTimestamp)
                        onPressing(duration)
                    }
                })
        }
    }

    public extension View {
        func onPress(interval: TimeInterval = 0.016, onPressing: @escaping (TimeInterval) -> Void, onEnded: @escaping () -> Void) -> some View {
            modifier(PressGestureViewModifier(interval: interval, onPressing: onPressing, onEnded: onEnded))
        }
    }

### 2.4 演示

    struct PressGestureView: View {
        @State var scale: CGFloat = 1
        @State var duration: TimeInterval = 0
        var body: some View {
            VStack {
                Circle()
                    .fill(scale == 1 ? .blue : .orange)
                    .frame(width: 50, height: 50)
                    .scaleEffect(scale)
                    .overlay(Text(duration, format: .number.precision(.fractionLength(1))))
                    .onPress { duration in
                        self.duration = duration
                        scale = 1 + duration * 2
                    } onEnded: {
                        if duration > 1 {
                            withAnimation(.easeInOut(duration: 2)) {
                                scale = 1
                            }
                        } else {
                            withAnimation(.easeInOut) {
                                scale = 1
                            }
                        }
                        duration = 0
                    }
            }
        }
    }

![pressGestureDemo.2022-01-08
13_50_59](https://cdn.fatbobman.com/pressGestureDemo.2022-01-08%2013_50_59.gif)

### 2.5 说明

- GestureState 数据的复原时间在 onEnded 之前，在 onEnded 中，startTimestamp 已经恢复为 nil
- DragGesture 仍是最好的实现载体。TapGesture、LongPressGesture 均在满足触发条件后会自动终止手势，无法实现对任意时长的支持

### 2.6 不足及改善方法

当前的解决方案没有提供类似 LongPressGesture 按压中位置偏移限定设置，另外尚未在 onEnded 中提供本次按压的总持续时长。

- 在 updating 中对偏移量进行判断，如果按压点的偏移超出了指定的范围，则中断计时。并在 updating 中，调用用户提供的 onEnded 闭包，并进行标记
- 在手势的 onEnded 中，如果用户提供的 onEnded 闭包已经被调用，则不会再此调用
- 使用 State 替换 GestureState，这样就可以在手势的 onEnded 中提供总持续时间。需自行编写 State 的数据恢复代码
- 由于使用了 State 替换 GestureState，逻辑判断就可以从 updating 移动到 onChanged 中

## 示例三：附带位置信息的点击

> SwiftUI 4.0 提供了新的 Gesture —— SpatialTapGesture , 使用它可以直接获得点击位置。onTapGesture
> 也获得提升，onChange 和 onEnd 中 value 将表示在特定坐标空间中的点击位置（ CGPoint ）

### 3.1 目标

实现提供触摸位置信息的点击手势（支持点击次数设定）。本例主要演示 simultaneously 的用法以及如何选择合适的回调时间点（onEnded）。

### 3.2 思路

手势的响应感觉应与 TapGesture 完全一致。使用 simultaneously 将两种手势联合起来，从 DrageGesture 中获取位置数据，从
TapGesture 中退出。

### 3.3 实现

    public struct TapWithLocation: ViewModifier {
        @State private var locations: CGPoint?
        private let count: Int
        private let coordinateSpace: CoordinateSpace
        private var perform: (CGPoint) -> Void

        init(count: Int = 1, coordinateSpace: CoordinateSpace = .local, perform: @escaping (CGPoint) -> Void) {
            self.count = count
            self.coordinateSpace = coordinateSpace
            self.perform = perform
        }

        public func body(content: Content) -> some View {
            content
                .gesture(
                    DragGesture(minimumDistance: 0, coordinateSpace: coordinateSpace)
                        .onChanged { value in
                            locations = value.location
                        }
                        .simultaneously(with:
                            TapGesture(count: count)
                                .onEnded {
                                    perform(locations ?? .zero)
                                    locations = nil
                                }
                        )
                )
        }
    }

    public extension View {
        func onTapGesture(count: Int = 1, coordinateSpace: CoordinateSpace = .local, perform: @escaping (CGPoint) -> Void) -> some View {
            modifier(TapWithLocation(count: count, coordinateSpace: coordinateSpace, perform: perform))
        }
    }

### 3.4 演示

    struct TapWithLocationView: View {
        @State var unitPoint: UnitPoint = .center
        var body: some View {
            Rectangle()
                .fill(RadialGradient(colors: [.yellow, .orange, .red, .pink], center: unitPoint, startRadius: 10, endRadius: 170))
                .frame(width: 300, height: 300)
                .onTapGesture(count:2) { point in
                    withAnimation(.easeInOut) {
                        unitPoint = UnitPoint(x: point.x / 300, y: point.y / 300)
                    }
                }
        }
    }

![TapWithLocationDemo](https://cdn.fatbobman.com/TapWithLocationDemo.gif)

### 3.5 说明

- 当 DragGesture 的 minimumDistance 设置为 0 时，其第一条数据的产生时间一定早于 TapGesture (count:1) 的激活时间
- 在 simultaneously 中，一共有三个 onEndend 时机。手势 1 的 onEnded，手势 2 的 onEnded，以及合并后手势的 onEnded。在本例中，我们选择在 TapGesture 的 onEnded 中回调用户的闭包

## 总结

当前 SwiftUI 的手势，暂处于使用门槛低但能力上限不足的状况，仅使用 SwiftUI
的原生手段无法实现非常复杂的手势逻辑。将来找时间我们再通过其它的文章来研究有关手势之间的优先级、使用 GestureMask 选择性失效，以及如何同
UIGestureRecognizer 合作创建复杂手势等议题。

# 健康笔记 2.0 开发随笔（三）

由于家属突发疾病，最近每天都要出入医院，因此最近用于开发的时间很有限。

目前 app 已经完成了笔记、条目、数据的创建、编辑、显示、删除全部逻辑。如果不考虑图表、数据导入导出、交叉比对等功能，app 的基本功能已经完成了。

在本次开发中，我着重调整了表单的开发方式，目前表单无论从响应，判断等方便都比上一版有了很大的提高。

本次我将以前分散的输入源（source of truth）统一到了一起，不仅更便于代码管理，同时也方便实现了很多以前无法或实现起来非常困难的功能。

关于表单的处理，可以参看我的文章 [ 如何在 SwiftUI 中创建一个实时响应的 Form ](/zh/posts/swiftui-input-
form/) 。

另外，由于我的 app 对于 sheet 的使用量也很多，所以也对 sheet 的响应做出了统一的管理，这方面我记录在另一篇文章中 [ 在 SwiftUI
中，根据需求弹出不同的 Sheet ](/zh/posts/swiftui-multisheet/) 。

时间有限，随便记录一点。

# 在 Linux 系统上搭建 Swift 开发调试环境

## Swift 与 Linux

自 2015 年 Swift 宣布开源并支持 Linux 后，一晃已超过 5 年。在最初几年间尽管 Swift 发展迅速，但并未被 Linux
社区广泛接受。造成这种局面的原因较多，其中既有语言稳定性方面的问题，同时又有对 Linux
的支持不完善、缺乏具有吸引力的基础库和第三方库、热点项目不足等多方面原因。

最近两年，上述问题均得到显著改善。

- 从 Swift 5 开始 Swift 团队宣布 ABI 稳定了。自此，Swift 为应用程序提供了二进制兼容性，有了 ABI 稳定性作为基础，Swift 对其他平台的支持速度和力度将大大提高
- 2020 年 Swift 团队推出了 5.3 版本，除了“重要的质量提升和性能增强”之外，Swift 5.3 的一个关键特性是正式支持 Linux 和 Window 平台。事实上，这也是 Swift 的发布流程首次为三个不同的平台分别设立了发布负责人。作为承诺将 Swift 引入 Linux 的第一份成果，Swift 团队宣布新的 Swift 版本可用于一众 Linux 发行版上。
- 出现了大量优秀的官方和第三方的跨平台库。仅 Apple 公司，最近几年来已经为 Swift 社区贡献了大量的 Swift 代码，并保持着非常高的提交频率。
- Swift 在服务器端及深度学习领域取得了不错的应用成果。

Swift 已经准备在 Linux 有更多的表现。

## 写本文的原因

前些日子写了篇 [ 用 Publish 创建博客（一）——入门 ](/zh/posts/publish-1/) （一个用 Swift
编写的优秀的静态网站生成器）的介绍，期间有网友问我是否可以在 Linux 上使用，我回答不成问题。但转过头来思考，虽然 `Publish` 完美地支持
Linux，但开发者能否像在 mac 上一样方便的进行开发调试呢？

之前使用 `Vapor` 的时候，曾通过 `Docker` 在 Ubuntu 上安装过 Swift，不过代码是在 mac 上调试的。我也十分好奇，在
2021 年 Swift 到底在 Linux 下的开发环境如何？

本文的目标是在 Linux 上搭建一个可供生产标准的 Swift
开发调试环境。使用者将获得一个支持代码高亮、自动补全、定义跳转、断点调试、代码美化、代码静态扫描、跨操作系统平台配置的综合开发体验。

## 准备

由于每个人使用的 Linux 发行版本不同，因此在安装过程中，如遇到缺少必要依赖的情况，请自行按系统提示安装所需的依赖库即可。

本文在描述每一步该如何做的同时，还会做出必要的解释。即使你使用的是其他的 Linux 发行版，或者不同的编辑器，甚至在 Swift
或其他工具发生了重大的升级后，仍可按照下面安装思路进行环境搭建。

本文搭建的起点是建立在已经安装了 Visual Studio Code 1.53.0 的 Ubuntu 20.04 LTS（最小化安装）系统上的。选择安装的
Swift Toolchain 为 5.3.3。

对于 Ubuntu 20.04, 需安装 `python2.7` 及 `npm` 以完成下面其他操作。

    $ sudo apt install libpython2.7 libpython2.7-dev libz3-4 npm

## Swift Toolchain

### 工具链选择

尽管你可以直接 [ 下载 Swift Toolchain 的源码 ](https://github.com/apple/swift/releases)
自己编译，但目前最推荐的方式还是使用官方提供的已编译好的下载包进行安装。 [ swift.org
](https://swift.org/download/#releases) 上提供了 Ubuntu 16.04、Ubuntu 18.04、Ubuntu
20.04、CentOS 7、CentOS 8、Amazon Linux 2 的下载包。其他的发行版本也多有自己的官方支持，比如 Fodor、Red Hat
Enterprise Linux 8、Raspbian OSi 等

Swift 在 5.3 版本后开始正式支持 Linux 平台，所以本文选择在 Ubuntu 20.04 上安装 [ Swift 5.3.3 Release
](https://swift.org/builds/swift-5.3.3-release/ubuntu2004/swift-5.3.3-RELEASE/swift-5.3.3-RELEASE-
ubuntu20.04.tar.gz) 。

### 安装 Toolchain

在 [ swift.org ](https://swift.org/download/) 上查找对应发行版的 Swift Toolchain 下载地址

![image-20210214092353715](https://cdn.fatbobman.com/swift_toolchain_download.png)

    $cd ~
    $wget https://swift.org/builds/swift-5.3.3-release/ubuntu2004/swift-5.3.3-RELEASE/swift-5.3.3-RELEASE-ubuntu20.04.tar.gz

解压文件

    $tar -xzf swift-5.3.3-RELEASE-ubuntu20.04.tar.gz

swift 工具链将被解压在 `~/swift-5.3.3-RELEASE-ubuntu20.04` 目录中，将该目录移动到你习惯的路径，比如：

    $sudo mv swift-5.3.3-RELEASE-ubuntu20.04 /usr/share/swift

请记住移动后的路径 `/usr/share/swift` ，该路径将在下面的配置中被多次使用到。

将 swift bin 的路径添加到环境中

    $echo "export PATH=/usr/share/swift/usr/bin:$PATH" >> ~/.bash
    $source .bash

至此，Swift 已经在当前系统上安装好了

    $swift --version
    Swift version 5.3.3 (swift-5.3.3-RELEASE)
    Target: x86_64-unknown-linux-gnu

### 运行第一段代码

创建 `hello.swift` ，内容为

    #!/usr/bin/env swift
    print("My first swift code")



    $cd ~
    $swift hello.swift
    My first swift code

或者可以将 swift 代码当做 script 来执行

    $chmod +755 hello.swift
    $./hellow.swift
    My first swift code

### 创建第一个 Swift 项目

Swift Package Manager (SPM) 是苹果推出的用于创建使用 swift 的库和可执行程序的工具。目前它已经是 Swift
Toolchain 的一部分了。

创建可执行程序项目

    $cd ~
    $mkdir MyProject
    $cd MyProject
    $swift package init --type executable
    Creating executable package: MyProject
    Creating Package.swift
    Creating README.md
    Creating .gitignore
    Creating Sources/
    Creating Sources/MyProject/main.swift
    Creating Tests/
    Creating Tests/LinuxMain.swift
    Creating Tests/MyProjectTests/
    Creating Tests/MyProjectTests/MyProjectTests.swift
    Creating Tests/MyProjectTests/XCTestManifests.swift

编译并运行该项目

    ~/MyProject$swift run
    [4/4] Linking MyProject
    Hello, world!

该项目在下面的配置中还将使用到。也可以直接使用 vscode 打开项目文件

    ~/MyProject$code .

![image-20210214144908318](https://cdn.fatbobman.com/swift_in_linux_vscode_overview.png)

vscode 对于 Swift 已经内置支持了代码高亮。

## SourceKit-LSP

### 什么是 LSP

`LSP` 的全程是 `Language Sever Protocol` ，是微软提出的一项标准化协议，旨在统一开发工具与 `Lanuguage
Server` 之间的通信。 `LSP` 为支持的语言提供了一套通用的功能集，包括：语法高亮、自动补全、定义跳转、查找引用等等。苹果公司从 2018
年开始为 Swift 社区提供了 [ LSP 的代码 ](https://github.com/apple/sourcekit-lsp) 及支持。目前 `LSP` 已经被集成到了 Swift 的工具链中。

### 安装 LSP

尽管 Swift ToolChain 中已经集成了 `LSP` ，但是我们还是需要为 `vscode` 安装对应的插件并进行配置，才能在
vscode 中使用 Swift 的 LSP 功能。

由于 Swift LSP 插件没有被放置在 `vscode` 的插件市场中，我们还是需要从苹果的 [ LSP Github
](https://github.com/apple/sourcekit-lsp) 站点上下载

    $git clone https://github.com/apple/sourcekit-lsp.git

下载的文件包含全部 LSP 的代码和插件代码，我们只需安装插件代码。

    $cd sourcekit-lsp/Editors/vscode/
    $npm run createDevPackage

> 2021 年 8 月更新

新的 LSP 版本更改了插件编译命令

    $cd sourcekit-lsp/Editors/vscode/
    $npm install
    $npm run dev-package

![image-20210214151421778](https://cdn.fatbobman.com/swift_in_linux_complie_vscode_lsp.png)

编译成功的插件被放置在 `~/sourcekit-lsp/Editors/vscode/out` 目录中。

### 配置 vscode

通过命令行将插件安装到 vscode 上

    $cd ~/sourcekit-lsp/Editors/vscode
    $code --install-extension sourcekit-lsp-vscode-dev.vsix

或者在 vscode 中选择该插件进行安装

![image-20210214151923560](https://cdn.fatbobman.com/swift_in_linux_vscode_install_lsp.png)

配置 `Settings`

![image-20210214154131957](https://cdn.fatbobman.com/swift_in_linux_lsp_setting_1.png)

由于 `lsp` 已经集成到了 swift toolchain 中，因此在我们安装 toolchain 时，它已经被安装到了 `/usr/share/swift/usr/bin` 的目录中，并且该目录也已经设置在环境的 PATH 中，因此通常无需指定绝对路径，vscode
便可以使用 swift 的 lsp 功能。如果你自己单独下载了新版本的 lsp，可以在 `settings.json` 中设置对应的路径。

JSON

Copy code

Copied!

    "sourcekit-lsp.serverPath": "/usr/share/swift/usr/bin/sourcekit-lsp"

安装完成后，vscode 便可支持代码自动补全、定义跳转等功能。

![swift_in_linux_lsp_demo](https://cdn.fatbobman.com/swift_in_linux_lsp_demo.gif)

## LLDB

### 什么是 LLDB

`LLDB` 调试器是 `LLVM` 项目的调试器组件。它构建为一组可重用的组件，这些组件广泛使用 `LLVM` 中的现有库，例如 `Clang` 表达式解析器和 `LLVM` 反汇编程序。通过 `LLDB` ，让 `vscode` 拥有了对 Swift 代码进行调试的能力。

### 安装 LLDB

由于 Swift Toolchain 当前已经集成了 `LLDB` ，因此我们无需对其进行安装，只需要安装 vscode 的 lldb 插件即可。

在 vscode 的插件市场中，安装 `CodeLLDB`

![image-20210214160313240](https://cdn.fatbobman.com/swift_in_linst_install_lldb_in_market.png)

在 `settings.json` 中指定 `lldb` 的位置

JSON

Copy code

Copied!

    "lldb.library": "/usr/share/swift/usr/lib/liblldb.so"

也可以在 `settings UI` 中设定

![image-20210214170242254](https://cdn.fatbobman.com/swift_in_linux_setting_lldb_path.png)

### 调试配置文件

在 vscode 中用 lldb 对项目进行调试，需要在项目的 `.vscode` 目录中针对每个项目分别创建调试配置文件 `launch.json` 和 `tasks.json` 。

`launch.json` 是 vscode 用于调试的配置文件，比如指定调试语言环境，指定调试类型等等。其作用和 `XCode` 中的
target 类似。在 swift 项目中，我们通常会设置两个 `configuration` ，一个用于调试程序，一个用于进行 `Unit
testing` 。

    $cd MyProject
    $code .

在第一次点击左侧的 `run` 按钮时，vscode 会提示创建 `launch.json` 文件，我们也可以自己手动在 `.vscode`
目录中创建该文件。

![image-20210214172254927](https://cdn.fatbobman.com/swift_in_linx_create_lanchjson.png)

**launch. json**

JSON

Copy code

Copied!

    {
        "version": "0.2.0",
        "configurations": [
            {
                "type": "lldb",
                "request": "launch",
                "name": "Debug",
                "program": "${workspaceFolder}/.build/debug/MyProject",
                "args": [],
                "cwd": "${workspaceFolder}",
                "preLaunchTask": "swift-build"
            },
            {
                "type": "lldb",
                "request": "launch",
                "name": "unit testing on Linux",
                "program": "./.build/debug/MyProjectPackageTests.xctest",
                "preLaunchTask": "swift-build-tests"
            }
        ]
    }

- type

用于此启动配置的调试器的类型，swift 调试需设置成 lldb

- request

此启动配置的请求类型，swift 调试需设置成 launch，

- name

在调试启动配置下拉列表中的显示名称

- program

可执行文件的位置。使用 `swift build` 编译后（不加 realase 参数）的执行文件被放置在 `项目目录${workspaceFolder}/.build/debug/` 下，文件名通常为项目名称（本例为 MyProject）； `swift
build -c release` 编译后的执行文件放置在 `${workspaceFolder}/.build/release/`
下，文件名为项目名称（本例为 MyProject）; `unit testing` 的可执行文件放置在 `${workspaceFolder}/.build/debug/` ，文件名通常为 `项目名称 PackageTests.xctest` （本例为
MyProjectPackageTests. xctest）。请根据每个项目的名称、配置设定该项。

- args

传递给程序的参数。比如你的项目支持启动参数设定 `MyProject name hello` ，则 `args` 为 `["name","hello"]`

- cwd

当前工作目录，用于查找依赖关系和其他文件

- preLaunchTask

要在调试会话开始之前启动的任务，每个任务都需要在 `tasks.json` 中有对应的设定。比如本例中， `swift-build` 对应着
tasks. json 中的 `label:swift-build` 的 task。对于 swift 项目，在调试前最常作的工作便是编译。

**tasks. json**

JSON

Copy code

Copied!

    {
        "version": "2.0.0",
        "tasks": [
            {
                "label": "swift-build",
                "type": "shell",
                "command":"swift build"
            },
            {
                "label": "swift-build-tests",
                "type": "process",
                "command": "swift",
                "args": [
                    "build",
                    "--build-tests"
                ]
            }
        ]
    }

- lable

同 `launch.json` 中的 `preLaunchTask` 对应

- type

`shell` 或 `process` ，为了更好的演示，本例中两种形式都采用了。

- command

如果 `type` 为 `process` ， `commnad` 只能为需要执行命令的可执行文件名称（不可带参数），在本例中为 `swift` , 如果 `type` 为 `shell` 则可以在 `command` 中直接写上需要调用的参数，比如 `swift build`

- args

对于 `type` 为 `process` 的情况，需要调用的参数在此填写。在本例中， `swift-build-tests` 也可以写成

JSON

Copy code

Copied!

    "label": "swift-build-tests",
    "type": "shell",
    "command": "swift build --build-tests"

`launch.json` 和 `tasks.json` 还有很多其他的选项，更多的用法请参阅 [ vscode 手册
](https://code.visualstudio.com/docs/editor/debugging) 以及 [ SPM 手册
](https://docs.swift.org/package-manager/) 。

现在我们就可以开始对 Swift 项目进行调试了

### 第一次调试

    $cd MyProject
    $code .

随便给 main. swift 添加点内容，比如：

    import Foundation
    let a = 100
    print("Hello, world!\(Int.random(in: 0...100))")
    print("a:\(a)")

![swift-in-linux-lldb-demo](https://cdn.fatbobman.com/swift-in-linux-lldb-
demo.gif)

## SwiftFormat

### 为什么要对代码 Foramt

许多项目都有固定的代码风格，统一的代码规范不仅有助于项目的迭代和维护，同时也让代码更加美观和易读。但并不是每个程序员都能够掌握并熟练使用项目风格约定。通过使用自动化工具完成上述工作是让人十分惬意的事情。

Swift 社区中有多个 Format 项目，目前最活跃的有 `nicklockwood` 的 [ swiftformat
](https://github.com/nicklockwood/SwiftFormat) 和 `Apple` 的 [ swift-format
](https://github.com/apple/swift-format) 。本例中，我们选择安装 `nicklockwood` 的 [
swiftformat ](https://github.com/nicklockwood/SwiftFormat) 。两者的安装方法类似，相对来说 `swiftformat` 支持的规则更多，另外同 Swift 的版本也不像 `swift-foramt` 那样需要严格绑定。

### 安装命令行工具

    $cd ~
    $git clone https://github.com/nicklockwood/SwiftFormat.git
    $cd SwiftFormat
    $swift build -c release
    $sudo cp ~/SwiftFormat/.build/release/swiftformat /usr/local/bin
    $swiftformat --version
    0.47.11

### 安装 vscode 插件

`swiftformat` 、 `swift-format` 以及 `swiftlint` 的 vscode 插件都是由 [ Valentin
Kabel ](https://github.com/vknabel) 开发的，他同时还管理、开发了其他及个 vscode 下的 swift 插件，为在
vscode 上更好的使用 swift 作出了不小的贡献。

在插件商店选择 swiftformat 对应的插件（注意不要选错）。

![image-20210214211153478](https://cdn.fatbobman.com/swift-in-linux-
swiftformat-plugin-install.png)

在 `settings.json` 中添加

JSON

Copy code

Copied!

    "swiftformat.path": "/usr/local/bin/swiftformat",
    "swiftformat.configSearchPaths": [
            "./swiftformat",
            "~/.swiftformat"
            ]

`swiftformat` 将从 `Swiftformat.configSearchPaths` 设定的路径中尝试查找用户自己创建的配置文件（ `.swiftformat` ），上面的配置为，如果当前目录没有，则从用户根目录上查找。如果都没有则使用默认配置和规则。

![swift-in-linux-format-demo](https://cdn.fatbobman.com/swift-in-linux-format-
demo.gif)

`swiftformat` 目前包含 50 多个规则，它的文档做的很好，可以在 [ Rules.md
](https://github.com/nicklockwood/SwiftFormat/blob/master/Rules.md)
中找到最新的规则列表及演示。需要注意的是，vscode 目前无法正确的响应 `swiftformat` 自定义配置中的 `--indent`
，需要在 vscode 中对 `indent` 做单独的设定（我目前采用的是通过 `EditorConfig for VS Code`
做统一设置）。另外，如果通过 `swift.options:["--config","~/rules/.swiftformat"]`
指定的规则文件的优先级高于 `swiftformat.path` 中的规则文件。

## SwiftLint

### 让代码更规范

在计算机科学中，lint 是一种工具程序的名称，它用来标记源代码中，某些可疑的、不具结构性的段落。它是一种静态程序分析工具，最早适用于 C 语言，在
UNIX 平台上开发出来。后来它成为通用术语，可用于描述在任何一种计算机程序语言中，用来标记源代码中有疑义段落的工具。swift
社区中，被使用的最广泛的就是 `realm` 开发的 [ SwiftLint ](https://github.com/realm/SwiftLint)
。

其实，上面的 swiftformat、swift-format 都具有 lint 的功能，并且和 swiftlint 在很多地方的规则都类似（都基于 [
Github’s Swift Style Guide ](https://github.com/realm/SwiftLint)
），但各自的特点还是略有不同。

swiftformat 更多的表现在对代码的自动修改上，而 swiftlint 由于直接 hook 了 Clang 和 Sourcekit，因此提供了
swiftformat 所不具备的，代码录入阶段的实时验证和提示功能（通常并不使用它的 `autocorrect` ）。

### 安装 SwiftLint

    $git clone https://github.com/realm/SwiftLint.git
    $cd SwiftLint
    $swift build -c release
    $sudo cp ~/SwiftLint/.build/release/swiftlint /usr/local/bin
    $swiftlint --version
    0.42.0

### 安装 swiftlint vscode 插件

在 vscode 插件市场中安装 swiftlint 插件

![image-20210215073043096](https://cdn.fatbobman.com/swift-in-linux-swiftlint-
plugin.png)

在 `settings.json` 中添加

JSON

Copy code

Copied!

    "swiftlint.path": "/usr/local/bin/swiftlint"，
    "swiftlint.toolchainPath": "/usr/share/swift/usr/bin",
    "swiftlint.configSearchPaths": [
            "./.swiftlint.yml",
            "~/.swiftlint.yml"
        ]

`configSearchPath` 的设置同 `swiftformat` 类似，如果不需要自定义配置，则无需填写。

![swift-in-linux-lint-demo](https://cdn.fatbobman.com/swift-in-linux-lint-
demo.gif)

## 跨平台配置

我们已经在 Ubuntu 20.04 上构建了一个较完整的 Swift 开发环境。

### settings

如果你也像我一样使用了 vscode 的 setting 同步功能，那么在其他的平台（比如 mac），上述的 settings. json 将无法正常使用。

为了让我们构建的开发环境适应多平台，需要启用配置的多平台支持，并且针对不同平台分别设定。

安装 `platform-settings` 插件

![image-20210215091440441](https://cdn.fatbobman.com/swift-in-linux-platform-
settings.png)

修改 `settings.json`

当前为：

JSON

Copy code

Copied!

    {
        "sourcekit-lsp.serverPath": "/usr/share/swift/usr/bin/sourcekit-lsp",
        "lldb.library": "/usr/share/swift/usr/lib/liblldb.so",
        "swiftformat.path": "/usr/local/bin/swiftformat",
        "swiftformat.configSearchPaths": [
            "./swiftformat",
            "~/.swiftformat"
        ],
        "swiftlint.path": "/usr/local/bin/swiftlint",
        "swiftlint.toolchainPath": "/usr/share/swift/usr/bin",
        "swiftlint.configSearchPaths": [
            "./.swiftlint.yml",
            "~/.swiftlint.yml"
        ]
    }

修改为：

JSON

Copy code

Copied!

    {
        "platformSettings.autoLoad": true,
        "platformSettings.platforms": {
            "linux":{
                "sourcekit-lsp.serverPath": "/usr/share/swift/usr/bin/sourcekit-lsp",
                "lldb.library": "/usr/share/swift/usr/lib/liblldb.so",
                "swiftformat.path": "/usr/local/bin/swiftformat",
                "swiftlint.path": "/usr/local/bin/swiftlint",
                "swiftlint.toolchainPath": "/usr/share/swift/usr/bin",
            },
            "mac":{
                "sourcekit-lsp.serverPath": "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/sourcekit-lsp",
                "lldb.library": "/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Versions/A/LLDB",
                "swiftformat.path": "/usr/local/bin/swiftformat", //homebrew 目前也恰巧安装在此
                "swiftlint.path": "/usr/local/bin/swiftlint", //指向工具的实际路径
                "swiftlint.toolchainPath": "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin",
            }

        },
        "swiftformat.configSearchPaths": [
            "./swiftformat",
            "~/.swiftformat"
        ],
        "swiftlint.configSearchPaths": [
            "./.swiftlint.yml",
            "~/.swiftlint.yml"
        ]
    }

### launch. json

在 mac 平台下， `unit testing` 的调用方式也和 linux 下不同，因此需要在 `launch.json` 中添加一个 `configuration` ，由于使用同一个 `preLauchchTask` ，因此 `tasks.json` 不用改动。

JSON

Copy code

Copied!

           {
                "type": "lldb",
                "request": "launch",
                "name": "Debug tests on macOS",
                "program": "/Applications/Xcode.app/Contents/Developer/usr/bin/xctest", //For example /Applications/Xcode.app/Contents/Developer/usr/bin/xctest
                "args": [
                    "${workspaceFolder}/.build/debug/MyProjectPackageTests.xctest"
                ],
                "preLaunchTask": "swift-build-tests"
            },

![image-20210215092656451](https://cdn.fatbobman.com/swift-in-linux-launch-
multiform.png)

在不同的平台上，选择对应的 target 即可。

## 结语

希望本文能够帮助更多的朋友在 Linux 上使用 Swift 进行开发。

# 介绍几个我在开发健康笔记 2 用到的 Swift 或 SwiftUI 第三方库

## [ SwiftUIX ](https://github.com/SwiftUIX/SwiftUIX)

> SwiftUIX 试图弥补仍处于新生阶段的 SwiftUI 框架的空白，提供了广泛的组件，扩展和实用程序套件来补充标准库。迄今为止，该项目是缺少的
> UIKit / AppKit 功能的最完整的移植，力求使其以大多数类似于 Apple 的方式交付。 这个项目的目标是补充 SwiftUI
> 标准库，提供数百种扩展和视图，使开发人员可以轻松地通过 SwiftUI 的革命来构建应用程序。

提供了非常多的苹果本应提供但没有提供的功能扩展。项目的发起者非常年轻，但 mac
的开发经验十分丰富。到目前为止一直保持的较高的更新频率和维护状态。这个库同时支持 UIKit 和
Appkit，对于需要做苹果生态全平台的用户十分友好。由于目前 SwiftUI 的 List 和 LazyVStack
的问题还很多，他自己在开发中也深受其苦，前天在交流中，他已经决定重做 CocoaList 功能，尤其提高对 Fetchrequest 的支持。

对于进行 SwiftUI 开发的朋友，它是十分值得推荐的。

目前的问题是文档太少。不过对我来说也未尝不是一个好事。在研究它的用法过程中，给了我更多的机会阅读并学习它的代码，对 SwiftUI，UIkit
等有了更多的认识和了解。

## [ Charts ](https://github.com/danielgindi/Charts)

> denielgindi 对著名的安卓图表库 MPAndroidChart 的 Swift 移植。是目前不多的纯 Swift
> 解决方案。它的优势也是同时支持 UIKit 和 Appkit，同时提供了不错的 Demo 社区活跃度。

不过他的开发者好像不打算在 3. x
版本上在增加太多的功能，非常多目前急需并且已有解决方案的功能并没有被当前版本接受。所以整体的视觉呈现还是比较传统的。社区上对于功能的讨论不少，但合并的极少，4.0
的版本好像也已经开发了不短的时间了，不过进度好像也不是特别理想。

从效率上讲，Charts 应该是非常合格的了。

[ 航歌 ](https://www.hangge.com) 上面有非常详细的中文使用教程，对我的学习帮助很大。

为了健康笔记开发的需要，我在当前 3.6 的版本上合并了两个社区上较为成熟的解决方案：

- 圆角 Bar

  dataSet.roundedCorners = [.topLeft,.topRight]

- 渐变色 Bar

  dataSet.drawBarGradientEnabled = true
  dataSet.colors = [UIColor(named: "barColor1")!, UIColor(named: "barColor1")!, UIColor(named: "barColor2")!]
  dataSet.gradientPositions = [0, 40, 100]

由于当前的 Charts 本身并不支持对于图表滚动后停止事件的响应，我自己为它增加了停止响应。

            //滚动终止时调用
            func chartScrollStop(_ chartView:ChartViewBase){
                print("stopped")
            }

修改后的代码 [ 在此可以获得 ](https://github.com/fatbobman/Charts) 。

## [ Introspect ](https://github.com/siteline/SwiftUI-Introspect)

> Introspect 允许您获取 SwiftUI 视图的基础 UIKit 或 AppKit 元素。 例如，使用 Introspect，您可以访问
> UITableView 来修改分隔符，或访问 UINavigationController 来自定义选项卡栏。

有一个非常推荐的利器。目前官方对于 SwiftUI 中的控件提供的可控选项很少，如果想做一些深度定制的话，通常就是自己写代码来重新包装 UIkit
控件。不过 introspect 提供了一个非常巧妙的办法通过简单的注入方式便可以对 SwiftUI 控件做更多的调整。

比如：

只有当内容超出显示范围才进行滚动

    ScrollView{
        ....
    }
    .introspectScrollView{ scrollView in
            crollView.isScrollEnabled = scrollView.contentSize.height > scrollView.frame.height
                   }

显示 TextField 的 clear 按钮

    TextField("note_noteName",text: $myState.noteName)
              .introspectTextField{ text in
                 text.clearButtonMode = .whileEditing
               }

对于新的控件它本身还没提供具体支持的也可以方便的注入

修改 SwiftUI 2.0 中新提供的 TextEditor 背景色

    TextEditor(text: $text)
                    .introspect(selector: TargetViewSelector.sibling){ textView in
                        textView.backgroundColor = .clear
                    }

等等。类似的用法在我整个的开发中的使用频率是很高的。

## [ SwiftDate ](https://github.com/malcommac/SwiftDate)

> 使用 Swift 编写的时间日期处理库。同时支持苹果平台以及 Linux。

它提供了非常详尽的文档，航哥上也有非常好的中文教程。

由于健康笔记需要对数据进行不少处理，尤其是需要将相同时间粒度的数据进行合并比较。SwiftDate 提供的 Region 方案提供了完美的解决途径。

在 SwiftDate 中，我多数使用它提供的 DateInRegion 来处理日期。通过

    SwiftDate.defaultRegion = region

我几乎无需关心日期的本地化问题。而且它也提供了部分的日期时间的本地化显示方案（但并不完美）。

一些使用举例：

除非用户在 app 中设定了特定的时区，否则使用当前设备的默认设置：

    if let data = UserDefaults.standard.data(forKey: "dateRegion"),
               let region = try? JSONDecoder().decode(Region.self, from: data) {
                SwiftDate.defaultRegion = region
            }
            else {
                SwiftDate.defaultRegion = Region(calendar: Calendars.gregorian, zone: Zones.current, locale: Locales.current)
            }

判断某个日期和指定日期的天数差（本地时区）：

    let startDate = DateInRegion(datas.first!.viewModel.date1).dateTruncated(at: [.hour,.minute,.second])!
    duration = date.difference(in: .day, from: startDate) ?? 0

如果你的程序需要对日期进行频繁的处理或者有较多的本地化需求时，SwiftDate 是非常好的选择！

## [ SwiftUIOverlayContainer

](https://github.com/fatbobman/SwiftUIOverlayContainer)

> SwiftUIOverlayContainer
> 本身并不提供任何预置的视图样式，不过通过它，你有充分的自有度来实现自己需要的视图效果。OverlayContainer
> 的主要目的在于帮助你完成动画、交互、样式定制等基础工作，使开发者能够将时间和精力仅需投入在视图本身的代码上。

这是我自己写的一个库，这次通过它实现的屏幕侧边滑动菜单。

本来它的用途主要不是做这个的，暂时使用它来完成侧向滑动菜单也是权宜之计，表现尚可。

## [ ZIPFoundation ](https://github.com/weichsel/ZIPFoundation)

> ZIP Foundation 是一个用于创建，读取和修改 ZIP 存档文件的库。 它是用 Swift 编写的，基于 Apple 的
> libcompression 来实现高性能和高能效。

小巧、高效，使用便捷。健康笔记在数据导入导出时，使用它来完成 zip 文件的操作。

比如解压备份数据：

    //打开沙盒读取权限
       _ = url.startAccessingSecurityScopedResource()
    //解压
       do {
          try FileManager.default.unzipItem(at: url, to: URL(fileURLWithPath: NSTemporaryDirectory()))
            }
            catch {

            }

## [ MarkdownView ](https://github.com/keitaoouchi/MarkdownView)

> 基于 WKwebView 实现的 Markdown 文件 Viewer。对 md 的解析是通过调用 js 库来完成的。

由于 SwiftUI 的 Text 文本排版能力几乎为零，因此我选择使用 md 格式来保存 app 所需的一些文字显示，比如隐私政策等。

MarkdownView 的渲染效率一般，但我的显示需求并不大，所以感觉不明显。但它的开发者对 js 文件进行了加扰处理，所以如果你想对其中它所调用的例如
mardown-it 进行更多配置的话，就几乎不可能了。

另外，通过 UIViewRepresentable 对其进行封装，在 SwiftUI 下是无法正确获取 frame 的尺寸的，从而无法正确显示。我对于
UIkit 所知甚少，只能做了最简单的修改，勉强让其可以在 SwiftUI 下完成所需要的功能。

修改后的版本可在 [ 这里下载 ](https://github.com/fatbobman/MarkdownView)

另外，我在 UIViewRepresentable 包装中增加了一些简单的修改，使其可以方便的将 md 中的图片，替换成 Bundle 中的本地图片。

调用代码 [ 下载
](https://github.com/fatbobman/ShareCode/blob/main/MarkDownView.swift)

## [ ExcelExport

](https://github.com/avielg/ExcelExport/blob/master/Sources/ExcelExport/ExcelExport.swift)

> 生成 XSL 文件的 Swift 代码。

这段代码有一段时间了，不过去年又做了更新，不过我感觉更新后的版本还不如之前的。但它的新版本不支持 Date 的字段导出，老版本导出的 Date 字段格式在
Excel 中也有问题。我合并了两个版本，并且让其在命名上对 SwiftUI 更加友好。

修改后的代码 [ 下载 ](https://github.com/fatbobman/ShareCode/blob/main/ExcelExport)

必须对日期做如下处理，日期字段才能被 Excel 顺利识别

     let date = DateInRegion(memo.viewModel.date).toFormat("yyyy-MM-dd")
     let time = DateInRegion(memo.viewModel.date).toFormat("HH:mm:ss.FFF")
     let dateCell = ExcelCell(date + "T" + time,type: .dateTime)

上述的库都被使用在 [ 健康笔记 2.0 ](https://apps.apple.com/us/app/health-
notes-2/id1534513553) 中。如想查看更多的演示，可以移步

# 掌握 Core Data 中的关系：基础

在众多关于 Core Data 的讨论中，“对象图管理”无疑是一个频繁出现的核心概念。作为一个颇具盛名的对象图管理框架，Core Data
如何精确描述并有效管理不同数据实例之间的复杂关系，成为了它的关键任务。事实上，管理关系的能力不仅构成了 Core Data
的核心特征，也是其相较于其他数据持久化框架的一大显著优势。在本文中，我们将深入探讨 Core Data
中关系的基本概念，同时提供关于实现这些关系的重要指导和建议。

在本文中，我们将深入探讨与关系相关的基础知识。这些概念不仅在 Core Data 中至关重要，同样也适用于其后继框架——SwiftData。

> 本文旨在为已具备一定 Core Data 关系知识和实践经验的读者提供进阶理解和应用的视角，并非旨在提供一个全面的教程。

## 关系的定义

在 Core Data
的世界里，关系是构筑实体（Entity）间相互联系的桥梁，它决定了一个实体如何对另一个实体产生影响。在大多数情况下（抽象实体除外），Core Data
中的每一个实体定义都对应着 SQLite 数据库中的一个表。因此，从底层实现的角度来看，Core Data
中的关系可以被看作是一种在不同表间建立联系和进行操作的机制。

## 关系的类型

在 Core Data 的架构中，实体间关系的描述方式多样。从实体间的引用角度出发，这些关系大致分为单向关系和双向关系。

单向关系存在于当一个实体（A）引用另一个实体（B），但 B 不反向引用 A 的情形。尽管在特定场景下，如 A 需要了解 B 的信息而 B 不需要知道 A
的详情时，单向关系可以满足要求，但考虑到数据的完整性和对象图的维护，双向关系往往是更优选择。

双向关系则是指当一个实体（A）引用另一个实体（B），同时 B 也反向引用 A 的情况。这种关系使得 Core Data
能够更有效地管理对象间的联结，并为开发者提供了从多个实体角度调用其他关联实体的更大灵活性。

在这种双向关系框架下，我们进一步可以将关系划分为三种主要类型：

1. 一对一（One-to-One）关系:
   - 定义: 一个实体（A）中的单个实例与另一个实体（B）中的单个实例相关联。
   - 用途: 适用于两个实体间存在独特且直接的联系时。
   - 示例: 个人（Person）与其护照（Passport）的关系。
2. 一对多（One-to-Many）关系:
   - 定义: 一个实体（A）中的单个实例与另一个实体（B）中的多个实例相关联。
   - 用途: 当一个实体能与另一个实体的多个实例建立联系时。
   - 示例: 用户（User）与其发布的多条帖子（Posts）。
3. 多对多（Many-to-Many）关系:
   - 定义: 一个实体（A）中的多个实例与另一个实体（B）中的多个实例相互关联。
   - 用途: 适用于两个实体间的实例可以自由组合关联的场景。
   - 示例: 文章（Article）与标签（Tag）之间的关系，其中一篇文章可以拥有多个标签，同时不同的文章也可以使用相同的标签进行标记。

在 Core Data 中，构建的关系越多，对象图越丰富，也就越复杂，这对 Core Data 的对象图管理能力构成了挑战。

## 逆向关系

在 Core Data 中，当我们建立双向关系后，框架会要求我们为这些关系指定逆向关系（Inverse
Relationship）。虽然苹果的官方文档明确要求必须设定逆向关系，但由于在许多情况下，即使未设置逆向关系，应用程序也能正常运行，因此一些开发者对是否真的需要设置逆向关系产生了疑问。

为了更好地理解在 Core Data
中使用逆向关系的必要性，我们需要深入了解逆关系的概念及其作用。尽管我们可能已经在两个实体间使用了双向关系，但如果不设置逆关系，对其中一侧实体的修改可能不会自动反映到另一侧。逆关系是一种数据模型设计概念，它在两个实体间的
**关系管理** 中起着关键作用。

逆关系的设置带来以下好处：

- 数据完整性

这是一个常见的疑问点。虽然开发者在未设置逆关系的情况下可能从未遇到数据不一致的问题，但在某些特定情况下，不设置逆关系可能导致预期之外的结果。

考虑这样一个例子：假设 A 和 B 之间存在着一个 `One-to-One` 、非可选的关系，且其删除规则设为 `Cascade` 。同时，B 和
A 之间也是 `One-to-One` 、非可选关系，但删除规则为 `Nullify` 。在未设置逆关系的情况下，直接删除 B
的实例的操作是被允许的，这与预期相悖，因为根据上述设置，删除操作理应只能从 A 端发起。如果设置了逆关系，Core Data 就会从 A
的角度检查是否允许执行删除操作。由于发现 A 与 B 之间是非可选的关联，Core Data 会阻止删除操作，从而确保数据的完整性和一致性得到维护。

逆关系在维护数据完整性方面发挥着关键作用。当你在一个实体中更新关系时，其逆关系会自动进行更新，确保不同实体间的数据保持同步和一致。

- 查询优化

Core Data 根据其所掌握的信息生成 SQL 语句。逆关系的存在可以丰富这些信息，从而优化查询条件和提升查询效率。

- 高效的内存管理

尽管官方文档中没有直接提到逆关系对内存管理的作用，但通过理解 Core Data
中的对象和引用管理原则，我们可以推断出逆关系对内存管理的潜在益处。逆关系简化了引用管理，确保对象根据对象图的当前状态得到适当的保留或释放。

因此，尽管某些开发者可能认为设定逆关系对他们本身看似无关紧要，它实际上为 Core Data 提供了重要的信息，帮助框架更有效地进行对象图管理。

> 在 SwiftData 中，对于某些关系类型，即使开发者没有显式设置逆关系，SwiftData 也会自动在数据模型中补充逆关系信息。

## 删除规则

在 Core Data 中，删除规则（Delete
Rules）起着关键作用，它们定义了在删除一个实体对象时如何处理与该对象关联的其他实体对象。选择合适的删除规则对于维护数据完整性和避免数据库中的悬空引用极为重要。Core
Data 提供了四种基本的删除规则：

1. Nullify（置空）:
   - 应用此规则时，删除对象会导致所有相关联对象的对应关系属性被置为空。
   - 这种方式相当于“解除关系”，而不是删除关联对象，仅移除双方的连接。
   - 通常适用于关系中的弱侧。例如，在一个主题（Topic）和多个附件（Attachment）的关系中，删除一个附件不会导致主题被删除。
2. Cascade（级联）:
   - 在删除对象时，所有与之关联的对象也会被删除。
   - 适用于强依赖关系，即关联对象在主对象不存在时没有存在意义。
   - 例如，如前文逆关系部分所述，A 作为关系中强侧的一方，采用了 `Cascade` 规则，这意味着删除 A 也会导致所有与 A 直接相关的 B 实体被删除。
3. Deny（拒绝）:
   - 若关联对象仍存在，则阻止删除操作。
   - 此规则用于确保不会因删除一个对象而产生悬空引用。
   - 例如，家庭成员对象不能独立于家庭存在，那么在家庭中至少存在一个成员的情况下，不允许删除家庭对象。
4. No Action（无操作）:
   - 删除对象时，不对关联对象做任何处理。
   - 可能会造成悬空引用，因此使用时需特别小心。
   - 实质上，这意味着开发者需自行处理相关的删除逻辑，而非由 Core Data 自动管理。

在设计数据模型时，选择合适的删除规则至关重要，因为它直接影响数据的完整性和应用的逻辑稳定性。通常情况下， `Nullify` 和 `Cascade`
因为能够有效管理关系的生命周期而被广泛使用，而 `Deny` 和 `No Action` 则需要在特定场景下谨慎使用。

## 有序关系

在 Core Data 中， `to-Many` 关系分为无序和有序两种形式。默认情况下，“对多”关系是无序的（对应 `NSSet`
类型，保证对象的唯一性，但不保证顺序）。开发者可以通过在数据模型中勾选 `ordered` 选项来将此关系设置为有序（对应 `NSOrderedSet` 类型）。

虽然官方文档和大多数第三方文章通常不会详细解释有序关系的底层实现，但通过分析其在 SQLite 中的数据结构，我们可以对其基本逻辑有所了解。

简而言之，对于有序关系的一方，Core Data 会创建一个类似索引的内部属性（字段）。例如，在 Item 和 Tag 之间存在一对多的有序关系时，Core
Data 会在 Tag 对应的表中添加一个 `Z_FOK_ITEM` 字段，并按顺序给它填充数字。为了避免因位置调整而频繁地更新所有索引，Core
Data 在相邻两个位置之间预留了一定的数字空间。

![image-20240102100725036](https://cdn.fatbobman.com/image-20240102100725036.webp)

有序关系的主要优势在于它提供了一系列方便的预置方法，如 `insertIntoTags(_:at:)` 和 `replaceTags(at:with:)`
等。这些方法只适用于操作隐藏的索引属性。然而，在更多的情况下，开发者通常会根据自己的需求创建专门用于排序的属性和相应的顺序处理机制。

## 关系与批量操作

在 Core Data
中，关系的验证和操作通常是在托管对象上下文（NSManagedObjectContext）中执行的。由于批量操作绕过了上下文处理，因此这些操作往往会忽略数据模型中设置的大多数关系规则（如验证、删除规则等）。然而，在进行批量删除操作时，Core
Data 仍会自动处理以下两种情况：

- 采用 Cascade 删除规则的关系：

例如，假设 Item 实体有一个名为 `attachment` 的关系（无论是一对一还是一对多），且该关系在 Item 端的删除规则设置为 `Cascade` 。当对 Item 实体进行批量删除操作时，Core Data 会自动删除所有与之关联的 Attachment 实体。

- 删除规则为 Nullify 且关系为可选：

假如 Item 实体有一个名为 `attachment` 的关系（无论是一对一还是一对多），且该关系在 Item 端的删除规则设置为
Nullify，并且关系被标记为可选（Optional）。在这种情况下，当对 Item 实体进行批量删除操作时，Core Data 会将所有相关
Attachment 实体中的关系 ID（指向 Item）设置为 NULL，但并不会删除这些 Attachment 实体。

> 想要深入了解 Core Data 中的批量操作，建议阅读 “ [ 如何在 Core Data 中进行批量操作
> ](/zh/posts/batchprocessingincoredata/) ” 这篇文章。

## 关系的懒加载特性及其应用

在 Core Data
中，托管对象的按需数据填充是一个关键功能。默认情况下，从持久化存储库中检索的托管对象初始状态为“惰性”（Fault），这意味着对象数据不会立即完全加载。只有当真正需要访问该对象的特定属性时，Core
Data 才会从行缓冲区或持久化存储中加载完整数据（即转为“实现”状态，Fulfilled）。为了优化性能，开发者可以通过设置 `NSFetchRequest` 的 `returnsObjectsAsFaults` 属性为 `false`
来在初次获取数据时即刻完成数据的加载，从而避免后续的二次 IO 操作。

这种按需加载的机制使得 Core Data 在性能效率和内存占用之间达到了良好的平衡。

然而，即使 `returnsObjectsAsFaults` 被设置为 `false` ，Core Data
也不会自动加载与当前实例相关的其他关系数据。如果开发者希望在获取特定实体 A 的同时预先加载其相关联的实体 B，可以在 `NSFetchRequest`
的 `relationshipKeyPathsForPrefetching` 属性中指定相关关系。例如：

    let request = NSFetchRequest<Item>(entityName: "Item")
    request.relationshipKeyPathsForPrefetching = ["Tag"]

正是由于这种懒加载特性，开发者在设计数据模型时会采取一些策略来优化性能和内存使用。例如，对于一个包含图片的 `Image`
实体，如果通常只需要显示图片的缩略图，可以将完整图片数据放在一个单独的 `ImageData`
实体中，并通过关系连接。这样，可以充分利用懒加载特性，在需要时才加载完整的图片数据，从而减少内存占用并提高应用的响应速度。

    class Image: NSManagedObject {
      @NSManaged var thumbnail: Data
      @NSManaged var Post: Post?
      @NSManaged var data: ImageData?
    }

    class ImageData: NSMangedObject {
      @NSManged var data: Data
    }

## 关系是如何在 SQLite 中标识的

Core Data 利用了在同一个数据库中仅需依靠 Z_ENT + Z_PK
即可定位记录的特性来实现了在不同的实体之间标注关系的工作。为了节省空间，Core Data 仅保存了每个关系记录的 Z_PK 数据，Z_ENT
则直接由数据模型从 Z_PRIMARYKEY 表中获取。

在数据库中，创建关系的规则如下：

- 一对多关系：

在“一”的一方不会创建新字段，而在“多”的一方会为关系创建新字段，该字段保存“一”方的 Z_PK 值。字段的名称通常是“Z”加上关系名称（大写形式）。

- 一对一关系：

关系的两端都会添加新字段，各自保存对方数据的 Z_PK 值。

- 多对多关系：

在关系的两端都不添加新字段，而是创建一个新的关联表来表示这种多对多关系。该表中逐行添加关系两端数据的 Z_PK 值。

例如，在下图所示的情况中，Item 和 Tag 之间存在多对多关系，Core Data 为此创建了 Z_2TAGS 表来管理这两个实体之间的关系数据。

![relationship](https://cdn.fatbobman.com/image-20220528162005978.png)

> 想要更深入了解 Core Data 如何在 SQLite 中存储数据，请参阅文章 “ [ Core Data 是如何在 SQLite 中保存数据的
> ](/zh/posts/tables_and_fields_of_coredata/) ” 以获取更多底层存储实现的细节。

## 在 Core Data with CloudKit 中的关系设置要求

随着 Core Data with CloudKit
的日益普及，越来越多的开发者开始在他们的应用中集成这项技术，以便为用户提供云存储和跨设备数据同步功能。在启用 Core Data with CloudKit
功能时，需要遵循一些特定的关系设置规则：

- 关系必须设为可选（ `Optional` ）
- 必须定义逆向关系
- 不支持 `Deny` 的删除规则
- 不支持有序关系

在设计支持 CloudKit 的 Core Data 数据模型时，遵循这些规则非常重要，因为它们直接影响到云数据的同步机制和整个应用的数据完整性。

> 欲了解更多关于 Core Data with CloudKit 的细节，请参阅 “ [ Core Data with CloudKit 系列文章
> ](/zh/posts/coredatawithcloudkit-1/) ”。

## 持久化存储内部的关系限制

在 Core Data
的应用中，虽然我们可以通过在模型编辑器中设置多个配置（Configurations），对应于不同的持久化存储描述（NSPersistentStoreDescription），来在不同的持久化存储中保存多种实体配置，但存在一定的限制。

具体而言，关系的创建只能局限于同一个持久化存储或配置内的实体之间。这意味着，关系只能在同一个 SQLite 数据库文件中的不同表间建立。这是由于 Core
Data 的底层存储逻辑决定的，它依赖于相同数据库文件内的表之间的关联，以维护数据的完整性和一致性。

因此，当设计涉及多个持久化存储的 Core Data 应用时，需要特别注意这一点，确保所有需要相互关联的实体都位于同一个配置内。

## 在什么情况下考虑使用关系

在 Core Data 模型中合理地使用关系，对于表示实体间的联系、提高数据操作效率和保证数据完整性都至关重要。以下是在什么情况下考虑使用关系的一些建议：

1. **多实体引用同一类型数据** ：当某种类型的数据可能被多个实体引用时，应该将其定义为一个单独的实体，并通过关系进行关联。这避免了在多个实体中重复定义相同的属性。
2. **实体间的业务逻辑关联** ：当两个或多个实体在业务逻辑上存在关联时，应通过关系来反映这种关联，例如作者与其书籍的关系。
3. **一对多或多对多复杂关系** ：在需要表达一对多或多对多的复杂关系时，关系成为模型的一个关键元素。
4. **数据一致性** ：通过设置关系的删除规则，可以在删除一个实体时自动处理相关联的数据，保持数据的一致性。
5. **优化查询效率** ：建立关系可以提高从一个实体获取关联实体数据的查询效率，并丰富查询手段。
6. **模型的清晰度和可维护性** ：关系可以明确地表示模型中的关联，提高整个数据模型的清晰度和可维护性。
7. **优化内存占用** ：对于不常用但占用资源较多的数据，可以通过关系的方式进行关联，优化内存使用。

总之，在数据模型中存在业务关联、需要表示复杂关系或者要求数据完整性的情况下，应该充分利用 Core Data
的关系特性，使模型更加清晰、高效。这不仅有助于提升应用的性能和健壮性，还能简化开发和维护过程。

## 接下来

在这篇文章中，我们对 Core Data 中的关系概念进行了基础性的介绍和整理。在下一篇文章中，我们将通过实际的代码示例来讨论在开发过程中运用 Core
Data
关系的一些技巧和经验。例如，如何在类型声明中修改关系类型，如何有效地设置和获取关系数据，以及如何在构建查询的谓词时更加巧妙地利用这些关系。这些内容旨在提供更实践的指导，帮助开发者在具体开发实践中更好地应用
Core Data 的关系管理特性。

# SwiftUI 4.0 的全新导航系统

长久以来，开发者对 SwiftUI 的导航系统颇有微词。受 NavigationView
的能力限制，开发者需要动用各种技巧乃至黑科技才能实现一些本应具备基本功能（例如：返回根视图、向堆栈添加任意视图、返回任意层级视图、Deep Link 跳转等
）。SwiftUI 4.0（ iOS 16+ 、macOS 13+ ）对导航系统作出了重大改变，提供了以视图堆栈为管理对象的新 API
，让开发者可以轻松实现编程式导航。本文将对新的导航系统作以介绍。

## 一分为二

新的导航系统最直接的变化是废弃了 NavigationView，将其功能分成了两个单独的控件 NavigationStack 和
NavigationSplitView。

NavigationStack 针对的是单栏的使用场景，例如 iPhone 、Apple TV、Apple Watch：

    NavigationStack {}
    // 相当于
    NavigationView{}
        .navigationViewStyle(.stack)

NavigationSplitView 则针对的是多栏场景，例如 ：iPadOS 、macOS：

    NavigationSplitView {
       SideBarView()
    } detail: {
       DetailView()
    }

    // 对应的是双列场景

    NavigationView {
        SideBarView()
        DetailView()
    }
    .navigationViewStyle(.columns)

![navigationSplitView_2_demo](https://cdn.fatbobman.com/navigationSplitView_2_demo.PNG)

    NavigationSplitView {
        SideBarView()
    } content: {
        ContentView()
    } detail: {
        DetailView
    }

    // 对应的是三列场景
    NavigationView {
        SideBarView()
        ContentView()
        DetailView()
    }
    .navigationViewStyle(.columns)

![navigationSplitView_3_demo](https://cdn.fatbobman.com/navigationSplitView_3_demo.png)

相较于通过 navigationViewStyle 设定 NavigationView 样式的做法，一分为二的方式将让布局表达更加清晰，同时也会强迫开发者为
SwiftUI 应用对 iPadOS 和 macOS 做更多的适配。

> 在 iPhone 这类设备中，NavigationSplitView 会自动进行单栏适配。但是无论是切换动画、编程式 API 接口等多方面都与
> NavigationStack 明显不同。因此对于支持多硬件平台的应用来说，最好针对不同的场景分别使用对应的导航控件。

## 两个组件两种逻辑

相较于控件名称上的改变，编程式导航 API 才是本次更新的最大亮点。使用新的编程式 API
，开发者可以轻松地实现例如：返回根视图、在当前视图堆栈中添加任意视图（ 视图跳转 ）、视图外跳转（ Deep Link ）等功能。

苹果为 NavigationStack 和 NavigationSplitView 提供了两种不同逻辑的 API ，这点或许会给部分开发者造成困扰。

### NavigationView 的编程式导航

NavigationView 其实是具备一定的编程式导航能力的，比如，我们可以通过以下两种 NavigationLink 的构造方法来实现有限的编程式跳转：

    init<S>(_ title: S, isActive: Binding<Bool>, @ViewBuilder destination: () -> Destination)
    init<S, V>(_ title: S, tag: V, selection: Binding<V?>, @ViewBuilder destination: () -> Destination)

上述两种方法有一定的局限性：

- 需要逐级视图进行绑定，开发者如想实现返回任意层级视图则需要自行管理状态
- 在声明 NavigationLink 时仍需设定目标视图，会造成不必要的实例创建开销
- 较难实现从视图外调用导航功能

“能用，但不好用” 可能就是对老版本编程式导航比较贴切地总结。

### NavigationStack

NavigationStack 从两个角度入手以解决上述问题。

#### 基于类型的响应式目标视图处理机制

比如下面的代码是在老版本（ 4.0 之前 ）SwiftUI 中使用编程式跳转的一种方式：

    struct NavigationViewDemo: View {
        @State var selectedTarget: Target?
        @State var target: Int?
        var body: some View {
            NavigationView{
                List{
                    NavigationLink("SubView1", destination: SubView1(), tag: Target.subView1, selection: $selectedTarget) // SwiftUI 在进入当前视图时，无论是否进入目标视图，均将创建其实例（ 不对 body 求值 ）
                    NavigationLink("SubView2", destination: SubView2(), tag: Target.subView1, selection: $selectedTarget)
                    NavigationLink("SubView3", destination: SubView3(), tag: 3, selection: $target)
                    NavigationLink("SubView4", destination: SubView4(), tag: 4, selection: $target)
                }
            }
        }

        enum Target {
            case subView1,subView2
        }
    }

NavigationStack 实现上述功能将更加地清晰、灵活和高效。

    struct NavigationStackDemo: View {
        var body: some View {
            NavigationStack {
                List {
                    NavigationLink("SubView1", value: Target.subView1) // 只声明关联的状态值
                    NavigationLink("SubView2", value: Target.subView2)
                    NavigationLink("SubView3", value: 3)
                    NavigationLink("SubView4", value: 4)
                }
                .navigationDestination(for: Target.self){ target in // 对同一类型进行统一处理，返回目标视图
                    switch target {
                        case .subView1:
                            SubView1()
                        case .subView2:
                            SubView2()
                    }
                }
                .navigationDestination(for: Int.self) { target in  // 为不同的类型添加多个处理模块
                    switch target {
                    case 3:
                        SubView3()
                    default:
                        SubView4()
                    }
                }
            }
        }

        enum Target {
            case subView1,subView2
        }
    }

NavigationStack 的处理方式有以下特点和优势：

- 由于无需在 NavigationLink 中指定目标视图，因此无须创建多余的视图实例
- 对由同一类型的值驱动的目标进行统一管理（ 可以将堆栈中所有视图的 NavigationLink 处理程序统一到根视图中 ），有利于复杂的逻辑判断，也方便剥离代码
- NavigationLink 将优先使用最接近的类型目标管理代码。例如根视图，与第三层视图都通过 navigationDestination 定义了对 Int 的响应，那么第三层及其之上的视图将使用第三层的处理逻辑

#### 可管理的视图堆栈系统

相较于基于类型的响应式目标视图处理机制，可管理的视图堆栈系统才是新导航系统的杀手锏。

NavigationStack 支持两种堆栈管理类型：

- NavigationPath

通过添加多个的 navigationDestination ，NavigationStack 可以对多种类型值（ Hashable ）进行响应，使用 `removeLast(_ k: Int = 1)` 返回指定的层级，使用 `append` 进入新的层级

    class PathManager:ObservableObject{
        @Published var path = NavigationPath()
    }

    struct NavigationViewDemo1: View {
        @StateObject var pathManager = PathManager()
        var body: some View {
            NavigationStack(path:$pathManager.path) {
                List {
                    NavigationLink("SubView1", value: 1)
                    NavigationLink("SubView2", value: Target.subView2)
                    NavigationLink("SubView3", value: 3)
                    NavigationLink("SubView4", value: 4)
                }
                .navigationDestination(for: Target.self) { target in
                    switch target {
                    case .subView1:
                        SubView1()
                    case .subView2:
                        SubView2()
                    }
                }
                .navigationDestination(for: Int.self) { target in
                    switch target {
                    case 1:
                        SubView1()
                    case 3:
                        SubView3()
                    default:
                        SubView4()
                    }
                }
            }
            .environmentObject(pathManager)
            .task{
                // 使用 append 可以跳入指定层级，下面将为 root -> SubView3 -> SubView1 -> SubView2 ，在初始状态添加层级将屏蔽动画
                pathManager.path.append(3)
                pathManager.path.append(1)
                pathManager.path.append(Target.subView2)
            }
        }
    }

    enum Target {
        case subView1, subView2
    }

    struct SubView1: View {
        @EnvironmentObject var pathManager:PathManager
        var body: some View {
            List{
                // 仍然可以使用此种形式的 NavigationLink，目标视图的处理在根视图对应的 navigationDestination 中
                NavigationLink("SubView2", destination: Target.subView2 )
                NavigationLink("subView3",value: 3)
                Button("go to SubView3"){
                    pathManager.path.append(3) // 效果与上面的 NavigationLink("subView3",value: 3) 一样
                }
                Button("返回根视图"){
                    pathManager.path.removeLast(pathManager.path.count)
                }
                Button("返回上层视图"){
                    pathManager.path.removeLast()
                }
            }
        }
    }

- 元素为符合 Hashable 的单一类型序列

采用此种堆栈，NavigationStack 将只能响应该序列元素的特定类型

    class PathManager:ObservableObject{
        @Published var path:[Int] = [] // Hashable 序列
    }

    struct NavigationViewDemo1: View {
        @StateObject var pathManager = PathManager()
        var body: some View {
            NavigationStack(path:$pathManager.path) {
                List {
                    NavigationLink("SubView1", value: 1)
                    NavigationLink("SubView3", value: 3)
                    NavigationLink("SubView4", value: 4)
                }
                // 只能响应序列元素类型
                .navigationDestination(for: Int.self) { target in
                    switch target {
                    case 1:
                        SubView1()
                    case 3:
                        SubView3()
                    default:
                        SubView4()
                    }
                }
            }
            .environmentObject(pathManager)
            .task{
                pathManager.path = [3,4]  // 直接跳转到指定层级，赋值更加方便
            }
        }
    }

    struct SubView1: View {
        @EnvironmentObject var pathManager:PathManager
        var body: some View {
            List{
                NavigationLink("subView3",value: 3)
                Button("go to SubView3"){
                    pathManager.path.append(3) // 效果与上面的 NavigationLink("subView3",value: 3) 一样
                }
                Button("返回根视图"){
                    pathManager.path.removeAll()
                }
                Button("返回上层视图"){
                    if pathManager.path.count > 0 {
                        pathManager.path.removeLast()
                    }
                }
                Button("响应 Deep Link，重置 Path Stack "){
                    pathManager.path = [3,1,1] // 会自动屏蔽动画
                }

            }
        }
    }

开发者可以根据自己的需求选择对应的视图堆栈类型。

> ⚠️ 在使用堆栈管理系统的情况下，请不要在编程式导航中混用声明式导航，这样会破坏当前的视图堆栈数据

下面的代码，如果点击声明式导航，将导致堆栈数据重置。

    NavigationLink("SubView3",value: 3)
    NavigationLink("SubView4", destination: { SubView4() }) // 不要在编程式导航中混用声明式导航

### NavigationSplitView

如果说 NavigationStack 是在三维的空间里堆叠视图，那么 NavigationSplitView
便是在二维的空间中于不同的栏之间动态切换视图。

#### 分栏布局

在 SwiftUI 4.0 之前的版本，可以这样使用 NavigationView 来创建拥有左右两个栏的编程式导航视图：

    class MyStore: ObservableObject {
        @Published var selection: Int?
    }

    struct NavigationViewDoubleColumnView: View {
        @StateObject var store = MyStore()
        var body: some View {
            NavigationView {
                SideBarView()
                DetailView()
            }
            .environmentObject(store)
        }
    }

    struct SideBarView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            List(0..<30, id: \.self) { i in
                // 此处我们没有使用 NavigationLink 来切换右侧视图，而是改变了 seletion 的值，让右侧视图响应该值的变化
                Button("ID: \(i)") {
                    store.selection = i
                }
            }
        }
    }

    struct DetailView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            if let selection = store.selection {
                Text("视图：\(selection)")
            } else {
                Text("请选择")
            }
        }
    }

![double_colunm_2022-06-11_10.16.38](https://cdn.fatbobman.com/double_colunm_2022-06-11_10.16.38.png)

用 NavigationSplitView 实现上面的代码基本上一样。最大的区别是，SwiftUI 4.0 为我们提供了在
NavigationSplitView 中通过 List 快速绑定数据的能力。

    struct NavigationSplitViewDoubleColumnView: View {
        @StateObject var store = MyStore()
        var body: some View {
            NavigationSplitView {
                SideBarView()
            } detail: {
                DetailView()
            }
            .environmentObject(store)
        }
    }

    struct SideBarView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            // 可以在 List 中直接绑定数据，无需通过 Button 显式进行修改
            List(0..<30, id: \.self, selection: $store.selection) { i in
                NavigationLink("ID: \(i)", value: i)  // 使用编程式的 NavigationLink
            }
        }
    }

![image-20220611104123815](https://cdn.fatbobman.com/image-20220611104123815.png)

由于 SwiftUI 4.0 为 List 提供了进一步的加强，我们还可以不使用 NavigationLink ，改写成下面的代码：

    struct SideBarView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            List(0..<30, id: \.self, selection: $store.selection) { i in
                Text("ID: \(i)")  // 也可以换成 Label 或其他视图 ，但不能是 Button
    //            NavigationLink("ID: \(i)", value: i)
            }
        }
    }

> SwiftUI 4.0 中，在 List 绑定了数据后，通过 List 构造方法创建的循环或 ForEach 创建的循环中的内容（
> 不能自带点击属性，例如 Button 或 onTapGesture ），将被隐式添加 tag 修饰符，从而具备点击后可更改绑定数据的能力

无论将 List 放置在 NavigationSplitView 的最左侧一栏（ 双栏模式 ）还是左侧两栏中（ 三栏模式 ），都可以通过 List
的绑定数据进行导航。这是 NavigationSplitView 的独有功能。

> 从 iOS 16.1 开始，开发者可以无需通过 List 的绑定模式来跳转视图了。通过在 NavigationSplitView 侧边栏里放一个.
> navigationDestination，这样侧边栏里的 NavigationLink 就会取代详细栏的根视图。

    NavigationSplitView {
        LazyVStack {
            NavigationLink("link", value: 213)
        }
        .navigationDestination(for: Int.self) { i in
            Text("The value is \(i)")
        }
    } detail: {
        Text("Click an item")
    }

#### 与 NavigationStack 合作

在 SwiftUI 4.0 之前，对于多栏的 NavigationView ，如果我们想在 SideBar 栏内实现堆栈跳转的话，可以使用如下代码：

    struct SideBarView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            List(0..<30, id: \.self) { i in
                NavigationLink("ID: \(i)", destination: Text("\(i)")) // 必须使用 NavigationLink
                    .isDetailLink(false) // 指定 destination 不要显示在 Detail 列中
            }
        }
    }

但如果，我们想在 Detail 栏中也想嵌入一个可以实现堆栈跳转的 NavigationView 则会有很大的问题。此时在 Detail 栏中将出现两个
NavigationTitle 以及两个 Toolbar 。

    struct NavigationViewDoubleColumnView: View {
        @StateObject var store = MyStore()
        var body: some View {
            NavigationView {
                SideBarView()
                DetailView()
                    .navigationTitle("Detail")  // 为 Detail 栏定义 title
                    .toolbar{
                        EditButton()  // 在 Detail 栏创建按钮
                    }
            }
            .environmentObject(store)
        }
    }

    struct SideBarView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            List(0..<30, id: \.self) { i in
                Button("ID: \(i)") {
                    store.selection = i
                }
            }
        }
    }

    struct DetailView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            NavigationView {
                VStack {
                    if let selection = store.selection {
                        NavigationLink("查看详情", destination: Text("\(selection)"))
                    } else {
                        Text("请选择")
                    }
                }
                .toolbar{
                    EditButton()  // 在 Detail 栏中的 NavigationView 创建按钮
                }
                .navigationTitle("Detail") // 为 Detail 栏中的 NavigationView 定义 Title
                .navigationBarTitleDisplayMode(.inline)
            }
            .navigationViewStyle(.stack)
        }
    }

![image-20220611110657857](https://cdn.fatbobman.com/image-20220611110657857.png)

> 为此，我之前不得已在 iPad 版本的应用程序中，使用 HStack 来避免出现上述问题。详情请参阅 [ 在 SwiftUI 下对 iPad 进行适配
> ](/zh/posts/swiftui-ipad/)

NavigationSpiteView 已经解决了上述问题，它现在可以同 NavigationStack 进行完美的合作。

    class MyStore: ObservableObject {
        @Published var selection: Int?
    }

    struct NavigationSplitViewDoubleColumnView: View {
        @StateObject var store = MyStore()
        var body: some View {
            NavigationSplitView {
                SideBarView()
            } detail: {
                DetailView()
                    .toolbar {
                        EditButton() // 在 Detail 栏中的 NavigationView 创建按钮
                    }
                    .navigationTitle("Detail")
            }
            .environmentObject(store)
        }
    }

    struct SideBarView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            List(0..<30, id: \.self, selection: $store.selection) { i in
                Text("ID: \(i)")
            }
        }
    }

    struct DetailView: View {
        @EnvironmentObject var store: MyStore
        var body: some View {
            NavigationStack {
                VStack {
                    if let selection = store.selection {
                        NavigationLink("查看详情", value: selection)
                    } else {
                        Text("请选择")
                    }
                }
                .navigationDestination(for: Int.self, destination: {
                    Text("\($0)")
                })
                .toolbar {
                    RenameButton() // 在 Detail 栏中的 NavigationView 创建按钮
                }
                .navigationTitle("Detail inLine")
                .navigationBarTitleDisplayMode(.inline)
            }
        }
    }

NavigationSplitView 会保留最近的 Title 设定，并对分别在 NavigationSplitView 和
NavigationStack 中为 Detail 栏添加的 Toolbar 按钮进行合并。

![image-20220611134247340](https://cdn.fatbobman.com/image-20220611134247340.png)

通过在 NavigationSplitView 中使用 NavigationStack ，开发者拥有了更加丰富的视图调度能力。

#### 动态控制多栏显示状态

另一个之前困扰多栏 NavigationView 的问题就是，无法通过编程的手段动态地控制多栏显示状态。NavigationSplitView
在构造方法中提供了 columnVisibility 参数 （ NavigationSplitViewVisibility 类型
），通过设置该参数，开发者拥有了对导航栏显示状态的控制能力。

    struct NavigationSplitViewDoubleColumnView: View {
        @StateObject var store = MyStore()
        @State var mode: NavigationSplitViewVisibility = .all
        var body: some View {
            NavigationSplitView(columnVisibility: $mode) {
                SideBarView()
            }
        content: {
                ContentColumnView()
            }
        detail: {
                DetailView()
            }
            .environmentObject(store)
        }
    }

![three_column_2022-06-11_13.52.10](https://cdn.fatbobman.com/three_column_2022-06-11_13.52.10.png)

- detailOnly 只显示 Detail 栏（ 最右侧栏 ）
- doubleColumn 在三栏状态下隐藏 Sidebar （ 最左侧 ）栏
- all 显示所有的栏
- automatic 根据当前的上下文自动决定显示行为

_上述选项并非适用于所有的平台，例如，在 macOS 上，detalOnly 不会起作用_

> 如果想在 SwiftUI 4.0 之前的版本上使用类似的功能，可以参考我在 [ 用 NavigationViewKit 增强 SwiftUI 的导航视图
> ](/zh/posts/navigationviewkit/) 一文中的实现方法

## 其他增强

除了上述的功能，新的导航系统还在很多其他的地方也进行了增强。

### 设置栏宽度

NavigationSplitView 为栏中的视图提供了一个新的修饰符 navigationSplitViewColumnWidth
，通过它开发者可以修改栏的默认宽度：

    struct NavigationSplitViewDemo: View {
        @State var mode: NavigationSplitViewVisibility = .all
        var body: some View {
            NavigationSplitView(columnVisibility: $mode) {
                SideBarView()
                    .navigationSplitViewColumnWidth(200)
            }
        content: {
                ContentColumnView()
                    .navigationSplitViewColumnWidth(min: 100, ideal: 150, max: 200)
            }
        detail: {
                DetailView()
            }
        }
    }

### 设置 NavigationSplitView 的样式

使用 navigationSplitViewStyle 可以设置 NavigationSplitView 的样式

    struct NavigationSplitViewDemo: View {
        @State var mode: NavigationSplitViewVisibility = .all
        var body: some View {
            NavigationSplitView(columnVisibility: $mode) {
                SideBarView()
            }
        content: {
                ContentColumnView()
            }
        detail: {
                DetailView()
            }
            .navigationSplitViewStyle(.balanced) // 设置样式
        }
    }

- prominentDetail

无论左侧栏显示与否，保持右侧的 Detail 栏尺寸不变（ 通常是全屏 ）。iPad 在 Portrait 显示状态下，默认即为此种模式

- balanced

在显示左侧栏的时候，缩小右侧 Detail 栏的尺寸。iPad 在 landscape 显示状态下，默认即为此种模式

- automatic

默认值，根据上下文自动调整外观样式

### 在 NavigationTitle 中添加菜单

使用新的 navigationTitle 构造方法，可以将菜单嵌入到标题栏中。

    .navigationTitle( Text("Setting"), actions: {
                    Button("Action1"){}
                    Button("Action2"){}
                    Button("Action3"){}
                })

![image-20220612085945286](https://cdn.fatbobman.com/image-20220612085945286.png)

### 更改 NavigationBar 背景色

    NavigationStack{
        List(0..<30,id:\.self){ i in
            Text("\(i)")
        }
        .listStyle(.plain)
        .navigationTitle("Hello")
        .toolbarBackground(.pink, in: .navigationBar)
    }

![RocketSim_Screenshot_iPhone_13_Pro_Max_2022-06-12_09.12.01](https://cdn.fatbobman.com/RocketSim_Screenshot_iPhone_13_Pro_Max_2022-06-12_09.12.01.png)

NavigationStack 的 toolbar 背景色只有在视图上滚时才会显示。

> SwiftUI 4.0 中，将 toolbar 的认定范围扩大到了 TabView 。在 toolbar 的设置中，通过 placement
> 可以设置适用的对象

### 隐藏 toolbar

    NavigationStack {
        ContentView()
            .toolbar(.hidden, in: .navigationBar)
    }

### 设置 toolbar 的色彩外观（ Color Scheme ）

    .toolbarColorScheme(.dark, for: .navigationBar)

![RocketSim_Screenshot_iPhone_13_Pro_Max_2022-06-12_09.21.29](https://cdn.fatbobman.com/RocketSim_Screenshot_iPhone_13_Pro_Max_2022-06-12_09.21.29.png)

### Toolbar 角色

使用 toolbarRole 设置当前 toolbar 的角色身份。不同的角色将让 toolbar 的外观和排版有所不同（ 视设备而异 ）。

    struct ToolRoleTest: View {
        var body: some View {
            NavigationStack {
                List(0..<10, id: \.self) {
                    NavigationLink("ID: \($0)", value: $0)
                }
                .navigationDestination(for: Int.self) {
                    Text("\($0)")
                        .navigationTitle("Title for \($0)")
                        .toolbarRole(.editor)
                }
                .navigationTitle("Title")
                .navigationBarTitleDisplayMode(.inline)
                .toolbarRole(.browser)
                .toolbar {
                    ToolbarItem(placement: .primaryAction) {
                        EditButton()
                    }
                }
            }
        }
    }

- navigationStack

默认角色，长按可显示视图堆栈列表

- browser

在 iPad 下，当前视图的 Title 将显示在左侧

![image-20220612190914949](https://cdn.fatbobman.com/image-20220612190914949.png)

- editor

不显示返回按钮旁边的上页视图 Title

![image-20220612191040190](https://cdn.fatbobman.com/image-20220612191040190.png)

### 定制 NavigationLink 样式

在之前版本的 SwiftUI 中，NavigationLink 其实一直都是作为一种特殊的 Button 存在的。到了 SwiftUI 4.0
版本后，SwiftUI 已经将其真正的视为了 Button 。

    NavigationStack {
        VStack {
            NavigationLink("Hello world", value: "sub1")
                .buttonStyle(.bordered)
                .controlSize(.large)
            NavigationLink("Goto next", destination: Text("Next"))
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .tint(.red)
        }
        .navigationDestination(for: String.self){ _ in
            Text("Sub View")
        }
    }

![image-20220613220926715](https://cdn.fatbobman.com/image-20220613220926715.png)

## 总结

SwiftUI 4.0 导航系统的变化如此之大，开发者在惊喜的同时，也要冷静的面对事实。相当一部分开发者由于版本适配的原因并不会使用新的 API
，因此，每个人都需要认真考虑如下问题：

- 如何从新 API 中获得灵感
- 如何在老版本中运用编程式导航思想
- 如何让新老版本的程序都能享受系统提供的便利

另一方面，新导航系统也向每一个开发者传递了明确的信号，苹果希望应用能够为 iPad 和 macOS 提供更加符合各自设备特点的 UI
界面。这种信号会越来越强，苹果也为此会提供越来越多的 API。

> 目前已经有人实现了 NavigationStack 在低版本 SwiftUI 下的仿制品 —— [ NavigationBackport
> ](https://github.com/johnpatrickmorgan/NavigationBackport)
> ，有兴趣的朋友可以参考作者的实现方式

# 在 SwiftUI 下使用 NSUbiquitousKeyValueStore 同步数据

NSUbiquitousKeyValueStore 是苹果官方提供的用于在设备间共享键值数据的解决方案。本文将对其用法做以简单介绍，着重探讨如何便捷地在
SwiftUI 中使用 NSUbiquitousKeyValueStore。

## 什么是 NSUbiquitousKeyValueStore

NSUbiquitousKeyValueStore 可以理解为 UserDefaults 的网络同步版本。它是 CloudKit
服务项目中的一员，只需简单的配置，就可以实现在不同的设备上共享数据（同一个 iCloud 账户）。

NSUbiquitousKeyValueStore 在大多数场合下表现的同 UserDefaults 十分类似：

- 都是基于键值存储
- 只能使用字符串作为键
- 可以使用任意属性列表对象（Property list object types）作为值
- 使用类似的读取和写入方法
- 都是率先将数据保存在内存中，系统会择机对内存数据进行持久化（此过程开发者通常无需干预）

即使你没有使用过 UserDefaults，只需花几分钟阅读一下 [ 官方文档
](https://developer.apple.com/documentation/foundation/nsubiquitouskeyvaluestore)
便可以掌握其基本用法。

### 同 UserDefaults 之间的不同

- NSUbiquitousKeyValueStore 不提供注册默认值的方法

使用 UserDefaults 时，开发者可以使用 `register(defaults:[String:Any])`
为键设置默认值，NSUbiquitousKeyValueStore 并没有提供类似的手段。对于不返回可选值的类型，应避免使用简便方法来获取值。

例如，可以使用类似下面的代码获取键名为”count”的整数值：

    func getInt(key: String, defaultValue: Int) -> Int {
        guard let result = NSUbiquitousKeyValueStore.default.object(forKey: key) as? Int else {
            return defaultValue
        }
        return result
    }

    let count = getInt(key: "count", defaultValue: 30)

    // longLong 的返回值不是可选值，应避免使用类似下方的简便方式获取值
    // NSUbiquitousKeyValueStore.default.longLong(forKey: "count") 默认值为 0

- NSUbiquitousKeyValueStore 有更多的限制

苹果并 **不推荐使用 NSUbiquitousKeyValueStore 保存数据量大、变化频繁且对 app 运行至关重要的数据** 。

NSUbiquitousKeyValueStore 最大的存储容量为 1 MB（每个用户），存储的键值对不得超过 1024 对。

NSUbiquitousKeyValueStore 网络同步的效率一般，在顺畅的情况下，一个键值对的数据可以在 10-20
秒左右完成同步。如果数据变化频繁，iCloud
会自动降低同步频率，同步时间可能会被延长至数分钟。开发者在进行测试时，由于会在短时间内多次修改数据，极大概率会出现同步缓慢的情况。

尽管 NSUbiquitousKeyValueStore 没有提供数据同步的原子支持，但在绝大多数情况下，NSUbiquitousKeyValueStore
会尽量保证在用户切换 iCloud 账户、重新登录 iCloud
账户、无网络后重新连接等状况下的数据完整性。但在个别情况下仍会出现数据不更新，设备之间不同步的情况，例如：

当 app 在正常运行过程中，用户在系统设置中选择关闭 app 的 iCloud 同步。此后 app 中所有对
NSUbiquitousKeyValueStore 的修改，即使在用户恢复 app 的 iCloud 同步功能后，都不会上传到服务器中。

- NSUbiquitousKeyValueStore 需要有开发者账户

需要拥有开发者账户才能启用 iCloud 同步功能。

- NSUbiquitousKeyValueStore 尚未提供 SwiftUI 下的便捷使用方法

从 iOS 14 开始，苹果为 SwiftUI 提供了 AppStorage，同对待@State 一样，通过@AppStorage，视图可以对
UserDefaults 中值的变化做出及时响应。

> 在多数情况下，我们可以将@AppStorage 看作是 UserDefaults 的 SwiftUI 包装，但在个别情况下，@AppStorage
> 并不完全与 UserDefaults 的行为保持一致（不仅仅指支持的数据类型方面）。

### 配置

在代码中使用 NSUbiquitousKeyValueStore 之前，我们首先需要对项目进行一定的配置以启用 iCloud 的键值存储功能。

- 在项目 TARGET 的 Signing&Capabilities 中，设置正确的 Team

![image-20211209174459745](https://cdn.fatbobman.com/image-20211209174459745.png)

- 在 Signing&Capabilities 中，点击左上角 `+Capability` 添加 iCloud 功能

![image-20211209174535198](https://cdn.fatbobman.com/image-20211209174535198.png)

- 在 iCloud 功能中，选中 Key-value storage

![image-20211209174907203](https://cdn.fatbobman.com/image-20211209174907203.png)

在选择键值存储后，Xcode 将为项目自动创建 entitlements 文件。并为 `iCloud Key-Value Store` 设置好对应的值
`$(TeamIdentifierPrefix)$(CFBundleIdentifier)`

![image-20211209175258618](https://cdn.fatbobman.com/image-20211209175258618.png)

TeamIdentifierPrefix 是你的开发者 Team（在最后需要添加 `.` ），可以从 [ 开发者账户 Certificates,
Identifiers & Profiles
](https://developer.apple.com/account/resources/certificates/list)
的右上角获取（由字母数字和点组成 `XXXXXXXX.` ）：

![image-20211209184208635](https://cdn.fatbobman.com/image-20211209184208635.png)

CFBundleIdentifier 就是 app 的的 Bundle Identifier。

如果想在其他的 app 或扩展上使用同一个 iCloud Key-value Store，可以手动修改 entitlements 文件中对应的内容。

获取其他 app 的 iCloud Key-value Store 最方便的方法是，在 plist 添加值为 `$(TeamIdentifierPrefix)$(CFBundleIdentifier)` 的键，通过 `Bundle.main.object(forInfoDictionaryKey:)` 进行查看。

> 可以确定的是，在同一个开发者账号下，只要指向同一个 iCloud Key-Value Store，无论是在不同的 app、还是 app
> extension 之间都可以同步数据（同一个 iCloud 账户）。我无法对不同的开发者账号指向同一个 iCloud Key-Value Store
> 的情况进行测试，请有条件的朋友帮忙测试一下并告知我，谢谢。

## 在 SwiftUI 视图中使用 NSUbiquitousKeyValueStore

本节中，我们将在不使用任何第三方库的情况下，实现 SwiftUI 视图对 NSUbiquitousKeyValueStore 的变化实时响应。

NSUbiquitousKeyValueStore 的基本工作流程如下：

- 将键值对保存到 NSUbiquitousKeyValueStore 中
- NSUbiquitousKeyValueStore 首先将键值数据保存在内存中
- 系统择机将数据持久化到磁盘上（开发者可以通过调用 `synchronize()` 显式调用该操作）
- 系统择机将变化的数据发送到 iCloud 上
- iCloud 和其他设备择机对变更后的数据进行同步
- 设备将网络同步的数据持久化到本地
- 同步完成后，会发送 `NSUbiquitousKeyValueStore.didChangeExternallyNotification` 通知，提醒开发者

除了网络同步的步骤外，工作流程同 UserDefaults 几乎一样。

在不使用第三方库的情况下，在 SwiftUI 视图中可以通过桥接@State 数据的形式，将 NSUbiquitousKeyValueStore
的变化同视图联系起来。

下面的代码将在 NSUbiquitousKeyValueStore 创建一个键名称为 text 的字符串，并将其同视图中的变量 text 关联起来：

    struct ContentView: View {
        @State var text = NSUbiquitousKeyValueStore().string(forKey: "text") ?? "empty"

        var body: some View {
            TextField("text:", text: $text)
                .textFieldStyle(.roundedBorder)
                .padding()
                .task {
                    for await _ in NotificationCenter.default.notifications(named: NSUbiquitousKeyValueStore.didChangeExternallyNotification) {
                        if let text = NSUbiquitousKeyValueStore.default.string(forKey: "text") {
                            self.text = text
                        }
                    }
                }
                .onChange(of: text, perform: { value in
                    NSUbiquitousKeyValueStore.default.set(value, forKey: "text")
                })
        }
    }

task 中的代码的作用与下方的代码等同，想了解具体的用法，可以参看 [ 聊聊 Combine 和 async/await 之间的合作
](/zh/posts/combineandasync/) 一文：

    .onReceive(NotificationCenter.default.publisher(for: NSUbiquitousKeyValueStore.didChangeExternallyNotification)) { _ in
        if let text = NSUbiquitousKeyValueStore.default.string(forKey: "text") {
            self.text = text
        }
    }

在 didChangeExternallyNotification 的 userinfo 中还含有一些其他的信息，比如消息提示原因以及本次变更的键名称等。

事实上，我们不可能对于每个 NSUbiquitousKeyValueStore 的键都采用上述的方式来驱动视图，在下文章我们将尝试使用更加方便的方法来完成同
SwiftUI 的集成工作。

## 像@AppStorage 一样使用 NSUbiquitousKeyValueStore

尽管上节中的代码有些繁琐，但它已经指明了 NSUbiquitousKeyValueStore 同视图联动的方向——将
NSUbiquitousKeyValueStore 的变化同一个可以导致视图刷新的数据（State、ObservableObject
等）关联起来，就可以实现同@AppStorage 一样的效果。

原理上并不复杂，但是为了能够支持全部的类型仍需要做大量细致的工作。好在 Tom Lokhorst 已经为我们实现了这一切，使用他开发的 [
CloudStorage ](https://github.com/tomlokhorst/CloudStorage) 库，我们可以十分轻松地在视图中使用
NSUbiquitousKeyValueStore。

上节中的代码在使用 CloudStorage 库后将变成：

    @CloudStorage("text") var text = "empty"

使用方式同@AppStorage 完全一样。

> 很多开发者在选择支持 NSUbiquitousKeyValueStore 的第三方库时，可能会率先想到 [ Zephyr
> ](https://github.com/ArtSabintsev/Zephyr) 。Zephyr 在处理 UserDefaults 同
> NSUbiquitousKeyValueStore 之间的联动方面做的很不错，但由于@AppStorage 的独特性（并非真正意义上的
> UserDefaults 完整包装），Zephyr 对于@AppStorage 的支持目前是有问题的，笔者并不推荐使用。

## 集中管理 NSUbiquitousKeyValueStore 的键值

随着 app 中创建的 UserDefaults、NSUbiquitousKeyValueStore
键值对的不断增加，逐个在视图中引入的方式将让数据变得难以管理。因此需要寻找一种适合 SwiftUI 的方式，将键值对统一配置、集中管理。

在 [ @AppStorage 研究 ](/zh/posts/appstorage/) 一文中，我介绍过如何对@AppStorage
进行统一管理、集中注入的方法。例如：

    class Defaults: ObservableObject {
        @AppStorage("name") public var name = "fatbobman"
        @AppStorage("age") public var age = 12
    }

    // 在视图中，集中注入
    @StateObject var defaults = Defaults()
    ...
    Text(defaults.name)
    TextField("name",text:defaults.$name)

那么，是否可以沿用这个思路将@CloudStorage 纳入进来呢？

> 2022 年 5 月更新：我按照 @Published 的实现方式重新修改了 @CloudStorage 。现在 @CloudStorage
> 的行为已经与 @AppStorage 完全一致了。详细内容请参阅 [ 为自定义属性包装类型添加类 @Published 的能力
> ](/zh/posts/adding-published-ability-to-custom-property-wrapper-types/) 。

~~遗憾的是，我至今仍没搞清@AppStorage 是如何从代码层面实现类似@Published
行为的原理。因此，我们只能采用一点相对笨拙的方式来达到目的~~ 。

~~我对 CloudStrorage 进行了一点修改，在几个数据更改的时机点上添加了通知机制，通过在符合 ObservableObject
的类中，响应该通知并调用`objectWillChange.send()` 来模拟@AppStorage 的特性。 ~~

~~可以在此下载[ 修改后的 CloudStorage 代码 ](https://github.com/fatbobman/CloudStorage) 。
~~

我提交的 PR 已被原作者采纳，可在原作者处下载。

    class Settings:ObservableObject {
           @AppStorage("name") var name = "fat"
           @AppStorage("age") var age = 5
           @CloudStorage("readyForAction") var readyForAction = false
           @CloudStorage("speed") var speed: Double = 0
    }

    struct DemoView: View {
        @StateObject var settings = Settings()
        var body: some View {
            Form {
                TextField("Name",text: $settings.name)
                TextField("Age", value: $settings.age, format: .number)
                Toggle("Ready", isOn: $settings.readyForAction)
                    .toggleStyle(.switch)
                TextField("Speed",value: $settings.speed,format: .number)
            }
            .frame(width: 400, height: 400)
        }
    }

由于 SwiftUI 系统组件包装的特殊性，采用上述的方式统一管理@AppStorage 和@CloudStorage 数据时，
**请特别注意在视图中调用@CloudStorage Binding 数据的方式** 。

只能使用 `$storage.cloud` 的方式， `stroage.$cloud` 将会导致 binding 数据无法刷新
wrappedValue 情况，从而出现视图上数据更新不完整的情况。

## 总结

NSUbiquitousKeyValueStore 正如它的名称一样，让 app 的数据无处不在。只需很少的配置就可以为你的 app
添加该项功能，有需求的朋友可以行动起来了！

# iCloud Documents 详解：基础设置与文件操作

iCloud 文档（iCloud
Documents）是苹果公司提供的一项云存储和同步服务，旨在使用户能够轻松存储、访问和共享他们的文档和文件，并在不同的苹果设备之间进行同步和共享。我将通过两篇文章详细介绍该功能。在本文中，我们将探讨如何在应用程序中集成该功能、进行文件的读写以及对文件内容变化的响应等内容。

## 写在前面的话

苹果基于 CloudKit
为开发者提供了三个主要的功能：CloudKit（保存结构化数据）、NSUbiquitousKeyValueStore（保存键值数据）以及 iCloud
Documents（文件共享与云存储）。前两项功能我之前都写过与其有关的文章，但迟迟没有找到好的时机来深入探讨 iCloud Documents
服务。不久前，著名漫画阅读器—— [ 可达阅读器
](https://apps.apple.com/cn/app/%E5%8F%AF%E8%BE%BE%E9%98%85%E8%AF%BB%E5%99%A8-%E7%A6%BB%E7%BA%BF%E5%9B%BE%E7%89%87%E9%98%85%E8%AF%BB%E5%99%A8/id1545372338)
的作者 [ Xiaogd ](https://twitter/kedamanga) 将他在开发中碰到的有关 iCloud Documents 的问题以 [
贴文 ](https://discord.com/channels/967978112509935657/1174644655678304357)
的形式发表在我的 Discord 服务器上。经过他本人同意，我在他的帖文基础上，结合我自己的研究和理解，撰写了本文。在此，特向 Xiaogd 表示感谢。

> 本文主要针对非文档类应用所撰写。因为文档类应用 (Document-based apps) 自身已经深度集成了 iCloud Documents,
> 可以自动实现本文中介绍的大多数功能。如果你正在开发文档类应用，可以直接参考系统提供的模板和范例代码，本文中的许多内容对你可能比较冗余。

## 如何开启 iCloud Documents 功能

要在你的项目中启用 iCloud Documents 功能，请按照以下步骤操作：

- 在 “Singing & Capabilities” 中，添加 iCloud 功能。

![https://cdn.fatbobman.com/image-20231204112428865.png](https://cdn.fatbobman.com/image-20231204112428865.png)

- 选择 “iCloud Documents” 功能，并创建或选择你想使用的 CloudKit 容器。

![https://cdn.fatbobman.com/image-20231204112526987.png](https://cdn.fatbobman.com/image-20231204112526987.png)

- 在 Info 中，添加如下内容：

![https://cdn.fatbobman.com/image-20231204112619092.png](https://cdn.fatbobman.com/image-20231204112619092.png)

XML

Copy code

Copied!

    <dict>
      <key>NSUbiquitousContainers</key>
      <dict>
        <key>iCloud.com.fatbobman.iCloudDocumentsDemoContainer</key>
        <dict>
          <key>NSUbiquitousContainerIsDocumentScopePublic</key>
          <true/>
          <key>NSUbiquitousContainerName</key>
          <string>Doc_Demo</string>
          <key>NSUbiquitousContainerSupportedFolderLevels</key>
          <string>ANY</string>
        </dict>
      </dict>
    </dict>

[ NSUbiquitousContainers
](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW32)
: 一个字典，指定了每个容器的 iCloud Drive 设置。该字典的键是你的应用程序的 iCloud
容器的容器标识符。比如在上面的例子中，我们在项目设置中使用了 `iCloud.com.fatbobman.iCloudDocumentsDemoContainer` 这个容器，那么在此就要以该 id 为键创建字典。

[ NSUbiquitousContainerIsDocumentScopePublic
](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW29)
：当将此键设置为 `YES` 时，表示该容器中的文档范围是公共的。用户可以在文件应用（iOS）或 Finder（macOS）中看到 iCloud
Documents 目录中的文档目录中的内容。 **只有保存在 iCloud Documents 的 Documents
目录中的内容才会被操作系统显示出来** 。

[ NSUbiquitousContainerName
](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW31)
：这是用户在 iCloud Drive 中看到的容器的友好名称。该名称用于在 Finder 或文件应用中显示的 iCloud
文件夹名称。在上述配置中，我们将其设置为 `Doc_Demo` ，然后我们将在 Finder 的 iCloud 云盘中会看到一个名为 `Doc_Demo` 的目录。

[ NSUbiquitousContainerSupportedFolderLevels
](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW30)
：这个配置决定了应用可以在 iCloud Drive 中创建的文件夹层级。常见的值有 `None` （不允许创建子文件夹）、 `One`
（允许一个层级的子文件夹）、 `Any` （允许任意层级的子文件夹）。

> 在创建或修改 Info 设置后，应该增加当前项目的 build number，以确保修改后的配置生效。

## 如何获取 iCloud Documents 文件夹的 URL

使用以下代码可以获取到 iCloud Documents 文件夹的 URL：

    // CloudKit Container ID
    let containerIdentifier = "iCloud.com.fatbobman.iCloudDocumentsDemoContainer"
    guard let url = FileManager.default.url(forUbiquityContainerIdentifier: containerIdentifier) else {
        print("Can't get UbiquityContainer url")
        return
    }

    print(url)

以下情况可能导致无法获取 URL：

- Info 设置错误或没有增加 build number。
- 没有登录 iCloud 账户。
- 登录了 iCloud 账户，但在系统的 iCloud 设置中关闭了当前应用的 iCloud 同步功能。

## 为什么无法在文件应用和 Finder 中看到我的文件夹

如果您已经能够获取到 iCloud Documents 文件夹的 URL，但在文件应用或 Finder 中仍无法看到当前项目的 iCloud
Documents 目录，可能是以下原因导致的：

- 确保 `NSUbiquitousContainerIsDocumentScopePublic` 为 `YES`
- 尝试增加 builder number 后再次运行
- 在 iCloud Documents 目录的 Documents 子目录中写入一个文件

在项目首次增加 iCloud Documents 功能后，有时需要在 Documents 子目录中创建一个文件后，才能在文件应用或 Finder
中看到该目录。可以尝试使用下面的代码先写入一个文件：

    let containerIdentifier = "iCloud.com.fatbobman.iCloudDocumentsDemoContainer"
    guard let containerURL = FileManager.default.url(forUbiquityContainerIdentifier: containerIdentifier) else {
        print("Can't get UbiquityContainer url")
        return
    }

    let fileURL = containerURL.appendingPathComponent("Documents").appendingPathComponent("hello.txt")
    try! "hello world".write(to: fileURL, atomically: true, encoding: .utf8)

- 确保模拟器的 iCloud 同步状态正常

需要注意的是，在某些情况下，即使您已在 iOS 模拟器上登录了 iCloud 账户，iCloud 文档的同步可能仍然不稳定，特别是在 iOS 17
系统中，这种情况更为常见。当遇到类似情况时，请多次尝试，或切换到新的模拟器环境。

完成上述操作后，您就可以在文件应用或 Finder 中看到当前应用创建的 `Doc_Demo` 目录以及 `hello.txt` 文件了。

![https://cdn.fatbobman.com/image-20231204122111342.png](https://cdn.fatbobman.com/image-20231204122111342.png)

当 iCloud Documents 的 Documents 子目录显示出来后，即使我们将 Documents 目录中的内容全部删除，该目录仍将显示。

## 是否需要将文件都保存在 iCloud Documents 的 Documents 子目录下

视情况而定。

对于想要在文件应用或 Finder 中显示的文件，将其保存在 “Documents” 子目录下。

如果你觉得没有将文件显示给使用者的必要，可以将 `NSUbiquitousContainerIsDocumentScopePublic` 直接设置为 `NO` 。该设置不会影响 iCloud Documents 目录在不同设备之间的同步功能。

## 谁可以读写 iCloud Documents 下的内容

- 使用相同开发者账号和相同 NSUbiquitousContainers 配置的其他应用程序
- 文件应用程序和 Finder（可以读写 Documents 子目录）

## 如何在 iCloud Documents 中进行文件操作

尽管在上文中，我们使用了与写入普通文件一样的方式在 Documents 子目录中创建了一个 `hello.txt` 文件，但这并不表示这是对
iCloud Documents 目录的正确操作模式。

对于 iCloud Document，苹果推荐开发者通过 [ NSFileCoordinator
](https://developer.apple.com/documentation/foundation/nsfilecoordinator)
的方式对其中的文件进行操作。这是因为除了当前的项目外，其他满足条件的应用和系统应用都可以读写 iCloud Document
目录下的内容。NSFileCoordinator 可以确保文件系统的多个访问请求得到适当的协调，以避免出现数据冲突和数据损坏。

因此，绝大部分对 iCloud Document 的文件操作，都应该通过 `NSFileCoordinator` 进行。

为了避免影响主线程，通常这些操作是在后台进行的。

需要注意的是， `NSFileCoordinator`
的协调任务和文件访问任务应该在同一个执行上下文（同一个线程）中完成，以确保文件访问的原子性和一致性。

### 创建文件

安全的文件写入方式是：

    actor CloudDocumentsHandler {
        let coordinator = NSFileCoordinator()

        func write(targetURL: URL, data: Data) throws {
            var coordinationError: NSError?
            var writeError: Error?

            // 使用 coordinationError 变量来捕获 coordinate 方法的错误信息。
            // 如果不提供一个 NSError 指针，协调过程中发生的错误将无法被捕获和处理。
            coordinator.coordinate(writingItemAt: targetURL, options: [.forDeleting], error: &coordinationError) { url in
                do {
                    try data.write(to: url, options: .atomic)
                } catch {
                    writeError = error
                }
            }

            // 在闭包外部检查是否有错误发生
            if let error = writeError {
                throw error
            }

            // 检查协调过程中是否发生了错误
            if let coordinationError = coordinationError {
                throw coordinationError
            }
        }
    }

    Task.detached {
        let containerIdentifier = "iCloud.com.fatbobman.iCloudDocumentsDemoContainer"
        guard let containerURL = FileManager.default.url(forUbiquityContainerIdentifier: containerIdentifier) else {
            print("Can't get UbiquityContainer url")
            return
        }
        let documentsFolderURL = containerURL.appendingPathComponent("Documents33")
        let fileURL = documentsFolderURL.appending(path: "hello.txt")
        let hander = CloudDocumentsHandler()
        do {
            try await hander.write(targetURL: fileURL, data: "hello world".data(using: .utf8)!)
        } catch {
            print(error)
        }
    }

在我们调用 `coordinator.coordinate(writingItemAt: targetURL, options: [], error:
&coordinationError)` 这个方法时， `NSFileCoordinator` 会在必要时为 targetURL 创建一个临时的
URL（并非总是创建），并会阻止其他使用 `NSFileCoordinator` 的进程或线程在协调块执行期间对相同文件进行写入操作。

当需要额外控制时，可以在 options 中添加需要的选项。这些选项提供了关于操作性质的上下文信息，帮助 `NSFileCoordinator`
更有效地处理并发和冲突问题。

### 读取文件

    actor CloudDocumentsHandler {
        let coordinator = NSFileCoordinator()

        ....

        func read(url: URL) throws -> Data {
            var coordinationError: NSError?
            var readData: Data?
            var readError: Error?

            coordinator.coordinate(readingItemAt: url, options: [], error: &coordinationError) { url in
                do {
                    readData = try Data(contentsOf: url)
                } catch {
                    readError = error
                }
            }

            // 检查读取过程中是否发生了错误
            if let error = readError {
                throw error
            }

            // 检查协调过程中是否发生了错误
            if let coordinationError = coordinationError {
                throw coordinationError
            }

            // 确保读取到的数据不为空
            guard let data = readData else {
                throw NSError(domain: "CloudDocumentsHandlerError", code: 0, userInfo: [NSLocalizedDescriptionKey: "No data was read from the file."])
            }

            return data
        }
    }

## 如何感知文件的变化

在上面的代码中，我们通过 `read(url: URL)`
获取了指定的文件数据。如果该文件被其他的进程或网络上其他的设备修改了，开发者该如何感知它的变化并及时更新呢？

通常情况下，对于单个文件的变化，我们可以使用 `NSFilePresenter` 来感知变化。

`NSFilePresenter` 的功能主要包括以下几点：

- 接收文件更改通知：当文件发生变化（如内容被修改、移动或删除）时，实现了 `NSFilePresenter` 协议的对象将会收到通知。
- 处理文件冲突：如果多个应用或进程尝试同时修改同一文件， `NSFilePresenter` 可以帮助识别和解决冲突。
- 协调文件的保存操作：在文件被保存之前，可以通知 `NSFilePresenter` ，从而允许它执行必要的操作，如保存当前状态或释放文件锁。

首先，我们需要创建一个符合 `NSFilePresenter` 协议的类型：

    class FilePresenter: NSObject, NSFilePresenter {
        let fileURL: URL
        var presentedItemOperationQueue: OperationQueue = .main

        init(fileURL: URL) {
            self.fileURL = fileURL
            super.init()
            // 注册，监视指定 URL
            NSFileCoordinator.addFilePresenter(self)
        }

        deinit {
            // 注销监视
            NSFileCoordinator.removeFilePresenter(self)
        }

        var presentedItemURL: URL? {
            return fileURL
        }

        func presentedItemDidChange() {
            // 当文件发生变化时，执行相关操作
            // 例如，重新加载文件或通知其他组件
            print("file changed")
        }
    }

然后，为 CloudDocumentsHandler 增加开启监视和关闭监视的方法：

    actor CloudDocumentsHandler {
        let coordinator = NSFileCoordinator()
        var filePresenters: [URL: FilePresenter] = [:]

        ....

        func startMonitoringFile(at url: URL) {
            let presenter = FilePresenter(fileURL: url)
            filePresenters[url] = presenter
        }

        func stopMonitoringFile(at url: URL) {
            if let presenter = filePresenters[url] {
                NSFileCoordinator.removeFilePresenter(presenter)
            }
            filePresenters[url] = nil
        }
    }

这样我们就可以在读取文件后，通过 `startMonitoringFile` 方法来实现对文件变化的感知。

    let data = try await hander.read(url: fileURL)
    await hander.startMonitoringFile(at: fileURL)
    // close monitor
    await hander.stopMonitoringFile(at: fileURL)

需要注意的点：

- `presentedItemDidChange` 并不会告知我们文件的具体变化，当需要更精确的处理文件冲突和保存操作的协调时，需要实现 `NSFilePresenter` 协议的其他方法。
- 在不需要对文件进行监视时，务必要及时移除 `NSFilePresenter` 的实例以提高效率并避免内存泄露

`NSFilePresenter`
不仅可以监视单个文件，还可以监视整个目录。然而，由于其提供的信息有限，除非你只需要在目录内容发生变化时得到通知，否则我们通常不会使用它来监控一个目录。

## 如何获取 iCloud Document 目录中的文件列表

那么我们该如何获取 iCloud Document 目录中的文件列表，并在内容发生变化时实现自动更新呢？

苹果给出的建议是使用 [ NSMetaDataQuery
](https://developer.apple.com/documentation/foundation/nsmetadataquery) 。

在使用 iCloud Documents 的项目中， `NSMetadataQuery` 作为一种搜索 Spotlight metadata
的工具，可以用来监控 iCloud 文档目录的文件变化。它允许开发者设置特定的查询条件，监控文件的添加、删除或修改。当检测到文件系统的这些变化时， `NSMetadataQuery` 会发送通知，使开发者能够及时更新应用界面或执行相应的逻辑操作。这一功能在处理文件同步和状态更新时尤其重要。

如果你使用过 Core Data，它的表现有些类似于 NSFetchedResultsController 或 @FetchRequest。

下面的代码将使用 `NSMetadataQuery` ，根据给定的 Predicate、Scope 和 SortDescriptor 创建一个
AsyncStream。它会返回指定位置的文件列表，并对其变化做出响应。

    class ItemQuery {
        let query = NSMetadataQuery()
        let queue: OperationQueue

        init(queue: OperationQueue = .main) {
            self.queue = queue
        }

        func searchMetadataItems(
            predicate: NSPredicate? = nil,
            sortDescriptors: [NSSortDescriptor] = [],
            scopes: [Any] = [NSMetadataQueryUbiquitousDocumentsScope]
        ) -> AsyncStream<[MetadataItemWrapper]> {
            query.searchScopes = scopes
            query.sortDescriptors = sortDescriptors
            // 获取 iCloud Ubiquity Container URL
            if let containerURL = FileManager.default.url(forUbiquityContainerIdentifier: nil)?.appendingPathComponent("Documents") {
                // 构建指向 Documents 目录的路径
                let documentsPath = containerURL.path

                // 使用动态路径创建谓词
                let defaultPredicate = NSPredicate(format: "%K BEGINSWITH %@", NSMetadataItemPathKey, documentsPath)
                query.predicate = predicate ?? defaultPredicate
            } else {
                // 如果无法获取路径，可以选择一个合适的默认行为
                query.predicate = predicate ?? NSPredicate(value: true)
            }

            return AsyncStream { continuation in
                NotificationCenter.default.addObserver(
                    forName: .NSMetadataQueryDidFinishGathering,
                    object: query,
                    queue: queue
                ) { _ in
                    let result = self.query.results.compactMap { item -> MetadataItemWrapper? in
                        guard let metadataItem = item as? NSMetadataItem else {
                            return nil
                        }
                        return MetadataItemWrapper(metadataItem: metadataItem)
                    }
                    continuation.yield(result)
                }

                NotificationCenter.default.addObserver(
                    forName: .NSMetadataQueryDidUpdate,
                    object: query,
                    queue: queue
                ) { _ in
                    let result = self.query.results.compactMap { item -> MetadataItemWrapper? in
                        guard let metadataItem = item as? NSMetadataItem else {
                            return nil
                        }
                        return MetadataItemWrapper(metadataItem: metadataItem)
                    }
                    continuation.yield(result)
                }

                query.start()

                continuation.onTermination = { @Sendable _ in
                    self.query.stop()
                    NotificationCenter.default.removeObserver(self, name: .NSMetadataQueryDidFinishGathering, object: self.query)
                    NotificationCenter.default.removeObserver(self, name: .NSMetadataQueryDidUpdate, object: self.query)
                }
            }
        }
    }

    struct MetadataItemWrapper: Sendable {
        let fileName: String?
        let fileSize: Int?
        let contentType: String?
        let isDirectory: Bool
        let url: URL?

        init(metadataItem: NSMetadataItem) {
            fileName = metadataItem.value(forAttribute: NSMetadataItemFSNameKey) as? String
            fileSize = metadataItem.value(forAttribute: NSMetadataItemFSSizeKey) as? Int
            contentType = metadataItem.value(forAttribute: NSMetadataItemContentTypeKey) as? String

            // 检查是否是目录
            if let contentType = metadataItem.value(forAttribute: NSMetadataItemContentTypeKey) as? String {
                isDirectory = (contentType == "public.folder")
            } else {
                isDirectory = false
            }

            url = metadataItem.value(forAttribute: NSMetadataItemURLKey) as? URL
        }
    }

以下代码展示了如何获取 iCloud Documents 下的 Document
目录中的文件列表，包括所有子目录和子目录中的文件，并自动更新以反映任何变化。

    Task {
        let query = ItemQuery()
        for await items in query.searchMetadataItems().debounce(for: .seconds(1)) {
            items.forEach{
                print($0.fileName ?? "", $0.isDirectory)
            }
        }
    }

为了避免 `NSMetadataQuery` 的频繁通知，在上面的代码中使用了 [ swift-async-algorithms
](https://github.com/apple/swift-async-algorithms) 的 `debounce`
方法进行限流。你可以根据自己的需求，用任何熟悉的方式（比如 Combine）来实现上述逻辑。

代码的逻辑比较简单：

- 创建一个 query，设置 Predicate、Scope 和 SortDescriptors。
- 注册 NSMetadataQueryDidFinishGathering 和 NSMetadataQueryDidUpdate 通知。
- 在有通知时，将 NSMetadataItem 转换成 MetadataItemWrapper（转换成 Sendable），并通过 AsyncStream 传递出来。

Scope 是用来设定搜索范围的。在 iCloud Document 的应用中，我们通常会使用：

- NSMetadataQueryUbiquitousDocumentsScope：在 iCloud Documents 的 Documents 子目录中进行搜索。
- NSMetadataQueryUbiquitousDataScope：在 iCloud Documents 目录中进行搜索，不包括 Documents 子目录。

Predicate 除了可以指定某个目录外，还可以实现搜索特定文件的功能。下面的代码将列出所有以字符 `h` 开头的文件和目录，但仅限于 iCloud
Documents 根目录下。

    guard let containerURL = FileManager.default.url(forUbiquityContainerIdentifier: containerIdentifier) else {
        return
    }
    let predicateFormat = "((%K BEGINSWITH[cd] 'h') AND (%K BEGINSWITH %@)) AND (%K.pathComponents.@count == %d)"
    // 通过 pathComponents 数量来控制目录深度
    let predicate = NSPredicate(format: predicateFormat,
                                NSMetadataItemFSNameKey,
                                NSMetadataItemPathKey,
                                containerURL.path,
                                NSMetadataItemPathKey,
                                containerURL.pathComponents.count + 1)
    for await items in query.searchMetadataItems(predicate: predicate, scopes: [NSMetadataQueryUbiquitousDataScope]).throttle(for: .seconds(1), latest: true) {
        items.forEach {
            print($0.fileName ?? "", $0.isDirectory)
        }
    }

你也可以通过 sortDescriptors 来设定返回结果的排序方式，例如：先按文件名正序，再按文件大小倒序来排序。

    let sortDescriptors = [
        NSSortDescriptor(key: NSMetadataItemFSNameKey, ascending: true),
        NSSortDescriptor(key: NSMetadataItemFSSizeKey, ascending: false)
    ]

在使用 `NSMetadataQuery` 时，开发者应该了解以下几点：

- `NSMetadataQuery` 是用于搜索 Spotlight metadata 的工具，而不是直接进行文件操作。
- 在创建谓词时，不应该依赖于传统的文件系统路径和逻辑，而应该使用与元数据匹配的谓词来筛选数据。
- `NSMetadataQuery` 会响应满足谓词的任意元数据的变化，开发者应根据需求提供尽可能精确的谓词。这有助于减少不必要的变化通知，提高效率。
- 如果变化响应过于频繁，应采取适当的限流措施。
- 当不再需要响应变化时，应尽早关闭 `NSMetadataQuery` 。这有助于释放资源并提高性能。

## 接下来

在本文中，我们讨论了如何在项目中集成 iCloud
文档功能，包括如何读写文件、获取文件列表以及响应文件或目录内容的变化。在下一篇文章中，我们将更详细地介绍占位文件、下载与空间清理、移动与重命名等技巧。

您可以在 [ 此处
](https://github.com/fatbobman/BlogCodes/tree/main/iCloudDocumentsDemo)
获取本文的源代码。

# 聊聊两年来我使用【健康笔记】的体会以及近几年的身体状况

2019 年中，我有了开发用于记录自己健康数据 app 的想法，并在同年 10 月完成了【健康笔记】第一个很简陋的版本。到今天，我已经使用 [ 健康笔记
](/healthnotes/) 两年了。

从记录的数据来看，手术后这几年身体的各项指标还算保持的不错，尽管并没有达到非常理想的状态，但同我个人之前的指标比较，已经改善太多，希望能够长期保持下去。

身体指标数据在积累到一定的量后可以反映出很多的问题和细节，不少情况下身体的主观感受同检查的结构是有不小偏差的。

![image-20211018074519792](https://cdn.fatbobman.com/image-20211018074519792.png)

> 很多时候尽管自我感觉相当不错，指标提醒我需要休息并作适度调整。结合主观和客观的信息综合判断，有利于更好的了解自己的身体状态。

另外，通过分析不同指标之间的趋势差异，也给了医生和我调整药物、调整运动量等多方面的依据。

![image-20211018074602941](https://cdn.fatbobman.com/image-20211018074602941.png)

肌酐从发病时的 2100，透析期间长期维持的 1100，在手术后 3 年终于降到标准值（接近标准值上限）。尽管移植手术后第 4
天因为突发状况进行了二次手术，好在有惊无险。虽然尽管有点小反复，不过总体的趋势还是向好的。尿素氮的趋势基本维持同肌酐一致，但始终没有降到标准范围内。

在术后三年时间中，我始终坚持运动，体重从术前的 82 kg 控制到目前的 67 kg。体脂从术后的 28%降到了目前的
14%。结合自己的身体感受和数据趋势不断调整着运动量和运动内容（中间一度追求更低的体脂，在体重降到 64 kg、体脂率为
12%时无论是主观感觉还是客观数据都不很令人满意，随即放弃）。

同我使用【健康笔记】主要记录自己的数据不同，我的太太用它主要来记录我家毛孩子的各种情况，比如：施打疫苗、洗澡美容、身体异常以及各种小错误 😅 等等。

![image-20211018084503550](https://cdn.fatbobman.com/image-20211018084503550.png)

![image-20211018084532829](https://cdn.fatbobman.com/image-20211018084532829.png)

![image-20211018084551706](https://cdn.fatbobman.com/image-20211018084551706.png)

几个月前，我的狗狗查出了早期肾衰，于是又为他建立了同我类似的生化指标笔记。

![image-20211018084831149](https://cdn.fatbobman.com/image-20211018084831149.png)

狗狗经过几个月的调整，指标还算稳定，主要的指标都有改善的状况。

【健康笔记】是面对具有长期数据记录需求和习惯的使用者，目前使用人群也以慢性病患者或患者家属为主。坚持记录身体的各项指标，经过时间的积累会带给你意想不到的回报。

# Core Data with CloudKit（三）—— CloudKit 仪表台

本篇文章中，我们将一起研究 `CloudKit` 仪表台。

## 初识仪表台

使用 `CloudKit Dashboard` 需要开发者拥有 [ Apple Developer Program
](https://developer.apple.com/programs/) 账号，访问 [
https://icloud.developer.apple.com ](https://icloud.developer.apple.com) 即可使用。

![image-20210808161150623](https://cdn.fatbobman.com/image-20210808161150623-8410311.png)

最近两年苹果对 `CloudKit 仪表台` 的布局做过较大的调整，上面的截图是 2021 年中时的样子。

仪表台主要分为三个部分：

- 数据库（ `CloudKit Database` ）

数据库 `Web` 客户端。涵盖管理 `Schema` 、 `Record` 、 `Zone` 、用户权限、容器环境等功能。

- 遥测（ `Telemetry` ）

使用直观的可视化效果，深入了解应用程序的服务器端性能以及跨数据库和推送事件的利用率。

- 日志（ `Logs` ）

CloudKit 服务器生成实时和历史日志，记录并显示应用程序和服务器之间的交互。

> 在绝大多数使用 `Core Data with CloudKit` 的场景下，我们仅需要使用仪表板中极少数的功能（环境部署），但利用 `CloudKit Dashboard` ，我们可以更清楚的了解 `Core Data` 数据同步背后运作的一些机制。

## 数据库（CloudKit Database）

![image-20210808163319683](https://cdn.fatbobman.com/image-20210808163319683-8411600.png)

在 [ Core Data with CloudKit（一） —— 基础 ](/zh/posts/coredatawithcloudkit-1/) 中已经对
`CKContainer` 、 `CKDababase` 、 `CKZone` 、 `CKSubscription` 、 `CKRecord` 等基础对象做了简单的说明，本文还将介绍 `CloudKit` 的其他一些对象和功能。

### 环境

`CloudKit` 为你的应用程序网络数据分别提供了开发环境（Develpment）和生产环境（Production）。

- 开发环境

当你的项目仍处于开发阶段时，所有通过 `CloudKit`
产生的数据都只被保存开发环境中，只有开发团队的成员才能访问该环境中的数据。在开发环境中，你可以随时进行 `Schema` 结构调整、对 `Record
Type` 的属性进行删除修改等操作。即使这些操作可能会引起不同版本之间数据冲突都没有问题（可以随时重置开发环境）。非常类似 `Core Data`
的应用程序上线前的状态，即使数据无法正常迁移，只需要删除重装 app 即可。通过开发环境，开发者可以在向用户提供 `CloudKit`
服务之前对应用程序进行充分的测试。

- 生产环境

当应用程序完成开发并准备提交应用商店时，需要将开发环境的结构部署到生产环境（ `Deploy Schema Changes` ）。 `Schema`
一旦部署到生产环境，则意味着开发者不可以像在开发环境中那样随意对 `Schema` 进行修改，所有的修改都必须以向前兼容的方式进行。

原因非常简单，一旦应用程序上线，我们无法控制客户端的更新频率，也就是客户端可能存在任何的结构版本，为了能够让低版本的客户端一样可以访问数据，任何对数据模型的更改都需要向下兼容。

在 `App Store` 上销售的应用程序只能访问生产环境。

即使开发者的开发者账户同个人 `iCloud` 账户一致，开发环境和生产环境也是两个不同的沙盒，数据是互不影响的。当使用 `Xcode`
调试程序时，应用只能访问开发环境，而通过 `Testflight` 或 `App Store` 下载的应用则只能访问生产环境。

在开发环境下，点击 `Deploy Schema Changes` 将开发环境的 `Schema` 部署到生产环境。

![image-20210808180259192](https://cdn.fatbobman.com/image-20210808180259192-8416980.png)

部署时，会显示自上次部署后开发环境做出的修改。

即使 `Schema` 已经部署到生产环境后，我们仍可继续改动开发环境并部署到生产环境，如果模型无法满足兼容条件， `CloudKit`
仪表台将会禁止你的部署行为。

![image-20210808175543219](https://cdn.fatbobman.com/image-20210808175543219-8416544.png)

在容器名称下方会显示 `Schema` 是否已经部署到生产环境。上图是尚未部署的状态，下图是已经部署的状态。

![image-20210808180421055](https://cdn.fatbobman.com/image-20210808180421055-8417062.png)

![image-20210808180014216](https://cdn.fatbobman.com/image-20210808180014216-8416815.png)

在做任何操作之前，要首先确认是否处于正确的环境设定中。

> 鉴于 `CloudKit` 的环境部署规则， **在采用`Core Data with CloudKit` 的项目中设计 `Core Data` 数据模型时一定要特别小心！ ** 。我个人的原则是 **可加、不减、不改** 。我将在下篇文章详细讨论该如何对 `Core Data with
CloudKit` 数据模型做版本迁移。

### 安全角色（Security Roles）

安全角色仅适用于公共数据库。

`CloudKit` 使用基于角色的访问控制（ `RBAC` ）来管理权限和控制对 **公共数据库中**
数据的访问（私有数据库对于应用程序的用户是唯一的）。通过 `CloudKit` ，你可以为一个角色设置权限级别，然后将该角色分配给一个给定的记录类型（
`Record Type` ）。

权限包括读、写、创建。读权限只允许读取记录，写权限允许读取和写入记录，而创建权限允许读取和写入记录以及创建新纪录。

`CloudKit` 包含 3 个预设角色，分别为 World（ `_world` ）、Authenticated（ `_icloud` ）和
Creator（ `_creator` ）。World 表示任何人，无论其是否为 iCloud 用户。Authenticated 适用于任何经过验证的
iCloud 用户。Creator 则是作为记录（ `Record` ）的创建者。

![image-20210808210401070](https://cdn.fatbobman.com/image-20210808210401070-8427842.png)

默认的设置为，任何人都可以读取数据，只有经过验证的 iCloud 用户才可以创建新纪录，记录的创建者可以更新自己的记录。

![image-20210809062640040](https://cdn.fatbobman.com/image-20210809062640040-8461601.png)

我们可以创建自定义安全角色，但是不能创建用户记录（ `User Record`
），当用户第一次对容器进行身份验证时时系统会为该用户创建用户记录。我们可以查找现有用户并将其分配给任意的自定义的角色。

安全角色是数据模型（ `Schema` ）的一部分，每当开发者修改了安全设置后，需要将其部署到生产环境才能在生产环境生效。部署后无法删除安全角色。

> 大多数 `Core Data with CloudKit` 应用场合，直接使用系统的默认配置即可。

### 索引（Indexes）

`CloudKit` 的索引分为三种类型：

- 可查询（ `queryable` ）
- 可搜索（ `searchable` ）
- 可排序（ `sortable` ）

当我们通过 `CloudKit` 创建 `Recored Type` 后，可以根据需要为每个字段创建所需的索引（只有 `NSString`
支持可搜索）。索引类型选项是独立的，如果你希望该字段既可查询又可排序，则需要分别创建两个索引。

![image-20210809064449042](https://cdn.fatbobman.com/image-20210809064449042-8462689.png)

**只有为`Record Type` 的 `recordName` 创建了 `queryable` 索引后，才可以在 `Records`
中浏览该 Type 的数据。 **

![image-20210809065509228](https://cdn.fatbobman.com/image-20210809065509228-8463311.png)

![image-20210809064743215](https://cdn.fatbobman.com/image-20210809064743215-8462864.png)

> `Core Data with CloudKit` 会自动为 `Core Data` 数据模型的每个属性在 `CloudKit`
> 上创建需要的索引（不包含 `recordName` ）。除非你需要在 `CloudKit` 仪表台上浏览数据，否则我们不需要对索引做任何添加。

### Record Types

`Record Type` 是开发人员为 `CKRecord` 指定的类型标识符。你可以直接在代码中创建它，也可以在 `CloudKit`
仪表盘上对其进行创建、修改。

![image-20210809073043092](https://cdn.fatbobman.com/image-20210809073043092-8465444.png)

在 [ 基础篇 ](/zh/posts/coredatawithcloudkit-1/) 中曾提到 `Entity` 相较 `Record Type` 拥有更多的配置信息，但 `Record Type` 也有一个 `Enitity` 没有的特性——元数据。

![image-20210809075124786](https://cdn.fatbobman.com/image-20210809075124786-8466685.png)

`CloudKit` 为每一个 `Record Type` 预设了若干元数据字段（即使开发者没有创建任何其他字段），每条数据记录（ `CKRecord` ）都会包含这些信息，其中绝大多数都是系统自动设定的。

- createdTimestamp

`CloudKit` 首次将记录保存到服务器的时间

- createUserRecordName

`_creator` 的用户记录，该记录保存在 `Users` （系统创建）中，每当用户第一次对容器进行身份验证时时系统会为该用户创建用户记录

- \_etag

版本令牌。每次 `CloudKit` 保存记录时，都会将该记录更新为新值。用于比较网络和本地数据的版本

- modifiedTimestamp

`CloudKit` 更新记录的最近时间

- modifiedUserRecordName

最后更新数据的用户记录

- recordName

记录的唯一 ID。在创建 `CKRcord` 时创建，通常会设置为 `UUID` 字符串

对于一些特殊类型的 `Record Type` ，系统还会增加一些针对性的元数据，比如 `role` , `cloud.shared` 等

本文的主题为 `Core Data with CloudKit` ，因此让我们来看一下 `NSPersistentCloudKitContainer` 是如何将 `Core Data` 托管对象的属性转换成 `CloudKit` 的 `Recore Type` 字段的。

![image-20210809104558352](https://cdn.fatbobman.com/image-20210809104558352-8477160.png)

![image-20210809104402659](https://cdn.fatbobman.com/image-20210809104402659-8477043.png)

> 上图是我们在 [ 同步本地数据库到 iCloud 私有数据库 ](/zh/posts/coredatawithcloudkit-2/) 中模版项目 `Item` 在 `CloudKit` 对应的 `Record Type` 。 `CloudKit`
> 会自动为托管对象实体的每个属性创字段，将属性名称映射到了具有 `CD_[attribute.name]` 键名的字段。该字段的类型在 `Core
Data` 和 `CloudKit` 之间可能也会有所不同。 `Record Type` 名称为 `CD_[entity]`
> 。一切的操作都是由系统自动完成的，我们无需干预。另外，还会为 `Enitity` 生成一个 `CD_entityName` 的字段，内容为 `Entity` 的类映射名。

这些以 `CD_` 为前缀的字符串，在数据同步过程中将不断出现在控制台上，了解了它的构成对调试代码有一定帮助。

`Record Type` 部署到生产环境后，字段不可以删除，字段名称也不可以修改。因此一些 `Core Data` 中的操作在 `Core
Data with CloudKit` 中是不允许的。

**不要对已经上线的应用程序数据模型的`Entity` 进行更名，也不要对 `Attribute` 更名，即使使用 Mapping
Model、Renaming ID 都是不行的。在开发阶段如果需要更名的话，可能需要删除 app 重装并重置 `CloudKit` 的开发环境。 **

### Zones

每个种类的数据库都有默认 `Zone` ，只有私有数据库可以自定义 `Zone` 。

![image-20210809143010363](https://cdn.fatbobman.com/image-20210809143010363-8490611.png)

对于私有数据库中的数据，在创建 `CKRecord` 时可以为数据指定 `Zone` 。

    let zone = CKRecordZone(zoneName: "myZone")
    let newStudent = CKRecord(recordType: "Student",
                              recordID: CKRecord.ID(recordName: UUID().uuidString,
                                                    zoneID: zone.zoneID))

`NSPersistentCloudKitContainer` 在将托管对象转换成 `CKRecord` 时，将 `ZoneID` 统一设置为
`com.apple.coredata.cloudkit.zone` 。必须切换到正确的 `Zone` 才能浏览到数据。

![image-20210809143648531](https://cdn.fatbobman.com/image-20210809143648531-8491011.png)

- OWNER RECORD NAME

用户记录，对应 `Zone` 的 `_creator`

- CHANGE TOKEN

比对令牌

- ATOMIC

当 CloudKit 无法更新 `Zone` 中的一个或多个记录时，如果值为 `true` 则整个操作失败

### Records

用于数据记录的浏览、创建、删除、更改、查询。

![image-20210809150327144](https://cdn.fatbobman.com/image-20210809150327144-8492609.png)

在浏览数据时，需注意以下几点：

- 选择正确的环境（开发环境和生产环境的数据完全不同）
- 选择正确的 `Database` 、 `Zone`
- 确认需要浏览的 `Record Type` 元数据 `recordName` 已经添加了 `queryable` 索引
- 如果需要对字段进行排序或过滤，请给该字段创建对应的索引
- 索引只有在部署后才会在生产环境下起作用

> 在 `CloudKit` 仪表台中修改 `Core Data` 的镜像数据，客户端会立即收到远程通知并进行更新。不过并不推荐此种做法。

你也可以在代码中获取到 `Core Data` 托管对象对应的 `CKRecord` ：

    func getLastUserID(_ object:Item?) -> CKRecord.ID? {
        guard let item = object else {return nil}
        guard let ckRecord = PersistenceController.shared.container.record(for: item.objectID) else {return nil}
        guard let userID = ckRecord.lastModifiedUserRecordID else {
            print("can't get userID")
            return nil
        }
        return userID
    }

上面的代码，将获取托管对象记录对应的 `CKRecord` 的最后修改用户

### Subscriptions

浏览在容器上注册的 `CKSubscription` 。

CKSubscription 是通过代码创建的，在仪表盘上只可以查看或删除。

比如下面的代码将创建一个 `CKQuerySubscription`

            let predicate = NSPredicate(format: "name = 'bob'")
            let subscription = CKQuerySubscription(recordType: "Student",
                                                   predicate: predicate,
                                                   options: [.firesOnRecordCreation])
            let info = CKSubscription.NotificationInfo()
            info.alertLocalizationKey = "create a new bob"
            info.soundName = "NewAlert.aiff"
            info.shouldBadge = true
            info.alertBody = "hello world"

            subscription.notificationInfo = info

            publicDB.save(subscription) { subscription, error in
                if let error = error {
                    print("error:\(error)")
                }
                guard let subscription = subscription else { return }
                print("save subscription successes:\(subscription)")
            }

![image-20210809154503445](https://cdn.fatbobman.com/image-20210809154503445-8495104.png)

> `NSPersistentCloudKitContainer` 会为 `Core Data` 镜像的私有数据库注册一个 `CKDatabaseSubscription` 。当 `com.apple.coredata.cloudkit.zone`
> 数据更新时，会推送远程通知。

![image-20210809154946576](https://cdn.fatbobman.com/image-20210809154946576-8495387.png)

### Tokens&Keys

设置容器的 API 令牌。

![image-20210809152554058](https://cdn.fatbobman.com/image-20210809152554058-8493955.png)

除了可以通过代码和 `CloudKit` 仪表台对数据进行操作外，苹果还提供了从网络或其他平台访问 `iCloud`
数据的手段。在获取令牌后，开发者还可以通过使用 [ CloudKit JS
](https://developer.apple.com/documentation/cloudkitjs) 或 [ CloudKit Web 服务
](https://developer.apple.com/library/archive/documentation/DataManagement/Conceptual/CloudKitWebServicesReference/)
与数据进行交互。

已有开发者利用以上服务，开发出可在其他平台访问 iCloud 数据的第三方库，比如 [ DroidNubeKit
](https://github.com/jaumecornado/DroidNubeKit) （在安卓上访问 `CloudKit` ）。

> 对于 `Core Data` 的网络镜像数据，除非你的数据模型足够简单，否则不推荐做这种尝试。 `CloudKit Web` 服务更适合直接通过
> `Cloudkit` 创建的数据记录。

### Sharing Fallbackd

为低版本操作系统（低于 iOS 10、macOS Sierra）提供数据记录共享回调支持。

## 遥测（Telemetry）

![image-20210809161022705](https://cdn.fatbobman.com/image-20210809161022705-8496624.png)

通过查看 Telemetry
的指标，方便你在开发或更新应用程序时可视化性能。包括请求数量、错误数量、推送数量、服务器延迟以及平均请求大小等等。通过设定范围，仅显示与你相关的数据，帮助你更好地了解应用程序的流量配置及使用趋势。

## 日志（Logs）

![image-20210809162346212](https://cdn.fatbobman.com/image-20210809162346212-8497427.png)

在历史日志中，你可以查看包括时间、客户端平台版本、用户（匿名）、事件、组织、细节等信息。

在提供详尽信息的基础上， `CloudKit`
尽可能地保持用户数据的隐秘性。日志显示每个用户记录的服务器事件，但不暴露任何个人身份信息。仅显示匿名的、特定于容器的 `CloudKit` 用户。

`AppStoreConnect` 的分析信息仅来自已同意与 App 开发者共享诊断和使用信息的用户， `CloudKit`
日志信息则来自于你的应用程序中所有使用了 `CloudKit` 服务的用户。两者结合使用，可以获得更好的效果。

## 总结

大多数使用 `Core Data with CloudKit` 的场景，开发者基本无需使用 `CloudKit`
仪表盘。不过偶尔研究一下仪表盘上的数据，也是一种不错的乐趣。

下一篇文章，我们将聊一下开发 `Core Data with CloudKit` 项目经常会碰到的一些情况，比如调试、测试、数据迁移等。

# 在 Text 中实现基于关键字的搜索和定位

前些日子，一位网友在聊天室中就如下的 [ 问题
](https://discord.com/channels/967978112509935657/967978112509935663/999357869591908382)
与大家进行了交流与探讨 —— 如何通过 Text + AttributedString 实现类似文章关键字检索的功能，并可通过按钮在搜索结果中进行滚动切换？

![Fae3VkfVUAAFzqB](https://cdn.fatbobman.com/Fae3VkfVUAAFzqB.jpeg)

![Fae3VkkVUAAga7w](https://cdn.fatbobman.com/Fae3VkkVUAAga7w.jpeg)

考虑到这个问题对于 SwiftUI
的应用来说比较新颖，且涉及不少博客中介绍过的知识，因此我对聊天室原本给出的解决方案进行了重新整理，并通过本文对解决思路、方法手段以及注意事项等内容与大家进行探讨。

> 可在此获取本文提供的 [ 范例代码
> ](https://github.com/fatbobman/BlogCodes/tree/main/ShowKeywordsInText)
> ，开发环境为 Xcode 14 beta 5

## 问题关键点

- 在分散的数据中进行关键字查询，并记录搜索结果

提问者给出的数据格式如下：

    struct Transcription: Equatable, Identifiable {
        let id = UUID()
        let startTime: String
        var context: String
    }

    let transcriptions: [Transcription] = [
        .init(startTime: "06:32", context: "张老三，我问你，你的家乡在哪里"),
        .init(startTime: "08:42", context: "我的家，在山西，过河还有三百里"),
    ]

- 对搜索结果进行高亮显示（ 实时响应 ）

![realtim_hightlight_2022-08-22_09.16.25.2022-08-22
09_17_38](https://cdn.fatbobman.com/realtim_hightlight_2022-08-22_09.16.25.2022-08-22%2009_17_38.gif)

- 通过按钮实现搜索结果的切换

![image-20220822084740855](https://cdn.fatbobman.com/image-20220822084740855.png)

- 切换搜索结果时可自动定位到结果所在的位置

- 点击非当前高亮关键字，会自动将其设置为当前高亮关键字并滚动至视图中心位置

![scrollTo_keyword2_2022-08-22_09.06.20.2022-08-22
09_07_57](https://cdn.fatbobman.com/scrollTo_keyword2_2022-08-22_09.06.20.2022-08-22%2009_07_57.gif)

- 在对话数据较多的情况下（上千条）不应有性能瓶颈

## 解决思路

一千个人眼中有一千个哈姆雷特。本节的内容仅代表我在考虑处理上述问题时的想法和思路。其中不少功能已经超出了原本的需求，增加这些功能一方面有利于更多地融汇以前博客中的知识点，另一方面也提高了解题的乐趣。

### 搜索关键字

通过正则表达式获取到所有满足查询条件的信息。

- 通过 Regex 创建正则表达式

近两年，苹果逐步为 Foundation 添加越来越多的 Swift 原生实现。在去年增加了 AttributedString 和 FormatStyle
后，今年又增加了 Swift 版本的正则表达式实现 —— Regex。

对于当前的问题，我们首先要通过关键字创建在 transcription（ 录音转文字 ）中进行搜索的正则表达式：

    let regex = Regex<AnyRegexOutput>(verbatim: keyword).ignoresCase()

    // 相当于
    let regex = try! NSRegularExpression(pattern: keyword, options: [.caseInsensitive,.ignoreMetacharacters])

verbatim 将保证不会将关键字中的特殊字符当作正则参数，ignoresCase 意味着将创建忽略大小写的正则表达式。

- 通过 ranges (of regex:) 获取匹配区间

使用 Swift 为字符串新增的正则方法，可以快速获取查询所需的信息：

    for transcription in transcriptions {
        let ranges = transcription.context.ranges(of: regex) ranges
        for range in ranges {
           ...
        }
    }

鉴于我们仅需要匹配的区间，因此使用了 ranges 方法。使用 matches 可以获得更加丰富的信息。

- 为定位及智能高亮保存更多数据

为了方便之后的搜索结果显示和定位，每次搜索均需记录如下的信息 —— 搜索结果总数量、当前高亮的结果位置、包含搜索结果的 transcription、每个
transcrption 中符合条件的 range 以及在搜索结果中的序号（ 位置 ）。为了方便其他的条件判断，我们又分别以满足条件的
transcription ID 和 position 为键，创建了两个辅助字典。

    @Published var count: Int // 结果数量
    @Published var rangeResult: [UUID: [TranscriptionRange]] // 搜索结果 transcription.id : 结果区间和序号
    @Published var currentPosition: Int? // 当前的高亮位置
    @Published var positionProxy: [Int: UUID] // 结果序号 : transcription.id
    var positionProxyForID: [UUID: [Int]] = [:] // transcription.id : [结果序号]

    struct TranscriptionRange {
        let position: Int
        let range: Range<String.Index>
    }

### 高亮显示

在 Transcription 的显示视图 TranscriptionRow 中，通过 AttributedString 对结果进行高亮显示。

> 请阅读 [ AttributedString——不仅仅让文字更漂亮 ](/zh/posts/attributedstring/) 了解更多有关
> AttributedString 的内容

- 将 `Range<String.Index>` 转换成 `AttributedString.Index`

通过字符串的 ranges 方法获取的结果类型是 `Range<String.Index>` ，因此我们需要将其转换成 `AttributedString.Index` ，才能用于 AttributedString：

    var text = AttributedString(transcription.context)
    let lowerBound = AttributedString.Index(transcriptionRange.range.lowerBound, within: text)
    let upperBound = AttributedString.Index(transcriptionRange.range.upperBound, within: text)

- 通过 AttributedString 的下标方法对区间进行高亮显示设置

  if ranges.currentPosition == transcriptionRange.position {
  text[lowerBound..<upperBound].swiftUI.backgroundColor = currentHighlightColor
  if bold {
  text[lowerBound..<upperBound].foundation.inlinePresentationIntent = .stronglyEmphasized
  }
  } else {
  text[lowerBound..<upperBound].swiftUI.backgroundColor = highlightColor
  }

改变所有满足查询条件的内容背景色。对当前的选择位置，使用更加明亮的颜色并标注粗体。

![image-20220822161247454](https://cdn.fatbobman.com/image-20220822161247454.png)

### 点击切换按钮定位到对应的搜索结果

为 TranscriptionRow 视图添加显式标识符，并通过 ScrollViewProxy 滚动到指定的位置。

- 通过 id 修饰器为 transcription 添加定位信息

  List(0..<store.transcriptions.count,id:\.self) { index in
  let transcription = store.transcriptions[index]
  TranscriptionRow()
  .id(transcription.id)
  }

当为 ForEach （ 上面的代码使用了隐式 ForEach 形式 ）中的 View 添加显式标识符后（ 使用 id 修饰器），在视图刷新时，List
将会为 ForEach 中的所有视图创建实例（ 并非渲染 ）用以比对视图类型的构造参数是否发生变化，但仍然只会渲染屏幕上显示部分的 Row 视图。

因此，在本例中，我们舍弃了通过构造参数为 TranscriptionRow 传递搜索结果的方式，采用了在 TranscriptionRow 中引入符合
DynamicProperty 协议的 Source of Truth 。这样在搜索结果变化时，仅有当前显示的 TranscriptionRow
会重新计算并渲染（ 如果没有添加 id，通过构造参数传递搜索，对改善性能会更有帮助 ）。

> 请阅读 [ 优化在 SwiftUI List 中显示大数据集的响应效率
> ](/zh/posts/optimize_the_response_efficiency_of_list/) 以及 [ 避免 SwiftUI
> 视图的重复计算 ](/zh/posts/avoid_repeated_calculations_of_swiftui_views/)
> 两篇文章，了解更多有关性能优化方面的内容

- 通过 currentPostion 获取需要滚动到的 transcriptionID

由于滚动定位是根据 transcription ID 来实现的，因此，我们需要将搜索结果的位置序号转换成对应的 transcription ID：

    var currentID: UUID? { // 当前高亮所在的 transcription ID ，用于 scrollTo
        guard let currentPosition else { return nil }
        return positionProxy[currentPosition]
    }

- 通过 onChange 比较 transcriptionID 变化的前后值，减少不必要的滚动

考虑到使用者的阅读感受，我希望如果当前定位的 transcription 中的结果值已经为高亮显示值（ 当前选择的高亮位置 ），且下一个序号位置仍在同一个
transcription 中，那么将放弃滚动。通过在 onChange 的闭包中将新值与保存的旧值进行比对，可以实现上述目标。

    .onChange(of: store.currentPosition) { [lastID = store.currentID] _ in
        let currentID = store.currentID
        if lastID != currentID {
            withAnimation {
                scrollProxy.scrollTo(currentID, anchor: .center)
            }
        }
    }

    func gotoPrevious() {
        if let currentPosition, currentPosition > 0 {
            self.currentPosition = currentPosition - 1
        }
    }

    func gotoNext() {
        if let currentPosition, currentPosition < count - 1 {
            self.currentPosition = currentPosition + 1
        }
    }

没有比较新旧值的情况：

![avoid_scroll_without_compare_2022-08-22_17.30.10.2022-08-22
17_31_07](https://cdn.fatbobman.com/avoid_scroll_without_compare_2022-08-22_17.30.10.2022-08-22%2017_31_07.gif)

比较了新旧值，避免不必要的滚动：

![avoid_scroll_with_compare_2022-08-22_17.28.56.2022-08-22
17_32_23](https://cdn.fatbobman.com/avoid_scroll_with_compare_2022-08-22_17.28.56.2022-08-22%2017_32_23.gif)

> 阅读 [ 了解 SwiftUI 的 onChange ](/zh/posts/onchange/) 一文，了解更多有关 onChange 的内容

### 搜索关键字改变后有条件重新定位

- 如果当前的高亮位置仍能满足条件不发生滚动

  /// 以当前选中的关键字为优先
  private func getCurrentPositionIfSubRangeStillExist(oldRange: [UUID: [TranscriptionRange]], newRange: [UUID: [TranscriptionRange]], keyword: String, oldCurrentPosition: Int?) -> Int? {
  if let oldResult = oldRange.lazy.first(where: { $0.value.contains(where: { $0.position == oldCurrentPosition }) }),
  let oldRange = oldResult.value.first(where: { $0.position == oldCurrentPosition })?.range,
  let newResult = newRange.lazy.first(where: { $0.key == oldResult.key && $0.value.contains(where: { oldRange.overlaps($0.range) || $0.range.overlaps(oldRange) }) }),
  let newPosition = newResult.value.first(where: { oldRange.overlaps($0.range) })?.position
  {
  return newPosition
  } else {
  let nearPosition = getCurrentPositionIfInOnScreen()
  return nearPosition ?? nil
  }
  }

![keep_in_single_hightlight_keyword_2022-08-22_17.42.13.2022-08-22
17_42_52](https://cdn.fatbobman.com/keep_in_single_hightlight_keyword_2022-08-22_17.42.13.2022-08-22%2017_42_52.gif)

- 优先定位于当前屏幕正在显示的 transcription

将搜索结果优先定位于 List 当前显示的 transcription 中。如果当前显示的 transcription
无法满足条件，才会定位到第一个满足条件的结果位置。

为了达成这个目标，我们首先需要记录在 List 中，哪些 transcription 正在被显示，以及该 transcription 的索引。通过
onAppear 和 onDisappear 即可达成此目的：

    var onScreenID: [UUID: Int] = [:] // 当前屏幕中正显示的 transcription ID

    List(0..<store.transcriptions.count, id: \.self) { index in
        let transcription = store.transcriptions[index]
        TranscriptionRow()
        .onAppear { store.onScreenID[transcription.id] = index }
        .onDisappear { store.onScreenID.removeValue(forKey: transcription.id) }
        .id(transcription.id)
    }

> 在 List 中，每个视图进入显示窗口时都会调用它的 onAppear，每个视图退出显示窗口时都会调用它的 onDisapper。了解更多内容，请阅读
> [ SwiftUI 视图的生命周期研究 ](/zh/posts/swiftuilifecycle/) 一文

优先定位于最靠近屏幕中央的搜索结果：

    /// 从 List 当前显示中的 transcription 中就近选择 match 的 position
    private func getCurrentPositionIfInOnScreen() -> Int? {
        guard let midPosition = Array(onScreenID.values).mid() else { return nil }
        let idList = onScreenID.sorted(by: { (Double($0.value) - midPosition) < (Double($1.value) - midPosition) })
        guard let id = idList.first(where: { positionProxyForID[$0.key] != nil })?.key, let position = positionProxyForID[id] else { return nil }
        guard let index = transcriptions.firstIndex(where: { $0.id == id }) else { return nil }
        if Double(index) >= midPosition {
            return position.first
        } else {
            return position.last
        }
    }

![locate_onScreen_2022-08-22_17.49.52.2022-08-22
17_50_35](https://cdn.fatbobman.com/locate_onScreen_2022-08-22_17.49.52.2022-08-22%2017_50_35.gif)

### 点击搜索结果切换当前选择

点击非选择中的搜索结果，将其设置为当前的选择

![openURL_2022-08-22_18.08.13.2022-08-22
18_18_17](https://cdn.fatbobman.com/openURL_2022-08-22_18.08.13.2022-08-22%2018_18_17.gif)

- 通过 AttributedString 的 link 属性，添加定位信息

  let positionScheme = "goPosition" // 自定义 Schmem

  text[lowerBound..<upperBound].link = URL(string: "\(positionScheme)://\(transcriptionRange.position)")

- 使用 OpenURLAction 完成重定位操作

  List(0..<store.transcriptions.count, id: \.self) { index in
  ...
  }
  .environment(\.openURL, OpenURLAction { url in
  switch url.scheme {
  case positionScheme:
  if let host = url.host(), let position = Int(host) {
  store.scrollToPosition(position)
  }
  return .handled
  default:
  return .systemAction
  }
  })

  @MainActor
  func scrollToPosition(\_ position: Int) {
  if position >= 0, position < count - 1 {
  self.currentPosition = position
  }
  }

> 阅读 [ 在 SwiftUI 视图中打开 URL 的若干方法 ](/zh/posts/open_url_in_swiftui/) 一文，了解更多有关
> OpenURLAction 的内容

### 创建体验感优秀的搜索条

- 使用 safeAreaInset 添加搜索栏

在没有 safeAreaInset 修饰器的时候，我们通常会用两种方式添加搜索栏 —— 1、通过 VStack 将搜索栏放置在 List 下方，2、使用
overlay 将搜索栏放置在 List 视图的上层。但是如果采用 overlay 的方式，搜索栏将会挡住 List 最下方的记录。使用
safeAreaInset ，我们可以将搜索栏的区域设置为 List 下方的安全区域，这样既可以实现类似 Tab 覆盖 List 的效果，同时也不会遮盖
List 最下方的数据。

> 阅读 [ 掌握 SwiftUI 的 Safe Area ](/zh/posts/safearea/) 一文，了解更多有关 safeAreaInset
> 修饰器的内容

![safeArea_2022-08-22_18.24.59.2022-08-22
18_25_53](https://cdn.fatbobman.com/safeArea_2022-08-22_18.24.59.2022-08-22%2018_25_53.gif)

- 在搜索条出现时，让 TextField 获得焦点

通过 @FocusState ，让 TextField 在搜索条出现时，自动获得焦点，从而自动开启键盘。

> 阅读 [ SwiftUI TextField 进阶 —— 事件、焦点、键盘 ](/zh/posts/textfield-event-focus-
> keyboard/) 一文，了解更多有关焦点的内容

    @FocusState private var focused: Bool
    TextField("查找", text: $store.keyword)
        .focused($focused)
        .task {
            focused = true
        }

### 减少因实时搜索造成的性能负担

在当前的案例中，实时响应关键字并进行搜索，会给性能造成很大的负担。我们需要采用如下方式避免因此而导致的应用卡顿：

- 确保搜索操作运行于后台线程
- 过滤关键字响应，避免因为输入太快导致的无效搜索操作

我们通常会在 Combine 中采用 `.subscribe(on: )` 来设定之后的 operator 操作线程。在范例代码中，我使用了 [ 聊聊
Combine 和 async/await 之间的合作 ](/zh/posts/combineandasync/) 一文中介绍的方法，通过自定义
Publisher ，将 async/await 方法嵌入到 Combine 的操作管道中，以实现同样的效果。

    public extension Publisher {
        func task<T>(maxPublishers: Subscribers.Demand = .unlimited,
                     _ transform: @escaping (Output) async -> T) -> Publishers.FlatMap<Deferred<Future<T, Never>>, Self> {
            flatMap(maxPublishers: maxPublishers) { value in
                Deferred {
                    Future { promise in
                        Task {
                            let output = await transform(value)
                            promise(.success(output))
                        }
                    }
                }
            }
        }
    }

    public extension Publisher where Self.Failure == Never {
        func emptySink() -> AnyCancellable {
            sink(receiveValue: { _ in })
        }
    }

    cancellable = $keyword
        .removeDuplicates()
        .throttle(for: .seconds(0.1), scheduler: DispatchQueue.main, latest: true) // 使用 debounce 可能会漏掉 keyword 的最终变化
        .task(maxPublishers: .max(1)) { keyword in
            await self.search(keyword: keyword)
        }
        .emptySink()

同时，通过 `flatMap(maxPublishers: .max(1))` 、 `removeDuplicates` 和 `throttle` 进一步限制在单位时间内的所能进行的搜索次数，以保证应用的流畅度。

## 总结

范例代码并没有十分刻意地创建规范的数据流，但由于做到视图与数据分离，因此将其改写成任何你想使用的数据流方式并非难事。

尽管仅在搜索和 TranscriptionRow 视图注入两处对性能做了部分优化，但最终的流畅度已基本满足需求，也从侧面证明了 SwiftUI
具备了相当的实战能力。

# 避免 SwiftUI 视图的重复计算

随着近年来有关 SwiftUI 的文章与书籍越来越多，开发者应该都已经清楚地掌握了 —— “视图是状态的函数” 这一 SwiftUI
的基本概念。每个视图都有与其对应的状态，当状态变化时，SwiftUI 都将重新计算与其对应视图的 body 值。

如果视图响应了不该响应的状态，或者视图的状态中包含了不该包含的成员，都可能造成 SwiftUI 对该视图进行不必要的更新（ 重复计算
），当类似情况集中出现，将直接影响应用的交互响应，并产生卡顿的状况。

通常我们会将这种多余的计算行为称之为过度计算或重复计算。本文将介绍如何减少（ 甚至避免 ）类似的情况发生，从而改善 SwiftUI 应用的整体表现。

## 视图状态的构成

可以驱动视图进行更新的源被称之为 Source of Truth，它的类型有：

- 使用 @State、@StateObject 这类属性包装器声明的变量
- 视图类型（ 符合 View 协议 ）的构造参数
- 例如 onReceive 这类的事件源

一个视图可以包含多个不同种类的 Source of Truth，它们共同构成了视图状态（ 视图的状态是个复合体 ）。

基于不同种类的 Source of Truth 的实现原理与驱动机制之间的区别，下文中，我们将以此为分类，分别介绍其对应的优化技巧。

## 符合 DynamicProperty 协议的属性包装器

几乎每一个 SwiftUI 的使用者，在学习 SwiftUI 的第一天就会接触到例如 @State、@Binding 这些会引发视图更新的属性包装器。

随着 SwiftUI 的不断发展，这类的属性包装器越来越多，已知的有（ 截至 SwiftUI
4.0）：@AccessibilityFocusState、@AppStorage、@Binding、@Environment、@EnvironmentObject、@FetchRequest、@FocusState、@FocusedBinding、@FocusedObject、@FocusedValue、@GestureState、@NSApplicationDelegateAdaptor、@Namespace、@ObservadObject、@ScaledMetric、@SceneStorage、@SectionedFetchRequest、@State、@StateObject、@UIApplicationDelegateAdaptor、@WKApplicationDelegateAdaptor、@WKExtentsionDelegateAdaptor
等。所有可以让变量成为 Source of Truth 的属性包装器都有一个特点 —— 符合 DynamicProperty 协议。

因此，了解 DynamicProperty 协议的运作机制对于优化因该种类 Source of Truth 造成的重复计算尤为重要。

### DynamicProperty 的工作原理

苹果并没有提供太多有关 DynamicProperty 协议的资料，公开的协议方法只有 update ，其完整的协议要求如下：

    public protocol DynamicProperty {
      static func _makeProperty<V>(in buffer: inout _DynamicPropertyBuffer, container: _GraphValue<V>, fieldOffset: Int, inputs: inout _GraphInputs)
      static var _propertyBehaviors: UInt32 { get }
      mutating func update()
    }

其中 `_makeProperty` 方法是整个协议的灵魂所在。通过 `_makeProperty` 方法，SwiftUI
得以实现在将视图加载到视图树时，把所需的数据（ 值、方法、引用等 ）保存在 SwiftUI 的托管数据池中，并在属性图（ AttributeGraph
）中将视图与该 Source of Truth 关联起来，让视图响应其变化（ **当 SwiftUI 数据池中的数据给出变化信号时，更新视图** ）。

以 @State 为例：

    @propertyWrapper public struct State<Value> : DynamicProperty {
      internal var _value: Value
      internal var _location: SwiftUI.AnyLocation<Value>? // SwiftUI 托管数据池中的数据引用
      public init(wrappedValue value: Value)
      public init(initialValue value: Value) {
            _value = value // 创建实例时，只会暂存初始值
        }
      public var wrappedValue: Value {
        get  //  guard let _location else { return _value} ...
        nonmutating set // 只能改动 _location 指向的数据
      }
      public var projectedValue: SwiftUI.Binding<Value> {
        get
      }
      // 在将视图加载到视图树中时，调用此方法，完成关联工作
      public static func _makeProperty<V>(in buffer: inout _DynamicPropertyBuffer, container: _GraphValue<V>, fieldOffset: Int, inputs: inout _GraphInputs)
    }

- 在初始化 State 时，initialValue 仅被保存在 State 实例的内部属性 \_value 中，此时，使用 Stae 包装的变量值没有被保存在 SwiftUI 的托管数据池中，并且 SwiftUI 也尚未在属性图中将其作为 Source of Truth 与视图关联起来。

- 当 SwiftUI 将视图加载到视图树时，通过调用 `_makeProperty` 完成将数据保存到托管数据池以及在属性图中创建关联的操作，并将数据在托管数据池中的引用保存在 `_location` （ AnyLocation 为引用类型，为 AnyLocationBase 的子类 ） 中。wrappedValue 的 get 和 set 方法都是针对 `_location` 操作的（ projectedValue 也一样 ）。

- 当 SwiftUI 将视图从视图树上删除时，会一并完成对 SwiftUI 数据池以及关联的清理工作。如此，使用 State 包装的变量，其存续期将与视图的存续期保持完全一致。并且 SwiftUI 会在其变化时自动更新（ 重新计算 ）对应的视图。

SwiftUI 上有一个困扰了不少人的问题：为什么无法在视图的构造函数中，更改 State 包装的变量值？了解了上述过程，问题便有了答案。

    struct TestView: View {
        @State private var number: Int = 10
        init(number: Int) {
            self.number = 11 // 更改无效
        }
        var body: some View {
            Text("\(number)") // 首次运行，显示 10
        }
    }

在构造函数中使用 `self.number = 11` 赋值时，视图尚未加载，\_location 为 nil , 因此赋值对应的
wrappedValue set 操作并不会起作用。

对于像 @StateObject 这类针对引用类型的属性包装器，SwiftUI 会在属性图中将视图与包装对象实例（ 符合 ObservableObject
协议 ）的 objectWillChange（ ObjectWillChangePublisher ）关联起来， **在该 Publisher
发送数据时，更新视图** 。任何通过 `objectWillChange.send` 进行的操作都将导致视图被刷新，无论实例中的属性内容是否被修改。

    @propertyWrapper public struct StateObject<ObjectType> : DynamicProperty where ObjectType : ObservableObject {
      internal enum Storage { // 通过内部定义的枚举来标注视图是否已经被加载、数据是否已被数据池托管
        case initially(() -> ObjectType)
        case object(ObservedObject<ObjectType>)
      }

      internal var storage: StateObject<ObjectType>.Storage
      public init(wrappedValue thunk: @autoclosure @escaping () -> ObjectType) {
            storage = .initially(thunk) // 初始化，视图尚未加载
        }
      @_Concurrency.MainActor(unsafe) public var wrappedValue: ObjectType {
        get
      }
      @_Concurrency.MainActor(unsafe) public var projectedValue: SwiftUI.ObservedObject<ObjectType>.Wrapper {
        get
      }
        // 在 DynamicProperty 要求的方法中，实现将实例保存在托管数据池，并将视图与托管实例的 objectWillChange 进行关联
      public static func _makeProperty<V>(in buffer: inout _DynamicPropertyBuffer, container: _GraphValue<V>, fieldOffset: Int, inputs: inout _GraphInputs)
    }

@ObservedObject 与 @StateObject 最大的区别是，ObservedObject 并不会在 SwiftUI
托管数据池中保存引用对象的实例（ @StateObject 会将实例保存在托管数据池中 ），仅会在属性图中创建视图与视图类型实例中的引用对象的
objectWillChange 之间的关联。

    @ObservedObject var store = Store() // 每次创建视图类型实例，都会重新创建 Store 实例

由于 SwiftUI 会不定时地创建视图类型的实例（ 非加载视图 ），每次创建的过程都会重新创建一个新的引用对象，因此假设使用上面的代码（ 用
@ObservedObject 创建实例 ），让 @ObservedObject 指向一个不稳定的引用实例时，很容易出现一些怪异的现象。

> 阅读如下的文章，可以帮助你更好地理解本节的内容： [ SwiftUI 视图的生命周期研究 ](/zh/posts/swiftuilifecycle/)
> 、 [ @state 研究 ](/zh/posts/swiftui-state/) 、 [ @StateObject 研究
> ](/zh/posts/stateobject/)

### 避免非必要的声明

任何可以在当前视图之外进行改动的 Source of Truth（ 符合 DynamicProperty 协议的属性包装器
），只要在视图类型中声明了，无论是否在视图 body 中被使用，在它给出刷新信号时，当前视图都将被刷新。

例如下面的代码：

    struct EnvObjectDemoView:View{
        @EnvironmentObject var store:Store
        var body: some View{
            Text("abc")
        }
    }

虽然当前的视图中并没有调用 store 实例的属性或方法，但无论在任何场合，但只要该实例的 objectWillChange. send 方法被调用（
例如修改了使用 @Published 包装的属性 ），所有与之相关联的视图（ 包括当前视图 ）都会被刷新（ 对 body 求值 ）。

类型的情况在 @ObservedObject、@Environment 上也会出现：

    struct MyEnvKey: EnvironmentKey {
        static var defaultValue = 10
    }

    extension EnvironmentValues {
        var myValue: Int {
            get { self[MyEnvKey.self] }
            set { self[MyEnvKey.self] = newValue }
        }
    }

    struct EnvDemo: View {
        @State var i = 100
        var body: some View {
            VStack {
                VStack {
                    EnvSubView()
                }
                .environment(\.myValue, i)
                Button("change") {
                    i = Int.random(in: 0...100)
                }
            }
        }
    }

    struct EnvSubView: View {
        @Environment(\.myValue) var myValue // 声明了，但并没有在 body 中使用
        var body: some View {
            let _ = print("sub view update")
            Text("Sub View")
        }
    }

即使 EnvSubView 的 body 中没有使用 myValue，但由于其祖先视图对 EnvironmentValues 中的 myValue
进行了修改，EnvSubView 也会被刷新。

只要多检查代码，清除掉这些没有使用的声明，就可以避免因此种方式产生重复计算。

### 其他建议

- 需要跳跃视图层级时，考虑使用 Environment 或 EnvironmentObject

- 对于不紧密的 State 关系，考虑在同一个视图层级使用多个 EnvironmentObject 注入，将状态分离

- 在合适的场景中，可以使用 objectWillChange. send 替换 @Published

- 可以考虑使用第三方库，对状态进行切分，减少视图刷新几率

- 无需追求完全避免重复计算，应在依赖注入便利性、应用性能表现、测试难易度等方面取得平衡

- 不存在完美的解决方案，即使像 TCA 这类的热门项目，面对切分粒度高、层次多的 State 时，也会有明显的性能瓶颈

## 视图的构造参数

在尝试改善 SwiftUI 视图的重复计算行为时，开发者通常会将注意力集中于那些符合 DynamicProperty
协议的属性包装器之上，然而，对视图类型构造参数进行优化，有时会取得更加明显的收益。

SwiftUI 会将视图类型的构造参数作为 Source of Truth 对待。与符合 DynamicProperty
协议的属性包装器主动驱动视图更新的机制不同，SwiftUI 在更新视图时，会通过检查子视图的实例是否发生变化（ 绝大多数都由构造参数值的变化导致
）来决定对子视图更新与否。

例如：当 SwiftUI 在更新 ContentView 时，如果 SubView 的构造参数（ name 、age ）的内容发生了变化，SwiftUI
会对 SubView 的 body 重新求值（ 更新视图 ）。

    struct SubView{
        let name:String
        let age:Int

        var body: some View{
            VStack{
                Text(name)
                Text("\(age)")
            }
        }
    }

    struct ContentView {
        var body: some View{
            SubView(name: "fat" , age: 99)
        }
    }

### 简单、粗暴、高效的比对策略

我们知道，在视图的存续期中，SwiftUI 通常会多次地创建视图类型的实例。在这些创建实例的操作中，绝大多数的目的都是为了检查视图类型的实例是否发生了变化（
绝大多数的情况下，变化是由构造参数的值发生了变化而导致 ）。

- 创建新实例
- 将新实例与 SwiftUI 当前使用的实例进行比对
- 如实例发生变化，用新实例替换当前实例，对实例的 body 求值，并用新的视图值替换老的视图值
- 视图的存续期不会因为实体的更替有所改变

由于 SwiftUI 并不要求视图类型必须符合 Equatable 协议，因此采用了一种简单、粗暴但十分高效地基于 Block 的比对操作（
并非基于参数或属性 ）。

比对结果仅能证明两个实例之间是否不同，但 SwiftUI 无法确定这种不同是否会导致 body 的值发生变化，因此，它会无脑地对 body 进行求值。

为了避免产生重复计算，通过优化构造参数的设计，让实例仅在真正需要更新时才发生变化。

> 由于创建视图类型实例的操作异常地频繁，因此一定不要在视图类型的构造函数中进行任何会对系统造成负担的操作。另外，不要在视图的构造函数中为属性（
> 没有使用符合 DynamicProperty 协议的包装器 ）设置不稳定值（ 例如随机值 ）。不稳定值会导致每次创建的实例都不同，从而造成非必要的刷新

### 化整为零

上述的比对操作是在视图类型实例中进行的，这意味着将视图切分成多个小视图（ 视图结构体 ）可以获得更加精细的比对结果，并会减少部分 body 的计算。

    struct Student {
        var name: String
        var age: Int
    }

    struct RootView:View{
        @State var student = Student(name: "fat", age: 88)
        var body: some View{
            VStack{
                StudentNameView(student: student)
                StudentAgeView(student: student)
                Button("random age"){
                    student.age = Int.random(in: 0...99)
                }
            }
        }
    }

    // 分成小视图
    struct StudentNameView:View{
        let student:Student
        var body: some View{
            let _ = Self._printChanges()
            Text(student.name)
        }
    }

    struct StudentAgeView:View{
        let student:Student
        var body: some View{
            let _ = Self._printChanges()
            Text(student.age,format: .number)
        }
    }

上面的代码虽然实现了将 Student 的显示子视图化，但是由于构造参数的设计问题，并没有起到减少重复计算的效果。

在点击 random age 按钮修改 age 属性后，尽管 StudentNameView 中并没有使用 age 属性，但 SwiftUI 仍然对
StudentNameView 和 StudentAgeView 都进行了更新。

这是因为，我们将 Student 类型作为参数传递给了子视图，SwiftUI 在比对实例的时候，并不会关心子视图中具体使用了 student
中的哪个属性，只要 student 发生了变化，那么就会重新计算。为了解决这个问题，我们应该调整传递给子视图的参数类型和内容，仅传递子视图需要的数据。

    struct RootView:View{
        @State var student = Student(name: "fat", age: 88)
        var body: some View{
            VStack{
                StudentNameView(name: student.name) // 仅传递需要的数据
                StudentAgeView(age:student.age)
                Button("random age"){
                    student.age = Int.random(in: 0...99)
                }
            }
        }
    }

    struct StudentNameView:View{
        let name:String // 需要的数据
        var body: some View{
            let _ = Self._printChanges()
            Text(name)
        }
    }

    struct StudentAgeView:View{
        let age:Int
        var body: some View{
            let _ = Self._printChanges()
            Text(age,format: .number)
        }
    }

经过上面的改动后，仅当 name 属性发生变化时，StudentNameView 才会更新，同理，StudentAgeView 也只会在 age
发生变化时更新。

### 让视图符合 Equatable 协议以自定义比对规则

也许由于某种原因，你无法采用上面的方法来优化构造参数，SwiftUI 还提供了另外一种通过调整比对规则的方式用以实现相同的结果。

- 让视图符合 Equatable 协议
- 为视图自定义判断相等的比对规则

> 在早期的 SwiftUI 版本中，我们需要使用 EquatableView 包装符合 Equatable
> 协议的视图以启用自定义比较规则，近期的版本已经无需使用

仍以上面的代码举例：

    struct RootView: View {
        @State var student = Student(name: "fat", age: 88)
        var body: some View {
            VStack {
                StudentNameView(student: student)
                StudentAgeView(student: student)
                Button("random age") {
                    student.age = Int.random(in: 0...99)
                }
            }
        }
    }

    struct StudentNameView: View, Equatable {
        let student: Student
        var body: some View {
            let _ = Self._printChanges()
            Text(student.name)
        }

        static func == (lhs: Self, rhs: Self) -> Bool {
            lhs.student.name == rhs.student.name
        }
    }

    struct StudentAgeView: View, Equatable {
        let student: Student
        var body: some View {
            let _ = Self._printChanges()
            Text(student.age, format: .number)
        }

        static func== (lhs: Self, rhs: Self) -> Bool {
            lhs.student.age == rhs.student.age
        }
    }

> 此种方法仅会影响视图类型实例的比对，并不会影响因符合 DynamicProperty 协议的属性包装器产生的刷新

### 闭包 —— 容易被忽略的突破点

当构造参数的类型为函数时，稍不注意，就可以导致重复计算。

比如，下面的代码：

    struct ClosureDemo: View {
        @StateObject var store = MyStore()
        var body: some View {
            VStack {
                if let currentID = store.selection {
                    Text("Current ID: \(currentID)")
                }
                List {
                    ForEach(0..<100) { i in
                        CellView(id: i){ store.sendID(i) } // 使用尾随闭包的方式为子视图设定按钮动作
                    }
                }
                .listStyle(.plain)
            }
        }
    }

    struct CellView: View {
        let id: Int
        var action: () -> Void
        init(id: Int, action: @escaping () -> Void) {
            self.id = id
            self.action = action
        }

        var body: some View {
            VStack {
                let _ = print("update \(id)")
                Button("ID: \(id)") {
                    action()
                }
            }
        }
    }

    class MyStore: ObservableObject {
        @Published var selection:Int?

        func sendID(_ id: Int) {
            self.selection = id
        }
    }

当点击某一个 CellView 视图的按钮后，所有的 CellView （ 当前 List 显示区域 ）都会重新计算。

![closure_view_udpate1_2022-07-30_14.37.20.2022-07-30
14_41_08](https://cdn.fatbobman.com/closure_view_udpate1_2022-07-30_14.37.20.2022-07-30%2014_41_08.gif)

这是因为，乍看起来，我们并没有在 CellView 中引入会导致更新的 Source of Truth，但由于我们将 store
放置在闭包当中，点击按钮后，因为 store 发生了变动，从而导致 SwiftUI 在对 CellView 实例进行比对时认定其发生了变化。

    CellView(id: i){ store.sendID(i) }

解决的方法有两种：

- 让 CellView 符合 Equatable 协议，不比较 action 参数

  struct CellView: View, Equatable {
  let id: Int
  var action: () -> Void
  init(id: Int, action: @escaping () -> Void) {
  self.id = id
  self.action = action
  }

      var body: some View {
          VStack {
              let _ = print("update \(id)")
              Button("ID: \(id)") {
                  action()
              }
          }
      }

      static func == (lhs: Self, rhs: Self) -> Bool { // 将 action 排除在比较之外
          lhs.id == rhs.id
      }

  }

  ForEach(0..<100) { i in
  CellView(id: i){ store.sendID(i) }
  }

- 修改构造参数中的函数定义，将 store 排除在 CellView 之外

  struct CellView: View {
  let id: Int
  var action: (Int) -> Void // 修改函数定义
  init(id: Int, action: @escaping (Int) -> Void) {
  self.id = id
  self.action = action
  }

      var body: some View {
          VStack {
              let _ = print("update \(id)")
              Button("ID: \(id)") {
                  action(id)
              }
          }
      }

  }

  ForEach(0..<100) { i in
  CellView(id: i, action: store.sendID) // 直接传递 store 中的 sendID 方法，将 store 排除在外
  }

![closure_view_udpate2_2022-07-30_14.38.32.2022-07-30
14_41_52](https://cdn.fatbobman.com/closure_view_udpate2_2022-07-30_14.38.32.2022-07-30%2014_41_52.gif)

## 事件源

为了全面地向 SwiftUI life cycle 转型，苹果为 SwiftUI
提供了一系列可以直接在视图中处理事件的视图修饰器，例如：onReceive、onChange、onOpenURL、onContinueUserActivity
等。这些触发器被称为事件源，它们也被视为 Source of Truth ，是视图状态的组成部分。

这些触发器是以视图修饰器的形式存在的，因此触发器的生命周期同与其关联的视图的存续期完全一致。当触发器接收到事件后，无论其是否更改当前视图的其他状态，当前的视图都会被更新。因此，为了减少因事件源导致的重复计算，我们可以考虑采用如下的优化思路：

- 控制生命周期

只在需要处理事件时才加载与其关联的视图，用关联视图的存续期来控制触发器的生命周期

- 减小影响范围

为触发器创建单独的视图，将其对视图更新的影响范围降至最低

    struct EventSourceTest: View {
        @State private var enable = false

        var body: some View {
            VStack {
                let _ = Self._printChanges()
                Button(enable ? "Stop" : "Start") {
                    enable.toggle()
                }
                TimeView(enable: enable) // 单独的视图，onReceive 只能导致 TimeView 被更新
            }
        }
    }

    struct TimeView:View{
        let enable:Bool
        @State private var timestamp = Date.now
        var body: some View{
            let _ = Self._printChanges()
            Text(timestamp, format: .dateTime.hour(.twoDigits(amPM: .abbreviated)).minute(.twoDigits).second(.twoDigits))
                .background(
                    Group {
                        if enable { // 只在需要使用时，才加载触发器
                            Color.clear
                                .task {
                                    while !Task.isCancelled {
                                        try? await Task.sleep(nanoseconds: 1000000000)
                                        NotificationCenter.default.post(name: .test, object: Date())
                                    }
                                }
                                .onReceive(NotificationCenter.default.publisher(for: .test)) { notification in
                                    if let date = notification.object as? Date {
                                        timestamp = date
                                    }
                                }
                        }
                    }
                )
        }
    }

    extension Notification.Name {
        static let test = Notification.Name("test")
    }

![event_source_2022-07-30_16.13.13.2022-07-30
16_14_08](https://cdn.fatbobman.com/event_source_2022-07-30_16.13.13.2022-07-30%2016_14_08.gif)

> 请注意，SwiftUI 会在主线程上运行触发器闭包，如果闭包中的操作比较昂贵，可以考虑将闭包发送到后台队列

## 总结

本文介绍了一些在 SwiftUI
中如何避免造成视图重复计算的技巧，除了从中查找是否有能解决你当前问题的方法外，我更希望大家将关注点集中于这些技巧在背后对应的原理。

# 构建稳定的预览视图 —— SwiftUI 预览的工作原理

作为 SwiftUI 最引人注目的功能之一，预览功能吸引了不少开发者初次接触
SwiftUI。然而，随着项目规模的增长，越来越多的开发者发现预览功能并不如最初想象的那么易用。由于预览崩溃的次数和场景的增加，一些开发者已经视预览为
SwiftUI 的缺点之一，并对其产生了排斥感。

预览功能真的如此不堪吗？我们当前使用预览的方式真的妥当吗？我将通过两篇文章来分享我对预览功能的认知和理解，并探讨如何构建稳定的预览。本文将首先剖析预览功能的实现机制，让开发者了解哪些情况是预览必然无法处理的。

## 让预览崩溃的一段视图代码

不久前，Toomas Vahter 写了一篇博客 [ Bizarre error in SwiftUI preview
](https://augmentedcode.io/2023/04/17/bizarre-error-in-swiftui-preview/)
，其中提到了一个有趣的现象。下面这段代码可以在真机和模拟器上运行，但会导致预览崩溃。

    import SwiftUI

    struct ContentView: View {
        @StateObject var viewModel = ViewModel()
        var body: some View {
            VStack {
                ForEach(viewModel.items) { item in
                    Text(verbatim: item.name)
                }
            }
            .padding()
        }
    }

    extension ContentView {
        final class ViewModel: ObservableObject {
            let items: [Item] = [
                Item(name: "first"),
                Item(name: "second"),
            ]
            func select(_: Item) {
                // implement
            }
        }

        struct Item: Identifiable {
            let name: String
            var id: String { name }
        }
    }

    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
        }
    }

解决的方法，便是将：

    func select(_: Item) {
                // implement
    }

修改为：

    func select(_: ContentView.Item) {
                // implement
    }

修改后，预览功能可以正常工作了。可惜的是，Toomas Vahter 在文章中没有告诉读者崩溃原因。我借用这段代码来与大家一起探究预览功能是如何工作的。

> 感谢 Dennis Nehrenheim 在 Medium 上的告知，这个问题已经在 Xcode 14.3.1
> 下被解决了。不过，即便如此，并不影响本文对预览原理的解释。

## 探寻预览崩溃的原因

首先，创建一个名为 StablePreview 的新 iOS 项目。将上述代码复制到其中（ **注意：此时不要启动视图预览** ），然后编译项目。

![image-20230522105513088](https://cdn.fatbobman.com/image-20230522105513088.png)

找到该项目对应的 Derived Data 目录。

![image-20230522105916884](https://cdn.fatbobman.com/image-20230522105916884.png)

在项目对应的 Derived Data 目录中，查找尾缀为 `.preview-thunk.swift` 的文件：

![image-20230522110506987](https://cdn.fatbobman.com/image-20230522110506987.png)

此时 Derived Data 目录中应该没有满足条件的文件。

点击预览的启用按钮，启动预览。

![image-20230522110636690](https://cdn.fatbobman.com/image-20230522110636690.png)

你会发现预览无法正常使用，错误提示为：

![image-20230522110719469](https://cdn.fatbobman.com/image-20230522110719469.png)

我们再次查找当前项目 Derived Data 目录下尾缀为 `.preview-thunk.swift` 的文件。

![image-20230522110813828](https://cdn.fatbobman.com/image-20230522110813828.png)

这时候，你会看到 Xcode 帮助我们生成了一个名为 `ContentView.1.preview-thunk.swift` 的文件。该文件是
Xcode 为预览功能生成的衍生代码，让我们打看这个文件，看看究竟生成了什么内容。

    @_private(sourceFile: "ContentView.swift") import StablePreview
    import SwiftUI
    import SwiftUI

    extension ContentView_Previews {
        @_dynamicReplacement(for: previews) private static var __preview__previews: some View {
            #sourceLocation(file: "/Users/yangxu/Documents/博客相关/BlogCodes/StablePreview/StablePreview/ContentView.swift", line: 34)
            ContentView()

    #sourceLocation()
        }
    }

    extension ContentView.Item {
    typealias Item = ContentView.Item

        @_dynamicReplacement(for: id) private var __preview__id: String {
            #sourceLocation(file: "/Users/yangxu/Documents/博客相关/BlogCodes/StablePreview/StablePreview/ContentView.swift", line: 28)
     name

    #sourceLocation()
        }
    }

    extension ContentView.ViewModel {
    typealias ViewModel = ContentView.ViewModel

        @_dynamicReplacement(for: select(_:)) private func __preview__select(_: Item) {
            #sourceLocation(file: "/Users/yangxu/Documents/博客相关/BlogCodes/StablePreview/StablePreview/ContentView.swift", line: 22)

    #sourceLocation()
                // implement
        }
    }

    extension ContentView {
        @_dynamicReplacement(for: body) private var __preview__body: some View {
            #sourceLocation(file: "/Users/yangxu/Documents/博客相关/BlogCodes/StablePreview/StablePreview/ContentView.swift", line: 6)
            VStack {
                ForEach(viewModel.items) { item in
                    Text(verbatim: item.name)
                }
            }
            .padding()

    #sourceLocation()
        }
    }

    import struct StablePreview.ContentView
    import struct StablePreview.ContentView_Previews

其中有这么几个语言特性需要注意：

- `@_private(sourceFile: )`

让当前代码可以访问原本外部无法访问的变量和函数，这样我们就无需在项目代码中提高访问权限。

- `#sourceLocation(file: ,line: )`

负责将衍生代码中发生的崩溃等调试信息反映在我们写的代码上，帮助开发者找到对应的源代码位置。

- `@_dynamicReplacement(for: )`

`@_dynamicReplacement` 是实现预览功能的关键机制。它用于指定某个方法作为另一个方法的动态替代方法。在衍生代码中，Xcode 使用
@\_dynamicReplacement 为多个函数提供了替代方法。在预览时，以替代后的 `__preview__previews`
方法作为预览入口。请参阅 [ Swift Native method swizzling
](https://www.guardsquare.com/blog/swift-native-method-swizzling) 以了解
@\_dynamicReplacement 的更多信息。

- `import struct StablePreview.ContentView`

在衍生代码中，未使用 `import StablePreview` ，而是使用了 `import struct
StablePreview.ContentView`
。这意味着编译器在编译这段代码时，可以依赖的信息很少，只能在很小的范围内进行类型推断，以提高效率。这也是本段代码无法在预览中正常运行的主要原因。

编译器在编译下面的代码时，无法找到 Item 对应的定义，因此导致预览失败。

    extension ContentView.ViewModel { // 无法进行正确的类型推断
    typealias ViewModel = ContentView.ViewModel

        @_dynamicReplacement(for: select(_:)) private func __preview__select(_: Item) {
            #sourceLocation(file: "/Users/yangxu/Documents/博客相关/BlogCodes/StablePreview/StablePreview/ContentView.swift", line: 22)

    #sourceLocation()
                // implement
        }
    }

按照原博客的做法，将 `func select(_: Item)` 特征为 `func select(_: ContentView.Item)`
后，衍生代码将改变为：

    extension ContentView.ViewModel {
    typealias ViewModel = ContentView.ViewModel

        @_dynamicReplacement(for: select(_:)) private func __preview__select(_: ContentView.Item) { // 具备了详细的信息，可以获取到 Item 的定义
            #sourceLocation(file: "/Users/yangxu/Documents/博客相关/BlogCodes/StablePreview/StablePreview/ContentView.swift", line: 22)

    #sourceLocation()
                // implement
        }
    }

因此在编译的时候，也就能够正确的获取 Item 的定义信息了。

这就解释了这段代码为什么在模拟器和真机中可以运行，但会导致预览崩溃。因为预览是以衍生代码作为入口，只依赖有限的导入信息对衍生代码进行编译，因此可能会出现因信息不完整而无法编译的情况。而在模拟器和真机运行时，并不需要编译为预览准备的衍生代码，只需要编译项目文件即可。编译器能够从完整的代码中正确推断出
ContentView 中的 Item 对应 `func select(_: Item)` 中的 Item。

了解了问题所在，我们还可以使用其他两种方式来解决之前的代码无法在预览中使用的问题。

- 方法一

将 Item 从 ContentView 中移出来，放置到与 ContentView 同级的代码位置。这样，在预览的衍生代码中，将会出现 `import
struct StablePreview.Item` 这行代码。编译器也就能够正确处理 `func select(_: Item)` 了。

- 方法二

在与 ContentView 同级的代码位置添加 `typealias Item = ContentView.Item` 。在预览的衍生代码中，将会出现
`typealias Item = StablePreview.Item` 。经过两次别名指引，编译器也能找到正确的 Item 定义。

接下来，让我们继续查看 Xcode 是如何加载预览视图的。。

在项目的 Derived Data 目录中查找尾缀为 `.preview-thunk.dylib` 的文件。

![image-20230522131911942](https://cdn.fatbobman.com/image-20230522131911942.png)

该文件是预览状态下衍生代码编译后生成的动态库。在该文件所在位置执行以下命令： `nm ./ContentView.1.preview-thunk.dylib | grep ' T '`

![image-20230522132730344](https://cdn.fatbobman.com/image-20230522132730344.png)

可以看出，Xcode 在编译了预览的衍生文件后，在动态库中只生成了一个 `_main 方法`
。在该方法中，大概率进行了定义预览相关的环境设置、设置预览初始状态等操作。最后，再创建了几个专门用于预览的进程。通过 XPC 在预览进程与 Xcode
之间进行通信，最终实现了在 Xcode 中预览特定视图的目的。

![image-20230522134401399](https://cdn.fatbobman.com/image-20230522134401399.png)

> 阅读 Damian Malarczyk 所写的 [ Behind SwiftUI Previews
> ](https://www.guardsquare.com/blog/behind-swiftui-previews) 一文，了解更多实现细节。

## 预览的工作流程

我们对上面的探索过程进行一个梳理，大致上可以得到如下的工作流程：

- Xcode 生成预览衍生代码文件
- Xcode 编译整个项目，解析文件、获取预览视图实现、准备依赖的其他资源
- Xcode 编译预览衍生代码文件，创建动态库
- Xcode 启动预览进程，在其中加载 \_XCPreviewKit 框架和预览衍生文件生成的 dylib
- XCPreviewKit 框架在预览进程中创建预览窗口
- Xcode 通过 XPC 发送消息指令， \_XCPreviewKit 框架更新预览窗口，并在两个进程建进行交互与同步
- 用户在 Xcode 界面中看到预览效果

## 从预览的实现中可以得到的部分结论

- 如果项目无法编译，预览也无法正常运行
- 预览并没有启动完整的模拟器，因此某些代码无法在预览中实现预期的行为，例如（ 预览不存在应用程序的生命周期事件 ）：

  struct ContentView: View {

      var body: some View {
          VStack {
              Text("Hello world")
          }
          .onReceive(NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)) { _ in
              print("App will resign active")
          }
      }

  }

  struct ContentView_Previews: PreviewProvider {
  static var previews: some View {
  ContentView()
  }
  }

- 为了提高效率，生成的预览衍生文件会尽可能减少不必要的导入。但是，这也可能导致无法正常编译的情况发生（例如本文中的例子）
- 预览是以预览衍生文件作为入口的，开发者必须在预览代码中为预览视图提供足够的上下文信息（ 例如注入所需的环境对象 ）

总的来说，Xcode
预览功能虽然在视图开发流程中极为方便，但它仍处在一个功能受限的环境中。开发者使用预览时需要清醒地认识到其局限性，并避免在预览中实现超出其能力范围的功能。

## 接下来

在本文中，我们探讨了 Xcode
预览功能的实现原理，并指出其存在一定局限性。在下一篇文章中，我们将从开发者的角度审视预览功能：它的设计目的、最适宜的使用场景以及如何构建稳定高效的预览。

# SwiftUI Overlay Container 2 —— 可定制、高效、便捷的视图管理器

[ SwiftUI Overlay Container
](https://github.com/fatbobman/SwiftUIOverlayContainer) 是一个用于 SwiftUI
的视图容器组件。一个可定制、高效、便捷的视图管理器。

仅需简单配置，SwiftUI Overlay Container
即可帮你完成从视图组织、队列处理、转场、动画、交互到显示样式配置等基础工作，让开发者可以将精力更多地投入到应用程序视图的实现本身。

## 历史

2020 年夏天，在为 [ 健康笔记 ](/healthnotes/)
添加侧向滑动菜单的过程中，我发现在开发中经常会碰到需要在一个视图的上方动态添加另一视图的场景，例如（提示信息、广告、浮动按钮、新手指南等等）。因此，我写了一个组件希望可以帮助开发者在
SwiftUI 中快速完成上述需求。但受限于当时的技术能力，很多的想法都没有能够很好地实现。

近期我重写了该组件，除了实现了以前尚未支持的功能外，更重要的是，以此检验一下自己这段时间的能力是否有所提高。

大家可以从 [ 这里 ](https://github.com/fatbobman/SwiftUIOverlayContainer) 获取最新的版本。

> 本文的内容直接搬运自项目的 README 文档。

## 设计动机

当我们需要在视图的上层显示新的内容（例如：弹出信息、侧边菜单、帮助提示等）时，有很多优秀的第三方解决方案可以帮助我们分别实现，但没有一个方案可以同时应对不同的场景需求。在
SwiftUI
中，描述视图已经变得十分的容易，因此我们完全可以将上述场景中的显示逻辑提炼出来，创建出一个可以覆盖更多使用场景的库，帮助开发者组织视图的显示风格和交互逻辑。

## 功能与特性

- 支持多个容器
- 单一容器内支持多个视图
- 可在 SwiftUI 视图代码内或视图代码外向任意指定的容器推送视图
- 可以动态修改容器的配置（除了队列类型）
- 容器内的视图有多种排列方式
- 有多种队列类型以指导容器如何显示视图

## 快速使用指南

> 更详细的信息，可以参看库中的演示以及源代码中的注释。

### 创建容器

在指定视图上层创建一个视图容器，此容器的尺寸同其附着的视图尺寸一致：

    VStack{
        // your view
    }
    .overlayContainer("containerA", containerConfiguration: AConfiguration())

当无需视图容器附着在某个视图时：

    ViewContainer("containerB", configuration: BConfiguration())

### 在容器中显示视图

在视图容器 containerA 显示视图 MessageView

    .containerView(in: "containerA", configuration: MessageView(), isPresented: $show, content: ViewConfiguration())

或者使用视图管理器

    struct ContentView1: View {
        @Environment(\.overlayContainerManager) var manager
        var body: some View {
            VStack {
                Button("push view in containerB") {
                    manager.show(view: MessageView(), in: "containerB", using: ViewConfiguration())
                }
            }
        }
    }

### 撤销指定容器内的所有视图

    struct ContentView1: View {
        @Environment(\.overlayContainerManager) var manager
        var body: some View {
            VStack {
                Button("push view in containerB") {
                    manager.dismissAllView(in: ["containerA","containerB"], animated: true)
                }
            }
        }
    }

## 基础

### 容器

接收并显示视图的组件。至少需要为容器设定：名称、视图显示类型、视图队列类型。

可以为容器设定默认的视图风格，对于视图未指定的风格属性，会使用容器的默认设置替代。

### 容器显示类型（ Display type ）

- stacking

当容器内同时显示多个视图时，视图沿 Z 轴排列。其表现同 `ZStack` 类似。

![stacking](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_stacking.gif)

- horizontal

当容器内同时显示多个视图时，视图沿 X 轴排列。其表现同 `HStack` 类似。

![horizontal](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_horizontal.gif)

- vertical

当容器内同时显示多个视图时，视图沿 Y 轴排列。其表现与 `VStack` 类似。

![vertical](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_vertical.gif)

### 视图队列类型（ Queue Type ）

- multiple

可以同时在容器内显示多个视图。当给定的视图数量超过了容器设定的最大视图数量时，超过的视图会暂存在等待队列中，并在已显示视图取消后，逐个递补。

![multiple](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_multiple.gif)

- oneByOne

同一时间只能在容器中显示一个视图。新添加的视图将自动替换掉正在显示的视图。

![oneByOne](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_oneByOne.gif)

- oneByOneWaitFinish

同一时间能在容器中显示一个视图。只有当前正在显示的视图被撤销后，新的视图才能被显示。

![oneByOneWaitFinish](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_oneByOneWaitFinish.gif)

### 配置容器

容器的配置至少要对以下属性进行设置：

    struct MyContainerConfiguration:ContainerConfigurationProtocol{
        var displayType: ContainerViewDisplayType = .stacking
        var queueType: ContainerViewQueueType = .multiple
    }

其他可以设置的属性还有：

- delayForShowingNext

自动递补下一个视图的时间间隔

- maximumNumberOfViewsInMultipleMode

multiple 模式下，容器内可同时显示的最多视图数量

- spacing

vertical 、horizontal 模式下，视图之间的间隔

- insets

在 stacking 模式下，该值为视图的内嵌值。在 horizontal 和 vertical 模式下，该值为视图组的内嵌值。

- 其他所有容器视图的配置（用作容器视图的默认值）

详情参阅下方的配置容器视图

### 容器环境值

每个容器都为容器内的视图提供了一个环境值—— `overlayContainer`
。容器内的视图可以通过该值获取容器的信息（名称、尺寸、显示类型、队列类型）并执行撤销显示的行为。

    struct MessageView: View {
        @Environment(\.overlayContainer) var container
        var body: some View {
            RoundedRectangle(cornerRadius: 10)
                .frame(width: 300, height: 10)
                .overlay(
                    HStack {
                        Text("container Name:\(container.containerName)")
                        Button("Dismiss me"){
                            container.dismiss()
                        }
                    }
                )
        }
    }

### 容器视图

所有的 SwiftUI 视图都可以在容器内显示。你可以为类似功能的视图创建同一个视图配置，或者让某个特定视图遵循
ContainerViewConfigurationProtocol 协议，单独进行设置。

### 配置容器视图

    public protocol ContainerViewConfigurationProtocol {
        var alignment: Alignment? { get }
        var tapToDismiss: Bool? { get }
        var backgroundStyle: ContainerBackgroundStyle? { get }
        var backgroundTransitionStyle: ContainerBackgroundTransitionStyle { get }
        var shadowStyle: ContainerViewShadowStyle? { get }
        var dismissGesture: ContainerViewDismissGesture? { get }
        var transition: AnyTransition? { get }
        var autoDismiss: ContainerViewAutoDismiss? { get }
        var disappearAction: (() -> Void)? { get }
        var appearAction: (() -> Void)? { get }
        var animation: Animation? { get }
    }

- alignment

设置视图或视图组在容器中的 alignment。stacking 模式下，可以为每个视图设置不同的 alignment，在 vertical 或
horizontal 模式下，所有视图（视图组）共用容器的 alignment 设置。

- tapToDismiss

在为视图设置了 backgroundStyle 的情况下，是否允许通过点击背景来撤销视图。

_详情参看项目演示代码_

- backgroundStyle

为容器视图设置背景。目前支持 color、blur、customView。

部分版本的操作系统（iOS 14，watchOS ）不支持 blur 模式，如果想在这些版本中使用 blur，可以通过 customView 来包裹其他的
blur 代码。

_详情参看项目演示代码_

![background](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_background.gif)

- backgroundTransitionStyle

背景的转场。默认为 opacity，设置为 identity 可取消转场。

- shadowStyle

为视图添加阴影

- dismissGesture

为视图添加取消手势，目前支持单击、双击、长按、左划、右划、上划、下划、自定义。

自定义手势需使用 `eraseToAnyGestureForDismiss` 对类型进行擦除。

      let gesture = LongPressGesture(minimumDuration: 1, maximumDistance: 5).eraseToAnyGestureForDismiss()

在 tvOS 下，仅长按被支持

_详情参看项目演示代码_

![gesture](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_gesture.gif)

- transition

视图的转场

- animation

视图转场的 animation

- autoDismiss

是否支持自动撤销。 `.seconds(3)` 表示 3 秒后视图会自动撤销。

_详情参看项目演示代码_

- disappearAction

视图被撤销后执行的闭包

- appearAction

视图在容器中显示前执行的闭包

### 容器管理器

容器管理器是程序代码与容器之间的桥梁。使用者通过调用容器管理器的特定方法，让指定的容器执行显示视图、撤销视图等工作。

### 容器管理器的环境值

在 SwiftUI 中，视图代码通过环境值调用容器管理器。

    struct ContentView1: View {
        @Environment(\.overlayContainerManager) var manager
        var body: some View {
            VStack {
                Button("push view in containerB") {
                    manager.show(view: MessageView(), in: "containerB", using: ViewConfiguration())
                }
            }
        }
    }

容器管理器目前提供的方法有：

- `show(view: Content, with ID: UUID?, in container: String, using configuration: ContainerViewConfigurationProtocol, animated: Bool) -> UUID?`

在指定的容器中显示视图，返回值为视图的 ID

- `dismiss(view id: UUID, in container: String, animated flag: Bool)`

在指定的容器中，撤销指定 ID 的视图

- `dismissAllView(notInclude excludeContainers: [String], onlyShowing: Bool, animated flag: Bool)`

撤销除了指定的容器外其他所有容器中的视图，当 onlyShow 为真时，仅撤销正在显示的视图。

- `dismissAllView(in containers: [String], onlyShowing: Bool, animated flag: Bool)`

撤销指定容器内的所有视图

### 可屏蔽动画

无论是直接调用容器管理器还是使用 View modifier，当将 animated 设为 false 时，均可强制取消转场动画。

对于处理例如 Deep Link 之类的场景时十分有效。

![animation](https://cdn.fatbobman.com/SwiftUIOverlayContainer2_animation.gif)

### 在 SwiftUI 视图外使用

如果想在 SwiftUI 视图之外调用容器管理器，可以直接调用 ContainerManager 的单例：

    let manager = ContainerManager.share
    manager.show(view: MessageView(), in: "containerB", using: ViewConfiguration())

## 系统需求

- iOS 14+
- macOS 11+
- tvOS 14+
- watchOS 7+

## 安装

安装 SwiftUIOverlayContainer 的首选方式是通过 Swift Package Manager。

    dependencies: [
      .package(url: "https://github.com/fatbobman/SwiftUIOverlayContainer.git", from: "2.0.0")
    ]

## 帮助与支持

可以通过创建 Issues 来反馈你的意见或建议。

# onAppear 的调用时机

onAppear（ task ）是 SwiftUI 开发者经常使用的一个修饰符，但一直没有权威的文档明确它的闭包被调用的时机。本文将通过 SwiftUI 4
提供的新 API ，证明 onAppear 的调用时机是在布局之后、渲染之前。

## 问题

同之前多篇博客类似，我们还是从 [ 聊天室 ](https://discord.gg/ApqXmy5pQJ) 的一个 [ 问题
](https://discord.com/channels/967978112509935657/967978112509935663/1085178054625734776)
开始。

![image-20230328163706115](https://cdn.fatbobman.com/image-20230328163706115.png)

请忽略例子中的写法是否合理和值得推荐，仅考虑为什么在第一段代码中，出现了数组越界的情况；以及第二段代码可以正确运行。

## 创建实例、求值、布局、渲染

在 SwiftUI 中，一个视图在它的生命周期中通常会经历四个阶段：

### 创建实例

视图树中，处于可显示分支的视图基本上都会经历的一个阶段。在一个视图的生存期中，SwiftUI 可能会多次创建视图实例。

> 由于惰性视图的优化机制，对于尚未处于可见区域的子视图，SwiftUI 不会创建其实例

### 求值

一个被显示的视图至少会经历一次的过程。由于 SwiftUI 的视图实际上是一个函数，SwiftUI 需要对视图进行求值（ 调用 body 属性
）并保留计算结果。当视图的依赖（ Source of truth ）发生变化后，SwiftUI
会重新计算视图结果值，并与旧值进行比较。如发生变化，则用新值替换旧值。

### 布局

在计算好当前需要显示的视图所有的视图值后，SwiftUI
将进入到布局阶段。通过父视图向子视图提供建议尺寸，子视图返回需求尺寸这一过程，最终计算出完整的布局结果。

> 有关布局的流程请阅读 [ SwiftUI 布局 —— 尺寸 ](/zh/posts/layout-dimensions-1/)

### 渲染

SwiftUI 通过调用更加底层的 API，将视图在屏幕上呈现的过程。此过程严格意义上已经不属于 SwiftUI 的管理范畴了。

## Appear 是相对于谁的？

在不少的词典中，appear 都被解释为例如 `to come into sight; become visible` 这样的意思。这会让开发者误以为
onAppear 是在视图渲染后（ 使用者看到后 ）才被调用的。但在 SwiftUI 中，onAppear 实际上是在渲染前被调用的。

假设排除了苹果起名出现了错误这个原因，此时的 appear 更像是针对 SwiftUI 系统来说的。视图在完成了创建实例、求值、布局后（ 完成了属于
SwiftUI 架构的管理流程 ），就算是 appear 于 SwiftUI 的“眼前”。

## 求证

口说无凭，本节我们将用证据来证明上述推断。

> 在写 [ SwiftUI 视图的生命周期研究 ](/zh/posts/swiftuilifecycle/) 一文时，我们只能通过现象来推断
> onAppear 的调用时机，随着版本的不断提高，SwiftUI 4 中为我们提供了足够的工具让我们可以获得更加确实的证据。

### 判断视图正在求值

在视图中添加类似如下的代码，是我们判断 SwiftUI 是否正在对视图进行求值的常用手段：

    VStack {
      let _ = print("evaluate")
    }

### 判断视图正处于布局阶段

在 4.0 中版本中，SwiftUI 提供了 Layout
协议，允许我们创建自定义布局容器，通过创建符合该协议的实例，我们便可以判断当前视图是否正处于布局阶段。

    struct MyLayout: Layout {
        let name: String
        func sizeThatFits(proposal _: ProposedViewSize, subviews _: Subviews, cache _: inout ()) -> CGSize {
            print("\(name) layout")
            return .init(width: 100, height: 100)
        }

        func placeSubviews(in _: CGRect, proposal _: ProposedViewSize, subviews _: Subviews, cache _: inout ()) {}
    }

上面的代码创建了一个固定返回 100 \* 100 需求尺寸的布局容器，在父视图询问其需求尺寸时将通过控制台报告给我们。

### 判断视图正准备渲染

尽管 SwiftUI 视图并没有提供可以展示该过程的 API，不过我们可以利用 UIViewControllerRepresentable 协议来包装一个
UIViewController ，并通过它的生命周期回调方法来确定当前的状态。

    struct ViewHelper: UIViewControllerRepresentable {
        func makeUIViewController(context _: Context) -> HelperController {
            return HelperController()
        }

        func updateUIViewController(_: HelperController, context _: Context) {
        }

        // SwiftUI 4 新增方法
        func sizeThatFits(_: ProposedViewSize, uiViewController _: HelperController, context _: Context) -> CGSize? {
            print("helper layout")
            return .init(width: 50, height: 50)
        }
    }

    final class HelperController: UIViewController {
        override func viewWillAppear(_: Bool) {
            print("will appear(render)")
        }
    }

在上面的代码中，sizeThatFits 与 Layout 协议的 sizeThatFits
调用时机一致，都是在布局过程中，父视图向子视图询问需求尺寸时访问。viewWillAppear 则是在 UIViewController 被呈现前（
可以理解为渲染前 ），会由 UIKit 调用。

> 通过 UIViewControllerRepresentable 封装的“视图”并非真正的视图，对于 SwiftUI
> 来说，它就是一块给出了需求尺寸的黑洞，因此并不存在求值一说。

### 整合

有了上面的工具，通过下面的代码，我们便可以完整地了解一个 SwiftUI 视图的处理过程，以及 onAppear 的调用时机。

    struct LayoutTest: View {
        var body: some View {
            MyLayout(name: "outer") {
                let _ = print("outer evaluate")
                MyLayout(name: "inner") {
                    let _ = print("inner evaluate")
                    ViewHelper()
                        .onAppear {
                            print("helper onAppear")
                        }
                }
                .onAppear {
                    print("inner onAppear")
                }
            }
            .onAppear {
                print("outer onAppear")
            }
        }
    }

输出如下：

    outer evaluate
    inner evaluate
    outer layout
    inner layout
    helper layout
    outer onAppear
    helper onAppear
    inner onAppear
    will appear(render)

### 分析

通过上面的输出，可以清楚地了解视图处理的全过程：

- SwiftUI 首先对视图进行求值（ 由外向内 ）
- 在全部求值结束后开始进行布局（ 由父视图到子视图 ）
- 在布局结束后，调用视图对应的 onAppear 闭包（ 顺序不明，不要假定 onAppear 之间的执行顺序 ）
- 渲染视图

由此可以证明，onAppear 确实是在布局之后，渲染之前被调用的。

## 解答

回到本文最初的问题。

### 第一段代码

- 对 VStack 进行求值
- 计算到 Text ，创建 Text 实例
- 创建实例时，需要调用 getWord 来获取参数
- 此时由于 newWords 数组为空，因此出现数组越界的错误

也就是说，在第一段代码报错时，该视图甚至还没有进入到布局阶段，就更不用提调用 onAppear 了。

在不考虑使用绝对索引值是否正确的情况下，通过下面的代码，便可以避免问题的出现：

    if !newWords.isEmpty {
        Text(getWord(at:0))
    }

### 第二段代码

- 对 List 进行求值
- 由于 ForEach 会根据 newWords 的数量进行子视图的处理，因此尽管此时 newWords 为空，但也不会有问题
- 完成布局
- 调用 onAppear 闭包，给 newWords 赋值
- 由于 newWords 是该视图的 Source of truth ，发生改变后，导致视图重新刷新
- 重复上面的过程，此时 newWords 已经有值了，ForEach 将正常处理所有的子视图

## 总结

在本文中，我们通过 SwiftUI 4 提供的新工具明确了 onAppear 的调用时机，或许这是新 API 开发时未曾想到的功能应用。

# HowTo —— SwiftUI2.0 使用 Link 或 openURL 打开 URL scheme

SwiftUI 2.0 提供了原生的打开 URL scheme 的功能，我们可以十分方便的在代码中调用其他的 app。

## Link

类似于 NavigationLink , 直接打开 URL scheme 对应的 app

    Link("openURL",destination:safariUrl)

## openURL

本次在 SwiftUI 2.0 中，苹果提供了若干个通过 Environment 注入的调用系统操作的方法。比如 exportFiles,
importFiles, openURL 等。

    @Environment(\.openURL) var openURL
    openURL.callAsFunction(url)

## 代码范例

    struct URLTest: View {
        @Environment(\.openURL) var openURL
        let safariUrl = URL(string:"http://www.apple.com")!
        let mailUrl = URL(string:"mailto:foo@example.com?cc=bar@example.com&subject=Hello%20Wrold&body=Testing!")!
        let phoneURl = URL(string:"tel:12345678")!

        var body: some View {
            List{
                Link("使用 safari 打开网页",destination:safariUrl)
                Button("发送邮件"){
                    openURL.callAsFunction(mailUrl){ result in
                        print(result)
                    }
                }
                Link(destination: phoneURl){
                    Label("拨打电话",systemImage:"phone.circle")
                }
            }
        }
    }

> 模拟器仅支持极少数的 URL，最好使用真机测试 [ 苹果官方提供的一些 URL scheme
> ](https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/PhoneLinks/PhoneLinks.html#//apple_ref/doc/uid/TP40007899-CH6-SW1)

你的浏览器不支持本视频

# 掌握 Transaction，实现 SwiftUI 动画的精准控制

SwiftUI 因其简便的动画 API
与极低的动画设计门槛而广受欢迎。但是，随着应用程序复杂性的增加，开发者逐渐发现，尽管动画设计十分简单，但要实现精确细致的动画控制并非易事。同时，在
SwiftUI 的动画系统中，有关 Transaction 的解释很少，无论是官方资料还是第三方文章，都没有对其运作机制进行系统的阐述。

本文将通过探讨 Transaction 的原理、作用、创建和分发逻辑等内容，告诉读者如何在 SwiftUI
中实现更加精准的动画控制，以及需要注意的其他问题。

## Transaction 是什么

- transaction 是一个值，包含了 SwiftUI 在处理当前状态变化时需要了解的上下文，其中最重要的是用于计算插值的动画函数。
- 与环境值有些类似，SwiftUI 会在视图层次结构中隐式向下传播 transaction。
- 所谓的“显式动画”和“隐式动画”的核心区别在于生成 transaction 和派发 transaction 的位置和逻辑不同。
- transaction 只与当前的状态变化有关。每当状态发生变化时，SwiftUI 会根据是否由“显式动画”发起或是否有声明”隐式动画”等情况按需生成新的 transaction，并在需要的视图层次中进行传递。
- 下游的 transaction 生成者（ `.animation` 、 `.transaction` ）将根据设置选择是否采用上游分发的 transaction 或生成新的 transaction。
- 在状态变化时，与当前变化状态有关联的可动画组件（通常遵守 Animatable 协议）将获取本次状态变化的上下文（transaction），得到动画曲线函数，并使用它来计算插值。
- transaction 并不能单独生成或派发，它是状态变化的附带信息。

我相信，很多读者在看完上述对 transaction 的描述后仍然会感到困惑。因此，在接下来的内容中，我们将更详细地介绍和阐述 transaction
的细节和实现，帮助你更好地理解。

## 如何观察 Transaction 的变化

通过 `.transaction` 视图修饰器，我们可以创建一个工具，以帮助我们更好地研究和理解 transaction。

    extension View {
        @ViewBuilder
        func transactionMonitor(_ title: String, _ showAnimation: Bool = true) -> some View {
            transaction {
                print(title, terminator: showAnimation ? ": " : "\n")
                if showAnimation {
                    print($0.animation ?? "nil")
                }
            }
        }
    }

## 什么是隐式动画

隐式动画是通过 `.animation` 或 `.transaction` （通常使用 `.animation`
）修饰器，在视图分支上声明在状态变化时应该创建的 transaction。

SwiftUI 会在以下情况下调用隐式动画创建 transaction：

- 当前视图分支在状态变化时会发生变化
- 当前视图分支上声明了隐式动画

下面的代码将展示隐式动画是如何创建 transaction 并向下传递的：

    struct ImplicitAnimationDemo: View {
        @State private var isActive = false
        var body: some View {
            VStack {
                Text("Hello")
                    .font(.largeTitle)
                    .offset(x: isActive ? 200 : 0)
                    .transactionMonitor("inner")
                    .animation(.smooth, value: isActive)
                    .transactionMonitor("outer")

                Text("World")
                    .transactionMonitor("world")

                Toggle("Active", isOn: $isActive)
                    .padding()
            }
            .transactionMonitor("VStack")
            .animation(.linear, value: isActive)
        }
    }

![implicit-animation-demo1_2023-06-25_15.43.04.2023-06-25
15_43_40.gif](https://cdn.fatbobman.com/implicit-animation-
demo1_2023-06-25_15.43.04.2023-06-25_15_43_40.gif)

输出为：

    VStack: BezierAnimation(duration: 0.35, curve: SwiftUI.UnitCurve.CubicSolver(ax: -2.0, bx: 3.0, cx: 0.0, ay: -2.0, by: 3.0, cy: 0.0))
    outer: BezierAnimation(duration: 0.35, curve: SwiftUI.UnitCurve.CubicSolver(ax: -2.0, bx: 3.0, cx: 0.0, ay: -2.0, by: 3.0, cy: 0.0))
    inner: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    VStack: nil
    outer: nil

- 通过 Toggle 调整 isActive，应用的状态发生了变化。
- SwiftUI 发现 `Text("Hello")` 和包裹它的 `VStack` 两个视图链会在状态变化时发生变化。
- `VStack` 通过 `.animation` 声明了在 `isActive` 变化时应创建的 transaction（动画函数为 `linear` ）。
- `Text("Hello")` 通过 `.animation` 声明了在 `isActive` 变化时应创建的 transaction（动画函数为 `smooth` ）。
- SwiftUI 调用 `VStack` 的 `.animation` 创建了新的 transaction，并向下传递。通过 VStack 和 outer 的输出信息可以看到获得了对应的值。
- SwiftUI 调用 `Text("Hello")` 的 `.animation` 创建了新的 transaction，并向下传递，该 transaction 替换了 VStack 向下传递的 transaction（ 查看 inner 的输出信息 ）。
- 在状态变化结束后，SwiftUI 重置了 `VStack` 和 `Text("Hello")` 外侧的 transaction（nil）。

几点提示：

- SwiftUI 可能会在应用初始阶段为部分视图设置 transaction（ 值为 nil ），即使没有设置，也不影响视图在状态变化时获取正确的 transaction。
- SwiftUI 可能会在状态改变后为部分视图重置 transaction（ 值为 nil ），即使没有重置，也不影响下次的动画（ 下次状态变化时，会生成新的 transaction ）。
- 当传递进来的 transaction 为 nil 时，SwiftUI 会优化调用 `.transaction` 修饰器闭包的时机。如果没有在闭包中修改 transaction，可能会忽略该闭包（ 不调用 ）。

## `.animation` 和 `.transaction` 有什么不同

`.animation` 修饰器是 `.transaction` 修饰器的快捷方式。同样，用于“显式动画”的 `withAnimation`
则是 `withTransaction` 的快捷方式。

例如，我们可以通过下面的代码为 iOS 13 创建与特定值关联的 `.animation` 修饰器版本。

    extension View {
        func myAnimation<V>(_ animation: Animation?, value: V) -> some View where V: Equatable {
            modifier(MyAnimationWithValueModifier(animation: animation, value: value))
        }
    }

    struct MyAnimationWithValueModifier<V>: ViewModifier where V: Equatable {
        @State private var holder: Holder
        private let value: V
        private let animation: Animation?
        init(animation: Animation?, value: V) {
            self.animation = animation
            self.value = value
            _holder = State(wrappedValue: Holder(value: value))
        }

        func body(content: Content) -> some View {
            content
                .transaction { transaction in
                    guard value != holder.value else { return }
                    holder.value = value
                    guard !transaction.disablesAnimations else { return }
                    transaction.animation = animation
                }
                .onAppear {} // Fixed the issue where the animation was not playing correctly on its first execution.
        }

        class Holder {
            var value: V
            init(value: V) {
                self.value = value
            }
        }
    }

代码提示：

- 保存要比较的值。
- 当关联的值发生变化时，更新保存的值。
- 检查上游的 transaction 的 disablesAnimations 属性，以判断是否用新的 transaction 替代上游的 transaction（有关 disablesAnimations，下文有更多说明）。
- onAppear 是用来保证第一次设置便起作用（解决 SwiftUI 的 Bug）。

使用方法和效果与 SwiftUI 官方版本 `animation<V>(_ animation: Animation?, value: V)`
完全一致。

## 使用与特定值关联的 `.animation` 修饰器版本，就可以避免动画的异常问题了吗？

并不是。

在最初的版本中，SwiftUI 只提供了一个版本的 `.animation` 。它会在当前视图链发生变化时创建
transaction，而不关心该变化是否由特定的关联值所导致。

后来提供的具备关联值版本的修饰器（类似于上面的自定义版本），将保证只在特定关联值发生变化时才创建 transaction，但如果使用不当，仍会出现问题。

例如，我们想要创建一个矩形。当 isActive 为 true 时，通过动画更改颜色；当 scale 为 true 时，不使用动画进行缩放。

    struct ImplicitAnimationBugDemo: View {
        @State private var isActive = false
        @State private var scale = false
        var body: some View {
            VStack {
                Rectangle()
                    .fill(isActive ? .red : .blue)
                    .frame(width: 200, height: 200)
                    .scaleEffect(scale ? 1.5 : 1.0)
                    .animation(.smooth, value: isActive)

                Button("Change") {
                    isActive.toggle()
                    scale.toggle()
                }
            }
        }
    }

执行上面的代码后，我们会发现，尽管 `.animation` 仅在 `isActive` 发生变化时才创建 transaction，但由于 `isActive` 和 `scale` 在同一个状态变化周期内都发生了改变，因此 `scaleEffect` 同样会使用该
transaction，并没有达到我们想要的效果。

![implicit-animtion-bug-demo1_2023-06-25_18.03.24.2023-06-25
18_04_05.gif](https://cdn.fatbobman.com/implicit-animtion-bug-
demo1_2023-06-25_18.03.24.2023-06-25_18_04_05.gif)

解决方法很简单，只需调整 `.animation` 的位置，使需要动画的组件获取到正确的 transaction 即可。

    Rectangle()
        .fill(isActive ? .red : .blue)
        .animation(.smooth, value: isActive) // move animation modifier
        .frame(width: 200, height: 200)
        .scaleEffect(scale ? 1.5 : 1.0)

![implicit-animation-bug-demo2_2023-06-25_18.05.24.2023-06-25
18_06_02.gif](https://cdn.fatbobman.com/implicit-animation-bug-
demo2_2023-06-25_18.05.24.2023-06-25_18_06_02.gif)

当然，我们也可以为不同的可动画组件设置不同的 transition。

    Rectangle()
        .fill(isActive ? .red : .blue)
        .animation(.smooth(duration: 0.2), value: isActive)
        .frame(width: 200, height: 200)
        .scaleEffect(scale ? 1.5 : 1.0)
        .animation(.bouncy(duration: 2), value: scale)

![implict-animtion-bug-demo3_2023-06-25_18.08.16.2023-06-25
18_09_07.gif](https://cdn.fatbobman.com/implict-animtion-bug-
demo3_2023-06-25_18.08.16.2023-06-25_18_09_07.gif)

**需要注意！在 SwiftUI 中，某些可动画组件存在获取 transaction 的 Bug** 。如果我们将 scaleEffect 替换为
offset，就无法实现与上面相同的效果：不同的动画组件应用不同的 transaction。

理论上，使用以下代码进行平移操作时不应该带有动画效果。

    struct ImplicitAnimationBugDemo: View {
        @State private var isActive = false
        @State private var scale = false
        var body: some View {
            VStack {
                Rectangle()
                    .fill(isActive ? .red : .blue)
                    .animation(.smooth, value: isActive)
                    .frame(width: 200, height: 200)
                    .offset(x: scale ? 200 : 0) // change scaleEffect to offset
                    .animation(.none, value: scale)

                Button("Change") {
                    isActive.toggle()
                    scale.toggle()
                }
            }
        }
    }

![implicit-animtion-bug-demo4_2023-06-25_18.13.37.2023-06-25
18_14_16.gif](https://cdn.fatbobman.com/implicit-animtion-bug-
demo4_2023-06-25_18.13.37.2023-06-25_18_14_16.gif)

**面对`offset` 不听话这样的情况该怎么办！ **

还记得 transaction 的派发原理吗？如果我们将 isActive 和 scale
的变化分开（改为两次状态调整），那么不同的可动画组件就可以获取到正确的 transaction 了。

    Button("Change") {
        isActive.toggle()
    	  // Adjust one-time state change to two-time state change
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.01){
            scale.toggle()
        }
    }

这是因为，在第一次状态变化时（isActive）， `fill` 将获得由 `animation(.smooth, value: isActive)` 创建的 transaction。而在第二次状态变化时， `fill` 已经完成了状态变化（动画进行中），它不需要再次获取 transaction。
`offset` 则获取了由 `animation(.none, value: scale)` 生成的
transaction。我们通过这种方式解决了 `offset` 无法正确获取 transaction 的 Bug。

## 新的隐式动画声明方式在 WWDC 2023 中被宣布

在 WWDC 2023 中，苹果为 SwiftUI 增加了新的 `animation` 和 `transaction` 版本。

    struct ImplicitAnimationNewVersionDemo: View {
        @State private var isActive = false
        @State private var scale = false
        var body: some View {
            VStack {
                Rectangle()
                    .animation(.smooth) {
                        $0.foregroundStyle(isActive ? Color.red : Color.blue)
                    }
                    .frame(width: 200, height: 200)
                    .transaction {
                        $0.animation = .none
                    } body: {
                        $0.scaleEffect(scale ? 1.5 : 1)
                    }

                Button("Change") {
                    isActive.toggle()
                    scale.toggle()
                }
            }
        }
    }

与之前的版本相比，新版的 `animation` 和 `transaction` 会将新创建的 transaction
仅应用于闭包内部。这样一来，上游传来的 transaction 将按照原样沿视图链继续传递，从而保证开发者的动画意图被正确地传递下去。

> 截止到 Xcode 15 beta 2，新版本的修饰符还无法正常工作。

## 什么是显式动画

在视图中，通过 `animation` 或 `transaction` 修饰器声明的 transaction
被称为“隐式动画”。使用命令式编程的手段，通过全局函数 `withAnimation` 或 `withTransaction` 创建
transaction 的方式则被称为“显式动画”。

相较于“隐式动画”，“显式动画”有以下不同之处：

- 无论在何处执行 `withAnimation` 函数，SwiftUI 都将从根视图开始派发“显式动画”创建的 transaction
- 当状态发生变化时，SwiftUI 会自动为所有受影响的视图分发 transaction

要创建显式动画，请按照以下方式进行：

    @main
    struct TransactionApp: App {
        var body: some Scene {
            WindowGroup {
                ExplicitAnimationDemo()
                    .transactionMonitor("App")
            }
        }
    }

    struct ExplicitAnimationDemo: View {
        var body: some View {
            VStack {
                Text("Hello World")
                    .transactionMonitor("Hello World")
                SubView()
                    .transactionMonitor("SubView")
            }
            .transactionMonitor("VStack")
        }
    }

    struct SubView: View {
        @State private var isActive = false
        var body: some View {
            Rectangle()
                .fill(.cyan)
                .frame(width: 300, height: isActive ? 400 : 200)
                .transactionMonitor("Rectangle")

            Button("Active") {
                withAnimation(.smooth) {
                    isActive.toggle()
                }
            }
        }
    }

输出为：

    App: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    VStack: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    SubView: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    Rectangle: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    Hello World: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    App: nil
    VStack: nil
    SubView: nil

![explicit-animtion-demo1_2023-06-25_19.45.37.2023-06-25
19_46_57.gif](https://cdn.fatbobman.com/explicit-animtion-
demo1_2023-06-25_19.45.37.2023-06-25_19_46_57.gif)

也许有人会想知道，为什么几乎所有的视图分支都被重新派发了 transaction，SwiftUI 是根据什么来决定哪些视图分支要派发“显式动画”创建的
transaction。

根据我的测试，SwiftUI 将为所有在本次状态变化时（ `withAnimation` 闭包引发）发生 **视觉变化** 的视图分支派发
transaction。

例如，上面代码中的 `Text("Hello World")` ，由于在 `isActive` 发生变化后，它的位置也将改变，因此，该分支也将被派发
transaction。另外，所有的 Button，无论是否发生变化，都将被派发 transaction（ 感觉上像 Bug ）。

通过修改代码，我们可以让 `Text("Hello World")` 在 `isActive` 变化后，不改变其位置：

    struct SubView: View {
        @State private var isActive = false
        var body: some View {
            Rectangle()
                .fill(.cyan)
                .frame(width: 300, height: isActive ? 400 : 200)
                .transactionMonitor("Rectangle")
            Spacer() // add Spacer()
            Button("Active") {
                withAnimation(.smooth) {
                    isActive.toggle()
                }
            }
        }
    }

输出：

    App: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    VStack: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    SubView: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    Rectangle: FluidSpringAnimation(response: 0.5, dampingFraction: 1.0, blendDuration: 0.0)
    App: nil
    VStack: nil
    SubView: nil

![explicit-animation-demo2_2023-06-25_19.54.17.2023-06-25
19_55_23.gif](https://cdn.fatbobman.com/explicit-animation-
demo2_2023-06-25_19.54.17.2023-06-25_19_55_23.gif)

通过添加 Spacer，我们可以确保 `Text("Hello world")` 的位置不会受到状态变化的影响。这样，SwiftUI 就不会为 `Text("Hello World")` 分发 transaction 了。

## 显式动画可以和隐式动画合作吗

可以。

开发者可以通过在“显式动画”派发的视图分支上声明“隐式动画”的方式，来改变局部的 transaction。

    struct SubView: View {
        @State private var isActive = false
        var body: some View {
            Rectangle()
                .fill(.cyan)
                .frame(width: 300, height: isActive ? 400 : 200)
                .animation(.bouncy, value: isActive) // bouncy will replace smooth

            Button("Active") {
                withAnimation(.smooth) {
                    isActive.toggle()
                }
            }
        }
    }

## 用显式动画覆盖隐式动画

相较于“隐式动画”，“显式动画”需要在更多、更深的视图分支和层级上派发
transaction。因此，理论上来说，为了达到相同的动画效果，“显式动画”的运行效率要低一点。

然而，在某些特定情况下，使用“显式动画”会更方便，例如：通过显式动画来覆盖隐式动画。

还记得上文中我们自定义的 `animation` 修饰器实现吗？在这个实现中，修饰器会判断上游 transaction 的 `disablesAnimations` 属性。如果该属性为 `true` ，则不创建新的 transaction。

这个自定义实现完全仿照了 SwiftUI 提供的 `animation` 修饰器的实现逻辑。

    struct CoverImplicitAnimationDemo: View {
        @State var isActive = false
        var body: some View {
            VStack {
                Rectangle()
                    .fill(isActive ? .red : .blue)
                    .frame(width: 300, height: 300)
                    .animation(.smooth, value: isActive)

                Button("Cover ImplicitAnimation") {
                    var transaction = Transaction(animation: .none)
                    transaction.disablesAnimations = true
                    withTransaction(transaction) {
                        isActive.toggle()
                    }
                }
            }
        }
    }

![explicit-cover-implicit-demo_2023-06-25_20.52.34.2023-06-25
20_53_36.gif](https://cdn.fatbobman.com/explicit-cover-implicit-
demo_2023-06-25_20.52.34.2023-06-25_20_53_36.gif)

虽然我们使用了“隐式动画”来为 `fill` 声明了 transaction，但是通过“显式动画”，我们创建并派发了一个 `disablesAnimations` 属性为 `true` 的 transaction。这样， `animation` 修饰符将不再创建新的
transaction（smooth）。

`animation` 修饰符会判断 `disablesAnimations` 属性，而 `transaction`
修饰符需要开发者自行决定采用何种逻辑。

## 利用显式动画的 diff 和自动分发 Transaction 的能力

大家是否会有些奇怪，为什么“显式动画”要对所有受影响的视图分发 transaction 呢？事实上，这也是在某些情况下，“显式动画”的另一个优势。

我们将上面“显式动画”与“隐式动画”合作的代码，改成纯“隐式动画”（去掉 withAnimation）的实现：

    struct ExplicitAnimationDemo: View {
        var body: some View {
            VStack {
                Text("Hello World")
                SubView()
            }
        }
    }

    struct SubView: View {
        @State private var isActive = false
        var body: some View {
            Rectangle()
                .fill(.cyan)
                .frame(width: 300, height: isActive ? 400 : 200)
                .animation(.bouncy, value: isActive)

            Button("Active") {
                isActive.toggle()
            }
        }
    }

![implicit-bug-demo5_2023-06-26_07.04.36.2023-06-26
07_05_36.gif](https://cdn.fatbobman.com/implicit-bug-
demo5_2023-06-26_07.04.36.2023-06-26_07_05_36.gif)

请注意，上图中，“Hello World” 的位移没有动画。

这是因为在上面的代码中，没有为 SubView 外面的 VStack 声明“隐式动画”。因此，当 Rectangle 的尺寸增大时，VStack
会调整布局。但由于没有找到对应的 transaction，此布局调整的过程是非动画的。从而导致了这种情况。使用“显式动画”，SwiftUI 将自动为
VStack 派发 transaction。

当然，如果我们可以调整数据源的位置，那么 “隐式动画” 同样可以避免上面的情况。

    struct ExplicitAnimationDemo: View {
        @State private var isActive = false // source of truth
        var body: some View {
            VStack {
                Text("Hello World")
                    .transactionMonitor("Hello World")
                SubView(isActive: $isActive)
                    .transactionMonitor("SubView")
            }
            .animation(.bouncy, value: isActive) // implicit aniamtion for VStack
        }
    }

    struct SubView: View {
        @Binding var isActive: Bool
        var body: some View {
            Rectangle()
                .fill(.cyan)
                .frame(width: 300, height: isActive ? 400 : 200)
                .animation(.bouncy, value: isActive)

            Button("Active") {
                isActive.toggle()
            }
        }
    }

在这种情况下，“显式动画”确实比“隐式动画”更方便。但是，过多的 transaction
派发也可能产生不必要的动画。通过将“显式动画”和“隐式动画”结合起来使用，才能更精确地控制动画效果。

## 使用显式动画屏蔽系统组件动画

在 iOS 17 中，SwiftUI 会让大多数系统组件（如 Sheet、FullScreeCover、NavigationStack、Inspector
等）在实现动画时，首先检查来自上游 transaction 的 `disablesAnimations` 属性。开发者终于可以用纯 SwiftUI
的方式来决定是否在这些组件的切换过程中使用动画了。

NavigationStack:

    struct NavigationStackDemo: View {
        @State var pathStore = PathStore()
        var body: some View {
            @Bindable var pathStore = pathStore
            NavigationStack(path: $pathStore.path) {
                List {
                    Button("Go Link without Animation") {
                        var transaction = Transaction(animation: .none)
                        transaction.disablesAnimations = true
                        withTransaction(transaction) {
                            pathStore.path.append(1)
                        }
                    }
                    Button("Go Link with Animation") {
                        pathStore.path.append(1)
                    }
                }
                .navigationDestination(for: Int.self) {
                    ChildView(store: pathStore, n: $0)
                }
            }
        }
    }

    @Observable
    class PathStore {
        var path: [Int] = []
    }

    struct ChildView: View {
        let store: PathStore
        let n: Int
        @Environment(\.dismiss) var dismiss
        var body: some View {
            List {
                Text("\(n)")
                Button("Dismiss without Animation") {
                    var transaction = Transaction(animation: .none)
                    transaction.disablesAnimations = true
                    withTransaction(transaction) {
                        store.path = []
                    }
                }
                Button("Dismiss with Animation") {
                    dismiss()
                }
            }
        }
    }

![disable-animation-demo1_2023-06-26_08.55.59.2023-06-26
08_56_52.gif](https://cdn.fatbobman.com/disable-animation-
demo1_2023-06-26_08.55.59.2023-06-26_08_56_52.gif)

Sheet:

    struct SheetDemo: View {
        @State private var isActive = false
        var body: some View {
            List {
                Button("Pop Sheet without Animation") {
                    var transaction = Transaction(animation: .none)
                    transaction.disablesAnimations = true
                    withTransaction(transaction) {
                        isActive.toggle()
                    }
                }
                Button("Pop Sheet with Animation") {
                    isActive.toggle()
                }
            }
            .sheet(isPresented: $isActive) {
                VStack {
                    Button("Dismiss without Animation") {
                        var transaction = Transaction(animation: .none)
                        transaction.disablesAnimations = true
                        withTransaction(transaction) {
                            isActive.toggle()
                        }
                    }
                    Button("Dismiss with Animation") {
                        isActive.toggle()
                    }
                }
                .buttonStyle(.borderedProminent)
            }
        }
    }

![disable-aniamtion-demo2_2023-06-26_09.02.07.2023-06-26
09_03_12.gif](https://cdn.fatbobman.com/disable-aniamtion-
demo2_2023-06-26_09.02.07.2023-06-26_09_03_12.gif)

## 可动画组件如何获取 Transaction

SwiftUI 会自动帮助符合 Animatable 协议的可动画组件获取 transaction，并计算插值。

如果你使用例如 UIViewRepresentable 的方式对 UIKit 或 AppKit 组件进行包装，则可以在 `update`
方法中获取当前的 transaction。这样就能保证在每次状态发生变化时都能获取正确的上下文信息。

    struct MyView:UIViewRepresentable {
        @Binding var isActive:Bool
        func makeUIView(context: Context) -> some UIView {
            return UIView()
        }

        func updateUIView(_ uiView: UIViewType, context: Context) {
            let transaction = context.transaction
            // check animation
            // do something
        }
    }

> 在 WWDC 2023 中，苹果为 Animation 添加了新的方法，可以帮助开发者获取在特定时间点对应的值。

## 支持设置 Transaction 或 Animation 的组件

在 SwiftUI 中，一些组件或类型允许开发者为其设置 transaction 或 animation，例如：Binding、FetchRequest
等。开发者应根据需要选择是否采用其内置的动画设置。

例如，对于 FetchRequest，我们可以通过三种方式来控制其在数据增加或删除时是否采用动画效果。

    // Solution 1
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
        animation: .none  // animation
    )

    // Soulution 2
    List {
        ForEach(items) { item in
           ....
        }
        .onDelete(perform: deleteItems)
    }
    .animation(.bouncy, value: items.count) // animation

    // Solution 3
    withAnimation {
       addNewItem()
    }

    withAniamtion {
        delItem()
    }

使用后两种方法，开发者将拥有更强的动画控制力。

## TransactionKey

在 WWDC 2023 上，苹果为 SwiftUI 添加了 TransactionKey。这允许开发者在 transaction 中携带一些自定义信息。

创建 TransactionKey 的方式与 EnvironmentKey 十分相似。

    enum TapSource {
        case root
        case welcome
        case other

        var animation: Animation? {
            switch self {
            case .root:
                Animation.smooth(duration: 3)
            case .welcome:
                nil
            case .other:
                Animation.linear
            }
        }
    }

    struct SourceKey: TransactionKey {
        static var defaultValue: TapSource = .root
    }

    extension Transaction {
        var source: TapSource {
            get { self[SourceKey.self] }
            set { self[SourceKey.self] = newValue }
        }
    }

使用方法：

    @Observable
    class Store {
        var isActive = false
    }

    struct KeyDemo: View {
        @State private var store = Store()
        var body: some View {
            VStack {
                Rectangle()
                    .fill(store.isActive ? .orange : .cyan)
                    .frame(width: 300, height: 300)
                    .transaction {
                        $0.animation = $0[SourceKey.self].animation
                    }

                RootView(store: store)
                WelcomeView(store: store)
            }
        }
    }

    struct RootView: View {
        let store: Store
        var body: some View {
            Button("From Root") {
                withTransaction(\.source, .root) {
                    store.isActive.toggle()
                }
            }
        }
    }

    struct WelcomeView: View {
        let store: Store
        var body: some View {
            Button("From Welcome") {
                withTransaction(\.source, .welcome) {
                    store.isActive.toggle()
                }
            }
        }
    }

![transactionKey-demo_2023-06-25_21.07.29.2023-06-25
21_08_28.gif](https://cdn.fatbobman.com/transactionKey-
demo_2023-06-25_21.07.29.2023-06-25_21_08_28.gif)

> 请阅读 [ 深度解读 Observation —— SwiftUI 性能提升的新途径 ](/zh/posts/mastering-
> observation/) 一文，了解 `@Observable` 的具体用法。

## 实现精准动画的一些建议

- 在需要使用动画的可动画组件附近声明“隐式动画”。
- 可能的情况下，使用新的“隐式动画”声明方法。
- 在同样的效果下，优先使用“隐式动画”。
- 在使用“显式动画”时，通过在局部声明“隐式动画”来避免部分视图出现动画异常。
- 在需要的情况下，可以通过 TransactionKey 提供更丰富的上下文信息
- 尽量不在一次状态改变中修改过多的属性。
- 出现动画异常时，应首先明确异常部位在状态变化时所获取到的 transaction。
- 对可动画部件要有明确的理解，除了支持动画的修饰器外，布局容器也是。
- 在包装 UIKit 或 AppKit 控件时，应添加检查当前 transaction 的逻辑。
- 在 iOS 17 中，更多的导航组件已支持通过使用“显式动画”来屏蔽动画转场。

## 最后

本文着重介绍 transaction 的创建和派发机制，对于 transaction 中的其他属性没有进行更多的讨论。无论 SwiftUI 未来为
transaction 添加多少信息，只要我们掌握了其原理，就能实现高效精准的动画。在出现预期之外的动画行为时，开发者也知道该如何调整。

# SwiftUI 布局 —— 尺寸（ 下 ）

在 [ 上篇 ](/zh/posts/layout-dimensions-1/) 中，我们对 SwiftUI
布局过程中涉及的众多尺寸概念进行了说明。本篇中，我们将通过对视图修饰器 frame 和 offset 的仿制进一步加深对 SwiftUI
布局机制的理解，并通过一些示例展示在布局时需要注意的问题。

## 相同的长相、不同的内涵

在 SwiftUI 中，我们可以利用不同的布局容器生成看起来几乎一样的显示结果。例如，无论是
ZStack、overlay、background、VStack、HStack 都可以实现下图的版式。

![image-20220715153543755](https://cdn.fatbobman.com/image-20220715153543755-7870624.png)

以 ZStack、overlay、background 举例：

    struct HeartView: View {
        var body: some View {
            Circle()
                .fill(.yellow)
                .frame(width: 30, height: 30)
                .overlay(Image(systemName: "heart").foregroundColor(.red))
        }
    }

    struct ButtonView: View {
        var body: some View {
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.blue.gradient)
                .frame(width: 150, height: 50)
        }
    }

    // ZStack
    struct IconDemo1: View {
        var body: some View {
            ZStack(alignment: .topTrailing) {
                ButtonView()
                HeartView()
                    .alignmentGuide(.top, computeValue: { $0.height / 2 })
                    .alignmentGuide(.trailing, computeValue: { $0.width / 2 })
            }
        }
    }

    // overlay
    struct IconDemo2: View {
        var body: some View {
            ButtonView()
                .overlay(alignment: .topTrailing) {
                    HeartView()
                        .alignmentGuide(.top, computeValue: { $0.height / 2 })
                        .alignmentGuide(.trailing, computeValue: { $0.width / 2 })
                }
        }
    }

    // background
    struct IconDemo3: View {
        var body: some View {
                HeartView()
                .background(alignment:.center){
                    ButtonView()
                        .alignmentGuide(HorizontalAlignment.center, computeValue: {$0[.trailing]})
                        .alignmentGuide(VerticalAlignment.center, computeValue: {$0[.top]})
                }
        }
    }

虽然 IconDemo 1、IconDemo 2、IconDemo 3
在单独预览时看起来完全一样，但如果将它们放置到其他的布局容器中，你会发现它们在容器内的布局后的摆放结果明显不同 —— 需求尺寸的构成和大小不一样（
下图中，用红框标注了各自的需求尺寸 ）。

![image-20220715162600792](https://cdn.fatbobman.com/image-20220715162600792.png)

布局容器在规划自身的需求尺寸上的策略不同是造成上述现象的原因。

像 ZStack、VStack、HStack 这几个容器，它们的需求尺寸是由其全部子视图按照指定的布局指南进行摆放后的获得的总尺寸所构成的。而
overlay 和 background 的需求尺寸则完全取决于它们的主视图（ 本例中，overlay 的需求尺寸由 ButtonView
决定，background 的需求尺寸由 HeartView 决定 ）。假设当前的设计需求是想将 ButtonView 和 HeartView
视作一个整体进行布局，那么 ZStack 是一个不错的选择。

每种容器都有其适合的场景，例如对于如下需求 —— 创建类似视频 app 中的点赞功能的子视图（ 在布局时，仅需考虑手势图标的位置和尺寸），overlay
这种需求尺寸仅依赖于主视图的容器便有了用武之地：

    struct FavoriteDemo: View {
        var body: some View {
            ZStack(alignment: .bottomTrailing) {
                Rectangle()
                    .fill(Color.cyan.gradient.opacity(0.5))
                Favorite()
                    .alignmentGuide(.bottom, computeValue: { $0[.bottom] + 200 })
                    .alignmentGuide(.trailing, computeValue: { $0[.trailing] + 100 })
            }
            .ignoresSafeArea()
        }
    }

    struct Favorite: View {
        @State var hearts = [(String, CGFloat, CGFloat)]()
        var body: some View {
            Image(systemName: "hand.thumbsup")
                .symbolVariant(.fill)
                .foregroundColor(.blue)
                .font(.title)
                .overlay(alignment: .bottom) {
                    ZStack {
                        Color.clear
                        ForEach(hearts, id: \.0) { heart in
                            Text("+1")
                                .font(.title)
                                .foregroundColor(.white)
                                .bold()
                                .transition(.asymmetric(insertion: .move(edge: .bottom).combined(with: .opacity), removal: .move(edge: .top).combined(with: .opacity)))
                                .offset(x: heart.1, y: heart.2)
                                .task {
                                    try? await Task.sleep(nanoseconds: 500000000)
                                    if let index = hearts.firstIndex(where: { $0.0 == heart.0 }) {
                                        let _ = withAnimation(.easeIn) {
                                            hearts.remove(at: index)
                                        }
                                    }
                                }
                        }
                    }
                    .frame(width: 50, height: 100)
                    .allowsHitTesting(false)
                }
                .onTapGesture {
                    withAnimation(.easeOut) {
                        hearts.append((UUID().uuidString, .random(in: -10...10), .random(in: -10...10)))
                    }
                }
        }
    }

![iShot_2022-07-16_09.06.08.2022-07-16
09_07_08](https://cdn.fatbobman.com/iShot_2022-07-16_09.06.08.2022-07-16%2009_07_08.gif)

相同长相的视图，未必有相同的内涵。当用布局容器创建合成视图时，必须将构成后的合成视图对父容器的布局影响考虑到其中。针对不同的需求，选择恰当的容器。

## 面子和里子

与 UIKit 和 AppKit 类似，SwiftUI 的布局操作是在视图层面（ 里子 ）进行的，而所有针对关联图层（ backing layer
）的操作仍是通过 Core Animation 来完成的。因此，针对 CALayer（ 面子 ）直接做出的调整，SwiftUI 的布局系统是无法感知的。

而这种在布局之后、渲染之前对内容进行调整的操作，大量存在于 SwiftUI
之中，例如：offset、scaleEffect、rotationEffect、shadow、background、cornerRadius
等操作都是在此阶段进行的。

例如：

    struct OffsetDemo1:View{
        var body: some View{
            HStack{
                Rectangle()
                    .fill(.orange.gradient)
                    .frame(maxWidth:.infinity)
                Rectangle()
                    .fill(.green.gradient)
                    .frame(maxWidth:.infinity)
                Rectangle()
                    .fill(.cyan.gradient)
                    .frame(maxWidth:.infinity)
            }
            .border(.red)
        }
    }

![image-20220716102117190](https://cdn.fatbobman.com/image-20220716102117190.png)

我们使用 offset 调整中间矩形的位置，并不会对 HStack 的尺寸造成任何影响，在此种情况下，面子和里子是脱节的：

    Rectangle()
        .fill(.green.gradient)
        .frame(width: 100, height: 50)
        .border(.blue)
        .offset(x: 30, y: 30)
        .border(.green)

![image-20220716102351620](https://cdn.fatbobman.com/image-20220716102351620.png)

> 在 SwiftUI 中，offset 修饰符对应的是 Core Animation 中的 CGAffineTransform 操作。 `.offset(x: 30, y: 30)` 相当于 `.transformEffect(.init(translationX: 30, y:
30))` 。这种直接在 CALayer 层面进行的修改，并不会对布局造成影响

上面或许就是你想要的效果，但如果想实现让位移后的视图能够对它的父视图（ 容器 ）的布局有所影响，或许就需要换一种方式 —— 用布局容器而非 Core
Animtion 操作：

    // 通过 padding
    Rectangle()
        .fill(.green.gradient)
        .frame(width: 100, height: 50)
        .border(.blue)
        .padding(EdgeInsets(top: 30, leading: 30, bottom: 0, trailing: 0))
        .border(.green)

![image-20220716103047458](https://cdn.fatbobman.com/image-20220716103047458.png)

或者：

    // 通过 frame
    Rectangle()
        .fill(.green.gradient)
        .frame(width: 100, height: 50)
        .border(.blue)
        .frame(width: 130, height: 80, alignment: .bottomTrailing)
        .border(.green)

    // 通过 position
    Rectangle()
        .fill(.green.gradient)
        .frame(width: 100, height: 50)
        .border(.blue)
        .position(x: 80, y: 55)
        .frame(width: 130, height: 80)
        .border(.green)

相较于 offset 视图修饰器，由于没有现成的可替换手段，想让 rotationEffect 修改后的结果反过来影响布局则要略显烦琐：

    struct RotationDemo: View {
        var body: some View {
            HStack(alignment: .center) {
                Text("HI")
                    .border(.red)
                Text("Hello world")
                    .fixedSize()
                    .border(.yellow)
                    .rotationEffect(.degrees(-40))
                    .border(.red)
            }
            .border(.blue)
        }
    }

![image-20220716104438958](https://cdn.fatbobman.com/image-20220716104438958.png)

    extension View {
        func rotationEffectWithFrame(_ angle: Angle) -> some View {
            modifier(RotationEffectWithFrameModifier(angle: angle))
        }
    }

    struct RotationEffectWithFrameModifier: ViewModifier {
        let angle: Angle
        @State private var size: CGSize = .zero
        var bounds: CGRect {
            CGRect(origin: .zero, size: size)
                .offsetBy(dx: -size.width / 2, dy: -size.height / 2)
                .applying(.init(rotationAngle: CGFloat(angle.radians)))
        }

        func body(content: Content) -> some View {
            content
                .rotationEffect(angle)
                .background(
                    GeometryReader { proxy in
                        Color.clear
                            .task(id: proxy.frame(in: .local)) {
                                size = proxy.size
                            }
                    }
                )
                .frame(width: bounds.width, height: bounds.height)
        }
    }

    truct RotationDemo: View {
        var body: some View {
            HStack(alignment: .center) {
                Text("HI")
                    .border(.red)
                Text("Hello world")
                    .fixedSize()
                    .border(.yellow)
                    .rotationEffectWithFrame(.degrees(-40))
                    .border(.red)
            }
            .border(.blue)
        }
    }

![image-20220716104820339](https://cdn.fatbobman.com/image-20220716104820339.png)

> scaleEffect 也可以用类似的方式实现以影响原有的布局

在 SwiftUI 中，开发者在对视图进行调整前需要清楚该操作是针对里子（ 基于布局机制 ）还是面子（ 在 CALayer
层面），或者是想通过对面子的修改进而影响里子，只有这样，才能让最终的呈现效果与预期的布局一致。

## 从模仿中学习

本章中，我们将通过使用 Layout 协议实现对 frame 和 offset 的仿制以加深对布局过程中的不同尺寸概念的认识。

> 有关 frame、offset 的布局逻辑在上篇中已有描述，本文仅对关键代码进行说明。可在 [ 此处获取
> ](https://github.com/fatbobman/BlogCodes/tree/main/My_Frame) 本文的仿制代码

### frame

SwiftUI 中有两个版本的 frame，本节我们将仿制 `frame(width: CGFloat? = nil, height: CGFloat?
= nil, alignment: Alignment = .center)` 。

> frame 视图修饰器本质上是对布局容器 \_FrameLayout 的包装，本例中我们将自定义的布局容器命名为 MyFrameLayout
> ，视图修饰器命名为 myFrame 。

#### 用 viewModifier 包装布局容器

在 SwiftUI 中，通常需要对布局容器进行二次包装后再使用。例如 \_VStackLayout 被包装成 VStack，\_FrameLayout 被包装成
frame 视图修饰器。

这种包装行为的作用为（ 以 MyFrameLayout 举例 ）：

- 简化代码

改善由 Layout 协议的 callAsFunction 所带来的多括号问题

- 预处理子视图

在 [ SwiftUI 布局 —— 对齐 ](/zh/posts/layout-alignment/)
一文中我们已经介绍了“对齐”是发生在容器中子视图之间的行为，因此对于 \_FrameLayout
这种开发者只提供一个子视图同时又需要对齐的布局容器，我们需要通过在 modifier 中添加一个 Color. clear 视图来解决对齐对象不足的问题

    private struct MyFrameLayout: Layout, ViewModifier {
        let width: CGFloat?
        let height: CGFloat?
        let alignment: Alignment

        func body(content: Content) -> some View {
            MyFrameLayout(width: width, height: height, alignment: alignment)() { // 由于 callAsFunction 所导致的多括号
                Color.clear // 添加用于辅助对齐的视图
                content
            }
        }
    }

    public extension View {
        func myFrame(width: CGFloat? = nil, height: CGFloat? = nil, alignment: Alignment = .center) -> some View {
            self
                .modifier(MyFrameLayout(width: width, height: height, alignment: alignment))
        }

        @available(*, deprecated, message: "Please pass one or more parameters.")
        func myFrame() -> some View {
            modifier(MyFrameLayout(width: nil, height: nil, alignment: .center))
        }
    }

#### frame (width:, height:) 的实现

这一版本的 frame 有如下功能：

- 当两个维度都设置了具体值时，将使用这两个值作为 \_FrameLayout 容器的需求尺寸，以及子视图的布局尺寸
- 当只有一个维度设置了具体值 A，则将该值 A 作为 \_FrameLayout 容器在该维度上的需求尺寸，另一维度的需求尺寸则使用子视图在该维度上的需求尺寸（ 以 A 及 \_FrameLayout 获得的建议尺寸作为子视图的建议尺寸 ）

  func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
  guard subviews.count == 2, let content = subviews.last else { fatalError("Can't use MyFrameLayout directly") }
  var result: CGSize = .zero

      if let width, let height { // 两个维度都有设定
          result = .init(width: width, height: height)
      }

      if let width, height == nil {  // 仅宽度有设定
          let contentHeight = content.sizeThatFits(.init(width: width, height: proposal.height)).height // 子视图在该维度上的需求尺寸
          result = .init(width: width, height: contentHeight)
      }

      if let height, width == nil {
          let contentWidth = content.sizeThatFits(.init(width: proposal.width, height: height)).width
          result = .init(width: contentWidth, height: height)
      }

      if height == nil, width == nil {
          result = content.sizeThatFits(proposal)
      }

      return result

  }

在 placeSubviews 中，我们将利用 modifier 中添加的辅助视图，对子视图进行对齐摆放。

    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        guard subviews.count == 2, let background = subviews.first, let content = subviews.last else {
            fatalError("Can't use MyFrameLayout directly")
        }
        // 在 bounds 中满铺 Color.clear
        background.place(at: .zero, anchor: .topLeading, proposal: .init(width: bounds.width, height: bounds.height))
        // 获取 Color.clear 对齐指南的位置
        let backgroundDimensions = background.dimensions(in: .init(width: bounds.width, height: bounds.height))
        let offsetX = backgroundDimensions[alignment.horizontal]
        let offsetY = backgroundDimensions[alignment.vertical]
        // 获取子视图对齐指南的位置
        let contentDimensions = content.dimensions(in: .init(width: bounds.width, height: bounds.height))
        // 计算 content 的 topLeading 偏移量
        let leading = offsetX - contentDimensions[alignment.horizontal] + bounds.minX
        let top = offsetY - contentDimensions[alignment.vertical] + bounds.minY
        content.place(at: .init(x: leading, y: top), anchor: .topLeading, proposal: .init(width: bounds.width, height: bounds.height))
    }

现在我们已经可以在视图中使用 myFrame 替代 frame ，并实现完全一样的效果。

### fixedSize

fixedSize 为子视图的特定维度提供未指定模式（ nil
）的建议尺寸，以使其在该维度上将理想尺寸作为其需求尺寸返回，并以该尺寸作为自身的需求尺寸返回给父视图。

    private struct MyFixedSizeLayout: Layout, ViewModifier {
        let horizontal: Bool
        let vertical: Bool

        func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
            guard subviews.count == 1, let content = subviews.first else {
                fatalError("Can't use MyFixedSizeLayout directly")
            }
            // 准备提交给子视图的建议尺寸
            let width = horizontal ? nil : proposal.width // 如果 horizontal 为 true 则提交非指定模式的建议尺寸，否则则提供父视图在改维度上的建议尺寸
            let height = vertical ? nil : proposal.height // 如果 vertical 为 true 则提交非指定模式的建议尺寸，否则则提供父视图在改维度上的建议尺寸
            let size = content.sizeThatFits(.init(width: width, height: height)) // 向子视图提交上方确定的建议尺寸，并获取子视图的需求尺寸
            return size // 以子视图的需求尺寸作为 MyFixedSizeLayout 容器的需求尺寸
        }

        func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
            guard subviews.count == 1, let content = subviews.first else {
                fatalError("Can't use MyFixedSizeLayout directly")
            }

            content.place(at: .init(x: bounds.minX, y: bounds.minY), anchor: .topLeading, proposal: .init(width: bounds.width, height: bounds.height))
        }

        func body(content: Content) -> some View {
            MyFixedSizeLayout(horizontal: horizontal, vertical: vertical)() {
                content
            }
        }
    }

    public extension View {
        func myFixedSize(horizontal: Bool, vertical: Bool) -> some View {
            modifier(MyFixedSizeLayout(horizontal: horizontal, vertical: vertical))
        }

        func myFixedSize() -> some View {
            myFixedSize(horizontal: true, vertical: true)
        }
    }

### 又见 frame

鉴于两个版本的 frame 无论在功能上还是实现上均有巨大的不同，因此在 SwiftUI 中它们分别对应着不同的布局容器。 `frame(minWidth:, idealWidth: , maxWidth: , minHeight: , idealHeight:,
maxHeight: , alignment:)` 是对布局容器 \_FlexFrameLayout 的二次包装。

\_FlexFrameLayout 实际上是两个功能的结合体：

- 在设置了 ideal 值且父视图的在该维度上提供了未指定模式的建议尺寸时，以 ideal value 作为需求尺寸返回，并将其作为子视图的布局尺寸
- 当 min 或（ 和 ） max 有值时，会按如下规则返回 \_FlexFrameLayout 的在该维度上的需求尺寸（ 下图来自于 [ SwiftUI-Lab ](https://swiftui-lab.com/frame-behaviors/) ）

![frame-flow-chart](https://cdn.fatbobman.com/frame-flow-chart.png)

    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        guard subviews.count == 2, let content = subviews.last else { fatalError("Can't use MyFlexFrameLayout directly") }

        var resultWidth: CGFloat = 0
        var resultHeight: CGFloat = 0

        let contentWidth = content.sizeThatFits(proposal).width // 以父视图的建议尺寸为建议尺寸，获取子视图在宽度上的需求尺寸
        // idealWidth 有值，且父视图在宽度上的建议尺寸为未指定模式，需求宽度为 idealWidth
        if let idealWidth, proposal.width == nil {
            resultWidth = idealWidth
        } else if minWidth == nil, maxWidth == nil { // min 和 max 均没有指定，返回子视图在宽度上的需求尺寸
            resultWidth = contentWidth
        } else if let minWidth, let maxWidth { // min 和 max 都有值时
                resultWidth = clamp(min: minWidth, max: maxWidth, source: proposal.width ?? contentWidth)
        } else if let minWidth { // min 有值时，确保需求尺寸不小于最小值
            resultWidth = clamp(min: minWidth, max: maxWidth, source: contentWidth)
        } else if let maxWidth { // max 有值时，确保需求尺寸不大于最大值
            resultWidth = clamp(min: minWidth, max: maxWidth, source: proposal.width ?? contentWidth)
        }

        // 将上面确定的需求宽度作为建议宽度，获取子视图的需求高度
        let contentHeight = content.sizeThatFits(.init(width: proposal.width == nil ? nil : resultWidth, height: proposal.height)).height
        if let idealHeight, proposal.height == nil {
            resultHeight = idealHeight
        } else if minHeight == nil, maxHeight == nil {
            resultHeight = contentHeight
        } else if let minHeight, let maxHeight {
                resultHeight = clamp(min: minHeight, max: maxHeight, source: proposal.height ?? contentHeight)
        } else if let minHeight {
            resultHeight = clamp(min: minHeight, max: maxHeight, source: contentHeight)
        } else if let maxHeight {
            resultHeight = clamp(min: minHeight, max: maxHeight, source: proposal.height ?? contentHeight)
        }

        let size = CGSize(width: resultWidth, height: resultHeight)
        return size
    }

    // 将值限制在最小和最大之间
    func clamp(min: CGFloat?, max: CGFloat?, source: CGFloat) -> CGFloat {
        var result: CGFloat = source
        if let min {
            result = Swift.max(source, min)
        }
        if let max {
            result = Swift.min(source, max)
        }
        return result
    }

在 View 扩展中需要判断 min、ideal、max 的值是否满足了升序要求：

    public extension View {
        func myFrame(minWidth: CGFloat? = nil, idealWidth: CGFloat? = nil, maxWidth: CGFloat? = nil, minHeight: CGFloat? = nil, idealHeight: CGFloat? = nil, maxHeight: CGFloat? = nil, alignment: Alignment = .center) -> some View {
            // 判断是否 min < ideal < max
            func areInNondecreasingOrder(
                _ min: CGFloat?, _ ideal: CGFloat?, _ max: CGFloat?
            ) -> Bool {
                let min = min ?? -.infinity
                let ideal = ideal ?? min
                let max = max ?? ideal
                return min <= ideal && ideal <= max
            }

            // SwiftUI 官方实现在数值错误的情况下仍会执行，但会在控制台显示错误信息。
            if !areInNondecreasingOrder(minWidth, idealWidth, maxWidth)
                || !areInNondecreasingOrder(minHeight, idealHeight, maxHeight) {
                fatalError("Contradictory frame constraints specified.")
            }

            return modifier(MyFlexFrameLayout(minWidth: minWidth, idealWidth: idealWidth, maxWidth: maxWidth, minHeight: minHeight, idealHeight: idealHeight, maxHeight: maxHeight, alignment: alignment))
        }
    }

## 总结

Layout 协议为我们提供了一个绝佳的可以深入了解 SwiftUI 布局机制的窗口，无论你在未来的工作中是否需要使用 Layout
协议创建自定义布局容器，掌握它都将获得莫大的好处。

# SwiftDataKit：让你在 SwiftData 中使用 Core Data 的高级功能

作为 Core Data 的继任者，全新的 SwiftData 框架在 WWDC 2023 上正式发布。SwiftData
预计会在未来很长一段时间内成为苹果生态系统的主要对象图管理和数据持久化解决方案，为开发者提供服务与支持。本文将讨论，在不使用 Core Data
数据栈的情况下，开发者如何在 SwiftData 中调用 Core Data 提供的高级功能，以扩展 SwiftData 目前的能力。

## SwiftData 当前的困境

与 Core Data 相比，SwiftData 在数据模型声明、类型安全、线程安全、以及与 SwiftUI 整合等多个方面进行了全面提升。其中，它基于
Swift 宏功能的数据模型创建机制、类型安全的谓词系统、依靠 Actor 实现的线程安全以及与 [ Observation
](/zh/posts/mastering-observation/) 框架的紧密结合，使得 SwiftData 更符合现代编程的需求。

然而，可能是由于准备时间不足，当前版本的 SwiftData 还无法实现 Core Data 中的一些高级功能。这就给想尝试 SwiftData
的开发者带来了一定的困扰。即使，开发者可以接受将项目的最小部署环境设置为最新的系统版本（ iOS 17、macOS 14
等），也难免需要在项目中同步创建一套基于 Core Data 的数据模型和数据栈，以实现 SwiftData 所缺少的功能。

如此一来，SwiftData
在数据模型声明上的优势便当然无存，不仅增加了工作量，开发者还需要面对如何处理两个数据框架、模型版本之间的协作问题。仅为实现一些高级功能，就在
SwiftData 的项目中创建一套并行的 Core Data 代码，无疑是十分不经济的。

正是由于上述困难，我一直难以下定决心在新项目中使用 SwiftData。

## 解决 SwiftData 困境的思路

虽然 SwiftData 在表现上与 Core Data 存在很大差异，但是它的核心基础仍然是 Core Data，苹果使用了 Swift
语言的新功能，用符合当代编程风格的设计思想，对 Core Data 进行了二次构建。这不仅使 SwiftData 继承了 Core Data
在数据持久化领域的稳定特质，也意味着 SwiftData 的部分关键组件背后对应着特定的 Core Data
对象。如果我们能够提取出这些对象，在安全的环境中进行有限度的使用，就可以在 SwiftData 中使用 Core Data 的高级功能。

通过 Swift 语言提供的反射 ( Mirror ) 功能，我们可以从 SwiftData 的某些组件中提取出需要的 Core Data 对象，例如从
PersistentModel 中提取出 NSManagedObject，从 ModelContext 中提取出
NSManagedContext。另外，SwiftData 的 PersistentIdentifier 符合 Codable 协议，这使我们可以在它与
NSManagedObjectID 之间进行转换。

## SwiftDataKit

根据前文的思路，我开发了 [ SwiftDataKit ](https://github.com/fatbobman/SwiftDataKit)
库，它允许开发者使用 SwiftData 组件背后的 Core Data 对象，以实现当前版本无法完成的功能。

例如，下面是从 ModelContext 中提取 NSManagedObjectContext 的代码示例：

    public extension ModelContext {
        // Computed property to access the underlying NSManagedObjectContext
        var managedObjectContext: NSManagedObjectContext? {
            guard let managedObjectContext = getMirrorChildValue(of: self, childName: "_nsContext") as? NSManagedObjectContext else {
                return nil
            }
            return managedObjectContext
        }

        // Computed property to access the NSPersistentStoreCoordinator
        var coordinator: NSPersistentStoreCoordinator? {
            managedObjectContext?.persistentStoreCoordinator
        }
    }

    func getMirrorChildValue(of object: Any, childName: String) -> Any? {
        guard let child = Mirror(reflecting: object).children.first(where: { $0.label == childName }) else {
            return nil
        }

        return child.value
    }

接下来，我将通过几个具体案例，简要介绍 SwiftDataKit 的使用方法和注意事项。

> SwiftDataKit 是一个实验性质的库。由于 SwiftData API
> 仍在快速演化中，我建议只有了解其实现原理且明确风险的有经验开发者，在特定场景下谨慎使用。

## 利用 NSManagedObjectContext 实现分组计数

在某些场景下，我们需要对数据进行分组后计数，比如统计不同出生年份的学生人数。

    @Model
    class Student {
        var name: String
        var birthOfYear: Int

        init(name: String, birthOfYear: Int) {
            self.name = name
            self.birthOfYear = birthOfYear
        }
    }

SwiftData 的新谓词系统目前尚不支持分组统计，使用原生方法如下所示：

    func birthYearCountByQuery() -> [Int: Int] {
        let description = FetchDescriptor<Student>(sortBy: [.init(\Student.birthOfYear, order: .forward)])
        let students = (try? modelContext.fetch(description)) ?? []
        let result: [Int: Int] = students.reduce(into: [:]) { result, student in
            let count = result[student.birthOfYear, default: 0]
            result[student.birthOfYear] = count + 1
        }
        return result
    }

开发者需获取全部数据在内存中进行分组统计。数据量大时，这种方法对性能和内存占用的影响极大。

有了 SwiftDataKit，我们可以 **直接使用 ModelContext 底层的 NSManagedObjectContext** ，通过创建
NSExpressionDescription，在 SQLite 数据库端完成该操作。

    func birthYearCountByKit() -> [Int: Int] {
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "Student")
        fetchRequest.propertiesToGroupBy = ["birthOfYear"]
        fetchRequest.sortDescriptors = [NSSortDescriptor(key: "birthOfYear", ascending: true)]
        fetchRequest.resultType = .dictionaryResultType
        let expressDescription = NSExpressionDescription()
        expressDescription.resultType = .integer64
        expressDescription.name = "count"
        let year = NSExpression(forKeyPath: "birthOfYear")
        let express = NSExpression(forFunction: "count:", arguments: [year])
        expressDescription.expression = express
        fetchRequest.propertiesToFetch = ["birthOfYear", expressDescription]
        // modelContext.managedObjectContext, use NSManagedObjectContext directly
        let fetchResult = (try? modelContext.managedObjectContext?.fetch(fetchRequest) as? [[String: Any]]) ?? []
        let result: [Int: Int] = fetchResult.reduce(into: [:]) { result, element in
            result[element["birthOfYear"] as! Int] = (element["count"] as! Int?) ?? 0
        }
        return result
    }

在 10000 条数据的测试中，基于 SwiftDataKit 的实现方法，效率是原生方法的 4 至 5 倍，内存占用也少了许多。

使用 SwiftDataKit 时有几点需要注意：

- 尽管未声明 Core Data 版本的数据模型类型，但可以用字符串方式访问 Entity 和属性。默认情况下，SwiftData 中的模型类型名对应 Entity 名，变量名对应属性名。
- 不推荐使用 `setPrimitiveValue(value:, forKey:)` 、 `value(forKey:)` 等方式读写 NSManagedObject 属性数据，缺乏编译检查。
- SwiftData 使用 [ Actor ](https://twitter.com/fatbobman/status/1694162814406123680) 保证数据操作在 ModelContext 所在线程中进行，所以在 Actor 方法内不需采用 `context.perform` 避免线程问题。

  @ModelActor
  actor StudentHandler {
  func birthYearCountByKit() -> [Int: Int] {
  ...
  // No need to use modelContext.managedObjectContext.perform { ... }
  }

      func birthYearCountByQuery() -> [Int: Int] {
          ...
      }

  }

- 与 Core Data 可以明确创建私有上下文（ 运行于非主线程）不同，通过 @ModelActor 创建的 actor 实例所绑定的线程与创建时的上下文有关（ \_inheritActorContext ）。

## 将 PersistentModel 转换为 NSManagedObject，实现子查询

在 Core Data 中，开发者可以通过创建子查询（SubQuery）谓词，直接在 SQLite 端实现嵌套查询，这对某些场景是必不可缺的功能。

比如我们有以下数据模型定义：

    @Model
    class ArticleCollection {
        var name: String
        @Relationship(deleteRule: .nullify)
        var articles: [Article]
        init(name: String, articles: [Article] = []) {
            self.name = name
            self.articles = articles
        }
    }

    @Model
    class Article {
        var name: String
        @Relationship(deleteRule: .nullify)
        var category: Category?
        @Relationship(deleteRule: .nullify)
        var collection: ArticleCollection?
        init(name: String, category: Category? = nil, collection: ArticleCollection? = nil) {
            self.name = name
            self.category = category
            self.collection = collection
        }
    }

    @Model
    class Category {
        var name: String
        @Relationship(deleteRule: .nullify)
        var articles: [Article]
        init(name: String, articles: [Article] = []) {
            self.name = name
            self.articles = articles
        }

        enum Name: String, CaseIterable {
            case tech, health, travel
        }
    }

在这种模型关系（ `ArticleCollection <-->> Article <<--> Category` ）下，我们想查询有多少个
ArticleCollection 中的任意 Article 属于特定的 Category。

当前，使用 SwiftData 的原生方法如下所示：

    func getCollectCountByCategoryByQuery(categoryName: String) -> Int {
        guard let category = getCategory(by: categoryName) else {
            fatalError("Can't get tag by name:\(categoryName)")
        }
        let description = FetchDescriptor<ArticleCollection>()
        let collections = (try? modelContext.fetch(description)) ?? []
        let count = collections.filter { collection in
            !(collection.articles).filter { article in
                article.category == category
            }.isEmpty
        }.count
        return count
    }

与上文的方式类似，需要获取全部数据在内存中进行过滤统计。

通过将 PersistentModel 转换成 NSManagedObject，我们可以用包含子查询的谓词提高效率：

    func getCollectCountByCategoryByKit(categoryName: String) -> Int {
        guard let category = getCategory(by: categoryName) else {
            fatalError("Can't get tag by name:\(categoryName)")
        }
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "ArticleCollection")
        // get NSManagedObject by category.managedObject
        guard let categoryObject = category.managedObject else {
            fatalError("can't get managedObject from \(category)")
        }
        // use NSManagedObject in Predicate
        let predicate = NSPredicate(format: "SUBQUERY(articles,$article,$article.category == %@).@count > 0", categoryObject)
        fetchRequest.predicate = predicate
        return (try? modelContext.managedObjectContext?.count(for: fetchRequest)) ?? 0
    }

    // fetch category by name
    func getCategory(by name: String) -> Category? {
        let predicate = #Predicate<Category> {
            $0.name == name
        }
        let categoryDescription = FetchDescriptor<Category>(predicate: predicate)
        return try? modelContext.fetch(categoryDescription).first
    }

在示例中，是通过 Category 的 name 来创建谓词并获取数据。通常我们也会用 PersistentIdentifier 在不同
ModelContext 间进行安全传递。这时可以：

    func getCategory(by categoryID:PersistentIdentifier) -> Category? {
        let predicate = #Predicate<Category> {
            $0.id == categoryID
        }
        let categoryDescription = FetchDescriptor<Category>(predicate: predicate)
        return try? modelContext.fetch(categoryDescription).first
    }

> SwiftData 在多线程开发方面与 Core Data 类似，只是形式不同。阅读 [ 关于 Core Data 并发编程的几点提示
> ](/zh/posts/concurrencyofcoredata/) 一文，了解 Core Data 在这方面的更多注意事项。

## 将 NSManagedObject 转换为 PersistentModel

有人可能会问，我们只能用 SwiftDataKit 返回统计数据吗？是否可以将 NSFetchRequest 获取的 NSManagedObject 转换为
PersistentModel 在 SwiftData 中使用？

与前面需求类似，这里我们想获取有哪些 ArticleCollection 的任意 Article 属于特定 Category。

利用 PersistentIdentifier 的 decode 构造方法，SwiftDataKit 支持将 NSManagedObjectID 转换为
PersistentIdentifier，用下面的代码，我们将获得所有符合条件的 ActicleCategory 的
PersistentIdentifier。

    func getCollectPersistentIdentifiersByTagByKit(categoryName: String) -> [PersistentIdentifier] {
        guard let category = getCategory(by: categoryName) else {
            fatalError("Can't get tag by name:\(categoryName)")
        }
        let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: "ArticleCollection")
        guard let categoryObject = category.managedObject else {
            fatalError("can't get managedObject from \(category)")
        }
        let predicate = NSPredicate(format: "SUBQUERY(articles,$article,$article.category == %@).@count > 0", categoryObject)
        fetchRequest.predicate = predicate
        fetchRequest.sortDescriptors = [.init(key: "name", ascending: true)]
        let collections = (try? modelContext.managedObjectContext?.fetch(fetchRequest)) ?? []
        // convert NSManageObjectID to PersistentIdentifier by SwiftDataKit
        return collections.compactMap(\.objectID.persistentIdentifier)
    }

然后根据 PersistentIdentifier 获取对应的 PersistentModel 实例：

    func convertIdentifierToModel<T: PersistentModel>(ids: [PersistentIdentifier], type: T.Type) -> [T] {
        ids.compactMap { self[$0, as: type] }
    }

> 在 SwiftData 中，提供了两种不使用谓词，通过 PersistentIdentifier 获取 PersistentModel
> 的方法，用法和区别我在这篇 [ 推文
> ](https://twitter.com/fatbobman/status/1699028201287356733) 中进行了说明。

![image-20230906200531775](https://cdn.fatbobman.com/image-20230906200531775.png)

通过这些示例，开发者基本可以在不创建 Core Data 数据模型和数据栈的情况下，在 SwiftData 中使用 Core Data 各种高级功能。

## 与 Core Data Stack 进行数据交换

如果直接操作 SwiftData 底层对象仍无法满足需求，则需要创建并行的 Core Data 数据模型和数据栈，并在 SwiftData 和 Core
Data 代码间进行数据交换。

由于 NSManagedObjectID 在不同 NSPersistentStoreCoordinator 间无法保持一致，可以使用
SwiftDataKit 提供的如下功能：

- 将 PersistentIdentifier 转换为 uriRepresentation
- 将 uriRepresentation 转为 PersistentIdentifier

  // convert persistentIdentifier to uriRepresentation
  category.id.uriRepresentation

  // convert uriRepresentation to persistentIdentifier
  uriRepresentation.persistentIdentifier

这样就可以在 SwiftData 栈与 Core Data 栈之间安全地传递数据。

## 总结

通过本文的讨论和示例，我们可以看到，虽然当前 SwiftData 还无法实现 Core Data 的所有高级功能，但通过 SwiftDataKit
提供的接口与工具，开发者可以相对轻松地在 SwiftData 中继续使用 Core Data 的优秀特性。这将大大降低新项目全面采用 SwiftData
的门槛，无需同步维护一套 Core Data 的数据模型与数据栈。

当然，SwiftDataKit 仅是一个过渡时期的解决方案。随着 SwiftData
不断地完善，它会加入越来越多的新功能。我们期待在不久的将来，SwiftData 能成为一个功能完备、简单易用的下一代 Core Data。

PS：SwiftDataKit 目前提供的功能还很有限，欢迎更多的开发者可以参与该项目，让大家能够尽早享受到使用 SwiftData 开发所能带来的爽快感。

# 自定义 Button 的外观和交互行为

通过 Style 改变组件的外观或行为是 SwiftUI 提供的一项非常强大的功能。本文将介绍如何通过创建符合 ButtonStyle 或
PrimitiveButtonStyle 协议的实现，自定义 Button 的外观以及交互行为。

> 可在 [ 此处 ](https://github.com/fatbobman/BlogCodes/tree/main/ButtonStyle)
> 获取本文的范例代码

## 定制 Button 的外观

按钮是 UI 设计中经常会使用到的组件。相较于 UIKit ，SwiftUI 通过 Button 视图，让开发者以少量的代码便可完成按钮的创建工作。

    Button(action: signIn) {
        Text("Sign In")
    }

多数情况下，开发者通过为 Button 的 `label` 参数提供不同的视图来定制按钮的外观。

    struct RoundedAndShadowButton<V>:View where V:View {
        let label:V
        let action: () -> Void
        init(label: V, action: @escaping () -> Void) {
            self.label = label
            self.action = action
        }
        var body: some View {
            Button {
                action()
            } label: {
                label
                    .foregroundColor(.white)
                    .padding(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .foregroundColor(.blue)
                        )
                    .compositingGroup()
                    .shadow(radius: 5,x:0,y:3)
                    .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
        }
    }

    let label = Label("Press Me", systemImage: "digitalcrown.horizontal.press.fill")

    RoundedAndShadowButton(label: label, action: { pressAction("button view") })

![buttonView_2023-02-15_17.36.59.2023-02-15
17_38_28](https://cdn.fatbobman.com/buttonView_2023-02-15_17.36.59.2023-02-15%2017_38_28.gif)

## 使用 ButtonStyle 定制交互动画

遗憾的是，上面的代码无法修改按钮在点击后的按压效果。幸好，SwiftUI 提供了 ButtonStyle 协议可以帮助我们定制交互动画。

    public protocol ButtonStyle {
        @ViewBuilder func makeBody(configuration: Self.Configuration) -> Self.Body
        typealias Configuration = ButtonStyleConfiguration
    }

    public struct ButtonStyleConfiguration {
        public let role: ButtonRole?
        public let label: ButtonStyleConfiguration.Label
        public let isPressed: Bool
    }

ButtonStyle 协议的使用方式与 ViewModifier 十分类似。通过 `ButtonStyleConfiguration`
提供的信息，开发者只需实现 `makeBody` 方法，即可完成交互动画的定制工作。

- label：目标按钮的当前视图，通常对应着 Button 视图中的 label 参数内容
- role：iOS 15 后新增的参数，用于标识按钮的角色（ 取消或具备破坏性）
- isPressed：当前按钮的按压状态，该信息是多数人使用 ButtonStyle 的原动力

  struct RoundedAndShadowButtonStyle:ButtonStyle {
  func makeBody(configuration: Configuration) -> some View {
  configuration.label
  .foregroundColor(.white)
  .padding(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
  .background(
  RoundedRectangle(cornerRadius: 10)
  .foregroundColor(.blue)
  )
  .compositingGroup()
  // 根据 isPressing 来调整交互动画
  .shadow(radius:configuration.isPressed ? 0 : 5,x:0,y: configuration.isPressed ? 0 :3)
  .scaleEffect(configuration.isPressed ? 0.95 : 1)
  .animation(.spring(), value: configuration.isPressed)
  }
  }

  // 快捷引用
  extension ButtonStyle where Self == RoundedAndShadowButtonStyle {
  static var roundedAndShadow:RoundedAndShadowButtonStyle {
  RoundedAndShadowButtonStyle()
  }
  }

通过 buttonStyle 修饰器应用于 Button 视图

    Button(action: { pressAction("rounded and shadow") }, label: { label })
           .buttonStyle(.roundedAndShadow)

![buttonStyle1_2023-02-15_18.27.17.2023-02-15
18_28_25](https://cdn.fatbobman.com/buttonStyle1_2023-02-15_18.27.17.2023-02-15%2018_28_25.gif)

创建一个通用性好 ButtonStyle 实现需要考虑很多条件，例如：role、controlSize、动态字体尺寸、色彩模式等等方面。同
ViewModifier 一样，可以通过环境值获取更多信息：

    struct RoundedAndShadowProButtonStyle:ButtonStyle {
        @Environment(\.controlSize) var controlSize
        func makeBody(configuration: Configuration) -> some View {
                configuration.label
                    .foregroundColor(.white)
                    .padding(getPadding())
                    .font(getFontSize())
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .foregroundColor( configuration.role == .destructive ? .red : .blue)
                    )
                    .compositingGroup()
                    .overlay(
                        VStack {
                            if configuration.isPressed {
                                RoundedRectangle(cornerRadius: 10)
                                    .fill(Color.white.opacity(0.5))
                                    .blendMode(.hue)
                            }
                        }
                        )
                    .shadow(radius:configuration.isPressed ? 0 : 5,x:0,y: configuration.isPressed ? 0 :3)
                    .scaleEffect(configuration.isPressed ? 0.95 : 1)
                    .animation(.spring(), value: configuration.isPressed)
        }

        func getPadding() -> EdgeInsets {
            let unit:CGFloat = 4
            switch controlSize {
                case .regular:
                    return EdgeInsets(top: unit * 2, leading: unit * 4, bottom: unit * 2, trailing: unit * 4)
                case .large:
                    return EdgeInsets(top: unit * 3, leading: unit * 5, bottom: unit * 3, trailing: unit * 5)
                case .mini:
                    return EdgeInsets(top: unit / 2, leading: unit * 2, bottom: unit/2, trailing: unit * 2)
                case .small:
                    return EdgeInsets(top: unit, leading: unit * 3, bottom: unit, trailing: unit * 3)
                @unknown default:
                    fatalError()
            }
        }

        func getFontSize() -> Font {
            switch controlSize {
                case .regular:
                    return .body
                case .large:
                    return .title3
                case .small:
                    return .callout
                case .mini:
                    return .caption2
                @unknown default:
                    fatalError()
            }
        }
    }

    extension ButtonStyle where Self == RoundedAndShadowProButtonStyle {
        static var roundedAndShadowPro:RoundedAndShadowProButtonStyle {
            RoundedAndShadowProButtonStyle()
        }
    }

    // 使用
    HStack {
        Button(role: .destructive, action: { pressAction("rounded and shadow pro") }, label: { label })
            .buttonStyle(.roundedAndShadowPro)
            .controlSize(.large)
        Button(action: { pressAction("rounded and shadow pro") }, label: { label })
            .buttonStyle(.roundedAndShadowPro)
            .controlSize(.small)
    }

![image-20230215183940567](https://cdn.fatbobman.com/image-20230215183940567.png)

## 使用 PrimitiveButtonStyle 定制交互行为

在 SwiftUI 中，Button 默认的交互行为是在松开按钮的同时执行 Button 指定的操作。并且，在点击按钮后，只要手指（ 鼠标
）不松开，无论移动到哪里（ 移动到 Button 视图之外 ），松开后仍会执行指定操作。

尽管 Button 的默认手势与 `TapGestur` 单击操作类似， ~~但 Button 的手势是一种不可撤销的操作~~ 。而
TapGesture 在不松开手指的情况下，如果移动到可点击区域外，SwiftUI 将不会调用 onEnded 闭包中的操作。

> 经网友 [ @Yoo_Das ](https://twitter.com/Yoo_Das) 的反馈，上文中 “Button 的手势是一种不可撤销的操作”
> 的描述不够准确。Button 的手势可以被视为有条件的可撤销操作。在按下按钮后，当手指移动的距离超出了系统预设的距离余量（ 不清楚明确值
> ）后再松开，按钮闭包并不会被调用。

假如，我们想达成与 TapGesture 类似的效果（ 可撤销按钮 ），则可以通过 SwiftUI 提供的另一个协议
PrimitiveButtonStyle 来实现。

    public protocol PrimitiveButtonStyle {
        @ViewBuilder func makeBody(configuration: Self.Configuration) -> Self.Body
        typealias Configuration = PrimitiveButtonStyleConfiguration
    }

    public struct PrimitiveButtonStyleConfiguration {
        public let role: ButtonRole?
        public let label: PrimitiveButtonStyleConfiguration.Label
        public func trigger()
    }

PrimitiveButtonStyle 与 ButtonStyle 两者之间最大的不同是，PrimitiveButtonStyle
要求开发者必须通过自行完成交互操作逻辑，并在适当的时机调用 trigger 方法（ 可以理解为 Button 的 action 参数对应的闭包 ）。

    struct CancellableButtonStyle:PrimitiveButtonStyle {
        @GestureState var isPressing = false

        func makeBody(configuration: Configuration) -> some View {
            let drag = DragGesture(minimumDistance: 0)
                .updating($isPressing, body: {_,pressing,_ in
                    if !pressing { pressing = true}
                })

            configuration.label
                .foregroundColor(.white)
                .padding(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                .background(
                    RoundedRectangle(cornerRadius: 10)
                        .foregroundColor( configuration.role == .destructive ? .red : .blue)
                )
                .compositingGroup()
                .shadow(radius:isPressing ? 0 : 5,x:0,y: isPressing ? 0 :3)
                .scaleEffect(isPressing ? 0.95 : 1)
                .animation(.spring(), value: isPressing)
                // 获取点击状态
                .gesture(drag)
                .simultaneousGesture(TapGesture().onEnded{
                    configuration.trigger() // 执行 Button 指定的操作
                })
        }
    }

    extension PrimitiveButtonStyle where Self == CancellableButtonStyle {
        static var cancellable:CancellableButtonStyle {
            CancellableButtonStyle()
        }
    }

![cancallableStyle_2023-02-15_19.06.47.2023-02-15
19_08_00](https://cdn.fatbobman.com/cancallableStyle_2023-02-15_19.06.47.2023-02-15%2019_08_00.gif)

或许有人会说，既然上面的代码可以通过 DragGesture 模拟获取到点击状态，那么完全可以不使用 PrimitiveButtonStyle
实现同样的效果。如此一来 **使用 Style 的优势在哪里呢** ？

- ButtonStyle 和 PrimitiveButtonStyle 是专门针对按钮的样式 API ，它们不仅可以应用于 Button 视图，也可以应用于很多 SwiftUI 预置的系统按钮功能之上，例如：EditButton、Share、Link、NavigationLink（ 不在 List 中） 等。
- `keyboardShortcut` 修饰器也只能应用于 Button，视图 + TapGesture 无法设定快捷键。

无论是双击、长按、甚至通过体感触发，开发者均可以通过 PrimitiveButtonStyle 协议定制自己的按钮交互逻辑。

## 系统预置的 Style

从 iOS 15 开始，SwiftUI 在原有 PlainButtonStyle、DefaultButtonStyle 的基础上，提供了更加丰富的预置
Style。

- PlainButtonStyle：不对 Button 视图添加任何修饰
- BorderlessButtonStyle：多数情况下的默认样式，在未指定文字颜色的情况下，将文字修改为强调色
- BorderedButtonStyle：为按钮添加圆角矩形背景，使用 tint 颜色作为背景色
- BorderedProminentButtonStyle：为按钮添加圆角矩形背景，背景颜色为系统强调色

其中，PlainButtonStyle 除了可以应用于 Button 外，同时也会对 List 以及 Form
的单元格行为造成影响。默认情况下，即使单元格的视图中包含了多个按钮，SwiftUI 也只会将 List 的单元格视作一个按钮（ 点击后同时调用所有按钮的操作
）。通过为 List 设置 PlainButtonStyle 风格，便可以调整这一行为，让一个单元格中的多个按钮可以被分别触发。

    List {
        HStack {
            Button("11"){print("1")}
            Button("22"){print("2")}
        }
    }
    .buttonStyle(.plain)

## 注意事项

- 同 ViewModifier 不同，ButtonStyle 并不支持串联，Button 只会采用最靠近的 Style

  VStack {
  Button("11"){print("1")} // plain
  Button("22"){print("2")} // borderless
  .buttonStyle(.borderless)
  Button("33"){print("3")} // borderedProminent
  .buttonStyle(.borderedProminent)
  .buttonStyle(.borderless)
  }
  .buttonStyle(.plain)

- 某些按钮样式在不同的上下文中的行为和外观会有较大差别，甚至不起作用。例如：无法为 List 中的 NavigationLink 设置样式
- 在 Button 的 label 视图或 ButtonStyle 实现中添加的手势操作（ 例如 TapGesture ）将导致 Button 不再调用其指定的闭包操作，附加手势需在 Button 之外添加（ 例如下文的 simultaneousGesture 实现 ）

## 为按钮添加 Trigger

在 SwiftUI 中，为了判断某个按钮是否被按下（ 尤其是系统按钮 ），我们通常会通过设置并行手势来添加 trigger ：

    EditButton()
        .buttonStyle(.roundedAndShadowPro)
        .simultaneousGesture(TapGesture().onEnded{ print("pressed")}) // 设置并行手势
        .withTitle("edit button with simultaneous trigger")

不过， [ 上述方法在 macOS 下不起作用
](https://twitter.com/fatbobman/status/1623643244994387968) 。通过 Style
，我们可以在设置按钮样式时为其添加触发器：

    struct TriggerActionStyle:ButtonStyle {
        let trigger:() -> Void
        init(trigger: @escaping () -> Void) {
            self.trigger = trigger
        }
        func makeBody(configuration: Configuration) -> some View {
            configuration.label
                .foregroundColor(.white)
                .padding(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                .background(
                    RoundedRectangle(cornerRadius: 10)
                        .foregroundColor(.blue)
                    )
                .compositingGroup()
                .shadow(radius:configuration.isPressed ? 0 : 5,x:0,y: configuration.isPressed ? 0 :3)
                .scaleEffect(configuration.isPressed ? 0.95 : 1)
                .animation(.spring(), value: configuration.isPressed)
                .onChange(of: configuration.isPressed){ isPressed in
                    if !isPressed {
                        trigger()
                    }
                }
        }
    }

    extension ButtonStyle where Self == TriggerActionStyle {
        static func triggerAction(trigger perform:@escaping () -> Void) -> TriggerActionStyle {
            .init(trigger: perform)
        }
    }

![trigger1_2023-02-15_20.08.05.2023-02-15
20_09_17](https://cdn.fatbobman.com/trigger1_2023-02-15_20.08.05.2023-02-15%2020_09_17.gif)

当然，用 PrimitiveButtonStyle 也一样可以实现：

    struct TriggerButton2: PrimitiveButtonStyle {
        var trigger: () -> Void

        func makeBody(configuration: PrimitiveButtonStyle.Configuration) -> some View {
            MyButton(trigger: trigger, configuration: configuration)
        }

        struct MyButton: View {
            @State private var pressed = false
            var trigger: () -> Void

            let configuration: PrimitiveButtonStyle.Configuration

            var body: some View {
                return configuration.label
                    .foregroundColor(.white)
                    .padding(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .foregroundColor(.blue)
                    )
                    .compositingGroup()
                    .shadow(radius: pressed ? 0 : 5, x: 0, y: pressed ? 0 : 3)
                    .scaleEffect(pressed ? 0.95 : 1)
                    .animation(.spring(), value: pressed)
                    .onLongPressGesture(minimumDuration: 2.5, maximumDistance: .infinity, pressing: { pressing in
                        withAnimation(.easeInOut(duration: 0.3)) {
                            self.pressed = pressing
                        }
                        if pressing {
                            configuration.trigger() // 原来的 action
                            trigger() // 新增的 action
                        } else {
                            print("release")
                        }
                    }, perform: {})
            }
        }
    }

![trigger2_2023-02-15_20.15.56.2023-02-15
20_16_30](https://cdn.fatbobman.com/trigger2_2023-02-15_20.15.56.2023-02-15%2020_16_30.gif)

## 总结

尽管自定义 Style 的效果显著，但遗憾的是，目前 SwiftUI
仅开放了少数的组件样式协议供开发者自定义使用，并且提供的属性也很有限。希望在未来的版本中，SwiftUI 可以为开发者提供更加强大的自定义组件能力。

# HowTo —— SwiftUI2.0 文件导入导出

SwiftUI 2.0 中新增了原生的文件导入导出功能。需注意的是对于不同目录下文件的导出行为会有不同，不同平台下对于权限的处理也不同。

## 更新

目前 SwiftUI 大幅度的修改了导入导出的用法。

fileImporter fileExporter fileMover 分别对应导入、导出、移动

示例如下：

      .fileImporter(isPresented: showImport, allowedContentTypes: [.zip], onCompletion: {
                result in
                switch result{
                case .success(let url):
                    print(store.dataHandler.importData(url))
                case .failure(let error):
                    print(error)
                }

                showImport.wrappedValue = false
      })

系统会自动弹出一个 sheet, 目前的 fileImporter 有 bug, 如果使用手势取消 sheet, 会很难二次呼出。只能使用 cancel
来取消。

其实我更喜欢之前的用法，不过现在以前的用法已经被废弃了。

---

## 原文章

---

## importFiles

    @Environment(\.importFiles) var importFile

    importFile.callAsFunction(singleOfType: [.plainText]){ result in}

## exportFiles

    @Environment(\.exportFiles) var exportFile

    try! exportFile.callAsFunction(FileWrapper(url: URL(fileURLWithPath:filePath), options: .immediate), contentType: .plainText){result in}

## 示例代码

    import SwiftUI

    struct ExportImportTest: View {
        @Environment(\.importFiles) var importFile
        @Environment(\.exportFiles) var exportFile
        @State var text:String = ""
        var body: some View {
            List{
                Button("生成文件"){
                    let filePath = NSTemporaryDirectory() + "test.txt"
                    let outputText = "Hello World!"
                    do {
                        try outputText.write(toFile: filePath, atomically: true, encoding: .utf8)
                        print("测试文件已生成")
                    }
                    catch let error {
                        print(error)
                    }
                }

                Button("导入文件 importFiles"){
                    importFile.callAsFunction(singleOfType: [.plainText]){ result in
                        switch result{
                        case .success(let url):
                            print(url)
                            do {
                                //iOS 的沙盒机制保护需要我们申请临时调用 url 的权限
                                _ = url.startAccessingSecurityScopedResource()
                                let fileData = try Data(contentsOf: url)
                                if let text = String(data:fileData,encoding: .utf8) {
                                    self.text = text
                                    print(text)
                                }
                                url.stopAccessingSecurityScopedResource()
                            }
                            catch let error {
                                print(error)
                            }
                        case .failure(let error):
                            print(error)
                        case .none:
                            break
                        }
                    }
                }

                Button("导出文件 exportFiles"){
                    //exportFile.callAsFunction(moving: URL, completion:  ) 移动文件，源文件会被删除
                    //move 如果出错（比如没有找到源文件，程序会崩溃）
                    //从临时目录导出文件无论是否使用 move, 源文件都会被删除
                    //个人比较倾向于 FileWrapper 的调用方式
                    let filePath = NSTemporaryDirectory() + "test.txt"
                    do {
                        try exportFile.callAsFunction(FileWrapper(url: URL(fileURLWithPath:filePath), options: .immediate), contentType: .plainText){result in
                            switch result{
                            case .success(let url):
                                print("文件导出成功：\(url)")
                            case .failure(let error):
                                print(error)
                            case .none:
                                break
                            }
                        }
                    }
                    catch let error {
                        print(error)
                    }
                }

                Text("导入文件内容：\(text)")
            }
        }
    }

> **macOS 下需要将项目配置中的 App Sandbox - User Selected File 设置为读写**

你的浏览器不支持本视频

## 遗憾

没有提供原生的 activityViewController。

# 深度解读 Observation —— SwiftUI 性能提升的新途径

在 WWDC 2023 中，苹果介绍了 Swift 标准库中的新成员：Observation 框架。它的出现有望缓解开发者长期面临的 SwiftUI
视图无效更新问题。本文将采取问答的方式，全面而详尽地探讨 Observation 框架，内容涉及其产生原因、使用方法、工作原理以及注意事项等。

## 为什么要创建 Observation 框架

在 Swift 5.9 版本之前，苹果没有为开发者提供一种统一高效的机制来观察引用类型属性对变化。KVO 仅限于 NSObject 子类使用，Combine
无法提供属性级别的精确观察，而且两者都无法实现跨平台支持。

此外，在 SwiftUI 中，引用类型的数据源（Source of Truth）采用了基于 Combine 框架的 ObservableObject
协议实现。这导致在 SwiftUI 中，极易产生了大量不必要的视图刷新，从而影响 SwiftUI 应用的性能。

为了改善这些限制，Swift 5.9 版本推出了 Observation 框架。相比现有的 KVO 和 Combine，它具有以下优点：

1. 适用于所有 Swift 引用类型，不限于 NSObject 子类，提供跨平台支持。
2. 提供属性级别的精确观察，且无需对可观察属性进行特别注解。
3. 减少 SwiftUI 中对视图的无效更新，提高应用性能。

## 如何声明可观察对象

使用 Combine 框架，我们可以这样声明一个可被观察的引用类型：

    class Store: ObservableObject {
        @Published var firstName: String
        @Published var lastName: String
        var fullName: String {
            firstName + " " + lastName
        }

        @Published private var count: Int = 0

        init(firstName: String, lastName: String, count: Int) {
            self.firstName = firstName
            self.lastName = lastName
            self.count = count
        }
    }

当实例的 firstName、lastName 以及 count 发生变化时， `@Published` 会通过 `objectWillChange` ( ObjectWillChangePublisher ) 发送通知，告诉所有订阅者，当前的实例即将发生变化。

使用 Observation 框架，我们将采用完全不同的声明方式：

    @Observable
    class Store {
        var firstName: String = "Yang"
        var lastName: String = "Xu"
        var fullName: String {
            firstName + " " + lastName
        }

        private var count: Int = 0

        init(firstName: String, lastName: String, count: Int) {
            self.firstName = firstName
            self.lastName = lastName
            self.count = count
        }
    }

- 在类的声明前添加 `@Observalbe` 标注，不需要指定 Store 类型要遵守某个协议。
- 不需要通过 `@Published` 来标注能引发通知的属性，没有特别标注的存储属性都可以被观察
- 可以观察计算属性（ 在例中，fullName 也可被观察 ）
- 对于不想被观察的属性，需要在其前方标注 `@ObservationIgnored`

  // count 不可被观察
  @ObservationIgnored
  private var count: Int = 0

- 所有的属性必须有字面默认值，即使提供了自定义的 init 方法

相较于基于 Combine 的声明方式，Observation 让可观察对象的声明更加简洁、更加符合直觉，同时也提供了对计算属性的观察支持。

## @Observable 做了哪些工作

与其他常见的使用 `@` 开头的关键字不同（例如 `@Published` 属性包装器和 `@available` 条件编译）， `@Observable` 在这里表示的是宏（Macro）。

宏（Macro）是 Swift 5.9 中新增的一项功能。它允许开发者在编译时操纵和处理 Swift
代码。开发者可以提供一段宏定义，该定义会在编译器编译源代码时执行，并对源代码进行修改、添加等操作。

在 Xcode 15 中，在 `@Observable` 处点击鼠标右键，选择“Expand Macro”操作。通过这步操作，我们可以看到 `@Observable` 宏为我们生成的代码：

![expend-macro-demo-2_2023-06-19_08.38.08.2023-06-19
08_38_52](https://cdn.fatbobman.com/expend-macro-
demo-2_2023-06-19_08.38.08.2023-06-19%2008_38_52.gif)

    @Observable
    class Store {
        @ObservationTracked
        var firstName: String = "Yang" {
            get {
                access(keyPath: \.firstName)
                return _firstName
            }

            set {
                withMutation(keyPath: \.firstName) {
                    _firstName = newValue
                }
            }
        }

        @ObservationTracked // 可以进一步展开
        var lastName: String = "Xu"
        var fullName: String {
            firstName + " " + lastName
        }

        @ObservationIgnored
        private var count: Int = 0

        init(firstName: String, lastName: String, count: Int) {
            self.firstName = firstName
            self.lastName = lastName
            self.count = count
        }

        @ObservationIgnored private let _$observationRegistrar = ObservationRegistrar()

        internal nonisolated func access<Member>(
            keyPath: KeyPath<Store, Member>
        ) {
            _$observationRegistrar.access(self, keyPath: keyPath)
        }

        internal nonisolated func withMutation<Member, T>(
            keyPath: KeyPath<Store, Member>,
            _ mutation: () throws -> T
        ) rethrows -> T {
            try _$observationRegistrar.withMutation(of: self, keyPath: keyPath, mutation)
        }

        @ObservationIgnored private var _firstName: String = "Yang"

        @ObservationIgnored private var _lastName: String = "Xu"
    }

    extension Store: Observable {}

可以看到， `Observable` 宏对我们原本的声明进行了调整。在 Store 中，声明了一个 ObservationRegistrar
结构，用于维护和管理可观察属性和观察者之间的关系。存储属性被改写为计算属性，原有值被保存在同名但带 `_` 前缀的版本中。在 get 和 set
方法中，通过 `_$observationRegistrar` 来注册和通知观察者。最后，宏添加了让可观察对象遵守 Observable
协议的代码（Observable 协议类似于 Sendable, 它不提供任何实现，仅起标示作用）。

## 如何在视图中使用可观察对象

### 在视图中声明可观察对象

与遵守 ObservableObject 协议的 Source of Truth 不同，我们会在视图中使用 `@State`
来确保可观察对象的生命周期。

    @Observable
    class Store {
       ....
    }

    struct ContentView: View {
        @State var store = Store()
        var body: some View {
           ...
        }
    }

### 通过环境在视图树中注入可观察对象

相较于遵守 ObservableObject 协议的 Source of Truth，用 Observation
框架声明的可观察对象拥有更加多样和灵活的环境注入选项。

- 通过 environment 注入实例

  @Observable
  class Store {
  ....
  }

  struct ObservationTest: App {
  @State var store = Store()
  var body: some Scene {
  WindowGroup {
  ContentView()
  .environment(store)
  }
  }
  }

  struct ContentView: View {
  @Environment(Store.self) var store // 在视图中通过环境注入
  var body: some View {
  ...
  }
  }

- 通过自定义 EnvironmentKey

  struct StoreKey: EnvironmentKey {
  static var defaultValue = Store()
  }

  extension EnvironmentValues {
  var store: Store {
  get { self[StoreKey.self] }
  set { self[StoreKey.self] = newValue }
  }
  }

  struct ContentView: View {
  @Environment(\.store) var store // 在视图中通过环境注入
  var body: some View {
  ...
  }
  }

- 注入可选值

  struct ObservationTest: App {
  @State var store = Store()
  var body: some Scene {
  WindowGroup {
  ContentView()
  .environment(store)
  }
  }
  }

  struct ContentView: View {
  @Environment(Store.self) var store:Store? // 在视图中注入可选值
  var body: some View {
  if let firstName = store?.firstName {
  Text(firstName)
  }
  }
  }

其中，自定义 EnvironmentKey 和注入可选值两者方式都完美的解决了忘记注入后导致的 Preview 崩溃问题。尤其是
EnvironmentKey，让开发者具备了提供默认值的能力。

也许有人会感到困惑，为什么使用 Observation 框架声明的可观察对象的注入方式与值类型类似，而遵守 ObservableObject
协议的引用类型，都需要使用注明了 Object 的方法才能注入（StateObject、EnvironmentObject），这样不会引起混淆吗？

可以预期，在开发 iOS 17+ 应用程序时，通过 Observation 框架声明的可观察对象和遵循 ObservableObject
协议的可观察对象，同时出现的场景将越来越少。因此，在不久后，引用类型和值类型在注入形式上将获得高度统一（ 几乎不会再出现使用
environmentObject 或 StateObject 的场景 ）。

### 在视图中传递可观察对象

    struct ContentView: View {
        @State var store = Store()
        var body: some body {
            SubView(store: store)
        }
    }

    struct SubView:View {
        let store:Store
        var body: some body {
           ....
        }
    }

使用 `let` 和 `var` 都可以

### 创建 Binding 类型

Binding 类型为 SwiftUI 提供了实现数据双向绑定的能力。使用 Observation 框架，我们可以通过如下方式创建属性对应的 Binding
类型。

方法一：

    struct ContentView: View {
        @State var store = Store()
        var body: some body {
            SubView(store: store)
        }
    }

    struct SubView:View {
        @Bindable var store:Store
        var body: some body {
           TextField("",text:$store.name)
        }
    }

方法二：

    struct SubView:View {
        var store:Store
        var body: some body {
           @Bindable var store = store
           TextField("",text:$store.name)
        }
    }

方法三：

    struct SubView:View {
        var store:Store
        var name:Binding<String>{
            .init(get: { store.name }, set: { store.name = $0 })
        }
        var body: some body {
           TextField("",text:name)
        }
    }

## Observation 框架支持低版本的 SwiftUI 吗

不支持。

## 如何观察可观察对象

Observation 框架提供了一个全局函数 `withObservationTracking`
。使用此函数，开发者可以跟踪可观察对象的属性是否发生变化。

函数签名：

    func withObservationTracking<T>(
        _ apply: () -> T,
        onChange: @autoclosure () -> () -> Void
    ) -> T

测试一：

    @Observable
    class Store {
        var a = 10
        var b = 20
        var c = 20
    }

    let sum = withObservationTracking {
        store.a + store.b
    } onChange: {
        print("Store Changed a:\(store.a) b:\(store.b) c:\(store.c)")
    }

    store.c = 100

    // No output

    store.b = 100

    // Output
    // Store Changed a:10 b:20 c:100

    store.a = 100

    // No output

测试二：

    withObservationTracking {
       print(store)
       DispatchQueue.main.asyncAfter(deadline: .now() + 0.3){
          store.a = 100
       }
    } onChange: {
        print("Store Changed")
    }

    store.b = 100

    // No output

    store.a = 100

    // No output

在苹果为 `withObservationTracking` 提供的 [ 官方文档
](https://developer.apple.com/documentation/observation/withobservationtracking "_:onchange:") 中，对函数的解释如下：

- apply：一个包含要跟踪的属性的闭包（ A closure that contains properties to track ）
- onChange：当属性值更改时调用的闭包（ The closure invoked when the value of a property changes ）
- 返回值：如果 `apply` 闭包有返回值，则返回该值；否则，没有返回值（ The value that the `apply` closure returns if it has a return value; otherwise, there is no return value ）

由于描述的过于简单，阅读后还是有不少让人困惑的地方：

- `withObservationTracking` 是如何判断 apply 闭包中哪些属性可以被观察？
- 为什么同样出现在 apply 闭包中的可观察属性，修改后并不会触发回调（ 测试二 ）？
- `withObservationTracking` 创建的观察行为是一次性的还是持久性的？
- onChange 闭包的调用时机是什么？所谓的 “when the value of a property changes” 是在属性被更改前还是更改后？

庆幸的是，Observation 框架是 Swift 5.9 标准库的一部分。我们可以通过查看其 [ 源代码
](https://github.com/apple/swift/tree/main/stdlib/public/Observation/Sources/Observation)
来了解更多信息。

## Observation 框架的观察原理是什么

通过阅读代码，我们将对 `withObservationTracking` 创建观察的操作流程有一定的了解。我将其梳理如下：

### 创建观察阶段

- `withObservationTracking` 在当前线程的 `_ThreadLocal.value` 中创建一个 `_AccessList`
- 执行 apply 闭包
- 可观察对象的可观察属性在 get 方法被调用时（ 调用由 apply 闭包引发 ）, 会通过 `access` 方法在可观察对象实例的 ObservationRegistrar 中保存 apply 闭包中出现的可观察属性与回调闭包之间的对应关系 ( 这里的回调闭包用于调用 withObservationTracking 中的 onChange 闭包）。
- `withObservationTracking` 在 `_AccessList` 中保存可观察属性与 onChange 回调闭包之间的对应关系

### 当被观察属性即将变化时

- 被观察属性会调用 ObservationRegistrar 中的 `willSet` 方法，找到当前属性 KeyPath 对应的回调闭包
- 通过调用该闭包，在 `withObservationTracking` 发起的线程中调用 onChange 闭包
- onChange 闭包调用完成后，会清除 `withObservationTracking` 当前线程中 `_AccessList` 中对应的信息
- 清除 ObservationRegistrar 中与本次观察操作有关的属性与回调闭包之间的对应关系

### 结论

通过梳理，我们可以得到如下结论：

- 只有 apply 闭包中被读取的可观察属性（通过调用其 get 方法）才会被观察（这解释了测试二中的问题）
- `withObservationTracking` 创建的观察操作是一次性的行为，任意一个被观察属性发生变化，在调用了 onChange 函数后，本次观察都将结束
- onChange 闭包是在属性值变化之前（willSet 方法中）被调用的
- 在一次观察操作中，可以观察多个可观察属性。任一属性值变化都会结束本次观察。
- 观察行为是线程安全的， `withObservationTracking` 可以运行在另一个线程中，onChange 闭包将运行于 `withObservationTracking` 发起的线程中
- 只有可观察属性可以被观察。apply 闭包中仅出现的可观察对象并不会创建观察操作（这解释了测试二）

> 目前，Observation 框架并未提供创建持续观察行为的 API。或许在之后的版本中会增加这部分功能。

## SwiftUI 的视图如何观察属性的变化

根据 Observation 框架的工作原理，我们可以推测 SwiftUI 大概会采用下面的方法在可观察属性与视图更新之间创建联系：

    struct A:View {
       var body: some View {
           ...
       }
    }

    let bodyValue = withObservationTracking {
        viewA.body
    } onChange: {
        PreparingToRe-evaluateTheBodyValue()
    }

在上文中，我们总结出“只有在 apply 闭包中被读取的可观察属性（通过调用其 get 方法）才会被观察”。因此可以得出以下结论：

    Text(store.a) // Changes in store.a will trigger a re-evaluation of the body.

    Button("Hi"){
        store.b = "abc" // Changes in store.b will not trigger a re-evaluation of the body.
    }

## 通过 @Obervable 标注的类，是否还可以遵守 ObservableObject 协议

可以，不过由于 @Published 属性包装器和 @Observable 宏之间会产生冲突，因此我们需要通过 `withObservationTracking` 来达成目的：

    @Observable
    final class Store: ObservableObject {
        var name = ""
        var age = 0

        init(name: String = "", age: Int = 0) {
            self.name = name
            self.age = age
            observeProperties()
        }

        private func observeProperties() {
            withObservationTracking {
                let _ = name
                let _ = age
            } onChange: { [weak self] in
                guard let self else { return }
                objectWillChange.send()
                observeProperties()
            }
        }
    }

> 如有需要，你可以通过自定义宏来完成在 observeProperties 方法中引入所有可观察属性的重复工作。

## 在视图中 @Obervable 与 ObservableObject 可以共存吗

可以。在一个视图中，可以同时存在以不同的方式声明的可观察对象。SwiftUI 将根据可观察对象在视图中的注入方式选择对应的观察手段。

例如，上文中同时满足两种观察途径的可观察对象，根据其注入的方式不同，SwiftUI 采用的更新策略也将不同。

    @State var store = Store() // 根据属性的变化，精细地决定是否重新评估 body

    @StateObject var store = Store() // 只要有属性（ @Published ）发生变化，便对 body 重新评估

## 可观察对象支持嵌套吗（ 一个可观察对象的属性为另一个可观察对象 ）

支持。

由于 `@Published` 仅支持值类型，因此对于遵守 ObservableObject 协议的可观察对象，很难实现类似的嵌套逻辑：

    class A:ObservableObject {
        @Published var b = B()
    }

    class B:ObserableObject {
        @Published var a = 10
    }

    let a = A()
    a.b.a = 100 // 并不会触发视图更新

我曾经编写过一个 `@PublishedObject` 属性包装器来解决这个问题。详细信息，请阅读 [ 为自定义属性包装类型添加类 @Published
的能力 ](/zh/posts/adding-published-ability-to-custom-property-wrapper-types/)
一文。原理上， `@PublishedObject` 是通过找到外部对象 A（ _enclosing instance_ ）的 `objectWillChange` ，在 B 的属性发生变化时通知 A 的订阅者。也就是说，用了高度耦合的方式才实现了可观察对象的嵌套。

然而，通过 Observation 框架创建的可观察对象实现嵌套则会简单得多。通过 `withObservationTracking`
创建观察操作时，每个被读取的可观察属性都会主动地创建与订阅者之间的关联。无论它处在关系链中的任何层级，或以任何形式存在（如数组、字典等），都能被正确地跟踪。

例如：

    @Observabl
    class A {
       var a = 1
       var b = B()
    }

    @Observable
    class B {
       var b = 1
    }

    let a = A()

    withObservationTracking {
       let _ = a.b.b
    } onChange: {
        print("update")
    }

对于上面的代码，下面两种方式都会调用 onChange 闭包（ 只会调用一次 ）。

    a.b.b = 100

    // or

    a.b = B()

在 `let _ = a.b.b` 这一行代码中，同时创建了对两个不同对象、不同层级的可观察属性的观察， `a.b` 以及 `b.b` 。这也是
Observation 框架的强大之处。

## Observation 是否解决了 ObservableObject 的性能问题

是的，Observation 框架从两方面改善了可观察对象在 SwiftUI 中的性能表现：

- 通过观察视图中的可观察属性而不是可观察对象，可以减少大量无效的视图更新。
- 相较于 Combine 的发布者-订阅者模式，Observation 的回调机制更加高效。

然而，由于 Observation 框架暂不支持创建可持续性的观察行为，每次评估后视图都需要重新创建观察操作（ 用时极少
）。我们需要更多时间来评估这是否会导致新的性能问题。

## Observation 框架会影响 SwiftUI 编程习惯吗

对我来说，是的。

比如，当前开发者通常会使用结构体（ Struct ）来构建应用的状态模型。使用了 Observation 框架后，为了实现属性级别的观察，我们应该改用
Observation 框架创建可观察对象，甚至多层嵌套的对可观察对象来构建状态模型。

另外，我们之前在视图中很多的优化技巧也将发生改变。例如，在使用 ObservableObject
时，我们会通过只引入与当前视图有用的数据，来减少不必要的刷新。

> 更多对视图优化技巧，请阅读 [ 避免 SwiftUI 视图的重复计算
> ](/zh/posts/avoid_repeated_calculations_of_swiftui_views/) 一文。

    class Store:ObservableObject {
        @Published var a = 1
        @Published var b = "hello"
    }

    struct Root:View {
        @StateObject var store = Store()
        var body: some View {
            VStack{
                A(a: store.a)
                B(b: store.b)
            }
        }
    }

    struct A:View {
        let a:Int    // only get a(Int)
        var body:some View {
            Text("\(store.a)")
        }
    }

    struct B:View { // only get b(String)
        let b:String
        var body:some View {
            Text(store.b)
        }
    }

当 `store.b` 发生变化时，只有 Root 和 B 两个视图会重新评估。

在改用 Observation 框架后，上述的优化策略将不再是最优解。相反，以前不推荐的方式更加适合新的可观察对象。

    @Observabl
    class Store {
        var a = 1
        var b = "hello"
    }

    struct Root:View {
        @State var store = Store()
        var body: some View {
            VStack{
                A(store: store)
                B(store: store)
            }
        }
    }

    struct A:View {
        let store: Store
        var body:some View {
            Text("\(store.a)")
        }
    }

    struct B:View {
        let store: Store
        var body:some View {
            Text(store.b)
        }
    }

只有出现在 body 中且被读取的属性才会触发视图的更新。经过修改后，当 `store.b` 发生变化时，只有 B 视图会重新评估。

由于 Observation 框架仍然是一个新事物，其 API 也还在不断演化中。随着越来越多的 SwiftUI
应用转换到这个框架上，开发者会总结出更多的使用心得。

## 最后

通过本文的论述，读者应该对 Observation 框架以及该框架如何改善 SwiftUI 的性能有了进一步的认识。尽管 Observation 框架目前与
SwiftUI 紧密绑定，但随着其 API 的丰富，相信它会出现在越来越多的应用场景中，而不仅仅是 SwiftUI。

# 在 SwiftUI 中实现视图居中的若干种方法

将某个视图在父视图中居中显示是一个常见的需求，即使对于 SwiftUI 的初学者来说这也并非难事。在 SwiftUI
中，有很多手段可以达成此目的。本文将介绍其中的一些方法，并对每种方法背后的实现原理、适用场景以及注意事项做以说明。

## 需求

实现下图中展示的样式：在彩色矩形视图中居中显示单行 Text

![image-20220829142518962](https://cdn.fatbobman.com/image-20220829142518962.png)

## 填充物

### Spacer

最常见也是最容易想到的解决方案。

    var hello: some View {
        Text("Hello world")
            .foregroundColor(.white)
            .font(.title)
            .lineLimit(1)
    }

    HStack {
        Spacer()
        hello
        Spacer()
    }
    .frame(width: 300, height: 60)
    .background(.blue)

如果我告诉你上面的代码有两个隐患你相信吗？

- 文本内容超出了矩形的宽度

Spacer 是有最小厚度设定的，默认的最小垫片厚度为 8 px 。即使文本宽度超出了 HStack 给出的建议宽度，但 HStack
在布局时，仍会保留其最小厚度，导致下图上方的文本无法充分利用矩形视图的宽度。

解决方法为： `Spacer(minLength: 0)` 。

当然，你也可以利用 Spacer 这个特性，控制 Text 在 HStack 中可使用的宽度。

![image-20220829152914736](https://cdn.fatbobman.com/image-20220829152914736.png)

- 将合成后的视图放置在某个可能会充满屏幕的视图的顶部或底部显示结果或者与你的预期不符

  VStack {
  // Hello world 视图 1
  HStack {
  Spacer(minLength: 0)
  hello
  Spacer(minLength: 0)
  }
  .frame(width: 300, height: 60)
  .background(.blue)

      HStack {
            Spacer(minLength: 0)
            hello
            Spacer(minLength: 0)
        }
        .frame(width: 300, height: 60) // 相同的尺寸
        .background(.red)

      Spacer() // 让 VStack 充满可用空间

  }

![image-20220829154641251](https://cdn.fatbobman.com/image-20220829154641251.png)

从 SwiftUI 3.0 开始，在使用 background 添加符合 ShapeStyle 协议的元素时，可以通过
ignoresSafeAreaEdges 参数设置是否忽略安全区域，默认值为 `.all` （ 忽略任何的安全区域 ）。因此，当我们将合成后的
hello world 视图放置在 VStack 顶部时（ 通过 Spacer ），矩形的 background 会连同顶部的安全区域一并渲染。

解决的方法是： `.background(.blue, ignoresSafeAreaEdges: [])` ，排除掉不希望忽略的安全区域。

另外，在给定尺寸不明的情况下（ 未显式为矩形设置尺寸 ），上面的代码也需要进行一定的调整。例如，在 List Row 中显示 hello world
视图，希望矩形能够充满 Row ：

    List {
        HStack {
            Spacer(minLength: 0)
            hello
            Spacer(minLength: 0)
        }
        .background(.blue)
        .listRowInsets(.init(top: 0, leading: 0, bottom: 0, trailing: 0)) // 将 Row 的 Insets 设置为 0

    }
    .listStyle(.plain)
    .environment(\.defaultMinListRowHeight, 80) // 设置 List 最小行高度

hello world 视图并不能充满 Row 提供的高度。这是由于 HStack 的高度是由容器子视图对齐排列后的高度决定的。Spacer 在
HStack 中只能进行横向填充，并不具备纵向的高度（ 高度为 0 ），因此 HStack 最终的需求高度与 Text 的高度一致。

![image-20220829155353877](https://cdn.fatbobman.com/image-20220829155353877.png)

解决的方法是：

    HStack {
        Spacer(minLength: 0)
        hello
        Spacer(minLength: 0)
    }
    .frame(maxHeight: .infinity) // 用满建议高度
    .background(.blue)

> 后文中为了简洁将省略掉针对给定尺寸不明情况的处理方式。统一使用固定尺寸（ `.frame(width: 300, height: 60)` ）。

### 其他填充物

那么，我们是否可以利用其它的视图实现与 Spacer 类似的填充效果呢？例如：

    HStack {
        Color.clear
        hello
        Color.clear
    }
    .frame(width: 300, height: 60)
    .background(Color.cyan)

很遗憾，使用上面的代码，Text 将只能使用 HStack 三分之一的宽度。

HStack、VStack 在进行布局时，会为每个子视图提供四种不同的建议模式（ 最小、最大、明确尺寸以及未指定
），如果子视图在不同的模式下返回的需求尺寸是不一样的，则意味着该视图是可变尺寸视图。那么 HStack、VStack
会在明确了所有固定尺寸子视图的需求尺寸后，将所剩的可用尺寸（ HStack、VStack 的父视图给他们的建议尺寸 - 固定尺寸子视图的需求尺寸
）平均分配（ 在优先级相同的情况下 ）给这些可变尺寸视图。

由于 Color、Text 都具备可变尺寸的特性，因此，它们三等分了 HStack。

![image-20220829160625981](https://cdn.fatbobman.com/image-20220829160625981.png)

但是我们可以通过调整视图优先级的方式，来保证 Text 能够获得最大的分量，例如：

    HStack {
        Color.clear
            .layoutPriority(0)
        hello
            .layoutPriority(1)
        Color.clear
            .layoutPriority(0)
    }
    .frame(width: 300, height: 60)
    .background(Color.cyan)

    Text("Hello world,hello world,hello world") // hello 的宽度超出了矩形的宽度

![image-20220829161755393](https://cdn.fatbobman.com/image-20220829161755393.png)

至于上图中 Text 仍没有充分利用 HStack 全部宽度的原因，是因为没有为 HStack 设置明确的 spacing ，将其设置为 0 即可： `HStack(spacing:0)` 。

为布局容器设置明确的 spacing 是一个好习惯，在未明确指定时，HStack、VStack
在进行布局时可能会出现某些超出你预期的情况。下文中也会碰到此种情况。

> HStack、VStack 是不会给 Spacer 分配 spacing 的，毕竟 Spacer 本身就代表了空间占用。因此在第一个例子中，即使没有为
> HStack 设置 spacing ，Text 仍然会使用全部的 HStack 宽度。

掌握了视图优先级的使用方式，我们还可以利用其他具备可变尺寸的特性的视图来充当填充物，例如：

- `Rectangle().opacity(0)`
- `Color.blue.opacity(0)`
- `ContainerRelativeShape().fill(.clear)`

在使用 SwiftUI 进行开发的过程中，Color、Rectangle 等经常被用来实现对容器的等分操作。另外，由于 Color、Rectangle
会在两个维度进行填充（ Spacer 会根据容器选择填充维度 ），因此，使用它们作为填充物时，将会自动使用全部的可用空间（ 包括高度 ），无需通过 `.frame(maxHeight: .infinity)` 应对给定尺寸不明的场景。

> 请阅读 [ SwiftUI 專欄 #4 Color 不只是顏色
> ](https://www.ethanhuang13.com/p/swiftui-4-not-just-color) ，掌握有关 Color 更多的内容

## 对齐指南

上节中，我们通过填充物让 Text 实现了左右居中。上下居中则是利用了 HStack 对齐指南的默认设定（ `.center`
）实现的。本节中，我们将完全通过对齐指南来实现居中操作。

### ZStack

    ZStack { // 使用对齐指南的默认值，相当于 ZStack(alignment:.center)
        Color.green
        hello
    }
    .frame(width: 300, height: 60)

上述代码的布局逻辑是：

- ZStack 为 Color 和 Text 分别给出了 300 x 60 的建议尺寸
- Color 会将建议尺寸作为自己的需求尺寸（ 表现为充满 ZStack 空间 ）
- Text 最大可用宽度为 300
- Color 与 Text 将按照对齐指南 center 进行对齐（ 看起来就是 Text 显示在 Color 的中间 ）

如果将代码改写成下面的方式就会出现问题：

    ZStack { // 在不明确设置 VStack spacing 的情况下，会出现 VStack spacing 不一致的情况
        Color.gray
            .frame(width: 300, height: 60)
        hello // 宽度没有约定，当文本较长时，会超过 Color 的宽度
    }

上方代码的布局逻辑是：

- Color 的尺寸为 300 x 60 ( 不关心 ZStack 给出的建议尺寸 )
- ZStack 的尺寸为 Color 和 Text 两者的最大宽度 x 最大高度，该尺寸是一个可变尺寸（ 取决于 Text 文本的长度 ）
- 当 ZStack 给出的建议宽度大于 300 时，Text 的可利用宽度将超过 Color 的宽度

因此会出现两种可能的错误状态：

- 当文本较长时，Text 会超过 Color 的宽度
- 由于合成视图具备可变尺寸特性，VStack、HStack 在为其添加 spacing 时将可能出现与预期不符的状况 （ 下图中 spacing 的分配不均匀。显式设置可以解决该问题，请养成显式设置 spacing 的习惯 ）

  VStack { // 没有设定 spacing ，显式设置可修复 spacing 不均匀的问题
  ZStack {
  Color.green
  hello
  }
  .frame(width: 300, height: 60)

      ZStack { // 在不明确设置 VStack spacing 的情况下，会出现 VStack spacing 不一致的情况
          Color.gray
              .frame(width: 300, height: 60)
          hello // 对于文字超过矩形宽度的情况不好处理
      }

      // Spacer 版本
      HStack {
          Spacer(minLength: 0)
          hello
              .sizeInfo()
          Spacer(minLength: 0)
              .sizeInfo()
      }
      .frame(width: 300, height: 60)
      .background(.blue, ignoresSafeAreaEdges: [])

  }

![image-20220829175721185](https://cdn.fatbobman.com/image-20220829175721185.png)

> 在不给 VStack、HStack 的 spacing 设定明确值的情况下（ spacing = nil
> ），布局容器将尝试从每个子视图中获取子视图的预设 spacing 值，并将此值应用在与之临近的视图之间。由于不同种类的视图的默认 spacing
> 并不相同，因此就会出现貌似 spacing 分配不均匀的情况（ 事实上布局容器正确地执行了我们的要求
> ）。如果想保证所有的视图之间都能保持一致的间隔，需要给布局容器设置明确的 spacing 值

### frame

    hello
        .frame(width: 300, height: 60) // 使用了默认的 center 的对齐指南，相当于 .frame(width: 300, height: 60,alignment: .center)
        .background(.pink)

布局逻辑：

- 使用 FrameLayout 布局容器对 Text 进行布局
- FrameLayout 给 Text 的建议尺寸为 300 x 60
- Text 与占位视图（ 空白视图的尺寸为 300 x 600 ）按对齐指南 center 进行对齐

这是我个人最喜欢使用的居中手段，应对给定尺寸不明的情况也十分方便：

    hello
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(.pink)

> 想了解 frame 的实现原理请阅读 [ SwiftUI 布局 —— 尺寸（ 下 ） ](/zh/posts/layout-dimensions-2/)
> 一文

### overlay

    Rectangle() // 直接使用 Color.orange 也可以
        .fill(Color.orange)
        .frame(width: 300, height: 60)
        .overlay(hello) // 相当于 .overlay(hello,alignment: .center)

布局逻辑：

- Rectangle 将获得 300 x 60 建议尺寸（ Rectangle 将使用全部的尺寸 ）
- 使用 OverlayLayout 布局容器对 Rectangle 及 Text 进行布局，建议尺寸采用主视图的需求尺寸（ Rectangle 的需求尺寸 ）
- Text 与 Rectangle 按照对齐指南 center 进行对齐

那么是否可以用 background 实现类似的样式呢？例如：

    hello
        .background(
            Color.cyan.frame(width: 300,height: 60)
        )
        .border(.red) // 显示边框以查看合成视图的布局尺寸

![image-20220829182808201](https://cdn.fatbobman.com/image-20220829182808201.png)

很遗憾，你将获得与上文中 ZStack 错误用法类似的结果。文字可能会超长，视图无法获得 spacing （ 即使进行了显式设置 ）。

> 请阅读 [ SwiftUI 布局 —— 对齐 ](/zh/posts/layout-alignment/) ，了解更多有关
> ZStack、overlay、background 的对齐机制

## Geometry

虽然有些大材小用，但当我们需要获取更多有关视图的信息时，GeometryReader 是一个相当不错的选择：

    GeometryReader { proxy in
        hello
            .position(.init(x: proxy.size.width / 2, y: proxy.size.height / 2))
            .background(Color.brown)
    }
    .frame(width: 300, height: 60)

布局逻辑：

- GeometryReader 将获得 300 x 60 的建议尺寸
- 由于 GeometryReader 拥有与 Color、Rectangle 类似的特征，会将给定的建议尺寸作为需求尺寸（ 表现为占用全部可用空间 ）
- GeometryReader 给 Text 提供 300 x 60 的建议尺寸
- GeometryReader 中的视图，默认基于 topLeading 对齐（ 类似 `overlay(alignment:.topLeading)` 的效果 ）
- 使用 postion 将 Text 的中心点与给定的位置进行对齐（ postion 是一个通过 CGPoint 来对齐中心点的视图修饰器 ）

当然，你也可以获取 Text 的 Geometry 信息，通过 offset 或 padding 的方式实现居中。不过除非矩形的尺寸明确，否则里外都需要使用
GeometryReader ，实现将过于烦琐。

## 总结

本文选取了一些有代表性的解决方法，随着 SwiftUI 功能的不断增强，会有越来越多的手段可供使用。万变不离其宗，掌握了 SwiftUI
的布局原理，无论需求如何变化都可轻松应对。

# WWDC 23 ，SwiftUI 5 和 SwiftData 的初印象

WWDC 2023 正在如火如荼地进行。苹果不仅带来了全新形态的硬件产品，还推出了几个相当震撼的新框架。本文将聊聊我对本届 WWDC 中 SwiftUI
5.0 和 SwiftData 的初步印象。

## SwiftUI

如果说从 SwiftUI 1.0 到 4.0 每年的升级是一种小修小补的行为，那么今年苹果在 SwiftUI 5.0 上做出的努力至少算得上是中期改款了。

今年 SwiftUI 的提升相当的大，有些改动可以视为革命性的变化。

### 全新的数据流声明和注入方式

利用 Swift 5.9 的新特性，对于引用类型的 Source of truth，只需使用 `@Observable`
进行标注，视图将对数据源的变化以属性为粒度进行响应。这从根本上解决了当前影响 SwiftUI 应用（ 过渡计算
）的效率问题。让开发者可以更加自由的来设计数据结构以及随心所欲的注入数据源。

不过很遗憾，这项新特性只能在 SwiftUI 5 上实现。如果你打算开发 iOS 17+ 的应用，那么就应该马上抛弃 `@ObservableObject` 这样的声明方式。

由于在同一个系统中存在了两种不同的数据源声明逻辑，这也给初学者带来了更多的困扰。

### 革命性的动画和视觉效果升级

SwiftUI 原本欠缺一些高级的动画和视觉功能在本次升级中一并被补上了，而且苹果大幅更新了动画、转场、Shape、效果等方面的内部实现。

本次升级带来了动画完成回调、阶段性动画、关键帧动画、全新的 Transition 协议（ 支持转场状态 ）、全新的 Shape 协议（ 支持 Shape
之间的运算 ）、全新的 TransactionKey（ 支持自定义 Transaction 属性 ）、Shader 支持（ 实现某些特殊效果将异常容易
）、类型安全的图片和颜色资源类型（ Assets 会自动生成对应的代码 ）、便捷的 Symbol 动画、全新的 CustomAnimation 协议（
支持自定义动画函数 ）、弹簧动画等众多新功能。总之，当前制约动画或视觉效果的将不再是 SwiftUI 的能力，而是开发者的创意。

### 大幅改善了 ScrollView 的控制力

本次升级中，为 ScrollView 带来了新的动态滚动定位系统（ 不依赖 ScrollViewReader 和显式的 id 声明）、一次性的定位系统（
在视图进入后，直接定位到滚动视图的特定位置，只能使用一次 ）、全新的滚动条控制（ 闪烁 ）、可自定义行视图在滚动区域的顶端和显示区域的显示状态（
例如可用其实现类似 watchOS 中的滚动到顶端子视图缩小的视觉效果 ）、支持分页滚动（ 开发者长期盼望的
）、自定义滚动内容的缩进、为滚动内容（非滚动容器）添加安全区域等众多功能。

### 其他功能

本次的升级内容非常多，导致苹果给出的 [ 更新文档
](https://developer.apple.com/documentation/Updates/SwiftUI)
中，很多的新功能也没有列出。在接下来的一段时间中，互联网上应该会有不少的文章对这些功能进行进一步的说明和讲解。

不过极为遗憾的是，苹果并没有充分的利用 Swift 的 `@_backDeploy` 功能，在 SwiftUI 5.0
中，仅有极少切不太重要的功能或类型实现了低版本的适配： `topBarLeading: SwiftUI.ToolbarItemPlacement` 、
`topBarTrailing: SwiftUI.ToolbarItemPlacement` 、 `accessoryBar<ID>` 、 `horizontalSizeClass` 、 `verticalSizeClass` 、 `typeSelectEquivalent` 。

在不考虑兼容旧版本的情况下，我认为 SwiftUI 5.0 的升级可以打 95 分（满分 100
分），不过考虑到很多的开发者在相当一段时间内还无法使用这些新功能，心情就会异常的低落。

## SwiftData

经过开发者长时间的期盼，苹果终于推出了基于 Swift 开发的对象图管理和持久化框架 ——
SwiftData。与之前的预判一样，在数据存储领域，苹果不会贸然地另起炉灶，创建一套全新的逻辑。SwiftData 本质上就是一套官方推出的，基于
Swift 5.9 新功能实现的 Core Data 的 Swift 封装库。

从我这两天的使用来看，在其功能和稳定性得到进一步改善和增强的情况下，它确实会给开发者带来更多的便利。

这是我目前整理的一些有关 SwiftData 的问题和注意事项（ 原文发表在推文中，没有进行更系统的归纳）：

- 尚不支持公共和共享数据的云同步
- 在当前版本中，通过其他上下文（ModelContext）创建的数据并不会自动合并到视图上下文中
- 自定义迁移 plan 在第一版中有问题
- 可以与 Core Data 代码混用，需通过 entityVersionHashesByName 来判断 SwiftData 与 Core Data 两者的模型是否完全一致
- PersistentModel 和 ModelContext 都不是 Sendable 的（ModelContainer 符合 Sendable），与 Core Data 一样，同样有线程限制
- 开启 `com.apple.CoreData.ConcurrencyDebug 1` 后，即使在新的 Context 中使用 transaction 尝试保持线程一致，仍会强制报错（即使是在一个新创建的 actor 中进行）
- 同样受到 CloudKit 同步的限制，演示中的 Attribute (. unique) 并不适用于同步场景
- 目前功能比 Core Data 少，没有新的增加
- PersistentModel 的性质与通过宏创建的 Observed 状态类似，可直接驱动视图更新（传递时无需使用属性包装器）
- Attribute 的派生选项被废弃了
- 可以在 Xcode 中使用 Model Editor 将 Model 转换为 SwiftData 代码，但目前问题还不少，当有多个选项，或属性类型为 transformable ，无法很好地应对
- Model 原来设置的 Index，目前无法转换（可生成对应的代码，但 Attributed 尚未完全）
- 所有针对 Core Data 的启动参数目前同样适用
- modelContext 的自动保存有问题，当前仍应调用 save 方法
- 与 Core Data Stack 混用时，Core Data 端要开启持久化历史跟踪
- Query（FetchRequest 的替代品）没有提供动态切换 predicate 和 sort 的方法

从代码风格和实现来看，SwiftData 有着光明的未来，但由于目前仍存在不少问题，即使你打算开发 iOS 17+ 应用，目前也不建议直接使用
SwiftData。

为配合 SwiftData，Core Data 做了很小幅度的升级，其中一个值得关注的功能是 [ 自定义 composite 类型
](https://twitter.com/fatbobman/status/1666677142170779648?s=20) 。

然而，Core Data with CloudKit API 在客户端方面没有任何调整，很令人失望。

## 开心还是无奈

在今年的 WWDC 中，苹果为 SwiftUI 带来了非常大的变革，并推出了开发者向往已久的
SwiftData。一开始看到这些信息时，我内心无比兴奋，但很快就平静下来了，最终还有些无奈。

对于绝大多数开发者来说，一旦能够在应用中使用这些新功能，苹果或许又会带来更多的新诱惑。SwiftUI
的新特性极大拓展了其表达能力，但同时也增加了其学习曲线，特别是对初学者而言。SwiftData 虽然简化了 Core Data
的开发，但作为一款新框架，其稳定性与健壮性还有待进一步验证。

在过去几年，苹果推出的新技术层出不穷，开发者要不断学习与适应，这无形中也增加了开发成本与风险。虽然苹果的新技术普遍都具有实用价值，但在追新与稳定之间，开发者也需要慎重地权衡。

不过对于我来说，本次 WWDC 提供了不少学习和写作的素材。在接下来的一段时间里，我将在博客中介绍和探讨 SwiftUI、SwiftData
以及几个我比较感兴趣的新框架 TipKit 和 CKSyncEngine。

# 健康笔记 2.0 开发随笔（五）

一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同 iOS 14 中的各种 Bug
和异常斗智斗勇。

本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊 iOS 14、Xcode 12 以及 SwiftUI 2.0
的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。

## Bug 实在多

2020 年苹果想在软件架构层面做出非常多的重要改变。big sur 要支持 Arm，SwiftUI 要真正做到一套代码顺利的多平台运行，iOS 14
也作出了在近几年肉眼可见的最大变化。不过可能是目标太多、太大，而时间又紧，至少到现在为止，bug
层出不穷，改不胜改。尤其是随着版本的升级，竟然出现了不少前面完全不曾出现的 bug，实在是令人心烦。

比如在 iOS 14.2 beta 2 中， `sheet` 的 Delegate 无法响应，而在之前的所有版本都没有问题。在 iOS 1 4.2
beta 2 中，View 的刷新时机有和之前有了细微的变化，在一些及特殊的情况下会出现刷新不同步。总之类似的错误一直在增加。

对于 `@FetchRequest` 中的数据进行修改，View 不会自动更新，尽管 14.2 对于 List
做了修复，但在其他情况下，还是需要人为干预。

`@FetechRequest` 的数据进行增减时，有时会有动画，有时没有动画。同样的代码，在不同的地方，有时会有动画，有时没有动画，而这些都是在
SwiftUI 1.0 版本都不曾出现的问题。

在 macOS 下通过 catalyst 运行 App 时，总是会出现假死情况（系统 cup 占用为 0，就是 app 没有响应）。

Xcode 12 各种现实异常，这两天出现了一个异常奇怪的现象，当我编辑 `xcdatamodeld`
文件时，屏幕上出现了一篇白色区域遮盖了数据编辑区，我只能盲操作。而编辑其他任何文件都没有这种情况。

Xcode 12 的代码补全远不如 Xcode 11，总是补全后需要删除大量无用的补全信息。

`fileImporter` 竟然不能通过手势取消，如果使用手势，会反复弹出 `sheet` ，除非你点击右上角的 `cancel` 。

Menu（SwiftUI 新增的控件） 在被键盘遮挡后会出现异常，所以我目前只能把 Menu 放置在屏幕的上方

ContextMenu 点选后总要闪烁一下，让人很不舒服。

在 SwiftUI 2
中，对于键盘的自动避让本来是一个相当不错的设计，但总会导致大量的布局受键盘浮动的影响，反倒需要做更多的工作来避免这种情况，结果是好的想法但实现起来适得其反。

Xcode 12 的 Debug 区域会丢失，可以通过快捷键重新唤出。而且莫名其妙的总是默认不显示右侧的 Debug Output 窗口。

上面所说的都是最近让我特别心烦的一些 bug，其他的实在是太多，就不一一例举了。

bug 过多的结果就是导致我需要花费大量的时间来了判断是我自己的实现错误还是由于系统的 bug 导致的。如果确定是 bug，还需要写不少的 feedback
给苹果，希望它能尽快修复。对于时间的浪费是十分巨大的。

为了判断是什么原因导致的，我目前在 mac 上安装了两个版本的 big sur（最新版、次新版），三个版本的 Xcode (11.7,12.01,12.2
beta 2), 两个运行不同版本的 iphone (14.2 beta 2,14.01), 两个模拟器（14.2，14.01）。总之有够花费精力的。

不过这也是在一个尚未完全成熟的架构下，在一个巨大变化的时间点进行开发所要付出的必要代价。

## 不小的进步

上面进行了不少的吐槽，下面我们来说说苹果在今年给我们带来的进步和改善。

### Xcode 12

preview 已经很成熟了，已经很少会出现崩溃或无法预览的情况。

在 project 嵌入 playground 非常方便，尤其是打开 Build Active Scheme 之后，可以在 playground
中直接使用第三方库。对于开发中进行试验测试提供了巨大的便利。

StoreKit 的模拟环境非常有用，极大的提高了开发应用内付费的效率。可以在不提交 app
并建立资费的情况下便完成和调试所有和收费相关代码。不过我目前发现 restore 好像没有回馈，不知道是我的使用方法不对还是就是没有提供。

全屏开发模式支持直接在一次放置模拟器，提高了屏幕使用率，而且有助于注意力的提升。

SwiftUI liftcycle 让跨平台开发更加便利。

### SwiftUI

onChange 是我对于今年 SwiftUI 改动最满意的地方。在 onChange 中的代码运行时机和 View 的 update
一直，基本可以保证正确的响应时机。

新的 DatePicker 在 iOS 上节省了显示的空间，让 form 更紧凑。不过选择后出现的闪烁还表示有进一步优化的空间

众多的新控件。进过我在本次开发中并没有使用太多的新控件，不过更多的选择还是有利于开发者的。

我目前最多使用的新控件有： toolbar menu lazyStack lazyGrid

在 DSL 中支持更复杂的逻辑判断。由于目前支持了 if let, switch 可以在 DSL 中用更少的代码实现更清晰的逻辑处理。

对于复杂的 DSL 的编译能力也有了提高

### Big Sur

随着测试版本的不断提高，catalyst 对于 SwiftUI 的支持越来越好。在最初的版本中，基本还是利用 appkit 的控件来代替 uikit
的控件，在目前的 beta 9 下，显示效果已经和 ipad 上相差无几。只是用 SwiftUI + catalyst 来开发 mac app
已经越来越有可能。

## 测试征集

健康笔记 2.0 目前已经到了收尾阶段，除了图表部分之外，大多数的功能都已完成。我正在申请 test flight 的 beta
测试。如果你有兴趣进行测试，请将你的邮箱发送给我。

健康笔记 2.0 需要运行在 iOS 14 以上的设备。

# SwiftUI TextField 进阶 —— 事件、焦点、键盘

本文将探讨涉及 SwiftUI TextField 的事件、焦点切换、键盘设置等相关的经验、技巧和注意事项。

## 事件

### onEditingChanged

当 TextField 获得焦点时（进入可编辑状态）， `onEditingChanged` 将调用给定的方法并传递 `true` 值；当
TextField 失去焦点时，再次调用方法并传递 `false` 。

    struct OnEditingChangedDemo:View{
        @State var name = ""
        var body: some View{
            List{
                TextField("name:",text:$name,onEditingChanged: getFocus)
            }
        }

        func getFocus(focused:Bool) {
            print("get focus:\(focused ? "true" : "false")")
        }
    }

该参数的名称容易让使用者产生歧义， **不要使用`onEditingChanged` 判断用户是否输入了内容 ** 。

在 iOS 15 中，新增的支持 ParseableFormatStyle 的构造方法不提供该参数，因此对于使用新 Formatter 的
TextField 需要使用其他的手段来判断是否获得或失去焦点。

### onCommit

当用户在输入过程中按下（或点击） `return` 键时触发 onCommit（无法通过代码模拟触发）。 **如果用户没有点击`return`
键（比如直接切换至其他的 TextField），将不会触发 onCommit ** 。触发 onCommit 的同时，TextField 也将失去焦点。

    struct OnCommitDemo:View{
        @State var name = ""
        var body: some View{
            List{
                TextField("name:",text: $name,onCommit: {print("commit")})
            }
        }
    }

如果你需要在用户输入后对用户的录入内容进行判断，最好结合 onCommit 和 onEdtingChanged
一起来处理。如果想实时的对用户的录入数据进行处理，请参阅 [ SwiftUI TextField 进阶——格式与校验
](/zh/posts/textfield-1/) 。

onCommit 对 SecureField 同样适用。

在 iOS 15 中，新增的支持 ParseableFormatStyle 的构造方法不提供该参数，可以使用新增的 onSubmit 来实现同样效果。

### onSubmit

onSubmit 是 SwiftUI 3.0 的新增功能。onCommit 和 onEditingChanged 是每个 TextField
对自身状态的描述，onSubmit 则可以从更高的角度对视图中多个 TextField 进行统一管理和调度。

    // onSubmit 的定义
    extension View {
        public func onSubmit(of triggers: SubmitTriggers = .text, _ action: @escaping (() -> Void)) -> some View
    }

下面的代码将实现同上面 onCommit 一样的行为：

    struct OnSubmitDemo:View{
        @State var name = ""
        var body: some View{
            List{
                TextField("name:",text: $name)
                    .onSubmit {
                        print("commit")
                    }
            }
        }
    }

onSubmit 的触发条件同 onCommit 一致，需要用户主动点击 `return` 。

onSubmit 同样适用于 SecureField。

#### 作用域及嵌套

onSubmit 背后的是通过设置环境值 `TriggerSubmitAction` （尚未对开发者开放）来实现的，因此 onSubmit
是有作用域范围的（可在视图树向上传递），且可嵌套。

    struct OnSubmitDemo: View {
        @State var text1 = ""
        @State var text2 = ""
        @State var text3 = ""
        var body: some View {
            Form {
                Group {
                    TextField("text1", text: $text1)
                        .onSubmit { print("text1 commit") }
                    TextField("text2", text: $text2)
                        .onSubmit { print("text2 commit") }
                }
                .onSubmit { print("textfield in group commit") }
                TextField("text3", text: $text3)
                    .onSubmit { print("text3 commit") }
            }
            .onSubmit { print("textfield in form commit1") }
            .onSubmit { print("textfield in form commit2") }
        }
    }

当 TextField（text 1） commit 时，控制台输出为

Shell

Copy code

Copied!

    textfield in form commit2
    textfield in form commit1
    textfield in group commit
    text1 commit

请注意， **调用的顺序是从外层向内的** 。

#### 限定作用域

可以使用 `submitScope` 阻断作用域（限制在视图树上进一步传递）。比如，上面的代码中，在 Group 后面添加 `submitScope`

                Group {
                    TextField("text1", text: $text1)
                        .onSubmit { print("text1 commit") }
                    TextField("text2", text: $text2)
                        .onSubmit { print("text2 commit") }
                }
                .submitScope()  // 阻断作用域
                .onSubmit { print("textfield in group commit") }

当 TextField 1 commit 时，控制台输出为

Shell

Copy code

Copied!

    text1 commit

此时 onSubmit 的作用域将被限定在 Group 之内。

当视图中有多个 TextField 时，通过 onSubmit 和 FocusState（下文介绍）的结合，可以给用户带来非常好的使用体验。

#### 对 searchable 的支持

iOS 15 新增的搜索框在点击 `return` 时同样会触发 onSubmit，不过需要将 triggers 设置为 search：

    struct OnSubmitForSearchableDemo:View{
        @State var name = ""
        @State var searchText = ""
        var body: some View{
            NavigationView{
                Form{
                    TextField("name:",text:$name)
                        .onSubmit {print("textField commit")}
                }
                .searchable(text: $searchText)
                .onSubmit(of: .search) { //
                    print("searchField commit")
                }
            }
        }
    }

需要注意的是，SubmitTriggers 为 **OptionSet** 类型，onSubmit 对于 `SubmitTriggers`
内包含的值会通过环境在视图树中持续传递。当接受到的 `SubmitTriggers` 值不包含在 onSubmit 设置的 `SubmitTriggers` 时，传递将终止。简单的说， `onSubmit(of:.search)` 将阻断 TextFiled 产生的
commit 状态。反之亦然。

例如，上面的代码，如果我们在 searchable 后面再添加一个 `onSubmt(of:.text)` , 将无法对 TextField 的
commit 事件进行响应。

                .searchable(text: $searchText)
                .onSubmit(of: .search) {
                    print("searchField commit1")
                }
                .onSubmit {print("textField commit")} //无法触发，被 search 阻断

因此当同时对 TextFiled 以及搜索框做处理时，需要特别注意它们之间的调用顺序。

可以通过如下代码在一个 onSubmit 中同时支持 TextField 和搜索框：

    .onSubmit(of: [.text, .search]) {
      print("Something has been submitted")
    }

下面代码由于 `onSubmit(of:search)` 被放置在 `searchable` 之前也一样不会触发。

            NavigationView{
                Form{
                    TextField("name:",text:$name)
                        .onSubmit {print("textField commit")}
                }
                .onSubmit(of: .search) { // 不会触发
                    print("searchField commit1")
                }
                .searchable(text: $searchText)
            }

## 焦点

在 iOS 15 / macOS Moterey 之前，SwiftUI 没有为 TextField 提供获得焦点的方法（例如： `becomeFirstResponder` ），因此在相当长的时间里，开发者只能通过非 SwiftUI 的方式来实现类似的功能。

在 SwiftUI 3.0 中，苹果为开发者提供了一个远好于预期的解决方案，同 onSubmit 类似，可以从更高的视图层次来统一对视图中的
TextField 进行焦点的判断和管理。

### 基础用法

SwiftUI 提供了一个新的 FocusState 属性包装器，用来帮助我们判断该视图内的 TextField 是否获得焦点。通过 `focused`
将 `FocusState` 与特定的 TextField 关联起来。

    struct OnFocusDemo:View{
        @FocusState var isNameFocused:Bool
        @State var name = ""
        var body: some View{
            List{
                TextField("name:",text:$name)
                    .focused($isNameFocused)
            }
            .onChange(of:isNameFocused){ value in
                print(value)
            }
        }
    }

上面的代码将在 TextField 获得焦点时将 `isNameFocused` 设置为 `true` ，失去焦点时设置为 `false` 。

对于同一个视图中的多个 TextField，你可以创建多个 FocusState 来分别关联对应的 TextField，例如：

    struct OnFocusDemo:View{
        @FocusState var isNameFocused:Bool
        @FocusState var isPasswordFocused:Bool
        @State var name = ""
        @State var password = ""
        var body: some View{
            List{
                TextField("name:",text:$name)
                    .focused($isNameFocused)
                SecureField("password:",text:$password)
                    .focused($isPasswordFocused)
            }
            .onChange(of:isNameFocused){ value in
                print(value)
            }
            .onChange(of:isPasswordFocused){ value in
                print(value)
            }
        }
    }

上述方法当视图中拥有更多的 TextField 时将变得很麻烦，而且不利于统一管理。好在，FocusState
不仅支持布尔值，还支持任何哈希类型。我们可以使用符合 Hashable 协议的枚举来统一管理视图中多个 TextField
的焦点。下面的代码将实现同上面一样的功能：

    struct OnFocusDemo:View{
        @FocusState var focus:FocusedField?
        @State var name = ""
        @State var password = ""
        var body: some View{
            List{
                TextField("name:",text:$name)
                    .focused($focus, equals: .name)
                SecureField("password:",text:$password)
                    .focused($focus,equals: .password)
            }
            .onChange(of: focus, perform: {print($0)})
        }

        enum FocusedField:Hashable{
            case name,password
        }
    }

### 显示视图后立刻让指定 TextField 获得焦点

通过 FocusState，可以方便的实现在视图显示后，立刻让指定的 TextField 获得焦点并弹出键盘：

    struct OnFocusDemo:View{
        @FocusState var focus:FocusedField?
        @State var name = ""
        @State var password = ""
        var body: some View{
            List{
                TextField("name:",text:$name)
                    .focused($focus, equals: .name)
                SecureField("password:",text:$password)
                    .focused($focus,equals: .password)
            }
            .onAppear{
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5){
                    focus = .name
                }
            }
        }

        enum FocusedField:Hashable{
            case name,password
        }
    }

在视图初始化阶段赋值是无效的。即使 **在`onAppear` 中，也必须要有一定延时才能让 TextField 焦点 ** 。

### 在多个的 TextFiled 之间切换焦点

通过使用 focused 和 onSubmit 的结合，我们可以实现当用户在一个 TextField 中输入完成后（点击 `return`
），自动让焦点切换到下一个 TextField 的效果。

    struct OnFocusDemo:View{
        @FocusState var focus:FocusedField?
        @State var name = ""
        @State var email = ""
        @State var phoneNumber = ""
        var body: some View{
            List{
                TextField("Name:",text:$name)
                    .focused($focus, equals: .name)
                    .onSubmit {
                        focus = .email
                    }
                TextField("Email:",text:$email)
                    .focused($focus,equals: .email)
                    .onSubmit {
                        focus = .phone
                    }
                TextField("PhoneNumber:",text:$phoneNumber)
                    .focused($focus, equals: .phone)
                    .onSubmit {
                        if !name.isEmpty && !email.isEmpty && !phoneNumber.isEmpty {
                            submit()
                        }
                    }
            }
        }

        private func submit(){
            // submit all infos
            print("submit")
        }

        enum FocusedField:Hashable{
            case name,email,phone
        }
    }

上述代码也可以利用 onSubmit 的传递特性变成如下的模样：

            List {
                TextField("Name:", text: $name)
                    .focused($focus, equals: .name)
                TextField("Email:", text: $email)
                    .focused($focus, equals: .email)
                TextField("PhoneNumber:", text: $phoneNumber)
                    .focused($focus, equals: .phone)
            }
            .onSubmit {
                switch focus {
                case .name:
                    focus = .email
                case .email:
                    focus = .phone
                case .phone:
                    if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {
                        submit()
                    }
                default:
                    break
                }
            }

结合设定的屏幕按钮（例如辅助键盘视图）或者快捷键，我们也可以让焦点向前改变或者跳转到其他特定的 TextField 上。

### 使用快捷键获得焦点

当一个视图中有多个 TextField（包括 SecureField）时，我们可以直接使用 `Tab` 键按顺序在 TextField 中切换焦点，但
SwiftUI 并没有直接提供使用快捷键让某个 TextField 获得焦点的功能。通过结合 `FocusState` 和 `keyboardShortcut` 可以在 iPadOS 和 MacOS 下获得这种能力。

创建支持快捷键绑定的 `focused` ：

    public extension View {
        func focused(_ condition: FocusState<Bool>.Binding, key: KeyEquivalent, modifiers: EventModifiers = .command) -> some View {
            focused(condition)
                .background(Button("") {
                    condition.wrappedValue = true
                }
                .keyboardShortcut(key, modifiers: modifiers)
                .hidden()
                )
        }

        func focused<Value>(_ binding: FocusState<Value>.Binding, equals value: Value, key: KeyEquivalent, modifiers: EventModifiers = .command) -> some View where Value: Hashable {
            focused(binding, equals: value)
                .background(Button("") {
                    binding.wrappedValue = value
                }
                .keyboardShortcut(key, modifiers: modifiers)
                .hidden()
                )
        }
    }

调用代码：

    struct ShortcutFocusDemo: View {
        @FocusState var focus: FouceField?
        @State private var email = ""
        @State private var address = ""
        var body: some View {
            Form {
                TextField("email", text: $email)
                    .focused($focus, equals: .email, key: "t")
                TextField("address", text: $address)
                    .focused($focus, equals: .address, key: "a", modifiers: [.command, .shift,.option])
            }
        }

        enum FouceField: Hashable {
            case email
            case address
        }
    }

当用户输入 ⌘ + T 时，负责 email 的 TextField 将获得焦点，用户输入 ⌘ + ⌥ + ⇧ + A 时，负责 address 的
TextField 获得焦点。

> 上述代码在 iPad 模拟器上运行效果不佳（有时无法激活），请使用真机测试。

### 创建自己的 onEditingChanged

判断单个 TextField 的焦点状态最佳选择仍是使用 `onEditingChanged` ，但对于某些无法使用 onEditingChanged
的场合（比如新的 Formatter），我们可以利用 FocusState 来实现类似的效果。

- 对单个 TextField 进行判断

  public extension View {
  func focused(\_ condition: FocusState<Bool>.Binding, onFocus: @escaping (Bool) -> Void) -> some View {
  focused(condition)
  .onChange(of: condition.wrappedValue) { value in
  onFocus(value == true)
  }
  }
  }

调用：

    struct onEditingChangedFocusVersion:View{
        @FocusState var focus:Bool
        @State var price = 0
        var body: some View{
            Form{
                TextField("Price:",value:$price,format: .number)
                    .focused($focus){ focused in
                        print(focused)
                    }
            }
        }
    }

- 对多个 TextField 进行判断

为了避免在 TextField 失去焦点后出现多次调用的情况，我们需要在视图层次保存上次获得焦点的 TextField 的 FocusState 值。

    public extension View {
        func storeLastFocus<Value: Hashable>(current: FocusState<Value?>.Binding, last: Binding<Value?>) -> some View {
            onChange(of: current.wrappedValue) { _ in
                if current.wrappedValue != last.wrappedValue {
                    last.wrappedValue = current.wrappedValue
                }
            }
        }

        func focused<Value>(_ binding: FocusState<Value>.Binding, equals value: Value, last: Value?, onFocus: @escaping (Bool) -> Void) -> some View where Value: Hashable {
            return focused(binding, equals: value)
                .onChange(of: binding.wrappedValue) { focusValue in
                    if focusValue == value {
                        onFocus(true)
                    } else if last == value { //只触发一次
                        onFocus(false)
                    }
                }
        }
    }

调用：

    struct OnFocusView: View {
        @FocusState private var focused: Focus?
        @State private var lastFocused: Focus?
        @State private var name = ""
        @State private var email = ""
        @State private var address = ""
        var body: some View {
            List {
                TextField("Name:", text: $name)
                    .focused($focused, equals: .name, last: lastFocused) {
                        print("name:", $0)
                    }
                TextField("Email:", text: $email)
                    .focused($focused, equals: .email, last: lastFocused) {
                        print("email:", $0)
                    }
                TextField("Address:", text: $address)
                    .focused($focused, equals: .address, last: lastFocused) {
                        print("address:", $0)
                    }
            }
            .storeLastFocus(current: $focused, last: $lastFocused) //保存上次的 focsed 值
        }

        enum Focus {
            case name, email, address
        }
    }

## 键盘

使用 TextField 不可避免的需要同软键盘打交道，本节将介绍几个同键盘有关例子。

### 键盘类型

在 iPhone 中，我们可以通过 `keyboardType` 来设定软键盘类型，方便用户的录入或限制录入字符范围。

比如：

    struct KeyboardTypeDemo:View{
        @State var price:Double = 0
        var body: some View{
            Form{
                TextField("Price:",value:$price,format: .number.precision(.fractionLength(2)))
                    .keyboardType(.decimalPad) //支持小数点的数字键盘
            }
        }
    }

![image-20211020184520202](https://cdn.fatbobman.com/image-20211020184520202.png)

目前支持的键盘类型共有 11 种，分别为：

- asciiCapable

ASCII 字符键盘

- numbersAndPunctuation

数字及标点符号

- URL

便于输入 URL，包含字符和 `.` 、 `/` 、 `.com`

- numberPad

使用区域设置的数字键盘（0-9、۰-۹、०-९ 等）。适用于正整数或 PIN

- phonePad

数字及其他电话中使用的符号，如 `*#+`

- namePhonePad

方便录入文字及电话号码。字符状态同 asciiCapable 类似，数字状态同 numberPad 类似

- emailAddress

便于录入 `@.` 的 assiiCapable 键盘

- decimalPad

包含小数点的 numberPad，具体见上图

- twitter

包含 `@#` 的 asciiCapable 键盘

- webSearch

包含 `.` 的 asciiCapable 键盘， `return` 键标记为 `go`

- asciiCapableNumberPad

包含数字的 asciiCapable 键盘

尽管苹果预置了不少键盘模式可以选择，不过在某些情况下仍无法满足使用的需要。

比如：numberPad、decimalPad 没有 `-` 及 `return` 。在 SwiftUI 3.0
之前，我们必须在主视图上另外绘制或者使用非 SwiftUI 的方式来解决问题，在 SwiftUI 3.0
中，由于添加了原生设置键盘辅助视图（下文具体介绍）的功能，解决上述问题将不再困难。

### 通过 TextContentType 获得建议

在使用某些 iOS app 时，在录入文字时会在软键盘上方自动提示我们需要输入的内容，比如电话、邮件、验证码等等。这些都是使用 `textContentType` 得到的效果。

通过给 TextField 设定 UITextContentType，系统在输入时智能地推断出可能想要录入的内容，并显示提示。

下面的代码在录入密码时，将允许使用钥匙串：

    struct KeyboardTypeDemo: View {
        @State var password = ""
        var body: some View {
            Form {
                SecureField("", text: $password)
                    .textContentType(.password)
            }
        }
    }

![image-20211020192033318](https://cdn.fatbobman.com/image-20211020192033318.png)

下面的代码在录入邮箱地址时，将从你的通讯录和邮件中查找相似的地址予以提示：

    struct KeyboardTypeDemo: View {
        @State var email = ""
        var body: some View {
            Form {
                TextField("", text: $email)
                    .textContentType(.emailAddress)
            }
        }
    }

![image-20211020193117256](https://cdn.fatbobman.com/image-20211020193117256.png)

可以设定的 UITextContentType 种类有很多，其中使用的比较多的有：

- password
- 姓名的选项，如：name、givenName、middleName 等等
- 地址选项，如 addressCity、fullStreetAddress、postalCode 等等
- telephoneNumber
- emailAddress
- oneTimeCode（验证码）

> 测试 `textContentType` 最好在真机上进行，模拟器不支持某些项目或者没有足够的信息提供。

### 取消键盘

有些情况下，在用户输入完毕后，我们需要取消软键盘的显示，以便留出更大的显示空间。某些键盘类型并没有 `return`
按键，因此我们需要使用编程的方式让键盘消失。

另外，有时候为了提高交互体验，我们可以希望用户在录入结束后，无需点击 `return`
按键，通过点击屏幕其他区域或者以滚动列表的方式来取消键盘。同样也需要使用编程的方式让键盘消失。

- 使用 FocusState 取消键盘

如果为 TextField 设置了对应的 FocusState，通过将该值设置为 `false` 或 `nil` 即可取消键盘

    struct HideKeyboardView: View {
        @State private var name = ""
        @FocusState private var nameIsFocused: Bool

        var body: some View {
            Form {
                TextField("Enter your name", text: $name)
                    .focused($nameIsFocused)

                Button("dismiss Keyboard") {
                    nameIsFocused = false
                }
            }
        }
    }

- 其他情况

更多的情况下，我们可以直接通过 UIkit 提供的方法来取消键盘

    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)

例如下面的代码将在用户对视图进行拖拽时取消键盘：

    struct ResignKeyboardOnDragGesture: ViewModifier {
        var gesture = DragGesture().onChanged { _ in
            UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
        }

        func body(content: Content) -> some View {
            content.gesture(gesture)
        }
    }

    extension View {
        func dismissKeyboard() -> some View {
            return modifier(ResignKeyboardOnDragGesture())
        }
    }

    struct HideKeyboardView: View {
        @State private var name = ""
        var body: some View {
            Form {
                TextField("Enter your name", text: $name)
            }
            .dismissKeyboard()
        }
    }

### 键盘辅助视图

#### 通过 toolbar 创建

在 SwiftUI 3.0 中，我们可以通过 `ToolbarItem(placement: .keyboard, content: View)`
来自创建键盘的辅助视图（inputAccessoryView）。

通过输入辅助视图，可以解决很多之前难以应对的问题，并为交互提供更多的手段。

下面的代码将为输入浮点数时添加正负转换以及确认按钮：

    import Introspect
    struct ToolbarKeyboardDemo: View {
        @State var price = ""
        var body: some View {
            Form {
                TextField("Price:", text: $price)
                    .keyboardType(.decimalPad)
                    .toolbar {
                        ToolbarItem(placement: .keyboard) {
                            HStack {
                                Button("-/+") {
                                    if price.hasPrefix("-") {
                                        price.removeFirst()
                                    } else {
                                        price = "-" + price
                                    }
                                }
                                .buttonStyle(.bordered)
                                Spacer()
                                Button("Finish") {
                                    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
                                    // do something
                                }
                                .buttonStyle(.bordered)
                            }
                            .padding(.horizontal, 30)
                        }
                    }
            }
        }
    }

![image-20211020202404796](https://cdn.fatbobman.com/image-20211020202404796.png)

遗憾的时，通过 ToolbarItem 设置输入辅助视图目前还有以下不足：

- 显示内容受限

高度固定，且无法利用辅助视图的完整显示区域。同其他类型的 Toolbar 类似，SwiftUI 会干预内容的排版。

- 无法对同一视图中多个 TextField 分别设定辅助视图

在 ToolbarItem 中无法使用稍微复杂一点的判断语法。如果分别对不同的 TextField 进行设定，SwiftUI 会将所有的内容合并起来显示。

> 目前 SwiftUI 对 toolbar 内容的干预和处理有些过头。初衷是好的，帮助开发者更轻松的组织按钮且自动针对不同平台优化并最佳显示效果。但
> toolbar 及 ToolbarItem 的 ResultBuilder 的限制太多，无法在其中进行更复杂的逻辑判断。将键盘辅助视图集成到
> toolbar 的逻辑中也有些令人令人费解。

#### 通过 UIKit 创建

当前阶段，通过 UIKit 来创建键盘辅助视图仍是 SwiftUI 下的最优方案。不仅可以获得完全的视图显示控制能力，并且可以对同一视图下的多个
TextField 进行分别设置。

    extension UIView {
        func constrainEdges(to other: UIView) {
            translatesAutoresizingMaskIntoConstraints = false
            NSLayoutConstraint.activate([
                leadingAnchor.constraint(equalTo: other.leadingAnchor),
                trailingAnchor.constraint(equalTo: other.trailingAnchor),
                topAnchor.constraint(equalTo: other.topAnchor),
                bottomAnchor.constraint(equalTo: other.bottomAnchor),
            ])
        }
    }

    extension View {
        func inputAccessoryView<Content: View>(@ViewBuilder content: @escaping () -> Content) -> some View {
            introspectTextField { td in
                let viewController = UIHostingController(rootView: content())
                viewController.view.constrainEdges(to: viewController.view)
                td.inputAccessoryView = viewController.view
            }
        }

        func inputAccessoryView<Content: View>(content: Content) -> some View {
            introspectTextField { td in
                let viewController = UIHostingController(rootView: content)
                viewController.view.constrainEdges(to: viewController.view)
                td.inputAccessoryView = viewController.view
            }
        }
    }

调用：

    struct OnFocusDemo: View {
        @FocusState var focus: FocusedField?
        @State var name = ""
        @State var email = ""
        @State var phoneNumber = ""
        var body: some View {
            Form {
                TextField("Name:", text: $name)
                    .focused($focus, equals: .name)
                    .inputAccessoryView(content: accessoryView(focus: .name))

                TextField("Email:", text: $email)
                    .focused($focus, equals: .email)
                    .inputAccessoryView(content: accessoryView(focus: .email))

                TextField("PhoneNumber:", text: $phoneNumber)
                    .focused($focus, equals: .phone)
            }
            .onSubmit {
                switch focus {
                case .name:
                    focus = .email
                case .email:
                    focus = .phone
                case .phone:
                    if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {}
                default:
                    break
                }
            }
        }
    }

    struct accessoryView: View {
        let focus: FocusedField?
        var body: some View {
            switch focus {
            case .name:
                Button("name") {}.padding(.vertical, 10)
            case .email:
                Button("email") {}.padding(.vertical, 10)
            default:
                EmptyView()
            }
        }
    }

> 到 SwfitUI 3.0 时，TextField 的自动避让（keyboard avoid）已经很成熟了。在不同的视图种类（例如
> List、Form、ScrollView）中，或使用辅助视图、textContentType 的情况下都可以避免遮挡正在输入的
> TextField。如果抬升的高度能再高一点或许效果会更好，现在略显局促。

### 自定义 SubmitLabel

默认情况下，TextField（SecureField）在键盘上对应的 submit 行为按钮为 `return` ，通过使用 SwiftUI 3.0
中新增了 `submitLabel` 修饰器，我们可以将 `return` 按钮修改成更符合输入上下文的显示文字。

    TextField("Username", text: $username)
                .submitLabel(.next)

![image-20211021070740662](https://cdn.fatbobman.com/image-20211021070740662.png)

目前支持的种类有：

- continue
- done
- go
- join
- next
- return
- route
- search
- send

例如之前的代码中，我们可以分别为 `name` 、 `email` 、 `phoneNumber` 设定不同的对应显示：

                TextField("Name:", text: $name)
                    .focused($focus, equals: .name)
                    .submitLabel(.next)

                TextField("Email:", text: $email)
                    .focused($focus, equals: .email)
                    .submitLabel(.next)

                TextField("PhoneNumber:", text: $phoneNumber)
                    .focused($focus, equals: .phone)
                    .submitLabel(.return)

## 总结

从 SwiftUI 1.0 开始，苹果持续不断地完善 TextField 的功能。在 3.0 版本中，SwiftUI 不仅提供了更多的原生修饰器，而且提供了
FocusState、onSubmit 此类的统合管理逻辑。相信再有 2-3 年，SwiftUI 的主要控件的原生功能就可以比肩对应的 UIKit 控件了。

关于如何对 TextField 的显示做更多的定制，之后会撰文探讨。

# SwiftUI geometryGroup() 指南：从原理到实践

在 WWDC 2023 中，苹果为 SwiftUI
添加了一个新的修饰器：geometryGroup()。它可以解决一些之前无法处理或处理起来比较困难的动画异常。本文将介绍 geometryGroup()
的概念、用法，以及在低版本 SwiftUI 中，在不使用 geometryGroup() 的情况下如何处理异常。

## geometryGroup() 的官方定义

对于 geometryGroup()，苹果提供了一份详细但不易理解的 [ 文档
](https://developer.apple.com/documentation/swiftui/view/geometrygroup%28%29)
解释：

> **geometryGroup()** :
>
> Isolates the geometry (e.g. position and size) of the view from its parent
> view.
>
> By default SwiftUI views push position and size changes down through the
> view hierarchy, so that only views that draw something (known as leaf views)
> apply the current animation to their frame rectangle. However in some cases
> this coalescing behavior can give undesirable results; inserting a geometry
> group can correct that. A group acts as a barrier between the parent view
> and its subviews, forcing the position and size values to be resolved and
> animated by the parent, before being passed down to each subview.

> **geometryGroup()** :
>
> 将视图的几何属性（例如位置和大小）与其父视图隔离开来。
>
> 默认情况下，SwiftUI
> 视图会将位置和大小的变化沿视图层级向下传递，以至于只有绘制内容的视图（称为叶子视图）将当前动画应用到它们的框架矩形上。然而在某些情况下，这种聚合行为可能会导致不希望的结果；插入一个几何组可以纠正这种情况。几何组充当父视图与其子视图之间的屏障，迫使位置和大小的值由父视图解析和动画化，然后再传递给每个子视图。

    VStack {
        ForEach(items) { item in
            ItemView(item: item)
                .geometryGroup()
        }
    }

不知道你怎么看这个文档和附带的代码片段，至少在我初次接触时，很难通过它来理解 geometryGroup()
的真正用途。因为文档遗漏了最主要的部分：”然而在某些情况下，这种聚合行为可能会导致不希望的结果（ However in some cases this
coalescing behavior can give undesirable results ）”。

那么，具体在哪些情况下会发生这种情况呢？

## In Some Cases

为了更好地理解 geometryGroup()
的实际作用，我们需要创建一个因父视图的几何属性发生变化而导致的非预期的子视图呈现，以便弄清楚文档中的“在某些情况下”到底指的是什么情况。

    struct ContentView: View {
        @State var toggle = false
        var size: CGSize {
            toggle ? .init(width: 300, height: 300) : .init(width: 200, height: 200)
        }

        var body: some View {
            VStack {
                Button("Toggle") {
                    toggle.toggle()
                }
                TopLeadingTest1(show: toggle)
                    .frame(width: size.width, height: size.height)
                    .animation(.smooth(duration: 1), value: toggle)
            }
        }
    }

    struct TopLeadingTest1: View {
        let show: Bool
        var body: some View {
            Color.red
                .overlay(alignment: .topLeading) {
                    if show {
                        Circle()
                            .fill(.yellow)
                            .frame(width: 20, height: 20)
                    }
                }
        }
    }

这是一段非常简单的代码，当 `toggle` 的状态改变时， `TopLeadingTest1` 的尺寸会发生变化。同时（ `toggle`
状态改变时），我们还在 `TopLeadingTest1` （ 红色矩形）的 topLeading 位置，创建了一个黄色的圆形。

运行后，我们将获得如下的效果：

![https://cdn.fatbobman.com/geometryGroup-
demo1_2023-11-27_08.17.48.2023-11-27%2008_18_55.gif](https://cdn.fatbobman.com/geometryGroup-
demo1_2023-11-27_08.17.48.2023-11-27%2008_18_55.gif)

结果似乎是对的，又不完全正确。当 `toggle`
状态发生改变时，红色矩形按照预期以动画方式进行了缩放。黄色圆形最终也出现在红色矩形放大后的左上角位置。然而，这是否符合我们的预期效果呢？

我认为，对于许多开发者来说，他们更希望黄色的圆形能够像红色矩形一样，通过动画的方式从原始的 topLeading 位置移动到放大后的 topLeading
位置。

那么，geometryGroup() 能够帮助实现这个效果吗？

    var body: some View {
        VStack {
            Button("Toggle") {
                toggle.toggle()
            }
            TopLeadingTest1(show: toggle)
                .geometryGroup()  // add geometryGroup between TopLeadingTest and frame
                .frame(width: size.width, height: size.height)
                .animation(.smooth(duration: 1), value: toggle)
        }
    }

![https://cdn.fatbobman.com/geometryGroup-
demo2_2023-11-27_08.25.22.2023-11-27%2008_29_25.gif](https://cdn.fatbobman.com/geometryGroup-
demo2_2023-11-27_08.25.22.2023-11-27%2008_29_25.gif)

问题解决了。那么是什么导致了出现了非预期的结果，geometryGroup() 又是如何纠正了这一问题呢？

## 出现异常的原因

我们可以通过分析 `toggle` 状态发生改变后，每个视图的行为来查找原因。

- `toggle` 状态发生变化，由 false 变为 true。
- `.animation(.smooth(duration: 1), value: toggle)` 这行代码创建了一个包含本次状态变化对应动画信息（ `.smooth(duration: 1)` ）的 transaction，并将其沿着视图分支向下传播。
- `frame` 的设置进行了调整，尺寸从 200 x 200 变为 300 x 300。由于 transaction 包含了动画信息，因此这次改变是有动画效果的。
- `TopLeadingTest1` 根据从父视图 `frame` 接收到的建议尺寸变化，根据其默认布局形态（充满全部可用空间）改变了自身的大小。
- Shape（红色矩形）符合 Animatable 协议，在调整尺寸时，查看当前 transaction 并获取对应的动画信息（动画曲线函数），因此这次改变也是有动画效果的。
- 在 `overlay` 中，由于 `show` 的变化，将创建一个新的视图（ `if show` ）即黄色圆形。
- 当 SwiftUI 在 `overlay` 中布局黄色圆形时（ `topLeading` ），此时红色矩形的尺寸（尽管仍在以动画的形式逐渐扩大）已经是调整后的 300 x 300。
- SwiftUI 将黄色圆形放置在放大后的红色矩形的 `topLeading` 位置。
- 黄色圆形的默认过渡效果是 `opacity` ，在创建黄色圆形时，SwiftUI 检查当前 transaction 并获取当前的动画信息。
- 黄色圆形以渐变的方式出现在 300 x 300 的 `topLeading` 位置。

上述每个过程的执行都严格且完美地遵循了 SwiftUI
的布局和动画规则。唯一让我们不满意的是，在创建黄色圆形时（布局它的位置时），它被放置在放大后的红色矩形的 `topLeading` 位置上。

这是因为在 SwiftUI 中，每个可动画视图根据 transaction 中的信息自行决定自身的动画行为。在创建黄色圆形时，它无法获得状态改变前的 `topLeading` 位置信息，因此无法满足我们的要求。

> 本节涉及到 transaction 以及 SwiftUI 动画的一些内部运行机制。您可以阅读 [ 掌握 Transaction，实现 SwiftUI
> 动画的精准控制 ](/zh/posts/mastering-transaction/) 和 [ SwiftUI 的动画机制了解更多的内容
> ](/zh/posts/the_animation_mechanism_of_swiftui/) 。

## geometryGroup() 的作用

那么为什么添加了 geometryGroup() 后，问题就解决了呢？根据文档的描述：迫使位置和大小的值由父视图解析和动画化，然后再传递给每个子视图（
forcing the position and size values to be resolved and animated by the
parent, before being passed down to each subview）。

以上面的示例来说，在添加了 geometryGroup() 后，父视图（ `frame`
）并不是一次性的将自身几何属性的改变状态传递给了子视图，而是将这些变化动画化了后，持续传递给子视图的。

当创建黄色圆形时，即使 `show` 状态已改变，父视图（ `frame` ）仍会持续传递其当前的几何信息（
动画中）。这让黄色圆形能够获得正确的布局位置。因此，最终产生的结果就是，黄色圆形从我们预期的 200 x 200 的 `topLeading`
处，以动画的形式移动到了 300 x 300 的 `topLeading` 位置。

由此可见，geometryGroup() 中 Group 的含义为父视图统一处理并动画化其几何属性变化后，再传递给子视图。子视图不再各自独立处理上述信息。

## 出现 “Some Cases” 的条件

至此，我们就可以将官方文档中 “In some cases” 的条件补充完整：

- 父视图的几何属性发生改变，且改变是动画化的
- 在父视图改变的同时（ 几何属性的变化 ），子视图因此变化（ 几何信息或导致几何信息变化的状态变化）而创建了新的视图

换句话说，当子视图在父视图的几何属性发生变化时，如果子视图在自身中创建了新的视图，由于新视图无法获取到变化之前的几何信息，因此会导致布局出现意料之外的情况。

geometryGroup() 确保子视图在统一的几何信息环境中，以实现预期的布局效果。它为子视图提供了一个连续的几何信息更新过程。

总结上述条件后，我们就很容易创建出其它会导致意外行为的代码。

例如：

    struct DynamicGridTest1: View {
        var body: some View {
            GeometryReader { proxy in
                let count = Int(proxy.size.width / 50)
                Grid(horizontalSpacing: 0, verticalSpacing: 0) {
                    ForEach(0 ..< count, id: \.self) { _ in
                        GridRow {
                            ForEach(0 ..< count, id: \.self) { _ in
                                Rectangle()
                                    .fill(.blue)
                                    .border(.yellow, width: 2)
                                    .frame(width: 50, height: 50)
                            }
                        }
                    }
                }
            }
            .clipped()
        }
    }

    struct ContentView: View {
        @State var toggle = false
        var size: CGSize {
            toggle ? .init(width: 300, height: 300) : .init(width: 200, height: 200)
        }

        var body: some View {
            VStack {
                Button("Toggle") {
                    toggle.toggle()
                }
                ZStack(alignment: .bottomTrailing) {
                    Color.green.frame(width: 300, height: 300)
                    DynamicGridTest1()
                        .frame(width: size.width, height: size.height)
                        .animation(.smooth(duration: 1), value: toggle)
                }
            }
        }
    }

![https://cdn.fatbobman.com/geometryGroup-
demo3_2023-11-27_09.48.31.2023-11-27%2009_49_04.gif](https://cdn.fatbobman.com/geometryGroup-
demo3_2023-11-27_09.48.31.2023-11-27%2009_49_04.gif)

当 `frame` （父视图）的尺寸发生变化后，GeometryReader 所获得的尺寸也会相应地改变。新创建的 Grid
单元格会直接放置在尺寸变化后的位置。因此会导致出现非预期的结果。

在添加了 geometryGroup() 后。

    DynamicGridTest1()
        .geometryGroup()
        .frame(width: size.width, height: size.height)

![https://cdn.fatbobman.com/geometryGroup-
demo4_2023-11-27_09.52.07.2023-11-27%2009_53_12.gif](https://cdn.fatbobman.com/geometryGroup-
demo4_2023-11-27_09.52.07.2023-11-27%2009_53_12.gif)

新创建的单元格将根据父视图持续传递进来的几何信息，获得正确的布局位置。

## 老版本 SwiftUI 该怎么办

只要我们能破坏 “Some Cases” 的构成条件，就能避免类似的非预期行为。

- 在父视图几何信息发生变化时，不要同时在子视图中创建新的内容
- 如果一定要在变化时为子视图增加新元素（ 比如上面基于 GeometryReader 的示例，可以将所需元素在父视图变化前便让其存在，通过透明度来调整其可见性 ）

例如，在较低版本的 SwiftUI 中，我们可以修改上面的示例一的代码，以避免出现非预期的行为：

    struct TopLeadingTest2: View {
        let show: Bool
        var body: some View {
            Color.red
                .overlay(alignment: .topLeading) {
                    Circle()
                        .fill(.yellow)
                        .frame(width: 20, height: 20)
                        .opacity(show ? 1 : 0)  // change visibilty by opacity
                }
        }
    }

示例二修改起来稍微麻烦一些，但原理也是一样的：

    struct DynamicGridTest2: View {
        private let max = 20
        var body: some View {
            Color.clear
                .overlay(alignment: .topLeading) {
                    GeometryReader { proxy in
                        let count = Int(proxy.size.width / 50)
                        Grid(horizontalSpacing: 0, verticalSpacing: 0) {
                            ForEach(0 ..< max, id: \.self) { r in
                                GridRow {
                                    ForEach(0 ..< max, id: \.self) { c in
                                        Rectangle()
                                            .fill(.blue)
                                            .border(.yellow, width: 2)
                                            .frame(width: 50, height: 50)
                                            .opacity((r >= count || c >= count) ? 0 : 1)
                                    }
                                }
                            }
                        }
                    }
                }
                .clipped()
        }
    }

### Update：transformEffect (. identity)

在 Reddit 上， [ Ne1nLives 给我提供了一个新的解决方案
](https://www.reddit.com/r/SwiftUI/comments/1870wct/comment/kbsn6x7/?utm_source=share&utm_medium=web2x&context=3)
：在低版本的 SwiftUI 中，可以使用 `transformEffect(.identity)` 来实现与 `geometryGroup`
类似的效果。

    DynamicGridTest1()
        .transformEffect(.identity) // keep the original geometry information
        .frame(width: size.width, height: size.height)

`transformEffect(.identity)`
实际上是对视图施加了一个“无变换”的变换。这样做不会改变视图的视觉表现，但可能会影响其在视图层级中的行为。

举个例子，在本文提供的示例代码中，当应用 `.transformEffect(.identity)`
时，其作用是让子视图的布局和位置在状态变化的第一时间保持不变。这相当于为新创建的视图（ 在状态变化时创建 ）提供了父视图的原始几何信息。由于子视图仍然会根据
transaction 中的信息进行动画，因此，我们会看到其呈现的效果与 `geometryGroup` 几乎一致。

虽然 `.transformEffect(.identity)` 可以在一些特定场景下模拟 `geometryGroup()`
的某些效果，但它不是一个全面的替代方案。

`geometryGroup` 的一个关键功能是创建一个边界，这个边界在父视图和子视图之间隔离了视图的几何属性，如位置和大小。这意味着，通过 `geometryGroup()` ，子视图的布局和动画可以独立于父视图进行处理。

因此， `geometryGroup()` 适用于处理更复杂和特定的布局隔离和动画协调场景，而 `.transformEffect(.identity)` 更多是在特定情况下保持子视图布局稳定性的一种策略。

## 小插曲

在写这篇文章时，我创建了一个更加简单的代码，结果也出现了非预期的呈现。

    struct TextTest1: View {
        let toggle: Bool
        var body: some View {
            Text(toggle ? "Hello" : "World")
        }
    }

    struct ContentView: View {
        @State var toggle = false
        var size: CGSize {
            toggle ? .init(width: 300, height: 300) : .init(width: 200, height: 200)
        }

        var body: some View {
            VStack {
                Button("Toggle") {
                    toggle.toggle()
                }
                TextTest1(toggle: toggle)
                    .frame(width: size.width, height: size.height)
                    .animation(.smooth(duration: 1), value: toggle)
            }
        }
    }

![https://cdn.fatbobman.com/geometryGroup-
demo5_2023-11-27_10.10.26.2023-11-27%2010_11_10.gif](https://cdn.fatbobman.com/geometryGroup-
demo5_2023-11-27_10.10.26.2023-11-27%2010_11_10.gif)

这个问题是从 iOS 16 开始出现的，而在更低版本中，文字的位置是正常的。从代码来看， `Text(toggle ? "Hello" :
"World")` 应该能够保持一个视图标识的稳定（也就是不应该创建新的 Text）。然而，根据实际效果分析，很可能与 iOS 16 引入的 `contentTransition` 修饰器有关。在 SwiftUI 内部，将上述的三元运算符调整为类似以下代码的形式：

    if toggle {
        Text("Hello")
    } else {
        Text("World")
    }

在 iOS 17 中，我们可以通过 geometryGroup() 来避免上述问题。对于 iOS
16，在文字变化较多且较大的情况下，应尽量避免在父视图几何信息调整时切换文字内容。

## 总结

在本文中，我们深入探讨了 SwiftUI 中 geometryGroup() 的重要性和实用性。通过实际的示例，我们看到了 geometryGroup()
在处理复杂的视图层级和同步动画时的强大功能。它不仅提供了对动画和布局的精细控制，而且确保了视图之间的一致性和流畅性。在实际开发中，尤其是面对复杂动画和布局的场景时，理解并正确使用
geometryGroup() 是至关重要的。

geometryGroup() 为我们提供了一个避免在个别情况下出现布局异常的能力。这是 SwiftUI
开发团队在完成了基本的布局功能后，腾出精力，进一步改善细节的一个表现。同时，我们也希望苹果能够在官方文档中能够提供更加清晰示例，以提高开发者学习新 API
的效率。

# 掌握 TipKit：基础

TipKit 是苹果在 WWDC 2023
上新推出的一个框架，可轻松在你的应用程序中显示提示。它可用于向用户介绍新功能，帮助他们发现隐藏的选项或展示完成任务更快的途径等场景。TipKit
可以运行在苹果生态系统的不同硬件环境和操作系统上，包括 iPhone、iPad、Mac、Apple Watch 和 Apple TV。

开发者不仅可以通过设定规则、显示频次策略等方式控制 Tip 显示的时机和频率，还可以通过 API 获取 Tip 的状态以及与 Tip 绑定的事件等信息。尽管
TipKit 是以展示提示为主要目的而创建的框架，但其功能不限于此。

我将用两篇文章探讨 TipKit 框架。在本文中，我们首先学习 TipKit
的用法；在下篇中，我们将讨论更多使用技巧、注意事项、实现原理，以及在其他场景中使用 TipKit 等扩展话题。

## 如何定义一个 Tip

在 TipKit 中，定义一个 Tip 就是声明一个遵循 `Tip` 协议的结构体。 `Tip` 协议定义了用于 Tip
显示的标题、图像、信息以及用于判断是否满足出现条件的规则。

    struct InlineTip: Tip {
        var title: Text {
            Text("Save as a Favorite")
        }
        var message: Text? {
            Text("Your favorite backyards always appear at the top of the list.")
        }
        var image: Image? {
            Image(systemName: "star")
        }
    }

![https://cdn.fatbobman.com/image-20231015144407862.png](https://cdn.fatbobman.com/image-20231015144407862.png)

## 让 Tip 达到应有的效果

下图中的提示具备可操作性、有指导性并且易于记忆的特点，因此是推荐的提示展示方式。

![https://cdn.fatbobman.com/image-20231015120758303.png](https://cdn.fatbobman.com/image-20231015120758303.png)

以下是不适合使用 Tip 展示的信息：

- 促销信息
- 错误信息
- 没有操作性的信息
- 内容过于复杂，无法立即阅读的信息

![https://cdn.fatbobman.com/image-20231015120911856.png](https://cdn.fatbobman.com/image-20231015120911856.png)

## 初始化 Tip 容器

要让 TipKit 框架在应用中发挥作用，需要在第一个 Tip 出现的场景之前执行一次 Tip 容器的配置指令，通常会在应用的初始阶段进行。例如：

    import TipKit

    @main
    struct TipKitExamplesApp: App {
        init() {
          // Configure Tip's data container
          try? Tips.configure()
        }
        var body: some Scene {
            WindowGroup {
                ContentView()
            }
        }
    }

`Tips.configure` 用于初始化数据容器，在其中，TipKit 保存了 Tip 和与之相关的事件信息。并支持通过参数对 Tip
的全局显示频次策略进行调整（下文中详述）。

## 在 SwiftUI 视图中添加 Tip

TipKit 提供了两种 Tip 的显示方式：内联（ `TipView` ）和弹出窗口（ `popoverTip` ）。

> 苹果官方提供了展示 Tip 各种功能的 [ Demo
> ](https://developer.apple.com/documentation/tipkit/highlightingappfeatureswithtipkit)
> ，本文采用了该 Demo 提供的部分代码。

### 內联

通过 TipKit 提供的 `TipView` 视图，可以在视图中使用内联方式添加 Tip。苹果建议尽量采用这种风格来显示
Tip，以避免覆盖人们可能想要查看的内容，以及要与之交互的 UI 元素。

    struct InlineView: View {
        // Create an instance of your tip content.
        var tip = InlineTip()

        var body: some View {
            VStack(spacing: 20) {
                Text("A TipView embeds itself directly in the view. Make this style of tip your first choice as it doesn't obscure or hide any underlying UI elements.")

                // Place your tip near the feature you want to highlight.
                TipView(tip, arrowEdge: .bottom)
                Button {
                    // Invalidate the tip when someone uses the feature.
                    tip.invalidate(reason: .actionPerformed)
                } label: {
                    Label("Favorite", systemImage: "star")
                }

                Text("To dismiss the tip, tap the close button in the upper right-hand corner of the tip or tap the Favorite button to use the feature, which then invalidates the tip programmatically.")
                Spacer()
            }
            .padding()
            .navigationTitle("TipView")
        }
    }

![https://cdn.fatbobman.com/image-20231015150453850.png](https://cdn.fatbobman.com/image-20231015150453850.png)

在上面的代码中，我们首先在视图中创建一个 InlineTip 实例，然后将 `TipView` 放置在希望出现 Tip 的位置。开发者可以通过 `arrowEdge` 参数来设置箭头的指示方向，当设置为 `nil` 时，箭头将不显示。

`TipView` 与其他的 SwiftUI 视图没有什么不同，它以标准的 SwiftUI
视图的方式参与布局，并在显示时对原有的布局产生影响。换句话说，开发者可以将其放入任何布局容器中，并且可以对其应用各种视图修饰器。

    TipView(tip)
        .frame(width:250)
        .symbolRenderingMode(.multicolor)

![https://cdn.fatbobman.com/image-20231015153758052.png](https://cdn.fatbobman.com/image-20231015153758052.png)

### 弹出窗口

使用 `popoverTip` 视图修饰器，在视图中以顶层视图的方式来展示 Tip。

![https://cdn.fatbobman.com/tipkit-popoverTip-
demo-7341202.png](https://cdn.fatbobman.com/tipkit-popoverTip-
demo-7341202.png)

    struct PopoverTip: Tip {
        var title: Text {
            Text("Add an Effect")
                .foregroundStyle(.indigo)
        }
        var message: Text? {
            Text("Touch and hold \(Image(systemName: "wand.and.stars")) to add an effect to your favorite image.")
        }
    }

    struct PopoverView: View {
        // Create an instance of your tip content.
        var tip = PopoverTip()

        var body: some View {
            VStack(spacing: 20) {
                ....
                Image(systemName: "wand.and.stars")
                    .imageScale(.large)
                    // Add the popover to the feature you want to highlight.
                    .popoverTip(tip)
                    .onTapGesture {
                        // Invalidate the tip when someone uses the feature.
                        tip.invalidate(reason: .actionPerformed)
                    }
                ....
            }
        }
    }

![https://cdn.fatbobman.com/image-20231015154038009.png](https://cdn.fatbobman.com/image-20231015154038009.png)

可以通过 `arrowEdge` 调整 Tip 相对于其所应用的视图的摆放位置，不能将其设置为 `nil` ：

    .popoverTip(tip,arrowEdge: .leading)

![https://cdn.fatbobman.com/image-20231015154758785.png](https://cdn.fatbobman.com/image-20231015154758785.png)

在 iOS 下，弹出窗口将以模态视图的方式呈现，只有在关闭或隐藏 Tip 后才能与其他元素进行交互。另外，开发者无法对通过 `popoverTip`
弹出的 Tip 视图应用视图修饰器。

## 如何调整 Tip 外观

对于 TipKit 提供的 `TipView` 和 `popoverTip` ，我们可以通过以下方式来调整它的显示效果：

### 为 Text 和 Image 应用不改变其类型的修饰器

在不破坏 Text 和 Image 类型的前提下，我们可以采用适当的修饰器来改善文字和图片的显示效果。例如：

    struct InlineTip: Tip {
        var title: Text {
            Text("Save \(Image(systemName: "book.closed.fill")) as a Favorite")
        }
        var message: Text? {
            Text("Your ") +
            Text("favorite")
                .bold()
                .foregroundStyle(.red) +
            Text(" backyards always appear at the \(Text("top").textScale(.secondary)) of the list.")
        }
        var image: Image? {
            Image(systemName: "externaldrive.fill.badge.icloud")
                .symbolRenderingMode(.multicolor)
        }
    }

![https://cdn.fatbobman.com/image-20231015164840908.png](https://cdn.fatbobman.com/image-20231015164840908.png)

这种方法对于 `TipView` 和 `popoverTip` 两种展示视图都有效。

### 使用 TipView 特有的修饰器

    TipView(tip,arrowEdge: .bottom)
        .tipImageSize(.init(width: 30, height: 30))
        .tipCornerRadius(0)
        .tipBackground(.red)

![https://cdn.fatbobman.com/image-20231015165115831.png](https://cdn.fatbobman.com/image-20231015165115831.png)

这种方式仅对 `TipView` 有效。

可以将特有修饰器、标准视图修饰器，以及包含更多信息的 Text 和 Image 结合在一起使用。

### 使用 TipViewStyle 自定义 TipView 的外观

与许多 SwiftUI 组件一样，TipKit 同样为 `TipView` 提供了通过风格来自定义外观的功能。

    struct MyTipStyle: TipViewStyle {
        func makeBody(configuration: Configuration) -> some View {
            VStack {
                if let image = configuration.image {
                    image
                        .font(.title2)
                        .foregroundStyle(.green)
                }
                if let title = configuration.title {
                    title
                        .bold()
                        .font(.headline)
                        .textCase(.uppercase)
                }
                if let message = configuration.message {
                    message
                        .foregroundStyle(.secondary)
                }
            }
            .frame(maxWidth: .infinity)
            .backgroundStyle(.thinMaterial)
            .overlay(alignment: .topTrailing) {
                // Close Button
                Image(systemName: "multiply")
                    .font(.title2)
                    .alignmentGuide(.top) { $0[.top] - 5 }
                    .alignmentGuide(.trailing) { $0[.trailing] + 5 }
                    .foregroundStyle(.secondary)
                    .onTapGesture {
                        // Invalidate Reason
                        configuration.tip.invalidate(reason: .tipClosed)
                    }
            }
            .padding()
        }
    }

    TipView(tip, arrowEdge: .bottom)
        .tipViewStyle(MyTipStyle())

![https://cdn.fatbobman.com/image-20231015180721474.png](https://cdn.fatbobman.com/image-20231015180721474.png)

开发者可以选择不在自定义样式中添加关闭按钮，以阻止使用者通过该途径使提示失效。

> 此外，开发者还可以完全舍弃 _`TipView` 和 `popoverTip` _ ，通过响应 Tip 状态的方式实现对 Tip
> 展示方式的完全掌控（下篇文章中会详细介绍）。

## 为 Tip 添加 Action Button

到目前为止，我们创建的 Tip 都是纯展示性的。通过添加 actions，我们可以让 Tip 具备更强的可操作性，实现更多的交互功能。

    struct PasswordTip: Tip {
        var title: Text {
            Text("Need Help?")
        }
        var message: Text? {
            Text("Do you need help logging in to your account?")
        }
        var image: Image? {
            Image(systemName: "lock.shield")
        }
        var actions: [Action] {
            // Define a reset password button.
            Action(id: "reset-password", title: "Reset Password")
            // Define a FAQ button.
            Action(id: "faq", title: "View our FAQ")
        }
    }

    // In View
    struct PasswordResetView: View {
        @Environment(\.openURL) private var openURL

        // Create an instance of your tip content.
        private var tip = PasswordTip()

        var body: some View {
            VStack(spacing: 20) {
                Text("Use action buttons to link to more options. In this example, two actions buttons are provided. One takes the user to the Reset Password feature. The other sends them to an FAQ page.")

                // Place your tip near the feature you want to highlight.
                TipView(tip, arrowEdge: .bottom) { action in
                    // Define the closure that executes when someone presses the reset button.
                    if action.id == "reset-password", let url = URL(string: "https://iforgot.apple.com") {
                        openURL(url) { accepted in
                            print(accepted ? "Success Reset" : "Failure")
                        }
                    }
                    // Define the closure that executes when someone presses the FAQ button.
                    if action.id == "faq", let url = URL(string: "https://appleid.apple.com/faq") {
                        openURL(url) { accepted in
                            print(accepted ? "Success FAQ" : "Failure")
                        }
                    }
                }
                Button("Login") {}
                Spacer()
            }
            .padding()
            .navigationTitle("Password reset")
        }
    }

![https://cdn.fatbobman.com/tipkit-tip-with-action-
demo_2023-10-15_18.17.09.2023-10-15%2018_17_49.gif](https://cdn.fatbobman.com/tipkit-
tip-with-action-demo_2023-10-15_18.17.09.2023-10-15%2018_17_49.gif)

在上面的代码中，我们首先在 PasswordTip 中添加 Action 数据。其中，id 用于在回调闭包中识别不同的 Action 来源。

    var actions: [Action] {
        Action(id: "reset-password", title: "Reset Password")
        Action(id: "faq", title: "View our FAQ")
    }

在 Tip 协议中，actions 的定义为 `@Tips.OptionsBuilder var options: [TipOption] { get }` ，它是一个 Result builders，因此可以用上述方式合成并返回 Action 数组。

在视图中，通过在 `TipView` 后面添加闭包来判断 Action 的来源，并实现相应的操作。

    TipView(tip, arrowEdge: .bottom) { action in
        if action.id == "reset-password", let url = URL(string: "https://iforgot.apple.com") {
            openURL(url) { accepted in
                print(accepted ? "Success Reset" : "Failure")
            }
        }
        if action.id == "faq", let url = URL(string: "https://appleid.apple.com/faq") {
            openURL(url) { accepted in
                print(accepted ? "Success FAQ" : "Failure")
            }
        }
    }

`popoverTip` 也提供了支持 Action 的版本。

    .popoverTip(tip){ action in
       // ....
    }

在本例中，由于需要使用视图环境值提供的 `openURL` ，因此对 Action 的操作实现是在视图中进行的。如果不需要使用视图中的信息，可以直接在
Action 的定义中添加对应的操作代码。

    Action(id: "faq", title: "View our FAQ", perform: {
        if let url = URL(string: "https://appleid.apple.com/faq") {
            UIApplication.shared.open(url)
        }
    })

    TipView(tip, arrowEdge: .bottom)

## 为 Tip 制定显示规则

如果只是为了提供上文中提到的 Tip 视图模板，那么苹果就完全没有创建 TipKit 框架的必要。TipKit 框架的强大之处在于，开发者可以为每个 Tip
创建独立的规则，并应用该规则来决定是否显示 Tip。

规则用来判断显示与否的依据来源于某些状态（ 参数）或用户事件，因此我们首先需要在 Tip 类型中定义所需的参数和事件。

### 为 Tip 定义参数（ Parameter）

我们可以通过 `@Parameter` 宏，在 Tip 结构中定义一个变量，用来表示要跟踪的应用程序状态。

    struct ParameterRuleTip: Tip {
        // Define the app state you want to track.
        @Parameter
        static var isLoggedIn: Bool = false
    }

请注意，定义的状态是静态属性，是被该结构的所有实例所共享的。

通过展开宏，我们可以看到 `@Parameter` 生成的完整代码：

    static var $isLoggedIn: Tips.Parameter<Bool> = Tips.Parameter(Self.self, "isLoggedIn", false)
    static var isLoggedIn: Bool = false
    {
        get {
            $isLoggedIn.wrappedValue
        }

        set {
            $isLoggedIn.wrappedValue = newValue
        }
    }

`$isLoggedIn` 的类型是 `Tips.Parameter<Bool>` ，它提供了对 ParameterRuleTip.
isLoggedIn 的值进行持续化的能力。

> TipKit 为 @Parameter 提供了一个 `@Parameter(.transient)` 选项。在开启后，TipKit
> 将在应用重启时，使用 Tip 定义中提供的默认值而不使用持久化的值。与 Core Data 或 SwiftData 中的 `transient`
> 选项性质略有不同，在 TipKit 中，即使开启 `transient` 选项，数据仍会被持久化。这主要是为了方便在使用同一个 TipKit
> 数据源的不同应用和组件之间保持该参数的动态同步。

### 创建规则（Rule），根据状态决定是否显示提示（Tip）

现在，我们可以利用之前定义的 `isLoggedIn` 属性来创建规则，以判断是否满足显示 ParameterRuleTip 的条件。

    struct ParameterRuleTip: Tip {
        // Define the app state you want to track.
        @Parameter
        static var isLoggedIn: Bool = false

        var rules: [Rule] {
            [
                // Define a rule based on the app state.
                #Rule(Self.$isLoggedIn) {
                    // Set the conditions for when the tip displays.
                    $0 == true
                }
            ]
        }
        // ...
    }

`#Rule(Self.$isLoggedIn)` 表示该条规则将观察 `isLoggedIn` 属性，并将 `isLoggedIn`
作为参数传递到闭包中。

`#Rule` 也是一个宏，展开后会发现 TipKit 的规则是基于 Predicate 构建的。

    Tip.Rule(Self.$isLoggedIn) {
        PredicateExpressions.build_Equal(
            lhs: PredicateExpressions.build_Arg($0),
            rhs: PredicateExpressions.build_Arg(true)
        )
    }

在视图中，我们可以通过修改 `isLoggedIn` 的值来显示或隐藏 Tip：

    struct ParameterView: View {
        // Create an instance of your tip content.
        private var tip = ParameterRuleTip()

        var body: some View {
            VStack(spacing: 20) {
                Text("Use the parameter property wrapper and rules to track app state and control where and when your tip appears.")

                // Place your tip near the feature you want to highlight.
                TipView(tip, arrowEdge: .bottom)
                Image(systemName: "photo.on.rectangle")
                    .imageScale(.large)

                Button("Tap") {
                    // Trigger a change in app state to make the tip appear or disappear.
                    ParameterRuleTip.isLoggedIn.toggle()
                }

                Text("Tap the button to toggle the app state and display the tip accordingly.")
                Spacer()
            }
            .padding()
            .navigationTitle("Parameters")
        }
    }

![https://cdn.fatbobman.com/tipkit-parameters-rule-
demo_2023-10-15_19.16.25.2023-10-15%2019_17_01.gif](https://cdn.fatbobman.com/tipkit-
parameters-rule-demo_2023-10-15_19.16.25.2023-10-15%2019_17_01.gif)

在上面的代码中，为了便于演示，我们通过点击按钮的方式来修改 `isLoggedIn` 的值。当然，我们也可以通过构造方法来传递值的变化，比如：

    struct ParameterRuleTip: Tip {
        init(isLoggedIn:Bool){
            Self.isLoggedIn = isLoggedIn
        }

        ....
    }

    struct ParameterView: View {
        private var tip: ParameterRuleTip
        init(isLoggedIn: Bool) {
            tip = ParameterRuleTip(isLoggedIn: isLoggedIn)
        }
        ....
    }

实际上，开发者可以在应用程序的任何位置通过 `ParameterRuleTip.isLoggedIn` 来读取或设置 `ParameterRuleTip.$isLoggedIn` 的值，无论是否在视图中。TipKit 将观察该值的变化，以决定是否显示
ParameterRuleTip。

`ParameterRuleTip.isLoggedIn` 的状态只能被 TipKit 实时观察，不能作为 SwiftUI 视图的数据源。

### 为 Tip 定义事件（ Event ）

除了通过观察某个特定状态来判断是否显示 Tip 的途径外，TipKit 还提供了另外一种利用统计分析的方式制定规则的方法。

首先，我们需要为 Tip 定义一个事件，然后根据该事件发生的数量和频率来决定是否显示 Tip。

    struct EventRuleTip: Tip {
        // Define the user interaction you want to track.
        static let didTriggerControlEvent = Event(id: "didTriggerControlEvent")
        ....

        var rules: [Rule] {
            [
                // Define a rule based on the user-interaction state.
                #Rule(Self.didTriggerControlEvent) {
                    // Set the conditions for when the tip displays.
                    $0.donations.count >= 3
                }
            ]
        }
    }

与参数一样，事件也是一个静态属性。 `id` 是事件的标识。

下面规则的含义是，只有在 `didTriggerControlEvent` 这个事件触发了至少三次后才显示 EventRuleTip。

    #Rule(Self.didTriggerControlEvent) {
        // Set the conditions for when the tip displays.
        $0.donations.count >= 3
    }

我们可以在应用程序的任何地方通过 `Tip 类型名称。事件属性。donate()` 的方式生成事件。TipKit
将记录每次事件生成的时间，并以此作为判断和筛选的依据。

    struct EventView: View {
        // Create an instance of your tip content.
        private var tip = EventRuleTip()

        var body: some View {
            VStack(spacing: 20) {
                Text("Use events to track user interactions in your app. Then define rules based on those interactions to control when your tips appear.")

                // Place your tip near the feature you want to highlight.
                TipView(tip)
                Button(action: {
                    // Donate to the event when the user action occurs.
                    Task { await EventRuleTip.didTriggerControlEvent.donate() }
                }, label: {
                    Label("Tap three times", systemImage: "lock")
                })

                Text("Tap the button above three times to make the tip appear.")
                Spacer()
            }
            .padding()
            .navigationTitle("Events")
        }
    }

![https://cdn.fatbobman.com/tipkit-event-rule-
demo_2023-10-15_20.04.07.2023-10-15%2020_05_19.gif](https://cdn.fatbobman.com/tipkit-
event-rule-demo_2023-10-15_20.04.07.2023-10-15%2020_05_19.gif)

在上面的演示中，我们通过单击按钮生成了相应的事件。当事件数量达到三条时，满足规则的条件，EventRuleTip 被显示出来。

    Button(action: {
        // Donate to the event when the user action occurs.
        Task { await EventRuleTip.didTriggerControlEvent.donate() }
    }, label: {
        Label("Tap three times", systemImage: "lock")
    })

TipKit 还提供了一个包含回调函数的同步版本的事件产生方法（ `sendDonation` ）。

    Button(action: {
        // Donate to the event when the user action occurs.
        EventRuleTip.didTriggerControlEvent.sendDonation{
            print("donate a didTriggerControlEvent")
        }
    }, label: {
        Label("Tap three times", systemImage: "lock")
    })

我们可以从多个维度依据事件进行判断：

    // 事件总数 >= 3
    $0.donations.count >= 3
    // 在一周内事件次数 < 3
    $0.donations.donatedWithin(.week).count < 3
    // 在三天内事件次数 > 3
    $0.donations.donatedWithin(.days(3)).count > 3

目前在每次产生的 Event 中，TipKit 只记录了事件创建的时间，尚未开放自定义 DonationInfo。如果开放了自定义
DonationInfo，我们便可以在创建事件时添加更多的附加信息，从而进行一些更有针对性的规则设定。

    public func donate(_ donation: DonationInfo) async

我们可以定义各种事件，例如进入特定视图、点击按钮、应用接收到网络数据等等。将 TipKit
的事件作为记录和筛选的一种手段，并应用于其他场景中（下篇文章中详述）。

### 规则适用

如果我们没有为某个 Tip 设定规则，可以将其视为拥有一个默认规则，该规则永远为真。

我们还可以在一个 Tip 中创建多个规则。在 Tip 协议中，rules 的定义为 `@Tips.RuleBuilder var rules:
[Self.Rule] { get }` ，同样是一个 Result Builder。多条规则之间使用 `AND`
的关系，必须全部满足才会显示。例如，我们可以将上文中的两条规则用以下方式进行合并。

    var rules: [Rule] {
        #Rule(Self.didTriggerControlEvent) {
            $0.donations.count > 3
        }
        #Rule(Self.$isLoggedIn) {
            $0 == true
        }
    }

只有当 `isLoggedIn` 为真且 `didTriggerControlEvent` 事件数量超过三个时，才显示 Tip。

## 让 Tip 失效（ invalidate ）的方法

在上文的代码中，出现了两次以下的代码：

    tip.invalidate(reason: .actionPerformed)
    configuration.tip.invalidate(reason: .tipClosed)

这两行代码的作用相同，都是使某个 Tip 失效并记录原因。

目前 TipKit 提供了三种 Tip 失效原因：

- actionPerformed：主要用于开发者在代码中主动产生的失效操作。
- tipClosed：点击 Tip 视图的关闭按钮（ `x` ）时会记录该原因。
- displayCountExceeded：当 Tip 显示的次数超过设定的阈值时，TipKit 会自动让该 Tip 失效，并记录该原因（下文详解）。

请特别注意，让 Tip 失效和不让 Tip 显示是两个不同的概念。

**我们通过规则来决定一个 Tip 是否满足了显示条件，但有一个前提是该 Tip 不能已经失效。否则即使满足了显示规则，如果 Tip 已经失效，TipKit
也不会显示该 Tip。**

## 通过 Option 设置 Tip 的最大显示次数

在上文中，我们提到了另一种导致 Tip 失效的原因： `displayCountExceeded` 。通过在 Tip
中定义选项，我们可以控制其最大显示次数。

    struct OptionTip: Tip {
        var title: Text {
            Text("Edit Actions in One Place")
        }

        var options: [Option] {
            // Show this tip once.
            Tips.MaxDisplayCount(1)
        }
    }

在上面的代码中，我们通过 `Tips.MaxDisplayCount(1)` 的设置，使得该 Tip 的视图（无论是 `TipView` 还是 `popoverTip` ）只能被显示一次。一旦显示过后，TipKit 会将该 Tip 设置为失效状态。

TipKit 还提供了另一个选项，用于忽略全局的显示频次策略（见下文）：

    Tips.IgnoresDisplayFrequency(true)

## 通过 Configuration 设置 Tip 的全局显示频次策略

也许有人会奇怪，如果一个 Tip 的规则判断结果为真，在其未失效的情况下，难道会一直显示吗？这样不会引起用户的反感吗？

TipKit 已经提前考虑到了这一点，因此它允许开发者通过 Configuration 设置全局的 Tip 显示频率策略。

    struct TipKitExamplesApp: App {
        init() {
            try? Tips.configure([
                // The system shows no more than one tip per day.
                .displayFrequency(.daily)
            ])
        }
        var body: some Scene {
            WindowGroup {
                ContentView()
            }
        }
    }

通过为 configure 设置 `.displayFrequency(.daily)` ，我们可以让尚未失效的 Tip
在规则为真的情况下，每天只显示一次。其他设置还有：hourly、weekly、monthly、immediate（不限制显示频次）。

当某个 Tip 的 options 设置为 `Tips.IgnoresDisplayFrequency(true)` 后，将会忽略全局的显示频次设定。

## 重置 TipKit 的所有数据

我们可以使用下面的代码重置当前应用已保存的所有 Tip 数据，包括事件、失效状态、显示次数等。通常在进行测试或对应用进行重大改动时使用该命令。

    try Tips.resetDatastore()

> 此方法应运行在 `try? Tips.configure()` 之前。

## 用于测试的配置指令

为了方便测试，您可以使用以下 API 强制显示或隐藏 Tip：

    // 显示所有的 Tip，无论其是否失效或规则是否为真
    try? Tips.showAllTipsForTesting()

    // 显示特定的 Tip，无论其是否失效或规则是否为真
    try? Tips.showTipsForTesting([EventRuleTip.self, ParameterRuleTip.self])

    // 隐藏所有的 Tip，即使其尚未失效且规则为真
    try? Tips.hideAllTipsForTesting()

## 设置 TipKit 数据保存的位置

我们还可以修改 TipKit 保存数据的位置。使用 App Group 时，可以让多个应用或组件共享同一个 TipKit 数据源。例如，在 A 应用中让某个
Tip 失效了，失效状态同样也会在应用 B 中反映出来。

    try? Tips.configure([
        .datastoreLocation(.groupContainer(identifier: "appGroup-id"))
    ])

或者将数据保存到指定目录中。

    try? Tips.configure([
        .datastoreLocation(.url(URL.documentsDirectory))
    ])

> 默认情况下，TipKit 的数据保存在 Application Support 目录中。

## 接下来

在本文中，我们介绍了 TipKit 的基本用法。在下篇文章中，我们将探讨更多关于 TipKit 的内容，包括 TipKit 的数据保存机制、在 UIKit
中使用 TipKit、将 TipKit 作为非提示领域的统计工具使用，以及如何实现完全的自定义视图（不使用 `TipView` 和 `popoverView` ）等进阶话题。

# iCloud Documents 进阶：理解占位文件、空间优化与操作技巧

欢迎回到我们关于 iCloud Documents 的深入探讨。在前文 [ iCloud Documents 详解：基础设置与文件操作
](/zh/posts/in-depth-guide-to-icloud-documents/) 中，我们探索了 iCloud Documents
的基本概念、设置步骤和基础的文件操作。本文将在上文基础上继续探讨，因此，如果你还未阅读前文，建议你先熟悉基础知识，以便更好地理解本文的内容。

本文我们将讨论 iCloud Documents 文件夹的独特性质，占位文件的重要性和应用，之外，我们还将探讨与文件操作和调试有关的技巧。

## iCloud Documents 文件夹

尽管同为应用可以访问到的文件夹，iCloud Documents 文件夹相较于应用沙盒内的文件夹（ Documents、Application
Support 等）仍有几个明显的不同点：

- iCloud Documents 文件夹不属于应用的沙盒范围，它在文件系统的特殊位置，与应用沙盒隔离。
- iCloud Documents 中的部分文件对其他应用也可能是可见或者可共享的，而应用内部的数据默认是私有的。
- iCloud Documents 中的文件默认就是与 iCloud 云端持续同步的，以支持在 Apple 设备之间的文档共享。而应用沙盒内的文件是否同步到 iCloud 取决于应用的设置（ 是否开启云备份 ）、文件的位置（ Documents 默认同步 ）、文件的配置（ Application Support 目录中的文件，可以通过 NSURLIsExcludedFromBackupKey 来设置是否同步 ）。
- 在满足 iCloud 备份条件（ 网络、电量、当前时间 ）时，应用沙盒内可备份的数据会同步到 iCloud 作为备份，该备份仅在下次安装应用时才会起作用。但是 iCloud Documents 中 的文档变更可以近似实时上传并同步给其他设备。
- 当应用被删除后，该应用的沙盒将被系统清空，而 iCloud Documents 中的文件会依然保留在 iCloud 和用户设备中。
- iCloud Documents 中的文件可以按需下载或释放空间（ 文件仍保存在云端 ），沙盒内的文档没有此能力
- iCloud Documents 提供了版本控制和冲突解决机制，有助于在多设备间同步时维护文件的一致性。

因此，开发者乃至使用者，要根据 iCloud Documents 文件夹的特点来决定使用的策略：

- 因为 iCloud Documents 文件夹内的数据都会被同步，因此只应该在 iCloud Documents 文件夹中放置真正需要即时备份、分享的文档数据。
- 考虑到其数据会在本地和云端占用双份空间，开发者应该提供空间释放空间的能力或提醒使用者通过系统应用来释放暂时不需要的资源。
- 尽管 iCloud Documents 的同步效率还可以，但它并不适合保存零散数据或增量数据。如有需要，开发者可以考虑使用 CloudKit 提供的其他服务。
- 考虑到用户的云端空间容量可能有限，开发者不应默认所有的数据都会成功上传到云端并同步到其他设备中。
- 为了减少用户云端容量的压力，开发者应该提供将数据转移至非自动同步目录的能力。

## 什么是占位文件

在云同步服务中，占位文件扮演者重要的角色。比如我在设备 A 上的 iCloud Documents 目录中创建了文件 `lesson1.pdf` ，设备
B 在收到同步消息后，多数情况下并不会自动下载该文件（ 在 macOS 上，如果关闭优化存储空间，系统会自动下载；在 iOS
中，如果文件很小且应用正在运行，有时系统会自动下载 ），设备 B 会在 iCloud Documents 目录相同位置创建一个对应的占位文件。设备 B
上的应用或使用者可以在需要的时候自主选择从云端下载完整的文件数据。

占位文件提供了一种平衡本地存储限制和即时云端文件访问的方式。通过它，用户可以有效管理他们的存储空间，同时保持对重要文件的即时访问。

以设备 B 和文件 `file1.txt` 举例，设备 B 在收到同步通知后，会在与设备 A 的 `lesson1.pdf`
相同的文件位置创建一个名为 `.lesson1.pdf.icloud` 文件。该文件将作为 `lesson1.pdf` 在设备 B 上的占位文件。

占位文件以 Property List 的形式保存了一些与原始文件有关的信息（ 文件名、文件容量、文件类型 ），经过解析后，大致的信息如下：

    [
      "NSURLNameKey": lesson1.pdf,
      "NSURLFileSizeKey": 206739,
      "NSURLFileResourceTypeKey": NSURLFileResourceTypeRegular
    ]

当文件应用或 Finder
发现文件是占位文件时，它仍会以正常的文件名、文件容量显示给用户，但是，会通过图标的方式提醒使用者，这个文件尚未下载到本地，使用者可以点击下载从云端下载完整版本。同样，对于已经下载到本地的完整文件，使用者也可以通过点击移除下载项来删除本地的完整文件，系统会自动创建一个新的占位文件。

由于占位文件机制的存在，因此对于开发者来说，在对文件进行某些操作前要先应判断文件的占位状态，然后再作出相应的操作。

同样，由于占位文件使用了特殊的名称标记方式，为此，获取文件列表最好的方式，仍是通过前一篇文章介绍的 [ NSMetaDataQuery
](https://developer.apple.com/documentation/foundation/nsmetadataquery)
。因为，即使开发者不顾虑多进程文件竞争，使用 `fileManager.contentsOfDirectory` 获取到的文件名会包含占位标识符（
对于占位文件 ），开发者还需要做特别的处理。

## 如何判断文件是否为占位文件

在处理 iCloud Documents
时，正确地识别占位文件是一个关键步骤。虽然我们可以通过检查文件名中是否包含特定的占位标识符来进行判断，但这并不是最准确或最可靠的方法。更科学的做法是利用我们通过
`NSMetadataQuery` 获得的文件列表，并查看每个文件的元数据属性来确定其是否为占位文件。

这种方法的优势在于，它基于文件的实际元数据状态，而不仅仅是文件名。为此，我们在之前定义的 `MetadataItemWrapper` 结构体中添加了一个
`isPlaceholder` 属性，用于存储每个文件的占位状态。

以下是相应的 Swift 代码实现：

    struct MetadataItemWrapper: Sendable {
        ....
        let isPlaceholder:Bool

        init(metadataItem: NSMetadataItem) {
            ....

            if let downloadingStatus = metadataItem.value(forAttribute: NSMetadataUbiquitousItemDownloadingStatusKey) as? String {
                if downloadingStatus == NSMetadataUbiquitousItemDownloadingStatusNotDownloaded {
                    // 文件是占位文件
                    isPlaceholder = true
                } else if downloadingStatus == NSMetadataUbiquitousItemDownloadingStatusDownloaded || downloadingStatus == NSMetadataUbiquitousItemDownloadingStatusCurrent {
                    // 文件已下载或是最新的
                    isPlaceholder = false
                } else {
                    isPlaceholder = false
                }
            } else {
                // 默认值，假设文件不是占位文件
                isPlaceholder = false
            }
        }
    }

## 如何下载文件

所谓的下载文件，是指让系统将占位文件的原始文件从云端下载下来对占位文件进行替换的过程。通过调用 `FileManager.default.startDownloadingUbiquitousItem(at: )`
，即可触发对特定占位文件的下载操作。为了安全起见，最好还是通过 NSFileCoordinator 来进行该操作。

以下是一个下载文件的示例方法，它使用了前文创建的 `CloudDocumentsHandler` 来确保文件下载的安全性和协调性：

    extension CloudDocumentsHandler {
        func download(url: URL) throws {
            var coordinationError: NSError?
            var downloadError: Error?

            coordinator.coordinate(writingItemAt: url, options: [.forDownloading], error: &coordinationError) { newURL in
                do {
                    try FileManager.default.startDownloadingUbiquitousItem(at: newURL)
                } catch {
                    downloadError = error
                }
            }

            // 检查下载过程中是否发生了错误
            if let error = downloadError {
                throw error
            }

            // 检查协调过程中是否发生了错误
            if let coordinationError = coordinationError {
                throw coordinationError
            }
        }
    }

在下载的过程中，系统并不会将尚未完成的文件保存在占位文件当前的目录中，只有等到文件完全下载后，系统才会用完整的文件替换掉占位文件。

对与已经下载完成的文件，再次调用 `startDownloadingUbiquitousItem` 不会有任何效果。

> 尽管官方文档描述该方法可以接收目录 URL 作为参数，但在测试中发现 `startDownloadingUbiquitousItem`
> 只能用于下载单个文件。

## 如何获得下载进度、下载状态、上传状态

下载进度：从文件的元数据 `NSMetadataUbiquitousItemPercentDownloadedKey` 中可以获取下载进度。这个值（
Double ）表示文件已经下载的百分比，可以用来追踪下载进度。

下载状态：结合占位状态和下载进度可以判断当前的下载状态。如果文件是占位文件且下载进度大于 0 且小于 100，则可以认为文件正在下载。

上传状态：从文件的元数据 `NSMetadataUbiquitousItemPercentUploadedKey`
中可以获取上传进度。这个值只有两个状态，0 表示未上传，100 表示已上传完成。

    struct MetadataItemWrapper: Sendable {
        ....
        let isDownloading: Bool
        let downloadProgress: Double
        let uploaded: Bool

        init(metadataItem: NSMetadataItem) {
            ....
            // 获取下载进度
            downloadProgress = metadataItem.value(forAttribute: NSMetadataUbiquitousItemPercentDownloadedKey) as? Double ?? 0.0

            // 如果是占位文件且下载进度大于 0 且小于 100，则认为文件正在下载
            isDownloading = isPlaceholder && downloadProgress > 0.0 && downloadProgress < 100.0
            // 是否已经上传完毕（只有 0 和 100 两个状态）
            uploaded = (metadataItem.value(forAttribute: NSMetadataUbiquitousItemPercentUploadedKey) as? Double ?? 0.0) == 100
        }
    }

通过这些属性，我们可以较精准的掌握文件状态，以便更好地管理和监控文件的同步过程并给予用户提示。

## 如何释放将已下载的文件所占用的空间

当你需要释放已下载的文件占用的空间将文件变回占位模式时，可以使用 `evictUbiquitousItem`
方法。这个方法非常类似于触发下载的操作，但它的作用是将已下载的文件变成占位模式，从而释放空间。 `evictUbiquitousItem`
方法可以用于文件和文件夹，当对文件夹执行此操作时，iCloud 会递归地移除文件夹中子项目的副本。

需要特别注意的是， **[ 不要使用协调器
](https://developer.apple.com/documentation/foundation/filemanager/1409696-evictubiquitousitem#discussion)
（ `NSFileCoordinator` ）执行此操作 ** ，因为这样做可能会导致死锁。你可以简单地调用 `evictUbiquitousItem` 方法来释放已下载文件的空间，而无需额外的协调。

    extension CloudDocumentsHandler {
        func evict(url: URL) throws {
            do {
                try FileManager.default.evictUbiquitousItem(at: url)
            } catch {
                throw error
            }
        }
    }

## 如何移动 iCloud Documents 目录中的文件而不必下载它们

你可以通过使用 `FileManager.default.moveItem(at:to:)` 方法在 iCloud Documents
目录中移动文件，而不必关系它的占位状态。即使文件是占位文件，只要目标地址也在 iCloud Documents 的目录中，移动后文件仍会保持占位状态。

以下是一个示例代码，演示如何在 iCloud Documents 目录中移动文件：

    extension CloudDocumentsHandler {
        func moveFile(at sourceURL: URL, to destinationURL: URL) throws {
            var coordinationError: NSError?
            var moveError: Error?

            coordinator.coordinate(writingItemAt: sourceURL, options: .forMoving, writingItemAt: destinationURL, options: .forReplacing, error: &coordinationError) { (newSourceURL, newDestinationURL) in
                do {
                    try FileManager.default.moveItem(at: newSourceURL, to: newDestinationURL)
                } catch {
                    moveError = error
                }
            }

            // 检查移动过程中是否发生了错误
            if let error = moveError {
                throw error
            }

            // 检查协调过程中是否发生了错误
            if let coordinationError = coordinationError {
                throw coordinationError
            }
        }
    }

请注意，对于特定的操作，如移动文件，应确保设置正确的选项（options），以便在移动过程中保持文件的正确状态。

## 如何在不下载文件的情况下重命名文件

只需使用上面用于移动的代码，更改目标名称即可。即使是占位文件，更名后仍会保持占位状态。

## 如何解除文件的同步状态

你可以通过将文件从 iCloud Documents 目录中移动到其他位置（ 非 iCloud Documents 目录
）来解除文件的同步状态。即使文件当前处于占位模式，系统也会在移动前自动开始下载文件，并在下载完成后将再将文件移动到新的位置。这个过程可能会有一定的延迟，特别是对于较大的文件。

## 调试技巧

在开发和调试涉及网络同步的功能时，我们通常面临一个挑战：快速且稳定的网络环境。这种环境虽然理想，但却不利于测试网络同步的边缘情况，例如慢速连接或不稳定网络。此外，在高速网络环境下，某些关键的传输细节和中间状态可能会被快速跳过，从而无法捕捉到。

为了解决这一问题，开发者可以利用苹果公司提供的一个工具：Network Link
Conditioner。这个工具允许我们模拟各种网络条件，如不同的网速、延迟和丢包率，从而创建出更接近现实生活中的网络环境。

以本文的撰写过程为例，我在尝试捕捉 iCloud Documents
的下载进度中间状态时遇到了困难。原因是网络速度过快，使得下载过程在瞬间完成。然而，通过使用 Network Link Conditioner
人为限制网络速度，成功模拟了较慢的下载环境，使得可以清晰地观察和记录下载的每个阶段。

获取 Network Link Conditioner 的方法：

- 在苹果开发者网站上，下载：Additional Tools for Xcode。

![image-20231205102918859](https://cdn.fatbobman.com/image-20231205102918859.png)

![image-20231205102856422](https://cdn.fatbobman.com/image-20231205102856422.png)

- 打开下载后的 `.dmg` 文件，找到 `Hardware/Network Link Conditioner.prefPane` ，将其复制到本地，双击安装即可。

![image-20231205103008115](https://cdn.fatbobman.com/image-20231205103008115.png)

![image-20231205103020359](https://cdn.fatbobman.com/image-20231205103020359.png)

- 在系统设置中，选择或创建一个 Profile ，开启该功能后，便可实现对当前开发环境的网络控制。

![image-20231205103112525](https://cdn.fatbobman.com/image-20231205103112525.png)

## 总结

通过前后两篇文章的探讨，我们可以发现，虽然涉及诸多细节，但只要我们细心地处理每一个步骤，并仔细调试，将 iCloud Documents
集成到我们的项目中并不困难。尽管这一过程需要我们投入一定的时间和精力，但最终为应用带来的增值和便利是显而易见的。

苹果公司提供的 CloudKit
服务，可以说是对开发者的一大福音。它使得开发者能够以极低的成本，为应用提供强大而灵活的网络数据同步功能。利用这些功能，将为应用赋予更强的竞争力和用户吸引力，也为用户带来更好的体验。

# 在 SwiftUI 中，根据需求弹出不同的 Sheet

Sheet 是一个我比较喜欢的交互形式，它可以很好的控制用户的操作行为，让用户的交互逻辑单线条化。在 iOS 14 上，SwiftUI 增加了
fullCover，支持了全屏的 Sheet 方式，让开发者又了更多的选择。

## 基本用法

    @State var showView1 = false
    @State var showView2 = false

    List{
        Button("View1"){
          showView1.toggle()
        }
      .sheet(isPresented:$showView1){
        Text("View1")
      }

      Button("View2"){
        showView2.toggle()
      }
      .sheet(isPresented:$showView2){
        Text("View2")
      }
    }

上述代码，我们可以通过点击不同的按钮而弹出相对应的 View。

不过它有两个缺点：

1. 如果你的代码有多处需要使用不同 view 作为 sheet 的情况，你需要声明多个对应的开关值
2. 如果你的 View 结构比较复杂，在比较内部的地方，上述代码很可能无法激发 sheet 的显示（这个问题在 ios 13 上就存在，在 ios 14 上仍有这样的情况。我至今也没有完全总结出规律）

## 使用 Item 来对应不同的 View

好在 sheet 提供了另外一种激活方式

    .sheet(item: Binding<Identifiable?>, content: (Identifiable) -> View)

我们可以使用它来完成只响应一个激活变量，而显示所需的不同 View

    struct View1:View{
        @Environment(\.presentationMode) var presentationMode
        let text:String
        var body: some View{
            NavigationView{
                VStack{
                Text(text)
                Text("View1")
                }
                    .toolbar{
                        ToolbarItem(placement: ToolbarItemPlacement.navigationBarLeading){
                            Button("cancel"){
                                presentationMode.wrappedValue.dismiss()
                            }
                        }
                    }
            }
        }

    }

    struct View2:View{
        @Environment(\.presentationMode) var presentationMode
        var body: some View{
            NavigationView{
                Text("View2")
                    .toolbar{
                        ToolbarItem(placement: ToolbarItemPlacement.navigationBarLeading){
                            Button("cancel"){
                                presentationMode.wrappedValue.dismiss()
                            }
                        }
                    }
            }
        }

    }

先准备两个需要显示的 View

    struct SheetUsingAnyView: View {
        @State private var sheetView:AnyView?
        var body: some View {
            NavigationView{
                List{
                    Button("View1"){
                        sheetView = AnyView(View1(text:"Hello world"))
                    }
                    Button("View2"){
                        sheetView = AnyView(View2())
                    }
                }
                .listStyle(InsetGroupedListStyle())
                .sheet(item: $sheetView){ view in
                   view
                }
                .navigationTitle("AnyView")
                .navigationBarTitleDisplayMode(.inline)
            }
        }
    }

    extension AnyView:Identifiable{
        public var id:UUID{UUID()}
    }

通过上述代码，我们便可以通过给 sheetView 赋予不同的值来实现弹出对应的 View。

这个解决方案非常的便捷，不过也存在两个问题：

1. 在极个别的情况下，当 app 进入后台（此时 app 的 sheet 处于显示状态），再从后台重新显示时会出现程序崩溃情况。这个问题在 ios 13 和目前的 ios 14（测试到 beta 5）都可能出现。不过出现的前提是你的代码的显示层级要足够复杂，如果代码比较简单，通常是可以正常运行的。

对于这个崩溃的情况，错误和调试代码给的信息都很不准确，估计应该和 View 的初始化冲突有关。

2. 指令不清晰。如果赋值给 sheetView 的 View 参数很多，你的代码的可读性会比较差

## 采用 Reducer 的思路解决问题

其实对于每一个 View，我们也都可以按照 MVVM 的思路来构建它自己的 mini 状态机（我的另一篇关于 Form 的文章也是这样的思路）。

    struct SheetUsingEnum: View {
        @State private var sheetAction:SheetAction?
        var body: some View {
            NavigationView{
                List{
                    Button("view1"){
                        sheetAction = .view1(text:"Test")
                    }
                    Button("view2"){
                        sheetAction = .view2
                    }
                }
                .listStyle(InsetGroupedListStyle())
                .sheet(item: $sheetAction){ action in
                    getActionView(action)
                }
                .navigationTitle("Enum")
                .navigationBarTitleDisplayMode(.inline)
            }
        }

        func getActionView(_ action:SheetAction) -> some View{
            switch action{
            case .view1(let text):
                return AnyView(View1(text: text))
            case .view2:
                return AnyView(View2())
            }
        }
    }

    enum SheetAction:Identifiable{
        case view1(text:String)
        case view2

        var id:UUID{
            UUID()
        }
    }

比较直接使用 AnyView，代码量稍微增多了点，不过第一没有了崩溃的可能性，同时代码的易读性也得到了提高。

## 解决某些 View 无法激活 Sheet 的问题

关于在某些 View 上无法激活 Sheet，我目前的解决方案是 bind 它的父 View 的 sheetAction，通过父 View 来激活
Sheet。通过枚举的相关值来传递所需的数据。

**更新** : 在 iOS 14 下，使用 item 来激活 sheet, 在某些特殊场合可能会导致 app（打开 sheet
的情况下）从后台返回时会发生错误甚至崩溃。所以上述代码中对于 sheet 的激活，已经作出了更改。更改后的代码已经统一到了 [ 在 SwiftUI
中制作可以控制取消手势的 Sheet ](/zh/posts/swiftui-dismiss-sheet/)

[ 可以在此下载项目完整代码 ](https://github.com/fatbobman/DismissConfirmSheet)

# WWDC 2023 我期待 SwiftUI 带来的新变化

距离 2023 年的 WWDC 还有约 20 天，每个苹果生态的开发者都在期待苹果会在当天带来哪些新东西。在本文中，我将列出个人对于 SwiftUI
的愿望单，期待着看到哪些愿望能够实现。

如果不限制数量，SwiftUI 开发者可能会列出一个长长的愿望列表。在此仅列出几个我认为重要且近一两年内有望实现的愿望，避免期望过高而带来的失望。

## 以属性为粒度的视图关联

紧迫性：4 实现可能性：3.5（ 总分 5 分 ）

在上个月，Swift 社区出现了一个提案 **[ SE-0395: Observability
](https://forums.swift.org/t/se-0395-observability/64342) ** , 简单来说可以将其理解为
Swift 原生的 KVO 加强版实现。如果这个提案得以在近期通过，那么在 SwiftUI 中，视图就有可能实现以属性为粒度的依赖关联。如此一来，在使用基于
ObservableObject 协议的引用类型 Source of truth 时，不必要的计算将大大减少，开发者将可以用更自由的方式来组织 Data
flow。

## 统一的 Gesture 逻辑、允许创建真正的自定义手势

紧迫性：5 实现可能性：2.5

在 SwiftUI 中，开发者很难实现复杂的手势逻辑。其中一个重要原因是 SwiftUI
目前存在两个手势系统，而且两者的兼容性很差，其中一种很容易被另一种打断。从 SwiftUI 的 interface
文件可以看到，ScrollView、List、TabView、Button 等控件都有其对应的内部手势实现，这些实现与常用的
DragGesture、TapGesture 等开放给开发者的手势在很大程度上不同。它们在优先级上更高，而且它们之间也不能很好地共融。这就导致无法用原生的
SwiftUI 方式应对有复杂手势需求的场景（例如多重滚动嵌套）。

此外，SwiftUI 并未提供真正的自定义手势能力，目前仅支持基于当前已提供手势的组合功能。如果开发者使用基于 UIKit
的自定义手势，则将落入到上文提到的手势之间相互竞争的困境中。

只有尽早提供完善的自定义手势功能，并在 SwiftUI 内部实现手势逻辑的统一，才能解决这些问题。

## 更完善的文字输入和显示

紧迫性：5 实现可能性：4

相较于最初版本，SwiftUI 4.0 的 Text 和 TextField
功能已经有了极大的增强和改善。然而，与成熟的解决方案相比，它们仍有相当的差距。许多开发者为了解决某些问题不得不基于 UIKit（ AppKit
）重新包装所需的显示和录入控件，这不仅增加了工作量，也放弃了许多原生控件所提供的优秀能力。

说实话，无论 Text 和 TextField 增强到何种程度都不为过。但对我而言，目前急需解决的问题有以下几点：

- 提供更好的 AttributedString 支持

除了在 AttributedString 诞生的那一年 Text 提供了部分支持外，上一个版本中没有在这方面做出任何改进。Text 应该提供更多对
AttributedString 属性的支持，特别是针对段落的支持。最好还能提供自定义 Attribute 显示的
API，给开发者提供自行扩充的能力。此外，TextField 也应该支持 AttributedString，这样就可以用原生的方式应对一些简单的排版场景。

- 为避免状态黑洞，需要更统一的状态响应逻辑。

虽然 TextField 的构造方法很好地遵循了 SwiftUI
由状态驱动的逻辑，但这只是表象。实际上，在很多情况下，它只是在表演状态与显示一一对应的关系。由于经过了二次包装，这些控件在内部实现时经常遗漏与外部状态的对应，从而出现无法处理的情况（无法从状态下手，也无法从内部找到
hack 的点）。

> 这种问题不仅出现在 TextField 上，很多主要依赖对 UIkit 二次包装的控件目前都存在类似的问题。从某些 Bug
> 的分析中可以看出，SwiftUI 团队的部分开发人员也没有完全转换至声明、状态、响应的思维逻辑上。在包装时，他们经常会遗漏与外部状态的同步。

## 稳定、高效的 ForEach 实现

紧迫性：5 实现可能性：3.5

在 SwiftUI 中，ForEach 是一个经常使用的控件，尤其在 Lazy 容器中。然而，直到 4.0
版本，它的稳定性和性能仍然无法完全令人满意。例如：

- [ 在子视图使用的 id 修饰符的情况下，优化机制失效 ](/zh/posts/optimize_the_response_efficiency_of_list/)
- [ 内存释放不及时，容易导致应用崩溃 ](/zh/posts/memory-usage-optimization/)
- [ task 修饰器闭包任务无法 100% 调用（ 已在 16.4 修复 ） ](https://twitter.com/fatbobman/status/1574252681467637760?s=61&t=ecQh6_M1bDgzJDGbrFupaw)
- [ 二级及以下子视图在 onDisappear 后无法保持状态 ](https://twitter.com/fatbobman/status/1572507700436807683?s=61&t=6wE0YqMg9Y85zDZMQr_ycg) （ 在写本文前两天，收到苹果的回复，证实此为 by Design 的行为 ）

这导致在数据量较大的情况下，基于 SwiftUI 的应用性能较差，用户体验不佳。随着基于 SwiftUI 的应用越来越复杂，ForEach 的问题急需解决。

> 当然，如果在改善 ForEach 问题的同时能提供一个支持 Lazy 的 Layout 协议那就更好了 👏。

## 向前兼容性

紧迫度：4 实现可能性：4.5

当看到 Swift 5.8 提供了 `@backDeployed` 特性时，相信很多开发者都迫切希望苹果能将其应用于
SwiftUI，以增强老版本的功能并修复 bug。每次 WWDC 推出新版本 SwiftUI
时，开发者在高兴的同时也会感到痛苦：难道又要提高应用的最低版本要求？

如果苹果能充分利用该特性，将为开发者带来巨大好处。

## 最后

作为未来数年中苹果生态中最主要的开发框架，SwiftUI 应该提供更多原生、稳定的底层
API，让有经验的开发者能够自行添加特性。这样既可以减轻苹果的工作量，又能让开发者有更多的选择。何乐而不为呢？

## 写出你的愿望单，赢取 🍒

如果你对 SwiftUI 5 有什么期望，请在此 **[ 推文
](https://twitter.com/fatbobman/status/1656109768795365376?s=20) ** 下回复。获得最多
❤️ 的 **7** 个回复者，我将送出一箱大连 🍒。

![Untitled](https://cdn.fatbobman.com/Untitled.png)

向公众号的读者道歉，昨天我本打算在公众号上举办这个活动，结果发出文章后才发现，我的公众号没有评论功能 😅。只能把原来准备给公众号的两箱樱桃也放到
Twitter 上了。

# 用 Publish 创建博客（二）—— 主题开发

拥用强大的主题系统是一个静态网站生成器能否成功的重要原因之一。 [ Publish
](https://github.com/JohnSundell/Publish) 采用 [ Plot
](https://github.com/JohnSundell/Plot) 作为主题的开发工具，让开发者在高效编写主题的同时享受到了 Swift
的类型安全的优势。本文将从 Plot 开始介绍，让读者最终学会如何创建 Publish 主题。

## Plot

### 简介

想要开发 Publish 的 `Theme` 主题，就不能不从 Plot 说起。

在 Swift 社区中，有不少优秀的项目致力于使用 Swift 生成 HTML：比如 Vapor 的 [ Leaf
](https://github.com/vapor/leaf) ，Point-Free 的 [ swift-html
](https://github.com/pointfreeco/swift-html) 等，Plot 也是其中的一员。Plot 最初是由 [ John
Sundell ](https://swiftbysundell.com) 编写的并作为 Publish 套件的一部分，它主要的关注点是 Swift
的静态网站 HTML 生成，以及创建建站所需的其他格式文档，包括 `RSS` 、 `podcast` 、 `Sitemap` 。它与
Publish 紧密集成但同时也作为一个独立项目存在。

Plot 使用了一种被称作 `Phantom Types` 的技术，该技术将类型用作编译器的“标记”，从而能够通过泛型约束来强制类型安全。Plot
使用了非常轻量级的 API 设计，最大限度的减少外部参数标签，从而减少渲染文档所需的语法量，使其呈现了具有“类似 DSL”的代码表现。

### 使用

#### 基础

- Node

是任何 Plot 文档中所有元素和属性的核心构件。它可以表示元素和属性，以及文本内容和节点组。每个节点都被绑定到一个 Context
类型，它决定了它可以访问哪种 DSL API（例如 `HTML.BodyContext` 用于放置在 HTML 页面 `<body>` 中的节点）。

- Element 代表一个元素，可以使用两个独立的标签打开和关闭（比如 `<body></body>` ），也可以自闭（比如 `<img/>` ）。当使用 Plot 时，你通常不需要与这个类型进行交互，基础 Node 中会创建它的实例。

- Attribute

表示附加在元素上的属性，例如 `<a>` 元素的 href，或者 `<img>` 元素的 src。你可以通过它的初始化器来构造 `Attribute` 值，也可以通过 DSL，使用 `.attribute()` 命令来构造。

- Document 和 DocumentFormat

给定格式的文档，如 HTML、RSS 和 PodcastFeed。这些都是最高级别的类型，你可以使用 Plot 的 DSL 来开始一个文档构建会话。

#### 类 DSL 语法

    import Plot

    let html = HTML(
        .head(
            .title("My website"),
            .stylesheet("styles.css")
        ),
        .body(
            .div(
                .h1("My website"),
                .p("Writing HTML in Swift is pretty great!")
            )
        )
    )

上面的 Swift 代码将生成下面的 HTML 代码。代码形式同 DSL 非常类似，代码污染极少。

HTML

Copy code

Copied!

    <!DOCTYPE html>
    <html>
        <head>
            <title>My website</title>
            <meta name="twitter:title" content="My website"/>
            <meta name="og:title" content="My website"/>
            <link rel="stylesheet" href="styles.css" type="text/css"/>
        </head>
        <body>
            <div>
                <h1>My website</h1>
                <p>Writing HTML in Swift is pretty great!</p>
            </div>
        </body>
    </html>

有些时候，感觉上 Plot 只是将每个函数直接映射到一个等效的 HTML 元素上——至少上面的代码看起来如此，但其实 Plot
还会自动插入许多非常有价值的元数据，在后面我们还将看到 Plot 更多的功能。

#### 属性

属性的应用方式也可以和添加子元素的方式完全一样，只需在元素的逗号分隔的内容列表中添加另一个条目即可。例如，下面是如何定义一个同时具有 CSS 类和 URL
的锚元素。属性、元素和内联文本都是以同样的方式定义的，这不仅使 Plot 的 API 更容易学习，也让输入体验非常流畅—因为你可以在任何上下文中简单地键入
`.` 来不断定义新的属性和元素。

    let html = HTML(
        .body(
            .a(.class("link"), .href("https://github.com"), "GitHub")
        )
    )

#### 类型安全

Plot 大量使用了 Swift 的高级泛型能力，不仅使采用原生代码编写 HTML 和 XML 成为可能，并在这一过程中实现了完全的类型安全。Plot
的所有元素和属性都是作为上下文绑定的节点来实现的，这既能强制执行有效的 HTML 语义，也能让 Xcode 和其他 IDE 在使用 Plot 的 DSL
编写代码时提供丰富的自动补全信息。

    let html = HTML(.body(
        .p(.href("https://github.com"))
    ))

比如， `<herf>` 是不能直接被放置在 `<p>` 中的，当输入 `.p`
的时候自动补全是不会提示的（因为上下文不匹配），代码也将在编译时报错。

这种高度的类型安全既带来了非常愉快的开发体验，也使利用 Plot 创建的 HTML 和 XML
文档在语义上正确的几率大大增加—尤其是与使用原始字符串编写文档和标记相比。

对于笔者这种 HTML 知识极度匮乏的人来说，在 Plot 下我也没有办法写出下面的错误代码（无法通过）。

    let html = HTML(.body)
        .ul(.p("Not allowed"))
    ))

#### 自定义组件

同样的，上下文绑定的 Node 架构不仅赋予了 Plot 高度的类型安全，也使得可以定义更多更高层次的组件，然后将这些自定义组件与 Plot
本身定义的元素灵活地混合使用。

例如，我们要为网站添加一个 advertising 组件，该组件绑定在 HTML 文档的 `<body>` 上下文中。

    extension Node where Context: HTML.BodyContext { //严格的上下文绑定
        static func advertising(_ slogan: String,herf:String) -> Self {
            .div(
                .class("avertising"),
                .a(
                    .href(herf),
                    .text(slogan)
                )
            )
        }
    }

现在可以使用与内置元素完全相同的语法来使用 `advertising` 。

    let html = HTML(
        .body(
            .div(
                .class("wrapper"),
                .article(
                   ....
                ),
                .advertising("肘子的 Swift 记事本", herf: "https://fatbobman.com")
            )
        ))

#### 控制流程

尽管 Plot 专注于静态站点生成，但它还是附带了几种控制流机制，可让您使用其 DSL 的内联逻辑。目前支持的控制命令有 `.if( )` ， `.if(_,else:)` ， `unwrap()` 以及 `forEach()` 。

    var books:[Book] = getbooks()
    let show:Bool = true
    let html = HTML(.body(
        .h2("Books"),
        .if(show,
        .ul(.forEach(books) { book in
            .li(.class("book-title"), .text(book.title))
        })
        ,else:
            .text("请添加书库")
        )
    ))

使用上述控制流机制，尤其是与自定义组件结合使用时，可以使你以类型安全的方式构建真正灵活的主题，创建所需的文档和 HTML 页面。

#### 自定义元素和属性

尽管 Plot 旨在涵盖与其支持的文档格式相关的尽可能多的标准，但你仍可能会遇到 Plot 尚不具备的某种形式的元素或属性。我们可以非常容易的在 Plot
中自定义元素和属性，这一点在生成 XML 的时候尤为有用。

    extension Node where Context == XML.ProductContext {
        static func name(_ name: String) -> Self {
            .element(named: "name", text: name)
        }

        static func isAvailable(_ bool: Bool) -> Self {
            .attribute(named: "available", value: String(bool))
        }
    }

#### 文档渲染

    let header = Node.header(
        .h1("Title"),
        .span("Description")
    )

    let string = header.render()

还可以对输出缩排进行控制

    html.render(indentedBy: .tabs(4))

#### 其他支持

Plot 还支持生成 RSS feeds，podcasting，site maps 等。Publish 中对应的部分同样由 Plot 实现。

## Publish 主题

阅读下面内容前，最好已阅读 [ 用 Publish 创建博客（一）——入门 ](/zh/posts/publish-1/) ，。

文中提到范例模板可以在 [ GIthub
](https://github.com/fatbobman/PublishThemeForFatbobmanBlog) 处下载。

### 自定义主题

在 Publish 中，主题需要遵循 `HTMLFactory` 协议。如下代码可以定义一个新主题：

    import Foundation
    import Plot
    import Publish

    extension Theme {
        public static var myTheme: Self {
            Theme(
                htmlFactory: MyThemeHTMLFactory<MyWebsite>(),
                resourcePaths: ["Resources/MyTheme/styles.css"]
            )
        }
    }

    private struct MyThemeHTMLFactory<Site: Website>: HTMLFactory {
            // ... 具体的页面，需实现六个方法
    }

    private extension Node where Context == HTML.BodyContext {
            // Node 的定义，比如 header，footer 等
    }

在 pipeline 中使用如下代码指定主题

    .generateHTML(withTheme:.myTheme ), //使用自定义主题

HTMLFactory 协议要求我们必须全部实现六个方法，对应着六种页面，分别是：

- `makeIndexHTML(for index: Index,context: PublishingContext<Site>)`

网站首页，通常是最近文章、热点推荐等等，默认主题中是显式全部 `Item` 列表

- `makeSectionHTML(for section: Section<Site>,context: PublishingContext<Site>)`

当 `Section` 作为 `Item` 容器时的页面。通常显示隶属于该 `Section` 的 `Item` 列表

- `makeItemHTML(for item: Item<Site>, context: PublishingContext<Site>)`

单篇文章（ `Item` ）的显示页面

- `makePageHTML(for page: Page,context: PublishingContext<Site>)`

自由文章（ `Page` ）的显示页面，当 Section 不作为容器时，它的 index. md 也是作为 `Page` 渲染的

- `makeTagListHTML(for page: TagListPage,context: PublishingContext<Site>)`

`Tag` 列表的页面。通常会在此显示站点文章中出现过的全部 `Tag`

- `makeTagDetailsHTML(for page: TagDetailsPage,context: PublishingContext<Site>)`

通常为拥有该 `Tag` 的 `Item` 列表

我们在 MyThemeHTMLFactory 每个方法中，按照上文介绍的 Plot 表述方式进行编写即可。比如：

    func makePageHTML(for page: Page,
                     context: PublishingContext<Site>) throws -> HTML {
        HTML(
            .lang(context.site.language),
            .head(for: page, on: context.site),
            .body(
                .header(for: context, selectedSection: nil),
                .wrapper(.contentBody(page.body)),
                .footer(for: context.site)
                )
            )
        }

`header` 、 `wrapper` 、 `footer` 都是自定义的 `Node`

### 生成机制

Publish 采用工作流机制，通过 [ 范例代码
](https://github.com/fatbobman/PublishThemeForFatbobmanBlog) 来了解一下数据是如何在 `Pipeline` 中操作的。

    try FatbobmanBlog().publish(
        using: [
            .installPlugin(.highlightJS()), //添加语法高亮插件。此插件在 markdown 解析时被调用
            .copyResources(), //拷贝网站所需资源，Resource 目录下的文件
            .addMarkdownFiles(),
            /*逐个读取 Content 下的 markdown 文件，对 markdown 文件进行解析，
            1：解析 metadata，将元数据保存在对应的 Item
            2：对文章中的 markdown 语段逐个解析并转换成 HTML 数据
            3：当碰到 highlightJS 要求处理的 (codeBlocks) 文字块时调用该插件
            4：所有的处理好的内容保存到 PublishingContext 中
            */
            .setSctionTitle(), //修改 section 的显示标题
            .installPlugin(.setDateFormatter()), //为 HTML 输出设置时间显示格式
            .installPlugin(.countTag()), //通过注入，为 tag 增加 tagCount 属性，计算每个 tag 下有几篇文章
            .installPlugin(.colorfulTags(defaultClass: "tag", variantPrefix: "variant", numberOfVariants: 8)), //通过注入，为每 tag 增加 colorfiedClass 属性，返回 css 文件中对应的色彩定义
            .sortItems(by: \.date, order: .descending), //所有文章降序
            .generateHTML(withTheme: .fatTheme), //指定自定义的主题，并在 Output 目录中生成 HTML 文件
            /*
            使用主题模板，逐个调用页面生成方法。
            根据每个方法要求的参数不同，传递对应的 PublishingContext，Item，Scetion 等
            主题方法根据数据，使用 Plot 渲染成 HTML
            比如 makePageHTML 中，显示 page 文章的内容便是通过 page.body 来获取的
            */
            .generateRSSFeed(
                including: [.posts,.project],
                itemPredicate: nil
            ), //使用 Plot 生成 RSS
            .generateSiteMap(), //使用 Plot 生成 Sitemap
        ]
    )

从上面的代码可以看出，使用主题模板生成 HTML 并保存是在整个 Pipeline
的末段，通常情况下，当主题方法调用给定的数据时，数据已经是准备好的。不过由于 Publish 的主题并非描述文件而是标准的程序代码，我们仍可以在最终 `render` 前，对数据再处理。

尽管 Publish 目前提供的页面种类并不多，但即使我们仅使用上述的种类仍可对不同的内容作出完全不同渲染结果。比如：

    func makeSectionHTML(for section: Section<Site>,
                             context: PublishingContext<Site>) throws -> HTML {
        //如果 section 是 posts，则显示完全不同的页面
        if section.id as! Myblog.SectionID == .posts {
                return HTML(
                    postSectionList(for section: Section<Site>,
                    context: PublishingContext<Site>)
                )
        }
        else {
               return HTML(
                    otherSctionList(for section: Section<Site>,
                    context: PublishingContext<Site>)
                )
           }
       }

也可以使用 Plot 提供的控制命令来完成，下面的代码和上面是等效的

    func makeSectionHTML(for section: Section<Site>,
                             context: PublishingContext<Site>) throws -> HTML {
          HTML(
            .if(section.id as! Myblog.SectionID  == .posts,
                  postSectionList(for section: Section<Site>,
                    context: PublishingContext<Site>)
                ,
                else:
                  otherSctionList(for section: Section<Site>,
                    context: PublishingContext<Site>)
               )
            )
        }

总之在 Publish 中用着写普通程序的思路来处理网页即可， **主题不仅仅是描述文件** 。

### 和 CSS 的配合

主题代码定义了对应页面的基本布局和逻辑，更具体的布局、尺寸、色彩、效果等都要在 `CSS` 文件中进行设定。 `CSS`
文件在定义主题时指定（可以有多个）。

如果你是一个有经验的 CSS 使用者，通常没有什么难度。但笔者几乎完全不会使用 CSS，在此次用 Publish 重建 Blog 的过程中，在 CSS
上花费的时间最长、精力最多。

> 请帮忙推荐一个能够整理 css 的工具或者 vscode 插件，由于我在 css 上没有经验所以代码写的很乱，是否有可能将同一层级或类似的 tag
> class 自动调整到一起，便于查找。

### 实战

接下来通过修改两个主题方法来体验一下的开发过程。

#### 准备工作

一开始完全重建所有的主题代码是不太现实的，所以我推荐先从 Publish 自带的默认主题 `foundation` 入手。

完成 [ Publish 创建博客（一）——入门 ](/zh/posts/publish-1/) 中的安装工作

修改 `main.swift`

    enum SectionID: String, WebsiteSectionID {
            // Add the sections that you want your website to contain here:
            case posts
            case about //添加一项，为了演示上方导航条
        }



    $http://cdn myblog
    $publish run

访问 `http://localhost:8000` ，页面差不多这样

![publis-2-defaultIndex](https://cdn.fatbobman.com/publis-2-defaultIndex.png)

在 `Resource` 目录中创建 `MyTheme` 目录。在 XCode 中将 Publish 库中的两个文件 `styles.css`
、 `Theme+Foundation.swift` 拷贝到 `MyTheme` 目录，也可以在 MyTheme 目录中新创建文件后粘贴代码。

    Publish--Resources--FoundatioinTheme-- styles.css



    Publish--Sources--Publish--API-- Theme+Foundation.swift

将 `Theme+Foundation.swift` 改名为 `MyTheme.swift` , 并编辑内容

将：

    private struct FoundationHTMLFactory<Site: Website>: HTMLFactory {

改成：

    private struct MyThemeHTMLFactory<Site: Website>: HTMLFactory {

将

     static var foundation: Self {
            Theme(
                htmlFactory: FoundationHTMLFactory(),
                resourcePaths: ["Resources/FoundationTheme/styles.css"]
            )
     }

改为

    static var myTheme: Self {
            Theme(
                htmlFactory: MyThemeHTMLFactory(),
                resourcePaths: ["Resources/MyTheme/styles.css"]
            )
    }

在 `main.swift` 中

将

    try Myblog().publish(withTheme: .foundation)

改为

    try Myblog().publish(withTheme: .myTheme)

随便在 `Content` 的 `posts` 目录下创建几个 `.md` 文件。比如

Markdown

Copy code

Copied!

    ---
    date: 2021-01-30 19:58
    description: 第二篇
    tags: second, article
    title: My second post
    ---

    hello world
    ...

至此准备完毕，页面看起来差不多是这个样子，创建当前显示页面的是 `makeIndexHTML` 方法。

![publish-2-defaultindex2](https://cdn.fatbobman.com/publish-2-defaultindex2.png)

#### 例子 1：在 makeIndexHTML 中改变 Item Row 的显示内容

当前的 makeIndexHTML 的代码如下：

    func makeIndexHTML(for index: Index,
                           context: PublishingContext<Site>) throws -> HTML {
            HTML(
                .lang(context.site.language),  //<html lang="en"> language 可以在 main.swift 中修改
                .head(for: index, on: context.site), //<head>内容，title 及 meta
                .body(
                    .header(for: context, selectedSection: nil), //上部网站名称 Site.name 及 nav 导航 SectionID
                    .wrapper(
                        .h1(.text(index.title)), // Welcome to MyBlog! 对应 Content--index.md 的 title
                        .p(
                            .class("description"),  //在 styels.css 对应 .description
                            .text(context.site.description) //对应 main.swift 中的 Site.description
                        ),
                        .h2("Latest content"),
                        .itemList(  //自定义 Node，显示 Item 列表，目前 makeIndex makeSection makeTagList 都使用这一个
                            for: context.allItems(
                                sortedBy: \.date, //按创建时间降序，根据 metatdata date
                                order: .descending
                            ),
                            on: context.site
                        )
                    ),
                    .footer(for: context.site) //自定义 Node，显示下部版权信息
                )
            )
        }

在 `makeIndexHTML` 中做如下修改

    .itemList(

改为

    .indexItemList(

在后添加 `.h2("Latesht content")` ，变成如下代码

           .h2("Latesht content"),
           .unwrap(context.sections.first{ $0.id as! Myblog.SectionID == .posts}){ posts in
                  .a(
                      .href(posts.path),
                      .text("显示全部文章")
                     )
                  },

在 `extension Node where Context == HTML.BodyContext` 中进行添加：

        static func indexItemList<T: Website>(for items: [Item<T>], on site: T) -> Node {
            let limit:Int = 2 //设置 index 页面最多显示的 Item 条目数
            let items = items[0...min((limit - 1),items.count)]
            return .ul(
                .class("item-list"),
                .forEach(items) { item in
                    .li(.article(
                        .h1(.a(
                            .href(item.path),
                            .text(item.title)
                        )),
                        .tagList(for: item, on: site),
                        .p(.text(item.description)),
                        .p(item.content.body.node) //添加显示 Item 全文
                    ))
                }
            )
        }

现在 Index 变成如下状态：

![image-20210201135111053](https://cdn.fatbobman.com/publish-2-index-
finish.png)

#### 例子 2：为 makeItemHTML 添加临近文章的导航

本例，我们将在 makeItemHTML 上添加文章导航功能，类似效果如下：

![image-20210201105104706](https://cdn.fatbobman.com/publish-2-item-
navigatore-demo.png)

点击进入任意 Item（文章）

        func makeItemHTML(for item: Item<Site>,
                          context: PublishingContext<Site>) throws -> HTML {
            HTML(
                .lang(context.site.language),
                .head(for: item, on: context.site),
                .body(
                    .class("item-page"),
                    .header(for: context, selectedSection: item.sectionID),
                    .wrapper(
                        .article( //<article>标签
                            .div(
                                .class("content"), //css .content
                                .contentBody(item.body) //.raw(body.html) 显示 item.body.html 文章正文
                            ),
                            .span("Tagged with: "),
                            .tagList(for: item, on: context.site) //下方 tag 列表，forEach(item.tags)
                        )
                    ),
                    .footer(for: context.site)
                )
            )
        }

在代码 `HTML(` 前添加如下内容：

            var previous:Item<Site>? = nil //前一篇 Item
            var next:Item<Site>? = nil //下一篇 Item

            let items = context.allItems(sortedBy: \.date,order: .descending) //获取全部 Item
            /*
            我们当前是获取全部的 Item，可以在获取时对范围进行限定，比如：
            let items = context.allItems(sortedBy: \.date,order: .descending)
                               .filter{$0.tags.contains(Tag("article"))}
            */
            //当前 Item 的 index
            guard let index = items.firstIndex(where: {$0 == item}) else {
                return HTML()
            }

            if index > 0 {
                previous = items[index - 1]
            }

            if index < (items.count - 1) {
                next = items[index + 1]
            }

            return HTML(
              ....

在 `.footer` 前添加

    .itemNavigator(previousItem:previous,nextItem:next),
    .footer(for: context.site)

在 `extension Node where Context == HTML.BodyContext` 中添加自定义 Node `itemNavigator`

       static func itemNavigator<Site: Website>(previousItem: Item<Site>?, nextItem: Item<Site>?) -> Node{
            return
                .div(
                    .class("item-navigator"),
                    .table(
                        .tr(
                            .td(
                                .unwrap(previousItem){ item in
                                    .a(
                                        .href(item.path),
                                        .text(item.title)
                                    )
                                }
                            ),
                            .td(
                                .unwrap(nextItem){ item in
                                    .a(
                                        .href(item.path),
                                        .text(item.title)
                                    )
                                }
                            )
                        )
                    )
                )
        }

在 `styles.css` 中添加

CSS

Copy code

Copied!

    .item-navigator table{
        width:100%;
    }

    .item-navigator td{
        width:50%;
    }

以上代码仅作为概念演示。结果如下：

![publish-2-makeitem-with-
navigator](https://cdn.fatbobman.com/publish-2-makeitem-with-navigator.png)

## 总结

如果你有 SwiftUI 的开发经验，你会发现使用方式非常相似。在 Publish 主题中，你有充足的手段来组织、处理数据，并布局视图（把 `Node`
当做 `View` ）。

Publish 的 `FoundationHTMLFactory` 目前仅定义了六个页面种类，如果想增加新的种类目前有两种方法：

1. Fork Publish，直接扩展它的代码

这种方式最彻底，但维护起来比较麻烦。

2. 在 Pipeline 执行过 `.generateHTML` 后，再执行自定义的 generate Step

无需改动核心代码。 可能会有冗余动作，并且需要在 `FoundationHTMLFactory`
内置方法中做一点处理以便和我们新定义的页面做连接。比如，目前 `index` ， `section list` 都不支持分页（只会输出一个 HTML
文件），我们可以在内置的 `makeIndex` 之后，再重新生成一组分页的 `index` ，并覆盖掉原来的。

在本篇中，我们介绍了如何使用 [ Plot ](https://github.com/JohnSundell/Plot) ，以及如何在 [ Publish
](https://github.com/JohnSundell/Publish) 中定制自己的主题。在下一篇文章中，我们要探讨如何在不改动 Publish
核心代码的情况下，增加各种功能的手段（不仅仅是 Plugin）。

# WWDC 2021 观后感

WWDC 2021 转眼间已经结束一周了。本次 WWDC
苹果一如既往的带来了新的操作系统以及一大堆开发工具、软件架构、网络服务等方面的升级。由于疫情的原因，这两年的 WWDC
都是采用录播形式，不过从视频内容上看，反倒比以前传达地更加精准，对观看者也更加地友善。本文仅从我个人感兴趣的几个角度进行一点介绍，并结合这段时间的学习谈谈使用感受。

## 操作系统

这几年苹果的系统一直保持一种渐进式的升级态势，即使是大版本号升级通常并不会给人特别大的惊喜和改变。不过也正是在这种逐步的变化中，苹果不断的将它多个系统的联系变得更加紧密，生态建设的愈发完善。网上已经有了大量关于系统新功能的文章，所以我仅从自己的使用上谈几点感受。

iOS 15 在旧设备上的效率相当不错（我在一台 iPhone 7 上进行了安装）。相较于 iPhone，iPad
上对于多任务、多窗口的交互提升观感更明显。在后期软件适配跟上的情况下，iPad 应用或许会有一个新的爆发。Monterey 第一个版本的稳定度明显好于去年的
Big Sur，界面细节的统一性也不错。相较于去年的大规模 UI 改变，今年在 UI 上更多是完善和细节改进。watchOS 8
我没有在实机上测试，我对它新的体能训练类型以及睡眠呼吸率比较感兴趣。

抛开表面功能，因为今年苹果在 Swift 语言以及系统框架的大规模提升，相信不久后适配了新框架和新服务的 App
在新系统上会有很不一样的表现。由于今年绝大多数的 Swift
语言层面、框架层面的新功能都不会下放到老版本的操作系统，所以估计苹果也会继续加大力度促使用户升级。好在，新系统对硬件的涵盖比较广，和最近几年的系统对硬件需求差不多，估计用户的系统更新速度应该会比较快。

## Swift

Swift 5.5 可以说是在 5.0 发布以后最重大的更新。在今年 Swift 重构了异步和多线程的解决方案，并提供了 `结构式多线程` 、 `Actor` 等重磅功能。

Swift 5.5 目前提供的异步、多线程方式对于开发者来说非常友好，从最近的使用来看不仅上手容易，而且可以让自己的代码在极短的时间中受益。目前距离
Swift 5.5 正式发布还有一段时间，除了不可避免的 Bug 外，关键字、语法等也还在不断变化中。Xcode 13 beta 1 中的 Swift
Toolchain 关于异步调用语法已经和最近的 snapshot 中有不小的改变。尽管如此，我还是推荐每一个 Swift
开发者都能够尽快地了解这些新的工具、模式，进而可以从另一个角度来思考编程的逻辑。关于异步、多线程的部分，我会在接下来一段时间写几篇文章做更多的介绍。

另一个让我非常有感的 Swift 增强是在 `通用上下文中扩展了静态成员的查找` 功能。这个看似不大的改动将极大地提高了 `自动补全`
的表现。官方框架已经对该功能做了充分适配，使用 Xcode 13 你会感慨原来自动补全也可以这么好用。

相较于第一个重磅功能，其他的如 `#if` 表达式、 `本地化的 lazy` 、 `属性包装器可用于函数` 、 `枚举适配编码` 、 `Double—CGFloat 相互转换` 等只能说是正常提升了。

## SwiftUI

学习和使用下来的总体感觉是继续补强和规范。

如果单看 Keynote，你会感觉好像苹果为 SwiftUI
带来了好多新的能力，不过仔细分析后会发现其中绝大多数都已经有较成熟的第三方解决方案了，当然官方的方案确实设计的统一性较好且实现地很优雅，相信这也将影响不少的
SwiftUI 三方库作者。提几个我个人感触较大的改进：

- **输入的全面提升** 。从 `Formatter 绑定` 到 `focusedState` 的添加，从 `onsubmit` 到 `submitLable` 以及 Toolbar 中的 `keyboard placement` ，总之全平台上的输入逻辑和设计都有了令人欣喜的提高。官方的方案如果单看某个平台的表现未必最好，不过它的多平台适配能力确实令人佩服。
- **异步概念的全面导入** 。 `task` 、 `refreshable` 中都是直接可以执行异步代码的上下文。由于 Swift 5.5 异步编程的简化，苹果在各个框架上都会强力引导开发者采用异步、多线程的方式进行编程。
- **富文本和符号的增强** 。Text 中可以直接使用 `Markdown` 符号，尤其是新增的 `AttributedString` ，开发者可以自定义 Markdown 符号（使用效果非常好，有很高的想象空间）。Text + AttributedString 解决了 SwiftUI 上富文本一个非常大的短板。 `SF 3.0` 近一步增加了符号种类，添加了更多的渲染方式，为我这样的个人开发者进一步减轻了美工压力。其他如文本动态尺寸限制、符号变体等也都比较有特点。
- **样式化趋势明显** 。将一些之前需要定义颜色、尺寸等多个步骤的工作统一成 style。同时也添加了 `Material` 样式。苹果在 SwiftUI 上喜欢为各个控件使用类似 `xxxstyle` 来定义它的样式，得益于 Swift 5.5 的静态成员查找能力，在代码中调用样式更加方便。这个也会很快在第三方控件上体现出来。
- **列表的全面补强** 。List 作为使用量巨大的控件一直以来在 SwiftUI 上都有诸多的不足。此次更新添加了诸多期待已久的功能并且调用的方式很 SwiftUI 化。 `ForEach` 可以使用绑定数据、 `searchable` 搜索解决方案、swipeAction 的侧滑按钮等等，使得以前只能通过重新包装、数据注入才能解决的问题，多数可以直接使用官方提供的方案。另外值得一提的是，终于可以取消分割线了。 `Section` 的加入为数据的组织方式添加了更多的选项。
- **按钮的全方位提升** 。此次 SwiftUI 为各类 Button 提供了非常好的扩展，比如 `controlGroup` 在各个不同平台的不同呈现，通过 `buttonStyle` 、 `controlSize` 、 `controlProminece` 、 `role:` 等等仅用几行代码便可以获得官方美工级别的按钮样式， `Menu` 也支持了二级菜单，并且为 mac 平台添加了 `.button` 的 style 等等。总之在本次版本中按钮呈现的改进是当今任何第三方开发者都没能达到的高度。
- **CoreData 配合度近一步提高** 。@fetchRequest 终于支持动态修改 sortDescripte 和 predicate 了，另外配合 Section 新增了 `@SectionedFetchRequest` ，极大的提升了 List 的表现能力。
- 其他比较有特点的还有： `Canvas` 、 `TimeLineView` 、 `confirmationDialog` 等等众多的新功能。

其中绝大多数的功能，我在之后会通过文章更详细的和大家分享。

> 遗憾的是，NavigationView 没有在此次升级中补强。

另外，在本次 WWDC 上的 [ Demystify SwiftUI
](https://developer.apple.com/videos/play/wwdc2021/10022/)
绝对不容错过，通过对身份、生命周期、依赖的详细讲述让开发者了解 SwiftUI 的开发哲学及核心原则，并掌握如何使用它们来保证应用程序的准确和性能。

## CoreData + Cloudkit

CoreData 在今年的改动不多，主要体现在对同步和多线程的支持上。在本次 WWDC 之前坊间传闻并期望的 SwiftData 并没有出现。不过
Cloudkit 今年还是给我带来了巨大的惊喜： `支持了本地化操作的 Share 数据库` 。

在 2019 年，通过 `NSPersistentCloudKitContainer` 苹果打通了 Coredata 同 cloudkit
上的私有库，去年带来了公有库的本地化，今年终于将最后的短板补齐，让开发者可以轻松实现 app 用户同其他的 icloud
用户实时分享数据。为了实现这个功能，Cloudkit 改善了它同本地数据的同步机制，响应不像去年的公共库同步那么迟钝。在今年 WWDC 众多的新功能中， `Share Data` 是我一直最想要的功能！

## Xcode

首先最直观的感觉很多的 `图标` 变得比以前精致了。 `Xcode Cloud`
看起来不错，但对于个人开发者的我来说还没有什么特别大的吸引力。如果你是 Vim 用户，一定会对 `Vim 模式` 的到来感到兴奋。 `版本控制`
终于得到了提升，不仅在功能上，即使在界面布局上也看出了此次苹果对于版本控制重要性的认识有了提高。得益于 Swift
的改进，代码补全、错误提示比之前有了不小的进步（测试版中，错误提示还是有点诡异的）。最后，有两个并不完全属于 Xcode 的功能反倒值得特别注意：

- 集成了 `Swift Package Collection` 。本次苹果推出了 Swift Package Collection，为用户分享和组织第三方库提供了新的选择。Xcode 已经全面集成了对此的支持。
- 全面集成 `Docc` 。我从 2019 年开始接触 mac 编程，当时的苹果的文档内容并不丰富，这两年有了不小的进步。在第一次看到 SwiftUI 的官方的交互式教程时我相当震惊，希望将来会有更多的类似文档资料。今年，苹果开发了 Docc，一个可以直接从代码构建美丽、交互式和原生文档的新工具。使用它，很轻松地就可以开发出类似苹果官方文档质量的文档集合。苹果在今年内会将其开源，届时即使是其他平台的 IDE 或者其他的开发语言都可以使用它进行文档工作。

## 其他

WWDC 涉及的领域实在是太多了，大多数的 Session 我都没有时间观看和学习。除了上面提到的变化外，我额外关注了 Foundation
在今年的变化。苹果着重介绍了 `AttributedString` 和 `Formatter` 。AttributedString
绝对是接下来在苹果开发生态中富文本的主力，Formatter 对国际化、本地化的支持也达到了空前的高度。另外，从 SwiftUI 的 Text 和
TextField 都可以直接使用 Formatter 的情况来看，苹果将来会在其官方框架中增加对开发人员的引导。

## 关于 WWDC 的资料

下面是我观看和学习 WWDC 中使用的一些资源：

- Developer (mac AppStore 和 iOS appStore 都可以下载）。推荐使用这个 app 来观看视频，可以点击每个 Session 的旁白或代码片段快速跳转到对应视频片段
- [ WWDC 官方演示代码 ](https://developer.apple.com/sample-code/wwdc/2021/) 在此网址可以查询视频中提及的演示项目的完整代码
- [ WWDC NOTES ](https://www.wwdcnotes.com) 各个 Essential 的图文整理
- [ HackingWithSwift ](https://www.hackingwithswift.com) 以及他的油管频道
- [ WWDC21Lounges ](https://roblack.github.io/WWDC21Lounges) 的 QA 汇总

# 为自定义属性包装类型添加类 @Published 的能力

本文将对 @Published 与符合 ObservableObject 协议的类实例之间的沟通机制做以介绍，并通过三个示例：@MyPublished（
@Published 的仿制版本 ）、@PublishedObject（包装值为引用类型的 @Published 版本）、@CloudStorage（类似
@AppStorage ，但适用于 NSUbiquitousKeyValueStore
），来展示如何为其他的自定义属性包装类型添加可访问包裹其的类实例的属性或方法的能力。

## 何为 @Published 的能力

@Published 是 Combine 框架中最常用到的属性包装器。通过 @Published 标记的属性在发生改变时，其订阅者（通过 `$` 或 `projectedValue` 提供的 Publisher ）将收到即将改变的值。

> 不要被它名称尾缀的 `ed` 所迷惑，它的发布时机是在改变前（ `willSet` ）

    class Weather {
        @Published var temperature: Double
        init(temperature: Double) {
            self.temperature = temperature
        }
    }

    let weather = Weather(temperature: 20)
    let cancellable = weather.$temperature
        .sink() {
            print ("Temperature now: \($0)")
    }
    weather.temperature = 25

    // Temperature now: 20.0
    // Temperature now: 25.0

而在符合 ObservableObject 协议的类中，通过 @Published 标记的属性在发生改变时，除了会通知自身 Publisher
的订阅者外，也会通过包裹它的类实例的 objectWillChange 来通知类实例（ 符合 ObservableObject
协议）的订阅者。这一特性，也让 @Published 成为 SwiftUI 中最有用的属性包装器之一。

    class Weather:ObservableObject {  // 遵循 ObservableObject
        @Published var temperature: Double
        init(temperature: Double) {
            self.temperature = temperature
        }
    }

    let weather = Weather(temperature: 20)
    let cancellable = weather.objectWillChange // 订阅 weather 实例的 obejctWillChange
        .sink() { _ in
            print ("weather will change")
    }
    weather.temperature = 25

    // weather will change

仅从调用包裹其类的 objectWillChange 的时机来讲，下面的代码与上面的代码的表现是一样的，但在 @Published 的版本中，
**我们并没有为 @Published 提供包裹其类的实例，它是隐式获得的** 。

    class Weather:ObservableObject {
        var temperature: Double{  // 没有使用 @Published 进行标记
            willSet {  // 改变前调用类实例的 objectWillChange
                self.objectWillChange.send()  // 在代码中明确地引用了 Weahter 实例
            }
        }
        init(temperature: Double) {
            self.temperature = temperature
        }
    }

    let weather = Weather(temperature: 20)
    let cancellable = weather.objectWillChange // 订阅 weather 实例
        .sink() { _ in
            print ("weather will change")
    }
    weather.temperature = 25

    // weather will change

长期以来，我一直将 @Published 调用包裹其类的实例方法的行为视为理所当然，从未认真想过它是如何实现的。直到我发现除了 @Published
外，@AppStorage 也具备同样的行为（参阅 [ @AppStorage 研究 ](/zh/posts/appstorage/)
），此时我意识到或许我们可以让其他的属性包装类型具备类似的行为，创建更多的使用场景。

本文中为其他属性包装类型添加的类似 @Published 的能力是指 —— **无需显式设置，属性包装类型便可访问包裹其的类实例的属性或方法** 。

## @Published 能力的秘密

### 从 Proposal 中找寻答案

我之前并不习惯于看 swift-evolution 的 [ proposal ](https://github.com/apple/swift-
evolution/tree/main/proposals) ，因为每当 Swift 推出新的语言特性后，很多像例如 [ Paul Hudson
](https://www.hackingwithswift.com/)
这样的优秀博主会在第一时间将新特性提炼并整理出来，读起来又快又轻松。但为一个语言添加、修改、删除某项功能事实上是一个比较漫长的过程，期间需要对提案不断地进行讨论和修改。proposal
将该过程汇总成文档供每一个开发者来阅读、分析。因此，如果想详细了解某一项 Swift 新特性的来龙去脉，最好还是要认真阅读与其对应的 proposal
文档。

在有关 Property Wrappers 的文档中，对于如何在属性包装类型中引用包裹其的类实例是有特别提及的 —— [ Referencing the
enclosing ‘self’ in a wrapper type ](https://github.com/apple/swift-
evolution/blob/main/proposals/0258-property-wrappers.md#referencing-the-
enclosing-self-in-a-wrapper-type) 。

提案者提出：通过让属性包装类型提供一个静态下标方法，以实现对包裹其的类实例的自动获取（无需显式设置）。

    // 提案建议的下标方法
    public static subscript<OuterSelf>(
            instanceSelf: OuterSelf,
            wrapped: ReferenceWritableKeyPath<OuterSelf, Value>,
            storage: ReferenceWritableKeyPath<OuterSelf, Self>) -> Value

虽然此种方式是在 proposal 的未来方向一章中提及的，但 Swift 已经对其提供了支持。不过，文档中的代码与 Swift
当前的实现并非完全一致，幸好有人在 stackoverflow 上提供了该下标方法的正确参数名称：

    public static subscript<OuterSelf>(
            _enclosingInstance: OuterSelf, // 正确的参数名为 _enclosingInstance
            wrapped: ReferenceWritableKeyPath<OuterSelf, Value>,
            storage: ReferenceWritableKeyPath<OuterSelf, Self>
        ) -> Value

@Published 就是通过实现了该下标方法从而获得了“特殊”能力。

### 属性包装器的运作原理

考虑到属性包装器中的包装值（ wrappedValue ）众多的变体形式，Swift 社区并没有采用标准的 Swift
协议的方式来定义属性包装器功能，而是让开发者通过声明属性 @propertyWrapper 来自定义属性包装类型。与 [ 掌握 Result
builders ](/zh/posts/viewbuilder1/) 一文中介绍的 @resultBuilder
类似，编译器在最终编译前，首先会对用户自定义的属性包装类型代码进行转译。

    struct Demo {
        @State var name = "fat"
    }

上面的代码，编译器将其转译成：

    struct Demo {
        private var _name = State(wrappedValue: "fat")
        var name: String {
            get { _name.wrappedValue }
            set { _name.wrappedValue = newValue }
        }
    }

可以看出 propertyWrapper
没有什么特别的魔法，就是一个语法糖。上面的代码也解释了为什么在使用了属性包装器后，无法再声明相同名称（前面加下划线）的变量。

    // 在使用了属性包装器后，无法再声明相同名称（前面加下划线）的变量。
    struct Demo {
        @State var name = "fat"
        var _name:String = "ds"  // invalid redeclaration of synthesized property '_name'
    }
    // '_name' synthesized for property wrapper backing storage

当属性包装类型仅提供了 wrappedValue 时（比如上面的 State ），转译后的 getter 和 setter 将直接使用
wrappedValue ，不过一旦属性包装类型实现了上文介绍的静态下标方法，转译后将变成如下的代码：

    class Test:ObservableObject{
        @Published var name = "fat"
    }

    // 转译为
    class Test:ObservableObject{
        private var _name = Published(wrappedValue: "fat")
        var name:String {
            get {
                Published[_enclosingInstance: self,
                                     wrapped: \Test.name,
                                     storage: \Test._name]
            }
            set {
                Published[_enclosingInstance: self,
                                     wrapped: \Test.name,
                                     storage: \Test._name] = newValue
            }
        }
    }

> 当属性包装器实现了静态下标方法且被 **类** 所包裹时，编译器将 **优先使用静态下标方法** 来实现 getter 和 setter 。

下标方法的三个参数分别为：

- \_enclosingInstance

包裹当前属性包装器的类实例

- wrapped

对外计算属性的 KeyPath （上面代码中对应 name 的 KeyPath ）

- storage

内部存储属性的 KeyPath （上面代码中对应 \_name 的 KeyPath ）

> 在实际使用中，我们只需使用 \_enclosingInstance 和 storage 。尽管下标方法提供了 wrapped
> 参数，但我们目前无法调用它。读写该值都将导致应用锁死

通过上面的介绍，我们可以得到以下结论：

- @Published 的“特殊”能力并非其独有的，与特定的属性包装类型无关
- 任何实现了该静态下标方法的属性包装类型都可以具备本文所探讨的所谓“特殊”能力
- 由于下标参数 wrapped 和 storage 为 ReferenceWritableKeyPath 类型，因此只有在属性包装类型被类包裹时，编译器才会转译成下标版本的 getter 和 setter

> 可以在此处获得 [ 本文的范例代码
> ](https://github.com/fatbobman/BlogCodes/tree/main/Published)

## 从模仿中学习 —— 创建 @MyPublished

实践是检验真理的唯一标准。本节我们将通过对 @Published 进行复刻来验证上文中的内容。

因为代码很简单，所以仅就以下几点做以提示：

- @Published 的 projectedValue 的类型为 `Published.Publisher<Value,Never>`
- 通过对 CurrentValueSubject 的包装，即可轻松地创建自定义 Publisher
- 调用包裹类实例的 objectWillChange 和给 projectedValue 的订阅者发送信息均应在更改 wrappedValue 之前

  @propertyWrapper
  public struct MyPublished<Value> {
  public var wrappedValue: Value {
  willSet { // 修改 wrappedValue 之前
  publisher.subject.send(newValue)
  }
  }

      public var projectedValue: Publisher {
          publisher
      }

      private var publisher: Publisher

      public struct Publisher: Combine.Publisher {
          public typealias Output = Value
          public typealias Failure = Never

          var subject: CurrentValueSubject<Value, Never> // PassthroughSubject 会缺少初始话赋值的调用

          public func receive<S>(subscriber: S) where S: Subscriber, Self.Failure == S.Failure, Self.Output == S.Input {
              subject.subscribe(subscriber)
          }

          init(_ output: Output) {
              subject = .init(output)
          }
      }

      public init(wrappedValue: Value) {
          self.wrappedValue = wrappedValue
          publisher = Publisher(wrappedValue)
      }

      public static subscript<OuterSelf: ObservableObject>(
          _enclosingInstance observed: OuterSelf,
          wrapped wrappedKeyPath: ReferenceWritableKeyPath<OuterSelf, Value>,
          storage storageKeyPath: ReferenceWritableKeyPath<OuterSelf, Self>
      ) -> Value {
          get {
              observed[keyPath: storageKeyPath].wrappedValue
          }
          set {
              if let subject = observed.objectWillChange as? ObservableObjectPublisher {
                  subject.send() // 修改 wrappedValue 之前
                  observed[keyPath: storageKeyPath].wrappedValue = newValue
              }
          }
      }

  }

现在，@MyPublished 拥有与 @Published 完全一样的功能与行为表现：

    class T: ObservableObject {
        @MyPublished var name = "fat" // 将 MyPublished 替换成 Published 将获得同样的结果
        init() {}
    }

    let object = T()

    let c1 = object.objectWillChange.sink(receiveValue: {
        print("object will changed")
    })
    let c2 = object.$name.sink{
        print("name will get new value \($0)")
    }

    object.name = "bob"

    // name will get new value fat
    // object will changed
    // name will get new value bob

> 下文中我们将演示如何将此能力应用到其他的属性包装类型

## @PublishedObject —— @Published 的引用类型版本

@Published 只能胜任包装值为 **值类型** 的场景，当 wrappedValue
为引用类型时，仅改变包装值的属性内容并不会对外发布通知。例如下面的代码，我们不会收到任何提示：

    class RefObject {
        var count = 0
        init() {}
    }

    class Test: ObservableObject {
        @Published var ref = RefObject()
    }

    let test = Test()
    let cancellable = test.objectWillChange.sink{ print("object will change")}

    test.ref.count = 100
    // 不会有提示

为此，我们可以实现一个适用于引用类型的 @Published 版本 —— @PublishedObject

提示：

- @PublishedObject 的 wrappedValue 为遵循 ObservableObject 协议的引用类型
- 在属性包装器中订阅 wrappedValue 的 objectWillChange ，每当 wrappedValue 发生改变时，将调用指定的闭包
- 在属性包装器创建后，系统 **会立刻调用静态下标的 getter 一次** ，选择在此时机完成对 wrappedValue 的订阅和闭包的设置

  @propertyWrapper
  public struct PublishedObject<Value: ObservableObject> { // wrappedValue 要求符合 ObservableObject
  public var wrappedValue: Value

      public init(wrappedValue: Value) {
          self.wrappedValue = wrappedValue
      }

      public static subscript<OuterSelf: ObservableObject>(
          _enclosingInstance observed: OuterSelf,
          wrapped wrappedKeyPath: ReferenceWritableKeyPath<OuterSelf, Value>,
          storage storageKeyPath: ReferenceWritableKeyPath<OuterSelf, Self>
      ) -> Value where OuterSelf.ObjectWillChangePublisher == ObservableObjectPublisher {
          get {
              if observed[keyPath: storageKeyPath].cancellable == nil {
                  // 只会执行一次
                  observed[keyPath: storageKeyPath].setup(observed)
              }
              return observed[keyPath: storageKeyPath].wrappedValue
          }
          set {
              observed.objectWillChange.send() // willSet
              observed[keyPath: storageKeyPath].wrappedValue = newValue
          }
      }

      private var cancellable: AnyCancellable?
      // 订阅 wrappedvalue 的 objectWillChange
      // 每当 wrappedValue 发送通知时，调用 _enclosingInstance 的 objectWillChange.send。
      // 使用闭包对 _enclosingInstance 进行弱引用
      private mutating func setup<OuterSelf: ObservableObject>(_ enclosingInstance: OuterSelf) where OuterSelf.ObjectWillChangePublisher == ObservableObjectPublisher {
          cancellable = wrappedValue.objectWillChange.sink(receiveValue: { [weak enclosingInstance] _ in
              (enclosingInstance?.objectWillChange)?.send()
          })
      }

  }

@PublishedObject 为我们提供了更加灵活的能力来驱动 SwiftUI 的视图，比如我们可以这样使用 @PublishedObject ：

    @objc(Event)
    public class Event: NSManagedObject { // Core Data 的托管对象符合 ObservableObject 协议
        @NSManaged public var timestamp: Date?
    }

    class Store: ObservableObject {
        @PublishedObject var event = Event(context: container.viewContext)

        init() {
            event.timestamp = Date().addingTimeInterval(-1000)
        }
    }

    struct DemoView: View {
        @StateObject var store = Store()
        var body: some View {
            VStack {
                Text(store.event.timestamp, format: .dateTime)
                Button("Now") {
                    store.event.timestamp = .now
                }
            }
            .frame(width: 300, height: 300)
        }
    }

![publishedObject_demo1_2022-05-15_09.28.41.2022-05-15
09_29_23](https://cdn.fatbobman.com/publishedObject_demo1_2022-05-15_09.28.41.2022-05-15%2009_29_23.gif)

## @CloudStorage —— @AppStorage 的 CloudKit 版本

在 [ @AppStorage 研究 ](/zh/posts/appstorage/) 一文中，我介绍过，除了 @Published
外，@AppStorage 也同样具备引用包裹其的类实例的能力。因此，我们可以使用如下的代码在 SwiftUI 中统一管理 UserDefaults ：

    class Defaults: ObservableObject {
        @AppStorage("name") public var name = "fatbobman"
        @AppStorage("age") public var age = 12
    }

Tom Lokhorst 写了一个类似 @AppStorage 的第三方库 —— @CloudStorage ，实现了在
NSUbiquitousKeyValueStore 发生变化时可以驱动 SwiftUI 视图的更新：

    struct DemoView: View {
        @CloudStorage("readyForAction") var readyForAction: Bool = false
        @CloudStorage("numberOfItems") var numberOfItems: Int = 0
        var body: some View {
            Form {
                Toggle("Ready", isOn: $readyForAction)
                    .toggleStyle(.switch)
                TextField("numberOfItems",value: $numberOfItems,format: .number)
            }
            .frame(width: 400, height: 400)
        }
    }

我们可以使用本文介绍的方法为其添加了类似 @Published 的能力。

> 在撰写 [ 在 SwiftUI 下使用 NSUbiquitousKeyValueStore 同步数据
> ](/zh/posts/nsubiquitouskeyvaluestore/)
> 一文的时候，我尚未掌握本文介绍的方法。当时只能采用一种比较笨拙的手段来与包裹 @CloudStorage
> 的类实例进行通信。现在我已用本文介绍的方式重新修改了 @CloudStorage 代码。由于 @CloudeStorage
> 的作者尚未将修改后的代码合并，因此大家目前可以暂时使用我 [ 修改后的 Fork 版本
> ](https://github.com/fatbobman/CloudStorage) 。

代码要点：

- 由于设置的 projectValue 和 \_setValue 的工作是在 CloudStorage 构造器中进行的，此时只能捕获为 nil 的闭包 sender ，通过创建一个类实例 holder 来持有闭包，以便可以通过下标方法为 sender 赋值。
- 注意 `holder?.sender?()` 的调用时机，应与 willSet 行为一致

  @propertyWrapper public struct CloudStorage<Value>: DynamicProperty {
  private let \_setValue: (Value) -> Void

      @ObservedObject private var backingObject: CloudStorageBackingObject<Value>

      public var projectedValue: Binding<Value>

      public var wrappedValue: Value {
          get { backingObject.value }
          nonmutating set { _setValue(newValue) }
      }

      public init(keyName key: String, syncGet: @escaping () -> Value, syncSet: @escaping (Value) -> Void) {
          let value = syncGet()

          let backing = CloudStorageBackingObject(value: value)
          self.backingObject = backing
          self.projectedValue = Binding(
              get: { backing.value },
              set: { [weak holder] newValue in
                  backing.value = newValue
                  holder?.sender?() // 注意调用时机
                  syncSet(newValue)
                  sync.synchronize()
              })
          self._setValue = { [weak holder] (newValue: Value) in
              backing.value = newValue
              holder?.sender?()
              syncSet(newValue)
              sync.synchronize()
          }

          sync.setObserver(for: key) { [weak backing] in
              backing?.value = syncGet()
          }
      }

      // 因为设置的 projectValue 和 _setValue 的工作是在构造器中进行的，无法仅捕获闭包 sender（当时还是 nil），创建一个类实例来持有闭包，以便可以通过下标方法配置。
      class Holder{
          var sender: (() -> Void)?
          init(){}
      }

      var holder = Holder()

      public static subscript<OuterSelf: ObservableObject>(
          _enclosingInstance observed: OuterSelf,
          wrapped wrappedKeyPath: ReferenceWritableKeyPath<OuterSelf, Value>,
          storage storageKeyPath: ReferenceWritableKeyPath<OuterSelf, Self>
      ) -> Value {
          get {
              // 设置 holder 的时机和逻辑与 @PublishedObject 一致
              if observed[keyPath: storageKeyPath].holder.sender == nil {
                  observed[keyPath: storageKeyPath].holder.sender = { [weak observed] in
                      (observed?.objectWillChange as? ObservableObjectPublisher)?.send()
                  }
              }
              return observed[keyPath: storageKeyPath].wrappedValue
          }
          set {
              if let subject = observed.objectWillChange as? ObservableObjectPublisher {
                  subject.send()
                  observed[keyPath: storageKeyPath].wrappedValue = newValue
              }
          }
      }

  }

使用修改后的代码，可以将 @AppStorage 和 @CloudStorage 统一管理，以方便在 SwiftUI 视图中使用：

    class Settings:ObservableObject {
           @AppStorage("name") var name = "fat"
           @AppStorage("age") var age = 5
           @CloudStorage("readyForAction") var readyForAction = false
           @CloudStorage("speed") var speed: Double = 0
    }

    struct DemoView: View {
        @StateObject var settings = Settings()
        var body: some View {
            Form {
                TextField("Name", text: $settings.name)
                TextField("Age", value: $settings.age, format: .number)
                Toggle("Ready", isOn: $settings.readyForAction)
                    .toggleStyle(.switch)
                TextField("Speed", value: $settings.speed, format: .number)
                Text("Name: \(settings.name)")
                Text("Speed: ") + Text(settings.speed, format: .number)
                Text("ReadyForAction: ") + Text(settings.readyForAction ? "True" : "False")
            }
            .frame(width: 400, height: 400)
        }
    }

![cloudStorage_demo_2022-05-15_09.41.31.2022-05-15
09_42_28](https://cdn.fatbobman.com/cloudStorage_demo_2022-05-15_09.41.31.2022-05-15%2009_42_28.gif)

## 总结

很多东西在我们对其不了解时，常将其视为黑魔法。但只要穿越其魔法屏障就会发现，或许并没有想象中的那么玄奥。

希望本文能够对你有所帮助。

# 如何在 SwiftUI 中创建一个实时响应的 Form

我的 app 健康笔记主要是对数据的收集、管理，所以对于表单的实时检查、响应的要求比较高。因此制作一个对用于输入响应及时、反馈准确的 Form
十分重要。本文尝试提出一个 SwiftUI 下的 Form 开发思路。

## 健康笔记 1.0 的时候

在开发健康笔记 1.0 的使用，当时由于 iOS 13 尚不支持 onChange，当时主要使用类似的检查方式：

## 对于简单情况

    @State var name = ""

    TextField("name",text:$name)
         .foregroundColor(name.count.isEmpty ? .red : .black)

## 稍复杂的情况

    @State var name = ""
    @State var age = ""

    TextField("name",text:$name)
        .foregroundColor(!checkName() ? .red : .black)
    TextField("age",text:$name)
         .keyboardType(.decimalPad)
         .foregroundColor(!checkAge() ? .red : .black)

    Button("Save"){
       //保存
    }
    .disable(!(checkName()&&checkeAge))

    func chekcName() -> Bool {
       return name.count > 0 && name.count <= 10
    }

    func checkAge() -> Bool {
       guard let age = Double(age) else {return false}
       return age > 10 && age < 20
    }

其实之前对于很复杂的表单，我也是采用了 Combine 的方式来做验证的。

不过 Publisher 的和 View
的刷新周期之间有一个响应的差距，也就是说，第一个输入的判断需要到第二个输入时才会返回结果。如此一来，只能将判断逻辑都写在 View
中。不过如果需要利用网络验证的部分，仍然是使用 Publisher 来处理的。它的响应由于使用 OnReceive 所以不会出现上面的判断时间差。

## 健康笔记 2.0 的处理方式

在我目前开发的健康笔记 2.0 中，由于 iOS 14 支持了 onChange, 让开发者在 View 有了非常方便的处理逻辑判断的时机。

以下是目前开发中的画面：

![demo](https://cdn.fatbobman.com/swiftui-form-formDemo.gif)

## 用 MVVM 的方式来编写 Form

在使用 SwiftUI 进行开发中，我们不仅需要使用 MVVM 的思想来考虑 app 的架构，对于每一个 View 都可以把它当做一个 mini 的 app
来对待。

在下面的例子中，我们需要完成如下的功能：

1. 显示档案、编辑档案、新建档案都使用同一个代码
2. 对于用户的每一次输入都给出及时和准确的反馈
3. 只有用户的数据完全满足需求时（各个输入项都满足检查条件同时在编辑状态下，当前修改数据要与原始数据不同），才允许用户保存。
4. 如果用户已经修改或创建了数据，用户取消时需要二次确认
5. 在用户显示档案时，可以一键切换到编辑模式

_如果你所需要创建的 FormView 功能简单，请千万不要使用下列的方法。下列代码仅在创建较复杂的表单时才会发挥优势。_

完成后的视频如下：

![demo](https://cdn.fatbobman.com/swiftui-form-studentDemo.gif)

下载 （当前代码已和 [ 在 SwiftUI 中制作可以控制取消手势的 Sheet
](https://zhuanlan.zhihu.com/p/245663226) 合并）

[ 源代码 ](https://github.com/fatbobman/DismissConfirmSheet)

为输入准备数据源

不同于创建多个@State 数据源来处理数据，我现在将所有需要录入的数据统一放到了一个数据源中

    struct MyState:Equatable{
        var name:String
        var sex:Int
        var birthday:Date
    }

让 View 响应不同的动作

    enum StudentAction{
        case show,edit,new
    }

**有了上述的准备，我们便可以创建表单的构造方法了：**

    struct StudentManager: View {
        @EnvironmentObject var store:Store
        @State var action:StudentAction
        let student:Student?

        private let defaultState:MyState  //用于保存初始数据，可以用来比较，或者在我的 app 中，可以恢复用户之前的值
        @State private var myState:MyState //数据源

        @Environment(\.presentationMode) var presentationMode

    init(action:StudentAction,student:Student?){
            _action = State(wrappedValue: action)
            self.student = student

            switch action{
            case .new:
                self.defaultState = MyState(name: "",sex:0, birthday: Date())
                _myState = State(wrappedValue: MyState(name: "", sex:0, birthday: Date()))
            case .edit,.show:
                self.defaultState = MyState(name: student?.name ?? "", sex:Int(student?.sex ?? 0) , birthday: student?.birthday ?? Date())
                _myState = State(wrappedValue: MyState(name: student?.name ?? "", sex:Int(student?.sex ?? 0), birthday: student?.birthday ?? Date()))
            }
        }

    }

准备表单显示内容

    func nameView() -> some View{
            HStack{
                Text("姓名：")
                if action == .show {
                    Spacer()
                    Text(defaultState.name)
                }
                else {
                    TextField("学生姓名",text:$myState.name)
                        .multilineTextAlignment(.trailing)
                }
            }
        }

合成显示内容

    Form{
                 nameView()
                 sexView()
                 birthdayView()
                 errorView()
          }

对每个输入项目进行验证

    func checkName() -> Bool {
            if myState.name.isEmpty {
                errors.append("必须填写姓名")
                return false
            }
            else{
                return true
            }
        }

处理所有的验证信息

    func checkAll() -> Bool {
            if action == .show {return true}
            errors.removeAll()
            let r1 = checkName()
            let r2 = checkSex()
            let r3 = checkBirthday()
            let r4 = checkChange()
            return r1&&r2&&r3&&r4
        }

通过 onChange 来进行校验

    .onChange(of: myState){ _ in
             confirm =  checkAll()
           }
    //由于 onChange 必须在数据源发生变化时才会激发，所以在 View 最初显示时便进行一次验证
    .onAppear{
         confirm =  checkAll()
       }

对 toolbar 的内容进行处理

    ToolbarItem(placement: ToolbarItemPlacement.navigationBarTrailing){
                        if action == .show {
                            Button("编辑"){
                                action = .edit
                                confirm = false
                            }
                        }
                        else {
                        Button("确定"){
                            if action == .new {
                            presentationMode.wrappedValue.dismiss()
                            store.newStudent(viewModel: myState)
                            }
                            if action == .edit{
                                presentationMode.wrappedValue.dismiss()
                                store.editStudent(viewModel: myState, student: student!)
                            }
                        }
                        .disabled(!confirm)
                        }

更详尽的内容可以参看 [ 源代码 ](https://github.com/fatbobman/DismissConfirmSheet)

# 如何在 SwiftUI 中实现 interactiveDismissDisabled

本文中我们将探讨如何实现一个 SwiftUI 3.0 中新增功能——interactiveDismissDisabled 的增强版；如何创建更
SwiftUI 化的功能扩展。

## 需求

由于 [ 健康笔记 ](/healthnotes/) 中数据录入都是在 Sheet 中进行的，为了防止用户在录入过程中由于误操作（使用手势取消
Sheet）丢失数据，因此，从最初的版本开始，我就一直使用各种手段加强对 Sheet 的控制。

去年 9 月，我在文章 [ 【在 SwiftUI 中制作可以控制取消手势的 Sheet】 ](/zh/posts/swiftui-dismiss-
sheet/) 中介绍了 [ 健康笔记 2.0 ](/healthnotes/) 版本的 Sheet 控制实现方法。目标为：

- 通过代码控制是否允许手势取消 Sheet
- 在用户使用手势取消 Sheet 时可以获得通知，进而拥有更多的控制能力

最终实现的效果如下：

![dismissSheet](https://cdn.fatbobman.com/dismissSheet.gif)

当用户有未保存的数据时，通过手势取消 Sheet 将被阻止，用户需明确选择保存或丢弃数据。

最终的效果已经完全满足了我的要求，不过唯一遗憾的是，使用起来不是那么的直观（具体使用方式请查看 [ 原文 ](/zh/posts/swiftui-
dismiss-sheet/) ）。

在今年推出的 SwiftUI 3.0 版本中，苹果添加了一个新的 View 扩展： `interactiveDismissDisabled`
，该扩展实现了上面的第一个要求——通过代码控制是否允许手势取消 Sheet。

    struct ExampleView: View {
           @State private var show: Bool = false

           var body: some View {

               Button("Open Sheet") {
                   self.show = true
               }
               .sheet(isPresented: $show) {
                   print("finished!")
               } content: {
                   MySheet()
               }
           }
       }

       struct MySheet: View {
           @Environment (\.presentationMode) var presentationMode
           @State var disable = false
           var body: some View {
               Button("Close") {
                   self.presentationMode.wrappedValue.dismiss()
               }
               .interactiveDismissDisabled(disable)
           }
       }

只需在被控制的视图中添加 `interactiveDismissDisabled`
，不影响其他地方的代码逻辑。这种实现是我所喜欢的，也给了我很大的启发。

在 [ WWDC 2021 观后感 ](/zh/posts/wwdc2021/) 一文中，我们已经探讨过 SwiftUI 3.0
将会影响非常多的第三方开发者编写 SwiftUI 扩展的思路和实现方式。

尽管 `interactiveDismissDisabled` 的实现很优雅，但仍未完成 [ 健康笔记 ](/healthnotes/)
需要的第二个功能：在用户使用手势取消 Sheet 时可以获得通知，进而拥有更多的控制能力。因此，我决定使用类似的方式实现它。

## 原理

### 委托

从 iOS 13 开始，苹果调整了模态视图的委托协议（UIAdaptivePresentationControllerDelegate）。其中：

- presentationControllerShouldDismiss ( **\_** presentationController: UIPresentationController) -> Bool

决定了是否允许通过手势来 dismiss sheet

- presentationControllerWillDismiss ( **\_** presentationController: UIPresentationController)

用户尝试使用手势取消时的执行此方法

当用户使用手势取消 Sheet 时，系统将首先执行 presentationControllerWillDismiss，然后再从
presentationControllerShouldDismiss 中获取是否允许取消。

默认情况下，展示（present）Sheet
的视图控制器（UIViewController）是没有设置委托的。因此，只要将定义好的委托实例在视图中注入给特定的视图控制器即可实现以上需求。

### 注入

创建一个空的 UIView（通过 UIViewRepresentable），在其中查找到持有它的 UIViewController `A` 。那么 `A` 的 presentationController 就是我们需要注入 delegate 的视图控制器。

在之前的 [ 版本中 ](/zh/posts/swiftui-dismiss-sheet/)
，用户使用手势取消时的通知和其他的逻辑是分离的，在使用中不仅繁琐，而且影响代码的观感。本次将一并解决这个问题。

## 实现

### Delegate

    final class SheetDelegate: NSObject, UIAdaptivePresentationControllerDelegate {
        var isDisable: Bool
        @Binding var attempToDismiss: UUID

        init(_ isDisable: Bool, attempToDismiss: Binding<UUID> = .constant(UUID())) {
            self.isDisable = isDisable
            _attempToDismiss = attempToDismiss
        }

        func presentationControllerShouldDismiss(_ presentationController: UIPresentationController) -> Bool {
            !isDisable
        }

        func presentationControllerDidAttemptToDismiss(_ presentationController: UIPresentationController) {
            attempToDismiss = UUID()
        }
    }

### UIViewRepresentable

    struct SetSheetDelegate: UIViewRepresentable {
        let delegate:SheetDelegate

        init(isDisable:Bool,attempToDismiss:Binding<UUID>){
            self.delegate = SheetDelegate(isDisable, attempToDismiss: attempToDismiss)
        }

        func makeUIView(context: Context) -> some UIView {
            let view = UIView()
            return view
        }

        func updateUIView(_ uiView: UIViewType, context: Context) {
            DispatchQueue.main.async {
                uiView.parentViewController?.presentationController?.delegate = delegate
            }
        }
    }

makeUIView 中只需要创建一个空视图（UIView），由于在执行 makeUIView 时，无法保证 Sheet
中的视图已经被正常展示，因此最佳的注入时机为 updateUIView。

为了方便查找持有该 UIView 的 UIController，我们需要对 UIView 进行扩展：

    extension UIView {
        var parentViewController: UIViewController? {
            var parentResponder: UIResponder? = self.next
            while parentResponder != nil {
                if let viewController = parentResponder as? UIViewController {
                    return viewController
                }
                parentResponder = parentResponder?.next
            }
            return nil
        }
    }

如此，便可以通过下面的代码为展示 Sheet 的视图控制器注入 delegate 了

    uiView.parentViewController?.presentationController?.delegate = delegate

### View Extension

使用了与系统相同的方法名

    public extension View{
        func interactiveDismissDisabled(_ isDisable:Bool,attempToDismiss:Binding<UUID>) -> some View{
            background(SetSheetDelegate(isDisable: isDisable, attempToDismiss: attempToDismiss))
        }
    }

## 结果

使用的方式同原生的功能几乎一样：

    struct ContentView: View {
        @State var sheet = false
        var body: some View {
            VStack {
                Button("show sheet") {
                    sheet.toggle()
                }
            }
            .sheet(isPresented: $sheet) {
                SheetView()
            }
        }
    }

    struct SheetView: View {
        @State var disable = false
        @State var attempToDismiss = UUID()
        var body: some View {
            VStack {
                Button("disable: \(disable ? "true" : "false")") {
                    disable.toggle()
                }
                .interactiveDismissDisabled(disable, attempToDismiss: $attempToDismiss)
            }
            .onChange(of: attempToDismiss) { _ in
                print("try to dismiss sheet")
            }
        }
    }

![dismissSheet2](https://cdn.fatbobman.com/dismissSheet2.gif)

> 本文的代码可以在 [ Gist
> ](https://gist.github.com/fatbobman/d248d80d8d1a23b5f8d84ed7544d2ae3) 上查看

## 总结

SwiftUI 已经诞生两年多了，开发者也已经逐渐掌握为 SwiftUI 添加新功能的各种技巧。通过学习和理解原生的 API，可以让我们的实现更加符合
SwiftUI 的风格，整体的代码更加的统一。

# Swift Playgrounds 4 娱乐还是生产力

赶在 2021 年底，苹果终于发布了 Swift Playgrounds 4，作为近年来最具革命性意义的版本，Swift Playgrounds 4
提供了在 iPad 上开发可发行 app 的能力。本文将对 Swift Playgrounds 4 的新功能做以介绍，并探讨将其作为开发工具的可行性。

> 本文中的 Swift Playgrounds 4 特指 iPad 版本。 ~~MacOS 下的 Swift Playgrounds 4 目前仍采用 3.
> x 引擎。~~ MacOS 下的 Playgrounds 4.1 版本已经换用了同 iPad 版本相同的内核。

## 关于 Swift Playgrounds

在 Swift 语言发布的两年后，苹果于 WWDC 2016 上推出了 iPad 版本的 Swift Playgrounds。

Swift Playgrounds
提倡以一种有趣的方式学习严肃的代码，它不要求用户具备编程知识，非常适合初学者。采用互动式的教学模式，苹果提供了一系列的课件，以满足 4-15 岁人群的需求。

![image-20211219194032374](https://cdn.fatbobman.com/image-20211219194032374.png)

> 上图中的课件内容，核心逻辑同几十年前的 Logo 语言十分类似，非常适合低幼人群。

或许受了“中国古拳法”的“人人有功练”影响，苹果提出了“人人能编程（Everyone Can Code）”计划。通过向美国的公立学校和教师提供大量的
iPad 和 Mac，希望在教育系统中大力推广 Swift 语言。该计划经过几年的运行，取得了一定的成绩，但效果并没有完全达到预期。

与此同时，智能玩具厂商也发现了 Swift Playgrounds 的潜力，推出了与之配合的课件，让 Swift Playgrounds
成为了教育玩具领域的重要工具。

Swift Playgrounds 是典型的寓教于乐型产品，最初的设计目标并不涉及专业开发所需的生产力方面需求。

从 3. x 版本开始，Swift Playgrounds 逐渐添加了一些适合专业开发者的功能，例如：

- 类似于 Xcode Playground 的共享 Swift 文件
- 更好的键鼠支持（随着 iPadOS 的键鼠能力的增强）
- 可以在控制台中显示 print () 语句的输出等

一些 Swift 开发者逐渐尝试使用 Swift Playgrounds 进行一些小规模的开发工作。

随着 iPad 性能的不断提升，尤其当苹果为 iPad Pro 推出了“你的下一台电脑，何必是电脑”的广告语后，不少 Swift 开发者呼吁苹果应该提供一款
iPad 版本的 Xcode。

当苹果在 WWDC 2021 上提出要在 iPad 上提供一款可以像 Xcode 一样开发 app 的应用时，人们都十分震惊并期待其尽早面世。

最终，在 2021 年底，苹果将 WWDC 2021 上展示的功能集成到了 Swift Playground 中，推出 Swift Playground
4.0 版本。

## Swift Playgrounds 4 的新功能

### 增加了对 Xcode Playground 文件格式的支持

尽管 Swift Playgrounds 的名称明显受到了 Xcode Playground 的影响，但长久以来，它的文件格式并不与 Xcode
Playground 兼容。

Swift Playgrounds 采用了一种名为 playgroundbook 的包来管理课件以及开发者自创的代码。开发者很难将其它资源注入其中，限制了在
Swift Playgrounds 中编写代码的灵活性。通过提供 playground 包支持，让开发者以更加熟悉的方式进行工作，汇集并测试灵感，并随时可在
Mac 和 iPad 之间切换。

点击首页下方的【查看全部】，选择其中的 Xcode Playground。

![image-20211224160807063](https://cdn.fatbobman.com/image-20211224160807063.png)

事实上，在 Swift Playgrounds 的 Playground 模式下，除了无法指定代码的结束位置外，使用体验与 Xcode Playground
已经十分接近。

![image-20211219194001850](https://cdn.fatbobman.com/image-20211219194001850.png)

> 或许由于 iPad 下最多只能分两屏的原因，使用 Swift Playgrounds 的 playground 模式调试代码，我获得了比 Mac
> 上更好的专注度。

### 在 iPad 上开发可上线发行的 iOS 应用程序

Swift Playground 4 中最亮眼的新功能就是提供了直接在 iPad 上通过 Swift Playgrounds 构建应用程序的能力（需要
iPadOS 15.2）。项目采用了与 SPM 结构完全一致的 swiftpm 包。可以在 Xcode 上打开，并进一步编辑。

![image-20211219200232619](https://cdn.fatbobman.com/image-20211219200232619.png)

应用被限定使用 SwiftUI life cycle，提供了响应迅速的预览以及全屏运行模式，支持添加第三方 SPM 库。

![image-20211219195937459](https://cdn.fatbobman.com/image-20211219195937459.png)

开发者可以使用类似 Xcode `+Capablility` 的选项来添加应用程序允许调用的系统功能。

![image-20211219200610143](https://cdn.fatbobman.com/image-20211219200610143.png)

在有开发者账户的情况下，可以直接将应用程序提交到 App Store 接受审核。

![image-20211219200946451](https://cdn.fatbobman.com/image-20211219200946451.png)

理论上来说，开发者可以不使用 Mac，仅在 Swift Playgrounds 中即可完成一个上线并发行的 iOS 应用程序。

### 更好的代码补全和帮助

在 4.0 版之前，Swift Playgrounds 采用了一种适合触摸屏方式的代码补全机制：

![image-20211219201452934](https://cdn.fatbobman.com/image-20211219201452934.png)

此种方式并不适用于习惯了专业 IDE 补全机制的开发者。在 4.0 版本中，Swift Playgrounds 在 playground 和 app
模式下，提供了同 Xcode 非常接近的代码补全和提示功能，极大地提高了代码的编写效率。

![image-20211219201734240](https://cdn.fatbobman.com/image-20211219201734240.png)

对于系统文档以及用户创建的 Markdown 注释均提供了良好的支持。

![image-20211219202725921](https://cdn.fatbobman.com/image-20211219202725921.png)

### Swift DocC 的全面支持

苹果为 Swift Playgrounds 4 提供了不少新的课件，主要集中于如何创建 app，如何使用 SwiftUI。苹果放弃了之前惯用的通过
PlaygroundBookTemplate 创建的课件方式，而是利用 Swift DocC 来组织教学内容。

![image-20211219203541692](https://cdn.fatbobman.com/image-20211219203541692.png)

Swift DocC 相较于 PlaygroundBookTemplate 编写更加容易，也更适合高阶的语言教学。另外，只需创建一套 Swift DocC
课件便可同时支持 iPad 和 Mac 两个平台。有鉴于此，相信不久的将来，会有更多官方和第三方的优秀课件涌现。

## Swift Playgrounds 4 的适用人群或场景

既然 Swift Playgrounds 4 已经提供了如此多针对专业开发需求的功能，是否可以将其作为严肃的生产力工具来对待呢？

经过几天来不间断地使用，我认为苹果并没有为了取悦专业开发者而彻底改变 Swift Playgrounds 的定位，现阶段 Swift Playgrounds
仍着重于教育用途，但提供了部分适合专业开发者使用的功能。

Swift Playgrounds 至今已经发展了 5 年，它的大量使用者应该已经掌握了足够的 Swift 编程基本技能，4.0
版本为他们提供了进一步提高的途径和手段。通过更专业的 playground 和 app 模式，将这些原本以娱乐的心态来使用 Swift
Playgrounds 的学生转换为更专业的开发人员。

Swift Playgounds 4 在专业开发用途上的一些主要的功能缺失：

- playground 模式下无法导入 SPM（Xcode 下可以通过 project 或 workspace 来导入），目前只能将源码导入 Source 目录来实现对部分 SPM 进行测试
- app 模式下不提供调试功能
- app 模式下，系统功能选项不足，尤其不提供任何与 iCloud 服务相关的功能
- 无法单独开发与 CoreData、SpriteKit、SceneKit 等等有关的项目，类似的项目均需要在 Mac 上做大量的工作
- App Store 提交内容选项明显不足，当前演示的意味更浓（不排除将来苹果推出某种特别类型（例如针对学生）的开发者账户，更便宜、有限的应用定价机制、有限的发行范围）
- 不提供资源管理，不提供本地化资源设置等等

考虑到 Swift Playgrounds 的定位，我认为苹果只会在将来的版本中弥补少量的专业缺失功能。或许在合适的时机，苹果会为专业开发者提供 Xcode
的 iPad 版本（个人认为可能性不大）。

当前的 Swift Playgrounds 适用于如下的人群或场景：

- 对编程感兴趣的孩子和学生（传统优势领域）
- 对智能玩具有编程需要的人
- 掌握了基本的 Swift 编程技巧需要进一步提高的使用者
- 想接触 iOS 及 Swift 编程，但没有 Mac 机的开发者或编程爱好者，通过 Swift Playgrounds 可以用极低的成本进入 iOS 的开发生态（Swift Playgrounds 即使在数年前的 iPad 上也运行的相当流畅）
- 专业的 Swift 开发者用 playground 模式来实现灵感，测试想法（在生产力方面最接近 Mac 下的体验）
- 专业的 Swift 开发者在只有 iPad 的情况下，在 Swift Playgrounds 上继续进行 Mac 上尚未完成的部分工作（需将项目转换成 Swift Playgrounds App 模式）。

## 总结

马上就要寒假了，或许可以让你的孩子在使用 iPad 娱乐之余，通过 Swift Playgrounds 学习一下编程，当将自己开发的 app
共享给其他的同学时，一定可以获得相当的自豪和满足。

专业的 Swift 开发者也不应错过 Swift Playgrounds 这个优秀的工具，更多地挖掘 iPad 的潜力。

Swift Playgrounds 在保留了快乐教育的功能前提下，满足了部分场景下的生产力需求。

# SwiftUI 与 Core Data —— 问题

我使用 Core Data 已经有三年的时间了，虽然至今也不能算是完全掌握，但基本上可以做到熟练使用，很少会犯原则性的错误了。当前，如何让 Core
Data 融入流行的应用架构体系，在 SwiftUI、TCA、Unit Tests、Preview
等环境下更加顺畅地工作已成为我的主要困扰和研究方向。我将通过几篇文章来介绍近半年来在这方面的一些想法、收获、体会及实践，也希望能够与有类似困惑的朋友进行更多的探讨。

## 廉颇老矣尚能饭否？

Core Data 是一个拥有悠久历史的框架。如果仅从苹果在 2005 年发布 MacOS X Tigger 中第一次集成了 Core Data
框架算起，Core Data 至今只有十余年的时间，但考虑到其很大一部分设计都继承自 Next 于 1994 年推出的 EOF（ Enterprise
Objects Framework ）框架，如此算来，其核心设计理念已经诞生了接近三十年。在 Core Data 框架的代码中，至今仍到处充斥着具有历史感的
`NS` 前缀。

与当前 Core Data 主流的使用场景不同，EOF 被集成在应用程序服务器 WebObjects 中，在电子商务的早期，吸引了不少大公司的使用，客户包括
BBC、Dell、Disney、GE、Merrill Lynch 等。直到前些年，WebObjects 仍为苹果的 Apple Store 和 iTunes
Store 提供动力。如此，便不难理解为什么与其他流行的移动持久化方案不同，Core Data
并不过分追求数据的访问效率，稳定才是其最关注的点，这在很多开发者中早已 [ 形成共识
](https://www.reddit.com/r/iOSProgramming/comments/q2w856/realm_vs_coredata_in_2021_which_do_you_use_and_why/)
。

或许是设计理念十分超前并且实现得已经足够完美（ 低情商：近些年苹果投入度较低 ），最近五六年中，苹果在不需要对核心代码做太多调整的情况下，便为 Core
Data 增加了如下的新功能：

- NSPersistentContainer

协调器、持久化存储、托管上下文包装的官方实现。几乎无需调整任何核心代码。

- 持久化历史跟踪

近期最大的改动。在持久化存储上增加了更多 Triger 的操作，并在协调器上提供了响应变化的 API

- 数据的批量操作

允许开发者跳过上下文，直接从协调器上对持久化存储进行批量操作

- Core Data with CloudKit

几乎不需对核心代码做调整，新增了 NSPersistentCloudKitContainer ，在协调器上附加了一个用于网络同步的模块。

- async/await 支持

提供了新的 perform 方法的实现

尽管开发者中近期流传着（ 或幻想着 ）苹果会推出全新的框架取代 Core Data 的言论，但只要认真了解并研究 Core Data
的历史和代码便可以分析出新框架出现的可能性十分的低。一方面，其优秀的架构设计仍可满足未来添加新功能的需求；另一方面，替换一个拥有如此悠久历史且以稳定性著称的框架需要极大的勇气。因此，开发者可能会在未来很长的一段时间中继续使用这套框架。

严格来说，排除掉不易学、不好掌握这个缺点，在一个理想的环境中，Core Data 无论从稳定性、开发效率、可扩展性等方面来说都相当的优秀（
网络同步不稳定不是 Core Data 的问题 ），在管理对象图、对象生命周期以及数据持久化方面仍是苹果生态的最佳选择。

不过这并非意味着 Core Data
能够完全适应如今的开发环境。虽然它仍然拥有超前的头脑、强壮的内脏，但外貌实在太陈旧了，已很难与新框架和新的开发流程匹配。假如我们可以为它创建一个新的外貌，或许可以让它重焕青春，再战十年。

## 你的荣耀，我的烦恼

有趣的是，造成 Core Data 与新框架、新开发流程不融洽的大多因素都是 Core Data 引以为傲的一些特点或优势。

### 数据结构谁做主

Core Data 的核心是对象图管理，持久化功能只是其一个附带功能。相较于其他框架，Core Data
对关系的描述和处理能力是其核心竞争力。或许是为了便于描述复杂的关系逻辑，开发者在创建数据结构前，通常需要在 Xcode 的数据模型编辑器中创建实体描述（
支持使用代码直接来定义，但较少会采用此种方式 ），然后使用自动或手动的方式生成对应的 NSManagedObject 定义代码。如此一来会出现如下问题：

- 为了保持与 Objectiv-C 的兼容性（ Core Data 的内部数据仍采用 Objective-C 实现 ），开发者在数据模型编辑器中，仅能用有限的数据类型来描述属性。这使得开发者在定义一个新的数据结构（ 对应 Core Data 的实体 ）时，无法在第一时间用最适合 Swift 语言风格的方式进行思考和描述，不自觉地便受制于模型编辑器的表述能力。
- 在使用了数据网络同步的情况下（ Core Data with CloudKit），由于无法在产品上线后修改实体或属性名称（ [只增不减不改原则]( [ https://fatbobman.com/zh/posts/coredatawithcloudkit-4/#更新数据模型 ](/zh/posts/coredatawithcloudkit-4/#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B) ） )，无论原有的实体、属性、关系名称定义得多么不合理，开发者也只能承受。随着版本的不断更迭，这些不合适的命名会充斥在代码各处，让人欲哭无泪。
- 很难在第一时间进入业务流程的开发状态。当将托管对象作为数据描述的类型后，开发者往往最初编写的代码都是有关于 Core Data Stack 方面的。在应用的开发过程中，对数据定义的任何调整都需要经过层层处理（ 模型编辑器、对应的 NSManamgedObject 定义、Stack 中的相关代码 ），严重影响了开发的效率。

总而言之，一旦在应用中使用了 Core Data，开发者很难在开发的初始阶段摆脱它的阴影。从导入 Core Data
的那一刻起，便对开发者的创造力、直觉、热情产生了负面的影响。

### R 0 值超高的托管机制

Core Data 的托管机制自 EOF 时期便已经存在。该机制让 Core Data 将来自底层的数据源暴露为持久对象的托管图（ 内存数据对象
），并通过托管上下文对对象图进行修改和跟踪。托管机制提供的数据惰性加载能力可以帮助开发者在读取效率和内存占用之间取得平衡。可以说，拥有托管机制是 Core
Data 长期以来的一个引以为傲的特性。

但托管机制意味着，开发者在进行任意操作前首先要搭建符合要求的托管环境。操作托管对象必须首先创建托管对象上下文。而让上下文可以工作的前提是创建托管协调器和持久化存储。

除了创建托管环境所需操作繁杂外，托管环境在某些场合下的运行稳定性并不可靠。事实上，Core Data 的托管环境已经是当下导致 SwiftUI
预览失败的主要原因之一。另外，对托管环境的准备和重置也会拖慢 Unit Tests
的速度，影响开发者编写单元测试的意愿。由此一来，会严重打击开发者在应用中采用模块式（ SPM ）开发的积极性。

如果说奥密克戎 BA. 4/5 的 R 0 值为 18.6 ，那么托管机制对于应用中涉及托管对象的代码的基本繁殖数就是 ∞ ，一旦沾上便甩不掉。

### 线程绑定与 Sendable

虽然 Core Data 的托管对象并非线程安全的，但只要严格遵守使用约定（ 只在创建托管对象的托管上下文中使用 ），在 Core Data
中进行多线程开发是很安全的。尽管有些开发者认为在 Core Data 中进行多线程有些烦琐，但又不得不承认相较于其他类似的框架，使用 Core Data
进行多线程开发，稳定性是很有保障的。

随着 Swift 5.5 在异步和并发方面能力的提升，开发者会自觉不自觉的在代码中使用到新的异步或并发机制。例如，TCA 的 Reducer 目前正朝
Global Actor 方向演进（ 也就是 Reducer 将不再运行于主线程上 ）。为了避免出现线程安全问题，让数据符合 Sendable
协议是有效的手段。

很显然，托管对象并不具备符合 Sendable 协议的基础。如何让 Core Data 与使用新并行机制的框架进行配合，同样是摆在开发者面前的一个新课题。

## 我向往的使用方式

尽管有些贪心，但我仍希望能做到鱼和熊掌兼而得之。我们将通过几篇文章一起来探讨，试图实现如下目标：

- 将 Core Data 对数据定义过程中（ 尤其是开发的初期 ） 的影响降至最低
- 将数据源切换至 Core Data 后，无需修改当前的代码
- 在预览、单元测试阶段不再受托管环境的困扰，可方便对代码实行模块化管理
- 仍保留 Core Data 的数据惰性加载机制，避免造成内存的过多占用
- 兼容新的并行机制，找寻 Senable 的最大公约数
- 用最少的代码实现上述目标，避免增加系统的不稳定性

## 下文介绍

在下篇文章中，我们将首先从数据（ 对应 Core Data 的实体、属性 ）的定义谈起，尝试通过泛型、类型擦除等方式从定义中移除托管环境。

> 由于一直没有为这个系列的文章想好恰当的题目，便暂且临时采用了 “SwiftUI 与 Core Data” 这个名称。如果你有什么好的建议欢迎告诉我。

# 在多包项目中统一管理资源

随着 SPM（ Swift Package Manager ） 功能的不断完善，越来越多的开发者开始在他的项目中通过创建多个 Package
的方式来分离功能、管理代码。SPM 本身提供了对包中各类资源（ 包括本地化资源 ）的管理能力，但主要局限于在本包中使用这些资源，难以将资源进行共享。在有多个
Target 均需调用同一资源的情况下，原有的方式很难应对。本文将介绍一种在拥有多个 SPM 包的项目中，对资源进行统一管理的方法。

## 问题

笔者最近正在使用 TCA（ [ The Composable Architecture
](/zh/posts/the_composable_architecture/) ）结合 SwiftUI 做一些开发，在 TCA 中，开发者通常会为一个
Feature 创建一个独立的包或在一个统一的包（ 拥有众多的 Target ）中创建一个单独的 Target。Feature 中通常会包含有关 UI
的逻辑处理代码（ Reducer ）、单元测试代码、与该 Feature 相关的视图代码以及预览代码。每个 Feature
基本上可以被视作一个可独立运行的小应用（ 在注入所需的环境后 ）。最终开发者需要通过在 Xcode 项目中导入所需的 Feature
模块，并通过串联代码将完整的 app 组合出来。在这种情况下，几乎每个 Feature 以及 Xcode 项目代码都需要使用到本地化及其他一些共用资源。

假设将共用资源分别复制到不同模块的 Resource 目录中，那么会造成如下的问题：

- 每个模块中都有重复的资源，应用的尺寸将增大
- 难以管理共用资源，可能会出现更新不同步的情况

如果所有的模块都位于同一个目录下，通过使用相对路径的方式，可以在各自的 Resources
目录中导入共用资源，这样虽然可以避免上述的更新不同步的情况，但仍需面对两个问题：

- 每个模块中都有重复的资源，应用的尺寸将增大
- 模块与资源文件之间的耦合度增加，不利于用多个仓库来分别管理

总之，最好能有一种方式可以做到：

- 资源与模块和 Xcode 项目之间低耦合度
- 可以统一管理资源，不会出现不同步
- 在最终的应用中只需要保留一份资源拷贝，不会造成存储的浪费

## 思路

Bundle 为代码和资源的组织提供了特定结构，意在 **提升开发者的体验**
。这个结构不仅允许预测性地加载代码和资源，同时也支持类似于本地化这样的系统性特性。Bundle 在存储上以目录的形式存在，在代码中则需要通过
Foundation 框架中的 Bundle 类来体现。

Xcode 工程项目本身就是在一个 Bundle 之下，开发者可以使用 `Bundle.main` 来获取其中的资源。

在 SPM 中，如果我们为 Target 添加了资源，那么在编译的时候，Xcode 将会自动为该 Target 创建一个 Bundle ，名称为
PackageName_TargetName. bundle（ 非 Mac 平台，尾缀为 resources ）。如果我们可以在其他的 Target
中获取到该 Bundle 的 URL ，并用其创建一个 Bundle 实例，那么就可以用下面的方式使用该 Bundle 中的资源：

    Text("MAIN_APP", bundle: .i18n)
          .foregroundColor(Color("i18nColor", bundle: .i18n))

因此，创建一个可以在 **任何状态** 下指向特定目录的 Bundle 实例便成了解决问题的关键。之所以强调任何状态，是因为，Swift
会视项目的编译需求而将 Bundle 放置在不同的目录层级上（ 例如单独编译 SPM Target 、在 SPM 中进行 Preview、在 Xcode
工程中引入 SPM Target 后编译应用等 ）。

幸运的是，Xcode 为我们提供了一段展示如何创建可应对多种编译状态下 Bundle 实例的示例代码。

在 SPM 中，如果你为 Target 添加了至少一个资源，那么 Xcode 将会为你创建一段辅助代码（ 该段代码并不包含在项目中，只在 Xcode
中起作用 ），生成一个指向该 Target Bundle 的实例：

![Bundle_module_2022-11-06_17.30.46.2022-11-06
17_33_41](https://cdn.fatbobman.com/Bundle_module_2022-11-06_17.30.46.2022-11-06%2017_33_41.gif)

代码如下：

    private class BundleFinder {}

    extension Foundation.Bundle {
        /// Returns the resource bundle associated with the current Swift module.
        static let module: Bundle = {
            let bundleName = "BundleModuleDemo_BundleModuleDemo" // PackageName_TargetName

            let overrides: [URL]
            #if DEBUG
            if let override = ProcessInfo.processInfo.environment["PACKAGE_RESOURCE_BUNDLE_URL"] {
                overrides = [URL(fileURLWithPath: override)]
            } else {
                overrides = []
            }
            #else
            overrides = []
            #endif

            let candidates = overrides + [
                // Bundle should be present here when the package is linked into an App.
                Bundle.main.resourceURL,

                // Bundle should be present here when the package is linked into a framework.
                Bundle(for: BundleFinder.self).resourceURL,

                // For command-line tools.
                Bundle.main.bundleURL,
            ]

            for candidate in candidates {
                let bundlePath = candidate?.appendingPathComponent(bundleName + ".bundle")
                if let bundle = bundlePath.flatMap(Bundle.init(url:)) {
                    return bundle
                }
            }
            fatalError("unable to find bundle named BundleModuleDemo_BundleModuleDemo")
        }()
    }

该段代码的基本逻辑是提供了三种可能的 Bundle 存放位置：

- Bundle. main. resourceURL
- Bundle (for: BundleFinder. self). resourceURL
- Bundle. main. bundleURL

在创建 Bundle 实例时，逐个位置查找，直到找到对应的 Bundle 目录后再创建实例。随后，我们就可以在代码中使用这个 Bundle. module
了 ：

    Text("Hello",bundle: .module)

很遗憾，上述的代码并没有覆盖全部的可能性，譬如在当前 Target 中运行 SwiftUI 的预览代码，就会出现无法找到对应的 Bundle
的情况。不过这已经为我们指明了道路，只要提供的备选位置足够充分，那么就有在任何场景下都成功创建对应的 Bundle 实例的可能。

## 实践

本节，我们将通过一个具体案例来演示如何在一个拥有多个包的 Xcode 项目中统一管理资源。可以在 [ 此处
](https://github.com/fatbobman/BlogCodes/tree/main/UnifiedLocalizationResources)
获得项目代码。

演示项目中，我们将创建一个名为 UnifiedLocalizationResources 的 Xcode 工程。并在其中创建三个 Package ：

- I 18 NResource

保存了项目中所有的资源，另外还包含一段创建 Bundle 实例的代码

- PackageA

包含了一段 SwiftUI 视图代码以及一段预览代码，视图中使用了 I 18 NResource 的资源

- PackageB

包含了一段 SwiftUI 视图代码以及一段预览代码，视图中使用了 I 18 NResource 的资源

![image-20221106175122954](https://cdn.fatbobman.com/image-20221106175122954.png)

所有的资源都保存在 I 18 NResource 的 Resources 目录下，PackageA、PackageB 以及 Xcode
工程代码中都将使用同一份内容。

### I 18 NResource

- 在 Target 对应的目录下创建 Resources 目录
- 修改 Package. swift，添加 `defaultLocalization: "en",` 启用本地化支持
- 在 I 18 NResource. swift 中添加如下代码：

  private class BundleFinder {}

  public extension Foundation.Bundle {
  static let i18n: Bundle = {
  let bundleName = "I18NResource_I18NResource"
  let bundleResourceURL = Bundle(for: BundleFinder.self).resourceURL
  let candidates = [
  Bundle.main.resourceURL,
  bundleResourceURL,
  Bundle.main.bundleURL,
  // Bundle should be present here when running previews from a different package "…/Debug-iphonesimulator/"
  bundleResourceURL?.deletingLastPathComponent().deletingLastPathComponent().deletingLastPathComponent(),
  bundleResourceURL?.deletingLastPathComponent().deletingLastPathComponent(),
  // other Package
  bundleResourceURL?.deletingLastPathComponent()
  ]

          for candidate in candidates {
              // 对于非 mac 苹果，可以需要使用 resources 尾缀
              let bundlePath = candidate?.appendingPathComponent(bundleName + ".bundle")
              if let bundle = bundlePath.flatMap(Bundle.init(url:)) {
                  return bundle
              }
          }
          fatalError("unable to find bundle named \(bundleName)")
      }()

  }

代码与 Xcode 自动生成的 module 代码很类似（ 就是在其基础上做的修改 ），但增加了三个新的候选项以适应更多的场景。现在只要调用 `Bundle.i18n` ，就可以根据所处环境生成正确的 Bundle 实例了。

- 添加资源文件

![image-20221106182644181](https://cdn.fatbobman.com/image-20221106182644181.png)

### PackageA

- 修改 Package. swift

添加 `defaultLocalization: "en"` , 在 Package 的 dependencies 中添加 `.package(path: "I18NResource")` ，在 PackageA target 的 dependencies 中添加 `.product(name: "I18NResource", package: "I18NResource")`

- 修改 PackageA. swift 代码

  import I18NResource // 导入资源库
  import SwiftUI

  public struct ViewA: View {
  public init() {}
  public var body: some View {
  Text("HELLO_WORLD", bundle: .i18n) // 使用 Bundle.i18n
  .font(.title)
  .foregroundColor(Color("i18nColor", bundle: .i18n)) // 使用 Bundle.i18n
  }
  }

  struct ViewAPreview: PreviewProvider {
  static var previews: some View {
  VStack {
  ViewA()
  .environment(\.locale, .init(identifier: "zh-cn"))
  VStack {
  ViewA()
  .environment(\.locale, .init(identifier: "zh-cn"))
  }
  .environment(\.colorScheme, .dark)
  }
  }
  }

![image-20221106182759688](https://cdn.fatbobman.com/image-20221106182759688.png)

现在我们已经可以在 PackageA 中使用 I 18 NResource 中的资源了。

> PackageB 的操作与 PackageA 基本一致

### Xcode 工程

- 为工程导入 PackageA 和 PackageB

![image-20221106183031414](https://cdn.fatbobman.com/image-20221106183031414.png)

- 修改 ContentView. swift

![image-20221106183121557](https://cdn.fatbobman.com/image-20221106183121557.png)

> 无需在 Xcode 工程中单独导入 I 18 NResource 模块，也可以直接使用其中的资源。

至此，我们便实现了本文的初衷：一个低耦合度、不增加容量、不会出现更新版本错误的统一资源管理方式。

## 总结

开发者不应仅仅将 SPM 视为一种包工具，应将其视为可以让你的项目以及开发能力获得提升的机遇。

> 随着时间的推移，每个模块都可以共享、测试和改进。对我来说，这不仅仅是一个小小的变化——这是一个巨大的飞跃。我的项目在每个级别都有所改进——它更稳定、更可测试，甚至更快。这并不是说
> Swift Packages 有一个秘密功能可以让你的项目运行得更好。创建 Swift
> 包的过程迫使您采取良好和健康的步骤来最终改进您的项目，例如测试、API
> 设计、依赖注入、文档编写等等。一旦我这样做了，我就意识到模块化我的代码，组织起来，并使用 “API 驱动” 的设计是多么重要。 ——
> 摘自：Mastering Swift Package Manager

# 老人新兵 —— 一款 iOS APP 的开发手记

> 本文是 2020 年初，我在 [ 知乎 ](https://zhuanlan.zhihu.com/p/103822455)
> 上写的一篇文章。记录了我重新开始学习编程的一点心路历程。现在回看起来，虽然里面有关技术方面的理解有点幼稚（ 请无视文中的技术细节
> ），但还蛮有意思的。恰逢博客的文章数达到了 100 篇，将其搬运回来以提醒自己不忘初心。

## 写在前面的话

我接触电脑的时间比较早（ 第一台电脑型号是 CP-80，CPU 是 MC 6800 ），开始学习编程也比较早（ 从中华学习机开始，Apple II
的国内兼容机
）。对于电脑和编程也都一直很有兴趣，不过从来也没有真正的把写代码当做过职业。虽然也使用过几种编程语言在不同的平台上写过些代码，但都不能算作完整的产品。习惯性地对信息行业的前沿动态以及一些新的技术方向保持着关注，但由于生意及其它方面的原因，从
10 几年前便完全没有再接触过编程了。

最近 6 — 7 年，由于疾病的原因，我的精力基本都集中在治疗上。由于治疗的需要，我作为一个不喜欢记笔记的人，却需要每天要记录大量的数据（
其实主要还是依赖我妻子
）。前年通过手术，疾病获得了很大的改善，本以为所需记录的数据能少一点，但事与愿违，数据量减少了，数据种类却大大地增加了，而且可以明确的是，这些数据将要在我有生之年一直记录下去。

![img](https://cdn.fatbobman.com/v2-e7d830909ff35974d795b314a12adcff_1440w.jpeg)

上图中的化验单是最近 1 年内的验血结果

之前也使用过电子表格整理过数据，但并不顺手。在 app 种类非常丰富的今天，也找过不少的 app
试图进行集中管理，不过效果并不理想。考虑到身体也已经恢复到了一个不错的状态，就决定尝试做一个能满足自己需求的
app，一方面是活动活动脑子，另一方面也算重拾当前的兴趣。

十多年间，信息技术的发展巨大，非常多的新技术、新方法、新概念以及之前难以想象的算力提升都给我这个老人新兵带来了不小的考验。

## 开发平台及框架的选择

作为一个苹果产品的长期使用者（ 从 Apple II 兼容机、Apple II、灰度显示的 PowerBook、伪彩的
PowerBook、若干代台灯、小白、小黑到如今的 iMac、MacBook Pro 以及众多的全家桶产品 ），开发一个能在 iOS 上使用的 app
是再自然不过的想法。

该 app 主要针对的对象就是像我这样对健康类数据有长期关注、管理、分析需求的人群。

曾考虑过使用可跨平台的开发框架，不过出于以下几个原因最终还是选择了 Native 的开发方式：

- 身边没有安卓设备

- 能力及精力有限，无法做大规模适配

- 有开发打算时恰逢 2019 年 WWDC 结束不久，苹果新推出的 SwiftUI、Combine 以及 Core Data 中的新特性对我很有吸引力

- 兴趣驱动，没有商业压力和历史包袱，因此可直接采用尚未成熟或前景不明的技术

在经过一番了解后，最终选择 SwiftUI + Combine + Core Data 的组合。其中既有庆幸也有艰辛，下文中也会有更多说明。

## 技术准备

十多年不接触代码我最大的担心不是我的知识储备不够，而是没有手感了。这个忧虑最终也得到了证实。

之前接触过不少种编程语言，因此对我来说编程语言基本的语法理解起来没有什么太大问题，主要是如何能将其特性发挥出来。OC 一方面是学习成本要高于
Swift，另外在 5.0 后，Swift 也已经逐步稳定下来，出于多快好省的想法，使用 Swift 是当前在 iOS 下进行开发的不错选择。

买了几本 Swift 的基础书籍（ 也是真够基础的
），通读了两遍，对其有了一定的了解。本以为至少读读其他人的代码应该不难吧，结果发现很多的代码都读不太明白。究其原因，大多 Swift
代码中使用了泛型、函数式编程等特性，这些知识在基础书籍里都是一笔带过的，从而导致代码看得一头雾水。没关系，回炉重造。这里我要特别感谢 ObjCCN
翻译并撰写的书籍。通过这些书籍，我对 Swift 语言有了更多的认识和了解。当然其中很多的资料并不太容易理解，不过咬牙读下来还是会有极大的收获。

在对 Swift 基本语法有所掌握的情况下，我开始学习 SwiftUI。最开始阅读的资料自然是 Apple 自带文档中的例程。对于我这样没有 UIKit
使用经验的人来说，声明式带来的好处起初并没有什么太大感觉（ 我最后的编程记忆停留在 Django 尚未 release 的时期，初步接触了 Django 的
MVC 模式 ），直到后来由于功能的需要在 SwiftUI 下混合使用 UIKit 开发才真正体会到了声明式的优势。

官方资料中的例子不错，但当我想以此为蓝本，实现一个完整的 app 时，确发现无从下手。这里仍然要感谢 ObjCCN 王巍编写的 SwiftUI 与
Combine 编程一书。我是在其预购时便开始阅读的，受益匪浅。尤其是对于 Combine 的响应式思想有了更加完善的认识。严格说 SwiftUI
是无法脱离 Combine 的，但是 Combine 可以和其他各种框架进行结合。

相较于声明式思想，响应式编程给我带来了更多的震撼。尤其在之后的开发过程，随着理解的深入，越发感受到了它的魅力所在。

在实现 app UI 有了一定技术基础的情况下，我便开始了关于 i 数据库方面的选择。

很早前使用过关系型数据库，因此还算有点基础。但对于在移动端应使用什么样的产品或框架则完全没有概念。想着既然作为兴趣作品，那么可以借机多了解一下当下流行的移动数据持久化方案。读了点
NoSQL 资料，也接触了点当下主流的云数据解决方案，各有特点，一时也拿不定主意。

其实最初我就打算使用 Core Data，但由于其资料不多，学习曲线陡峭，另外感觉到国内的 app
开发者好像普遍不太喜欢使用它，所以暂时搁置。最后在反复权衡后仍然回头选择了 Core Data。首先在 iOS 13 下它自带的云同步非常吸引我（
基本免费、性价比超高 ），另外由于 Core Data 并非一个 ORM（ 应该称其为对象图管理框架 ），在性能及安全等方面还有不少其他的优势。

学习 Core Data 时面临的问题不少，主要体现在资料少、入手难。我目前所能找到的最好的资料是 objc 创作的 Core Data
中文译本，不过说实话这本书非常不适合初学者阅读。通过不断地在网上查找资料、观看油管视频、研究苹果文档里令人费解的说明，用了将近一个月的时间才初窥门径。随着理解的深入，我对于
Core Data 的好感也不断加深。如果你的 app 并不打算跨平台（ 仅支持苹果生态 ），或者希望使用 native 的方式进行 iOS
下的本地数据管理，Core Data 真的是相当不错的选择。比如像我的 app 这样只在 iOS
上运行的话，只需要最小的代码开销便可完成非常优秀的云同步。另外如果利用好 Core Data 的特性，在当 SwiftUI + Combine
下你可以获得极为方便的动态数据管理流程。

另外在储备期间还学习了 DesignCode 的 SwiftUI 和 Sketch 两个视频课程，尤其是 Sketch 对于之后的开发起到了不小的帮助作用。

从去年（ 2019 年 ）十一开始进入到学习状态，到 11 月底，用了两个月的时间，达到了基本具备构建一个完整 app 的能力（ 个人认为 ），从 11 月
24 开始（ Git 上第一个 commit 时间 ）进入到了正式的开发阶段。

## 正式开发

由于对需求的考虑比较充分（ 了解自己需要什么样的工具 ），因此最初几天的进展很快。SwiftUI 给我创建了一个非常高效的环境，在短时间内便可以将整个
app 的原型跑起来，但当真正地将具体实现以及数据流完全串联起来时才发现一切并不那么简单。

有以下几个难点：

- SwiftUI 功能十分有限

在真正要实现诸多功能时发现，目前很多场景下仍然要通过 UIKit 才能完成，为此又耗费了些心力学习了点 UIKit 的内容（
至少需要掌握两者之间如何混合使用 ）。在最后的 app 里面有接近一半的显示控制其实都是在 UIKit 下完成的，即使像 TextField
这样最基本的需求，SwiftUI 的原生版本有时都无法胜任。

- SwiftUI 和 Combine 的 Bug 太多

尽管做好新产品并不完善的准备，不过 bug 的数量还是远远多于我的预期。在整个开发过程中我通过 feedback 汇报了十余处明显的
bug，还有很多灵异现象由于无法使用简短的例程重现我都没有办法汇报。总之在逐渐摸清了这两个老爷的脾气后，已经基本上能够和这些 bug 和睦相处了。

- 编程思想

尽管我有使用最新编程思想的觉悟，也在设计和开发中向着这个方向努力，但一方面是之前的经验惯性，另外还是对新思路的掌握浅薄，在整个的开发中走了不少的弯路。我的数据流控制逻辑基本上推倒重写了
4 次，目前版本的代码量在完成更多功能、更加稳定并且每个 view 中的数据都无需干预、动态更新的情况下少了一半。

- 开发环境

多年不接触编程，在相当长的一段时间里仍无法完全适应当今如此复杂的 IDE 工具。另外 Xcode
的某些错误提醒也很神奇，一部分很准确、一部分很无语，把本来简单的错误指引到了奇怪的地方。用了差不多半个月才基本搞清楚什么能信什么不能信。

另外开发中的包管理、版本管理等对我来说都是新课题，总之每每遇到新问题都是一种修行。

- 上线审核

我是打算在本次开发中，多接触点新的课题。最后在 app
中使用了应用内购买、自动续费等多种方式。随后发现真是给自己挖了个大坑，十分庆幸总算搞定。主要的问题并不是技术方面，而是由于完全没有审核经验因此走了很多冤枉路。

总之经过了一个半月的开发（ 其中包括半个月的各种审核问题 ），第一个版本目前已登陆 App Store。

## 吐槽、提示、经验、总结

本文基本上处于意识流状态，想哪写哪。下文是关于我在开发过程中遇到的一些问题，bug
，总结的技巧，获得的一点点经验等。没有必然的前后顺序，如果里面有错误，希望大家轻点点评 😅。

### TabView

SwiftUi 中的 TabView 本来是一个很方便的控件，寥寥几句代码便可完成一个标准的屏幕底部页面切换功能，不过它有几个问题：

- item 的版式控制力差，这个还是可以接受的，可以通过一些手段调整，不过就不优美了；

- 切换页面 view 会重置状态，比如说 view 1 里有个 ScrollView, 你已经进行了滚动，当你通过 TabView 切换到其他视图后切换回来，ScrollView 不会保留在原来的地方，直接会回到顶部

- 由于切换重置，在复杂页面加载时效率低到可怕。TabView 在切换时，应该是把原来的 view 完全销毁掉，而且销毁的效率很低。导致如果页面复杂切换就像机械相机按动快门一样，会闪。这个是所有问题里最不能够接受的一点

本来想实在不行就通过桥接 UIKit 来实现吧，最后采用通过 ZStack 模拟 TabView
功能的方案，解决了以上的问题，并获得了更多的控制能力。当然也有弊端，使用了 ZStack 后，所有的 view
即使看不见实际上也已经初始化并显示了，并且不会销毁，因此失去通过 onAppear 和 onDisappear 进行介入的手段（ 最后采用了其他的变通方式
）。

### ScrollView

SwiftUI 中的 ScrollView 沿袭了其他 SwiftUI 控件的特点，使用起来非常轻巧，但几乎不提供额外的控制选项。在我的 app
中，多数情况它还是胜任的，不过它和某些 UIKit 的实现结合起来使用会出现灵异现象，最后在个别页面中，还是使用了 UIScrollView 才解决了问题。

### NavigationView

灵异现象较多。

最大的一个是如果 view 的内容比较复杂，且 barItem 使用中文或图片，缓慢地从左侧滑动页面返回时，会出现不同 View 顶部的
NavigationBarItem 重叠的现象，导致 BarItem 的按钮失效。这个 bug，我已经通过 feedback 和 apple
沟通了几轮，由于简单的例子很难重现，为了 feedback，我几乎单独又写了个小程序给他们。目前这个 bug 还没有解决，为了不让用户的体验出现问题（
只是偶尔出现，但也很烦人 ），我暂时屏蔽了 app 中的从屏幕左侧滑动返回的功能。

模拟器中 NavigationLink 只能使用一次，第二次点会失效，实机没有问题。

很难实现直接返回到根视图，通过 dissmiss 只能返回到上层视图。在 Xcode 11 的 beta
版本中还可以采用一些非常规手段实现这一功能，不过目前已被屏蔽了。导致我无法很好地实现双击 TabView 图标返回该 Tab
的根视图，比较郁闷。其实也有笨办法，通过自己管理一个 View Stack, 然后使用 onReceive 一层层的给 view 传递 dismiss
指令。但由于这个多层返回是显式的，也就是都有完整的动画，超过一层时，使用者的感觉会更怪。最后仅是在当 view 在 ZStack 的后面时使用了这个手段。

### Sheet

问题很奇怪。

环境值和环境对象必须显式注入，否则会运行错误。从这一点来看 Sheet 应该和其他的 view 在数据环境上是隔绝的。

当一个 view 中有基于 ForEach 动态变化的数据时，如果该 view 在 sheet 中，数据变化后会导致触发异常，如果将 view 从
Sheet 中提取出来直接显示则无此问题。

复杂的 Form 在同一个 view 中，处于 Sheet 和非 Sheet 下也会出现异常。

### TextField

简单应用没有问题，除了不支持多行输入。

但如果对 TextField 的 binding text 进行实时判断处理的话，系统自带的中文输入法将无法输入中文，绝大多数第三方输入法没有问题。最后使用
UITextView 解决。

如果 TextField 在 ScrollView 中，当在不同的 Segment Picker
中切换时，使用系统自带中文输入会闪退。英文和第三方中文输入没有问题。

不支持输入后隐藏输入法，需要通过 UIKit 想办法解决。

### Text

没什么大问题，挺好用，就是版式控制弱了点。

### Form

如果 Form 中使用 if 根据条件动态显示的话，会有灵异事件。同样代码，有时可以正常编译，有时不能。同样的 Form 代码，有时在 Sheet
中可以正常编译，移出 Sheet 又编译错误，有时反之。

### List

List 具备惰性数据加载能力，很适合数据量较大的场景。但版式控制力差。如果非要在 init 中使用类似 UITableView. appearance
之类的方式进行设定的话，单个 view 中的设定会影响整个 app（ 除非能够很好地控制该 view 的初始化和销毁 ）。这也是目前 SwiftUI
中控件显示设定的一个问题（ 主要是官方并不推荐和支持这样的行为 ），各个 view 中如果通过 UIKit 修改设定的话，之间不隔离。

如果有 animation 的话，数据多时效率会很低，使用 id 强制重绘可以解决。

### VStack HStack ZStack

版式控制很方便，可以在短时间内就完成较复杂的版式构图。不过其对 ViewBuilder 的类型支持比较有限，一个 Stack 中所能包含的 Stack
也不能过于复杂（ 目前 apple 也就只定义了几种 TupleView 的形式 ）。尤其对于在 if 后的 Stack 要求严格。判断分支中的 some
view 有时会要求得极为变态，但有时又会适当放松。

### Picker

种类基本够用，细节还需要进一步加强。Segment 必须动画显示完才转换，有粘滞感。Date 占地较大。

### ForEach

视图声明中唯一的循环控制方式，控制力有待加强。

如果使用 `data: Range<Int>` 的话，range 不可变。比如说 `0..<students.count` students
数量如果动态变化会 game over 。

### GeometryReader PreferenceKey 等

视图自我认知的好手段。通过 Geometry Proxy 可以获得足够的空间信息，如果需要将信息传递给上层视图的话，通过 PreferenceKey
即可完成

### Preview

很好的想法，对于简单的 view 响应很快。不过一旦 view 比较复杂，有时候还不如 rebuild 来的爽。另外如果 view
的初始参数比较复杂，比如直接传递个 NSManagedObject，构建 preview 也很麻烦。后期多数时间都直接删除，前期构建框架时很好用。

### Combine

很好用，很方便。和很多系统自带框架结合也很好，不愧是系统级的支持。

效率目前有问题。SwiftUI 中的多数控件都是采用 bind 的方式来响应及传递数据，设计起来思路会很清晰，不过执行起来会有粘滞感。复杂 Sheet
会尤其明显。所有基于异步的设计响应都会有延时。希望将来能够对响应进行一定的优化。我的 app 中有几处 Sheet 弹出的响应就比较慢（ 将 view 移出
sheet，使用 NavigationLink 调用显示就很好 ），尤其是退出时的响应更慢。感觉 SwiftUI 在销毁 view 上的代码有比较严重的效率
bug（ 参见上面的 TabView ）。

### Core Data

新的基于 iCloud 同步（ 不是 CloudKit ）很好用，设置也非常方便。

开发环境下 app 里云数据库中的数据和 app store 下载的 app 数据不互通（ 同一个 id
），开发时模拟器里的数据也不能和实机的数据云同步，必须在多个实机中才能测试。

我的 app 是有纯本地数据库（ 无需同步 ）和同步数据库的，各自在不同的 Configuration 里。不同的 Configuration 之间不能建立
relationship，毕竟是两个不同的 sqlit 库。

不要用数据库的思路使用 Core Data.

RelationShip 是一个好东西，系统会自动维护数据之间的关系。

由于有了 RelationShip，多数情况下无需自己设计主键，这是一个极大的便利，但当需要将数据库手动导出备份时却出现了问题。你无法使用系统内置的主键或
ObjectID。最后还是在需要导出的 Entite 中追加了可标识的属性。平时的程序运行完全不依赖于该属性，在导出 JSON
时则依赖这些属性来标注他们之间的 relationship.

在托管上下文中，数据的执行效率很高。

@FetchRequest 对数据的动态管理非常好，在 SwiftUI 中数据的任何变化都能动态体现。

@FetchRequest 目前只能在 init 中通过参数动态设置一次（ 无法动态修改 ），如果需要显示不同的谓词或排序结果，只能通过上层视图重新设置。

@FetchRequest 没办法设置 fetchLimit 等更多优化参数。

### 应用内购买

技术上并不复杂，因为我并不需要自设服务器来二度认证，所以逻辑上就简单了很多。唯一的就是苹果在购买完成后最初的完成反馈其实并不能保证用户已经付款，所以需要在后台查询确保已付款成功。退款等也不会有提示，反正定期更新收据就行了。

### App Store 审核

我在审核上卡的时间比较久，完全是因为自己没有搞懂它的使用方法。碰到的大多问题都源自应用内购买。

最初是因为元数据缺失，反复了两三次后我才搞明白需要填写内购资费的截图和备注。

后来发现还需要在 app 提交中选择 app 中使用的内购资费。

如果此时我不做任何动作就没问题了。但我一时头脑发热在 app 已经进入了 review 的情况下改动了资费的元数据，结果 app
被拒，而此时该资费便始终处于审核状态。

等不下去了，删除了原来的资费数据又重新创建了资费数据，提交审核资费通过。

将新的资费数据重新填入 app 的提交中，再度被拒。

原来描述中没有内购资费的详细说明，修改后终于通过。

用时较长的主要原因是每次的反馈都需要 1 天，而且 apple 的回复也确实太泛泛，让人疑惑。

### 其他的以后有时间再写

虽然目前仍有很多不足，但 SwiftUI + Combine 的方向绝对正确，即使在当下也可以带来很大的效率提升。再过 2—3
年，相信能有非常大的提高。CoreData 很好用，原生的 iOS 程序还是可以多多考量它的。

## 尾声

一不小心就乱写了一大堆，就当是对这几个月的一个简单小结吧。

# CoreData 探秘 - 从数据模型构建到托管对象实例

对每一个使用 Core Data 的开发者来说，用 Xcode 的 Core Data
模型编辑器构建数据模型、创建容器、加载数据模型并通过托管对象上下文最终创建托管对象实例，这都是十分普通的过程。但你是否好奇过这一切的内部运行机制，Core
Data 是如何在幕后辅助我们完成这一切的？本文将深入探究 Core Data 是如何通过数据模型构建出托管对象实例的内部运行机制，读完本文可以让你对
Core Data 的工作流程有更深入的理解，在开发中可以更得心应手。

## 写在前面的话

最近我正在撰写有关 SwiftData 并发的文章。原计划在第一部分中探讨 SwiftData 如何根据模型声明来创建 PersistentModel
实例。本打算用几段文字阐明，但在写作时发现无法简单表述，必须将该部分独立成文。当我着手编写这篇文章时，又发现需要另一篇文章来具体说明 Core Data
版本的实现过程。由此偶然间诞生了这篇文章。

在本文中，我们不会深入讨论从构建数据模型到创建托管对象实例的每个细节。我们主要将探讨两个环节：Core Data 如何将模型文件转换为
ManagedObjectModel，以及它如何从中提取信息来创建托管对象实例。

> 本文将以 Xcode 创建的 Core Data 项目模版提供的数据模型文件作为讨论基础

## 用模型编辑器构建 Core Data 数据模型文件

Xcode 的模型编辑器为我们提供了一个可视化的界面来定义 Core Data
应用程序的数据模型，包括实体、属性等信息。使用模型编辑器可以更直观地构建数据模型。

当新建项目选择包含 Core Data 时，Xcode 会在项目中自动创建一个名为 `ProjectName.xcdatamodeld`
的数据模型文件（ Core Data Model Bundle ）。我们也可以自行在项目中创建 Core Data 数据模型文件，其文件扩展名为 `.xcdatamodeld` 。

![image-20230918092422868](https://cdn.fatbobman.com/image-20230918092422868.png)

![image-20230918092749973](https://cdn.fatbobman.com/image-20230918092749973.png)

Xcode 将开发者在模型编辑器中创建的一切信息都保存在 xcdatamodeld 中。

确切来说，xcdatamodeld 是一个目录，通常被称为 “Core Data Model Bundle”。它是一个特殊的 Bundle，用于存储和管理
Core Data 的数据模型信息。它包含了一个或多个数据模型文件（ `.xcdatamodel` ）以及其他与数据模型相关的信息。Xcode 会在
xcdatamodeld 中为每个模型版本分别创建一个 `VersionName.xcdatamodel` 的 Bundle。

现在，用文本编辑器打开 `xcdatamodel` 中的 `content` 文件，可以看到，当前版本的所有模型信息，都是以 XML
的格式保存在其中。

XML

Copy code

Copied!

    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="1" systemVersion="11A491" minimumToolsVersion="Automatic" sourceLanguage="Swift" usedWithCloudKit="false" userDefinedModelVersionIdentifier="">
        <entity name="Item" representedClassName="Item" syncable="YES" codeGenerationType="class">
            <attribute name="timestamp" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        </entity>
        <elements>
            <element name="Item" positionX="-63" positionY="-18" width="128" height="44"/>
        </elements>
    </model>

其中，每个 entity 元素对应一个 Entity，包含了实体名称、对应的子类名称、属性、关系、自定义索引等众多信息。如果我们在模型编辑器中创建了新的
Configuration 或 Fetch Request ，也能在 XML 文件中找到对应的信息。在 Xcode 14
中，可视化的关系视图被取消了。这个关系视图在模型编辑器中起到了重要的作用，可以直观地显示实体之间的关系。由于取消了可视化的关系视图， `elements` 元素中的信息基本上失去了作用。

Xcode 在编译项目时，会将 `.xcdatamodel` 目录以 `momd` 为尾椎添加到应用的资源中，其中的 `xcdatamode`
Bundle 会编译成尾缀为 `mom` 的二进制文件，一方面减少空间占用，另一方面也可以提高加载速度。这也是当我们用代码加载模型文件时，尾缀需要设置为
`momd` 的原因。

开发者应该了解的是，我们通过 Xcode 的模型编辑器创建的模型文件只是一种对模型的结构化表达，并非程序化表达。

## 生成实体对应的 NSManagedObject 子类声明

在绝大多树情况下，开发者都会为 Entity 创建对应的 NSManageObject 子类声明。当 Codegen 设置为 Class
Definition 或 Category/Extension 时，Xcode 会隐式的帮我们完成这项工作。

![image-20230918143644990](https://cdn.fatbobman.com/image-20230918143644990.png)

当 Codegen 设置为 Class Definition 时，Xcode 会生成一个独立的 NSManagedObject
子类，其中包含了实体属性和方法的定义。例如：

    @objc(Item)
    public class Item: NSManagedObject {}

    extension Item {
        @nonobjc public class func fetchRequest() -> NSFetchRequest<Item> {
            return NSFetchRequest<Item>(entityName: "Item")
        }

        @NSManaged public var timestamp: Date?
    }

    extension Item : Identifiable {}

当 Codegen 设置为 Category/Extension 时，Xcode 会生成一个扩展，将实体属性和方法添加到 NSManagedObject
的默认实现中。这样可以避免修改自动生成的代码，保持代码的可维护性。

> `@NSManaged` 是一个属性修饰符，用于标记一个被 Core Data 管理的属性。它告诉编译器这个属性将由 Core Data
> 自动生成相关的存取方法，并且在运行时会动态地与托管对象上的属性进行关联。

开发者也可以选择手动创建这些代码，或使用 Xcode 显式生成。手动创建代码可以更准确地表达属性类型，并且灵活性更高。使用 Xcode
生成代码可以省去手动编写的工作量，特别是在属性较多或模型结构复杂的情况下。无论选择哪种方式，生成一个符合 NSManagedObject
的子类声明，可以让开发者更加安全、方便地访问托管对象的托管属性，并且通过重写子类的某些方法（例如：willSave），可以将某些操作特定到具体的实体上。

    extension Item {
        public override func willSave() {
            super.willSave()
            // do something
        }
    }

尽管可以获得上述优势， **但为实体声明一个对应的 NSManagedObject 的子类并非是必须的** 。这是因为 Core Data
也提供了一种轻量级的方式来访问和操作托管对象，即使用 `NSManagedObject` 对象本身来进行属性访问和操作。

    // item:Item
    let timestamp = item.timestamp
    // object is a NSManagedObject instance create by Item Entity description
    let timestamp = object.value(forKey: "timestamp") // trigger KVO
    let timestamp = object..primitiveValue(forKey: "timestamp") // not trigger KVO

在上面的示例中， `item.timestamp` 是通过为实体 `Item` 声明一个对应的 NSManagedObject 的子类（ `Item` ）来实现的，而 `object.value(forKey:)` 和 `object.primitiveValue(forKey:)`
是通过 `NSManagedObject` 对象本身来访问属性的方法。需要注意的是， `value(forKey:)` 方法会触发 Key-
Value Observing (KVO)，而 `primitiveValue(forKey:)` 方法则不会触发 KVO。

> 在某种程度上，我们可以将 `@NSManaged` 视作与 Swift 的计算属性类似的机制。通过 `value(forKey:)` 和 `setValue(_:forKey:)`
> 方法，我们可以读取和设置托管对象的底层值。这使得我们可以在需要的时候对属性进行自定义的逻辑操作，例如数据格式转换、数据校验等。

## 加载数据模型，创建 Container

自从 Core Data 提供了 NSPersistentContainer
后，除非特别情况，开发者几乎都不会在代码中显式地读取数据模型文件并创建数据模型了（ NSManageObjectModel ）。

    let container = NSPersistentContainer(name: "ModelEditorDemo")

然而，了解 Core Data 在创建 container 的背后所做的工作，对于之后理解托管对象实例的创建过程仍然非常有帮助。

    // Load the data model file and create NSManagedObjectModel
    guard let url = Bundle.main.url(forResource: "ModelEditorDemo", withExtension: "momd"),
          let dataModel = NSManagedObjectModel(contentsOf: url) else {
         fatalError("Failed to load the data model file")
    }

    // Create the persistent store coordinator
    let coordinator = NSPersistentStoreCoordinator(managedObjectModel: dataModel)

    // Get the configuration from the data model
    let configuration = dataModel.configurations.first!

    // Create the URL for the persistent store
    let storeURL = URL.applicationDirectory.appending(path: "store.sqlite")

    // Create or load the persistent store with the specified configuration
    guard let store = try? coordinator.addPersistentStore(type: .sqlite, configuration: configuration,at: storeURL,options: nil) else {
        fatalError("Failed to create persistent store: \(error)")
    }

    // Create a main queue NSMangedObjectContext
    let viewContext = NSManagedObjectContext(.mainQueue)
    // Link context to coordinator
    viewContext.persistentStoreCoordinator = coordinator

大致的流程如下：

1. 获取数据模型文件（momd）的 URL。

2. 使用该 URL 创建一个 NSManagedObjectModel 实例。

3. 使用 NSManagedObjectModel 实例创建一个 NSPersistentStoreCoordinator 实例。

4. 在 NSPersistentStoreCoordinator 实例上添加一个持久化存储。

5. 创建一个主线程的托管对象上下文。

6. 将上下文与 NSPersistentStoreCoordinator 实例关联。

其中，在使用数据模型文件 URL 来创建 NSManagedObjectModel 实例的时候，Core Data
会将模型文件中的描述率先转换成对实体的程序式表达，然后再通过这些程序式表达创建 NSManagedObjectModel
实例。这种转换过程使得我们能够以编程方式来创建和操作数据模型，而不仅限于使用可视化编辑器。

## 以编程的方式来描述实体，创建数据模型实例

除了使用数据模型编辑器进行可视化操作外，Core Data 提供了以编程的方式来表述实体并创建数据模型的方式。

下面的代码，展示了编程化的方式来描述 Item 实体并创建数据模型的过程。

    func createModel() -> NSManagedObjectModel {
        let itemEntityDescription = NSEntityDescription()
        // Entity Name
        itemEntityDescription.name = "Item"
        // NSManagedObject SubClass Name
        itemEntityDescription.managedObjectClassName = "Item"
        // Descriptor timestamp attribute
        let timestampAttribute = NSAttributeDescription()
        // Attribute Name
        timestampAttribute.name = "timestamp"
        // Is Optional
        timestampAttribute.isOptional = true
        // Attribute Type
        if #available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *) {
            timestampAttribute.type = .date
        } else {
            timestampAttribute.attributeType = .dateAttributeType
        }
        // Add timestamp to Item
        itemEntityDescription.properties.append(timestampAttribute)
        // Create a empty NSManagedObject
        let model = NSManagedObjectModel()
        // Add Item Entity into model
        model.entities = [itemEntityDescription]
        return model
    }

上面的代码几乎与我们在模型编辑器中所做的操作一一对应。然而，当属性数量众多或关系复杂时，可视化操作更加高效和便利。通过可视化操作，我们可以直观地在图形界面中添加、编辑和删除实体、属性和关系，而不需要手动编写大量的代码。这使得数据模型的创建和维护变得更加容易和快速。

现在我们就可以用这段代码，替换掉之前通过数据模型文件创建 NSManagedObjectModel 的操作。

    // Create data model by programming way
    let dataModel = createModel()

    // Create persistent store coordinator by dataModel
    let coordinator = NSPersistentStoreCoordinator(managedObjectModel: dataModel)

尽管可视化编辑更加高效，不过编程式表述为开发者提供更广阔的数据模型描述的空间，可以将自定义的描述方式映射为 Core Data
可以接受的程序化表达。这种灵活性使得开发者能够更好地满足特定的业务需求，另外，编程方式还可以提供更多的类型安全和编译时检查，减少了在运行时出现错误的可能性。

## 创建托管对象实例

Core Data 是一个对象图管理框架，我们构建数据模型的目的是为了以面向对象的方式操作持久化数据。具体的数据操作通常会在托管对象实例上进行。

最常见的获取托管对象实例的途径有两种：

- 设置谓词，通过 NSFetchRequest ，Core Data 将符合条件数据以托管对象的形式返回给开发者
- 通过直接调用与 Entity 对应的 NSManagedObject 子类的构造方法创建托管对象实例

开发者惯常使用下面这种方式创建托管对象实例：

    let item = Item(context: viewContext)
    item.timestamp = .now
    try? viewContext.save()

然而 `init(context:)` 要求我们必须首先创建托管对象上下文（ NSManagedObjectContext ），其实，在 Core
Data 中，我们完全可以在没有上下文的情况下来创建托管对象实例。

    let item = Item(entity: Item.entity(), insertInto: nil)
    item.timestamp = .now
    viewContext.insert(item)
    try? viewContext.save()

事实上， `init(entity:, insertInto:)` 构造方法是 NSManagedObject 的指定初始化器（designated
initializer），而 `init(context:)` 是其便捷初始化器（convenience
initializer）。创建托管对象实例的关键并不在于是否有托管对象上下文，而在于告诉 NSManagedObject，该实例对应的是哪个
EntityDescription。

需要注意的是，当我们使用 `Item.entity()` 来获取 Item 对应的 EntityDescription 时，需确保
NSManagedObjectModel 已经被 NSPersistentStoreCoordinator 加载。

    let coordinator = NSPersistentStoreCoordinator(managedObjectModel: dataModel)

在 Core Data 中，当 NSPersistentStoreCoordinator 被创建后，数据模型会被保存在一个可供内部元素访问的位置，以便获取。
`Item.entity()` 方法会从中获取 Item 对应的 EntityDescription。如果我们在创建
NSPersistentStoreCoordinator 时没有使用包含 Item 的数据模型，或根本没有创建
NSPersistentStoreCoordinator，调用 `Item.entity()` 后，Core Data 会抛出如下错误：

Shell

Copy code

Copied!

    CoreData: error: No NSEntityDescriptions in any model claim the NSManagedObject subclass 'Item' so +entity is confused.  Have you loaded your NSManagedObjectModel yet ?

这并不意味着我们没有其他方法可以绕过 NSPersistentStoreCoordinator 的限制。

    guard let url = Bundle.main.url(forResource: "ModelEditorDemo", withExtension: "momd"),
          let dataModel = NSManagedObjectModel(contentsOf: url) else {
         fatalError("Failed to load the data model file")
    }

    let entityDescription = dataModel.entitiesByName["Item"]!
    let item = Item(entity: entityDescription, insertInto: nil)

通过直接从 NSManagedObjectModel 获取对应的 EntityDescription，开发者可以在仅拥有
NSManagedObjectModel
实例的情况下，就具备了创建托管对象实例的条件。这对于某些特定情况下，只需要操作数据模型而无需操作托管对象上下文的场景非常有用。

> 阅读 [ 如何在 Xcode 下预览含有 Core Data 元素的 SwiftUI 视图
> ](/zh/posts/coredatainpreview/) 一文，查看此种方法在 SwiftUI 预览中的应用。

正如前文所提到的，开发者并不一定要创建托管对象子类的实例。通过使用正确的 EntityDescription，我们可以创建 NSManagedObject
实例，在许多场景下可以达到同样的效果。

    let item = NSManagedObject(entity: Item.entity(), insertInto: nil)
    item.setValue(Date.now, forKey: "timestamp")
    viewContext.insert(item)
    try? viewContext.save()

## 最后

在本文中，我们探讨了几种不同的在 Core Data
中构建数据模型和创建托管对象实例的方法，其中一些方法可能并不常见。有些读者可能会对这些方法感到困惑，但即使不了解这些方法，也不会影响我们熟练使用 Core
Data。然而，本文创作的目的正是向读者介绍这些非常见的方法，因为在接下来的文章中，我们将探讨 “SwiftData 如何根据模型声明来创建
PersistentModel 实例”。届时，我们将看到 SwiftData 开发团队是如何利用本文介绍的内容和 Swift
的新特性，构建出符合新时代的持久化框架的。

# 解析 SwiftUI 中两处由状态更新滞后引发的严重 Bug

众所周知，SwiftUI
是一个响应式框架，这意味着，当数据源发生变化时，框架会自动更新视图。同样，当我们想调整视图显示时，应直接对状态进行修改。但是，SwiftUI
中的一些系统控件并没有完全遵循响应式的设计原则，由此在某些情况下会出现严重的错误，影响用户体验，并使开发者无所适从。

本文将解析 SwiftUI 中两个由于未能贯彻响应式编程原则而导致的严重错误，并提供相应的解决方案。这两个错误包括：通过手势取消 Sheet
后，快速右滑导航容器导致应用锁死；以及在滚动中返回上层视图时导致应用崩溃。

## 视图变化在前、状态变化在后

在 SwiftUI 中，某些可编程控件在执行一定的操作时，会先更新视图，待视图变化完成后再修改与其对应的状态。这些控件基本上都是对
UIkit（AppKit）的二次包装。

### Sheet

执行下面的代码，你可以清楚地看到，在通过手势取消 Sheet 时，与其关联的状态是在 Sheet
完成取消动画后才发生了改变。而通过调用环境值或直接修改绑定状态，SwiftUI 则遵循了响应式编程原则，进行了的先调整状态，后更新视图的操作。

    struct SheetDemo: View {
        @StateObject var store = SheetStore()
        var body: some View {
            Button("Show") {
                store.show.toggle()
            }
            .sheet(isPresented: $store.show) {
                SheetView()
                    .environmentObject(store)
            }
        }
    }

    struct SheetView: View {
        @Environment(\.dismiss) var dismiss
        @EnvironmentObject var store: SheetStore
        var body: some View {
            VStack {
                Button("Dismiss by ENV") {
                    print("Dismiss by ENV")
                    dismiss()
                }
                Button("Dismiss by Store") {
                    print("Dismiss by Store")
                    store.show = false
                }
            }
        }
    }

    class SheetStore: ObservableObject {
        @Published var show = false {
            didSet {
                print("show \(show ? "T" : "F")")
            }
        }
    }

> 请注意观察，在操作后命令行界面的输出情况。

![sheet-dismiss-demo_2023-08-29_15.37.17.2023-08-29
15_40_10](https://cdn.fatbobman.com/sheet-dismiss-
demo_2023-08-29_15.37.17.2023-08-29%2015_40_10.gif)

### NavigationStack

NavigationStack 同样也存在类似的情况。运行下面的代码，点击左上方的返回按钮，与 NavigationStack 绑定的
path，直到视图返回上一层后，才会发生改变。通过环境值返回上层视图也同样需要等待视图返回后，才会修改状态。只有直接修改 path，SwiftUI
才能表现的像一个真正的响应式编程框架。

    struct NavigationStackDemo: View {
        @StateObject var store = StackStore()
        var body: some View {
            NavigationStack(path: $store.path) {
                List(0 ..< 20) { i in
                    NavigationLink(value: i) { Text("\(i)") }
                }
                .navigationDestination(for: Int.self) { n in
                    Row(n: n)
                        .environmentObject(store)
                }
            }
        }
    }

    struct Row: View {
        @Environment(\.dismiss) var dismiss
        @EnvironmentObject var store: StackStore
        let n: Int
        var body: some View {
            List {
                Button("Dismiss By ENV") {
                    print("Dismiss By Env")
                    dismiss()
                }
                Button("Dismiss By Store") {
                    print("Dismiss by Store")
                    store.path.removeLast()
                }
            }
            .navigationTitle("\(n)")
        }
    }

    class StackStore: ObservableObject {
        @Published var path = [Int]() {
            didSet {
                print("set path \(path)")
            }
        }
    }

![stack-back-demo_2023-08-29_15.55.31.2023-08-29
15_56_48](https://cdn.fatbobman.com/stack-back-
demo_2023-08-29_15.55.31.2023-08-29%2015_56_48.gif)

### 这有什么问题吗？

如果仅从上述两个例子考虑，无论状态调整是否及时，都不会出现什么错误的结果。但是，当应用程序处于某些特殊状态或用户进行某些特定操作时，状态更新的滞后会导致不可接受的后果。

## 通过手势取消 Sheet 后，快速右滑导航容器会导致应用锁死

这是一个在 SwiftUI 所有版本中存在的错误，你可以在众多的论坛或聊天室里看到不少的开发者都在寻找解决方法。它的复现条件非常简单：

- 在真机上测试（ 模拟器上不容易复现 ）
- 点击 “GO” 按钮进入下一层视图
- 点击 “Show Sheet” 按钮弹出 Sheet
- 通过下滑手势取消 Sheet
- 在 Sheet 取消后（动画结束时）， **立即** 在屏幕上由左至右滑动，返回上一层视图
- 在滑动返回到上一层视图后，应用会锁死。

  struct SheetDismissDemo: View {
  @State var showSheet = false
  var body: some View {
  NavigationStack {
  VStack {
  NavigationLink("GO") {
  VStack {
  Button("Show Sheet") {
  showSheet.toggle()
  }
  .sheet(isPresented: $showSheet) {
  SheetDetailView()
  }
  }
  }
  }
  }
  }
  }

  struct SheetDetailView: View {
  var body: some View {
  Text("Sheet")
  }
  }

> 注意观察，在尝试使用手势返回上层视图后，左上角的 Back 按钮将消失，但视图并没有返回根视图

![sheet-dismiss-demo2_Final1693298235.2023-08-29
16_39_51](https://cdn.fatbobman.com/sheet-dismiss-
demo2_Final1693298235.2023-08-29%2016_39_51.gif)

如果我告诉你，上述情况正是由前文提到的状态更新滞后所导致，那么你该如何避免这个问题呢？

我们首先做一个测试：

    struct SheetDetailView: View {
        @Binding var isPresented: Bool
        var body: some View {
            Button("Dismiss") {
                isPresented = false
            }
        }
    }

在修改了 SheetDetailView 的代码后，我们不再使用手势来取消 Sheet，而是通过点击 “Dismiss”
按钮来实现这一操作。再次执行上述过程，您会发现在返回上层视图后，应用并不会锁死，一切都恢复了正常。

然而，明显地，强迫用户点击 “Dismiss” 按钮并不是一个好的选择，特别是在没有屏蔽手势取消 Sheet 的情况下。

通过下面的代码，我们可以让用户使用下滑手势来取消 Sheet，同时又不会导致应用锁死。

    struct SheetDismissDemo: View {
        @State var showSheet = false
        var body: some View {
            NavigationStack {
                VStack {
                    NavigationLink("GO") {
                        VStack {
                            Button("Show Sheet") {
                                showSheet.toggle()
                            }
                            .sheet(isPresented: $showSheet) {
                                SheetDetailView()
                            }
                        }
                    }
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .overlay(
                Group {
                    // disable NavigationStack gesture when showSheet is true
                    if showSheet {
                        Color.white.opacity(0.01)
                            .highPriorityGesture(DragGesture(minimumDistance: 0))
                    }
                }
            )
        }
    }

    struct SheetDetailView: View {
        var body: some View {
            Text("Sheet")
        }
    }

原理如下：当 showSheet 为真时，为 NavigationStack 添加一个屏蔽手势的前景视图，以确保用户只能在 showSheet
为否时通过滑动返回到上一层视图。

## 当视图正在滚动时返回上一层视图会导致应用崩溃

这是一个由 xiaogd 在我的 Discord 论坛中提出的 [ 问题
](https://discord.com/channels/967978112509935657/1101097701975801887)
。它的复现条件如下：

- iOS 16 系统，在真机或模拟器上测试
- 点击视图列表中的按钮，可以进入下一级视图。请至少进入第三级视图
- 滚动当前视图
- 当视图处于滚动状态时，点击 NavigationStack 左上角的 “Back” 按钮。
- 在返回上层视图后，继续点击 “Back” 按钮
- 应用大概率会出现崩溃情况

  struct NavigationStackBackDemo: View {
  @StateObject var pathHolder = PathHolder()
  var body: some View {
  NavigationStack(path: $pathHolder.path) {
  DetailView()
  .navigationDestination(for: Int.self) { \_ in
  DetailView()
  }
  }
  .environmentObject(pathHolder)
  }
  }

  struct DetailView: View {
  @EnvironmentObject var holder: PathHolder
  var body: some View {
  ScrollView {
  ForEach(0 ..< 100) { i in
  NavigationLink(value: i) {
  Text("\(i)")
  .font(.title)
  .foregroundStyle(.yellow)
  .frame(maxWidth: .infinity)
  .frame(height:150).padding(.vertical,5)
  .background(.blue)
  }
  }
  }
  .navigationBarTitleDisplayMode(.inline)
  .navigationTitle(!holder.path.isEmpty ? "\(holder.path.count)" : "Root")
  }
  }

  class PathHolder: ObservableObject {
  @Published var path = [Int](){
  didSet{
  print("set path \(path)")
  }
  }
  }

![navigationStack-back-demo2_2023-08-29_18.10.50.2023-08-29
18_12_07](https://cdn.fatbobman.com/navigationStack-back-
demo2_2023-08-29_18.10.50.2023-08-29%2018_12_07.gif)

根据前文所述，我们知道直接点击 NavigationStack 提供的 Back
按钮，状态只会在视图已经返回到上一层时才会更新。如果我们认为问题出在这里，就需要使用编程式导航的方式来调整代码。

为了不影响用户的使用习惯，我们禁用了 NavigationStack 自带的 Back 按钮。通过自定义返回按钮以及扩展
UINavigationController 的方式，实现了在禁用 Back 按钮后仍支持手势返回，并先修改状态后再进行视图响应。

    ScrollView {
      ....
    }
    // start
    .navigationBarBackButtonHidden(true)
    .toolbar {
        if !holder.path.isEmpty {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    holder.path.removeLast()
                } label: {
                    Image(systemName: "chevron.backward")
                }
            }
        }
    }
    // end
    .navigationBarTitleDisplayMode(.inline)

扩展 UINavigationController：

    extension UINavigationController: UIGestureRecognizerDelegate {
        override open func viewDidLoad() {
            super.viewDidLoad()
            interactivePopGestureRecognizer?.delegate = self
        }

        // Allows swipe back gesture after hiding standard navigation bar with .navigationBarHidden(true).
        public func gestureRecognizerShouldBegin(_: UIGestureRecognizer) -> Bool {
            viewControllers.count > 1
        }

        // Allows interactivePopGestureRecognizer to work simultaneously with other gestures.
        public func gestureRecognizer(_: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith _: UIGestureRecognizer) -> Bool {
            viewControllers.count > 1
        }

        // Blocks other gestures when interactivePopGestureRecognizer begins (my TabView scrolled together with screen swiping back)
        public func gestureRecognizer(_: UIGestureRecognizer, shouldBeRequiredToFailBy _: UIGestureRecognizer) -> Bool {
            viewControllers.count > 1
        }
    }

![navigationStack-back-demo3_2023-08-29_18.20.16.2023-08-29
18_21_23](https://cdn.fatbobman.com/navigationStack-back-
demo3_2023-08-29_18.20.16.2023-08-29%2018_21_23.gif)

> 这个问题已经在 iOS 17 中得以修复，不知道是否和我们在 Discord 中讨论后给苹果提交的 Feedback 有关。

## 为什么状态更新滞后会导致严重错误

由于 SwiftUI 的不透明性，想要分析这些问题的成因并不容易。幸运的是，我从 [ @KyleSwifter
](https://twitter.com/KyleSwifter) 的 [ 解密 SwiftUI 背后的 AttributeGraph
](https://kyleye.top/posts/demystify-attributegraph-1/) 一文中找到了线索。

AttributeGraph 是 SwiftUI 用于维护众多数据源与视图之间依赖关系的工具。为了改善 AttributeGraph
的效率并减少其占用空间，SwiftUI 会在一些特定情况下对其进行清理和维护（例如通过 `CFRunLoopObserverCreate` 监听
Runtime 的空闲时机）。

在我们遇到问题的两个场景中，应用程序都恰好使用了导航容器，并且通过特定的操作，使 RunLoop 处于了适合 AG
打包更新的状态。由于在返回上层视图时，状态尚未更新，因此在清理 AG 时（返回动画运行中），会破坏应用程序的 AttributeGraph
完整性，从而导致应用程序死锁或崩溃。

因此，当我们首先更新状态，然后 SwiftUI 再响应该状态的变化（返回上层视图），即使此时对 AG 进行清理，仍将可以保证 AttributeGraph
的完整性，应用自然不会出现问题。

> 状态更新滞后不仅存在于本文介绍的两个案例中，当开发者遇到类似情况时，可以尝试采用状态更新优先的开发策略进行修改。

## 总结

今年 SwiftUI 已经进入了第五个年头。随着版本的提高，SwiftUI 的功能也确实得到了相当程度的增加。不过，即使在最新的版本中，在一些对
UIKit（AppKit）进行二次包装的控件中，仍有不少细节处理不到位的问题。希望 SwiftUI 开发组能尽早重视这些问题。

# 掌握 SwiftUI 的 task 修饰器

随着 Swift 5.5 引入了 async/await 特性，苹果也为 SwiftUI 添加了 task 视图修饰器，以方便开发者在视图中使用基于
async/await 的异步代码。本文将对 task 视图修饰器的特点、用法、注意事项等内容做以介绍，并提供了将其移植到老版本 SwiftUI 的方法。

## task vs onAppear

SwiftUI 提供了两个版本的 task 修饰器，版本一的作用和调用时机与 onAppear 十分类似：

    public func task(priority: TaskPriority = .userInitiated, _ action: @escaping @Sendable () async -> Void) -> some View

![image-20220806084339042](https://cdn.fatbobman.com/image-20220806084339042.png)

![image-20220806084436930](https://cdn.fatbobman.com/image-20220806084436930.png)

通过 task 修饰器开发者可以添加在视图“出现之前”的异步操作。

> 用 “出现之前” 来描述 onAppear 或 task 闭包的调用时机属于无奈之举。在不同的上下文中，“出现之前”会有不同的解释。详情请参阅 [
> SwiftUI 视图的生命周期研究
> ](/zh/posts/swiftuilifecycle/#onappear-%E5%92%8C-ondisappear) 一文中有关 onAppear
> 和 onDisappear 的章节

SwiftUI
为了判断视图的状态是否发生了改变，它会在视图的存续期内，反复地生成视图类型实例以达成此目的。因此，开发者应避免将一些会对性能造成影响的操作放置在视图类型的构造函数之中，而是在
onAppear 或 task 中进行该类型的操作。

    struct TaskDemo1:View{
        @State var message:String?
        let url = URL(string:"https://news.baidu.com/")!
        var body: some View{
            VStack {
                if let message = message {
                    Text(message)
                } else {
                    ProgressView()
                }
            }
            .task {  // VStack “出现之前” 执行闭包中的代码
                do {
                    var lines = 0
                    for try await _ in url.lines { // 读取指定 url 的内容
                        lines += 1
                    }
                    try? await Task.sleep(nanoseconds: 1_000_000_000) // 模拟更复杂的任务
                    message = "Received \(lines) lines"
                } catch {
                    message = "Failed to load data"
                }
            }
        }
    }

我们可以通过 priority 参数来设定创建异步任务时要使用的任务优先级（ 默认优先级为 userInitiated ）。

    .task(priority: .background) {
        // do something
    }

> 任务优先级并不会影响创建任务所使用的线程

## task vs onChange

另一个版本的 task 修饰器则提供了类似 onChange + onAppear 的联合能力。

    public func task<T>(id value: T, priority: TaskPriority = .userInitiated, _ action: @escaping @Sendable () async -> Void) -> some View where T : Equatable

除了在视图“出现之前”执行一次异步任务外，还会在其观察的值（ 符合 Equatable 协议 ）发生变化时，重新执行一次任务（ 创建一个新的异步任务 ）：

    struct TaskDemo2: View {
        @State var status: Status = .loading
        @State var reloadTrigger = false
        let url = URL(string: "https://source.unsplash.com/400x300")! // 获取随机图片的地址
        var body: some View {
            VStack {
                Group {
                    switch status {
                    case .loading:
                        Rectangle()
                            .fill(.secondary)
                            .overlay(Text("Loading"))
                    case .image(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                    case .error:
                        Rectangle()
                            .fill(.secondary)
                            .overlay(Text("Failed to load image"))
                    }
                }
                .padding()
                .frame(width: 400, height: 300)

                Button(status.loading ? "Loading" : "Reload") {
                    reloadTrigger.toggle()  // 读取新图
                }
                .disabled(status.loading)
                .buttonStyle(.bordered)
            }
            .animation(.easeInOut, value: status)
            .task(id: reloadTrigger) { // 在 VStack “出现之前” 以及当 reloadTrigger 发生变化时，执行如下内容。
                do {
                    status = .loading
                    var bytes = [UInt8]()
                    for try await byte in url.resourceBytes {
                        bytes.append(byte)
                    }
                    if let uiImage = UIImage(data: Data(bytes)) {
                        let image = Image(uiImage: uiImage)
                        status = .image(image)
                    } else {
                        status = .error
                    }
                } catch {
                    status = .error
                }
            }
        }

        enum Status: Equatable {
            case loading
            case image(Image)
            case error

            var loading: Bool {
                switch self {
                case .loading:
                    return true
                default:
                    return false
                }
            }
        }
    }

![task_onChange_Recording_iPhone_12_Pro_15.5_2022-08-06_10.50.13.2022-08-06
10_51_57](https://cdn.fatbobman.com/task_onChange_Recording_iPhone_12_Pro_15.5_2022-08-06_10.50.13.2022-08-06%2010_51_57.gif)

> 请阅读 [ 了解 SwiftUI 的 onChange ](/zh/posts/onchange/) 一文，掌握更多有关 onChang 修饰器的知识

## task 的生命周期

上文中的两段演示代码，即使算上网络延迟， task 闭包的运行持续时间也不会太长。这并没有充分发挥 task 的优势，因为我们还可以用 task
修饰器创建可以持续运行的异步任务：

    struct TimerView:View{
        @State var date = Date.now
        @State var show = true
        var body: some View{
            VStack {
                Button(show ? "Hide Timer" : "Show Timer"){
                    show.toggle()
                }
                if show {
                    Text(date,format: .dateTime.hour().minute().second())
                        .task {
                            let taskID = UUID()  // 任务 ID
                            while true { // 持续运行
                                try? await Task.sleep(nanoseconds: 1_000_000_000) // 间隔一秒
                                let now = Date.now // 每隔一秒更新一次时间
                                date = now
                                print("Task ID \(taskID) :\(now.formatted(date: .numeric, time: .complete))")
                            }
                        }
                }
            }
        }
    }

这段代码将通过 task 修饰器创建一个持续运行的异步任务，每秒更新一次 date 变量，并且在控制台中显示当前的任务 ID 及时间。

![task_longrun1_2022-08-07_09.07.44.2022-08-07
09_09_38](https://cdn.fatbobman.com/task_longrun1_2022-08-07_09.07.44.2022-08-07%2009_09_38.gif)

我们的本意是通过按钮来开启和关闭计时器的显示以控制任务的生命周期（ 关闭时结束任务 ），但在点击 Hide Timer 按钮后，app
出现了无法响应且控制台仍在持续输出（ 不按照原定的间隔时间 ）的情况，为什么会出现这样的问题呢？

> app 无法响应是由于当前 task 是在主线程上运行的，如果按照下文中的方法将 task 运行在后台线程之中，那么 app
> 将可以继续响应，但会在不显示日期文字的情况下，继续更新 date 变量，并且会在控制台持续输出

Swift 采用的是协作式任务取消机制，也就是说，SwiftUI 是无法直接停止掉我们通过 task 修饰器创建的异步任务的。当满足了需要停止由 task
修饰器创建的异步任务条件时，SwiftUI 会给该任务发送任务取消信号，任务必须自行响应该信号并停止作业。

在以下两种情况下，SwiftUI 会给由 task 创建的异步任务发送任务取消信号：

- 视图（ task 修饰器绑定的视图 ）满足 onDisappear 触发条件时
- 绑定的值发生变化时（ 采用 task 观察值变化时 ）

为了让之前的代码可以响应取消信号，我们需做如下调整：

    // 将
    while true {
    // 修改成
    while !Task.isCancelled { // 仅在当前任务没被取消时执行以下代码

![task_longrun2_2022-08-07_09.39.21.2022-08-07
09_40_53](https://cdn.fatbobman.com/task_longrun2_2022-08-07_09.39.21.2022-08-07%2009_40_53.gif)

开发者也可以利用 Swift 这种协作式取消的机制来实现一些类似 onDisappear 的操作。

    .task {
        let taskID = UUID()
        defer {
            print("Task \(taskID) has been cancelled.")
            // 做一些数据的善后工作
        }
        while !Task.isCancelled {
            try? await Task.sleep(nanoseconds: 1000000000)
            let now = Date.now
            date = now
            print("Task ID \(taskID) :\(now.formatted(date: .numeric, time: .complete))")
        }
    }

## task 运行的线程

使用 task 修饰器在视图中创建异步任务，除了方便使用基于 async/await 语法的 API
外，开发者也希望能够让这些任务运行在后台线程中，以减少主线程的负担。

非常遗憾，当前上文中所有的使用 task 创建的异步任务都是运行在主线程当中的。你可以通过在闭包中添加如下语句查看当前任务运行的线程：

    print(Thread.current)

    // <_NSMainThread: 0x6000011d0b80>{number = 1, name = main}

为什么会出现这样的情况呢？task 为什么没有默认运行在后台线程中？

> 使用 url. lines 和 url. resourceBytes 获取网络数据时，系统 API 会跳转到后台线程，不过最终仍会回到主线程上

想要了解并解决这个问题，我们还要从 task 修饰器的定义中入手。以下是 task 修饰器更加完整的定义（ 从 swiftinterface 文件中获得
）：

    @inlinable public func task(priority: _Concurrency.TaskPriority = .userInitiated, @_inheritActorContext _ action: @escaping @Sendable () async -> Swift.Void) -> some SwiftUI.View {
        modifier(_TaskModifier(priority: priority, action: action))
    }

其中 `@_inheritActorContext` 编译属性将为我们带来答案。

![image-20220807111608120](https://cdn.fatbobman.com/image-20220807111608120.png)

当一个 `@Sendable async` 闭包被标记 `@_inheritActorContext` 属性后，闭包将根据其声明的地点来继承
actor 上下文（ 即它应该在哪个 actor 上运行 ）。那些没有特别声明需运行在某特定 actor 上的闭包，它们可以运行于任意地点（ 任何的线程之中
）。

回到当前的问题，由于 View 协议限定了 body 属性必须运行于主线程中（ 使用了 @MainActor 进行标注 ），因此，如果我们直接在 body
中为 task 修饰器添加闭包代码，那么该闭包只能运行于主线程中（ 闭包继承了 body 的 actor 上下文 ）。

    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    public protocol View {
        associatedtype Body : View
        @ViewBuilder @MainActor var body: Self.Body { get }
    }

如果我们想让 task 修饰器中的闭包不运行在主线程上，只需要将其声明在没有要求运行于 @MainActor 的地方即可。例如，将上面的计时器代码修改为：

    struct TimerView: View {
        @State var date = Date.now
        @State var show = true
        var body: some View {
            VStack {
                Button(show ? "Hide Timer" : "Show Timer") {
                    show.toggle()
                }
                if show {
                    Text(date, format: .dateTime.hour().minute().second())
                        .task(timer)
                }
            }
        }

        // 在 body 外面定义异步函数
        @Sendable
        func timer() async {
            let taskID = UUID()
            print(Thread.current)
            defer {
                print("Task \(taskID) has been cancelled.")
                // 做一些数据的善后工作
            }
            while !Task.isCancelled {
                try? await Task.sleep(nanoseconds: 1000000000)
                let now = Date.now
                date = now
                print("Task ID \(taskID) :\(now.formatted(date: .numeric, time: .complete))")
            }
        }
    }

![task_thread1_2022-08-07_15.21.25.2022-08-07
15_23_01](https://cdn.fatbobman.com/task_thread1_2022-08-07_15.21.25.2022-08-07%2015_23_01.gif)

> 务必注意，如果将 `.task(timer)` 写为 `.task{ await timer() }` ，则仍会运行于主线程中

如果你的视图中声明了其他符合 DynamicProperty 协议的 Source of Truth （ **将 wrappedValue 和
projectedValue 标注为 @MainActor** ），那么上面的方法将不再适用。因为 **SwiftUI 会将视图类型的实例默认推断为标注了
@MainActor ，并限定运行于主线程（ 不仅仅是 body 属性 ）** 。

    struct TimerView: View {
        @State var date = Date.now
        @State var show = true
        // 在 StateObject 的定义中，wrappedValue 和 projectedValue 被标注了 @MainActor
        @StateObject var testObject = TestObject() // 导致 SwiftUI 会将视图类型的实例默认推断为运行于主线程
        var body: some View {
            VStack {
                Button(show ? "Hide Timer" : "Show Timer") {
                    show.toggle()
                }
                if show {
                    Text(date, format: .dateTime.hour().minute().second())
                        .task(timer)
                }
            }
        }

        // 在 body 外面定义异步函数
        @Sendable
        func timer() async {
           print(Thread.current) // 仍然会运行于主线程
           ....
        }
    }

我们可以通过将异步方法移到视图类型之外来解决这个问题。

SwiftUI 对 @State 做了特别的处理，我们可以在任意线程中对其进行安全的修改。但对于其他符合 DynamicProperty 协议的
Source of Truth （ 将 wrappedValue 和 projectedValue 标注为 @MainActor
），在修改前必须切换到主线程上：

    struct TimerView: View {
        @StateObject var object = TestObject()

        var body: some View {
            VStack {
                Button(object.show ? "Hide Timer" : "Show Timer") {
                    object.show.toggle()
                }
                if object.show {
                    Text(object.date, format: .dateTime.hour().minute().second())
                        .task(object.timer)
                }
            }
        }
    }

    class TestObject: ObservableObject {
        @Published var date: Date = .now
        @Published var show = true

        @Sendable
        func timer() async {
            let taskID = UUID()
            print(Thread.current)
            defer {
                print("Task \(taskID) has been cancelled.")
                // 做一些数据的善后工作
            }
            while !Task.isCancelled {
                try? await Task.sleep(nanoseconds: 1000000000)
                let now = Date.now
                await MainActor.run { // 需要切换回主线程
                    date = now
                }
                print("Task ID \(taskID) :\(now.formatted(date: .numeric, time: .complete))")
            }
        }
    }

## task vs onReceive

通常，我们会用 onReceive 修饰器在视图中响应 Notification Center 的消息。作为一个事件源类型的 Source of
Truth，每当接收到一个新的消息时，它都会导致 SwiftUI 对视图的 body 重新求值。

> 请阅读 [ 避免 SwiftUI 视图的重复计算
> ](/zh/posts/avoid_repeated_calculations_of_swiftui_views/)
> 一文，以了解更多有关事件源方面的内容

如果，你想有选择性的处理消息，可以考虑用 task 来代替 onReceive，例如：

    struct NotificationHandlerDemo: View {
        @State var message = ""
        var body: some View {
            Text(message)
                .task(notificationHandler)
        }

        @Sendable
        func notificationHandler() async {
            for await notification in NotificationCenter.default.notifications(named: .messageSender) where !Task.isCancelled {
                // 判断是否满足特定条件
                if let message = notification.object as? String, condition(message) {
                    self.message = message
                }
            }
        }

        func func condition(_ message: String) -> Bool { message.count > 10 }
    }

    extension Notification.Name {
        static let messageSender = Notification.Name("messageSender")
    }

在当前场景中，使用 task 替换 onReceive 可以获得两个好处：

- 减少视图不必要的刷新（ 避免重复计算 ）
- 在后台线程响应消息，减少主线程的负荷

> 请注意！task 并不能完全取代 onReceive。对于某些视图（ 在惰性容器中的视图、处在 TabView 中的视图等 ），它们可能会反复满足
> onAppear 和 onDisappear 的触发条件（ 滚动出屏幕外、在不同的 Tab 中切换 ）。如此一来，运行在 task 中的
> notificationHandler 并不会持续运行。但对于 onRecevie，即使视图触发了 onDisappear
> ，但只要视图的仍然存续，那么就会持续执行闭包中的操作（ 不会丢失必要的信息 ）。

## 为老版本的 SwiftUI 添加 task 修饰器

当前，Swift 已经将 async/await 特性向后移植至 iOS 13，但并没有在低版本的 SwiftUI 中提供 task 修饰器（ 原生的
task 修饰器最低要求 iOS 15 ）。

在了解了两个版本的 task 修饰器的工作原理和调用机制后，为老版本的 SwiftUI 添加 task 修饰器将不再有任何困难。

    #if canImport(_Concurrency)
    import _Concurrency
    import Foundation
    import SwiftUI

    public extension View {
        @available(iOS, introduced: 13.0, obsoleted: 15.0)
        func task(priority: TaskPriority = .userInitiated, @_inheritActorContext _ action: @escaping @Sendable () async -> Void) -> some View {
            modifier(_MyTaskModifier(priority: priority, action: action))
        }

        @available(iOS, introduced: 14.0, obsoleted: 15.0)
        func task<T>(id value: T, priority: TaskPriority = .userInitiated, @_inheritActorContext _ action: @escaping @Sendable () async -> Void) -> some View where T: Equatable {
            modifier(_MyTaskValueModifier(value: value, priority: priority, action: action))
        }
    }

    @available(iOS 13,*)
    struct _MyTaskModifier: ViewModifier {
        @State private var currentTask: Task<Void, Never>?
        let priority: TaskPriority
        let action: @Sendable () async -> Void

        @inlinable public init(priority: TaskPriority, action: @escaping @Sendable () async -> Void) {
            self.priority = priority
            self.action = action
        }

        public func body(content: Content) -> some View {
            content
                .onAppear {
                    currentTask = Task(priority: priority, operation: action)
                }
                .onDisappear {
                    currentTask?.cancel()
                }
        }
    }

    @available(iOS 13,*)
    struct _MyTaskValueModifier<Value>: ViewModifier where Value: Equatable {
        var action: @Sendable () async -> Void
        var priority: TaskPriority
        var value: Value
        @State private var currentTask: Task<Void, Never>?

        public init(value: Value, priority: TaskPriority, action: @escaping @Sendable () async -> Void) {
            self.action = action
            self.priority = priority
            self.value = value
        }

        public func body(content: Content) -> some View {
            content
                .onAppear {
                    currentTask = Task(priority: priority, operation: action)
                }
                .onDisappear {
                    currentTask?.cancel()
                }
                .onChange(of: value) { _ in
                    currentTask?.cancel()
                    currentTask = Task(priority: priority, operation: action)
                }
        }
    }
    #endif

> 你可以自行添加一个 onChange 的向后移植版本（ 支持 iOS 13 ），让第二个版本的 task 修饰器（ onAppear +
> onChange ）支持到 iOS 13

## 总结

task 修饰器将 async/await 和 SwiftUI 视图的生命周期连接起来，让开发者可以在视图中高效地构建复杂的异步任务。但过度地通过 task
修饰器在视图声明中对副作用进行控制，也会对视图的纯粹度、可测试度、复用性等造成影响。开发者应拿捏好使用的分寸。

# WWDC 2021 新 Formatter API：新老比较及如何自定义

在 WWDC 2021 的 [ What’s in Foundation
](https://developer.apple.com/videos/play/wwdc2021/10109/) 专题中，苹果隆重介绍了适用于
Swift 的新 Formatter API。网上已经有不少文章对新 API 的用法进行了说明。本文将通过介绍如何创建符合新 API 的
Formatter，让读者从另一个角度了解新 Formatter API 的设计机制；并对新旧两款 API 进行比较。

> 本文的演示代码可以在 [ Github
> ](https://github.com/fatbobman/CustomParseableFormatStyleDemo) 上下载

## 新旧交替或风格转换

### 新 Formatter API 可以做什么

新 Formatter 提供了一个便捷的接口，让 Swift 程序员以更熟悉方式在应用程序中呈现本地化的格式字符串。

### 新 API 比旧 API 好吗

好和坏都是相对的，对于以 Swift 开发为主或者只会 Swift 的程序员（比如我本人），新 Formatter
不仅学习和使用起来更容易，同时也更适合日益流行的声明式编程风格。不过从整体功能和效率上讲，新 Formatter 并不具备优势。

### 新旧 API 比较

#### 调用方便度

如果说新 API 相较旧 API 的最大优势，便是在调用上更符合直觉、更方便了。

旧 API：

          let number = 3.147
          let numberFormat = NumberFormatter()
          numberFormat.numberStyle = .decimal
          numberFormat.maximumFractionDigits = 2
          numberFormat.roundingMode = .halfUp
          let numString = numberFormat.string(from: NSNumber(3.147))!
          // 3.15

新 API：

          let number = 3.147
          let numString = number.formatted(.number.precision(.fractionLength(2)).rounded(rule: .up))
          // 3.15

旧 API：

          let numberlist = [3.345,534.3412,4546.4254]
          let numberFormat = NumberFormatter()
                  numberFormat.numberStyle = .decimal
                  numberFormat.maximumFractionDigits = 2
                  numberFormat.roundingMode = .halfUp
          let listFormat = ListFormatter()
          let listString = listFormat
                      .string(from:
                                  numberlist
                                  .compactMap{numberFormat.string(from:NSNumber(value: $0))}
                      ) ?? ""
          // 3.35, 534.35, and 4,546.43

新 API：

            let numString1 = numberlist.formatted(
                .list(
                    memberStyle: .number.precision(.fractionLength(2)).rounded(rule: .up),
                    type: .and
                )
            )
        // 3.35, 534.35, and 4,546.43

即使你对新 API 并不很了解，仅凭代码的自动提示你就可以快速组合出想要的格式化结果。

#### 运行效率

在 WWDC 视频中，苹果几次提及新 API 对性能的提升。不过苹果并没有告诉你全部的真相。

从我个人的测试数据来看，新 API 的效率相较于仅使用一次的 Formatter 实例来说，提升还是比较明显的（30% —— 300%），不过同可复用的
Formatter 实例比较，仍有数量级上的差距。

旧 API，每次都重新创建实例

        func testDateFormatterLong() throws {
            measure {
                for _ in 0..<count {
                    let date = Date()
                    let formatter = DateFormatter()
                    formatter.dateStyle = .full
                    formatter.timeStyle = .full
                    _ = formatter.string(from: date)
                }
            }
        }
    // 0.121

旧 API，只创建一次实例

        func testDateFormatterLongCreateOnce() throws {
            let formatter = DateFormatter()
            measure {
                for _ in 0..<count {
                    let date = Date()
                    formatter.dateStyle = .full
                    formatter.timeStyle = .full
                    _ = formatter.string(from: date)
                }
            }
        }
    // 0.005

新 API

        func testDateFormatStyleLong() throws {
            measure {
                for _ in 0..<count {
                    _ = Date().formatted(.dateTime.year().month(.wide).day().weekday(.wide).hour(.conversationalTwoDigits(amPM: .wide)).minute(.defaultDigits).second(.twoDigits).timeZone(.genericName(.long)))
                }
            }
        }
    // 0.085

使用新 API，配置的内容越多，执行所需时间也会相应增长。不过除非是对性能有非常高要求的场景，否则新 API 的执行效率还是有可以令人满意的。

> 本文的 Demo 中，附带了部分 Unit Test 代码，大家可以自行测试。

#### 统一性

旧 API 中，针对不同的格式化类型，我们需要创建不同的 Formatter 实例。比如使用 NumberFormatter
格式化数字、DateFormatter 格式化日期。

新 API 针对每个支持的类型都提供了统一的调用接口，尽量减少代码层面的复杂度

    Date.now.formatted()
    // 9/30/2021, 2:12 PM
    345.formatted(.number.precision(.integerLength(5)))
    // 00,345
    Date.now.addingTimeInterval(100000).formatted(.relative(presentation: .named))
    // tomorrow

#### 自定义难度

新 API 的调用便利性是建立在大量繁杂工作的基础之上的。相较于旧 API 通过属性直接设置，新 API
采用函数式编程方式，针对每个属性单独编写设置方法。虽然并不复杂，但工作量明显提高。

#### AttributedString

新 API 为每个可转换类型都提供 AttributedString 格式支持。通过 AttribtedString 中的
Field，可以方便的生成想要的显示样式。

比如：

        var dateString: AttributedString {
            var attributedString = Date.now.formatted(.dateTime
                .hour()
                .minute()
                .weekday()
                .attributed
            )
            let weekContainer = AttributeContainer()
                .dateField(.weekday)
            let colorContainer = AttributeContainer()
                .foregroundColor(.red)
            attributedString.replaceAttributes(weekContainer, with: colorContainer)
            return attributedString
        }

    Text(dateString)

![image-20210930142453213](https://cdn.fatbobman.com/image-20210930142453213-2983094.png)

#### 代码出错率

在新 API 中，一切都是类型安全的，开发者无需反复的查阅文档，你的代码可以享受编译时检查的好处。

比如下面的代码

旧 API

    let dateFormatter:DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        return formatter
    }()

    let dateString = dateFormatter.string(from: Date.now)

新 API

    let dateString = Date.now.formatted(.iso8601.year().month().day().dateSeparator(.dash).dateTimeSeparator(.space).time(includingFractionalSeconds: false) .timeSeparator(.colon))

如果单从代码量上来看，在本例中，新 API 不占据任何优势。不过你无需在 yyyy 和 YYYY 或者 MM 还是 mm 中犹豫，也不用反复查看 [
令人头痛的文档
](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_symbol_table)
，减少了在代码中犯错的可能性。

### 风格转换？

旧 API 是 Objectiv-C 的产物，它十分高效且好用，但在 Swift 中使用难免有不协调感。

新 API 是完全为 Swift 开发的，它采用了当前流行的声明式的风格。开发者只需要声明需要显示的字段，系统将以合适的格式进行呈现。

两种风格将在苹果的开发生态中长期共存，开发者可以选择适合自己的方式来实现同一个目标。

因此不存在风格转换的问题，苹果只是补交了 Swift 开发环境上缺失的一部分而已。

### 结论

新旧 API 将长期共存。

新 API 并非用来替换旧的 Formatter API，应该算是旧 Formatter 的 Swift 实现版本。新 API 基本涵盖了旧 API
绝大多数的功能，着重改善了开发者的使用体验。

类似的情况在最近几年中将不断上演，苹果在 Swift 语言层面基本完善的情况下，将逐步提供其核心框架的 Swift 版本。本届 WWDC 上推出的
AttributedString 也可以佐证这一点。

## 如何自定义新的 Formatter

### 新老 API 在自定义方面的不同

旧 API 是用类实现的，在创建自定义格式化器时，我们需要创建一个 Formatter 的子类，并至少实现以下两个方法：

    class MyFormatter:Formatter {
       // 将被格式化类型转换成格式类型（字符串）
        override func string(for obj: Any?) -> String?{
            guard let value = obj as? Double else {return nil}
            return String(value)
        }

       // 将格式化类型（字符串）转换回被格式化类型
        override func getObjectValue(_ obj: AutoreleasingUnsafeMutablePointer<AnyObject?>?, for string: String, errorDescription error: AutoreleasingUnsafeMutablePointer<NSString?>?) -> Bool{
            guard let value = Double(string) else {return false}
            obj?.pointee = value as AnyObject
            return true
        }
    }

需要的情况下，我们也可以提供 `NSAttributedString` 的格式化实现

        override func attributedString(for obj: Any, withDefaultAttributes attrs: [NSAttributedString.Key : Any]? = nil) -> NSAttributedString? {
            nil
        }

数据的格式转换都是在 **一个类** 定义中完成的。

新 API 充分体现了 Swift 作为面向协议语言的特点，使用两个协议（ `FormatStyle` 、 `ParseStrategy`
），分别定义了格式化数据和从格式化转换两个方向的实现。

### 新协议

#### FormatStyle

将被格式化类型转换成格式化类型。

    public protocol FormatStyle : Decodable, Encodable, Hashable {

        /// The type of data to format.
        associatedtype FormatInput

        /// The type of the formatted data.
        associatedtype FormatOutput

        /// Creates a `FormatOutput` instance from `value`.
        func format(_ value: Self.FormatInput) -> Self.FormatOutput

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        func locale(_ locale: Locale) -> Self
    }

尽管在导出类型上使用了泛型，不过由于新 API 着重于格式化（而不是类型转换），因此通常 FormatOutpu 为 `String` 或者 `AttributedString` 。

`func format(_ value: Self.FormatInput) -> Self.FormatOutput` 是必须实现的方法， `locale` 用来为 Formatter 设置区域信息，其返回值中的 `format` 方法的输出类型同原结构一致。因此，尽管 Formatter
会针对不同区域提供不同语言的返回结果，但为了兼容性，返回结果仍为 `String` 。

FormatStyle 协议同时约定了必须满足 Codable 和 Hashable。

#### ParseStrategy

将格式化后的数据转换成被格式化类型

    public protocol ParseStrategy : Decodable, Encodable, Hashable {

        /// The type of the representation describing the data.
        associatedtype ParseInput

        /// The type of the data type.
        associatedtype ParseOutput

        /// Creates an instance of the `ParseOutput` type from `value`.
        func parse(_ value: Self.ParseInput) throws -> Self.ParseOutput
    }

`parse` 的定义可比旧 API 的 `getObjectValue` 容易理解多了。

#### ParseableFromatStyle

由于 `FormatStyle` 和 `ParseStrategy` 是两个独立的协议，因此苹果又提供了 `ParseableFromatStyle` 协议，方便我们在一个结构体中实现两个协议的方法。

    public protocol ParseableFormatStyle : FormatStyle {

        associatedtype Strategy : ParseStrategy where Self.FormatInput == Self.Strategy.ParseOutput, Self.FormatOutput == Self.Strategy.ParseInput

        /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
        var parseStrategy: Self.Strategy { get }
    }

> 尽管理论上也可以通过 `FormatStyle&ParseStrategy` 在一个结构体中实现双向转换，不过官方框架只支持通过 `ParseableFromatStyle` 协议实现的 Formatter。

### 其他

尽管 `ParseableFromatStyle` 协议并没有要求一定要输出 AttributedString，不过在官方的新 Formatter
API 中还是为每个类型都提供了 AttributedString 的输出。

为了方便 Formatter 的调用，所有的官方 Formatter 都使用了 Swift 5.5 的新功能——在泛型上下文中扩展静态成员查找

例如

    extension FormatStyle where Self == IntegerFormatStyle<Int> {
        public static var number: IntegerFormatStyle<Int> { get }
    }

我们最好也为自定义的 Formatter 提供类似的定义

## 实战

### 目标

本节中，我们将用新的协议来实现针对 UIColor 的 Formatter，它将实现如下功能：

- 转换成 String

  UIColor.red.formatted()
  // #FFFFFF

- 转换成 AttributedString

  UIColor.red.formatted(.uiColor.attributed)

![image-20210930171252694](https://cdn.fatbobman.com/image-20210930171252694.png)

- 从 String 转换成 UIColor

  let color = try! UIColor("#FFFFFFCC")
  // UIExtendedSRGBColorSpace 1 1 1 0.8

- 支持链式配置（前缀、标记符号、是否显示透明度）

  Text(color, format: .uiColor.alpah().mark().prefix)

![image-20210930171608519](https://cdn.fatbobman.com/image-20210930171608519.png)

- localized

![image-20210930171654956](https://cdn.fatbobman.com/image-20210930171654956.png)

### 实现 ParseStrategy

将字符串转换成 UIColor。

    struct UIColorParseStrategy: ParseStrategy {
        func parse(_ value: String) throws -> UIColor {
            var hexColor = value
            if value.hasPrefix("#") {
                let start = value.index(value.startIndex, offsetBy: 1)
                hexColor = String(value[start...])
            }

            if hexColor.count == 6 {
                hexColor += "FF"
            }

            if hexColor.count == 8 {
                let scanner = Scanner(string: hexColor)
                var hexNumber: UInt64 = 0

                if scanner.scanHexInt64(&hexNumber) {
                    return UIColor(red: CGFloat((hexNumber & 0xff000000) >> 24) / 255,
                                   green: CGFloat((hexNumber & 0x00ff0000) >> 16) / 255,
                                   blue: CGFloat((hexNumber & 0x0000ff00) >> 8) / 255,
                                   alpha: CGFloat(hexNumber & 0x000000ff) / 255)
                }
            }

            throw Err.wrongColor
        }

        enum Err: Error {
            case wrongColor
        }
    }

在 Demo 中，我们并没有实现一个要求非常严格的 ParseStrategy。任何长度为 6 或 8 的十六进制字符串都将被转换成 UIColor。

### 实现 ParseableFromatStyle

    struct UIColorFormatStyle: ParseableFormatStyle {
        var parseStrategy: UIColorParseStrategy {
            UIColorParseStrategy()
        }

        private var alpha: Alpha = .none
        private var prefix: Prefix = .hashtag
        private var mark: Mark = .none
        private var locale: Locale = .current

        enum Prefix: Codable {
            case hashtag
            case none
        }

        enum Alpha: Codable {
            case show
            case none
        }

        enum Mark: Codable {
            case show
            case none
        }

        init(prefix: Prefix = .hashtag, alpha: Alpha = .none, mark: Mark = .none, locale: Locale = .current) {
            self.prefix = prefix
            self.alpha = alpha
            self.mark = mark
            self.locale = locale
        }

        func format(_ value: UIColor) -> String {
            let (prefix, red, green, blue, alpha, redMark, greenMark, blueMark, alphaMark) = Self.getField(value, prefix: prefix, alpha: alpha, mark: mark, locale: locale)
            return prefix + redMark + red + greenMark + green + blueMark + blue + alphaMark + alpha
        }
    }

    extension UIColorFormatStyle {
        static func getField(_ color: UIColor, prefix: Prefix, alpha: Alpha, mark: Mark, locale: Locale) -> (prefix: String, red: String, green: String, blue: String, alpha: String, redMask: String, greenMark: String, blueMark: String, alphaMark: String) {
            var r: CGFloat = 0
            var g: CGFloat = 0
            var b: CGFloat = 0
            var a: CGFloat = 0
            color.getRed(&r, green: &g, blue: &b, alpha: &a)
            let formatString = "%02X"
            let prefix = prefix == .hashtag ? "#" : ""
            let red = String(format: formatString, Int(r * 0xff))
            let green = String(format: formatString, Int(g * 0xff))
            let blue = String(format: formatString, Int(b * 0xff))
            let alphaString = alpha == .show ? String(format: formatString, Int(a * 0xff)) : ""

            var redMark = ""
            var greenMark = ""
            var blueMark = ""
            var alphaMark = ""

            if mark == .show {
                redMark = "Red: "
                greenMark = "Green: "
                blueMark = "Blue: "
                alphaMark = alpha == .show ? "Alpha: " : ""
            }

            return (prefix, red, green, blue, alphaString, redMark, greenMark, blueMark, alphaMark)
        }
    }

在 ParseableFromatStyle 中，除了实现 `format` 方法外，我们为不同的配置声明了属性。

> 将 `getField` 方法声明为结构方法，便于之后的 `Attributed` 调用

在完成了上述代码后，我们已经可以使用代码在 UIColor 和 String 之间进行转换：

    let colorString = UIColorFormatStyle().format(UIColor.blue)
    // #0000FF

    let colorString = UIColorFormatStyle(prefix: .none, alpha: .show, mark: .show).format(UIColor.blue)
    // Red:00 Green:00 Blue:FF Alpha:FF

    let color = try! UIColorFormatStyle().parseStrategy.parse("#FF3322")
    // UIExtendedSRGBColorSpace 1 0.2 0.133333 1

### 链式配置

    extension UIColorFormatStyle {
        func prefix(_ value: Prefix = .hashtag) -> Self {
            guard prefix != value else { return self }
            var result = self
            result.prefix = value
            return result
        }

        func alpah(_ value: Alpha = .show) -> Self {
            guard alpha != value else { return self }
            var result = self
            result.alpha = value
            return result
        }

        func mark(_ value: Mark = .show) -> Self {
            guard mark != value else { return self }
            var result = self
            result.mark = value
            return result
        }

        func locale(_ locale: Locale) -> UIColorFormatStyle {
            guard self.locale != locale else { return self }
            var result = self
            result.locale = locale
            return result
        }
    }

现在我们获得了链式配置的能力。

    let colorString = UIColorFormatStyle().alpah(.show).prefix(.none).format(UIColor.blue)
    // 0000FFFF

### localized 支持

由于 `format` 的输出类型为 String，因此，我们需要在 `getField` 中将 `Mark` 转换成对应区域的文字。在 `getField` 中做如下修改：

            if mark == .show {
                redMark = getLocalizedString(.red, locale: locale)
                greenMark = getLocalizedString(.green, locale: locale)
                blueMark = getLocalizedString(.blue, locale: locale)
                alphaMark = alpha == .show ? getLocalizedString(.alpha, locale: locale) : ""
            }

在 UIColorFormatStyle 添加如下代码：

    enum MarkTag:String{
            case red
            case green
            case blue
            case alpha
        }

        static let localeString:[String:String] = [
            "EN-red":" Red:",
            "EN-green":" Green:",
            "EN-blue" : " Blue:",
            "EN-alpha" : " Alpha:",
            "ZH-red" : " 红：",
            "ZH-green" : " 绿：",
            "ZH-blue" : " 蓝",
            "ZH-alpha" : " 透明度："
        ]

至此，当系统切换到拥有对应语言包的地区时，Mark 将显示对应的内容

    # Red:00 Green:00 Blue:FF Alpha:FF
    # 红：00 绿：00 蓝：FF 透明度：FF

> ~~截至本文完成时，`String(localized:String,locale:Locale)` 仍有 Bug，无法获取到对应的 Locale
> 文字。系统的 Formatter 也有这个问题。正常的情况下，我们可以使用如下代码，在非中文区域获得中文的 mark 显示 ~~
>
> 之前对 String 新的构造方法理解有误，经过官方的邮件解释， `String(localized:String, locale:Locale)`
> 中的 `locale` 是用来设置字符串差值中 formatter 的 locale。因此对原有代码进行了修改。

    let colorString = UIColorFormatStyle().mark().locale(Locale(identifier: "zh-cn")).format(UIColor.blue)

在 SwiftUI 中设置

    // Text 将自动调用 Formatter 的 locale 方法
    Text(color, format: .uiColor.mark())
        .environment(\.locale, Locale(identifier: "zh-cn"))

### AttributedString 支持

创建自定义 Field，便于使用者修改 AttributedString 不同区域的 Style

    enum UIColorAttirbute: CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {
        enum Value: String, Codable {
            case red
            case green
            case blue
            case alpha
            case prefix
            case mark
        }

        static var name: String = "colorPart"
    }

    extension AttributeScopes {
        public struct UIColorAttributes: AttributeScope {
            let colorPart: UIColorAttirbute
        }

        var myApp: UIColorAttributes.Type { UIColorAttributes.self }
    }

    extension AttributeDynamicLookup {
        subscript<T>(dynamicMember keyPath: KeyPath<AttributeScopes.UIColorAttributes, T>) -> T where T: AttributedStringKey { self[T.self] }
    }

> 过些日子我会写篇博文介绍 AttributedString 的用法，以及如何自定义 AttributedKey

由于将 UIColor 格式化成 AttributedString 是单向的（无需从 AttribuedString 转换回 UIColor），因此
Attributed 只需遵循 FormatStyle 协议

    extension UIColorFormatStyle {
        var attributed: Attributed {
            Attributed(prefix: prefix, alpha: alpha,mark: mark,locale: locale)
        }

        struct Attributed: Codable, Hashable, FormatStyle {
            private var alpha: Alpha = .none
            private var prefix: Prefix = .hashtag
            private var mark: Mark = .none
            private var locale: Locale = .current

            init(prefix: Prefix = .hashtag, alpha: Alpha = .none, mark: Mark = .none, locale: Locale = .current) {
                self.prefix = prefix
                self.alpha = alpha
                self.mark = mark
                self.locale = locale
            }

            func format(_ value: UIColor) -> AttributedString {
                let (prefix, red, green, blue, alpha, redMark, greenMark, blueMark, alphaMark) = UIColorFormatStyle.getField(value, prefix: prefix, alpha: alpha, mark: mark, locale: locale)
                let prefixString = AttributedString(localized: "^[\(prefix)](colorPart:'prefix')", including: \.myApp)
                let redString = AttributedString(localized: "^[\(red)](colorPart:'red')", including: \.myApp)
                let greenString = AttributedString(localized: "^[\(green)](colorPart:'green')", including: \.myApp)
                let blueString = AttributedString(localized: "^[\(blue)](colorPart:'blue')", including: \.myApp)
                let alphaString = AttributedString(localized: "^[\(alpha)](colorPart:'alpha')", including: \.myApp)

                let redMarkString = AttributedString(localized: "^[\(redMark)](colorPart:'mark')",  including: \.myApp)
                let greenMarkString = AttributedString(localized: "^[\(greenMark)](colorPart:'mark')" ,including: \.myApp)
                let blueMarkString = AttributedString(localized: "^[\(blueMark)](colorPart:'mark')" ,including: \.myApp)
                let alphaMarkString = AttributedString(localized: "^[\(alphaMark)](colorPart:'mark')" ,including: \.myApp)

                let result = prefixString + redMarkString + redString + greenMarkString + greenString + blueMarkString + blueString + alphaMarkString + alphaString
                return result
            }

            func prefix(_ value: Prefix = .hashtag) -> Self {
                guard prefix != value else { return self }
                var result = self
                result.prefix = value
                return result
            }

            func alpah(_ value: Alpha = .show) -> Self {
                guard alpha != value else { return self }
                var result = self
                result.alpha = value
                return result
            }

            func mark(_ value: Mark = .show) -> Self {
                guard mark != value else { return self }
                var result = self
                result.mark = value
                return result
            }

            func locale<T:FormatStyle>(_ locale: Locale) -> T {
                guard self.locale != locale else { return self as! T }
                var result = self
                result.locale = locale
                return result as! T
            }
        }
    }

### 统一性支持

为 UIColorFormatStyle 添加 FormatStyle 扩展，方便在 Xcode 中使用

    extension FormatStyle where Self == UIColorFormatStyle.Attributed {
        static var uiColor: UIColorFormatStyle.Attributed {
            UIColorFormatStyle().attributed
        }
    }

    extension FormatStyle where Self == UIColorFormatStyle {
        static var uiColor: UIColorFormatStyle {
            UIColorFormatStyle()
        }
    }

为 UIColor 添加便捷构造方法和 `formatted` 方法，保持同官方 Formatter 一致的使用体验。

    extension UIColor {
        func formatted<F>(_ format: F) -> F.FormatOutput where F: FormatStyle, F.FormatInput == UIColor, F.FormatOutput == String {
            format.format(self)
        }

        func formatted<F>(_ format: F) -> F.FormatOutput where F: FormatStyle, F.FormatInput == UIColor, F.FormatOutput == AttributedString {
            format.format(self)
        }

        func formatted() -> String {
            UIColorFormatStyle().format(self)
        }

        convenience init<T:ParseStrategy>(_ value: String, strategy: T = UIColorParseStrategy() as! T  ) throws where T.ParseOutput == UIColor {
            try self.init(cgColor: strategy.parse(value as! T.ParseInput).cgColor)
        }

        convenience init(_ value: String) throws  {
            try self.init(cgColor: UIColorParseStrategy().parse(value).cgColor)
        }
    }

### 完成品

![uicolorFormatter](https://cdn.fatbobman.com/uicolorFormatter.gif)

可以在 [ Github ](https://github.com/fatbobman/CustomParseableFormatStyleDemo)
上下载全部代码。

## 总结

鉴于官方已经提供了大量种类齐全、功能丰富的 Formatter，大多数的开发者可能都不会碰到需要自定义 Formatter 的场景。不过通过对自定义
Formatter 协议的了解，可以加强我们对原生 Formatter 的认识，在代码中更好地使用它们。

# SwiftUI 布局 —— 尺寸（ 上 ）

在 SwiftUI 中，尺寸这一布局中极为重要的概念，似乎变得有些神秘。无论是设置尺寸还是获取尺寸都不是那么地符合直觉。本文将从布局的角度入手，为你揭开盖在
SwiftUI 尺寸概念上面纱，了解并掌握 SwiftUI 中众多尺寸的含义与用法；并通过创建符合 Layout 协议的 frame 和 fixedSize
视图修饰器的复制品，让你对 SwiftUI 的布局机制有更加深入地理解。

## 尺寸 —— 一个刻意被淡化的概念

SwiftUI 是一个声明式框架，提供了强大的自动布局能力。开发者几乎可以在不涉及尺寸（ 或很少涉及 ）这一概念的情况下创建出漂亮、精美、准确的布局效果。

但由于 SwiftUI 的视图并没有提供尺寸这一属性，因此即使在 SwiftUI
诞生了数年后的今天，如何获取视图的尺寸仍然是网络上的热门问题。同时对于不少的开发者来说，使用 frame
修饰器为视图设置尺寸产生的结果也经常与他们的预期有所不同。

这并非意味着尺寸在 SwiftUI 中不重要，事实恰恰相反，正是由于在 SwiftUI
中尺寸是一个十分复杂的概念，苹果将绝大多数有关尺寸的配置和表述都隐藏到了引擎盖之下，刻意对其进行了包装与淡化。

淡化尺寸概念的初衷或许是出于以下两点：

- 引导开发者转型到声明式编程逻辑，转变使用精准尺寸的习惯
- 掩盖 SwiftUI 中复杂的尺寸概念，减少初学者的困扰

但无论如何淡化或掩盖，当涉及更加高级、复杂、精准的布局时，尺寸是一个始终无法绕开的环节。随着你对 SwiftUI 认识的提高，了解并掌握 SwiftUI
中的众多尺寸含义也势在必行。

## SwiftUI 布局过程速览

SwiftUI 的布局就是布局系统通过为视图树上的节点提供必要的信息，最终计算出每个视图（ 矩形 ）所需的尺寸以及摆放位置的行为。

    struct ContentView: View {
        var body: some View {
            ZStack {
                Text("Hello world")
            }
        }
    }
    // ContentView
    //     |
    //     |———————— ZStack
    //                 |
    //                 |—————————— Text

以上面的代码为例（ ContentView 为应用的根视图 ），我们简述一下 SwiftUI 的布局过程（ 当前设备为 iPhone 13 Pro ）：

1. SwiftUI 的布局系统为 ZStack 提供一个 **建议尺寸** （ 390 x 763 该尺寸为设备屏幕尺寸去掉安全区域的大小 ），并询问 ZStack 的 **需求尺寸**

2. ZStack 为 Text 提供 **建议尺寸** （ 390 x 763 ），并询问 Text 的 **需求尺寸**

3. Text 根据 ZStack 提供的 **建议尺寸** ，返回了自己的 **需求尺寸** （ 85.33 x 20.33 ，因为 ZStack 提供建议尺寸大于 Text 的实际需求，因此 Text 的需求尺寸为对文本不折行，不省略的完整显示尺寸）

4. ZStack 向 SwiftUI 的布局系统返回了自己的需求尺寸（ 85.33 x 20.33，因为 ZStack 中仅有 Text 一个子视图，因此 Text 的需求尺寸便是 ZStack 的需求尺寸 ）

5. SwiftUI 的布局系统将 ZStack 放置在了 152.33, 418.33 处，并为其提供了 **布局尺寸** （ 85.33 x 20.33 ）

6. ZStack 将 Text 放置在了 152.33, 418.33 处，并为其提供了 **布局尺寸** （ 85.33 x 20.33 ）

布局过程基本上分为两个阶段：

- 第一阶段 —— 讨价还价

在这个阶段，父视图为子视图提供建议尺寸，子视图为父视图返回需求尺寸（ 上方的 1-4 ）。在 Layout 协议中，对应的是 sizeThatFits
方法。经过该阶段的协商，SwiftUI 将确定视图所在屏幕上的位置和尺寸。

- 第二阶段 —— 安置子民

在该阶段，父视图将根据 SwiftUI 布局系统提供的屏幕区域（ 由第一阶段计算得出 ）为子视图设置布局的位置和尺寸（ 上方的 5-6 ）。在 Layout
协议中，对应的是 placeSubviews 方法。此时，视图树上的每个视图都将与屏幕上的具体位置联系起来。

讨价还价的次数与视图结构的复杂度成正比，整个的协商过程可能会反复出现多次甚至推倒重来的情况。

## 容器与视图

在阅读 SwiftUI 布局系列文章时，大家可能会对其中某些称谓产生困惑。一会儿父视图、一会儿布局容器，到底它们之间是什么关系，是不是同一个东西？

在 SwiftUI 中，只有符合 View 协议的 component 才能被 [ ViewBuilder
](/zh/posts/viewbuilder1/) 所处理。因此任何一种布局容器，最终都会被包装并以 View 的形式出现在代码中。

例如，下面是 VStack 的构造函数，content 被传递给了真正的布局容器 \_VStackLayout 进行布局：

    public struct VStack<Content>: SwiftUI.View where Content: View {
        internal var _tree: _VariadicView.Tree<_VStackLayout, Content>
        public init(alignment: SwiftUI.HorizontalAlignment = .center, spacing: CoreFoundation.CGFloat? = nil, @SwiftUI.ViewBuilder content: () -> Content) {
            _tree = .init(
                root: _VStackLayout(alignment: alignment, spacing: spacing), content: content()
            )
        }
        public typealias Body = Swift.Never
    }

除了我们熟悉的 VStack、ZStack、List 等布局视图外，在 SwiftUI 中，大量的布局容器是以视图修饰器的形式存在的。例如，下面是
frame 在 SwiftUI 中的定义：

    public extension SwiftUI.View {
        func frame(width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil, alignment: SwiftUI.Alignment = .center) -> some SwiftUI.View {
            return modifier(
                _FrameLayout(width: width, height: height, alignment: alignment))
        }
    }

    public struct _FrameLayout {
        let width: CoreFoundation.CGFloat?
        let height: CoreFoundation.CGFloat?
        init(width: CoreFoundation.CGFloat?, height: CoreFoundation.CGFloat?, alignment: SwiftUI.Alignment)
        public typealias Body = Swift.Never
    }

\_FrameLayout 被包装成 viewModifier ，作用于给定的视图。

    Text("Hi")
        .frame(width: 100,height: 100)

    // 可以被视为

    _FrameLayout(width: 100,height: 100,alignment: .center) {
        Text("Hi")
    }

此时 \_FrameLayout 即是 Text 的父视图，也是布局容器。

对于不包含子视图的视图来说（ 例如 Text 这类的元视图 ），它们同样会提供接口供父视图来调用以向其传递建议尺寸并获取其需求尺寸。虽然当前 SwiftUI
中绝大多数的视图并不遵循 Layout 协议，但从 SwiftUI 诞生之始，其布局系统便是按照 Layout 协议提供的流程进行布局操作的，Layout
协议仅是将内部的实现过程包装成开发者可以调用的接口，以方便我们进行自定义布局容器的开发。

因此，为了简化文字，我们在文章中会将父视图与具备布局能力的容器等同起来。

不过需要注意的是，在 SwiftUI 中，有一类视图是会在视图树上显示为父视图，但并不具备布局能力。其中的代表有 Group、ForEach
等。这类视图的主要作用有：

- 突破 ViewBuilder Block 的数量限制
- 方便为一组视图统一设置 view modifier
- 有利于代码管理
- 其他特殊应用，如 ForEach 可支持动态数量的子视图等

例如在本文最初的例子中，SwfitUI 会将 ContentView 视作类似 Group 的存在。这类视图本身并不会参与布局，SwiftUI
的布局系统会在布局时自动将它们忽略，让其子视图与具备布局能力的祖先视图直接联系起来。

## SwiftUI 中的尺寸

如上文中所示，在 SwiftUI 的布局过程中，在不同的阶段、出于不同的用途，尺寸这一概念是在不断地变化的。本节将结合 SwiftUI 4.0 中的
Layout 协议对布局过程涉及的尺寸做更详细的介绍。

> 即使你对 Layout 协议不了解或短时间无法使用 SwiftUI 4.0 ，并不会影响你对下文的阅读和理解。尽管 Layout
> 协议的主要用途是让开发者创建自定义布局容器，且在 SwiftUI 中仅有少数的视图符合该协议，但从 SwiftUI 1.0 开始，SwiftUI
> 视图的布局机制便基本与 Layout 协议所实现的流程一致。可以说 Layout 协议是一个用来观察和验证 SwiftUI 布局运作原理的优秀工具。

### 建议尺寸

SwiftUI 的布局是从外向内进行的。布局过程的第一个步骤便是由父视图为子视图提供建议尺寸（ Proposal
Size）。顾名思义，建议尺寸是父视图为子视图提供的建议，子视图在计算其需求尺寸时是否考虑建议尺寸完全取决于它自己的行为设定。

以子视图为符合 Layout 协议的自定义布局容器举例，父视图通过调用子视图的 `sizeThatFits` 方法提供建议尺寸。建议尺寸的类型为
ProposedViewSize，它的宽和高均为 `Optional<CGFloat>` 类型。而该自定义布局容器又会在它的 sizeThatFits
方法中通过调用其子视图代理（ Subviews，子视图在 Layout 协议中的表现方式 ）的 sizeThatFits
方法为子视图代理提供建议尺寸。建议尺寸在布局的两个阶段（讨价还价、安置子民）均会提供，但通常我们只需在第一个阶段使用它（ 可以在第一阶段用 catch
保存中间的计算数据，减少第二阶段的计算量 ）。

    // 代码来自 My_ZStackLayout

    // 容器的父视图（父容器）将通过调用容器的 sizeThatFits 获取容器的需求尺寸，本方法通常会被多次调用，并提供不同的建议尺寸
    func sizeThatFits(
        proposal: ProposedViewSize, // 容器的父视图（父容器）提供的建议尺寸
        subviews: Subviews, // 当前容器内的所有子视图的代理
        cache: inout CacheInfo // 缓存数据，本例中用于保存子视图的返回的需求尺寸，减少调用次数
    ) -> CGSize {
        cache = .init() // 清除缓存
        for subview in subviews {
            // 为子视图提供建议尺寸，获取子视图的需求尺寸 (ViewDimensions)
            let viewDimension = subview.dimensions(in: proposal)
            // 根据 MyZStack 的 alignment 的设置获取子视图的 alignmentGuide
            let alignmentGuide: CGPoint = .init(
                x: viewDimension[alignment.horizontal],
                y: viewDimension[alignment.vertical]
            )
            // 以子视图的 alignmentGuide 为 (0,0) , 在虚拟的画布中，为子视图创建 CGRect
            let bounds: CGRect = .init(
                origin: .init(x: -alignmentGuide.x, y: -alignmentGuide.y),
                size: .init(width: viewDimension.width, height: viewDimension.height)
            )
            // 保存子视图在虚拟画布中的数据
            cache.subviewInfo.append(.init(viewDimension: viewDimension, bounds: bounds))
        }

        // 根据所有子视图在虚拟画布中的数据，生成 MyZtack 的 CGRect
        cache.cropBounds = cache.subviewInfo.map(\.bounds).cropBounds()
        // 返回当前容器的理想尺寸，当前容器的父视图将使用该尺寸在它的内部进行摆放
        return cache.cropBounds.size
    }

根据建议尺寸内容的不同，我们可以将建议尺寸细分为四种建议模式，在 SwiftUI
中，父视图会根据它的需求选择合适的建议模式提供给子视图。由于可以在宽度和高度上分别选择不同的模式，因此建议模式特指在一个维度上所提供的建议内容。

- 最小化模式

该维度的建议尺寸为 0 。 `ProposedViewSize.zero` 表示两个维度都为最小化模式的建议尺寸。某些布局容器（比如
VStack、HStack ），会通过为其子视图代理提供最小化模式的建议尺寸以获取子视图在特定维度下的最小需求尺寸（ 例如对视图使用了 minWidth
设定 ）

- 最大化模式

该模式的建议尺寸为 CGFloat. infinity 。 `ProposedViewSize.infinity`
表示两个维度都为最大化模式的建议尺寸。当父视图想获得子视图在最大模式下的需求尺寸时，会为其提供该模式的建议尺寸

- 明确尺寸模式

非 0 或 infinity 的数值。比如在上文的例子中，ZStack 为 Text 提供了 390 x 763 的建议尺寸。

- 未指定模式

nil，不设置任何数值。 `ProposedViewSize.unspecified` 表示两个维度都为未指定模式的建议尺寸。

为子视图提供不同的建议模式的目的是获得在该模式下子视图的需求尺寸，具体使用哪种模式，完全取决于父视图的行为设定。例如：ZStack
会将其父视图提供给它的建议模式直接转发给 ZStack 的子视图，而 VStack、HStack
则会要求子视图返回全部模式下的需求尺寸，以判断子视图是否为动态视图（ 在特定维度可以动态调整尺寸 ）。

在 SwiftUI 中，通过设置或调整建议模式而进行二次布局的场景很多，比较常用的有：frame、fixedSize 等。比如，下面的代码中，frame
便是无视 VStack 提供建议尺寸，强行为 Text 提供了 50 x 50 的建议尺寸。

    VStack {
        Text("Hi")
           .frame(width: 50,height: 50)
    }

### 需求尺寸

在子视图收到了父视图的建议尺寸后，它将根据建议模式和自身行为特点返回需求尺寸。需求尺寸的类型为 CGSize 。在绝大多数情况下，自定义布局容器（ 符合
Layout 协议）在布局第一阶段最终返回的需求尺寸与第二阶段 SwiftUI 布局系统传递给它的屏幕区域（ CGRect ）的尺寸一致。

    // 代码来自 FixedSizeLayout
    // 根据建议尺寸返回需求尺寸
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        guard subviews.count == 1, let content = subviews.first else {
            fatalError("Can't use MyFixedSizeLayout directly")
        }
        let width = horizontal ? nil : proposal.width
        let height = vertical ? nil : proposal.height
        // 获取子视图的需求尺寸
        let size = content.sizeThatFits(.init(width: width, height: height))
        return size
    }

比如以下是 `Rectangle()` 在四种建议模式下返回的结果，以两个维度为同一种模式举例：

- 最小化模式

需求尺寸为 0 x 0

- 最大化模式

需求尺寸为 infinity \* infinity

- 明确尺寸模式

需求尺寸为建议尺寸

- 未指定模式

需求尺寸为 10 x 10（ 至于为什么是 10 x 10 ，下文中的理想尺寸将有更详细的说明 ）

`Text("Hello world")` 在四种建议模式下计算需求尺寸的行为与 Rectangle 则大相径庭：

- 最小化模式

当任意维度为最小化模式时，需求尺寸为 0 x 0

- 最大化模式

需求尺寸为 Text 的实际显示尺寸（ 文本不折行、不省略 ） 85.33 x 20.33（ 上文例子中尺寸 ）

- 明确尺寸模式

如果建议宽度大于单行显示的需要，则需求宽度返回单行实现显示尺寸的宽度 85.33
；如果建议宽度小于单行显示的需要则需求宽度返回建议尺寸的宽度；如果建议高度小于单行显示的高度，则需求高度返回单行的显示高度
20.33；如果建议高度高于单行显示的高度且宽度大于单行显示的宽度，则需求高度返回单行显示的高度 20.33 ……

- 未指定模式

当两个维度均为未指定模式时，需求尺寸为单行完整显示所需的宽和高 85.33 x 20.33

不同的视图，在相同的建议模式及尺寸下会返回不同的需求尺寸这一事实既是 SwiftUI
的特色也是十分容易很让人困扰的地方。不过不用太紧张，需求尺寸总体上来说还是有规律可循的：

- Shape

除了未指定模式，其他均与建议尺寸一致

- Text

需求尺寸的计算规则较为复杂，需求尺寸取决于建议尺寸和实际完整显示尺寸

- 布局容器（ ZStack 、HStack、VStack 等）

需求尺寸为容器内子视图按指定对齐指南对齐摆放后（ 已处理动态尺寸视图 ）的总尺寸，详情请参阅 [ SwiftUI 布局 —— 对齐
](/zh/posts/layout-alignment/)

- 其他控件例如 TextField、TextEditor、Picker 等

需求尺寸取决于建议尺寸和实际显示尺寸

在 SwiftUI 中， `frame(minWidth:,maxWidth:,minHeight:,maxHeight)`
便是对子视图的需求尺寸进行调整的典型应用。

### 布局尺寸

在布局的第二阶段，当 SwiftUI 的布局系统调用布局容器（ 符合 Layout 协议 ）的 placeSubviews
方法时，布局容器会将每个子视图放置在给定的屏幕区域（ 尺寸通常与该布局容器的需求尺寸一致 ）中，并为子视图设置布局尺寸。

> 在本文之前的版本中，该尺寸被称为渲染尺寸

    // 代码来自 FixedSizeLayout
    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        guard subviews.count == 1, let content = subviews.first else {
            fatalError("Can't use MyFixedSizeLayout directly")
        }

        // 设置布局位置及布局尺寸。
        content.place(at: .init(x: bounds.minX, y: bounds.minY), anchor: .topLeading, proposal: .init(width: bounds.width, height: bounds.height))
    }

父视图将根据自身的行为特点以及参考子视图的需求尺寸计算子视图的布局尺寸，例如：

- 在 ZStack 中，ZStack 为子视图设置的布局尺寸与子视图的需求尺寸一致
- 在 VStack 中，VStack 将根据其父视图提供的建议尺寸、子视图是否为可扩展视图、子视图的视图优先级等信息，为子视图计算布局尺寸。比如： 当固定高度的子视图的总高度已经超出了 VStack 获得的建议尺寸高度，那么 Spacer 就只能获得高度为 0 的布局尺寸

多数情况下，布局尺寸与子视图的最终显示尺寸（ 视图尺寸 ）一致，但并非绝对。

SwiftUI 没有提供可以在视图中直接处理布局尺寸的方式（ 除了 Layout 协议 ），通常我们会通过对建议尺寸以及需求尺寸的调整，来影响布局尺寸。

### 视图尺寸

视图渲染后在屏幕上呈现的尺寸，也是热门提问 —— 如何获取视图的尺寸中所指的尺寸。

在视图中可以通过 GeometryReader 获取特定视图的尺寸及位置。

    extension View {
        func printSizeInfo(_ label: String = "") -> some View {
            background(
                GeometryReader { proxy in
                    Color.clear
                        .task(id: proxy.size) {
                            print(label, proxy.size)
                        }
                }
            )
        }
    }

    VStack {
        Text("Hello world")
            .printSizeInfo() // 打印视图尺寸
    }

另外，我们可以通过 border 视图修饰器更加直观地比对不同层级的视图尺寸：

    VStack {
        Text("Hello world")
            .border(.red)
            .frame(width: 100, height: 100, alignment: .bottomLeading)
            .border(.blue)
            .padding()
    }
    .border(.green)

![image-20220711134423997](https://cdn.fatbobman.com/image-20220711134423997.png)

视图尺寸已经是布局完成之后的产物了，在没有 Layout
协议之前，开发者只能通过获取当前视图以及子视图的视图尺寸来实现自定义布局。不仅性能较差，而且一旦设计有误可能会导致视图的循环刷新，进而造成程序崩溃。通过
Layout 协议，开发者可以站在上帝的视角，利用建议尺寸、需求尺寸、布局尺寸等信息从容地进行布局。

### 理想尺寸

理想尺寸（ ideal size ）特指在建议尺寸为未指定模式下返回的需求尺寸。例如在上文中，SwiftUI 为所有的 Shape 设置的默认理想尺寸为
10 x 10 ，Text 默认的理想尺寸为单行完整显示全部内容所需的尺寸。

我们可以使用 `frame(idealWidth:CGFloat, idealHeight:CGFloat)` 为视图设置理想尺寸，并使用 `fixedSize` 为视图的特定维度提供未指定模式的建议尺寸，以使其在该维度上将理想尺寸作为其需求尺寸。

在撰写本文之前，我发了个 [ 推文 ](https://twitter.com/fatbobman/status/1544530914297798658)
，询问大家对 fixedSize 的了解：

![image-20220711140418269](https://cdn.fatbobman.com/image-20220711140418269.png)

![FW9GLjJVsAAmDXX](https://cdn.fatbobman.com/FW9GLjJVsAAmDXX.jpeg)

    Text("Hello world")
        .border(.red)
        .frame(idealWidth: 100, idealHeight: 100)
        .fixedSize()
        .border(.green)

![image-20220711140000421](https://cdn.fatbobman.com/image-20220711140000421.png)

在了解了理想尺寸之后，我想大家应该能够推断出推文中以及上面代码的布局结果了吧。

## 尺寸的应用

在上文中，我们已经提及了不少在视图中设置或获取尺寸的工具和手段，现做以下汇总：

- frame (width: 50, height: 50)

为子视图提供 50 x 50 的建议尺寸，并将 50 x 50 作为需求尺寸返回给父视图

- fixedSize ()

为子视图提供未指定模式的建议尺寸

- frame (minWidth: 100, maxWidth: 300)

将子视图的需求尺寸控制在指定的范围中，并将调整后的尺寸作为需求尺寸返回给父视图

- frame (idealWidth: 100, idealHeight: 100)

如果当前视图收到为未指定模式的建议尺寸，则返回 100 x 100 的需求尺寸

- GeometryReader

将建议尺寸作为需求尺寸直接返回（ 充满全部可用区域 ）

## 接下来

在上篇中，我们对 SwiftUI 中的各种尺寸概念做了介绍，在下篇中我们将通过创建 frame、fixedSize 的复制品进一步提升大家对 SwiftUI
不同尺寸概念的理解和掌握。

> 可在此处获取 [ 下篇的代码 ](https://github.com/fatbobman/BlogCodes/tree/main/My_Frame)
> ，提前对内容有所了解。

# Swift Predicate: 用法、构成及注意事项

NSPredicate 一直是 Apple
提供的一个强大工具，允许开发者通过定义复杂的逻辑条件以自然且高效的方式对数据集合进行筛选和评估。随着时间的推移，Swift 语言的不断成熟和发展，2023
年 Swift 社区着手使用纯 Swift 语言重构 Foundation 框架。在这一重大更新中，引入了基于 Swift 编码的新 Predicate
功能，标志着在数据处理和评估方面迈入了新的阶段。本文旨在探讨 Swift Predicate 的使用方法、构成以及在实际开发中应注意的关键事项。

## 什么是谓词

在现代软件开发中，对数据进行高效且精确的筛选和评估是至关重要的。谓词（Predicate）作为一种强大的工具，允许开发者通过定义返回布尔值（true 或
false）的逻辑条件，来实现这一目标。这不仅在筛选集合或查找集合中的特定元素时发挥着核心作用，而且也是数据处理和业务逻辑实现的基石。

尽管苹果的 `NSPredicate` 提供了这种能力，但它依赖于 Objective-C
语法、存在容易出现运行时错误的风险以及面临平台限制等挑战，这些限制了其在不同环境下的应用范围和灵活性。

    class MyObject: NSObject {
      @objc var name: String
      init(name: String) {
        self.name = name
      }
    }
    let object = MyObject(name: "fat")

    // create NSPredicate
    let predicate = NSPredicate(format: "name = %@", "fat")
    XCTAssertTrue(predicate.evaluate(with: object)) // true

    let objs = [object]
    // filter object by predicate
    let filteredObjs = (objs as NSArray).filtered(using: predicate) as! [MyObject]
    XCTAssertEqual(filteredObjs.count, 1)

### Swift Predicate 的引入与改进

为了克服这些限制并拓展谓词的应用范围，Swift 社区对 Foundation 框架进行了重构，引入了基于 Swift 语言的 Predicate
功能。这一新特性不仅摆脱了对 Objective-C 的依赖，还通过 Swift 的宏功能，简化了谓词的构建过程，如下所示：

    class MyObject {
      var name:String
      init(name: String) {
        self.name = name
      }
    }

    let object = MyObject(name: "fat")
    let predicate = #Predicate<MyObject>{ $0.name == "fat" }
    try XCTAssertTrue(predicate.evaluate(object)) // true

    let objs = [object]
    let filteredObjs = try objs.filter(predicate)
    XCTAssertEqual(filteredObjs.count, 1)

在此示例中，我们通过 `#Predicate`
宏构建了一个逻辑条件。这种构建方式非常类似于撰写闭包代码，使得开发者能够以自然的方式构建出更加复杂的逻辑，例如：包含多个条件的谓词：

    let predicate = #Predicate<MyObject>{ object in
      object.name == "fat" && object.name.count < 3
    }
    try XCTAssertTrue(predicate.evaluate(object)) // false

此外，现在的 `MyObject` 无需继承自 `NSObject` 或使用 `@objc` 标注其属性，以支持 KVC。当然，Swift
Predicate 同样适用于仍继承自 `NSObject` 的类型。

### NSPredicate 与 Swift Predicate 的比较

相较于 NSPredicate，Swift Predicate 提供了诸多改进：

- **开源性与平台兼容性** ：支持跨平台使用，如 Linux 和 Windows。
- **类型安全** ：利用 Swift 的类型检查减少运行时错误。
- **开发效率** ：受益于 Xcode 支持，提高了代码编写的速度和准确性。
- **语法自由度** ：提供更大的表达自由，不受 Objective-C 语法规则的限制。
- **泛用性** ：可应用于所有 Swift 类型，不再限于继承自 NSObject 的类。
- **现代 Swift 特性支持** ：支持 Sendable 和 Codable 等现代 Swift 特性，使其更适合当下的 Swift 编程范式。

通过这些改进，Swift Predicate 不仅优化了开发者的工作流程，而且为 Swift 生态系统的扩展和成长开辟了新路径。

## Swift Predicate 的主要构成

在深入探讨 Swift Predicate 的使用方法和注意事项之前，首先需要对其结构进行一番了解。具体来说，我们应该明白 Predicate
是由哪些元素构成的，以及 Predicate 宏是如何发挥作用的。

### PredicateExpression 协议

`PredicateExpression`
协议（或者说是遵循该协议的具体类型）定义了表达式的条件逻辑。例如，它能够代表一个“小于”条件，该条件包含具体的逻辑判断，用以决定某个输入值是否小于给定的值。这一协议是构建
Swift Predicate 架构中最为关键的部分。 `PredicateExpression` 协议的声明如下：

    public protocol PredicateExpression<Output> {
        associatedtype Output

        func evaluate(_ bindings: PredicateBindings) throws -> Output
    }

Foundation 提供了一系列 [ 预定义
](https://developer.apple.com/documentation/foundation/predicateexpressions)
的表达式类型，这些类型都遵循 `PredicateExpression` 协议，使得开发者能够直接利用 `PredicateExpressions`
下的类型或类型方法来构造谓词表达式。这为构建灵活而强大的条件评估逻辑铺平了道路。例如，若我们想构造一个代表数字 `4` 的表达式，相应的代码如下：

    let express = PredicateExpressions.Value(4)

`PredicateExpressions.Value` 的实现 [ 代码 ](https://github.com/apple/swift-
foundation/blob/b8ef4ce99ca7c5b8f39dbba7acb86721c916fb40/Sources/FoundationEssentials/Predicate/Expression.swift#L143)
如下所示：

    extension PredicateExpressions {
      public struct Value<Output> : PredicateExpression {
            public let value: Output

            public init(_ value: Output) {
                self.value = value
            }

            public func evaluate(_ bindings: PredicateBindings) -> Output {
                return self.value
            }
        }
    }

`Value` 结构体直接封装了一个值，并在调用其 `evaluate` 方法时，简单地返回该被封装的值。这让 `Value`
成为了一种在谓词表达式中代表常量值的有效方式。

> 需要特别指出的是， `PredicateExpression` 的 `evaluate` 方法可以返回任何类型的值，而不仅限于布尔类型。

进一步，若我们需要定义一个表达 `3 < 4` 条件的表达式，相应的代码示例如下：

    let express = PredicateExpressions.build_Comparison(
      lhs: PredicateExpressions.Value(3),
      rhs: PredicateExpressions.Value(4),
      op: .lessThan
    )

此代码片段将生成一个遵循 `PredicateExpression` 协议的类型实例：

    PredicateExpressions.Comparison<PredicateExpressions.Value<Int>, PredicateExpressions.Value<Int>>

调用此实例的 `evaluate` 方法时，将返回一个布尔值，即判断结果。

通过嵌套表达式的方式，开发者可以构建出极为复杂的逻辑判断。同时，所产生的类型表达式也相应地变得复杂。

### Predicate 结构体

Swift Predicate，即使通过宏定义，其核心依然是 `Predicate` 结构体。这个结构体负责将逻辑条件（由 `PredicateExpression` 实现）与具体的值相绑定。这种机制使得 `Predicate`
能够实例化具体的条件逻辑，并接受输入值以进行评估。

它的 [ 定义 ](https://github.com/apple/swift-
foundation/blob/b8ef4ce99ca7c5b8f39dbba7acb86721c916fb40/Sources/FoundationEssentials/Predicate/Predicate.swift#L14)
如下所示：

    public struct Predicate<each Input> : Sendable {
        public let expression : any StandardPredicateExpression<Bool>
        public let variable: (repeat PredicateExpressions.Variable<each Input>)

        public init(_ builder: (repeat PredicateExpressions.Variable<each Input>) -> any StandardPredicateExpression<Bool>) {
            self.variable = (repeat PredicateExpressions.Variable<each Input>())
            self.expression = builder(repeat each variable)
        }

        public func evaluate(_ input: repeat each Input) throws -> Bool {
            try expression.evaluate(
                .init(repeat (each variable, each input))
            )
        }
    }

主要特性包括：

- **布尔值返回限制** ： `Predicate` 专门处理返回布尔值的表达式。这意味着复杂的表达式树的最终结果必须是一个布尔值，以便于进行逻辑判断。
- **构造过程** ：在构造 `Predicate` 时，必须提供一个闭包，该闭包接收 `PredicateExpressions.Variable` 类型参数，并返回一个遵循 `StandardPredicateExpression<Bool>` 协议的表达式。
- **`StandardPredicateExpression` 协议 ** ：这是对 `PredicateExpression` 协议的扩展，要求表达式同时遵循 `Codable` 和 `Sendable` 。目前，官方只允许 Foundation 预置的表达式符合此协议。

  public protocol StandardPredicateExpression<Output> : PredicateExpression, Codable, Sendable {}

- **构造闭包和变量属性的高级特性** ：利用 Swift 的 [ Parameter Packs ](https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md) 特性， `Predicate` 支持创建能同时处理多个泛型参数的谓词，这是 `NSPredicate` 所不具备的功能。

比如，利用 `Predicate` 结构体和 `PredicateExpression` 协议，我们可以构造出一个用于比较两个整数 `n` 和
`m` （ `n < m` ）的谓词示例：

    // 定义闭包：比较两个整数值是否满足"小于"关系
    // 此闭包采用两个 PredicateExpressions.Variable<Int> 类型的参数，
    // 并构造一个表示"小于"比较逻辑的 PredicateExpression
    let express = { (value1: PredicateExpressions.Variable<Int>, value2: PredicateExpressions.Variable<Int>) in
        PredicateExpressions.build_Comparison(
            lhs: value1,
            rhs: value2,
            op: .lessThan
        )
    }

    // 使用 express 闭包构造 Predicate 实例，
    // 其中 express 定义了评估逻辑，即判断第一个参数是否小于第二个参数
    let predicate = Predicate {
        express($0, $1)
    }

    let n = 3
    let m = 4

    // 评估 predicate：检查 n 是否小于 m，预期返回 true
    try XCTAssertTrue(predicate.evaluate(n, m))

### Predicate 宏

与通过字符串构建的 `NSPredicate` 相比，虽然直接使用 `PredicateExpression` 和 `Predicate`
结构体构建谓词能够获得类型安全检查、代码自动完成等优势，但这种方式在效率上较低，编写和阅读的难度也相对较高，这无疑增加了开发者在创建谓词时的心智负担。

为了降低这种复杂性，Foundation 引入了 Predicate 宏（ `#Predicate` ），旨在以更简洁、高效的方式帮助开发者构建
Swift Predicate。

仍以构建判断 `n < m` 的谓词为例，通过使用宏可以大大地简化谓词的构建操作：

    let predicate = #Predicate<Int,Int>{ $0 < $1}
    let n = 3
    let m = 4
    try XCTAssertTrue(predicate.evaluate(n,m)) // true

在 Xcode 中，通过查看宏展开后生成的代码，我们可以清楚地看到宏如何简化了之前需要大量代码才能实现的逻辑。

![image-20240225182917655](https://cdn.fatbobman.com/image-20240225182917655-zipic.png)

Predicate 宏的 [ 实现代码 ](https://github.com/apple/swift-
foundation/blob/5b06c5d5ac15c6eb052ac1f91fc023d4299b5f66/Sources/FoundationMacros/PredicateMacro.swift)
大约有 1200 行，其只支持 Foundation
中预置的谓词表达式以及特定可用于谓词中的方法。在转换时，当遇到不支持的表达式类型、方法或找不到对应的表达式时会报错。

通过引入 Predicate 宏，Swift 提供了一种既简洁又强大的方式来构建复杂的谓词逻辑，它允许开发者以几乎原生 Swift
代码的形式直接构建出复杂的逻辑判断，显著提高了代码的可读性和可维护性。更重要的是，Predicate
宏的使用大幅减少了开发者构建复杂查询时的心智负担，使得开发工作流程更为流畅和高效。

## Swift Predicate 构建的技巧与注意事项

在了解了 Swift Predicate 的构成之后，我们可以更准确地掌握构建 Predicate 时的限制与技巧。

### 全局函数的限制

使用 Predicate 宏构建谓词时，需要注意宏的转换逻辑是将闭包代码转换为 Foundation 的预置 `PredicateExpress`
表达式。当前预置的 `PredicateExpress` 实现并不支持直接访问全局函数或类型方法或属性返回的数据。因此，在使用这类数据构建谓词时，应通过
`let` 关键字预先获取所需数据。例如：

    func now() -> Date {
      .now
    }
    let predicate = #Predicate<Date>{ $0 < now()  } // Global functions are not supported in this predicate

正确的方式是先获取函数或属性的值，再构建谓词：

    let now = now()
    let predicate = #Predicate<Date>{ $0 < now  }

同理，对于类型属性的直接访问也存在限制：

    let predicate = #Predicate<Date>{ $0 < Date.now  }
    // Key path cannot refer to static member 'now'

    let now = Date.now
    let predicate = #Predicate<Date>{ $0 < now  }

这是由于当前的谓词表达式仅支持实例属性的 KeyPath，并不支持类型属性。

### 实例方法的限制

与上一条相同，在谓词中直接调用实例方法（如 `.lowercased()` ）也不受支持。

    struct A {
      var name:String
    }

    let predicate = #Predicate<A>{ $0.name.lowercased() == "fat" } // The lowercased() function is not supported in this predicate

在这种情况下，应使用 Swift Predicate 支持的内置方法，例如：

    let predicate = #Predicate<A>{ $0.name.localizedLowercase == "fat" }

目前可用的内置方法集合是相对有限的，这包括但不限于： `contains` 、 `allSatisfy` 、 `flatMap` 、 `filter` 、 `subscript` 、 `starts` 、 `min` 、 `max` 、 `localizedStandardContains` 、 `localizedCompare` 、 `caseInsensitiveCompare` 等。开发者应定期查阅苹果的 [ 官方文档
](https://developer.apple.com/documentation/foundation/predicate) 或直接参考
Predicate 宏的源代码，以获取对最新支持的方法的全面了解。

由于目前内置的方法并不全面，一些在 NSPredicate 中常见的谓词构建方式在 Swift Predicate 中可能尚未得到支持。这意味着，尽管
Swift Predicate 为构建类型安全且表达力强的谓词提供了强大的工具，但开发者可能仍需在某些场景下寻找替代方案或等待未来的扩展以覆盖更广泛的用例。

### 支持创建多种泛型参数的谓词

得益于 Parameter Packs 功能，Swift Predicate
为开发者提供了更高的灵活性，允许定义能够接收多种泛型参数的谓词。这种能力极大地扩展了谓词的适用场景，使得开发者能够轻松应对各种复杂的条件判断需求。

正如前文中构建的 `n < m` 示例所展示的，这种方法不仅可以应用于单一类型的参数比较，还可以扩展到多个不同类型的参数，进一步增强了 Swift
Predicate 相比传统 Swift 高阶函数的表达能力和灵活性。这一特性让 Swift Predicate
成为构建复杂逻辑判断的强大工具，同时保持代码的清晰性和类型安全。

    struct A {
      var name:String
    }

    struct B {
      var age: Int
    }

    let predicate = #Predicate<A,B>{ a,b in
      !a.name.isEmpty && b.age > 10
    }

### 通过嵌套机制创建复杂的判断逻辑

Swift Predicate 的设计允许开发者通过嵌套谓词表达式构建出结构复杂的谓词逻辑。这种能力使得在实现那些在 `NSPredicate`
中通常需要依赖子查询来完成的条件判断变得更加直观和简洁。如今，这些复杂的逻辑表达可以更加符合 Swift 语言的编程习惯，提高了代码的可读性和可维护性。

    struct Address {
      var city:String
    }
    struct People {
      var address:[Address]
    }

    let predicate = #Predicate<People>{ people in
      people.address.contains { address in
        address.city == "Dalian"
      }
    }

> 当数据模型包含对多关系且为可选时，上述方法不起作用

### 支持构建包含可选值的谓词

Swift Predicate
支持了可选值类型的使用，这是在处理数据模型中常见的可选属性时的一大优势。这种支持允许开发者直接在谓词逻辑中处理可选值，从而使得谓词表达式的书写更加直接和清晰。

例如，以下示例展示了如何在 Swift Predicate 中处理一个可选字符串属性，根据其是否以特定前缀开始来进行过滤：

    let predicate = #Predicate<Note> {
      if let name = $0.name {
        return name.starts(with: "fat")
      } else {
        return false
      }
    }

对于希望深入了解如何在 Swift Predicate 中高效处理可选值的开发者，推荐阅读 [ 如何处理 SwiftData 谓词中的可选值
](/zh/posts/how-to-handle-optional-values-in-swiftdata-predicates/) 。

### Swift Predicate 是线程安全的

Swift Predicate 的设计考虑到了并发编程的需求，确保了其线程安全性。通过遵循 `Sendable` 协议，Swift Predicate
支持在不同的执行上下文之间安全地传递。这一特性显著增强了 Swift Predicate 的实用性，使其能够适应现代 Swift
应用程序中对并发和异步编程的广泛需求。

### Swift Predicate 支持序列化和反序列化

通过实现 `Codable` 协议，Swift Predicate 可以被转换成 JSON
或其他格式，从而实现数据的序列化与反序列化。这一特性对于需要将谓词条件保存至数据库或配置文件，或者需要在客户端与服务器之间共享谓词逻辑的应用场景尤为重要。

以下示例展示了如何将一个 `Predicate` 实例序列化为 JSON 数据，进而可以存储或传输：

    struct A {
      var name:String
    }

    let predicate = #Predicate<A>{ $0.name == "fatbobman" }
    var configuration = Predicate<A>.EncodingConfiguration.standardConfiguration
    configuration.allowKeyPath(\A.name, identifier: "name")
    let data = try JSONEncoder().encode(predicate, configuration: configuration)

### 在构建复杂谓词时，应注意其对编译时间的影响

类似于在 SwiftUI 中构建界面时遇到的情况，在构建复杂的 Swift Predicate 表达式时，Swift
编译器需要处理并转换成一个庞大且复杂的类型。这个过程中，一旦表达式的复杂度超过了某个阈值，编译器在进行类型推断的时间将显著增加。

当发现编译时长受到影响时，开发者可以考虑将复杂的谓词声明放置在独立的 Swift
文件中。这样做不仅有助于组织和管理代码，还可以在一定程度上减少因频繁修改其他部分代码而触发的重新编译。

### 尚不支持使用自定义谓词表达式构建谓词

目前，尽管开发者可以创建符合 `PredicateExpress` 协议的自定义表达式类型，但官方并不允许自定义表达式符合 `StandardPredicateExpression` 协议。因此，虽然可以创建自定义表达式类型，但在构建谓词时无法直接使用这些自定义表达式。

即使开发者将自定义表达式标注为遵循 `StandardPredicateExpression` 协议，但是 Predicate 宏目前仅支持使用
Foundation 中预置的 `StandardPredicateExpression` 实现。这一限制使得开发者无法在 Predicate
宏中使用自定义表达式，从而导致无法利用自定义表达式构建谓词。

### 尚不支持将多个谓词组合成更加复杂的谓词

在构建 `NSPredicate` 时，开发者可以通过 `NSCompoundPredicate` 将多个简单逻辑的 `NSPredicate`
灵活组合成更复杂的谓词。然而，Swift Predicate 目前尚未提供类似的能力，这在一定程度上限制了开发者构建复杂谓词的灵活性。

在之后的文章中，我将介绍如何在当前阶段通过 `PredicateExpress`
动态构建复杂的谓词，以满足特定的需求。这样的方法可能会在某些情况下提供一种替代方案，以应对当前不支持将多个谓词合并的局限性。

## 在 SwiftData 中应用 Swift Predicate

SwiftData 和 Core Data 中使用 Predicate 作为数据检索条件是许多开发者的常见场景。理解 SwiftData 对 Swift
Predicate 的处理方式对于最大化其效用至关重要。

### SwiftData 与 Swift Predicate 的交互机制

当在 SwiftData 中设置 `FetchDescriptor` 的 Predicate 时，SwiftData 并不直接采用 Swift
Predicate 的评估机制。相反，它通过解析 Predicate 的 `express` 属性所定义的表达式树，并将这些表达式转换成 SQL
语句，以便从 SQLite 数据库检索数据。这意味着，在 SwiftData 环境中，评估操作实际上是通过 SQL 指令从 SQLite
数据库获取数据的过程，是在数据库端进行的。

### SwiftData 对谓词参数的限制

SwiftData 要求每个 FetchDescriptor
必须对应一个具体的数据实体。因此，构建谓词时，相应的实体类型成为谓词的唯一参数，这一点对于有效利用 SwiftData 构建谓词至关重要。

### SwiftData 谓词构建的表达能力限制

虽然 Swift Predicate 提供了一个强大的框架用于数据筛选，但其在 SwiftData 环境中的表达能力相比于结合使用 NSPredicate
的 Core Data
有所限制。面对特定筛选需求时，开发者可能需要采用间接方法，例如执行多次筛选或在实体中预先添加适配当前谓词能力的特定属性。例如，由于内置的 `starts` 方法对大小写敏感，若需实现忽略大小写的匹配，推荐为筛选属性创建一个预处理版本（如全部转为小写），以支持更灵活的数据检索。

### 谓词出现运行时错误

即使 Swift Predicate 在编译时没有错误，使用 SwiftData 进行数据检索时也可能遇到无法成功转换为 SQL
语句的情况，从而导致出现运行时错误。考虑以下示例：

    let predicate = #Predicate<Note> { $0.id == noteID }
    // Runtime error：Couldn't find \Note.id on Note with fields

虽然 `Note` 类型遵循 PersistentModel 协议，并且其 `id` 属性的类型也为 PersistentIdentifier，但
SwiftData 在讲谓词转换为 SQL 指令时却无法识别 `id` 属性。在这种情况下，开发者应使用 `persistentModelID`
属性进行比较（ 在进行谓词转换时，除了底层数据模型对应的属性外， `persistentModelID` 是为数不多的特别支持的属性 ）：

    let predicate = #Predicate<Note> { $0.persistentModelID == noteID }

此外，尝试在 PersistentModel 的属性上应用内置方法集时也可能遇到问题：

    let predicate = #Predicate<Note> {
      $0.name.localizedLowercase.starts(with: "abc".localizedLowercase)
    }
    // Runtime error: Couldn't find \Note.name.localizedLowercase on Note with fields

当 SwiftData 转换这些表达式时，很多内置方法同样也不适用于 PersistentModel 的属性，SwiftData 会错误地将其视为一个 `KeyPath` 。因此，在当前阶段，开发者可能需要创建额外的属性（例如，属性的小写版本）来适应这种场景。

### 获取不到预期结果的情况

在某些情况下， Swift Predicate 能够顺利编译并在 SwiftData 环境下运行而不报错，却可能因为 SwiftData 转换了错误的
SQL 指令，导致无法检索到预期的结果。以下示例说明了这一点：

    let predicate = #Predicate<Item> {
      $0.note?.parent?.persistentModelID == rootNoteID
    }

此谓词在编译和运行时都不会出现问题，但最终无法正确检索数据。为了解决这个问题，我们需要用其他的方式构建相同逻辑的谓词，确保它能够正确处理可选值，详情请见 [
如何处理 SwiftData 谓词中的可选值 ](/zh/posts/how-to-handle-optional-values-in-swiftdata-
predicates/) 一文：

    let predicate = #Predicate<Item> {
      if let note = $0.note {
        return note.parent?.persistentModelID == rootNoteID
      } else {
        return false
      }
    }

> 正因如此，进行全面而及时的单元测试在构建 SwiftData
> 谓词时显得尤为重要。通过测试，开发者可以验证谓词的行为与预期是否一致，确保数据检索的准确性和应用的稳定性。

## 总结

Swift Predicate 为 Swift
开发者带来了一种强大且灵活的工具，使得数据筛选和逻辑判断变得更加直观和高效。通过本文的探讨，我希望开发者不仅能够充分掌握 Swift Predicate
的强大功能和使用方法，而且能够在面对挑战和限制时，找到创造性的解决方案。

# @FocusedBinding 浅谈

在苹果 WWDC 20
中视频中出现了下面的代码，介绍了一个新的属性包装器@FocusedBinding。由于仍处于测试阶段，当前的代码并不能被正确的执行。@FocusedBinding
的资料苹果披露的也很少，网上也没有相关的信息。出于个人兴趣，我对它进行了简单的研究。尽管@FocusedBinding 在目前 Xcode Version
12.0 beta 2 (12 A 6163 b) 的版本上运行还有很多问题，但我基本上对其有了一定的了解。

    struct BookCommands: Commands {
     @FocusedBinding(\.selectedBook) private var selectedBook: Book?
      var body: some Commands {
        CommandMenu("Book") {
            Section {
                Button("Update Progress...", action: updateProgress)
                    .keyboardShortcut("u")
                Button("Mark Completed", action: markCompleted)
                    .keyboardShortcut("C")
            }
            .disabled(selectedBook == nil)
        }
      }

       private func updateProgress() {
           selectedBook?.updateProgress()
       }
       private func markCompleted() {
           selectedBook?.markCompleted()
       }
    }

## 用途

**在任意视图（View）之间数据共享、修改、绑定操作。**

在 SwiftUI 1.0 中，我们可以使用 EnvironmentKey 向子视图传递数据，使用 PreferenceKey
向父视图传递数据。如果我们想在不在同一视图树上的两个平行视图间进行数据传递的话，通常需要使用 Single of truth 或者通过
NotificationCenter 来进行。

在 SwiftUI 2.0 中，苹果引入了@FocusedBinding 和@FocusedValue 来解决这个问题。通过定义
FocusedValueKey，我们可以在任意的视图之间，无需通过 Single of truth，便可以直接进行数据共享、修改、绑定。

在 [ SwiftUI2.0 —— Commands（macOS 菜单） ](/zh/posts/swiftui2-commands/)
这篇文章中，我们通过了 Single of truth 的方式，在 App 这个层级，使 Commnads 可以同其他视图进行数据共享。通过 WWDC
提供的例子，我们可以看出，苹果希望能够提供一种其他的解决方案，完成上述的功能。同样，这种方案也使我们拥有了可以在任意视图（无论是否在同一颗树上，是否有联系）之间进行数据交换。

## 使用方法

其基本的使用方式和 Environment 很类似，都需要首先定义指定的 Key

    struct FocusedMessageKey:FocusedValueKey{
        //同 EnvironmentKey 不同，FocusedValueKey 没有缺省值，且必须是一个可选值。为了下面的演示，在这里我们将数据类型设置为 Binding<String>, 可以设置为任意值类型数据
        typealias Value = Binding<String>
    }

    extension FocusedValues{

        var message:Binding<String>?{
            get{self[FocusedMessageKey.self]}
            set{self[FocusedMessageKey.self] = newValue}
        }
    }

由于可以使用在任意视图，所以数据无需注入。和 EnvironmentKey 不同（只在当前注入的视图树之下有效），数据在全域有效。

    struct ShowView:View{
        //调用方式同@Environment 几乎一致，使用@FocusedValue 或@FocusedBinding 需不同的引用方式
        @FocusedValue(\.message) var focusedMessage
        //@FocusedBinding(\.message) var focusedMessage1
        var body: some View{
            VStack{
            Text("focused:\(focusedMessage?.wrappedValue ?? "")")
            //Text("focused:\(focusedMessage1 ?? "")")
            }
        }
    }

在另一视图对该 FocusedValueKey 数据进行修改。

    struct InputView1:View{
        @State private var text = ""
        var body: some View{
            VStack{
            TextField("input1:",text:$text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                //使 message 和 text 同步
                .focusedValue(\.message, $text)
            }
        }
    }

可以在多个视图对同一 FocusedValueKey 进行修改

    struct InputView2:View{
        @State private var text = ""
        var body:some View{
            TextField("input2:",text:$text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .focusedValue(\.message, $text)
        }
    }

最后组装在一起

    struct RootView: View {
        var body: some View {
            VStack{
                //三个视图是平行关系，在之前使用 Environment 或者 Preference 都无法在这三个视图间进行数据传递、共享
                InputView1()
                InputView2()
                ShowView()
            }
            .padding(.all, 20)
            .frame(maxWidth:.infinity, maxHeight: .infinity)
        }
    }

您的浏览器不支持播放该视频！

目前在 iOS 下无法获取 FocusedValueKey 数值，文档中标识是支持 iOS 的，应该在未来会解决

## 如何用，怎么用？

FoccusedBinding 的引入，进一步完善了 SwiftUI 不同视图中数据操作的功能。不过个人建议还是不要滥用此功能。

由于我们可以在任意视图中修改 key 中的值，一旦滥用，很可能再度陷入代码难以管理的窘境。

对于一些功能很简单，无需使用 MVVM 逻辑的代码，或者 Single of truth 过于臃肿（ [ ObservableObject
研究——想说爱你不容易 ](/zh/posts/observableobject-study/) ），可能导致 app
响应问题的代码，可以考虑使用上述的方案。

# ViewBuilder 研究（下） —— 从模仿中学习

在 [ 上篇 ](/zh/posts/viewbuilder1/) 中，我们对 result builders 做了较详细的介绍。本篇我们将通过对
ViewBuilder 的仿制，探索更多有关 SwiftUI 视图背后的秘密。

## 视图能够提供的信息

> 本文中的视图是指符合 SwiftUI View 协议的各种类型

开发者通过 SwiftUI 框架提供的基础视图类型将自定义的视图串联起来，这些视图将向 SwiftUI 提供如下的信息：

- 界面设计

开发者通过声明的方式对用户界面进行轻量级描述。 SwiftUI 会在恰当的时机从开发者创建的视图 body 属性中读取这些描述并进行绘制。

- 依赖

我们常说，视图是状态的函数。对于单个视图来说，它的状态是由所有与之相关的依赖共同组成的。视图的依赖包括：视图的基本属性（无需符合
DynamicProperty 协议）、可驱动视图更新的属性 （ 符合 DynamicProperty 协议，例如 @State、@Environment
等）以及 onRecevie 等元素。

- 视图类型

SwiftUI 根据视图层次结构（视图树）中的视图类型和具体位置来区分视图（谁是谁）。对 SwiftUI 来说视图的类型本身就是最重要的信息之一。

- 其他

与当前视图有关的一些轻量级代码。

## SwiftUI 如何处理视图

SwiftUI 从加载视图、响应状态到屏幕绘制大概经历如下过程：

- 从根视图开始按视图层级结构沿特定分支（依据初始状态）逐个实例化视图，直到满足当前全部的显示所需
- 上述实例化后的视图值（结构值，非 body 值）将被保存在 SwiftUI 的托管数据池中
- 根据视图的依赖信息在 AttributeGraph 数据池中创建与当前显示的视图树对应的依赖图，并监控依赖的变化
- 依据 SwiftUI 数据池中视图值的 body 属性或视图类型的特定类型方法（非公开）进行布局和渲染
- 当用户或系统的某些行为导致依赖数据发生变化后，SwiftUI 将根据依赖图定位到需要重新评估的视图
- 以需重新评估的视图为根，按视图层级结构依当前状态逐个实例化视图类型（到满足全部显示所需为止）
- 将已不再需要参与布局和渲染的视图的值从 SwiftUI 数据池中移除，并在数据池中添加上新增的视图值
- 对于仍需显示但视图值发生变化的视图，使用新的视图值替换原有视图值
- 重组依赖图并绘制新增及发生变化的视图
- 周而复始、循环往复

## 仿制 ViewBuilder

ViewBuilder（视图构建器）将帮助开发者以一种简洁、清晰、易读的方式声明视图。对其实现原理尚不清楚朋友请先阅读 [ ViewBuilder
研究（上）—— 掌握 Result builders ](/zh/posts/viewbuilder1/) 。

> 本文中仿制的 View 协议、ViewBuilder 以及其他内容仅涉及 SwiftUI 框架内容的冰山一角。可在 [ 此处
> ](https://github.com/fatbobman/BlogCodes/tree/main/ViewBuilder/) 获得本文的全部代码。

### 创建 View 协议

既然视图指是符合 View 协议的各种类型，我们首先需要定义自己的 View 协议。

    import Foundation

    public protocol View {
        associatedtype Body: View
        var body: Self.Body { get }
    }

View 协议的公开接口非常简单，开发者自定义的视图类型只需提供一个符合 View 协议的 body 属性即可。SwiftUI
是怎样通过如此简单的接口完成上面缜密的视图处理过程呢？答案是：不能！

SwiftUI View 协议还有三个没有公开的接口，它们是：

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?

一个完整功能的视图类型应该提供上述要求的全部定义。目前无法自行实现这几个非公开的方法，仅能使用 SwiftUI 提供的默认实现。但 SwiftUI
框架提供的基本视图类型则充分利用了这些接口以实现各自的不同需求。

如果你查看 SwiftUI 的文档，它所提供的基本视图类型（例如：Text、EmptyView、Group 等等）的 body 类型大多都是 Never
，这与开发者的自定义视图类型截然不同。

这些使用了 Never 作为 body 属性类型的视图主要分为几类：

- 定义布局

例如：VStack、HStack、Spacer

- 沟通底层绘制元素

例如：Text、TextField、UIViewControllerRepresentable

- 类型占位与擦除

例如：EmptyView、AnyView

- 包装

例如：ModifiedContent、Group

- 逻辑描述：

例如：\_ConditionalContent

SwiftUI 在碰到这些视图类型时，并不会尝试获取它们的 body 属性内容（ Never 是不可触碰的），而是按照其各自特定的逻辑来进行处理。

因此，我们需要让 Never 符合 View 协议以继续下面的工作：

    extension Never: View {
        public typealias Body = Never
        public var body: Never { fatalError() }
    }

### 创建 EmptyView

有了 View 协议后，我们将创建第一个基础视图 EmptyView 。顾名思义，EmptyView 就是一个什么都不做的空视图：

    public struct EmptyView: View {
        public typealias Body = Never
        public var body: Never { fatalError() }
        public init() {}
    }

> 本文中，我们主要的目的是让 ViewBuilder 的逻辑跑起来，仅需让视图类型满足 View 协议的公开要求即可。

### 类型打印工具

为了在下文中更好的比对我们自定义的 ViewBuilder 同 SwiftUI 官方的 ViewBuilder
之间对视图类型的解析是否一致，我们还需要准备一个视图扩展方法（对原装和仿制的都有效）：

    public extension View {
        func debug() -> some View {
            let _ = print(Mirror(reflecting: self).subjectType)
            return self
        }
    }

在 SwiftUI 下使用 debug 打印视图的类型信息示例如下：

    struct ContentView:View {
        var body: some View {
            Group {
                Text("Hello")
                Text("World")
            }
            .debug()
        }
    }

    // Group<TupleView<(Text, Text)>>

打印的内容将向我们展示当前的视图层次结构，我们的自定义 ViewBuilder 应该能生成同 SwiftUI 的 ViewBuilder 几乎一样的信息。

### 创建 ViewBuilder

对于一个 result builders 来说，至少应该提供一个 [ buildBlock
](/zh/posts/viewbuilder1/#%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8%E8%BD%AC%E8%AF%91-block)
的实现。

    @resultBuilder
    public enum ViewBuilder {
        // 对于空闭包，将返回类型设定为 EmptyView
        public static func buildBlock() -> EmptyView {
            EmptyView()
        }
    }

恭喜你，至此我们已经完成了对 ViewBuilder 的最基础的创建工作。

使用它来解析第一个视图：

    @ViewBuilder
    func myFirstView() -> some View {}

通过 debug 查看视图的类型信息：

    print(type(of: myFirstView()))
    // EmptyView

现在我们可以在之前的 View 协议以及 debug 扩展中使用 ViewBuilder 了，将它们改为：

    public protocol View {
        associatedtype Body: View
        @ViewBuilder var body: Self.Body { get }  // 添加了 @ViewBuilder
    }

    public extension View {
        @ViewBuilder
        func debug() -> some View {
            let _ = print(Mirror(reflecting: self).subjectType)
            self
        }
    }

### 创建更多的 buildBlock

上文中仅提供了一个支持空闭包（ 0 个 component ）的 buildBlock 实现，下面的代码将允许我们在视图声明中添加一个 component
（视图）：

    // 对于单个 component ，buildBlock 将保留它的原始类型
    public static func buildBlock<Content>(_ content: Content) -> Content where Content: View {
        content
    }

现在就可以在闭包中添加一个 component 了：

    struct ContentView:View {
        var body: some View {
            EmptyView()
        }
    }

    ContentView().body.debug() // 因为我们的视图无法加载，需要使用这种方法来获得视图 body 的类型信息
    // EmptyView

此时如果现在我们在闭包中添加两个 EmptyView 会如何呢？

![image-20220406164006295](https://cdn.fatbobman.com/image-20220406164006295.png)

由于目前仅定义了支持 0 个和 1 个 component 的 buildBlock ，编译器会提示我们无法找到对应的 buildBlock 实现。

因为 View 协议中使用了关联类型，所以我们无法像上篇的 AttributedTextBuilder 那样使用数组来处理任意数量的 component
。SwiftUI 通过创建多个返回类型为 TupleView 的 buildBlock 重载来应对不同数量的 component 情况。

创建 TupleView 基础视图类型：

    public struct TupleView<T>: View {
        var content: T
        public var body: Never { fatalError() }
        public init(_ content: T) {
            self.content = content
        }
    }

创建更多的 buildBlock :

    // 针对 2 个到 10 个的 component，返回类型为 TupleView<>
    public extension ViewBuilder {
        static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> TupleView<(C0, C1)> where C0: View, C1: View {
            TupleView((c0, c1))
        }

        static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> TupleView<(C0, C1, C2)> where C0: View, C1: View, C2: View {
            .init((c0, c1, c2))
        }

        static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> TupleView<(C0, C1, C2, C3)> where C0: View, C1: View, C2: View, C3: View {
            .init((c0, c1, c2, c3))
        }

        // ...
    }

当前的 SwiftUI 只创建了至多支持 10 个 component 的 buildBlock 重载，因此我们在视图闭包中的同一个层次最多只能声明 10
个视图。如果你想让 SwiftUI 支持更多的 component 数量，只需创建更多的重载即可。

    // 现在我们可以在闭包中声明更多的视图了
    struct ContentView:View {
        var body: some View {
            EmptyView()
            EmptyView()
        }
    }

    ContentView().body.debug()
    // TupleView<(EmptyView, EmptyView)>

> 目前有一个针对 result builds 的 [ 提案 ](https://github.com/apple/swift-
> evolution/blob/main/proposals/0348-buildpartialblock.md) 正在审议中。添加了
> buildPartialBlock 方法。如该提案通过，只需实现 `buildPartialBlock(first: Component) ->
Component` 和 `buildPartialBlock(accumulated: Component, next: Component)
-> Component` 两个方法即可应对任意数量的 component 。

### 创建更多的基础视图

目前我们已经创建了两个基础视图类型： EmptyView 及 TupleView ，接下来将创建更多的基础视图类型为之后做准备。

- Group

  public struct Group<Content>: View {
  var content: Content
  public var body: Never { fatalError() }
  public init(@ViewBuilder \_ content: () -> Content) {
  self.content = content()
  }
  }

  struct ContentView: View {
  var body: some View {
  Group {
  EmptyView()
  EmptyView()
  }
  }
  }

  ContentView().body.debug()
  // Group<TupleView<(EmptyView, EmptyView)>>

- Text

  public struct Text: View {
  public typealias Body = Never
  public var body: Never { fatalError() }
  var content: String //SwiftUI 中，会通过一个枚举类型来区分 String 同 LocalizedStringKey ，仿制过程将一律简化
  public init(\_ content: String) {
  self.content = content
  }
  }

  struct ContentView: View {
  var body: some View {
  Group {
  EmptyView()
  Text("hello world")
  }
  }
  }

  // Group<TupleView<(EmptyView, Text)>>

### 在不同的分支中保存类型信息

在上篇的 [ 添加对多分支选择的支持
](/zh/posts/viewbuilder1/#%E6%B7%BB%E5%8A%A0%E5%AF%B9%E5%A4%9A%E5%88%86%E6%94%AF%E9%80%89%E6%8B%A9%E7%9A%84%E6%94%AF%E6%8C%81)
一节中， AttributedStringBuilder
在处理选择时，仅需考虑当前的分支而无需考虑另一条未被调用的分支。AttributedStringBuilder 的定义如下：

    // 对条件为真的分支调用 （左侧分支）
    public static func buildEither(first component: AttributedString) -> AttributedString {
        component
    }

    // 对条件为否的分支调用 （右侧分支）
    public static func buildEither(second component: AttributedString) -> AttributedString {
        component
    }

但 SwiftUI
需要通过视图的类型和位置对视图进行标识，因此在处理选择分支时，无论该分支是否被显示，在视图代码被编译后，所有分支的类型信息都需要明确下来。SwiftUI
利用 \_ConditionalContent 视图类型来达成此目的。

    public struct _ConditionalContent<TrueContent, FalseContent>: View {
        public var body: Never { fatalError() }
        let storage: Storage
        // 利用枚举锁定类型信息
        enum Storage {
            case trueContent(TrueContent)
            case falseContent(FalseContent)
        }

        init(storage: Storage) {
            self.storage = storage
        }
    }

    public static func buildEither<TrueContent, FalseContent>(first content: TrueContent) -> _ConditionalContent<TrueContent, FalseContent> where TrueContent: View, FalseContent: View {
        .init(storage: .trueContent(content))
    }

    public static func buildEither<TrueContent, FalseContent>(second content: FalseContent) -> _ConditionalContent<TrueContent, FalseContent> where TrueContent: View, FalseContent: View {
        .init(storage: .falseContent(content))
    }

> 参照 SwiftUI ViewBuilder 的实现，上面的代码是可以正常运行的。但对 buildEither 能同时推断 TrueContent 和
> FalseContent 两个的类型的能力我无法理解。是编译器为 result builders 开的后门吗？希望了解的朋友能给一点提示。

如此一来，不同分支的类型都将在编译后被固定下来。

    struct ContentView: View {
        var show: Bool
        var body: some View {
            if show {
                Text("hello")
            } else {
                Text("hello")
                Text("world")
            }
        }
    }

    ContentView(show:true).body.debug()
    // _ConditionalContent<Text, TupleView<(Text, Text)>>

    struct ContentView: View {
        var selection: Int
        var body: some View {
            switch selection {
                case 1:
                    Text("喜羊羊")
                case 2:
                    Text("灰太狼")
                default:
                    Text("懒羊羊")
            }
        }
    }

    ContentView(selection: 2).body.debug()
    // _ConditionalContent<_ConditionalContent<Text, Text>, Text>

这个实现对于 SwiftUI 至关重要，它是隐式标识的重要保证之一。

### 不一样的 buildOptional

在仿制 ViewBuilder 的过程中，唯有 [ buildOptional
](/zh/posts/viewbuilder1/#%E6%B7%BB%E5%8A%A0%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5%E6%94%AF%E6%8C%81%EF%BC%88-%E4%B8%8D%E5%B8%A6-else-%E7%9A%84-if-%EF%BC%89)
我无法实现的同 SwiftUI 完全一致。这是因为在 SwiftUI 诞生时，result builders 使用 buildIf 来处理不包含 `else` 的 `if` 语句。尽管当前仍支持 buildIf ，但已经无法像官方的 ViewBuilder 版本那样返回 Optional
类型的数据了。

    // SwiftUI 的 ViewBuilder 的 buildIf 定义
    public static func buildIf<Content>(_ content: Content?) -> Content? where Content : View

如果我们也定义成 `Content?` 编译器将无法通过。我们可以通过在 buildOptional 中使用 \_ConditionalContent
实现一样的目的（处理不包含 `else` 的 `if` 语句）：

    public static func buildOptional<Content>(_ content: Content?) -> _ConditionalContent<Content, EmptyView> where Content: View {
        guard let content = content else {
            return .init(storage: .falseContent(EmptyView()))
        }
        return .init(storage: .trueContent(content))
    }

尽管实现同原版的略有不同，但转译后的实现的显示效果完全一致。我们可以通过如下的方式在 SwiftUI 中验证上述代码：

- 在 SwiftUI 环境中添加如下代码

  public extension ViewBuilder {
  static func buildOptional<Content>(\_ content: Content?) -> \_ConditionalContent<Content, EmptyView> where Content: View {
  guard let content = content else {
  return buildEither(second: EmptyView())
  }
  return buildEither(first: content) // 因为 \_ConditionalContent 的构造器没有开放 public 权限，使用 buildEither 过渡一下
  }
  }

> buildOptional 的优先级高于 buildIf , SwiftUI 的 ViewBuilder 将使用我们提供的 buildOptional
> 来处理不包含 `else` 的 `if` 语句

- 在 SwiftUI 环境中创建如下视图

  struct ContentView: View {
  var show: Bool
  var body: some View {
  Group {
  if show {
  Text("Hello")
  }
  Text("World")
  }
  .debug()
  }
  }

  // Group<TupleView<(Optional<Text>, Text)>> 原装的 ViewBuilder 的解析类型（通过 buildIf ）
  // Group<TupleView<(\_ConditionalContent<Text, EmptyView>, Text)>> 仿制的 ViewBuilder 的解析类型（通过 buildOptional ）

虽然两者转译后的类型略有不同，但在显示效果上是完全一样的。

### 支持 API 可用性检查

result builders 通过 [ buildLimitedAvailablility
](/zh/posts/viewbuilder1/#%E6%8F%90%E9%AB%98%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E6%80%A7)
提供对 API 可用性检查的支持。它会和 buildOptional 或 buildEither 一并使用，在满足了 API
可用性检查的情况下会调用该实现。

请考虑下面 buildLimitedAvailability 的代码有什么不妥：

    public static func buildLimitedAvailability<Content>(_ content: Content) -> Content where Content: View {
        content
    }

    @available(macOS 14, iOS 16,*)
    struct MyText: View {
        var body: some View {
            Text("abc")
        }
    }

    struct TestView: View {
        var body: some View {
            if #available(macOS 14, iOS 16, *) {
                MyText()
            }
        }
    }

由于 MyText 仅应出现在 macOS 14 或 iOS 16 以上的版本，尽管我们已经提供了 buildLimitedAvailability
实现，但在编译该代码时，仍将会得到如下的错误提示：

![image-20220407092636776](https://cdn.fatbobman.com/image-20220407092636776.png)

这是因为，SwiftUI 会在编译之后将所有视图的类型固定下来（无论是否执行该分支），而在低版本的系统中并没有 MyText
的定义。为了解决这个问题，我们需要将 MyText 转换成在低版本系统下可识别的类型。因此 buildLimitedAvailability
的最终定义如下：

    public static func buildLimitedAvailability<Content>(_ content: Content) -> AnyView where Content: View {
        AnyView(content)
    }

### 创建 AnyView

在 Swift 的世界中难免会碰到需要使用类型擦除的场景，SwiftUI 也无法避免。例如，上文中 buildLimitedAvailability
通过返回 AnyView 实现在低版本系统中隐藏尚不支持的视图类型；亦或将不同类型的视图转换为 AnyView（ View
协议使用了关联类型）以保存至数组。

由于 SwiftUI 通过视图层次结构中的类型和位置来对视图进行标识，AnyView 将会擦除（隐藏）掉这些重要的信息，因此除非到了必须使用的地步，否则
**我们应尽量避免在 SwiftUI 中使用 AnyView。**

为了让 ViewBuilder 的仿制过程能够继续下去，我们也需要创建一个 AnyView 类型。

    // 有多种方法可以实现类型擦除，本例中的 AnyView 实现与 SwiftUI 的实现有较大区别
    protocol TypeErasing {
        var view: Any { get }
    }

    public struct AnyView: View {
        var eraser: TypeErasing
        public var body: Never { fatalError() }
        public init<V>(_ content: V) where V: View {
            self.eraser = ViewEraser(content)
        }

        var wrappedView: Any {
            eraser.view
        }

        class ViewEraser<V: View>: TypeErasing {
            let originalView: V
            var view: Any {
                originalView
            }

            init(_ view: V) {
                self.originalView = view
            }
        }
    }

现在，下面的代码就可以正常编译了：

    struct TestView: View {
        var body: some View {
            if #available(macOS 14, iOS 16, *) {
                MyText()
            }
        }
    }

    // _ConditionalContent<AnyView, EmptyView>

> 苹果在 WWDC 2021 的 [ Demystify SwiftUI
> ](https://developer.apple.com/videos/play/wwdc2021/10022/) 专题中特别指出了应减少
> AnyView 的使用。AnyView 除了会隐藏重要的类型和位置信息外，转换过程也会导致一定的性能损失。不过，SwiftUI 的 AnyView
> 实现得十分精妙，通过将大量的原始信息（依赖、分解后的视图值等）保存在其中，将性能损失降至相当低的程度。

至此，我们已经基本完成了对 SwiftUI 的 ViewBuilder 的仿制，创建了一个可以表述视图层次结构的构建器。

### 其他的 result builders 方法

SwiftUI 的 ViewBuilder 并没有支持 buildExpression、buildArray 以及 buildFinalResult
等方法。如果你自己有需要，可以对其进行扩展，例如可以参照上篇中的范例，通过 buildExpression 将字符串直接转换成 Text 。

## 没有 Modifier 的视图是不完整的

SwiftUI 通过视图修饰符（ ViewModifier ）为视图的声明提供了巨大的灵活性。在本文的最后一部分，我们将对 Modifier 做一点探讨。

### 创建通用的 ViewModifier

SwiftUI 为我们提供了大量的 modifier，比如下面的代码：

    struct TestView: View {
        var body: some View {
            VStack {
                Text("Hello world")
                    .background(Color.blue)
            }
            .frame(width: 100, height: 200, alignment: .leading)
        }
    }

    // ModifiedContent<VStack<ModifiedContent<Text, _BackgroundModifier<Color>>>, _FrameLayout>

background（ `_BackgroundModifier` ）和 frame （ `_FrameLayout` ）都是内置的
Modifier。

ViewBuilder 是视图构建器，根据 buildBlock 的定义，它的每个 component 都必须符合 View 协议。开发者通过
Modifier 在视图中表述自己的想法，SwiftUI 只会在布局和渲染时才会真正调用这些 modifier 的实现。考虑到 View 协议所能提供的
API 有限，无法应对 modifier 的各种需求，SwiftUI 通过 ViewModifier 协议（ \_ViewModifier_Content
）为 modifier 提供了更多的表述空间。

首先，我们先仿制一个 ViewModifier 协议：

    public protocol ViewModifier {
        associatedtype Body: View
        typealias Content = _ViewModifier_Content<Self>
        @ViewBuilder func body(content: Content) -> Self.Body
    }

    // _ViewModifier_Content 提供了额外的 API ，在此就不进行复现了。
    public struct _ViewModifier_Content<Modifier>: View where Modifier: ViewModifier {
        public typealias Body = Never
        public var body: Never { fatalError() }
    }

创建 ModifiedContent 视图类型：

    public struct ModifiedContent<Content, Modifier>: View where Content: View, Modifier: ViewModifier {
        public typealias Body = Never
        public var content: Content
        public var modifier: Modifier
        public init(content: Content, modifier: Modifier) {
            self.content = content
            self.modifier = modifier
        }

        public var body: ModifiedContent<Content, Modifier>.Body {
            fatalError()
        }
    }

仿造一个 overlay 方法：

    public struct _OverlayModifier<Overlay>: ViewModifier where Overlay: View {
        public var overlay: Overlay
        public init(overlay: Overlay) {
            self.overlay = overlay
        }

        public func body(content: Content) -> Never {
            fatalError()
        }
    }

    public extension View {
        func modifier<T>(_ modifier: T) -> ModifiedContent<Self, T> {
            .init(content: self, modifier: modifier)
        }

        func overlay<Overlay>(_ overlay: Overlay) -> some View where Overlay: View {
            modifier(_OverlayModifier(overlay: overlay))
        }

        func overlay<Overlay>(@ViewBuilder _ overlay: () -> Overlay) -> some View where Overlay: View {
            modifier(_OverlayModifier(overlay: overlay()))
        }
    }

    struct TestView: View {
        var body: some View {
            Group {
                Text("Hello")
            }
            .overlay(Text("world"))
        }
    }
    // ModifiedContent<Group<Text>, _OverlayModifier<Text>>

ModifiedContent 通过泛型 `<Content, Modifier>` 在视图层次结构中对自身进行标识。

### 为特定视图类型创建 Modifier

除了符合 ViewModifier 协议的通用 modifier 外，SwiftUI 中还有很多仅适用于特定视图类型的 modifier，比如 Text
、TextField、ForEach 等等都有其专有的修饰符。它们的实现要比通用 modifier 简单的多，但同 [ 在 SwiftUI 中使用
UIKit 视图 ](/zh/posts/uikitinswiftui/#swiftui-%E9%A3%8E%E6%A0%BC%E5%8C%96)
一文中介绍的方式略有不同。

以 Text 的 foregroundColor 举例：

    public struct Text: View {
        public typealias Body = Never
        public var body: Never { fatalError() }
        var content: String
        var modifiers: [Modifier] = []  // 记录所使用的 Modifier
        public init(_ content: String) {
            self.content = content
        }
    }

    public extension Text {
        // SwiftUI 通过枚举列出了仅适用于 Text 视图类型的 modifier
        enum Modifier {
            case color(Color?)
            /*
            case font(Font?)
            case italic
            case weight(Font.Weight?)
            case kerning(CGFloat)
            case tracking(CGFloat)
            case baseline(CGFloat)
            case rounded
            case anyTextModifier(AnyTextModifier)
            */
        }
    }

扩展 Text ：

    func foregroundColor(_ color: Color?) -> Text {
        guard !modifiers.contains(where: {
            if case .color = $0 { return true } else { return false }
        }) else { return self }
        var text = self
        text.modifiers.append(.color(color))
        return text
    }

此种处理 modifier 的方式有如下优点：

- 转译时仅传递信息，只在布局或渲染时才会真正处理 modifier
- 方便兼容不同的框架（ UIKit 、AppKit ）
- modifier 的优先级逻辑同 SwiftUI 的通用 modifier 一致 —— 内层优先

## 总结

result builders 已经推出一段时间了，但一直没有对其进行深入地研究。最初只想通过仿制 ViewBuilder 加深对 result
builders 的理解，但没想到此次的仿制过程，让我厘清了不少与 SwiftUI 视图有关的困惑，可谓意外之喜。

# SwiftUI 2.0 —— App、Scene、新的代码结构（二）

在 [ 上篇文章 ](/zh/posts/swiftui2-new-feature-1/) 中我们简单了解了 App、Scene，以及几个内置 Scene
的应用。在本文中，我们着重探讨在 SwiftUI 2.0 新的代码结构下如果更高效的组织 Data Flow。

## 新特性

### @AppStorage

AppStorage 是苹果官方提供的用于操作 UserDefault 的属性包装器。这个功能在 Swift 提供了 propertyWrapper
特性后，已经有众多的开发者编写了类似的代码。功能上没有任何特别之处，不过名称对应了新的 App 协议，让人更容易了解其可适用的周期。

- 数据可持久化，app 退出后数据仍保留
- 仅包装了 UserDefault，数据可以 UserDefault 正常读取
- 可保存的数据类型同 UserDefault，不适合保存复杂类型数据
- 在 app 的任意 View 层级都可适用，不过在 app 层使用并不起作用（不报错）

  @main
  struct AppStorageTest: App {
  //不报错，不过不起作用
  //@AppStorage("count") var count = 0
  var body: some Scene {
  WindowGroup {
  RootView()
  CountView()
  }
  }
  }

  struct RootView: View {
  @AppStorage("count") var count = 0
  var body: some View {
  List{
  Button("+1"){
  count += 1
  }
  }
  }
  }

  struct CountView:View{
  @AppStorage("count") var count = 0
  var body: some View{
  Text("Count:\(count)")
  }
  }

### @SceneStorage

使用方法同@AppStorage 十分类似，不过其作用域仅限于当前 Scene。

- 数据作用域仅限于 Scene 中
- 生命周期同 Scene 一致，当前在 iPadOS 下，如果强制退出一个两分屏显示的 App, 系统在下次打开 App 时有时会保留上次的 Scene 信息。不过，如果如果单独退出一个 Scene，数据则失效
- 支持的类型基本等同于@AppStorage，适合保存轻量数据
- 比较适合保存基于 Scene 的特质信息，比如 TabView 的选择，独立布局等数据

  @main
  struct NewAllApp: App {
  var body: some Scene {
  WindowGroup{
  ContentView1()
  }
  }
  }

  struct ContentView:View{
  @SceneStorage("tabSeleted") var selection = 2
  var body:some View{
  TabView(selection:$selection){
  Text("1").tabItem { Text("1") }.tag(1)
  Text("2").tabItem { Text("2") }.tag(2)
  Text("3").tabItem { Text("3") }.tag(3)
  }
  }
  }

![abc](https://cdn.fatbobman.com/swiftui2-new-feature-2-sceneStorage.png)

> _**上述代码在 PadOS 下运行正常，不过在 macOS 下程序会报错。估计应该是 bug** _

## Data Flow

### 手段

苹果在 SwiftUI 2.0 中添加了 @AppStorage @SceneStorage @StateObject
等新的属性包装器，我根据自己的理解对目前 SwiftUI 提供的部分属性包装器做了如下总结：

![propertyWrapperSheet](https://cdn.fatbobman.com/swiftui2-new-
feature-2-propertyWrapperSheet.png)

经过此次升级后，SwiftUI 已经大大的完善了各个层级数据的生命周期管理，对不同的类型、不同的场合、不同的用途都提供了解决方案，为编写符合 SwiftUI
的 Data Flow 提供了便利，我们可以根据自己的需要选择适合的 Source of truth 手段。

想了解其中的更多细节，可以参看我的其他文章：

[ @State 研究 ](/zh/posts/swiftui-state/)

[ @StateObject 研究 ](/zh/posts/stateobject/)

[ ObservableObject 研究 —— 想说爱你不容易 ](/zh/posts/observableobject-study/)

### 变化

在 SwiftUI 1.0 中，我们通常会在 AppDelegate 中创建需要生命周期与 app 一致的数据（比如 CoreData 的
Container ），在 SceneDelegate 中创建 Store 之类的数据源，并通过。environmentObject 注入。不过随着
SwiftUI 2.0 在程序入口方面的变化，以及采取的全新 Delegate 响应方式，我们可以通过更简洁、清晰的代码完成上述工作。

    @main
    struct NewAllApp: App {
        @StateObject var store = Store()
        var body: some Scene {
            WindowGroup{
                ContentView()
                    .environmentObject(store)
            }
        }
    }

    class Store:ObservableObject{
        @Published var count = 0
    }

上述例子中，将

    @StateObject var store = Store()

换成

    let store = Store()

目前来说是一样的。

_虽然目前 SceneBuilder、CommandBuilder 对 Dynamic update
和逻辑判断尚不支持，我相信应该在不久的将来，或许我们就可以使用类似下面的代码来完成很多有趣的工作了，**当前代码无法执行** _

    @main
    struct NewAllApp: App {
        @StateObject var store = Store()
        @SceneBuilder var body: some Scene {
            //@SceneBuilder 目前不支持判断，不过将来应该会加上
            if store.scene == 0 {
            WindowGroup{
                ContentView1()
                    .environmentObject(store)
            }
            .onChange(of: store.number){ value in
                print(value)
            }
            .commands{
                CommandMenu("DynamicButton"){
                    //目前无法动态切换内容，怀疑是 bug，已反馈
                    switch store.number{
                    case 0:
                        Button("0"){}
                    case 1:
                        Button("1"){}
                    default:
                        Button("other"){}
                    }
                }
            }
            else {
             DocumentGroup(newDocment:TextFile()){ file in
                  TextEditorView(document:file.$document)
             }
            }

            Settings{
                VStack{
                   //可正常变换
                    Text("\(store.number)")
                        .padding(.all, 50)
                }
            }

        }
    }

    struct ContentView1:View{
        @EnvironmentObject var store:Store
        var body:some View{
            VStack{
            Picker("select",selection:$store.number){
                Text("0").tag(0)
                Text("1").tag(1)
                Text("2").tag(2)
            }
            .pickerStyle(SegmentedPickerStyle())
            .padding()
            }
        }
    }

    class Store:ObservableObject{
        @Published var number = 0
        @Published var scene = 0
    }

### 跨平台代码

在 [ 上篇文章 ](/zh/posts/swiftui2-new-feature-1/) 我们介绍了新的
@UIApplicationDelegateAdaptor 的使用方法，我们也可以直接创建一个支持 Delegate 的 store。

    import SwiftUI

    class Store:NSObject,ObservableObject{
        @Published var count = 0
    }

    #if os(iOS)
    extension Store:UIApplicationDelegate{
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
            print("launch")
            return true
        }
    }
    #endif

    @main
    struct AllInOneApp: App {
        #if os(iOS)
        @UIApplicationDelegateAdaptor(Store.self) var store
        #else
        @StateObject var store = Store()
        #endif

        @Environment(\.scenePhase) var phase

        @SceneBuilder var body: some Scene {
                WindowGroup {
                    RootView()
                        .environmentObject(store)
                }
                .onChange(of: phase){phase in
                    switch phase{
                    case .active:
                        print("active")
                    case .inactive:
                        print("inactive")
                    case .background:
                        print("background")
                    @unknown default:
                        print("for future")
                    }

                }

            #if os(macOS)
            Settings{
                Text("偏好设置").padding(.all, 50)
            }
            #endif
        }
    }

## 总结

在 [ ObservableObject 研究 —— 想说爱你不容易 ](/zh/posts/observableobject-study/)
中，我们探讨过 SwiftUI 更倾向于我们不要创建一个沉重的 Singel source of truth,
而是将每个功能模块作为独立的状态机（一起组合成一个大的状态 app），使用能够对生命周期和作用域更精确可控的手段创建区域性的 source of
truth。

从 SwiftUI 第一个版本升级的内容来看，目前 SwiftUI 仍是这样的思路。

# HowTo —— Swift2.0 在视图中显示地图

Swift 2.0 中，苹果添加了 Map，让开发者可以非常容易的在 View 中添加需要的地图元素。

    import SwiftUI
    import MapKit

    struct MapView: View{
        //设置初始显示区域
        @State private var region:MKCoordinateRegion = MKCoordinateRegion(
            center: CLLocationCoordinate2D(latitude: 38.92083, longitude: 121.63917),
            span: MKCoordinateSpan(latitudeDelta: 0.5, longitudeDelta: 0.5)
        )

        //设置是否持续跟踪用户当前位置
        @State private var trackmode = MapUserTrackingMode.follow

        //设置标记点信息
        let dots:[MapDot] = [
            MapDot(title:"point1",
                   coordinate:CLLocationCoordinate2D(latitude: 38.92083, longitude: 121.63917),
                   color:.red),
            MapDot(title:"point2",
                   coordinate:CLLocationCoordinate2D(latitude: 38.92183, longitude: 121.62717),
                   color:.blue)
        ]

        @StateObject var store = Store()

        var body: some View {
            ZStack(alignment:.bottom){
                Map(coordinateRegion: $region,
                    interactionModes: .all, //.pan .zoom .all
                    showsUserLocation: true, //是否显示用户当前位置
                    userTrackingMode:$trackmode, //是否更新用户位置
                    annotationItems:dots //标记点数据
                ){item in
                    //标记点显示，也可以直接使用内置的 MapPin, 不过 MapPin 无法响应用户输入
                    MapAnnotation(coordinate: item.coordinate  ){
                        //不知道是否是 bug, 目前 iOS 下无法显示 Text,maxOS 可以显示
                        Label(item.title, systemImage: "star.fill")
                            .font(.body)
                            .foregroundColor(item.color)
                            .onTapGesture {
                                print(item.title)
                            }
                    }
                }
            }
            .edgesIgnoringSafeArea(.all)
        }
    }

    //标记点数据，要求符合 Identifiable
    struct MapDot:Identifiable{
        let id = UUID()
        let title:String
        let coordinate:CLLocationCoordinate2D
        let color:Color
    }

    class Store:ObservableObject {
        let manager = CLLocationManager()
        init() {
            //请求位置访问权限。需要在 plist 中设置 Privacy - Location When In Use Usage Description
            //如果不需要显示当前用户位置，则无需申请权限
            #if os(iOS)
                manager.requestWhenInUseAuthorization()
            #endif
        }
    }

# SwiftUI 布局 —— 对齐

“对齐”是 SwiftUI 中极为重要的概念，然而相当多的开发者并不能很好地驾驭这个布局利器。在 WWDC 2022 中，苹果为 SwiftUI 增添了
Layout 协议，让我们有了更多的机会了解和验证 SwiftUI 的布局原理。本文将结合 Layout 协议的内容对 SwiftUI 的 “对齐”
进行梳理，希望能让读者对“对齐”有更加清晰地认识和掌握。

> 本文并不会对 alignment 、alignmentGuide 等内容作详尽的介绍，想了解更多的内容可以阅读文中推荐的资料。可以在此处下载 [
> 本文所需的源代码 ](https://github.com/fatbobman/BlogCodes/tree/main/MyZStack)

## 什么是对齐（ Alignment ）

对齐是发生在多个对象之间的一种行为。比如将书桌上的一摞书摆放整齐，列队训练时向左（右）看齐等等。在 SwiftUI
中，对齐是指在布局容器中，将多个视图按照对齐指南（ Alignment Guide ）进行对齐。比如下面的代码便是要求 ZStack
容器内的所有视图，按照各自的中心点进行对齐：

    ZStack(alignment: .center) {
        Text("Hello")
        Text("World")
        Circle()
            .frame(width: 50, height: 50)
    }

在“对齐”行为中最关键的两点为：

- 以什么为对齐指南
- 对哪些视图进行“对齐”

## 对齐指南

### 概述

对齐指南（ alignment guide）用来标识视图间进行对齐的依据，它具备如下特点：

- 对齐指南不仅可以标识点，还可以标识线

在 SwiftUI 中，分别用 HorizontalAlignment 和 VerticalAlignment
来标识在视图纵轴和横轴方向的参考线，并且可以由两者共同构成对视图中的某个具体的参考点的标识。

HorizontalAlignment. leading 、HorizontalAlignment. center
、HorizontalAlignment. trailing 分别标识了前沿、中心和后缘（ 沿视图水平轴 ）。

VerticalAlignment. top 、VerticalAlignment. center 、VerticalAlignment. bottom
则分别标识了顶部、中心和底部（ 沿视图垂直轴 ）。

而 Alignment. topLeading 则由 HorizontalAlignment. leading 和 VerticalAlignment.
top 构成，两条参考线的交叉点标识了视图的顶部—前沿。

![image-20220704154347077](https://cdn.fatbobman.com/image-20220704154347077.png)

![image-20220704154754068](https://cdn.fatbobman.com/image-20220704154754068.png)

- 对齐指南由函数构成

HorizontalAlignment 和 VerticalAlignment 本质上是一个返回类型为 CGFloat
的函数。该函数将返回沿特定轴向的对齐位置（ 偏移量 ）

- 对齐指南支持多种布局方向

正是由于对齐指南由函数构成，因此其先天便具备了灵活的适应能力。在 SwiftUI
中，系统预置对齐指南都提供了对不同布局方向的支持。只需修改视图的排版方向，对齐指南将自动改变其对应的位置

    VStack(alignment:.leading){
        Text("Hello world")
        Text("WWDC 2022")
    }
    .environment(\.layoutDirection, .rightToLeft)

![image-20220629202253658](https://cdn.fatbobman.com/image-20220629202253658.png)

![image-20220629202556777](https://cdn.fatbobman.com/image-20220629202556777.png)

> 想更多地了解自定义对齐指南以及 Alignment Guide 的应用案例，推荐阅读 Javier 的 [ Alignment Guides in
> SwiftUI ](https://swiftui-lab.com/alignment-guides/) 一文

### 自定义对齐指南

除了 SwiftUI 提供的预置对齐指南外，开发者也可以自定义对齐指南：

    struct OneThirdWidthID: AlignmentID {
        static func defaultValue(in context: ViewDimensions) -> CGFloat {
            context.width / 3
        }
    }
    // 自定义了一个 HorizontalAlignment , 该参考值为视图宽度的三分之一
    extension HorizontalAlignment {
        static let oneThird = HorizontalAlignment(OneThirdWidthID.self)
    }

    // 也可以为 ZStack 、frame 定义同时具备两个维度值的参考点
    extension Alignment {
        static let customAlignment = Alignment(horizontal: .oneThird, vertical: .top)
    }

自定义对齐指南与 SwiftUI 预置的对齐指南一样，可用于任何支持对齐的容器视图。

### alignmentGuide 修饰器

在 SwiftUI 中，开发者可以使用 alignmentGuide 修饰器来修改视图某个对齐指南的值（ 为对齐指南设定显式值，有关显式值见下文）。比如：

    struct AlignmentGuideDemo:View{
        var body: some View{
            VStack(alignment:.leading) {
                rectangle // Rectangle1
                    .alignmentGuide(.leading, computeValue: { viewDimensions in
                        let defaultLeading = viewDimensions[.leading] // default is 0
                        let newLeading = defaultLeading + 30
                        return newLeading
                    })

                rectangle // Rectangle2
            }
            .border(.pink)
        }

        var rectangle:some View {
            Rectangle()
                .fill(.blue.gradient)
                .frame(width: 100, height: 100)
        }
    }

通过 alignmentGuide 我们将 Rectangle 1 的 HorizontalAlignment. leading 沿水平轴向右侧偏移了 30
，与 Rectangle 2 在 VStack 中按 .leading 对齐后结果如下图：

![image-20220704171710023](https://cdn.fatbobman.com/image-20220704171710023.png)

### 对齐指南的显式值

对齐指南值 = 显式值 ?? 默认值

视图中的每个对齐指南都有默认值（ 通过在对齐指南定义中的 defaultValue 方法获取 ）。在不为对齐指南设置显式值（ 显式值为 nil
）的情况下，对齐指南将返回默认值。

    Rectangle()
        .fill(.blue.gradient)
        .frame(width: 100, height: 100)
    // 默认的对齐指南值：
    // leading: 0 , HorizontalAlignment.center: 50, trailing: 100
    // top: 0 , VerticalAlignment.center: 50 , bottom: 100
    // firstTextBaseline : 100 , lastTextBaseline : 100

如果我们使用了 alignmentGuide 为某个对齐指南设置了显式值，那么此时对齐指南的值为我们设置的显式值。

    Rectangle()
        .fill(.blue.gradient)
        .frame(width: 100, height: 100)
        .alignmentGuide(.leading, computeValue: { viewDimensions in
            let leading = viewDimensions[.leading] // 由于此时显式值为 nil , 因此 leading 值为 0
            return viewDimensions.width / 3 // 将 leading 的显式值设置为宽度三分之一处
        })
        .alignmentGuide(.leading, computeValue: { viewDimensions in
            let leading = viewDimensions[.leading] //  因为上面设置了显式值，此时 leading 值为 33.33
            let explicitLeading = viewDimensions[explicit: .leading] // 显式值 , 此时为 Optional(33.33)
            return viewDimensions[HorizontalAlignment.center] // 再度设置 leading 的显式值。此时显式值为 Optional(50) , .leading 值为 50
        })

即使你没有修改对齐指南的默认值，但只要为 alignmentGuide 提供了返回值，便设置了显式值：

    Rectangle()
        .fill(.blue.gradient)
        .frame(width: 100, height: 100)
        .alignmentGuide(.leading, computeValue: { viewDimensions in
            let leading = viewDimensions[.leading] // 此时 leading 的显式值为 nil
            return leading  // 此时 leading 为 0 ，leading 的显式值为 0
        })

### 特殊的对齐指南

在上文中，我们故意避开了两个容易令人困惑的对齐指南：firstTextBaseline、lastTextBaseline
。因为这两个对齐指南会根据视图内容的不同而变化。

在阅读下面的代码时，请在心中自行分析一下视图对应的 firstTextBaseline 和 lastTextBaseline 对齐指南的位置：

    Rectangle()
        .fill(.orange.gradient)
        .frame(width: 100, height: 100)

![image-20220629205343135](https://cdn.fatbobman.com/image-20220629205343135.png)

> 视图中没有文字，firstTextBaseline 和 lastTextBaseline 等同于 bottom

    Text("Hello world")
        .border(.red)

![image-20220704175657449](https://cdn.fatbobman.com/image-20220704175657449.png)

> 单行文字，firstTextBaseline 和 lastTextBaseline 相同。文字基线不同于 bottom

    Text("山不在高，有仙则名。水不在深，有龙则灵。斯是陋室，惟吾德馨。苔痕上阶绿，草色入帘青。谈笑有鸿儒，往来无白丁。可以调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭。孔子云：何陋之有？")
        .frame(width:200)

![image-20220704175811856](https://cdn.fatbobman.com/image-20220704175811856.png)

> 多行文字，firstTextBaseline 为第一行文字基线，lastTextBaseline 为最后一行文字基线

SwiftUI 对于布局容器（ 复合视图 ）的 firstTextBaseline 和 lastTextBaseline
的不透明计算方法，是产生困惑的主要原因。

    Button("Hello world"){}
        .buttonStyle(.borderedProminent)
        .controlSize(.large)

![image-20220629212234572](https://cdn.fatbobman.com/image-20220629212234572.png)

    Button(action: {}, label: {
        Capsule(style: .circular).fill(.yellow.gradient).frame(width: 30, height: 15)
    })
    .buttonStyle(.borderedProminent)
    .controlSize(.large)

![image-20220630112907178](https://cdn.fatbobman.com/image-20220630112907178.png)

    Text("Hello world")
        .frame(width: 100, height: 100, alignment: .topLeading)
        .border(.red)

![image-20220629210927483](https://cdn.fatbobman.com/image-20220629210927483.png)

    VStack {
        Rectangle().fill(.red.gradient).frame(width: 50, height: 10)
        Text("Hello world")
        Text("WWDC 2022")
        Text("肘子的 Swift 记事本")
        Rectangle().fill(.blue.gradient).frame(width: 50, height: 10)
    }
    .border(.red)

![image-20220630112242594](https://cdn.fatbobman.com/image-20220630112242594.png)

    VStack {
        Rectangle().fill(.red.gradient).frame(width: 50, height: 50)
        Rectangle().fill(.blue.gradient).frame(width: 50, height: 50)
    }
    .border(.red)

![image-20220630112428784](https://cdn.fatbobman.com/image-20220630112428784.png)

    HStack(alignment: .center) {
        Rectangle().fill(.blue.gradient).frame(width: 20, height: 50)
        Text("Hello world")
            .frame(width: 100, height: 100, alignment: .top)
        Text("山不在高，有仙则名。水不在深，有龙则灵。斯是陋室，惟吾德馨。苔痕上阶绿，草色入帘青。谈笑有鸿儒，往来无白丁。可以调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭。孔子云：何陋之有？")
            .frame(width: 100)
        Text("WWDC 2022")
            .frame(width: 100, height: 100, alignment: .center)
        Rectangle().fill(.blue.gradient).frame(width: 20, height: 50)
    }
    .border(.red)

![image-20220630113215811](https://cdn.fatbobman.com/image-20220630113215811.png)

    ZStack {
        Text("Hello world")
            .frame(width: 100, height: 100, alignment: .topTrailing)
            .border(.red)
        Color.blue.opacity(0.2)
        Text("肘子的 Swift 记事本")
            .frame(width: 100, height: 100, alignment: .bottomLeading)
            .border(.red)
    }
    .frame(width: 130, height: 130)
    .border(.red)

![image-20220629211312570](https://cdn.fatbobman.com/image-20220629211312570.png)

    Grid {
        GridRow(alignment:.lastTextBaseline) {
            Text("Good")
            Text("Hello world")
                .frame(width: 50, height:50, alignment: .top)
                .border(.red)
            Text("Nice")
        }
        GridRow {
            Color.red.opacity(0.3)
            Color.green.opacity(0.2)
            Color.pink.opacity(0.2)
        }
        GridRow(alignment:.top) {
            Text("Start")
            Text("WWDC 2022")
                .frame(width: 70, height:50, alignment: .center)
                .border(.red)
            Rectangle()
                .fill(.blue.gradient)
        }
    }
    .frame(maxWidth: 300, maxHeight: 300)
    .border(.red)

![image-20220630113419551](https://cdn.fatbobman.com/image-20220630113419551.png)

    HStack {
        Text("First")
        VStack {
            Text("Hello world")
            Text("肘子的 Swift 记事本")
            Text("WWDC")
        }
        .border(.red)
        .padding()
        Text("Second")
        Rectangle().fill(.red.gradient)
            .frame(maxWidth: 10, maxHeight: 100)
    }
    .border(.green)

![image-20220630113655186](https://cdn.fatbobman.com/image-20220630113655186.png)

请暂停阅读下文，看看你是否可以从上面的代码中总结出 SwiftUI 对于布局容器（ 复合视图 ）的 firstTextBaseline 和
lastTextBaseline 的计算规律。

…

…

…

…

…

…

…

…

…

…

复合视图的 firstTextBaseline 和 lastTextBaseline 计算方法为：

- 对于 firstTextBaseline ，如果复合视图中（ 容器中 ）的子视图存在 **显式值非 nil** 的 firstTextBaseline ，则返回显式值位置最高的 firstTextBaseline，否则返回默认值（ 通常为 bottom ）
- 对于 lastTextBaseline ，如果复合视图中（ 容器中 ）的子视图存在 **显式值非 nil** 的 lastTextBaseline ，则返回显式值位置最低的 lastTextBaseline，否则返回默认值（ 通常为 bottom ）

这就是尽管开发者很少会在 alignmentGuide 中关心并使用对齐指南的显式值，但它在 SwiftUI 中仍十分重要的原因。

### 为符合 Layout 协议的自定义布局设置显式对齐指南

SwiftUI 4.0 新增的 Layout 协议，让开发者拥有了自定义布局容器的能力。通过使用 Layout 协议提供的
explicitAlignment 方法，我们可以验证上面有关布局容器（ 复合视图 ）的 firstTextBaseline 和
lastTextBaseline 的算法正确与否。

Layout 协议提供了两个不同参数类型的 explicitAlignment 方法，分别对应 VerticalAlignment 和
HorizontalAlignment 类型。explicitAlignment
让开发者可以站在布局的角度来设置对齐指南的显式值。explicitAlignment 的默认实现将为任何的布局指南的显式值返回 nil 。

下面的代码片段来自本文附带的源码 —— 用 Layout 协议仿制 ZStack 。我将通过在 explicitAlignment 方法中分别为
firstTextBaseline 和 lastTextBaseline 设置了显式对齐指南，以证实之前的猜想。

    // SwiftUI 通过此方法来获取特定的对齐指南的显式值
    func explicitAlignment(of guide: VerticalAlignment,  // 查询的对齐指南
                           in bounds: CGRect, // 自定义容器的 bounds ，该 bounds 的尺寸由 sizeThatFits 方法计算得出，与 placeSubviews 的 bounds 参数一致
                           proposal: ProposedViewSize,  // 父视图的建议尺寸
                           subviews: Subviews,  // 容器内的子视图代理
                           cache: inout CacheInfo // 缓存数据，本例中，我们在缓存数据中保存了每个子视图的 viewDimension、虚拟 bounds 能信息
                          ) -> CGFloat? {
        let offsetY = cache.cropBounds.minY * -1
        let infinity: CGFloat = .infinity

        // 检查子视图中是否有 显式 firstTextBaseline 不为 nil 的视图。如果有，则返回位置最高的 firstTextBaseline 值。
        if guide == .firstTextBaseline,!cache.subviewInfo.isEmpty {
            let firstTextBaseline = cache.subviewInfo.reduce(infinity) { current, info in
                let baseline = info.viewDimension[explicit: .firstTextBaseline] ?? infinity
                // 将子视图的显式 firstTextBaseline 转换成 bounds 中的偏移值
                let transformBaseline = transformPoint(original: baseline + info.bounds.minY, offset: offsetY, targetBoundsMinX: 0)
                // 返回位置最高的值（ 值最小 ）
                return min(current, transformBaseline)
            }
            return firstTextBaseline != infinity ? firstTextBaseline : nil
        }

        if guide == .lastTextBaseline,!cache.subviewInfo.isEmpty {
            let lastTextBaseline = cache.subviewInfo.reduce(-infinity) { current, info in
                let baseline = info.viewDimension[explicit: .lastTextBaseline] ?? -infinity
                let transformBaseline = transformPoint(original: baseline + info.bounds.minY, offset: offsetY, targetBoundsMinX: 0)
                return max(current, transformBaseline)
            }
            return lastTextBaseline != -infinity ? lastTextBaseline : nil
        }

        return nil
    }

> 由于视图使用 Layout 协议的 explicitAlignment
> 方法的默认实现效果与使用我们自定义的方法效果完全一致，因此可以证明我们之前的猜想是正确的。如果你只想让你的自定义布局容器呈现与 SwiftUI
> 预置容器一致的对齐指南效果，直接使用 Layout 协议的默认实现即可（ 无需实现 explicitAlignment 方法 ）。

即使布局容器通过 explicitAlignment 为对齐指南提供了显式值，开发者仍然可以通过 alignmentGuide 做进一步设置。

## 对哪些视图进行“对齐”

在上文中我们用了不小的篇幅介绍了对齐指南，本节中我们将探讨“对齐”的另一大关键点 —— 在不同的上下文中，哪些视图会使用对齐指南进行“对齐”。

### VStack、HStack、ZStack 等支持多视图的布局容器

你是否了解 SwiftUI 常用布局容器构造方法中的对齐参数的含义？它们又是如何实现的呢？

    VStack(alignment:.trailing) { ... }
    ZStack(alignment: .center) { ... }
    HStack(alignment:.lastTextBaseline) { ... }
    GridRow(alignment:.firstTextBaseline) { ... }

由于苹果对容器视图的 alignment 参数的描述并不很清晰，因而开发者很容易出现理解偏差。

> The guide for aligning the subviews in this stack. This guide has the same
> vertical screen coordinate for every child view —— Apple documentation for
> VStack’s alignment

对于本段视图声明代码，你会选择下面哪种文字表述：

    ZStack(alignment: .bottomLeading) {
        Rectangle()
            .fill(.orange.gradient)
            .frame(width: 100, height: 300)
        Rectangle()
            .fill(.cyan.gradient).opacity(0.7)
            .frame(width: 300, height: 100)
    }

1. 在 ZStack 中按顺序重叠排列子视图（ Rectangle 1 和 Rectangle 2 ），并让每个子视图的 bottomLeading 与 ZStack 的 bottomLeading 对齐

2. 按顺序重叠排列 Rectangle 1 和 Rectangle 2，并让两者的 bottomLeading 对齐

![image-20220701132738722](https://cdn.fatbobman.com/image-20220701132738722.png)

如果你选择了 1 ，请问你该如何解释下面代码中的 alignmentGuide 无法影响子视图的对齐。

    ZStack(alignment: .bottomLeading) {
        Rectangle()
            .fill(.orange.gradient)
            .frame(width: 100, height: 300)
        Rectangle()
            .fill(.cyan.gradient).opacity(0.7)
            .frame(width: 300, height: 100)
    }
    .alignmentGuide(.leading){
        $0[.leading] + 10
    }

描述 1 在绝大多数的情况下（ 不设置对齐指南显式值 ）看起来都 **像是** 正确的，而且也很符合人的直觉，但从 SwiftUI
的角度来说，它将根据描述二来执行。因为在布局容器构造方法中设定的对齐指南只用于容器的子视图之间。

为了更好地理解之所以描述二才是正确的，我们需要对 SwiftUI 的布局原理以及 ZStack 的处理方式有所了解。

布局容器在布局时，容器会为每个子视图提供一个建议尺寸（ proposal size ），子视图将参考容器提供的建议尺寸返回自己的需求尺寸（
子视图也可以完全无视容器的建议尺寸而提供任意的需求尺寸 ）。容器按照预设的行为（ 在指定轴向排列、点对齐、线对齐、添加间隙等
）在一个虚拟的画布中摆放所有的子视图。摆放结束后，容器将汇总摆放后的所有子视图的情况并向它的父视图（ 父容器 ）返回一个自身的需求尺寸。

因此，在布局容器对子视图进行对齐摆放过程中，布局容器的尺寸并没有确定下来，所以不会存在将子视图的对齐指南与容器的对齐指南进行“对齐”的可能。

通过创建符合 Layout 协议的布局容器可以清楚地展示上述的过程，下面的代码来自本文附带的演示代码 —— 一个 ZStack 的复制品 ：

    // 容器的父视图（父容器）通过调用容器的 sizeThatFits 获取容器的建议尺寸，本方法通常会被多次调用，并提供不同的建议尺寸
    func sizeThatFits(
        proposal: ProposedViewSize, // 容器的父视图（父容器）提供的建议尺寸
        subviews: Subviews, // 当前容器内的所有子视图的代理
        cache: inout CacheInfo // 缓存数据，本例中用于保存子视图的返回的需求尺寸，减少调用次数
    ) -> CGSize {
        cache = .init() // 清除缓存
        for subview in subviews {
            // 为子视图提供建议尺寸，获取子视图的需求尺寸 (ViewDimensions)
            let viewDimension = subview.dimensions(in: proposal)
            // 根据 MyZStack 的 alignment 的设置获取子视图 alignmentGuide 对应的点
            let alignmentGuide: CGPoint = .init(
                x: viewDimension[alignment.horizontal],
                y: viewDimension[alignment.vertical]
            )
            // 以子视图的 alignmentGuide 对应点为 (0,0) , 在虚拟的画布中，为子视图创建 Bounds
            let bounds: CGRect = .init(
                origin: .init(x: -alignmentGuide.x, y: -alignmentGuide.y),
                size: .init(width: viewDimension.width, height: viewDimension.height)
            )
            // 保存子视图在虚拟画布中的信息
            cache.subviewInfo.append(.init(viewDimension: viewDimension, bounds: bounds))
        }

        // 根据所有子视图在虚拟画布中的数据，生成 MyZStack 的 Bounds
        cache.cropBounds = cache.subviewInfo.map(\.bounds).cropBounds()
        // 返回当前容器的需求尺寸，当前容器的父视图将使用该尺寸在它的内部进行摆放
        return cache.cropBounds.size
    }

    // 容器的父视图（父容器）将在需要的时机调用本方法，为本容器的子视图设置渲染尺寸
    func placeSubviews(
        in bounds: CGRect, // 根据当前容器在 sizeThatFits 提供的尺寸，在真实渲染处创建的 Bounds
        proposal: ProposedViewSize, // 容器的父视图（父容器）提供的建议尺寸
        subviews: Subviews, // 当前容器内的所有子视图的代理
        cache: inout CacheInfo // 缓存数据，本例中用于保存子视图的返回的需求尺寸，减少调用次数
    ) {
        // 虚拟画布左上角的偏移值 ( 到 0,0 )
        let offsetX = cache.cropBounds.minX * -1
        let offsetY = cache.cropBounds.minY * -1

        for index in subviews.indices {
            let info = cache.subviewInfo[index]
            // 将虚拟画布中的位置信息转换成渲染 bounds 的位置信息
            let x = transformPoint(original: info.bounds.minX, offset: offsetX, targetBoundsMinX: bounds.minX)
            let y = transformPoint(original: info.bounds.minY, offset: offsetY, targetBoundsMinX: bounds.minY)
            // 将转换后的位置信息设置到子视图上
            subviews[index].place(at: .init(x: x, y: y), anchor: .topLeading, proposal: proposal)
        }
    }

VStack 和 HStack 相对于 ZStack 在布局时将更加复杂。由于需要考虑在特定维度上可动态调整尺寸的子视图，比如： Spacer 、Text
、frame (minWidth:maxWidth:minHeight:maxHeight) 等，VStack 和 HStack
会为子视图进行多次尺寸提案（ 包括理想尺寸、最小尺寸、最大尺寸、特定尺寸等 ），并结合子视图的布局优先级（ layoutPriority
）才能计算出子视图的需求尺寸，并最终确定自身的尺寸。

总之，为 VStack、HStack、ZStack 这类可包含多个子视图的官方布局容器设置 alignment 的含义就只有一种 ——
在特定维度上，将所有的子视图按照给定的对齐指南进行对齐摆放。

### overlay、background

在 SwiftUI 中，除了我们熟悉的 VStack、HStack、ZStack 、Grid 、List 外，很多 modifier
的功能也都是通过布局来实现的。例如 overlay、background、frame、padding 等等。

你可以将 overlay 和 background 视作一个特殊版本的 ZStack 。

    // 主视图
    Rectangle()
        .fill(.orange.gradient)
        .frame(width: 100, height: 100)
        // 附加视图
        .overlay(alignment:.topTrailing){
            Text("Hi")
        }

比如上面的代码，如果用布局的逻辑可以表示为（ 伪代码）：

    _OverlayLayout {
        // 主视图
        Rectangle()
            .fill(.orange.gradient)
            .frame(width: 100, height: 100)

        // 附加视图
        Text("Hi")
            .layoutValue(key: Alignment.self, value: .topTrailing) // 一种子视图向最近容器传递信息的方式
    }

与 ZStack
的不同在于，它只会包含两个子视图，且它的尺寸将仅由主视图来决定。主视图将和附加视图按照设定的对齐指南进行对齐。只要理解了这点，就会知道该如何调整主视图或辅助视图的对齐指南了，比如：

    // 主视图
    Rectangle()
        .fill(.orange.gradient)
        .frame(width: 100, height: 100)
        .alignmentGuide(.trailing, computeValue: {
            $0[.trailing] - 30
        })
        .alignmentGuide(.top, computeValue: {
            $0[.top] + 30
        })
        // 附加视图
        .overlay(alignment:.topTrailing){
            Text("Hi")
        }

![image-20220701143710982](https://cdn.fatbobman.com/image-20220701143710982.png)

### frame

frame 本质上就是 SwiftUI 中一个用于调节尺寸的布局容器，它会变换容器传递给子视图的建议尺寸，也可能会改变子视图返回给容器的需求尺寸。比如：

    VStack {
        Text("Hello world")
           .frame(width: 10, height: 30, alignment: .top)
    }

在上面的代码中，由于添加了 frame 修饰器，因此 FrameLayout（ 实现 frame 的后端布局容器 ）将无视 VStack
提供的建议尺寸，强行为 Text 提供 10 x 30 的建议尺寸，并且无视子视图 Text 的需求尺寸，为父视图（ VStack ）返回 10 x 30
的需求尺寸。虽然 FrameLayout 中只包含一个子视图，但在布局时它会让子视图与一个特定尺寸的虚拟视图进行对齐。或许将上面的 frame 代码转换成
background 的布局模式会更加方便理解：

    _BackgroundLayout {
        Color.clear
            .frame(width: 10, height: 30)

        Text("Hello world")
            .layoutValue(key: Alignment.self, value: .top)
    }

> 动态版本的 frame（ FlexFrameLayout ） 修饰器是一个学习、理解 SwiftUI 布局中尺寸协商机制的绝佳案例。有兴趣的朋友可以使用
> Layout 协议对其进行仿制。

## 总结

虽然本文并没有提供具体的对齐使用技巧，但只要你理解并掌握了对齐的两大要点：以什么为对齐指南、对哪些视图进行“对齐”，那么相信一定会减少你在开发中遇到的对齐困扰，并可以通过对齐实现很多以前不容易完成的效果。

如果你想对 Layout 协议做更全面地了解，推荐你观看 Jane（ 美眉 up 主）制作的有关 SwiftUI Layout 协议的中文视频 —— [
自订 Layout 排版教学 ](https://youtu.be/du_Bl7Br9DM) 。

# 探讨 SwiftUI 中的属性包装器：@UIApplicationDelegateAdaptor、@AccessibilityFocusState、@FocusedObject、@FocusedValue 和 @FocusedBinding

在本文中，我们将对 `@UIApplicationDelegateAdaptor` 、 `@AccessibilityFocusState` 、 `@FocusedObject` 、 `@FocusedValue` 和 `@FocusedBinding`
等属性包装器进行探讨。这些属性包装器涵盖了不同框架声明周期的整合、辅助聚焦、焦点值观察管理等功能。

> 本文旨在提供对这些属性包装器的主要功能和使用注意事项的概述，而非详尽的使用指南。

- [ @State、@Binding、@StateObject、@ObservedObject、@EnvironmentObject、@Environment ](/zh/posts/exploring-key-property-wrappers-in-swiftui/)
- [ @AppStorage、@SceneStorage、@FocusState、@GestureState、@ScaledMetric ](/zh/posts/exploring-swiftui-property-wrappers-2/)
- [ @FetchRequest、@SectionedFetchRequest、@Query、@Namespace、@Bindable ](/zh/posts/exploring-swiftui-property-wrappers-3/)

## 1\. @UIApplicationDelegateAdaptor

`@UIApplicationDelegateAdaptor` 为开发者提供了在以 SwiftUI 生命周期为基础的应用中访问和利用 UIKit 的
AppDelegate 功能的能力，从而处理如推送通知、生命周期事件等 UIKit 特有的任务。

### 1.1 基本用法

    class AppDelegate: NSObject,UIApplicationDelegate {
        // 实现相关的 UIApplicationDelegate 方法
        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
                print("App launched")
                return true
            }
    }

    @main
    struct DelegateDemo: App {
        @UIApplicationDelegateAdaptor var delegate:AppDelegate
        var body: some Scene {
            WindowGroup {
                ContentView()
            }
        }
    }

在上述代码示例中，我们首先声明了一个同时遵循 `NSObject` 和 `UIApplicationDelegate` 协议的类。接着，通过使用 `UIApplicationDelegateAdaptor` ，我们在 App 的声明中对这个类进行了注册。

### 1.2 主要功能

- 允许 SwiftUI 应用利用 UIKit 提供的丰富功能，如后台任务处理、App 生命周期管理等。
- 对于现有的 UIKit 应用，使用 `@UIApplicationDelegateAdaptor` 可以更平滑地过渡到 SwiftUI，而无需重写大量的应用逻辑。

### 1.3 注意事项与使用技巧

- **唯一性与位置限制：** `UIApplicationDelegateAdaptor` 应在 App 的主体声明中定义，并且在整个应用中只能定义一次。
- **环境变量注入：** 处理 AppDelegate 逻辑的类可以实现 `ObservableObject` 协议，并通过环境变量注入到视图树中。这样，可以在视图内部使用 `@EnvironmentObject` 获取 AppDelegate 的实例。

  class AppDelegate: NSObject,UIApplicationDelegate,ObservableObject {
  @Published var launched:Bool = false
  func application(\_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
  launched = true
  return true
  }
  }

  @main
  struct DelegateDemo: App {
  @UIApplicationDelegateAdaptor var delegate:AppDelegate
  var body: some Scene {
  WindowGroup {
  ContentView()
  .environmentObject(delegate)
  }
  }
  }

  struct ContentView:View {
  @EnvironmentObject var delegate:AppDelegate
  var body: some View {
  Text("Launched \(delegate.launched ? "True" : "False")")
  }
  }

- **聚焦生命周期与系统事件：** `AppDelegate` 类建议专注于应用生命周期和系统事件的处理，避免混入业务逻辑。
- **处理 SceneDelegate 事件：** 若要响应 `UIWindowSceneDelegate` 的事件，可以按以下方式实现：

  final class SceneDelegate:NSObject,UIWindowSceneDelegate{
  func sceneWillEnterForeground(\_ scene: UIScene) {
  print("will enter foreground")
  }
  }

  extension AppDelegate {
  func application(\_ application: UIApplication,
  configurationForConnecting connectingSceneSession: UISceneSession,
  options: UIScene.ConnectionOptions) -> UISceneConfiguration {
  let sceneConfig = UISceneConfiguration(name: nil, sessionRole: connectingSceneSession.role)
  sceneConfig.delegateClass = SceneDelegate.self
  return sceneConfig
  }
  }

- **自动注入 SceneDelegate：** 如果 `SceneDelegate` 实现了 `ObservableObject` ，并且 `AppDelegate` 被注入环境中，SwiftUI 也会自动将 `SceneDelegate` 注入相同环境。

  extension SceneDelegate:ObservableObject {}

  ContentView()
  .environmentObject(delegate)

  struct ContentView1:View {
  @EnvironmentObject var appDelegate:AppDelegate
  @EnvironmentObject var sceneDelegate:SceneDelegate
  var body: some View {
  Text("Launched \(appDelegate.launched ? "True" : "False")")
  }
  }

- **Observation 框架适用性：** 上述逻辑在使用 Observation 框架时同样适用。

  @Observable // Using Observation
  class AppDelegate: NSObject,UIApplicationDelegate {
  var launched:Bool = false
  func application(\_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
  launched = true
  print("lanched")
  return true
  }
  }

  @Observable // Using Observation
  final class SceneDelegate:NSObject,UIWindowSceneDelegate{
  var foreground:Bool = false
  func sceneWillEnterForeground(\_ scene: UIScene) {
  foreground = true
  print("will enter foreground")
  }
  }

  extension AppDelegate {
  func application(\_ application: UIApplication,
  configurationForConnecting connectingSceneSession: UISceneSession,
  options: UIScene.ConnectionOptions) -> UISceneConfiguration {
  let sceneConfig = UISceneConfiguration(name: nil, sessionRole: connectingSceneSession.role)
  sceneConfig.delegateClass = SceneDelegate.self
  return sceneConfig
  }
  }

  @main
  struct PropertyWrapperApp: App {
  @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate
  var body: some Scene {
  WindowGroup {
  ContentView1()
  .environment(delegate) // 按照 Observed 的方式注入
  }
  }
  }

  struct ContentView1:View {
  @Environment(AppDelegate.self) var appDelegate
  @Environment(SceneDelegate.self) var sceneDelegate
  var body: some View {
  VStack {
  Text("Launched \(appDelegate.launched ? "True" : "False")")
  Text("Foreground \(sceneDelegate.foreground ? "True" : "False")")
  }
  }
  }

- **优先使用 SwiftUI 原生事件处理：** 对于 SwiftUI 已提供原生支持的事件处理逻辑，如 `sceneWillEnterForeground` ，建议优先使用原生方法，例如响应 `scenePhase` 环境值。

  struct ContentView:View {
  @Environment(\.scenePhase) var scenePhase
  var body: some View {
  Text("Hello World")
  .onChange(of: scenePhase){ phase in
  switch phase {
  case .active: // 对应 sceneWillEnterForeground
  print("active")
  case .inactive:
  print("inactive")
  case .background:
  print("background")
  @unknown default:
  break
  }
  }
  }
  }

- **其他原生修饰器：**SwiftUI 还提供了一系列修饰器，可以用来避免在 Delegate 中处理某些事件，如 `onContinueUserActivity` 、 `backgroundTask` 、 `handlesExternalEvents` 、 `onOpenURL` 和 `userActivity` 等。在可能的情况下，应优先考虑使用这些 SwiftUI 原生的方法。

> [ `@NSApplicationDelegateAdaptor` > ](https://developer.apple.com/documentation/swiftui/nsapplicationdelegateadaptor)
> 、 [ `@WKApplicationDelegateAdaptor` > ](https://developer.apple.com/documentation/swiftui/wkapplicationdelegateadaptor)
> 和 [ `@WKExtensionDelegateAdaptor` > ](https://developer.apple.com/documentation/swiftui/wkextensiondelegateadaptor)
> 在用法上与 `@UIApplicationDelegateAdaptor`
> 非常相似，但它们分别适配不同的平台。由于这些属性包装器的基本原理相同，本文将不对它们进行单独的讨论。

## 2 @AccessibilityFocusState

`@AccessibilityFocusState` 在 SwiftUI 中被设计用于增强无障碍体验。这个属性包装器使得开发者能够更有效地管理和响应
VoiceOver 等辅助功能的焦点状态，进而为所有用户打造出更加易于导航和操作的应用界面。它在基本概念和应用方法上与 `@FocusState`
非常相似，可以被视为专门针对辅助功能元素的 `@FocusState` 。

### 2.1 基本用法

    // 方式一：
    struct AccessibilityFocusStateView:View {
        @AccessibilityFocusState(for: .switchControl) var isClickButtonFocused:Bool
        var body: some View {
            VStack {
                Button("Press me"){
                    print("Press")
                }

                Button("Click me"){
                    print("Click")
                }
                .accessibilityFocused($isClickButtonFocused)
            }
            .onChange(of: isClickButtonFocused){
                print(isClickButtonFocused)
            }
        }
    }

    // 方式二：
    struct AccessibilityFocusStateView: View {
        @AccessibilityFocusState var focused: FocusField?
        var body: some View {
            VStack {
                Button("Press me") {
                    // do something
                    // then change focus
                    focused = .click
                }
                .accessibilityFocused($focused, equals: .press)

                Button("Click me") {
                    print("Click")
                }
                .accessibilityFocused($focused, equals: .click)
            }
        }
    }

    enum FocusField: Hashable {
        case press
        case click
    }

### 2.2 注意事项与使用技巧

- **特定辅助模式配置：** `@AccessibilityFocusState` 可以根据需要配置，以仅在特定辅助模式下激活，例如 `.switchControl` 或 `.voiceOver` 。默认情况下，它支持所有辅助功能。

  @AccessibilityFocusState(for:.switchControl) var focused: FocusField?
  // or
  @AccessibilityFocusState(for:.voiceOver) var focused: FocusField?

- **无障碍测试：** 为了确保无障碍用户的良好体验，应使用 VoiceOver 等辅助工具测试应用中的焦点管理功能，确保它们按预期运作。
- **避免复杂化：** 在使用 `@AccessibilityFocusState` 时，应避免在不必要的场景中引入过于复杂的焦点管理逻辑，以免造成用户的困扰或混乱。

## 3 @FocusedObject

`@FocusedObject` 用于观察由当前聚焦的视图或场景提供的可观察类型数据。这些数据可以由获得焦点的可观察视图（使用 `.focusedObject` 修饰符）或获得焦点的场景（使用 `.focusedSceneObject` 修饰符）来提供和管理。

### 3.1 基本用法

- **观察聚焦场景数据** ：下面的代码将在 macOS 上创建一个菜单项 Empty，点击它会情况当前聚焦场景中的文本框内容（ 使用 ⌘-N 可以创建新的场景 ）：

  // 要求符合 ObservableObject 协议
  class DataModel:ObservableObject {
  @Published var text = ""
  }

  struct MyCommands:Commands {
  // 获取由当前聚焦场景中，由 focusedSceneObject 提供的 DataModel 实例，如果没有则为 nil
  @FocusedObject var dataModel:DataModel?
  var body: some Commands {
  CommandMenu("Action") {
  Button("Empty"){
  dataModel?.text = ""
  }
  }
  }
  }

  @main
  struct FocusedSceneObjectDemoApp: App {
  var body: some Scene {
  WindowGroup {
  ContentView()
  .scenePadding()
  }
  .commands {
  MyCommands()
  }
  }
  }

  struct ContentView: View {
  @StateObject var dataModel = DataModel()
  var body: some View {
  VStack {
  // focusedSceneObject 在场景聚焦时便会自动提供数据，与当前视图是否可聚焦无关
  Text("Input:")
  .focusedSceneObject(dataModel)
  TextEditor(text: $dataModel.text)
  }
  }
  }

- **观察聚焦视图（ 可聚焦视图 ）数据** ：下面的代码提供与上面代码相同的功能，唯一的区别是 `focusedObject` 需要使用在可聚焦视图或元素上，且只有当该视图或元素获得了焦点后，才会提供数据。

  // 其他代码一样
  struct ContentView: View {
  @StateObject var dataModel = DataModel()
  var body: some View {
  VStack {
  Text("Input:")
  // 由可聚焦视图在获得焦点时提供数据
  TextEditor(text: $dataModel.text)
  .focusedObject(dataModel)
  }
  }
  }

### 3.2 主要功能

`@FocusedObject`
为应用提供了从当前聚焦元素获取可观察对象的能力，这极大地方便了开发者创建动态且响应用户操作的界面。它经常被用于实现需要根据当前焦点状态进行相应处理的功能，如菜单和
HUB 等场景。

### 3.3 注意事项与使用技巧

- **可选值类型：** `@FocusedObject` 应声明为可选（Optional）类型。当相关的焦点场景或元素失去焦点后，该对象的值将自动变为 nil。
- **遵循`ObservableObject` ： ** 用于 `@FocusedObject` 的数据类型必须实现 `ObservableObject` 协议。
- **唯一实例数据：** 类似于 `EnvironmentObject` ，对于任意给定类型，系统在同一时间内仅保留一个实例的数据。因此，应避免同时使用多个 `focusedObject` 或 `focusedSceneObject` 提供同一类型的多份数据。
- **多场景数据提供：** 在多场景应用中，建议使用 `focusedSceneObject` 来提供跨场景数据。
- **使元素可聚焦：** 可以通过 `focusable` 修饰符使原本不可聚焦的元素成为可聚焦的，这样一来，当元素获得焦点时，它也能通过 `focusedObject` 提供数据。

  Text("Input:")
  .focusable()
  .focusedObject(dataModel)

- **观察范围取决于声明位置：** `@FocusedObject` 观察到的数据受其声明位置的影响。在 App 或 Commands 层级声明时，它能够访问所有场景中通过 `focusedObject` 或 `focusedSceneObject` 提供的同类型数据。然而，若在特定场景的代码中声明，则仅能够访问当前场景内由任意视图提供的同类型 `focusedObject` 或 `focusedSceneObject` 数据。

  struct MyCommands: Commands {
  // 可以观察所有场景中的 DataModel 可聚焦数据
  @FocusedObject var dataModel: DataModel?
  var body: some Commands {
  ....
  }
  }

  @main
  struct FocusedSceneObjectDemoApp: App {
  // 可以观察所有场景中的 DataModel 可聚焦数据
  @FocusedObject var dataModel: DataModel?
  var body: some Scene {
  ....
  }
  }

  struct ContentView: View {
  // 仅观察当前场景中的 DataModel 可聚焦数据
  @FocusedObject var dataModel: DataModel?
  var body: some View {
  ....
  }
  }

- **自动识别可聚焦元素：** 除了被直接应用于具体的可聚焦元素， `@FocusedObject` 还能自动识别视图中的所有可聚焦元素。在下面的示例中，无论哪个 `TextEditor` 获得焦点， `@FocusedObject` 都将提供相应的数据：

  VStack {
  TextEditor(text: $dataModel.text)
  TextEditor(text: $dataModel.text2)
  }
  .focusedObject(dataModel)

- **单场景内的多重聚焦：** `@FocusedObject` 不仅适用于跨多个场景的数据观察，也可以在单个场景内发挥作用。例如，下面的代码演示了如何在同一个界面中同时管理用户和产品的不同聚焦状态。

  struct MultiFocusedDemo:View {
  @StateObject var user = UserProfile()
  @StateObject var product = ProductDetails()

      var body: some View {
          Form {
              UserView()
              ProductView()
              Group {
                  TextField("User Name:",text:$user.username)
                  TextField(value: $user.age, format: .number){ Text("Age:")}
              }
              .focusedObject(user)

              Group{
                  TextField("Product Name:",text:$product.productName)
                  TextField(value: $product.price, format: .number){ Text("Price:")}
              }
              .focusedObject(product)

          }
      }

  }

  class UserProfile: ObservableObject {
  @Published var username: String = "JohnDoe"
  @Published var age: Int = 30
  }

  class ProductDetails: ObservableObject {
  @Published var productName: String = "Widget"
  @Published var price: Double = 19.99
  }

  struct UserView: View {
  @FocusedObject var user: UserProfile?

      var body: some View {
          if let userProfile = user {
              Text("Username: \(userProfile.username)")
              Text("Age: \(userProfile.age)")
          }
      }

  }

  struct ProductView: View {
  @FocusedObject var product: ProductDetails?

      var body: some View {
          if let productDetails = product {
              Text("Product: \(productDetails.productName)")
              Text("Price: $\(productDetails.price)")
          }
      }

  }

- **结合其他焦点管理方案：** `@FocusedObject` 可以与其他焦点管理工具结合使用，从而实现更加灵活的交互设计。例如，在下面的代码中，我们通过 `@FocusState` 实现了在元素获得焦点的同时立即获取其相关的可观察对象数据：

  struct FocusStateDemo:View {
  @FocusState var focused:Bool
  @FocusedObject var data:DataModel?
  @StateObject var model = DataModel()
  var body: some View {
  VStack {
  if let text = data?.text {
  Text(text)
  }
  TextField("",text:$model.text)
                    .focused($focused)
  .focusedObject(model)
  }
  .task {
  focused = true
  }
  }
  }

## 4 @FocusedValue

`@FocusedValue` 属性包装器在 SwiftUI 中的作用与 `@FocusedObject` 非常相似，但它专注于值类型及基于
Observation 框架构建的可观察对象实例（使用 `@Observable` ）。

### 4.1 基本用法

与 EnvironmentValue 类似， `@FocusedValue` 的使用需先声明 `FocusedValueKey` 并扩展 `FocusedValues` ：

    struct MyFocusKey: FocusedValueKey {
        typealias Value = String
    }

    extension FocusedValues {
        var myKey: String? {  // Optional
            get { self[MyFocusKey.self] }
            set { self[MyFocusKey.self] = newValue }
        }
    }

在失去焦点时，系统会重置 `@FocusedValue` ，因此在声明 `FocusedValueKey` 时，默认值为 nil（ 无需设置默认值
）。

在应用中， `@FocusedValue` 的使用方式与 `@FocusedObject` 类似：

    struct ContentView: View {
        @FocusedValue(\.myKey) var key
        var body: some View {
            VStack {
                Text(key ?? "nil")
                SubView()
            }
        }
    }

    struct SubView:View {
        @State var key = "Hello"
        var body: some View {
            TextField("text",text:$key)
                .focusedValue(\.myKey, key)
        }
    }

### 4.2 注意事项与使用技巧

- 大部分在 `@FocusedObject` 中提及的注意事项与技巧同样适用于 `@FocusedValue` 。
- 在声明 `FocusedValueKey` 和扩展 `FocusedValues` 时，确保使用的类型为 Optional。
- 截至 Xcode 15.2 版本，尽管 `focusedValue` 支持发送由 `@Observable` 创建的实例， `@FocusedValue` 仍无法正常观察相应实例。此外，目前也缺乏支持 Observable 实例的 `focusedSceneValue` 版本。预计这些问题将在未来版本中得到解决。

## 5\. @FocusedBinding

`@FocusedBinding` 属性包装器赋予开发者在聚焦值观察端修改 `FocusedValueKey`
数据的能力，提供了更多的灵活性和控制权。。

### 5.1 基本用法

`@FocusedBinding` 允许在界面中直接修改与焦点相关的绑定数据。以下代码示例展示了如何在文本输入框和按钮中（
数据提供端和数据观察端）修改与 `myKey` 相关的数据：

    struct ContentView: View {
        @FocusedBinding(\.myKey) var key
        var body: some View {
            VStack {
                Text(key ?? "nil")
                Button("Change Key"){
                    key = "\(Int.random(in: 0..<100))"
                }
                SubView()
            }
        }
    }


    struct SubView:View {
        @State var key = "Hello"
        var body: some View {
            TextField("text",text:$key)
                .focusedValue(\.myKey, $key) // Binding
        }
    }

    struct MyFocusKey: FocusedValueKey {
        typealias Value = Binding<String> // Binding
    }

    extension FocusedValues {
        var myKey: Binding<String>? { // Optional
            get { self[MyFocusKey.self] }
            set { self[MyFocusKey.self] = newValue }
        }
    }

### 5.2 注意事项

- **绑定类型声明：** 在 `FocusedValueKey` 中声明的类型应为 `Binding` 。
- **值类型数据专用：** `@FocusedBinding` 仅用于值类型数据。待 `@Observable` 的相关问题解决后，无需使用 `Binding` 便可在观察端直接修改其属性（ 与 `@FocusedObject` 一样 ）。
- **SwiftUI 生命周期兼容性** ：当前 `@FocusedBinding` 仅在使用 SwiftUI 生命周期的应用中有效。

## 总结

Swift 语言的属性包装器与 SwiftUI 诞生于同一年。SwiftUI
充分利用这一功能，为开发者提供了一系列属性包装器，极大地简化了开发过程。在这个系列的四篇文章中，我们详细梳理了截至 iOS 17 时期 SwiftUI
所提供的全部属性包装器，旨在帮助开发者更加高效和便捷地使用 SwiftUI。希望这些内容能对大家在使用 SwiftUI 时提供有价值的指导和帮助。

# 探讨 SwiftUI 中的属性包装器：@AppStorage、@SceneStorage、@FocusState、@GestureState 和 @ScaledMetric

在本文中，我们将继续了解 SwiftUI 中的属性包装器： `@AppStorage` 、 `@SceneStorage` 、 `@FocusState` 、 `@GestureState` 以及 `@ScaledMetric`
。这些属性包装器涵盖了数据持久化、交互响应、辅助功能、多窗口支持等多个方面, 为开发者提供了简洁实用的解决方案。

> 本文旨在提供对这些属性包装器的主要功能和使用注意事项的概述，而非详尽的使用指南。

- [ @State、@Binding、@StateObject、@ObservedObject、@EnvironmentObject、@Environment ](/zh/posts/exploring-key-property-wrappers-in-swiftui/)
- [ @FetchRequest、@SectionedFetchRequest、@Query、@Namespace、@Bindable ](/zh/posts/exploring-swiftui-property-wrappers-3/)
- [ @UIApplicationDelegateAdaptor, @AccessibilityFocusState, @FocusedObject, @FocusedValue, @FocusedBinding ](/zh/posts/exploring-swiftui-property-wrappers-4/)

## 1\. @AppStorage

在 SwiftUI 中， `@AppStorage`
作为一个属性包装器，主要用于数据的持久化。它使我们能够轻松地将少量数据存储在用户的默认设置（UserDefaults）中。此外，当这些数据变更时，相关联的视图会自动进行更新。

### 1.1 基本用法

以下是 `@AppStorage` 的基本使用示例：

    @AppStorage("isLogin") var isLogin: Bool = false

### 1.2 主要功能

- `@AppStorage` 主用于存储和检索在应用全局范围内使用的数据，例如用户的偏好设置、上次访问时间、访问次数等。
- 通过 UserDefaults， `@AppStorage` 实现了数据的持久存储，确保即便应用关闭后，数据依然得以保存。
- 当 UserDefaults 中的相应值发生更改时， `@AppStorage` 自动更新视图，确保数据与界面保持同步。

### 1.3 注意事项与使用技巧

- UserDefaults 的持久化不是原子级别的，存在数据丢失的风险。因此，不建议使用 `@AppStorage` 来保存关键数据，即那些数据丢失后可能影响应用正常运行的信息。

- 同样也不建议用 `@AppStorage` 来保存敏感数据。

- `@AppStorage` 作为 SwiftUI 对 UserDefaults 的包装，其默认仅支持有限的数据类型。常见的数据类型如日期和数组等默认不被支持。开发者可通过让不支持的数据类型遵循 RawRepresentable 协议，以实现对更多类型的存储。更多信息请参阅： [ @AppStorage 研究 ](/zh/posts/appstorage/) 。

- 应确保保存的数据是轻量级的。不应将较大尺寸的数据存储在 `@AppStorage` 中，否则可能会导致性能下降。

- 除了默认的 `standard` suite， `@AppStorage` 也支持开发者定义的 UserDefaults suite。以下代码展示了如何将数据保存在 App Group 对应的 suite 中：

  public extension UserDefaults {
  static let appGroup = UserDefaults(suiteName: "group.com.fatbobman.myApp")!
  }

  @AppStorage("isLogin",store: .appGroup) var isLogin: Bool = false

- 使用 `defaultAppStorage` 可以为视图设置默认的 UserDefaults suite，从而免去在每个 `@AppStorage` 中重复设置：

  ContentView()
  .defaultAppStorage(.appGroup)

  @AppStorage("isLogin") var isLogin: Bool = false // in ContentView, store in appGroup suit

- 在 `@AppStorage` 中设置的默认值仅适用于其本身，不适用于直接访问 UserDefaults 的方式：

  @AppStorage("count") var count = 100

  // in View
  print(count) // 100
  print(UserDefaults.standard.value(forKey: "count")) // nil

- 使用 UserDefaults 的 `register` 方法设置的默认值可以适用于 `@AppStorage` ：

  struct DefaultValue: View {
  @AppStorage("count") var count = 100
  var body: some View {
  Button("Count") {
  print(count) // 50
  }
  }
  }

  DefaultValue()
  .onAppear {
  UserDefaults.standard.register(defaults: ["count": 50])
  }

- `@AppStorage` 中的键值对的默认值以首次设置的为准：

  @AppStorage("count") var count = 100
  @AppStorage("count") var count1 = 300

  print(count) // 100

- 可以将多个 `@AppStorage` 实例放在遵循 ObservableObject 协议的类中，以便进行统一管理。更多信息请参阅： [ @AppStorage 研究 ](/zh/posts/appstorage/) ：

  class Settings:ObservableObject {
  @AppStorage("count") var count = 100
  @AppStorage("isLogin") var isLogin = false
  }

  @StateObject var settings = Settings()
  Toggle("Login", isOn: $settings.isLogin)

- 与 UserDefaults 类似， `@AppStorage` 的键（Key）是基于字符串的。为了保证一致性和避免在不同视图中由于拼写错误导致的问题，建议采用上统一管理的方式，或者统一定义键。这种做法不仅减少了错误的风险，还使代码更易于维护和理解。

  enum Keys {
  static let count = "count"
  static let isLogin = "isLogin"
  }

  @AppStorage(Keys.count) var count = 0

## 2\. @SceneStorage

`@SceneStorage` 是一个专为场景（Scene）中数据共享而设计的属性包装器，主要适用于支持多场景的设备，例如 iPadOS、macOS 和
visionOS。它能够在每个独立场景中保存特定数据，非常适合用于多窗口或标签页应用，以保持用户界面状态的一致性和持续性。

### 2.1 基本用法

    @SceneStorage("selectedTab") private var selectedTab: Int = 0

### 2.2 主要功能

`@SceneStorage` 主要用于在同一个应用的不同实例或窗口间共享轻量级数据，例如用户在标签页中的选择或滚动视图的位置。

### 2.3 注意事项与使用技巧

- `@SceneStorage` 支持的数据类型与 `@AppStorage` 相同，其类型扩展方法亦如此。

- 与 `@AppStorage` 不同， `@SceneStorage` 不支持统一管理注入方式。

- `@SceneStorage` 是一个专属于 SwiftUI 的独特概念，它并不对应任何已知的底层数据结构。因此， `@SceneStorage` 应仅在视图内部使用，不应在视图外部或视图模型中使用它。

- 每个场景（Scene）之间的 `@SceneStorage` 数据是独立保存的，不会在不同场景间共享。若需跨场景共享数据，应使用 `@AppStorage` 或在应用层面创建的模型。

- `@SceneStorage` 的工作原理与 `@State` 相似，后者用于保存视图的私有状态，而 `@SceneStorage` 用于保存场景的私有状态。在某种意义上， `@SceneStorage` 可被视为场景中视图间共享数据的便捷方式，免去了为每个场景单独注入模型的需求。有关场景的概念及如何为不同场景注入模型的更多信息，请参阅 [ 打造可适配多平台的 SwiftUI 应用 ](/zh/posts/building-multiple-platforms-swiftui-app/#%E6%95%B0%E6%8D%AE%E6%BA%90) 。

- 尽管 `@SceneStorage` 展现了一定的持久化特性，系统并不保证数据保存的具体时间和持久化条件。特别是当场景被显式销毁时（例如，在 iPadOS 上关闭应用的切换器快照，或在 macOS 上关闭应用窗口），相关数据可能会随之丢失。值得注意的是，在实际应用中，即便应用已经被显式销毁，有时重新启动应用后系统可能仍保留最后一个场景的数据。然而，鉴于这种行为的不确定性，不建议将 `@SceneStorage` 作为数据持久化的主要手段。

## 3\. FocusState

`@FocusState` 是 SwiftUI 中用于管理焦点状态的属性包装器。它允许开发者在 SwiftUI 视图中轻松地跟踪和修改焦点状态。

### 3.1 基本用法

基于布尔类型的使用示例：

    @FocusState private var isNameFocused: Bool
    TextField("name:",text:$name)
        .focused($isNameFocused)

基于枚举类型的使用示例：

    enum FocusedField:Hashable{
        case name,password
    }

    @FocusState var focus:FocusedField?
    TextField("name:",text:$name)
        .focused($focus, equals: .name)

> 更多详细的使用方法，可参阅 [ SwiftUI TextField 进阶 —— 事件、焦点、键盘 ](/zh/posts/textfield-
> event-focus-keyboard/) 。

### 3.2 主要功能

- `@FocusState` 主要用于管理和追踪用户界面中的焦点状态。
- 可以通过设置 `@FocusState` 让特定输入字段获取焦点
- 它可以用来感知哪个输入字段或视图元素（ 已进行焦点绑定）当前拥有焦点。
- 通过绑定到视图的某些部分，可以在特定元素获得或失去焦点时执行动作。

### 3.3 注意事项与使用技巧

- 目前，只有 `TextField` 和 `TextEdit` 支持通过代码修改 `@FocusState` 的值来获得或失去焦点。
- 通过 `searchable` 创建的搜索栏无法通过 `@FocusState` 设置或获取焦点状态，对此有需求的开发者可参考 Daniel Saidi 提供的 [ 解决方案 ](https://danielsaidi.com/blog/2023/12/20/quick-search-with-swiftui-searchable) 。
- 在 iOS 17 之前，设置默认焦点需要在 `onAppear` 中进行；iOS 17 及以后的版本允许使用 `defaultFocus` 设置默认焦点，此功能同样适用于 macOS 和 tvOS。
- 在 tvOS 中， `@FocusState` 可以用于判断哪个视图当前获得了焦点。
- 使用 `focusable` 可以使原本不可聚焦的视图变得可聚焦。对于这类视图，只能通过键盘让其获得焦点（无法通过修改 `@FocusState` 直接设置），但可以通过关联 `@FocusState` 来指示其当前获得了焦点。例如：

  struct FocusableDemo: View {
  @FocusState private var isFocused
  var body: some View {
  VStack {
  Rectangle()
  .fill(.red.gradient)
  .overlay(
  Text("\(isFocused ? "focused" : "")").font(.largeTitle)
  )
  .padding()
  .focusable() // 允许聚焦
  .focusEffectDisabled() // 取消默认样式
  .focused($isFocused) // 必须放在 focusable 之后

              Rectangle()
                  .fill(.blue.gradient)
                  .padding()
                  .focusable()
          }
          .padding(50)
      }

  }

- 在使用时应避免焦点绑定的不明确性。在同一视图中，每个焦点绑定应该是明确且唯一的。

## 4\. @GestureState

`@GestureState` 是 SwiftUI
中用于简化手势处理的属性包装器，主要用于临时存储与手势相关的状态。当手势活动结束时，这些状态会自动重置。

### 4.1 基本用法

以下是 `@GestureState` 的基本使用示例（在手势取消后， `isPressed` 会被重置为 `false` ）：

    struct ContentView: View {
        @GestureState var isPressed = false
        var body: some View {
            VStack {
                Rectangle()
                    .fill(.orange).frame(width: 200, height: 200)
                    .gesture(DragGesture(minimumDistance: 0).updating($isPressed) { _, state, _ in
                        state = true
                    })
                    .overlay(
                        Text(isPressed ? "Pressing" : "")
                    )
            }
        }
    }

与此等价的基于 `@State` 的方式：

    struct ContentView: View {
        @State var isPressed = false
        var body: some View {
            VStack {
                Rectangle()
                    .fill(.orange).frame(width: 200, height: 200)
                    .gesture(DragGesture(minimumDistance: 0).onChanged{ _ in
                        isPressed = true
                    }.onEnded{ _ in
                        isPressed = false
                    })
                    .overlay(
                        Text(isPressed ? "Pressing" : "")
                    )
            }
        }
    }

> 阅读 [ 在 SwiftUI 下定制手势 ](/zh/posts/swiftuigesture/) 一文，以了解更多有关 SwiftUI 手势的内容。

### 4.2 主要功能

- `@GestureState` 常用于存储临时的手势数据，如拖拽的位移、旋转的角度等。
- 它会自动管理状态的生命周期，当手势结束时，状态会重置到初始值。
- 使用 `@GestureState` 可以让手势处理代码更加简洁，且易于维护。

### 4.3 注意事项与使用技巧

- `@GestureState` 仅适用于临时的、与手势相关的状态。它不适合用于长期存储或在应用的多个部分之间共享状态。
- 可以通过 `@GestureState` 的构造方法为状态复位设置 `Transaction` ，或根据复位时的状态值设定 `Transaction` 。以下代码演示了只有当横向移动距离超过 200 时才会给复位操作添加动画。更多关于 `Transaction` 的信息，请参阅 [ 掌握 Transaction，实现 SwiftUI 动画的精准控制 ](/zh/posts/mastering-transaction/) 。

  struct ContentView: View {
  @GestureState(wrappedValue: CGSize.zero, reset: { value, transaction in
  if abs(value.width) > 200 {
  transaction.animation = .smooth
  }
  }) var offset
  var body: some View {
  VStack {
  Rectangle()
  .fill(.orange).frame(width: 200, height: 200)
  .offset(x: offset.width, y: offset.height)
  .gesture(DragGesture().updating($offset) { value, state, \_ in
  state = value.translation
  })
  }
  }
  }

- 在 SwiftUI 中，某些系统操作可能会打断 SwiftUI 手势的正常处理流程，导致 `onEnded` 闭包不被执行。使用 `@GestureState` 可以确保即使手势被系统打断，相关状态仍会恢复到初始值。例如，在以下基于 `@State` 的代码示例中，如果用户在拖动过程中执行了系统操作（例如，用另一只手下拉控制中心），会导致 `offset` 无法恢复。而在使用 `@GestureState` 的版本中，状态可以正确地恢复。

  struct ContentView: View {
  @State var offset = CGSize.zero
  var body: some View {
  VStack {
  Rectangle()
  .fill(.orange).frame(width: 200, height: 200)
  .offset(x: offset.width, y: offset.height)
  .gesture(DragGesture().onChanged {
  offset = $0.translation
  }.onEnded { \_ in
  offset = .zero
  })
  }
  }
  }

## 5\. @ScaledMetric

`@ScaledMetric` 是 SwiftUI
中用于处理基于用户设定的文本大小自动缩放度量值的属性包装器。它主要用于适配不同用户的辅助功能需求，特别是那些需要根据系统设置中的字体大小变化来调整布局和元素大小的情况。

### 5.1 基本用法

以下是 `@ScaledMetric` 的基本使用示例：

    struct ContentView: View {
        @ScaledMetric var size: CGFloat = 100

        var body: some View {
            Image(systemName: "person.fill")
                .frame(width: size, height: size)
        }
    }

> 更多具体用例，请参阅 [ 在 SwiftUI 中用 Text 实现图文混排
> ](/zh/posts/mixing_text_and_graphics_with_text_in_swiftui/#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B-%E8%87%AA%E5%8A%A8%E7%BC%A9%E6%94%BE%E5%AD%97%E4%BD%93)
> 。

### 5.2 主要功能

- `@ScaledMetric` 用于根据用户的辅助功能设置（如更大的文本大小）自动调整数值。
- 它能够确保应用界面在不同用户偏好下保持可用性和舒适性。
- `@ScaledMetric` 可以用于调整任何需要根据系统字体大小比例变化的尺寸，如图标大小、布局间距等。

### 5.3 注意事项与使用技巧

- `@ScaledMetric` 的 `relativeTo` 参数允许将数值与特定的文本风格尺寸变化曲线相关联，默认对应 `body` 风格。

  @ScaledMetric(relativeTo: .largeTitle) var height = 17

- 不同的文本风格对动态类型变化的响应曲线不尽相同，因此其对 `@ScaledMetric` 的影响也非线性。

- 使用 `@ScaledMetric` 时需注意，其影响的是尺寸大小而非布局结构。确保应用在不同缩放级别下保持合理的布局和功能性（ 如结合 [ ViewThatFits ](/zh/posts/mastering-viewthatfits/) 、AnyLayout、 [ GeometryReader ](/zh/posts/geometryreader-blessing-or-curse/) 等）。
- `@ScaledMetric` 适用于动态尺寸调整，但需谨慎使用，以避免过度调整导致布局失衡或可读性降低。
- 可以通过 `.dynamicTypeSize` 限制视图的动态类型尺寸变化范围，防止布局异常。

## 总结

每种属性包装器都有其独特的适用场景和注意事项。 `@AppStorage` 适用于全局数据的轻量级持久化; `@SceneStorage`
专注于场景间状态共享； `@FocusState` 简化了焦点管理； `@GestureState` 自动化手势状态的生命周期； `@ScaledMetric` 实现了尺寸的自动缩放。

正确使用这些属性包装器可以让 SwiftUI 代码更加简洁高效。与直接使用底层 API 相比, 属性包装器抽象了许多细节,
开发者可以更加关注业务逻辑。当然, 还需要谨记它们的使用限制, 避免滥用。

未来，我们会对其他尚未介绍的属性包装器进行更多的探讨。

# 在 SwiftUI 中用 Text 实现图文混排

SwiftUI 提供了强大的布局能力，不过这些布局操作都是在视图之间进行的。当我们想在 Text
中进行图文混排时，需要采用与视图布局不同的思路与操作方式。本文将首先介绍一些与 Text 有关的知识，并通过一个实际案例，为大家梳理出在 SwiftUI
中用 Text 实现图文混排的思路。

## 一个和一组

在 SwiftUI 中，Text 是使用频率最高的几个组件之一，几乎所有的文字显示操作均由其完成。随着 SwiftUI 版本的不断提升，Text
的功能也得到持续地增强。除了基本的文本内容外，还提供了对 AttributedString、Image（ 有限度 ）、Fomatter 等类型的支持。

如果 Text 视图无法在给定的建议宽度内显示全部的内容，在建议高度允许的情况下（ 没有限制高度或显示行数 ），Text
会对内容进行换行处理，通过多行显示的方式保证内容的完整性。上述特性有一个基本要求 —— 换行操作是在单一 Text
视图中进行的。在下面的代码中，尽管我们通过布局容器视图将 Text 横向排列到一起，但 SwiftUI 仍会将它们视作多个 Text 视图（ 一组
），对每个 Text 分别进行换行操作：

    struct TempView:View{
        let str = "道可道，非常道；名可名，非常名。"
        var body: some View{
            HStack{
                Text(str)
                Text(str)
                Text(str)
            }
            .padding()
        }
    }

![image-20220814083426515](https://cdn.fatbobman.com/image-20220814083426515.png)

SwiftUI 提供了两种方式用以将多个 Text 转换成一个 Text：

- 通过 LocalizedStringKey 插值的方式

  HStack{
  let a = Text(str)
  let b = Text(str)
  let c = Text(str)
  Text("\(a) \(b) \(c)")
  }

![image-20220814084617352](https://cdn.fatbobman.com/image-20220814084617352.png)

我们不仅可以通过插值的方式添加 Text ，还可以添加 Image、Date 等众多类型。王巍在 [ SwiftUI 中的 Text 插值和本地化
](https://onevcat.com/2021/03/swiftui-text-1/) 一文中对此做了详尽的介绍。

> 请注意：从第二个 Text 插值元素开始，必须在插值符号 `\(` 前添加一个空格，否则会出现显示异常。尝试将上面的代码 `Text("\(a)
\(b) \(c)")` 改成 `Text("\(a)\(b)\(c)")` 即可复现该错误。从 iOS 16 开始，本错误已经被修复。

- 使用加法运算符

  HStack{
  let a = Text(str)
  let b = Text(str)
  let c = Text(str)
  a + b + c
  }

加法运算仅可以在 Text 类型之间进行。这意味着，当我们对部分 Text 进行配置时，只能使用不改变 Text 类型的修饰器（
该原则同样适用于通过插值方式进行的合并 ），例如：

    HStack{
        let a = Text(str)
            .foregroundColor(.red) // Text 专用版本，不改变 Text 类型
            .underline() // 不改变 Text 类型
    //      .background(Color.yellow) // background 是针对 View 协议的修饰器，会改变 Text 的类型，无法使用
        let b = Text(str)
            .foregroundColor(.blue)
            .font(.title)
        let c = Text(str)
            .foregroundColor(.green)
            .bold()
        a + b + c
    }

![image-20220814090556878](https://cdn.fatbobman.com/image-20220814090556878-0439158.png)

如果你经常有组成复杂文本的需求，可以创建一个结果构造器来简化该过程：

    @resultBuilder
    enum TextBuilder {
        static func buildBlock(_ components: Text...) -> Text {
            components.reduce(Text(""),+)
        }
    }

使用该构造器，我们可以更加清晰、快捷地合成复杂文本：

    @TextBuilder
    func textBuilder() -> Text {
        Text(str)
            .foregroundColor(.red)
            .underline()
        Text(str)
            .foregroundColor(.blue)
            .font(.title)
        Text(str)
            .foregroundColor(.green)
            .bold()
    }

> 可以阅读 [ 掌握 Result builders ](/zh/posts/viewbuilder1/) 一文，了解更多有关结构构造器方面的内容

## 在 Text 中使用 SF Symbols

[ SF Symbols ](https://developer.apple.com/sf-symbols/)
是苹果为开发者带来的一份厚礼，让开发者可以在苹果生态中近乎免费地使用由专业设计师创建的海量图标。截至 2022 年，SF Symbols 已经拥有了超过
4000 个符号，每个符号均拥有九种重量和三种比例，并可自动与文本标签对齐。

在 SwiftUI 中，我们需要通过 Image 来显示 SF Symbols，并可使用一些修饰器来对其进行设置：

    Image(systemName: "ladybug")
        .symbolRenderingMode(.multicolor) // 指定渲染模式，Image 专用修饰器 ，Image 类型不发生改变
        .symbolVariant(.fill) // 设置变体 ，该修饰器适用于 View 协议，Image 类型发生了改变
        .font(.largeTitle) // 适用于 View 的修饰器，非 Text 专用版本

![image-20220814103141010](https://cdn.fatbobman.com/image-20220814103141010.png)

SF Symbols 提供了与苹果平台的系统字体 San Francisco 无缝集成的能力，Text
会在排版过程中将其视为普通文本而统一处理。上文中介绍的两种方法均适用于将 SF Symbols 添加到 Text 中：

    let bug = Image(systemName: "ladybug.fill") // 由于 symbolVariant 会改变 Image 的类型，因此我们采用直接在名称中添加变体的方式来保持类型的稳定
        .symbolRenderingMode(.multicolor) // 指定渲染模式，Image 专用修饰器 ，Image 类型不发生改变
    let bugText = Text(bug)
        .font(.largeTitle) // Text 专用版本，Text 类型不发生变化

    // 通过插值的方式
    Text("Hello \(bug)") // 在插值中使用 Image 类型，由于 font 会改变 Image 的类型，因此无法单独修改 bug 的大小

    Text("Hello \(bugText)") // 在插值中使用 Text，font（ Text 专用修饰器 ）不会改变 Text 类型，因此可以单独调整 bug 的大小

    // 使用加法运算符
    Text("Hello ") + bugText

![image-20220814104652581](https://cdn.fatbobman.com/image-20220814104652581.png)

可以说，在 Text 中，可以直接使用 Image 类型这个功能主要就是为 SF Symbols 而提供的。在可能的情况下，通过 Text + SF
Symbols 的组合来实现图文混排是最佳的解决方案。

    struct SymbolInTextView: View {
        @State private var value: Double = 0
        private let message = Image(systemName: "message.badge.filled.fill") // 􁋭
            .renderingMode(.original)
        private let wifi = Image(systemName: "wifi") // 􀙇
        private var animatableWifi: Image {
            Image(systemName: "wifi", variableValue: value)
        }

        var body: some View {
            VStack(spacing:50) {
                VStack {
                    Text(message).font(.title) + Text("文字与 SF Symbols 混排。\(wifi) Text 会将插值图片视作文字的一部分。") + Text(animatableWifi).foregroundColor(.blue)
                }
            }
            .task(changeVariableValue)
            .frame(width:300)
        }

        @Sendable
        func changeVariableValue() async {
            while !Task.isCancelled {
                if value >= 1 { value = 0 }
                try? await Task.sleep(nanoseconds: 1000000000)
                value += 0.25
            }
        }
    }

![sfsymbols_In_Text_2022-08-14_10.53.10.2022-08-14
10_53_54](https://cdn.fatbobman.com/sfsymbols_In_Text_2022-08-14_10.53.10.2022-08-14%2010_53_54.gif)

尽管我们可以使用 SF Symbols 应用程序来修改或创建自定义符号，但由于受颜色、比例等方面的限制，在相当多的场合中， SF Symbols
仍无法满足需求。此时，我们需要使用真正的 Image 来进行图文混排工作。

    VStack {
        let logo = Image("logo")  // logo 是一个 80 x 28 尺寸的图片，默认情况下，title 的高度为 28

        Text("欢迎访问 \(logo) ！")
            .font(.title)

        Text("欢迎访问 \(logo) ！")
            .font(.body)
    }

![image-20220814155725538](https://cdn.fatbobman.com/image-20220814155725538.png)

当在 Text 中使用真正的 Image （ 非 SF Symbols ）时，Text 只能以图片的原始尺寸进行渲染（ SVG、PDF 以标注尺寸为准 ），
**图片的尺寸并不会随字体尺寸大小的变化而变化** 。

另一方面，由于 Image（ 非 SF Symbols ）的 textBaseline 在默认情况下是与其 bottom 一致的，这导致在与 Text
中其他的文字进行混排时，图片与文字会由于基准线的不同而发生上下错位的情况。我们可以通过使用 Text 专属版本的 baselineOffset
修饰器对其进行调整。

    let logo = Text(Image("logo")).baselineOffset(-3) // Text 版本的修饰器，不会改变 Text 类型，使用 alignmentGuide 进行修改会更改类型

    Text("欢迎访问 \(logo) ！")
        .font(.title)

![image-20220814160547051](https://cdn.fatbobman.com/image-20220814160547051.png)

> 有关 baseline 对齐线方面的内容，请阅读 [ SwiftUI 布局 —— 对齐 ](/zh/posts/layout-alignment/)
> 一文

再次强调，我们只能使用不会改变 Text 或 Image 类型的修饰器。例如
frame、scaleEffect、scaleToFit、alignmentGuide 之类会改变类型状态的修饰器将导致无法进行 Text
插值以及加法运算操作！

如此一来， **为了能让视图与文字完美地进行匹配，我们需要为不同尺寸的文字准备不同尺寸的视图** 。

## 动态类型（ 自动缩放字体 ）

苹果一直很努力地改善其生态的用户体验，考虑到用户与显示器的距离、视力、运动与否，以及环境照明条件等因素，苹果为用户提供了动态类型功能来提高内容的可读性。

动态类型（ Dynamic Type
）功能允许使用者在设备端设置屏幕上显示的文本内容的大小。它可以帮助那些需要较大文本以提高可读性的用户，还能满足那些可以阅读较小文字的人，让更多信息出现在屏幕上。支持动态类型的应用程序也会为使用者提供一个更一致的阅读体验。

用户可以在控制中心或通过【设置】—【辅助功能】—【显示与文字大小】—【更大字体】来更改单个或全部应用程序的文字显示大小。

![DynamicType](https://cdn.fatbobman.com/DynamicType.png)

从 Xcode 14 开始，开发者可以在预览中快速检查视图在不同动态类型下的表现。

    Text("欢迎访问 \(logo) ！")
        .font(.title)  // title 在不同动态模式下，显示的尺寸不同。

![image-20220814173320321](https://cdn.fatbobman.com/image-20220814173320321-0469602.png)

在 SwiftUI 中，除非进行了特别的设置，否则所有字体的尺寸都会跟随动态类型的变化而变化。从上图中可以看出， **动态类型仅对文本有效，Text
中的图片尺寸并不会发生改变** 。

在使用 Text
实现图文混排时，如果图片不能伴随文本的尺寸变化而变化，就会出现上图中的结果。因此，我们必须通过某种手段让图片的尺寸也能自动适应动态类型的改变。

使用 SwiftUI 提供的 @ScaledMetric 属性包装器，可以创建能够跟随动态类型自动缩放的数值。relativeTo
参数可以让数值与特定的文本风格的尺寸变化曲线相关联。

    @ScaledMetric(relativeTo: .body) var imageSize = 17

> 不同的文本风格（ Text Style ）用以响应动态类型变化的尺寸数值曲线并不相同，详情请阅读苹果的 [ 设计文档
>
> > ](https://developer.apple.com/design/human-interface-
> > guidelines/foundations/typography/#specifications)

    struct TempView: View {
        @ScaledMetric(relativeTo:.body) var height = 17 // body 的默认高度
        var body: some View {
            VStack {
                Image("logo")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(height:height)

                Text("欢迎访问！")
                    .font(.body)
            }
            .padding()
        }
    }

上面的代码，通过 ScaledMetric 将图片的高度与 .body 文本风格的尺寸进行了关联，当动态类型发生改变时，图片的尺寸也会随之做出调整。

![image-20220814181138809](https://cdn.fatbobman.com/image-20220814181138809.png)

遗憾的是，由于 frame 会更改 Image 的类型，因此我们无法将通过 frame 动态更改尺寸后的图片嵌入到 Text
中，以实现可动态调整尺寸的图文混排。

使用 `.dynamicTypeSize(DynamicTypeSize.xSmall...DynamicTypeSize.xxxLarge)`
可以让视图只在指定的动态类型范围内发生变化。

使用 `.font(custom(_ name: String, size: CGFloat))`
设置的自定义尺寸的字体也会在动态类型变化时自动调整尺寸。

使用 `.font(custom(_ name: String, size: CGFloat, relativeTo textStyle:
Font.TextStyle))` 可以让自定义尺寸的字体与某个预设文本风格的动态类型尺寸变化曲线相关联。

使用 `.font(custom(_ name: String, fixedSize: CGFloat))`
将让自定义尺寸字体忽略动态类型的变化，尺寸始终不发生改变。

## 一个有关图文混排的问题

前几天在 [ 聊天室 ](https://discord.gg/ApqXmy5pQJ) 中，一个朋友询问 SwiftUI 是否能实现下图中 tag（
超市标签 ）+ 商品介绍的版式效果。我直接回复没有问题，但直到考虑具体实现时才发现，情况没有那么简单。

![image-20220815082801108](https://cdn.fatbobman.com/image-20220815082801108.png)

- 标签采用了圆角背景，意味着基于 [ AttributedString ](/zh/posts/attributedstring/) 的解决方案被排除
- 标签特定的尺寸与内容，意味着基于自定义 SF Symbols 的解决方案被排除
- 通过在 Text 中添加 Image 进行图文混排，需要考虑如何处理动态类型变化的问题（ 不可能预生成如此多尺寸的图片 ）
- 是否可以不通过预制标签图片的方式（ 用动态视图 ）来解决当前问题

下文中，我将提供三种解决思路和对应代码，利用不同的方式来实现当前的需求。

> 限于篇幅，下文中将不会对范例代码做详尽的讲解，建议你结合本文附带的 [ 范例代码
> ](https://github.com/fatbobman/BlogCodes/tree/main/InlineImageWithText)
> 一并阅读接下来的内容。从 Xcode 运行范例代码，动态创建的图片可能并不会立即显示出来（ 这是 Xcode 的问题
> ）。直接从模拟器或实机上再次运行将不会出现上述延迟现象。

## 方案一：在 Text 中直接使用图片

### 方案一的解决思路

既然为不同的动态类型提供不同尺寸的图片可以满足 Text 图文混排的需求，那么方案一就以此为基础，根据动态类型的变化自动对给定的预制图片进行等比例缩放即可。

- 从应用程序或网络上获取标签图片
- 当动态类型变化时，将图片缩放至与关联的文本风格尺寸一致

  VStack(alignment: .leading, spacing: 50) {
  TitleWithImage(title: "佳农 马来西亚冷冻 猫山王浏览果肉 D197", fontStyle: .body, tagName: "JD_Tag")

              TitleWithImage(title: "佳农 马来西亚冷冻 猫山王浏览果肉 D197", fontStyle: .body, tagName: "JD_Tag")
                  .environment(\.sizeCategory, .extraExtraExtraLarge)
          }

![image-20220815112324138](https://cdn.fatbobman.com/image-20220815112324138.png)

### 方案一的注意事项

- 为了保证图片缩放后的质量，范例中采用了 SVG 格式
- 鉴于 SwiftUI 提供的图片缩放 modifier 均会改变类型，缩放操作将使用 UIGraphicsImageRenderer 针对 UIImage 进行

  extension UIImage {
  func resized(to size: CGSize) -> UIImage {
  return UIGraphicsImageRenderer(size: size).image { \_ in
  draw(in: CGRect(origin: .zero, size: size))
  }
  }
  }

- 由于使用了 `UIFont.preferredFont` 获取 Text Style 的尺寸，因此 Text Style 参数采用了 UIFont. TextStyle 类型。
- 让 Image 的初始高度与给定的 Text Style 一致，并通过使用 @ScaledMetric 让两者的尺寸变化保持同步

  let uiFont = UIFont.preferredFont(forTextStyle: fontStyle)
  pointSize = uiFont.pointSize
  textStyle = Font.TextStyle.convert(from: fontStyle)
  \_fontSize = ScaledMetric(wrappedValue: pointSize, relativeTo: textStyle)

- 使用 `.font(.custom("", size: pointSize, relativeTo: textStyle))` 设置字体尺寸，并与给定的 Text Style 进行关联
- 正确使用 task 修饰器，以确保尺寸缩放操作在后台线程进行，减少对主线程的影响

  @Sendable
  func resizeImage() async {
  if var image = UIImage(named: tagName) {
  let aspectRatio = image.size.width / image.size.height
  let newSize = CGSize(width: aspectRatio \* fontSize, height: fontSize)
  image = image.resized(to: newSize)
  tagImage = Image(uiImage: image)
  }
  }

  .task(id: fontSize, resizeImage)

- 通过 baselineOffset 修改图片的文本基线。偏移值应该根据不同的动态类型进行微调（ 本人偷懒，范例代码中使用了固定值 ）

### 方案一的优缺点

- 方案简单，实现容易

- 由于图片需要预制，因此不适合标签种类多，且经常变动的场景

- 在无法使用矢量图片的情况下，为了保证缩放后的效果，需要提供分辨率较高的原始图片，这样会造成更多的系统负担

## 方案二：在 Text 上使用覆盖视图

### 方案二的解决思路

- 不使用预制图片，通过 SwiftUI 视图创建标签
- 根据标签视图的尺寸创建空白占位图片
- 在 Text 中添加占位图片，进行混排
- 使用 overlay 将标签视图定位在 leadingTop 位置，覆盖于占位图片上

  TitleWithOverlay(title: "佳农 马来西亚冷冻 猫山王浏览果肉 D197", tag: "京东超市", fontStyle: .body)

  TitleWithOverlay(title: "佳农 马来西亚冷冻 猫山王浏览果肉 D197", tag: "京东超市", fontStyle: .body)
  .environment(\.sizeCategory, .extraExtraExtraLarge)

![image-20220815134505932](https://cdn.fatbobman.com/image-20220815134505932.png)

### 方案二的注意事项

- 使用 `fixedSize` 禁止标签视图自行响应动态类型。标签视图 TagView 中的文字尺寸完全由 TitleWithOverlay 控制

  Text(tag)
  .font(.custom("", fixedSize: fontSize))

- 使用 `alignmentGuide` 微调标签视图的位置，使其与 Text 的文字对齐。与方案一类似，offset、padding、fontSize 等最好根据动态类型进行微调（ 作者偷懒，没有微调。不过最终效果还可以接受 ）

  TagView(tag: tag, textStyle: textStyle, fontSize: fontSize - 6, horizontalPadding: 5.5, verticalPadding: 2)
  .alignmentGuide(.top, computeValue: { $0[.top] - fontSize / 18 })

- 当 fontSize （ 动态类型下当前的文本尺寸 ）发生变化时，更新标签视图尺寸

  Color.clear
  .task(id:fontSize) { // 使用 task(id:)
  tagSize = proxy.size
  }

- 当标签视图尺寸 tagSize 发生变化时，重新创建占位图片

  .task(id: tagSize, createPlaceHolder)

- 正确使用 task 修饰器，以确保创建占位图片的操作在后台线程进行，减少对主线程的影响

  extension UIImage {
  @Sendable
  static func solidImageGenerator(\_ color: UIColor, size: CGSize) async -> UIImage {
  let format = UIGraphicsImageRendererFormat()
  let image = UIGraphicsImageRenderer(size: size, format: format).image { rendererContext in
  color.setFill()
  rendererContext.fill(CGRect(origin: .zero, size: size))
  }
  return image
  }
  }

  @Sendable
  func createPlaceHolder() async {
  let size = CGSize(width: tagSize.width, height: 1) // 仅需横向占位，高度够用就行
  let uiImage = await UIImage.solidImageGenerator(.clear, size: size)
  let image = Image(uiImage: uiImage)
  placeHolder = Text(image)
  }

### 方案二的优缺点

- 无须预制图片
- 标签的内容、复杂度等不再受限
- 仅适用于当前的特殊案例（ 标签在左上角 ），一旦改变标签的位置，此方案将不再有效（ 其他位置很难在 overlay 中对齐 ）

## 方案三：将视图转换成图片，插入 Text 中

### 方案三的解决思路

- 与方案二一样，不使用预制图片，使用 SwiftUI 视图创建标签
- 将标签视图转换成图片添加到 Text 中进行混排

  TitleWithDynamicImage(title: "佳农 马来西亚冷冻 猫山王浏览果肉 D197", tag: "京东超市", fontStyle: .body)

  TitleWithDynamicImage(title: "佳农 马来西亚冷冻 猫山王浏览果肉 D197", tag: "京东超市", fontStyle: .body)
  .environment(\.sizeCategory, .extraExtraExtraLarge)

![image-20220815141821917](https://cdn.fatbobman.com/image-20220815141821917.png)

### 方案三的注意事项

- 确保在后台进程中进行视图转换成图片的操作

  @Sendable
  func createImage() async {
  let tagView = TagView(tag: tag, textStyle: textStyle, fontSize: fontSize - 6, horizontalPadding: 5.5, verticalPadding: 2)
  tagView.generateSnapshot(snapshot: $tagImage)
  }

- 转换图片的过程中需设置正确的 scale 值，以保证图片的品质

  func generateSnapshot(snapshot: Binding<Image>) {
  Task {
  let renderer = await ImageRenderer(content: self)
  await MainActor.run {
  renderer.scale = UIScreen.main.scale // 设置正确的 scale 值
  }
  if let image = await renderer.uiImage {
  snapshot.wrappedValue = Image(uiImage: image)
  }
  }
  }

### 方案三的优缺点

- 无须预制图片
- 标签的内容、复杂度等不再受限
- 无须限制标签的位置，可以将其放置在 Text 中的任意位置
- 由于范例代码中采用了 SwiftUI 4 提供的 ImageRenderer 完成视图至图片的转换，因此仅支持 iOS 16+

> 在低版本的 SwiftUI 中，可以通过用 UIHostingController 包裹视图的方式，在 UIKit 下完成图片的转换操作。但由于
> UIHostingController 仅能运行于主线程，因此这种转换操作对主线程的影响较大，请自行取舍

## 总结

在读完本文后，或许你的第一感受是 SwiftUI
好笨呀，竟然需要如此多的操作才能完成这种简单的需求。但能用现有的方法来解决这类实际问题，何尝又不是一种挑战和乐趣？至少对我如此。

# 掌握 Core Data Stack

或许觉得比较枯燥，亦或许感觉 Xcode 提供的模版已经满足了使用的需要，很多 Core Data 的使用者并不愿意在 Core Data Stack
的了解和掌握上花费太多的精力。这不仅限制了他们充分使用 Core Data 提供的丰富功能，同时也让开发者在面对异常错误时无所适从。本文将对 Core
Data Stack 的功能、组成、配置等做以说明，并结合个人的使用经验聊一下如何设计一个符合当下需求的 Core Data
Stack。本文并不会展示一个完整的创建代码，更多是原理、思路和经验的阐述。

## 什么是 Core Data Stack

### 功能

在使用 Core Data 的应用程序中，将管理并持久化应用的模型层视为 Core Data Stack。在 Core Data Stack
中，通过创建并配置 Core Data 提供的一组相互配合的类的实例来为应用程序提供对象图管理、数据持久化等服务。

Core Data Stack 对其实例的命名、类型没有具体的要求，你可以根据自己的习惯和需求使用结构、类来创建、组织自己的代码。

### 组成

一个最基本的 Core Data Stack 至少要由以下四个类的实例构成：

- NSManagedObjectModel（托管对象模型）
- NSManagedObjectContext（托管对象上下文）
- NSPersistentStoreCoordinator（持久化存储协调器）
- NSPersistentStore（持久化存储）

下面这张图表说明了它们之间的关系：

![coreDataStack](https://cdn.fatbobman.com/coreDataStack.svg)

#### NSManagedObjectModel

每个 Core Data Stack 都要有一个 NSManagedObjectModel（托管对象模型）实例，可以将其看作是实际数据模型的程序呈现。

通常我们会使用 Xcode 提供的数据模型编辑器来创建数据蓝图，并在其中定义应用程序使用的
Entity（实体）、Attributes（属性）、RelationShip（关系）、Configurations 等。

数据模型编辑器将定义的结果保存成 XML 格式的文件，Xcode 会在编译项目时将该文件编译成尾缀为 momd 的二进制文件并放置在 Bundle
中，在创建 NSManagedObjectModel 实例时，实际使用的即为该文件。

#### NSManagedObjectContext

NSManagedObjectContext（托管对象上下文）可以将其看作一个类似绘图的刮擦板，我们可以在其中任意绘画，并随时清除。

托管对象上下文的主要职责是管理
NSManagedObject（托管对象）实例的集合，对托管对象的获取、创建、删除、修改等操作绝大多数都是在此进行。托管对象上下文内置撤销管理器，提供了
Undo/Redo 的功能。

托管对象上下文将确保一个上下文中不会出现多个托管对象实例对应同一个持久存储记录的情况，并提供了其它诸如缓存、更改跟踪、惰性加载、数据验证、变更通知等功能。

它位于 Core Data Stack 的顶部，在应用程序与 Core Data Stack 之间承担着主要的交互职责。

应用程序通常至少需要创建一个运行于主线程的托管对象上下文实例。实际使用中创建多个托管对象上下文的情况并不少见。

#### NSPersistentStore

NSPersistentStore（持久化存储）是所有 Core Data 持久存储的抽象基类，通过指定存储类型（SQLite、Binary、XML 和
Memory）创建不同的实例。持久化存储提供了一种标准的 API，将 Core Data 的内部数据对象、逻辑、操作转换成对应存储类型的指令或记录。

如果 Core Data 预置的四种存储类型不能满足你的需要，开发者也可以为自己的数据源定制所需的持久化存储。

在几年前，多数应用只需创建一个持久化存储。随着 Core Data with CloudKit 的不断普及，拥有多个持久化存储的应用越来越多。

#### NSPersistentStoreCoordinator

NSPersistentStoreCoordinator（持久化存储协调器）在 Core Data Stack
中起到了胶水的作用。作为协调器，它为其它组件之间创建了沟通的桥梁。无论是托管对象模型、托管对象上下文、或者持久化存储都以持久化存储协调器为核心进行协作。

处于效率的考虑，数据批量处理、CoreData with CoreSpotlight、数据库迁移等应用场合通常都需要开发者直接和其打交道。

如上图所示，一个持久化存储协调器只对应一个托管对象模型，但可以与多个托管对象上下文和多个持久化存储配合使用。

> 看到这里，应该会有不少读者认为本文有了一个巨大的遗漏——NSPersistentContainer。作为近几年最常用的创建 Core Data
> Stack 的手段，截至目前还没有做介绍。NSPersistentContainer
> 创建的初衷即为简化上述模组的配置复杂度，在其内部仍以上面四个组件为主。下文中，将以 NSPersistentContainer
> 的诞生为分界线，分别介绍在其出现前后的 Core Data Stack 的创建过程，让读者对 Core Data Stack
> 的发展进程和实现原理有更多的了解。

## 没有 NSPersistentContainer 的时代

在 NSPersistentContainer 诞生之前（Xcode 8 以前），我们通常会采用如下的流程通过上述的四大组件来创建 Core Data
Stack。

- 实例化一个托管对象模型

要创建一个 NSManagedObjectModel 的实例，需要从应用程序包中加载数据模型文件。大致的代码如下：

      guard let url = Bundle.main.url(forResource: "Model", withExtension: "momd") else {fatalError()}
      guard let model = NSManagedObjectModel(contentsOf: url) else {fatalError()}

- 实例化持久化存储协调器

创建持久化存储协调器需要使用托管对象模型实例，只有掌握了应用程序的数据模型后，协调器才能添加持久化存储。

    let coordinator = NSPersistentStoreCoordinator(managedObjectModel: model)

- 创建持久化存储

创建持久化存储时，需要指定存储类型、配置名称（在数据模型编辑器中设置）、路径等信息。对于已经存在的数据库文件，持久化存储协调器将检查它是否同托管对象模型的定义完全一致。

            guard let store = try? coordinator.addPersistentStore(type: .sqlite,
                                                                  configuration: "Local",
                                                                  at: localURL,
                                                                  options: nil)
            else {
                fatalError()
            }

- 创建托管对象上下文并保留对托管对象的引用

创建托管对象上下文，设置其类型（主线程或后台线程），并保留持久化存储协调器的引用

            let viewContext = NSManagedObjectContext(.mainQueue)
            viewContext.persistentStoreCoordinator = coordinator

> 如果单纯从代码量上来看，即使不使用 NSPersistentContainer，创建一个具有基本功能的 Core Data Stack
> 也用不了几行代码。但此种创建方式要求开发者对 Core Data 的几大组件要有充分的认识和掌握才能完成。NSPersistentContainer
> 正是为了降低开发者创建 Core Data Stack 的门槛而诞生的。

## NSPersistentContainer 开启的新时代

### Xcode 8. x —— Xcode 10. x

自 Xcode 8.0 开始，苹果为 Core Data 推出了 NSPersistentContainer（持久化容器）。

NSPersistentContainer 将托管对象模型、持久化存储协调器、托管对象上下文以及持久化存储都封装到了一起，简化了 Core Data
Stack 的创建和管理。

可以将一个 NSPersistentContainer 的实例视为一个简化版本的 Core Data Stack，Xcode
中提供的模版可以应对大多数的场景下对 Core Data Stack 的需求。

下面便是 Xcode 13 中提供的 Core Data 模版的部分代码。

    struct PersistenceController {
        static let shared = PersistenceController()

        let container: NSPersistentContainer

        init(inMemory: Bool = false) {
            container = NSPersistentContainer(name: "Model")
            if inMemory {
                container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: "/dev/null")
            }
            container.loadPersistentStores(completionHandler: { _, error in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
        }
    }

无需任何托管对象模型、持久化存储协调器以及持久化存储的知识，开发者便可以创建 Core Data Stack。

NSPersistentContainer 一方面极大地降低了 Core Data 的使用门槛，同时也造成了很多新的 Core Data 使用者对 Core
Data 的内部运作原理不明而无法深入使用 Core Data 的局面。

直到 Xcode 11 NSPersistentCloudContainer 推出之前，NSPersistentContainer 的作用仅限于简化
Core Data Stack 创建，本身并没有提供什么新的功能。

### Xcode 11. x —— 至今

从 Xcode 11 开始，苹果推出了 NSPersistentCloudContainer，将 Core Data 同 CloudKit
两者之间的壁垒打通。至此，NSPersistentContainer 逐渐开始拥有了自己独有的功能，并愈发地重要起来。

NSPersistentCloudContainer 是 NSPersistentContainer 的子类，它在简化传统 Core Data Stack
创建的基础上，提供了对于 CloudKit 网络数据库的支持。目前多数同网络数据库有关的方法和属性都只能在
NSPersistentCloudContainer 中进行操作。由于苹果没有公开 NSPersistentCloudContainer
的内部细节，导致目前针对 Core Data 的第三方 Stack 封装库仅能支持本地存储（无法使用 Core Data with CloudKit
的功能）。

## 当下的 Core Data Stack 中都有些什么内容

近年来，随着 Core Data 的功能不断增强，Core Data Stack 中包含的内容也越来越多。即便使用了
NSPersistentContainer，代码也不可避免的重新复杂起来。

### Core Data with CloudKit

作为苹果生态优势的集中体现，越来越多应用程序都提供了基于 Core Data with CloudKit 的网络同步功能，为此就需要在 Core Data
Stack 中为网络同步进行更多的设定和扩展。

> 更多关于 NSPersistentCloudContainer 的信息，请参阅我关于 [ Core Data with CloudKit
> ](/zh/tags/CloudKit/) 的系列文章。

除了在 Core Data Stack 中使用 Core Data 框架提供的网络同步方法和属性外，很多开发者都会在 Core Data Stack
的层面创建适合项目应用的方法。例如，苹果在关于 [ 数据共享的例程
](https://developer.apple.com/documentation/coredata/synchronizing_a_local_store_to_the_cloud)
中，为共享参与者、创建 CKShare、获取 CKShare、数据权限判定等方面在 Core Data Stack 上创建了不少便捷方法。

### Persistent History Tracking

近年来，在苹果的大力推广下，越来越多的应用程序提供了 Widget（桌面部件），或通过 App Group 方式让多个应用程序共享相同的数据内容。

对于使用 Core Data 的应用来说，为 Core Data 启用 Persistent History
Tracking（持久化历史跟踪）功能可以让用户获得更好的使用体验。另外，苹果的一些新 API 也要求必须在开启持久化历史跟踪的情况下方可使用。

因此，Core Data Stack 中又新增了对于 Persistent History Tracking 的设定和事务处理功能需要。

> 更多关于 Persistent History Tracking 的内容，请参阅我的文章 [ 在 CoreData 中使用持久化历史跟踪
> ](/zh/posts/persistenthistorytracking/) 。

### CoreData with CoreSpotlight

在 WWDC 2021 上，苹果推出了新版的 NSCoreDataCoreSpotlightDelegate API。该 API 极大地降低了在系统
Spotlight 上维护应用程序中的 Core Data 数据的难度。由于创建 NSCoreDataCoreSpotlightDelegate 需要使用
NSPersistentStoreDescription 和 NSPersistentStoreCoordinator ，因此同样需要在 Core Data
Stack 中来完成这些工作。Core Data Stack 的内容和功能也将进一步增多。

> 更多关于 NSCoreDataCoreSpotlightDelegate 的内容，请参阅我的文章 [ 在 Spotlight 中展示应用中的 Core
> Data 数据 ](/zh/posts/spotlight/) 。

## 该暴露 Context 还是 Container

几年前的 Core Data Stack，对外通常只需要提供一个 NSManagedObjectContext
的实例即可。通过该实例，我们可以获取到持久化存储协调器，通过协调器可以获取到托管对象模型以及持久化存储。

但在使用了 NSPersistentContainer 之后（尤其是
NSPersistentCloudContainer），开发者无法通过托管对象上下文获得到对应的持久化容器，从而无法调用持久化容器特有的属性和方法。

因此，在目前的 Core Data Stack 中最好也能将持久化容器暴露给其它的模块或代码以方便使用。

## 使用结构还是类

目前 Xcode 提供的 Core Data 模版使用结构来定义 Core Data Stack。以我个人的使用经验来看，如果你的 Core Data
Stack 的功能需求较多，代码较复杂，类或许是更好的选择。原因有二：

- 在一个应用程序中通常只需要一个 Core Data Stack 实例，使用类的单例将给我更好的安全感，也方便在代码不同的地方对 Stack 进行访问。
- 如果你需要在 Core Data Stack 中处理持久化历史跟踪的事务通知或者调用 NSCoreDataCoreSpotlightDelegate 的话，使用类更方便编程。具体可参阅我之前提供的两篇文章。

## 为 Core Data Stack 创建多个配置模式

### 为什么要创建多个配置

如今创建一个 Core Data Stack 除了需要保证程序的正常运行功能所需外，最好同时为 Unit Test，SwiftUI 的 Preview
等场景做以准备。通过 Core Data Stack 构造函数的参数或应用程序的启动参数，为 Core Data Stack 创建应对不同场景的多个配置。

### 内存模式

在 Xcode 提供的 Core Data 模版中，已经为开发者提供了内存模式的配置和如何在内存模式下创建测试数据的演示。

需要注意的是，此处所说的内存模式对应的存储类型仍为 SQLite（并非 NSPersistentStore
支持的四种存储模式之一的内存模式），通过将持久化存储的存储路径设置为 `/dev/null` ，从而达到只在内存中保存数据的效果。

使用参数来设定内存模式：

        /// 是否开启仅内存模式。可以通过启动参数 -InMemory 1 或 构造函数的参数 inMemory:true 开启
        private let _inMemory: Bool
        private lazy var inMemory: Bool = {
            let arguments = ProcessInfo.processInfo.arguments
            var allow = false
            for index in 0..<arguments.count - 1 where arguments[index] == "-InMemory" {
                allow = arguments.count >= (index + 1) ? arguments[index + 1] == "1" : false
                break
            }
            return allow || _inMemory
        }()

在 Xcode 的模版中，内存模式同非内存模式是无法共存的，这在绝大多数的情况下都是合理的。

在开发中的 [ 健康笔记 3 ](/healthnotes/)
里，我需要让内存模式同非内存模式共存，也就是在特定的情况下，应用程序中同时会存在两个使用同样托管对象模型的
Container，并可随时切换。为了应对同一个托管对象模型文件只能在应用中被一个实例所持有的问题，可以通过创建一个
NSManagedObjectModel 实例，然后分别用该实例来创建 NSPersistentCloudContainer 的方式予以解决。

    class CoreDataStack {
        private static var _model: NSManagedObjectModel?
        static func model(name: String = CoreDataStackSetting.defaultModelName) -> NSManagedObjectModel {

            if _model == nil {
                do {
                    _model = try loadModel(name: name, bundle: Bundle.main)
                } catch {
                    let err = error.localizedDescription
                    fatalError("❌数据库 momd 文件无法加载")
                }
            }

            return _model!
        }

        private static func loadModel(name: String, bundle: Bundle) throws -> NSManagedObjectModel {
            guard let modelURL = bundle.url(forResource: name, withExtension: "momd") else {
                fatalError("❌数据库 momd 文件无法加载")
            }
            guard let model = NSManagedObjectModel(contentsOf: modelURL) else {
                fatalError("❌数据库 momd 文件无法解析")
            }
            return model
        }

        public lazy var persistentContainer: NSPersistentCloudKitContainer = {
            let container = NSPersistentCloudKitContainer(
                name: modelName,
                managedObjectModel: Self.model(name: modelName)
            )
            // 其它配置代码
            ........
        }
    }

### 无需网络同步的模式

在使用 Core Data with CloudKit
的应用中，我们无需在每次代码调试时都启用网络同步功能。通过参数关闭网络同步，简化调试流程，减少因网络同步产生的大量控制台输出。

使用参数设置网络同步：

       /// 是否允许网络同步，可以使用构造器参数 allowCloudKiteSync = false 或 启动参数-AllowCloudKitSync 0 来禁止网络同步
        private let _allowCloudKitSync: Bool
        private lazy var allowCloudKitSync: Bool = {
            let arguments = ProcessInfo.processInfo.arguments
            var allow = true
            for index in 0..<arguments.count - 1 where arguments[index] == "-AllowCloudKitSync" {
                allow = arguments.count >= (index + 1) ? arguments[index + 1] == "1" : true
                break
            }
            return allow && _allowCloudKitSync
        }()

关闭网络同步：

            if !allowCloudKitSync {
                privateDescrition.cloudKitContainerOptions = nil
                shareDescription.cloudKitContainerOptions = nil
            }

只需要将对应的 NSPersistentStoreDescription 实例中的 cloudKitContainerOptions 设置为 nil 即可。

需要注意的是，如果你在代码中启用了 Persistent History Tracking，在关闭网络同步的时候仍需保持其开启。

### 测试模式

为了在 Unit Test 测试中不损害原有的 SQLite 数据库文件内容，我通常会创建一个测试模式。该模式下数据仍将被持久化，但会将其保存在用户的
caches 目录中，并在每次测试前对其进行清空处理。

        /// 是否为测试模式，用于在 Unit Test，在此模式下，本地存储将保存在 Catch 目录中
        private let _testMode: Bool
        private lazy var testMode: Bool = {
            let arguments = ProcessInfo.processInfo.arguments
            var allow = false
            for index in 0..<arguments.count - 1 where arguments[index] == "-TestMode" {
                allow = arguments.count >= (index + 1) ? arguments[index + 1] == "1" : false
                break
            }
            return allow || _testMode
        }()

         if !testMode {
                    privateDescrition = NSPersistentStoreDescription(url: groupStoreURL)
         } else {
                // 保存在 catch 目录中
                privateDescrition = NSPersistentStoreDescription(url: privateStoreTestURL)
         }

> 根据自己的需要为 Core Data Stack 创建适合的模式，并通过单例的方式进行引用

    public extension CoreDataStack {
        /// 正常 App 使用的 Stack
        static let shared = CoreDataStack(modelName: "Model")

        /// 只保存在内存的预览 Stack
        static let previewInMemory = CoreDataStack(modelName: "Model", inMemory: true)

        /// 保存在本地存储的预览 Stack
        static let previewInPersistentStore = CoreDataStack(modelName: "Model", allowCloudKitSync: false)

        /// Unit Test 模式
        static let testMode = CoreDataStack(modelName: "Model",testMode: true)
    }

![image-20211101202616881](https://cdn.fatbobman.com/image-20211101202616881.png)

## 总结

Core Data Stack 近年来逐渐走过了由难至简，由小至大的历程创建真实的代码并多做练习将有助于对其更好地了解和掌握。

# iBug 16 有感

> 由于在 SwiftUI 4 中，Lazy 容器的表现出现了与以往较大的差异，因此已完成大半的《使用 Lazy
> 容器的注意事项》一文将暂时搁置，待情况稳定时再更新

到 2022 年，SwiftUI 已经迈入了第四个年头。尽管在之前的版本更新过程中，SwiftUI 也出现了或多或少的问题，但从来也没有像 SwiftUI
4 这么严重。Bug 众多的现象不仅仅表现在 SwiftUI 上，在 iOS、macOS 以及苹果很多其他的产品上都有所体现。

这绝非苹果独有的问题，整个社会目前都处在一种浮躁的发展轨迹中。求快、求变、求成效体现在方方面面，无论是企业还是个人。

不管消费者是否有购买新品的计划，每当新品诞生时，网络上充斥最多的声音就是“挤牙膏”。这反过来也会影响了企业的经营思路，为了迎合市场，企业会不断地推出新型号，为了变而变，为了不同而不同。

不过，消费者对变化的无限渴望也是由企业的各种措施导致的。当企业痴迷于为产品每年推出新的版本号，用订阅制取代买断制，让消费者在第一时间有感（ 而不是有用
）成了首要目标。

OTA 这种本来用于某些特定领域的更新手段，被作为思想运用于经营、设计、制造等等领域，令人震惊。不出 Bug、少出 Bug 已变成奢望，高速迭代变成了主流
—— 在迭代中修复 Bug ，在迭代中创造 Bug。

> 自我安慰一下：SwiftUI 4 中出现了大量不可思议的 Bug，例如视图无法持久、task 无法触发、闭包代码无法更新视图（ 某些 Style 下
> ）等情况。一方面表明，苹果的开发管理出现了明显的问题，另一方面，也间接地证明了 SwiftUI 4
> 重写了大量的底层代码，待这些代码稳定后，可能会有不错的结果（ 也许是更多的 Bug ）

我们真的需要走得这么快吗？

![stay_away_from_bugs_lie_down_together](https://cdn.fatbobman.com/stay_away_from_bugs_lie_down_together-4176048.jpeg)

# 如何在 Core Data 中对 NSManagedObject 进行深拷贝

对 NSMangedObject 进行深拷贝的含义是 **为一个
NSManagedObject（托管对象）创建一个可控的副本，副本中包含该托管对象所有关系层级中涉及的所有数据** 。

尽管 Core Data
是一个功能强大的对象图管理框架，但本身并没有直接提供托管对象的复制方法。如果开发者想创建某个托管对象的副本，唯一可行的途径就是编写一段特定的代码，将原始对象中属性的内容逐个读出并赋值给新对象。此种方式在托管对象结构简单时比较有效，一旦托管对象结构复杂、关系繁多，代码量将显著增大，且极易出错。

多年来开发者一直在寻找一种便捷且通用的工具来解决深拷贝的问题，不过直到现在并没有一个被广泛认可的方案。

我在开发 [ 健康笔记 ](/healthnotes/)
新版本时也碰到了这个问题，需要深拷贝一个结构复杂、关系链牵涉大量数据的托管对象。考虑到以后可能还会遇到类似的情况，我决定编写一段使用简单、适用性广的代码方便自己使用。

本文中将探讨在 Core Data 中对 NSManagedObject 进行深拷贝的技术难点、解决思路，并介绍我写的工具—— [ MOCloner
](https://github.com/fatbobman/MOCloner) 。

## 对 NSManagedObject 进行深拷贝的难点

### 复杂的关系结构

下图是 [ 健康笔记 ](/healthnotes/) 的数据模型图节选。尽管只选取了模型关系的一部分，但实体之间几乎涵盖了所有的关系类型，包含了 one-
to-one、one-to-many、many-to-many 等形式。

每当复制一个 Note 对象，同时会涉及关系链条中数百上千个其它对象。实现对所有数据的快速、准确地深拷贝具有相当挑战性。

![image-20211112143836634](https://cdn.fatbobman.com/image-20211112143836634.png)

### 选择性拷贝

当进行深拷贝时，有时我们并不需要复制所有关系层级中的全部数据，可能会想在第 n 个层级忽略某个 n+1 级的关系分支。

或者在复制托管对象某个属性（可选或设有默认值）时，选择性的不复制其内容。

以上工作都最好能在深拷贝时一并处理。

### 数据有效性

托管对中某些属性具有唯一性或即时性，在深拷贝中需特别处理。

例如：

- 上图中 Note 的 id 的类型为 UUID，在深拷贝时不应复制原来的内容而应该为新对象创建新的数据
- Item 中的 NoteID 应该对应的是 Note 的 id，如何在复制过程中保持一致
- ItemDate 的 createDate 应该是记录创建的时间，如何将其设置为深拷贝时的日期

如果无法在深拷贝时一并处理类似的问题，在数据量大的情况下，拷贝后调整将比较吃力。

### 逆向对多关系

上图中 Tag 同 Memo 之间是多对多（many-to-many）关系。当在一个关系链条上出现了逆向对多（Tag）的情况时，需特别谨慎处理。Tag
从业务逻辑上并不属于某个 Note 的具体分支，如何处理此种情况一直都是 Core Data 数据同步时的一个难题。

## 深拷贝的解决思路

尽管需要面对的问题不少，但仍旧可以利用 Core Data 提供的众多手段予以解决。

### 善用 Description

在 Xcode 中使用 Data Model Editor 创建的数据模型，会在编译时转换成 momd 文件并保存在 Bundle 中。在创建
NSPersistentContainer 时，NSManagedObjectModel 将通过该文件将模型定义转换为程序实现。代码通过访问 Core
Data 提供的各种 Description 可以获取到所需信息。

开发者最常接触的 Description 可能就是 NSPersistentStoreDescription 了，从中可以获取 Config 或者设置
iCloud options（更多资料请参阅 [ 掌握 Core Data Stack
](/zh/posts/masteringofcoredatastack/) ）。

其它的的 Description 还包括但不限于：

- NSEntityDescription

实体描述

- NSRelationshipDescription

实体关系的描述

- NSAttributeDescription

实体 Attribute 的描述

- NSFetchIndexDescription

索引 Index 的描述

- NSDerivedAttributeDescription

派生属性的描述

下面的代码将用给定托管对象的 NSEntityDescription，创建一个结构相同的新对象：

    guard let context = originalObject.managedObjectContext else {
        throw CloneNSManagedObjectError.contextError
    }

    // create clone NSManagedObject
    guard let entityName = originalObject.entity.name else {
        throw CloneNSManagedObjectError.entityNameError
    }
    let cloneObject = NSEntityDescription.insertNewObject(
        forEntityName: entityName,
        into: context
    )

通过 NSAttributeDescription，获取托管对象的所有属性描述：

    let attributes = originalObject.entity.attributesByName
    for (attributeName, attributeDescription) in attributes {
        ...
    }

通过 NSRelationshipDescription，遍历托管对象的所有关系描述：

    let relationships = originalObject.entity.relationshipsByName

    for (relationshipName, relationshipDescription) in relationships {
        ...
    }

获取逆向关系描述对应的实体：

    let inverseEntity = relationshipDescription.inverseRelationship?.entity

这些 Description 是开发 NSManagedObject 深拷贝通用代码的基石。

### 使用 userinfo 传递信息

为解决上文中提到的选择性拷贝、数据有效性等问题，需要在深拷贝时给代码提供足够的信息。

由于这些信息可能分布在整个关系链的各个层级中，最直接、有效的方式是在 Xcode 的数据模型编辑器提供的 User Info 中添加对应的内容。

![image-20211112163510728](https://cdn.fatbobman.com/image-20211112163510728.png)

每个使用过 Xcode 数据模型编辑器的开发者应该都看到过右侧的 User Info 输入框。通过该输入框，我们可以为
Entity、Attribute、Relationship 设置想要传递的信息，并从对应的 Description 中提取出来。

下面的代码将判断 Attribute 的 userinfo 中是否有排除标志：

    if let userInfo = attributeDescription.userInfo {
        // Check if the "exclude" flag is added to this attribute
        // Only detemine whether the Key is "exclude" or note, do not care about the Vlaue
        if userInfo[config.exclude] != nil {
            if attributeDescription.isOptional || attributeDescription.defaultValue != nil {
                continue
            } else {
                throw CloneNSManagedObjectError.attributeExcludeError
            }
        }
    }

下面的代码将对 userinfo 中包含有 rebuild : uuid 标志的 Attribute（类型为 UUID），创建新的 UUID：

    if let action = userInfo[config.rebuild] as? String {
                        switch action {
                        case "uuid":
                            if attributeDescription.attributeType == NSAttributeType.UUIDAttributeType {
                                newValue = UUID()
                            } else {
                                throw CloneNSManagedObjectError.uuidTypeError
                            }
                        ...
                        default:
                            break
                        }
                    }

### setPrimitiveValue 和 setValue

在 Core Data 开发中，会在不少场合使用 setPrimitiveValue 。比如在 awakeFromInsert 中为属性设置初始值，在
willSave 中用检查属性值的有效性等等。尤其当我们无法直接调用托管对象实例属性时，使用 setPrimitiveValue 可以方便的利用
AttributeName 来设置 Value。

    for (attributeName, attributeDescription) in attributes {
        var newValue = originalObject.primitiveValue(forKey: attributeName)
        cloneObject.setPrimitiveValue(newValue, forKey: attributeName)
    }

由于 setPrimitiveValue 直接访问托管对象的原始值（跳过快照），因而效率更高，同时不触发 KVO 观察。

setPrimitiveValue 也有其缺点——不会自动处理逆向关系。使用它来设置关系内容，需要在关系的两侧都进行对应的工作，代码量将显著提高。

对于托管对象实例，多数情况下通常会直接采用 Core Data 生成的关系管理方法来进行关系操作，例如：

    @objc(addItemsObject:)
    @NSManaged public func addToItems(_ value: Item)

    @objc(removeItemsObject:)
    @NSManaged public func removeFromItems(_ value: Item)

    @objc(addItems:)
    @NSManaged public func addToItems(_ values: NSSet)

    @objc(removeItems:)
    @NSManaged public func removeFromItems(_ values: NSSet)
    // Note 和 Item 是 one-to-many 的关系
    let note = Note(context: viewContext)
    let item = Item(context: viewContext)
    note.addToItems(item)
    item.note = note

在通用型的深拷贝代码中，我们无法直接使用这些系统预置的方法，但可以通过 setValue 来设置关系数据。

setValue 将在内部查找对应的 Setter 来完成双向关系的管理工作。

下面是设置 to-one 关系的代码：

    if !relationshipDescription.isToMany,
       let originalToOneObject = originalObject.primitiveValue(forKey: relationshipName) as? NSManagedObject {
        let newToOneObject = try cloneNSMangedObject(
            originalToOneObject,
            parentObject: originalObject,
            parentCloneObject: cloneObject,
            excludedRelationshipNames: passingExclusionList ? excludedRelationshipNames : [],
            saveBeforeReturn: false,
            root: false,
            config: config
        )
        cloneObject.setValue(newToOneObject, forKey: relationshipName)
    }

### NSSet 和 NSOrderedSet

在 Core Data 中，对多关系在生成的 NSMangedObject Subclass 代码中对应的类型是 NSSet?
，但如果将对多关系设置为有序时，对应的类型将变成 NSOrderedSet? 。

![image-20211112184857192](https://cdn.fatbobman.com/image-20211112184857192.png)

通过判断 NSRelationshipDescription 的 isOrdered ，选择正确的对应类型。例如：

    if relationshipDescription.isOrdered {
        if let originalToManyObjects = (originalObject.primitiveValue(forKey: relationshipName) as? NSOrderedSet) {
            for needToCloneObject in originalToManyObjects {
                if let object = needToCloneObject as? NSManagedObject {
                    let newObject = try cloneNSMangedObject(
                        object,
                        parentObject: originalObject,
                        parentCloneObject: cloneObject,
                        excludedRelationshipNames: passingExclusionList ? excludedRelationshipNames : [],
                        saveBeforeReturn: false,
                        root: false,
                        config: config
                    )
                    newToManyObjects.append(newObject)
                }
            }
        }
    }

### 逆向关系对多的处理逻辑

沿着关系链向下，如果某个关系的逆向关系为对多，则无论正关系是对一还是对多，在深拷贝时都会形成一个尴尬的局面——逆向关系为对多的实体，服务于全部的正向关系树。

例如，前文图中的 Memo 和 Tag，一个备注可以对应多个标签，同时一个标签也可以对应多个备注。当我们从 Note 向下深拷贝到 Memo 时，如果继续对
Tag 进行复制，则会和 Tag 的设计初衷相违背。

解决方案为，当在关系链中碰到了逆向关系为对多的实体 A，则不再继续向下拷贝。而是将新拷贝的托管对象添加到与 A 的关系中，满足数据模型的设计意图。

![image-20211112192815648](https://cdn.fatbobman.com/image-20211112192815648.png)

    if let inverseRelDesc = relationshipDescription.inverseRelationship, inverseRelDesc.isToMany {
        let relationshipObjects = originalObject.primitiveValue(forKey: relationshipName)
        cloneObject.setValue(relationshipObjects, forKey: relationshipName)
    }

## 用 MOCloner 进行深拷贝

综合上面的思路，我写了一个用于在 Core Data 中对 NSManagedObject 进行深拷贝的库 —— [ MOCloner
](https://github.com/fatbobman/MOCloner)

### MOCloner 说明

MOCloner 是一个很小的库，旨在实现对 NSManagedObject 的可定制深拷贝。支持 one-to-one、one-to-many、many-
to-many 关系方式。除了忠于原始数据的拷贝方式外，还提供了选择性拷贝、拷贝时生成新值等功能。

### 基础演示

创建上图中 Note 的深拷贝

    let cloneNote = try! MOCloner().clone(object: note) as! Note

从关系链中间部分向下深拷贝（不拷贝关系链向上的部分）

    // 在 excludedRelationshipNames 中添加忽略的关系名称
    let cloneItem = try! MOCloner().clone(object: item, excludedRelationshipNames: ["note"]) as! Item

### 自定义

MOCloner 采用在 Xcode 的 Data Model Editor 中对 User Info
添加键值的方式对深拷贝过程进行定制。目前支持如下命令：

- exclude

该键可以设置在 Attribute 或 Relationship 中。只要出现 exclude 键，无论任何值都将启用排除逻辑。

设置在 Attribute 的 userinfo 时，深拷贝将不复制原始对象属性的值（要求 Attribute 为 Optional 或已经设置了
Default value）。

设置在 Relationship 的 userinfo 时，深拷贝将忽略此关系分支下的所有关系和数据。

为了方便某些不适合在 userinfo 中设置的情况（比如从关系链中间进行深拷贝），也可以将需要排除的关系名称添加到
excludedRelationshipNames 参数中（如基础演示 2）。

![image-20211112200648882](https://cdn.fatbobman.com/image-20211112200648882.png)

- rebuild

用于在深拷贝时动态生成新的数据。仅用于设置 Attribute。目前支持两个 value : uuid 和 now。

uuid：类型为 UUID 的 Attribute，在深拷贝时为该属性创建新的 UUID

now：类型为 Date 的 Attribute，在深拷贝时为该属性创建新的当前日期（Date. now）

![image-20211112201348978](https://cdn.fatbobman.com/image-20211112201348978.png)

- followParent

简化版的 Derived。仅用于设置 Attribute。可以指定关系链下层 Entity 的 Attribute 获取上层关系链对应的托管对象实例的指定
Attribute 值（要求两个 Attribute 类型一致）。下图中，Item 的 noteID 将获得 Note 的 id 值。

![image-20211112205856380](https://cdn.fatbobman.com/image-20211112205856380.png)

- withoutParent

仅搭配 followParent 使用。处理当从关系链中部进行深拷贝时，设置了 followParent 但无法获取 ParentObject 的情况。

当 withoutParent 为 keep 时，将保持被复制对象的原值

当 withoutParent 为 blank 时，将不对其设置值（要求该 Attribute 为 Optional 或设有 Default value）

![image-20211112210330127](https://cdn.fatbobman.com/image-20211112210330127.png)

如果以上 userinfo 的键名称与你的项目中已经使用的键名称冲突，可以通过自定义 MOClonerUserInfoKeyConfig 重新设置。

    let moConfig = MOCloner.MOClonerUserInfoKeyConfig(
        rebuild: "newRebuild", // new Key Name
        followParent: "followParent",
        withoutParent: "withoutParent",
        exclude: "exclude"
    )

    let cloneNote = try cloner.clone(object: note,config: moConfig) as! Note

### 系统需求

MOCloner 最低需求为 macOS 10.13、iOS 11、tvOS 11、watchOS 4 以上的系统。

### 安装

MOCloner 使用 Swift Package Manager 分发。要在另一个 Swift 包中使用它，请在你的 Package. swift
中将其作为一个依赖项添加。

    let package = Package(
        ...
        dependencies: [
            .package(url: "https://github.com/fatbobman/MOCloner.git", from: "0.1.0")
        ],
        ...
    )

如果想在应用程序中使用 MOCloner，请使用 Xcode 的 File > Add Packages… 将其添加到你的项目中。

    import MOCloner

鉴于 MOCloner 只有几百行代码，可以将代码拷贝到你的项目中直接使用。

## 使用 MOCloner 的注意事项

### 在私有上下文中进行

当深拷贝涉及到大量数据时，请在私有上下文中进行操作，避免占用主线程。

最好在深拷贝操作前后使用 NSManagedObjectID 进行数据传递。

### 内存占用

当深拷贝的托管对象牵涉大量的关系数据时，则可能会形成大量的内存占用。在包含二进制类型数据时会尤为明显（比如将大量图片数据保存在 SQLite
中）。可以考虑使用如下的方式控制内存的占用情况：

- 在深拷贝时，将内存占用较高的属性或关系暂时排除。深拷贝后，通过其它的代码再为其逐个添加。
- 深拷贝多个托管对象时，考虑通过 performBackgroundTask 逐个进行。

## 版本与支持

MOCloner 采用 [ MIT ](https://github.com/fatbobman/MOCloner/blob/main/LICENSE)
协议，你可以自由地在项目中使用它。但请注意，MOCloner 不附带任何官方支持渠道。

Core Data 提供了丰富的功能和选项，开发者可以使用它创建大量不同组合的关系图。MOCloner 只对其中的部分情况做了测试。因此，在开始准备将
MOCloner 用于你的项目之前，强烈建议你花点时间熟悉其实现，并做更多的单元测试，以防遇到任何可能出现的数据错误问题。

如果你发现问题、错误，或者想提出改进建议，请创建 [ Issues
](https://github.com/fatbobman/MOCloner/issues) 或 [ Pull Request
](https://github.com/fatbobman/MOCloner/pulls) 。

## 总结

对 NSManagedObject 进行深拷贝并非是一个常见的功能需求。但当有了可以轻松完成的解决手段时，或许可以在你的 Core Data
项目中尝试一些新的设计思路。

# 健康笔记 2.0 开发随笔（六）

收尾工作往往是最枯燥的。

最近这 10 几天，主要的工作都是查找 bug，改进性能，反复测试数据的稳定性，以及更加枯燥的文档准备工作。

向 app store 提交反倒异常顺利，中间只出现了一次反复。苹果要我确认是否会滥用用户的数据，在明确回复不会之后就通过了。想想去年底健康笔记 1.0
的上线反复折腾了我 10 多天。

XCode 12 中的 StoreKit 对于调试应用内的购买实在是太方便了，在开发的最后阶段，我将 app
分成了基础版和专业版。基础版其实已经能应对生活中绝大多数的需求了。通过 StoreKit
的模拟环境，我的应用内购买没有使用任何沙盒测试便一次性的开发调试成功，并且上线后也运行正常。极大的提高了效率！

在本次历时近两个月的开发过程中，基本上没走太多弯路。真正让我消耗精力的反倒是和 iOS 14 以及 SwiftUI 2.0 中的 Bug
斗智斗勇。很多奇怪的问题，在对自己代码反复的检查之后才能基本确认是系统的原因，然后还需要设法用最少的代码重现问题得以最终确认。从 WWDC 20
过后，目前已经给苹果提交了 10 几条的 Feedback。其中超过半数在不断的版本升级后得到了修复。

下面是我在这次的开发中使用的第三方库，我最近会对这些库进行详细的介绍：

- SwiftUIX
- Charts
- Introspect
- ZIPFoundation
- SwiftUIOverlayContainer
- SwiftDate
- MarkdownView

iPad 的适配工作量也比想象中的大。尽管 SwiftUI 己经提供了极大的方便，但如果想更好的利用 iPad 的特性的话，还是有不少工作需要完成的。

本地化也是这次开发的一个目标，难度不太大，但工作量不小。

# 用 Async-Await 重建 SwiftUI 的 Redux-like 状态容器

经过两年多的时间，SwiftUI 发展到当前的 3.0 版本，无论 SwiftUI 的功能还是 Swift 语言本身在这段时间里都有了巨大的提升。是时候使用
Async/Await 来重构我的的状态容器代码了。

## SwiftUI 的状态容器

我是从王巍的 [ SwiftUI 与 Combine 编程 ](https://objccn.io/products/) 一书中，第一次接触到 `Single souce of truth` 式的编程思想。整体来说，同 Redux 的逻辑基本一致：

- 将 App 当做状态机，UI 是 App 状态（State）的具体呈现。
- State（值类型）被保存在一个 Store 对象当中，为了在视图中注入方便，Store 需符合 `ObservableObject` 协议，且为 State 设置 `@Published` 属性包装，保证 State 的任何变化都将被及时响应。
- View 不能直接修改 State，只能通过发送 Action 间接改变 Store 中的 State 内容
- Store 中的 Reducer 负责处理收到的 Action，并按照 Action 的要求变更 State

![Redux1](https://cdn.fatbobman.com/Redux1.png)

通常，对 State、Store 和 Action 的定义如下：

    struct AppState {
        var name: String = ""
        var age:Int = 10
    }

    enum AppAction {
        case setName(name:String)
        case setAge(age:Int)
    }

    final class Store: ObservableObject {
        @Published private(set) var state: AppState

        func dispatch(action:Action) {
            reducer(action)
        }

        func reducer(action)
    }

Reducer 在处理 Action 时，经常会面对带有副作用（side effect）的情况，比如：

- 需从网络查询获得数据后，根据数据修改 State
- 修改 State 后，需要向磁盘或数据库写入数据等

我们无法控制副作用的执行时间（有长有短），并且副作用还可能会通过 Action 继续来改变 State。

对状态（State）的修改必须在主线程上进行，否则视图不会正常刷新。

我们构建的状态容器（Store）需要满足处理上述情况的能力。

## 1.0 版本

在编写 [ 健康笔记 1.0 ](/healthnotes/) 时，我采用了 [ SwiftUI 与 Combine 编程
](https://objccn.io/products/) 一书中提出的解决方式。

对于副作用采用从 Reducer 中返回 Command 的方式来处理。Command 采用异步操作，将返回结果通过 Combine 回传给 Store。

    struct LoginAppCommand: AppCommand {
      //...
      func execute(in store: Store) {
        //...
        .sink(
          receiveCompletion: { complete in
            if case .failure(let error) = complete {
              store.dispatch(
                .accountBehaviorDone(result: .failure(error))
              )
            }
          },
          receiveValue: { user in
            store.dispatch(
              .accountBehaviorDone(result: .success(user))
            )
          }
        )
      }
    }





    func reduce(
      state: AppState,
      action: AppAction
    ) -> (AppState, AppCommand?)
    {
      // ...
      case .accountBehaviorDone(let result):
        // 1
        appState.settings.loginRequesting = false
        switch result {
        case .success(let user):
          // 2
          appState.settings.loginUser = user
        case .failure(let error):
          // 3
          print("Error: \(error)")
        }
      }

      return (appState, appCommand)
    }

采用了如下的方式保证了 State 只能在主线程上进行修改：

        func dispatch(_ action: AppAction) {
            let result = reduce(state: appState, action: action)
            if Thread.isMainThread {
                state = result.0
            } else {
                DispatchQueue.main.async { [weak self] in
                    self?.state = result.0
                }
            }
            if let command = result.1 {
                command.execute(in: self)
            }
        }

作者自己在书中也说上述代码属于试验性质，因此尽管完全胜任 Store 的工作，但是从逻辑组织上还是比较复杂，尤其对于每个 Command 的处理十分的繁琐。

## 2.0 版本

通过阅读、学习 Majid 的文章 [ Redux-like state container in SwiftUI
](https://swiftwithmajid.com/2019/09/18/redux-like-state-container-in-
swiftui/) ，在 [ 健康笔记 ](/healthnotes/) 2.0 中，我重构了 Store 的代码。

Majid 的实现方式最大的提升在于，大大简化了副作用代码的复杂度，将原本需要在副作用中处理的 Publisher 生命周期管理集中到了 Store
中。并且使用 Combine 提供的线程调度，保证了只在主线程上修改 State。

        func dispatch(_ action: AppAction) {
            let effect = reduce(&state, action, environment)

            var didComplete = false
            let uuid = UUID()

            let cancellable = effect
                .receive(on: DispatchQueue.main)
                .sink(
                    receiveCompletion: { [weak self] _ in
                        didComplete = true
                        self?.effectCancellables[uuid] = nil
                    },
                    receiveValue: { [weak self] in self?.send($0) }
                )
            if !didComplete {
                effectCancellables[uuid] = cancellable
            }
        }

Reducer

        private let reduce: Reducer<AppState, AppAction, AppEnvironment> = Reducer { state, action, environment in
            switch action {
            case .editMemo(let memo, let newMemoViewModel):
                return environment.dataHandler.editMemo(memo: memo, newMemoViewModel: newMemoViewModel)

            case .setSelection(let selection):
                state.selection = selection
            }
         return Empty(completeImmediately: true)
                .eraseToAnyPublisher()
        }

副作用代码

    func editNote(note: Note, newNoteViewModel: NoteViewModel) -> AnyPublisher<AppAction, Never> {
            _ = _updateNote(note, newNoteViewModel)
            if !_coreDataSave() {
                logDebug("更新 Note 出现错误")
            }
            return Just(AppAction.none).eraseToAnyPublisher()
        }

## 3.0 版本

无论 1.0 版本还是 2.0 版本，都可以很好的完成我们对状态容器功能的要求。

两个版本都严重依赖 Combine，都是采用 Combine 来进行异步代码的生命周期管理，并且在 2.0 中又是通过 Combine 提供的 `.receive(on: DispatchQueue.main)` 来进行的线程调度。

幸好，Combine 很好的完成了这个本来并非它最擅长（管理生命周期，线程调度）的工作。

今年，Swift 5.5 推出了大家期待已久的 Async/Await 功能，在对新功能有了一定的了解后，我便有了用 Async/Await
来实现新的状态容器的想法。

- 使用@MainActore 保证 State 只能在主线程被修改
- dispatch 创建即发即弃的 Task 完成副作用生命周期管理
- 同 2.0 版本类似，在副作用方法中返回 `Task<AppAction,Error>` ，简化副作用代码

具体的实现：

    @MainActor
    final class Store: ObservableObject {
        @Published private(set) var state = AppState()
        private let environment = Environment()

        @discardableResult
        func dispatch(_ action: AppAction) -> Task<Void, Never>? {
            Task {
                if let task = reducer(state: &state, action: action, environment: environment) {
                    do {
                        let action = try await task.value
                        dispatch(action)
                    } catch {
                        print(error)
                    }
                }
            }
        }
    }

Reducer：

    extension Store {
        func reducer(state: inout AppState, action: AppAction, environment: Environment) -> Task<AppAction, Error>? {
            switch action {
            case .empty:
                break
            case .setAge(let age):
                state.age = age
                return Task {
                    await environment.setAge(age: 100)
                }
            case .setName(let name):
                state.name = name
                return Task {
                    await environment.setName(name: name)
                }
            }
            return nil
        }
    }

副作用：

    final class Environment {
        func setAge(age: Int) async -> AppAction {
            print("set age")
            return .empty
        }

        func setName(name: String) async -> AppAction {
            print("set Name")
            await Task.sleep(2 * 1000000000)
            return AppAction.setAge(age: Int.random(in: 0...100))
        }
    }

由于 Store 声明为@MainActor，我们在代码中须通过如下两种方式之一来引用：

    @main
    struct NewReduxTest3AppApp: App {
        @StateObject var store = Store()
        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environmentObject(store)
            }
        }
    }

或者

    @main
    @MainActor
    struct NewReduxTest3AppApp: App {
        let store = Store()
        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environmentObject(store)
            }
        }
    }

新版本的代码不仅易读性更好，而且可以充分享受到 Swift 5.5 带来的安全、高效的线程调度能力。

## 总结

通过此次重建状态容器，让我对 Swift 的 Async/Await 有了更多的了解，也认识到它在现代编程中的重要性。

# 与 AI 结对编程

在过去的两周时间里，在 AI
的辅助下，我在一个不熟悉的开发环境中使用陌生的语言和框架启动了博客的重建工作。通过这次重建过程，我希望能够对新的语言和框架有一定的掌握。本文记录了我与 AI
一起工作的一些体会。

> 维基百科：
>
> **结对编程** （Pair
> programming）是一种敏捷软件开发的方法，两个程序员在一个计算机上共同工作。一个人输入代码，而另一个人审查他输入的每一行代码。输入代码的人称作
> **驾驶员** ，审查代码的人称作 **观察员** （或 **导航员** ）。两个程序员经常互换角色。
>
> 在结对编程中，观察员同时考虑工作的战略性方向，提出改进的意见，或将来可能出现的问题以便处理。这样使得驾驶者可以集中全部注意力在完成当前任务的“战术”方面。观察员当作安全网和指南。结对编程对开发程序有很多好处。比如增加纪律性，写出更好的代码等。

## 契机

我计划从明年开始，在我的博客上同步发布文章的中英文版本（目前英文版本发布在 [ Medium
](https://fatbobman.medium.com/) ）。同时，我也打算更新博客的外观设计。为此，我决定对博客进行一次全面重构。

这次重构不仅仅是为了改变外观，更是一个挑战自我、学习新技术的机会。我选择使用一种全新的编程语言，目标是在完成重构的同时，深入理解这种新语言和框架，以及之前不太熟悉的开发环境。

在以往的项目中，我虽然使用过一些 AI 服务，但更多的是试水而非深度体验。因此，这次重构成了一个绝佳的契机，让我深入感受在 AI
的紧密配合下的工作效果及其优缺点。

为了确保 AI 在此次重构中扮演关键角色，我设定了以下规则：

- 在获取信息方面，传统搜索引擎的使用比例不得超过 20%。
- 不向其他开发者求助。

换言之，AI 将成为我在这次开发和学习过程中的主要信息来源、合作伙伴和助手。这种合作，在某种意义上，类似于一场与 AI 的“结对编程”，其中 AI
还担任着老师的角色。

在这次“结对编程”中，我使用了 GitHub Copilot、ChatGPT、Claude 和 Warp（AI
助手）等服务，将它们视为这次编程旅程中的关键伙伴。

## 与 AI 的合作之旅

### 选择技术栈

在选择技术栈的这一阶段，我主要依赖于 ChatGPT 和
Claude。通过向它们详细阐述我的技术背景和具体需求，在多轮交流后逐渐明确了我所需的开发语言、框架和编辑器。

与 AI 的对话既自由又发散。每当 AI 提出建议或提示后，我都会就其中某些特定方向或细节进行更加深入的探讨，并定期总结我的理解，向 AI
进行再次确认。与几个月前相比，GPT-4 和 Claude 2
不再仅仅迎合提问者，它们会及时且礼貌地指出我的理解中的错误，有效避免了我在错误的道路上越走越远。最终，我选择了
TypeScript、Astro、TailWindCSS 以及 VSCode 这一组合，用于博客的重构。

AI 在这个阶段为我提供了极大的帮助，提高了我获取有效信息的效率，并帮助我迅速做出决策。能取得这样的效果，应该归结于以下原因：

- **明确的需求** ：我的需求既明确又普通，易于 AI 理解，这简化了整个沟通过程。
- **成熟的技术选择** ：我选择的技术栈由成熟的项目构成，它们在互联网上拥有活跃的社区和丰富的文档，这些信息为 AI 提供了可靠的语义资源，确保了 AI 对这些技术的深入了解。
- **结合个人经验** ：凭借我在其他开发语言上的经验，我在讨论中使用了自己熟悉的语言、框架和开发环境作为参考，以帮助 AI 更好地理解我的需求。这也使我更容易理解 AI 提供的建议。
- **多 AI 平台的互补** ：在此阶段，我同时在 ChatGPT 和 Claude 上进行讨论。尽管在大多数情况下，两者回答的信息内容区别不大，但偶尔还是会出现一些不同的回答方向，这就相当于多了一个人在讨论。
- **人的判断力不可或缺** ：尽管与传统搜索相比，AI 提供的资料量已经减少了，但是，如果使用者的分析能力不足、决策不果断，仍然会迟迟无法做出选择。这在与生成式 AI 进行讨论时经常会遇到的情况。使用者必须具备较强的分析和决断能力，否则过多的自由反而会影响最终获得良好的结果。

### 搭建开发环境

虽然我平时也使用 VSCode，但之前从未将其作为主力开发工具。对于安装 Node. js 和使用 NPM，我的了解也相对有限。在这方面，AI
的帮助使我能够顺利构建开发环境。

对于解答命令行操作和在操作中遇到的问题，Warp 提供的 AI 助手使用起来最为方便。遇到错误时，我只需点击 ⚡️ 按钮，AI
助手即会自动将相关的命令和输出作为上下文提交给 AI。相较之下，在 GitHub Copilot
中，为了确保上下文的完整性，我需要手动选择需要解释的输出内容，再通过右键菜单中的 AI 选项或使用快捷命令 **`@workspace /explain
#terminalSelection` ** 进行操作，这比 Warp 略显繁琐。

与 Xcode 提供的集成式测试环境不同，在 VSCode
中，开发者需要根据所使用的语言和框架选择合适的测试框架和插件。在这一过程中，我遇到了一些困难。最初按照 AI 的建议尝试安装 Jest，但由于与 Astro
的配合问题，一直无法成功。在多次与 AI
的讨论无果后，我转向搜索引擎，但仍未找到解决方案。最终，我在网上找到了一篇文章。文章提到了我之前在配置中没有接触到的知识点。我将这个知识点告知了
AI，并提供了更多上下文信息。最终，在 AI 的指导下成功配置了 Jest 框架。

然而，在后续的单元测试中发现，Jest 无法与 Astro 的运行时环境协同工作。通过查阅 Astro 的官方文档，我发现 ViTest 是更合适
Astro 的测试框架。安装 ViTest 过程十分顺利，且能完美运行涉及 Astro 代码的测试。

因此，在这个项目中，我最终配置了两个测试框架：针对 Astro 的测试使用 ViTest，而其他测试仍使用 Jest。

> 不知道是否是我的配置问题，通过快捷命令，GitHub Copilot 默认生成的测试代码是基于 Jest 的。为了生成适合 ViTest
> 的测试代码，我需要通过对话方式明确提出要求。

从这个经历中，我意识到，即使有 AI 和搜索引擎的帮助，最权威的信息源仍然是官方文档。尽管 AI
对这些文档有相当程度的了解，但有时仍会漏掉关键信息。由此可见，官方文档的权威性不可被替代，仍是首选的信息渠道。

### 通过阅读代码，学习新语言

阅读 Astro 提供的官方模板是我了解 Astro 和学习 TypeScript 的最好途径。在这个阶段，AI
扮演了决定性的助手角色，极大地提高了我学习的效率。

在 Astro 项目中， **`astro` ** 文件可能包含 TypeScript、JavaScript、HTML、CSS 以及 Astro
特有的标记和用法等多种元素。对于我这样之前没有相关经验的人来说，在没有 AI 的帮助下，基本上是无从下手的。

通过让 AI 对代码作出详细的解释，我逐步理解了其结构和逻辑。虽然 Astro 相对于其他框架而言历史较短，但 AI 知识库对其有相当充分的了解。AI
能够清晰地指出代码中各个部分的含义，对于我不理解的地方，我会继续询问以获得更详尽的说明。

在这个讨论过程中，我充分利用了自己对其他开发语言和框架的了解，作为与 AI 对话的参考。我还会定期总结自己的理解，让 AI
帮助我纠正任何理解上的偏差。此外，随着讨论内容的增加，我也会定期要求 AI 对之前的讨论进行阶段性的总结，并进行记录。

这一阶段的代码解释和讨论主要在 GitHub Copilot 中进行。尽管 GitHub Copilot 总体表现良好，但在使用过程中需要注意以下几点：

- 如果没有特定选择代码，GitHub Copilot 仅解释当前编辑窗口中可见的代码部分。
- 为了提供更多的代码给 GitHub Copilot，需要手动选择想要提交的代码，以使其成为当前问题的上下文。
- GitHub Copilot 不支持跨文档讨论，需要用户自行整合不同文档内容，以形成完整的上下文。
- GitHub Copilot 的回答长度有限，如果答案过长，提示信息可能会覆盖掉已经给出的部分，此时需要求助于 ChatGPT 或 Claude。
- 在某些问题上，GitHub Copilot 的回答质量可能不及 ChatGPT。

总的来说，AI 在辅助学习方面给我带来了巨大惊喜。未来，我计划在学习过程中更多地融入 AI 的使用。

### 编码实践

根据提示自动创建代码是开发者能够第一时间感受到 AI 强大功能的最佳方式。尤其是 GitHub Copilot
可以揣摩开发者的意图，实时生成质量不低的代码，一度引发开发者群体的热烈讨论。对我而言，这个功能固然十分优秀，但就我目前的需求而言，它反而成了阻碍。

在这次的博客重构中，我不仅要创建一个新的博客，还希望能够在这个过程中更多地了解和掌握新的语言和框架。在启用 GitHub Copilot
的情况下，只要我给出足够的提示（注释），GitHub Copilot
就会快速给出结果。一开始，我觉得这是个不错的方式。但是随着使用的增加，我发现自己在很短的时间里便养成了面向 AI
编程的习惯：更注重注释对代码生成的影响，而不是构思具体的代码实现。这与我想通过本次重构来掌握一门新语言的愿望是相悖的。依赖于 AI
给出的代码结果只会让我产生错觉，认为自己已经掌握了，但实际上并没有。

发现了这种情况后，我只在自己无法独立实现的情况下才会启用 GitHub Copilot 的实时代码生成功能。无论写得好坏，我都会先尝试自己写一遍，然后让
AI 帮助我找到问题，并逐步改进代码的可读性和实用性。在这个过程中，我会向 AI 咨询语法细节，同时让 AI 指导我使用更符合 TypeScript
的编程范式以及更纯正的代码实现方式。

由于同一个功能的代码会被反复创建多次，因此提前创建单元测试非常重要。在不断修改代码的过程中，经常会出现修改或优化错误的情况。有了测试，问题可以及时发现。

> 在 VSCode 中，无论是 Jest 还是 ViTest，都可以启用自动测试，即在代码修改后可以立即运行一遍测试。希望 Xcode
> 也能提供类似的能力。

随着 AI 拥有快速编写代码的能力，许多开发者担心自己会被 AI 取代。作为一名开发者，我认为只有保持自身技能的不断提升，展现出 AI
无法替代的价值，才是避免被取代的关键。过度依赖 AI
确实可以在短期内提高某些方面的工作效率或完成之前无法完成的成果，但长期来看，开发者可能会逐渐失去自身优势，最终从 AI 工具的使用者转变为 AI
工具的助手：人肉提示词生成器。

## 最后

经过这段时间与 AI 产品紧密合作的经历，我深刻认识到了在有效利用 AI 的同时，保持个人技术成长和独立思考的重要性。AI
的迅猛发展是不可阻挡的，它将无疑将在未来（ 事实上现在已经开始了 ）深刻影响我们的生活和工作的方方面面。在这个 AI
日益普及的时代，那些希望继续蓬勃发展的人必须学会如何妥善利用 AI，并在这个时代发挥和展现自己的独特价值。

博客的重构工作仍在进行中，预计将于年底完成。

# 博客更新记

上个周末，我将本博客进行了一番装修升级。我对本次更新的效果比较满意，并非博客变得多好，而是通过此次更新，让我对当今的 Web
技术有了一定的了解。同时在本次更新过程中，无论是调试 Swift 代码、CSS 代码还是 Markdown 文档，都是在 Visual Studio
Code 中进行的，这也让我对 Visual Studio Code 有了进一步的认识和掌握。

通过本文将这几天更新过程记录下来。

> 作为一个使用 CSS、javascript 仅几天的人来说，本文的内容可能并不正确或相当偏颇，望见谅。

## 本次更新目标

在完全停止写博客和写代码超过 15 年后，2020 年我重新创建了自己的个人博客。目的同之前的博客一样，记录并分享自己的编程学习心得、体会、经验和教训。

本博客的主题是记录有关 Swift 学习方面的内容，因此在使用了一段时间的 WordPress、Hexo 后，我找到了一个由 Swift
编写的静态站点生成器 [ Publish ](https://github.com/JohnSundell/Publish)
，并用它完成了博客的第一次重大调整。

> 如果对 Publish 感兴趣，可以阅读我写的几篇 Publsih 的介绍文章。用 [ Publish 创建博客——入门
> ](/zh/posts/publish-1/) ， [ 主题开发 ](/zh/posts/publish-2/) ， [ 插件开发
> ](/zh/posts/publish-3/) 。

当时我对 Swift
的掌握很一般（现在也很一般，不过比当时强些），因此上次博客的更新过程跌跌绊绊，很多预期的功能并没有实现。随着博文的增多，觉得有必要对博客进行再度更新了。

本次更有以下几个主要目标：

- 添加评论功能
- 调整版式，提高对移动设备的适配
- 增加 TOC（文章目录），方便长文章的阅读

尽管最终的结果基本达到了预期，但我还是将本次更新的难度想的简单了。

## 今时不同往日

从 2005 年开始我就没有多余的精力投入编程这个业余爱好了。在此之前我自认对 Web 技术还有一定的了解，使用过
HTML、PHP、Python（用了一段时间的 Django），不过真当我进行此次更新时，才发现时代完全变了。

Publish 虽然可以帮助我完成内容管理、Markdown 转换、大的布局构建等工作，但如果没有 CSS、Javascript
的基础，想实现复杂版式、动态功能几乎寸步难行。

本着临时抱佛脚的态度，用了点时间大致接触了点 CSS、Javascript
的知识。很短的时间后我就清除地认识到，它们不是我短时间可以掌握的——已经发展的太庞大了。

CSS 和 Javascript
就像两个雪球一样，随着互联网的高速发展极速膨胀。仅从我的初步观感来看，它们的技术基础已经不适应当今的需要了。有什么需求，就添加什么功能，难度不算高，但内容非常多，完全是两个大杂烩。

好在，如今网络上分享知识的朋友越来越多，多花点时间查找还是能找到所需的资料和解决方案。

## 添加评论

这个是最先解决也是最容易的。

作为静态站点，评论系统选择不是特别多。排除掉国内外商业机构提供的静态评论系统外，最终选择了基于 Github Issue 的解决方案。

一开始试用了 [ gitment ](https://github.com/imsun/gitment)
，不过总是出现授权错误，无法加载评论区代码，最后采用了 [ gitalk ](https://github.com/gitalk/gitalk)
，几天的使用下来，感觉还是不错的。唯一遗憾的是，官方的 js 没有汉化方案，有时间再调整吧。

gittalk 的使用非常简单，在 GitHub 的 OAuth Apps 创建了 ClientID 后，经过简单配置就可以将其添加到博客代码中。

对于像 gittalk 这样只需要少量 js 代码的应用来说，在 Publish 中，可以直接使用。raw 将其包装进 Swift 代码中。例如：

               .script(
                    .raw(
                        """
                        $(document).ready(function(){
                            setHeight();
                        })
                        """
                    )
                )

如果代码量大，还是采用导入 js 文件更方便些。毕竟在 Swift 代码中添加 Javascript 代码无法获得编辑器的帮助（拼写检查、自动补全等）。

## 调整版式、提高适配

绝大多数的版式都是通过 CSS 来实现和调整的。

### 版式

可能是由于这两年我被 SwiftUI 惯坏了，很多我认为应该没有什么难度的地方，在 CSS 中实现起来不太容易。

我希望在更新后 Footer 能够在浏览器的最下方，即使中间的内容不足以充满整个空间。在 SwiftUI 中，一个 `Spacer()`
就能解决问题，但我查找了很久，都没有找到只使用 CSS 即可实现的便捷方案。最后依靠 javascript 的配合才达到了预期的效果。

![image-20210817160939449](https://cdn.fatbobman.com/image-20210817160939449.png)

另外，在 CSS 中如果想实现复杂的版式位置不太直观。尽管提供了不少的 `Position`
选项，但是想配置成想要的结果需下不少功夫（最主要的原因是我太菜）。

随着 Style 设置的增多，我发现在 CSS 文件中想找到对应的配置不容易。希望有经验的朋友能够告诉我应该如何在开发中组织 CSS 文件。

### 调试

Chrome（和 Safari）的调试功能为我本次更新提供了非常大的便利。Publish
是静态生成框架，对源文件的任何修改都需要生成后才会在网页中体现出来。通过使用浏览器的调试功能，我可以在浏览器中尝试各种 CSS
的设置，调试满意后再在代码中做最终的修改，极大的提高了效率。

本次更新中，Javascript 代码大多也是通过浏览器的调试功能进行的学习和调整。我有点理解了为什么当前的浏览器都如此的庞大和消耗资源（相当于内建一个小
IDE）。

Javascript 在浏览器中的运行效率远超我的预期，本来我打算更多的依赖静态生成，但在见识了效率后，我在不少地方都采用了通过 javascript
进行后期调整的方式。

### 适配

适配不同的屏幕尺寸，难度倒不大，主要是个功夫活。不过解决不同浏览器的表现差异确实比较让人痛苦。

在日常生活中，我绝大多数的时间都是使用 Safari。本次更新调试代码我采用了 Chrome（Safari
的调试区在下方，用起来不舒服），绝大多数的代码执行效果的都符合预期。但切换成 Safari
后，突然发现在某些页面的表现差异不小，甚至完全无法接受（不是都差不多的内核吗）。解决这些问题耗时不小。最终我也没有再测试 FireFox 和
Opera，看不见问题就不心烦。

## TOC

我一直都希望博客有个漂亮的 TOC，对于阅读篇幅较长的博文很有帮助。在众多的网站中，我个人比较喜欢掘金的 TOC 表现。

最初打算写一个 Publish 的插件，在 Publish 解析 Markdown 文档时，一并将文档结构记录下来，并在生成时创建静态页面代码。不过在认识到
Javascript 有足够的效率后，我还是决定上网找现成的 JS 方案直接拿来用。

网上基于 javascript 实现的 TOC 着实不少，不过很多都用不了，要不就是针对某些内容管理器制作的插件，要不然就是单独的 Markdown TOC
生成（不包含网页注入），有几个注入效果不错的又不支持扫描 HTML 生成目录结构。经过比较和测试后，最终在一个国内网友 [ Xinxing Li
](https://github.com/lxx2013) 提供的代码基础上实现了预期的效果。完全保留了他的扫描 HTML
生成结构的代码，改动了锚点判断逻辑并解决了滚动不正常的问题。

## Visual Studio Code

我绝大多数时间都使用的是 Xcode，由于本次更新中大量工作都是针对 CSS 和 Javascript 代码的编写，因此全程采用了 Visual
Studio Code。

VSCode 对于 CSS 和 Javascript 的支持好于 Xcode 是理所当然的。在此次更新过程中，VSCode 在 Swift
开发上的表现还是让我比较吃惊的。

在完成了 [ 在 Linux 系统上搭建 Swift 开发调试环境 ](/zh/posts/swift-in-linux/) 一文后，我很少有机会长时间的在
VSCode 中开发 Swift 代码。除了在调试方面差距较大外，用 VSCode 来开发 Swift 代码的部分体验竟然好于 Xcode，尤其在
Format 和 lint 的集成度方面完爆 Xcode。真希望 Xcode 也能更加开放自己的插件 API，提高插件的集成度。

## 后续

本次更新还有些小的目标没有实现，比如支持 Twitter Card（目前发现是域名解析的问题，正在更换注册商）、提供微博、微信分享（都需要注册
API）等。将来有时间再调整。

PS：最近一直都工作在 macOS Monterey Beta 5 下，系统基本已经达到了一个稳定的状态。

# 掌握 ViewThatFits

在 iOS 16 中，SwiftUI 增加了一个新的自适应布局容器
ViewThatFits。正如其名称所示，它的作用是在给定的多个视图中找出最合适的视图并使用。对于大多数人来说，这是一个简单易用的容器。不过，本文打算对其进行彻底的剖析，包括规则细节、理想尺寸的含义、使用示例等。最后，我们将创建一个复刻版本的
ViewThatFits，以加深对其的认识和理解。

## ViewThatFits 详解

### 定义

在 SwiftUI 的官方文档中，对 ViewThatFits 的定义如下：

> A view that adapts to the available space by providing the first child view
> that fits.
>
> 一个能够适应可用空间的视图，它提供的是第一个能够适应的子视图

    public struct ViewThatFits<Content> : View where Content : View {
        public init(in axes: Axis.Set = [.horizontal, .vertical], @ViewBuilder content: () -> Content)
    }

`ViewThatFits` evaluates its child views in the order you provide them to
the initializer. **It selects the first child whose ideal size on the
constrained axes fits within the proposed size** . This means that you provide
views in order of preference. Usually this order is largest to smallest, but
since a view might fit along one constrained axis but not the other, this
isn’t always the case. By default, `ViewThatFits` constrains in both the
horizontal and vertical axes.

ViewThatFits 按照你提供给初始化器的顺序评估其子视图。 **它选择在受限轴上理想尺寸适应建议尺寸的第一个子视图**
。这意味着你按照优先级顺序提供视图。通常这个顺序是从最大到最小，但由于一个视图可能在一个受限轴上适应但在另一个轴上不适应，所以这并不总是如此。默认情况下，ViewThatFits
在水平和垂直轴上都进行约束。

我知道，通过示例代码并观察其运行结果能让你对 ViewThatFits 获得更好的感性认识，但请不要着急，让我们首先对 ViewThatFits
的判断和呈现逻辑进行更多的剖析。

### ViewThatFits 的判断和呈现逻辑

既然 ViewThatFits 是从给定的视图中挑选出最合适的那个，那么它的判断依据是什么呢？判断的顺序如何？最终又如何呈现呢？

1. 首先，ViewThatFits 需要获取它所能使用的空间，也就是其父视图给出的建议尺寸。
2. 判断顺序根据 ViewBuilder 闭包中的顺序，从上至下逐个对子视图进行。
3. ViewThatFits 向子视图查询其理想尺寸（根据未指定建议尺寸返回的需求尺寸）。
4. 根据受限轴的设置，在选择的受限轴上，比较子视图的理想尺寸和 ViewThatFits 的父视图给出的建议尺寸。
5. 如果在所有设置的受限轴上，理想尺寸都小于等于建议尺寸，那么选择该子视图，并停止对后续子视图进行判断。
6. 如果所有的子视图都不满足条件，则选择闭包中的最后一个子视图。
7. ViewThatFits 将父视图给出的建议尺寸作为自己的建议尺寸传递给选择的子视图，并获得该子视图在明确建议尺寸下的需求尺寸。
8. ViewThatFits 将上一步获得的需求尺寸作为自己的需求尺寸返回给父视图。

一个 ViewThatFits 最终会选择那个子视图，取决于以下几个因素：

- ViewThatFits 可用的空间（它的父视图给它的建议尺寸）
- ViewThatFits 设定的受限轴
- 子视图的在受限轴上的理想尺寸
- 子视图的排列顺序

任何一个因素发生变化，最终呈现的结果都可能会不同。

比如，对于下面的代码，用更符合开发者主观目标的语言来描述就是：

    ViewThatFits(in: .horizontal) {
        Text("Hello Beautiful World")
        Text("Hello World")
        Text("Hi")
    }

ViewThatFits 会选择闭包中首个在其给定的宽度内用不折行的方式完整显示的 Text 视图。

因此，当我们将上述代码放置在不同的上下文中时，它最终呈现的子视图（选择的子视图）可能会有所不同。

    ViewThatFits(in: .horizontal) {
        Text("Hello Beautiful World") // 100 < width < 200
        Text("Hello World") //  20 < width < 100
        Text("Hi") // 10 < width < 20
    }
    .border(.blue) // required size of ViewThatFits
    .frame(width:100)
    .border(.red) // proposed size from parent View

![https://cdn.fatbobman.com/image-20231104213915624.png](https://cdn.fatbobman.com/image-20231104213915624.png)

在宽度只有 100 的情况下，最终显示的是 `Text("Hello World")` 。当宽度调整为 200 时，它将显示为 `Text("Hello Beautiful World")` 。

![https://cdn.fatbobman.com/image-20231104214010204.png](https://cdn.fatbobman.com/image-20231104214010204.png)

让我们增加一点难度，使用 `.frame(width:10)` 将 ViewThatFits 的可用尺寸（父视图给它的建议尺寸）设置为
10。根据代码中注释标注的不同 Text 的宽度，最终的呈现会是什么样子呢？

    ViewThatFits(in: .horizontal) {
        Text("Hello Beautiful World") // 100 < width < 200
        Text("Hello World") //  20 < width < 100
        Text("Hi") // 10 < width < 20
    }
    .border(.blue) // required size of ViewThatFits
    .frame(width:10)
    .border(.red) // proposed size from parent View

![https://cdn.fatbobman.com/image-20231104215314315.png](https://cdn.fatbobman.com/image-20231104215314315.png)

我们最初的意图是选择一个适合给定尺寸并且不会自动换行的文本。为什么最后会变成这个样子呢？

首先，ViewThatFits 经过逐个比对，发现闭包中没有任何一个 Text 的理想尺寸宽度不大于 10 ，因此它选择了最后一个 `Text("Hi")` 。此时 `Text("Hi")` 只获得了宽度为 10 的建议尺寸。根据 Text 的默认显示规则（显示不下就折行），它用了两行才能将 `Hi`
全部显示完。

由此可以看出，ViewThatFits
本身在最终呈现时，并不对子视图施加理想尺寸的限制。它只在检查阶段使用子视图的理想尺寸进行判断，在最终呈现阶段，它将向子视图提交有值的建议尺寸，并使用子视图的需求尺寸作为自身的需求尺寸。

为了应对这种极端情况（文字折行），我们需要对子视图进行特别的设定，例如通过 `fixedSize`
强制展示完整内容（最终的显示尺寸可能会超过父视图给出的建议尺寸）：

    Text("Hi")
        .fixedSize(horizontal: true, vertical: false)

![https://cdn.fatbobman.com/image-20231104221054205.png](https://cdn.fatbobman.com/image-20231104221054205.png)

或者可以使用 `lineLimit` 来限制其在垂直方向上只能使用 1 行的空间，但无法保证完全显示全部内容：

    Text("Hi")
        .lineLimit(1)

![https://cdn.fatbobman.com/image-20231104221034986.png](https://cdn.fatbobman.com/image-20231104221034986.png)

好吧，我承认，我是故意将问题复杂化的。要真正正确地使用
ViewThatFits，我们必须充分了解它的判断、呈现逻辑，并且掌握“理想尺寸”的概念。否则，很可能会面对与预期不一致的情况。

### 理想尺寸（ Ideal Size ）

在 SwiftUI 中，相较于建议尺寸，很多开发者对理想尺寸接触的较少，理解的也不太深入。

就布局而言，“理想尺寸”指的是当父视图以未指定的模式提供建议尺寸时，视图返回的需求尺寸。

用更容易理解的语言来说，理想尺寸就是一个视图在不给其任何尺寸限定（理想的外部环境）的情况下，其最理想的呈现结果所占用的尺寸。

**对于不同种类的视图，它们的理想呈现处理规则是不同的** 。

例如：

- Rectangle：在理想状态的轴上只使用 10（所有 Shape 都遵循该规则）。
- Text：在理想状态的轴上占用尽可能多的空间，展示全部文本（不进行任何截取）。
- ScrollView：如果理想状态的轴与滚动方向一致，则在滚动方向上一次性展示所有的子视图而无视父视图的建议尺寸。
- VStack、HStack、ZStack：所有子视图在理想状态下的整体呈现。

在 SwiftUI 中，我们可以通过 `fixedSize` 来强制一个视图以理想尺寸进行呈现：

    struct IdealSizeDemo: View {
        var body: some View {
            VStack {
                Text("GeometryReader has been present since the birth of SwiftUI, playing a crucial role in many scenarios.")
                    .fixedSize()
                Rectangle().fill(.orange)
                    .fixedSize()
                Circle().fill(.red)
                    .fixedSize()
                ScrollView(.horizontal) {
                    HStack {
                        ForEach(0 ..< 50) { i in
                            Rectangle().fill(.blue).frame(width: 30, height: 30)
                                .overlay(Text("\(i)").foregroundStyle(.white))
                        }
                    }
                }
                .fixedSize()
                VStack {
                    Text("GeometryReader has been present since the birth of SwiftUI, playing a crucial role in many scenarios.")
                    Rectangle().fill(.yellow)
                }
                .fixedSize()
            }
        }
    }

![https://cdn.fatbobman.com/image-20231105155129190.png](https://cdn.fatbobman.com/image-20231105155129190.png)

从截图中可以看出，Text、Shape 和 ScrollView 的“理想呈现”都比较容易预测，与我们上面的描述一致。唯一有些奇怪的是 VStack：

    VStack {
        Text("GeometryReader has been present since the birth of SwiftUI, playing a crucial role in many scenarios.")
        Rectangle().fill(.yellow)
    }
    .fixedSize()

对于这种视图，其“理想呈现”是一个复合的状态：

- 宽度：VStack 将逐个询问子视图的理想尺寸，使用其中宽度的最大值作为它的需求尺寸，并在最终布局时（placeSubviews）将其作为建议尺寸传递给子视图。
- 高度：VStack 将所有子视图的理想尺寸高度和 Spacing 的和作为自己的需求尺寸。

SwiftUI 提供了两个版本的 `fixedSize`
，我们当前使用的版本要求视图在水平和垂直两个轴向上都使用理想尺寸，而另一个版本允许我们对单个轴向进行限定。

    struct IdealSizeDemo2: View {
        var body: some View {
            Text("GeometryReader has been present since the birth of SwiftUI, playing a crucial role in many scenarios.")
                .fixedSize(horizontal: false, vertical: true)
                .border(.red, width: 2)
                .frame(width: 100, height: 100)
                .border(.blue, width: 2)
        }
    }

`fixedSize(horizontal: false, vertical: true)` 表示，我们要求 Text 在 vatical
轴向上呈现理想状态，在 horizontal 轴向上继续使用具有明确数值的建议尺寸宽度（ 100 ）。用易懂的描述就是，在有明确宽度限定的情况下，要求
Text 显示全部的文本内容。

![https://cdn.fatbobman.com/image-20231105160806434.png](https://cdn.fatbobman.com/image-20231105160806434.png)

从上图中可以看出，由于 `fixedSize` 的存在，Text 忽略了其父视图给出的 100 x 100
的建议尺寸高度，充分利用了垂直方向上的空间，将完整的文本内容呈现出来。

这种对理想尺寸在单个轴向上的限制与 ViewThatFits 构造方法中的受限轴设置完全对应。通过设置，我们可以让 ViewThatFits
只在特定轴向上对子视图的理想尺寸进行判断。

    struct IdealSizeDemo3: View {
        var body: some View {
            HStack {
                // ViewThatFits result
                ViewThatFits(in: .vertical) {
                    Text("1: GeometryReader has been present since the birth of SwiftUI, playing a crucial role in many scenarios.")
                    Text("2: In addition, some views believe that:")
                }
                .border(.blue)
                .frame(width: 200, height: 100, alignment: .top)
                .border(.red)

                // Text1's ideal size ,only vetical fixed
                Text("1: GeometryReader has been present since the birth of SwiftUI, playing a crucial role in many scenarios.")
                    .fixedSize(horizontal: false, vertical: true)
                    .border(.blue)
                    .frame(width: 200, height: 100, alignment: .top)
                    .border(.red)

                // Text2's ideal size ,only vetical fixed
                Text("2: In addition, some views believe that:")
                    .fixedSize(horizontal: false, vertical: true)
                    .border(.blue)
                    .frame(width: 200, height: 100, alignment: .top)
                    .border(.red)
            }
        }
    }

上面这段代码清晰地展示了 ViewThatFits 选择第二个 Text 的判断依据。当 Text 1 在垂直轴上被单独限定为理想尺寸时，它的高度超过了
ViewThatFits 可提供的高度 100（蓝色边框高度大于红色边框）。而 Text 2 的高度符合 ViewThatFits 的要求。

![https://cdn.fatbobman.com/image-20231105162429959.png](https://cdn.fatbobman.com/image-20231105162429959.png)

实际上，即使 Text 2 的理想高度大于 ViewThatFits 提供的高度，根据 ViewThatFits
的判断规则，在所有子视图都不满足条件的情况下，它也会默认选择最后一个子视图（Text 2）。不过，最终的呈现会是怎样的呢？

    ViewThatFits(in: .vertical) {
        Text("1: GeometryReader has been present since the birth of SwiftUI, playing a crucial role in many scenarios.")
        Text("2: In addition, some views believe that:")
    }
    .border(.blue)
    .frame(width: 200, height: 30, alignment: .top)
    .border(.red)

![https://cdn.fatbobman.com/image-20231105162904137.png](https://cdn.fatbobman.com/image-20231105162904137.png)

开发者必须清楚，ViewThatFits 是基于理想尺寸来进行判断，但在最终呈现时，被选择的子视图并不是按照理想状态来呈现的。由于 ViewThatFits
能够提供的高度只有 30，在 Text 2 最终呈现时，它将根据其默认显示规则对文字进行截断处理。

在 SwiftUI 中，我们可以通过 `frame` 来修改视图在理想状态下的呈现。

    struct SetIdealSize: View {
        @State var useIdealSize = false
        var body: some View {
            VStack {
                Button("Use Ideal Size") {
                    useIdealSize.toggle()
                }
                .buttonStyle(.bordered)

                Rectangle()
                    .fill(.orange)
                    .frame(width: 100, height: 100)
                    .fixedSize(horizontal: useIdealSize ? true : false, vertical: useIdealSize ? true : false)

                Rectangle()
                    .fill(.cyan)
                    .frame(idealWidth: 100, idealHeight: 100)
                    .fixedSize(horizontal: useIdealSize ? true : false, vertical: useIdealSize ? true : false)

                Rectangle()
                    .fill(.green)
                    .fixedSize(horizontal: useIdealSize ? true : false, vertical: useIdealSize ? true : false)
            }
            .animation(.easeInOut, value: useIdealSize)
        }
    }

`.frame(width: 100, height: 100)` 与 `.frame(idealWidth: 100, idealHeight:
100)` 之间的不同在于前者在任何场景下（理想状态或非理想状态）均被视为视图的需求尺寸，后者仅在理想状态下作为需求尺寸。

![https://cdn.fatbobman.com/set-ideal-size-
demo_2023-11-05_16.49.08.2023-11-05%2016_50_09.gif](https://cdn.fatbobman.com/set-
ideal-size-demo_2023-11-05_16.49.08.2023-11-05%2016_50_09.gif)

> 如果你想进一步了解更多有关理想尺寸和建议尺寸的内容，请阅读 [ SwiftUI 布局 —— 尺寸（ 上 ） ](/zh/posts/layout-
> dimensions-1/) 一文。

## 示例

所有的理论知识都是为实际应用而服务的。在本节中，我们将通过几个示例来展示 ViewThatFits 的功能。

### 自适应滚动

通过下面的代码，我们可以实现在内容宽度超过给定宽度时，自动进入可滚动状态。

    struct ScrollViewDemo: View {
        @State var step: CGFloat = 3
        var count: Int {
            Int(step)
        }

        var body: some View {
            VStack(alignment:.leading) {
                Text("Count: \(count)")
                Slider(value: $step, in: 3 ... 20, step: 1)

                ViewThatFits {
                    content
                    ScrollView(.horizontal,showsIndicators: true) {
                        content
                    }
                }
            }
            .frame(width: 300)
            .border(.red)
        }

        var content: some View {
            HStack {
                ForEach(0 ..< count, id: \.self) { i in
                    Rectangle()
                        .fill(.orange.gradient)
                        .frame(width: 30, height: 30)
                        .overlay(
                            Text(i, format: .number).foregroundStyle(.white)
                        )
                }
            }
        }
    }

![https://cdn.fatbobman.com/viewThatFits-scrollView-
demo_2023-11-05_17.06.10.2023-11-05%2017_08_32.gif](https://cdn.fatbobman.com/viewThatFits-
scrollView-demo_2023-11-05_17.06.10.2023-11-05%2017_08_32.gif)

如果 `content` 的宽度超过了 ViewThatFits 允许的宽度（300），则 ViewThatFits 会选择最后一个使用
ScrollView 的子视图。在这个示例中，尽管 ScrollView 在理想状态下，呈现的宽度也超过了 ViewThatFits
允许的宽度，但由于它是最后一个子视图，因此最终选择了它。这也是一个典型的判断和呈现不一致的情况。

### 选择合适长度的文本

这也是 ViewThatFits 最常被使用的场景，从提供的一组文本中，找出最适合当前空间的那个。

    struct TextDemo: View {
        @State var width: CGFloat = 100
        var body: some View {
            VStack {
                Slider(value: $width, in: 30 ... 300)
                    .padding()
                ViewThatFits {
                    Text("Fatbobman's Swift Weekly")
                    Text("Fatbobman's Weekly")
                    Text("Fat's Weekly")
                    Text("Weekly")
                        .fixedSize()
                }
                .frame(width: width)
                .border(.red)
            }
        }
    }

![https://cdn.fatbobman.com/viewThatFits-Text-
Demo_2023-11-05_17.26.17.2023-11-05%2017_27_16.gif](https://cdn.fatbobman.com/viewThatFits-
Text-Demo_2023-11-05_17.26.17.2023-11-05%2017_27_16.gif)

为了确保即使在空间有限的情况下，仍然可以完整显示文本，我们对最后一个 Text 使用了 `fixedSize` 。

有些开发者可能会使用以下代码（相同的内容，不同的字体尺寸），为 ViewThatFits 提供不同尺寸的子视图：

    ViewThatFits {
        Text("Fatbobman's Swift Weekly")
            .font(.body)
        Text("Fatbobman's Swift Weekly")
            .font(.subheadline)
        Text("Fatbobman's Swift Weekly")
            .font(.footnote)
    }

![https://cdn.fatbobman.com/viewThatFits-Text-
demo2_2023-11-05_17.38.52.2023-11-05%2017_39_20.gif](https://cdn.fatbobman.com/viewThatFits-
Text-demo2_2023-11-05_17.38.52.2023-11-05%2017_39_20.gif)

然后，对于内容相同但尺寸不同的需求，ViewThatFits 可能并不是最优解决方案。下面的代码可以带来更好的效果：

    Text("Fatbobman's Swift Weekly")
        .lineLimit(1)
        .font(.body)
        .minimumScaleFactor(0.3)
        .frame(width: width)
        .border(.red)

![https://cdn.fatbobman.com/viewThatFits-Text-
demo3-minimumScaleFactor_2023-11-05_17.55.33.2023-11-05%2017_56_16.gif](https://cdn.fatbobman.com/viewThatFits-
Text-demo3-minimumScaleFactor_2023-11-05_17.55.33.2023-11-05%2017_56_16.gif)

ViewThatFits 更擅长为不同的空间提供不同的备选内容。

### 自适应横竖布局

在给定的空间中，自动选择适合的布局方式：

    var logo: some View {
        Rectangle()
            .fill(.orange)
            .frame(idealWidth: 100, maxWidth: 200, idealHeight: 100)
            .overlay(
                Image(systemName: "heart.fill")
                    .font(.title)
                    .foregroundStyle(.white)
            )
    }

    var title: some View {
        Text("Hello World")
            .fixedSize()
            .font(.headline).bold()
            .frame(maxWidth: 120)
    }

    struct LayoutSwitchDemo: View {
        @State var width: CGFloat = 100
        var body: some View {
            VStack {
                ViewThatFits(in: .horizontal) {
                    HStack(spacing: 0) {
                        logo
                        title
                    }
                    VStack(spacing: 0) {
                        logo
                        title
                    }
                }
                .frame(maxWidth: width, maxHeight: 130)
                .border(.blue)

                Spacer()
                Slider(value: $width, in: 90 ... 250).padding(50)
            }
        }
    }

![https://cdn.fatbobman.com/viewThatFits-layout-switch-
demo1_2023-11-05_18.51.22.2023-11-05%2018_52_23.gif](https://cdn.fatbobman.com/viewThatFits-
layout-switch-demo1_2023-11-05_18.51.22.2023-11-05%2018_52_23.gif)

在这个示例中，我们利用了 ViewThatFits 的特性，在判断子视图和最终呈现时采用不同的建议尺寸模式，以确保最终呈现的子视图始终能够充满
ViewThatFits 视图。对于 logo 和 title，我们没有给出明确的尺寸。通过为 Rectangle 设置理想尺寸，供
ViewThatFits 用来选择合适的子视图。选定了子视图后，子视图中的 logo 会根据 ViewThatFits
提供的尺寸，在最终的呈现时调整自己的尺寸。

## 创建 ViewThatFits 的复刻版本

在学习 SwiftUI
的过程中，我经常尝试复刻一些布局容器和修饰符。通过这个过程，除了验证我的一些猜想外，还能更深入地理解和掌握它们。在本节中，我们将创建一个符合 Layout
协议的布局容器，来实现对 ViewThatFits 的复刻。

我们已经在第一个章节中详细阐述了 ViewThatFits 的实现细节（判断规则、呈现逻辑），因此使用 Layout 协议来实现非常方便。

    struct _MyViewThatFitsLayout: Layout {
        let axis: Axis.Set
        func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout Int?) -> CGSize {
            // 没有子视图，返回 zero
            guard !subviews.isEmpty else { return .zero }
            // 一个子视图，返回该子视图的需求尺寸
            guard subviews.count > 1 else {
                cache = subviews.endIndex - 1
                return subviews[subviews.endIndex - 1].sizeThatFits(proposal)
            }
            // 从第一个到倒数第二个子视图逐个在限定的轴向上获取其理想尺寸进行判断
            for i in 0..<subviews.count - 1 {
                let size = subviews[i].dimensions(in: .unspecified)
                switch axis {
                case [.horizontal, .vertical]:
                    if size.width <= proposal.replacingUnspecifiedDimensions().width && size.height <= proposal.replacingUnspecifiedDimensions().height {
                        cache = i
                        // 满足判断条件，返回该子视图的需求尺寸（ 用正常的建议尺寸询问 ）
                        return subviews[i].sizeThatFits(proposal)
                    }
                case .horizontal:
                    if size.width <= proposal.replacingUnspecifiedDimensions().width {
                        cache = i
                        return subviews[i].sizeThatFits(proposal)
                    }
                case .vertical:
                    if size.height <= proposal.replacingUnspecifiedDimensions().height {
                        cache = i
                        return subviews[i].sizeThatFits(proposal)
                    }
                default:
                    break
                }
            }
            // 上述都不满足，则使用最后一个子视图
            cache = subviews.endIndex - 1
            return subviews[subviews.endIndex - 1].sizeThatFits(proposal)
        }

        func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout Int?) {
            for i in subviews.indices {
                if let cache, i == cache {
                    subviews[i].place(at: bounds.origin, anchor: .topLeading, proposal: proposal)
                } else {
                    // 将不需要显示的子视图，放置在一个无法显示的位置
                    subviews[i].place(at: .init(x: 100_000, y: 100_000), anchor: .topLeading, proposal: .zero)
                }
            }
        }

        func makeCache(subviews _: Subviews) -> Int? {
            nil
        }
    }

    public struct MyViewThatFitsByLayout<Content>: View where Content: View {
        let axis: Axis.Set
        let content: Content

        public init(axis: Axis.Set = [.horizontal, .vertical], @ViewBuilder content: @escaping () -> Content) {
            self.axis = axis
            self.content = content()
        }

        public var body: some View {
            _MyViewThatFitsLayout(axis: axis) {
                content
            }
        }
    }

经过检验，我们的复刻版本与 ViewThatFits 的效果完全一致。

![https://cdn.fatbobman.com/MyViewThatFitsByLayoutDemo_2023-11-05_19.25.40.2023-11-05%2019_26_32.gif](https://cdn.fatbobman.com/MyViewThatFitsByLayoutDemo_2023-11-05_19.25.40.2023-11-05%2019_26_32.gif)

> 你可以在 [ 此处 ](https://github.com/fatbobman/BlogCodes/tree/main/ViewThatFits)
> 获取本文的全部代码。

## 总结

正如我们所看到的，ViewThatFits 是 SwiftUI
工具箱中的一个强大而灵活的组件，它可以帮助开发者优雅地解决多种布局挑战，提升应用程序的用户体验和界面适应性。但是，与任何强大的工具一样，能否发挥期作用来自于深入理解其使用方式和限制。

在本文中，我们对 SwiftUI 中的 ViewThatFits
容器进行了深入的探索。从基本定义到复杂的布局机制，我们试图揭示这个强大工具背后的逻辑和潜力。通过对理想尺寸和布局适应性的详细分析，我们展示了
ViewThatFits 如何在多样化的应用场景中发挥作用。

尽管 ViewThatFits
在处理多种视图和布局挑战方面非常有用，但它并不是万能的。在某些复杂的布局需求下，开发者可能需要更精细的控制或采用其他布局策略。因此，理解它的内部工作原理和限制是至关重要的，这样开发者才能充分利用它的优势，同时避免潜在的布局问题。

希望这篇文章能为你在使用 SwiftUI 进行布局设计时提供有价值的见解。

# SwiftUI 2.0 —— @StateObject 研究

WWDC 20
刚刚结束，在过去的一周，苹果为开发者带来了巨大的惊喜。由于新特性实在太多，需要不少时间来消化，我首先选择自己最感兴趣的内容进行一些简单的研究和探讨。本文首先浅谈一下
SwiftUI 新提供的属性包装器@StateObject。

## 为什么要新增 @StateObject

在我之前的文章 [ @State 研究 ](/zh/posts/swiftui-state/) 中我们探讨过
@State，通过它，我们可以方便的将值类型数据作为 View 的 Source of truth。在 SwiftUI 1.0 时代，如果想将引用类型作为
source of truth, 通常的方法是使用 @EnvironmentObject 或者 @ObservedObject。

    struct RootView:View{
        var body: some View{
            ContentView()
                .environmentObject(Store())
        }
    }

    struct ContentView: View {
        @EnvironmentObject  var store1:Store
        var body: some View {
            Text("count:\(store.count)")
        }
    }

对于使用 @EnvironmentObject 注入的数据，由于其通常是在 SceneDelegate 或着当前 View 的父辈、祖先 View
上创建的，所以其生命周期必然不短于当前 View, 因此在使用中并不会发生由于生命周期不可预测而导致的异常。

    struct Test5: View {
        @ObservedObject var store = Store()
        var body: some View {
            Text("count:\(store.count)")
        }
    }

对于上面的代码，乍看起来没有任何不妥，不过由于 @ObservedObject 的机制问题，其创建的实例并不被当前 View 所拥有（当前 View
无法管理其生命周期），因此在一些特殊的情况下会出现不可预料的结果。

为了能够让开发者更好的掌控代码，同时也保持对于上一版本良好的兼容性，苹果在 SwiftUI 2.0 中添加了 @StateObject。顾名思义，它是
@State 的引用类型版本。

在 WWDC 的视频中，苹果明确的表明 @StateObject 是被创建他的 View 所持有的，也就是说，实例的生命周期是完全可控的，是同创建它的
View 的生命周期一样的。

**@StateObject 和 @ObservedObject 的区别就是实例是否被创建其的 View 所持有，其生命周期是否完全可控。**

## 通过代码了解不同

我通过下面的代码来详细阐述一下 @StateObject 和 @ObservedObject 的不同表现。

**准备工作：**

    class StateObjectClass:ObservableObject{
        let type:String
        let id:Int
        @Published var count = 0
        init(type:String){
            self.type = type
            self.id = Int.random(in: 0...1000)
            print("type:\(type) id:\(id) init")
        }
        deinit {
            print("type:\(type) id:\(id) deinit")
        }
    }

    struct CountViewState:View{
        @StateObject var state = StateObjectClass(type:"StateObject")
        var body: some View{
            VStack{
                Text("@StateObject count :\(state.count)")
                Button("+1"){
                    state.count += 1
                }
            }
        }
    }

    struct CountViewObserved:View{
        @ObservedObject var state = StateObjectClass(type:"Observed")
        var body: some View{
            VStack{
                Text("@Observed count :\(state.count)")
                Button("+1"){
                    state.count += 1
                }
            }
        }
    }

StateObjectClass 将在其被创建和销毁时通过 type 和 id 告知我们它是被那种方法创建的，以及具体哪个实例被销毁了。

CountViewState 和 CountViewObserved 唯一的不同是创建实例使用的属性包装器不同。

**测试 1：**

    struct Test1: View {
        @State var count = 0
        var body: some View {
            VStack{
                Text("刷新 CounterView 计数 :\(count)")
                Button("刷新"){
                    count += 1
                }

                CountViewState()
                    .padding()

                CountViewObserved()
                    .padding()

            }
        }
    }

在测试 1 中，当进点击+1 按钮时，无论是 @StateObject 或是 @ObservedObject 其都表现出一致的状态，两个 View
都可以正常的显示当前按钮的点击次数，不过当点击刷新按钮时，CountViewState 中的数值仍然正常，不过 CountViewObserved
中的计数值被清零了。从调试信息可以看出，当点击刷新时，CountViewObserved
中的实例被重新创建了，并销毁了之前的实例（CountViewObserved 视图并没有被重新创建，仅是重新求了 body 的值）。

    type:Observed id:443 init
    type:Observed id:103 deinit

在这个测试中，@ObservedObject 创建的实例的生命周期短于当前 View。

**测试 2:**

    struct Test2: View {
        @State var count = 0
        var body: some View {
            NavigationView{
                List{
                    NavigationLink("@StateObject", destination: CountViewState())
                    NavigationLink("@ObservedObject", destination: CountViewObserved())
                }
            }
        }
    }

测试 2 中，点击 link 进入对应的 View 后通过点击+1 进行计数，然后返回父视图。当再次进入 link 后，@StateObject
对应的视图中计数清零（由于返回父视图，再次进入时会重新创建视图，所以会重新创建实例），不过@ObservedObject 对应的视图中计数是不清零的。

在这个测试中，@ObservedObject 创建的实例生命周期长于当前的 View。

**测试 3:**

    struct Test3: View {
        @State private var showStateObjectSheet = false
        @State private var showObservedObjectSheet = false
        var body: some View {
            List{
                Button("Show StateObject Sheet"){
                    showStateObjectSheet.toggle()
                }
                .sheet(isPresented: $showStateObjectSheet) {
                    CountViewState()
                }
                Button("Show ObservedObject Sheet"){
                    showObservedObjectSheet.toggle()
                }
                .sheet(isPresented: $showObservedObjectSheet) {
                    CountViewObserved()
                }
            }
        }
    }

测试 3 中点击按钮，在 sheet 中点击+1, 当再次进入 sheet 后，无论是 @StateObject 还是 @ObservedObject
对应的 View 中的计数都被清零。

在这个测试中，@ObservedObject 创建的实例生命周期和 View 是一致的。

**三段代码，三种结果，这也就是为什么苹果要新增 @StateObject 的原因——让开发者可以明确地了解并掌握实例的生命周期，消除不确定性！**

## ObservedObject 是否还有存在的必要？

当然有必要！

StateObject 之所以能为实例创建稳定的生命周期，其根本原因是其为实例带来了唯一性：使用 `@StateObject`
标注的对象在视图的整个生命周期中是唯一的。这意味着即使视图重新渲染，对象也不会重新创建。

但这也同时意味着，在某些我们不需要这种唯一性的场景时， `@ObservedObject` 才是正确的选择。

详情请阅读 [ StateObject 与 ObservedObject
](/zh/posts/stateobject_and_observedobject/) 中 “何时选择使用 ObservedObject” 的章节。

## Next

苹果使用 @StateObject 一方面修复了之前的隐患，同时通过 SwiftUI 2.0 众多新特性的引入，进一步完善了 Data Flow
的实现手段。

# Core Data with CloudKit （六） —— 创建与多个 iCloud 用户共享数据的应用

本文中，我们将探讨如何使用 Core Data with CloudKit 创建与多个 iCloud 用户共享数据的应用。

> 本篇是本系列的最后一篇，本文中将涉及大量之前提到的知识，阅读本文前，最好已经阅读过之前的文章。

相信应该有不少的朋友都使用过 iOS 自带的共享相簿或者共享备忘录功能。这些功能的实现都是基于几年前苹果推出的 CloudKit 共享数据 API。在
WWDC 2021 中，苹果将该功能集成到 Core Data with CloudKit 之中，我们终于可以在使用少量 CloudKit API
的情况下，用 Core Data 的操作方式创建具有同样功能的应用程序了。

就像 WWDC session [ Build apps that share data through CloudKit and Core Data
](https://developer.apple.com/videos/play/wwdc2021/10015/)
提到的那样，共享数据功能的实现远复杂于同步私有数据库以及同步公共数据库。尽管苹果提供了不少新的 API
来简化该操作，但想完整的在应用程序中实现该功能仍具有不小的挑战。

## 基础

> 本节主要介绍的是 Core Data with CloudKit 下的共享机制，某些地方同原生的 CloudKit 共享不同。

### 所有者和参与者

在每个共享数据关系中，都有一个所有者（ `owner` ）和若干个参与者（ `participant` ）。无论是所有者还是参与者，都必须为
iCloud 用户，且只能在已经登录了有效 iCloud 账户的苹果设备上进行操作。

所有者发起共享，并向参与者发送共享链接。参与者点击共享链接后，设备将自动打开对应的 app，导入共享数据。

所有者可以指定具体的参与者，或者将共享设置为任何点击共享链接的人都可以访问。两种情况互斥，可以切换，当从指定具体参与者切换到任何人时，系统将删除所有的具体参与者信息。

所有者可以为参与者设置数据操作权限，只读或可读写，权限可以在之后修改。

### CKShare

CKShare 是管理共享记录集合的专用记录类型。包含了需要共享的根记录或自定义区域信息以及在此次共享关系中的所有者和参与者的信息。

在 Core Data with CloudKit 模式下，所有者将托管对象实例（ `NSManagedObject`
）设置为共享的过程，其实就是为其创建了一个 `CKShare` 实例。

    let (ids, share, ckContainer) = try await stack.persistentContainer.share([note1,note2], to: nil)

我们可以在一个共享关系中，一次性共享多个托管对象。

托管对象关系（ `relationship` ）对应的所有数据都将自动被共享。

针对共享后的托管对象的任何修改都将自动同步到所有者和参与者的设备中。在当前的 Core Data with CloudKit
机制下，我们无法在共享后添加最顶层的托管对象（例如上面代码中的 `note` ）。

### 云端共享机制

在 WWDC 2021 之前，CloudKit 的机制是通过一个 `rootRecord` 来实现共享，所有者为某个 CKRecord 创建
CKShare，实现单个记录（包含它的关系数据）共享。

    let user = CKRecord(recordType:"User")
    let share = CKShare(rootRecord: user)

WWDC 2021 中 CloudKit
提供了一种新的共享机制——共享自定义区域（Zone）。所有者在自己的私有数据库中创建一个新的自定义区域，为该区域创建
CKShare。参与者将共享该区域中所有的数据。

    init(recordZoneID: CKRecordZone.ID)

此种共享方式更适合数据集较大、关系较复杂的应用场景。Core Data with CloudKit 的数据共享就是采用这种共享机制。

在之前的同步私有数据库中我们介绍过，私有数据库的自定义区域可以创建 `CKDatabaseSubscription`
，参与者正式通过该订阅来及时获取到共享数据的变化。

当所有者创建了一个共享关系后，系统将自动为其在私有数据库中创建一个新的自定义区域（ `com.apple.coredata.cloudkit.share.xxx-xx-xx-xx-xxx`
），并将共享的数据（包括其关系数据）从私有数据库中的 `com.apple.coredata.cloudkit.zone` 移动到新建的 Zone
中。此过程为 NSPersistentCloudContainer 自动完成。

每个共享关系都将创建一个新的自定义区域。

![image-20210911110311850](https://cdn.fatbobman.com/image-20210911110311850.png)

参与者将在他的网络共享数据库中看到一个同上面新建的 Zone 名称一样的自定义区域（之前的文章介绍过，共享数据库是其他用户的私有数据库的数据投影）。

所有者对数据都操作都是在自己的网络私有数据库自定义区域中进行的，而参与者则是在自己的网络共享数据库对应的自定义区域中进行的。

> 每个使用者都可能发起共享，也可能接受共享，无论用户在一个共享关系中是什么角色，数据的保存逻辑是不变的。

### 本地存储机制

在之前的文章中，我们已经介绍了如何通过多个 NSPersistentStoreDescription 创建多个持久化存储。同网络端类似，在用户的设备端，通过
Core Data with CloudKit 共享数据同样需要创建两个本地 Sqlite 数据库。两个数据库分别对应网络端的私有数据库和共享数据库。

从共享关系中的所有者来看，所有者创建的所有数据都保存在本地的私有数据库中。即使该数据被共享，其他参与者对数据的修改也保存在所有者的私有数据库中。

从数据的参与者来看，任何所有者共享的数据，都保存在参与者的本地的共享数据库文件中，即使是参与者本人进行的添加或修改，也同样保存在本地共享数据库文件中。

以上的行为，同网络端的逻辑完全一致。

> 苹果为了实现以上的功能，在背后做了大量的工作。NSPersistentCloudContainer
> 在同步数据时，需要对每条数据进行网络自定义区域和本地持久化存储的判断、转换等大量工作。因此在实际使用中，同步速度比单纯的同步本地数据库要慢。

由于网络共享库是网络私有库数据的投影，因此两个数据库使用的数据模型是完全一致的。因此在代码实现上，基本上就是采用简单的 `Copy` 完成。

    guard let shareDesc = privateDesc.copy() as? NSPersistentStoreDescription else {
                fatalError("Create shareDesc error")
            }

苹果在去年为 `cloudKitContainerOptions` 添加了 `databasScope` 属性，支持了 `private` 和
`public` ，今年又增加了 `shared` 选项以支持共享数据类型。

    shareDescOption.databaseScope = .shared

> 由于所有的共享数据都是需要对应的 CKRecord 信息，因此，本地私有数据库必须同时支持网络同步。

网络端和本地端数据保存逻辑如下：

![共享数据库示意图。drawio-2](https://cdn.fatbobman.com/%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio-2.png)

与同步公共数据库一样，Core Data with CloudKit 为了缩短通过网络查询 CloudKit 数据时间，将 NSManagedObject
对应的 CKRecord 都保存在本地数据库文件中，在使用共享数据功能的情况下，本地还会保存对应的自定义区域以及所有的 CKShare 信息。

以上举措一方面极大的改善了数据查询的效率，同时也对维护本地 Catch 数据的有效性提出了更高的要求。苹果提供了部分的 API 来解决 Catch
的新鲜度问题，不过并不完美，仍需开发者编写较多的额外代码。另外，系统自带的 UICloudSharingController 仍未支持 Catch
更新（Xcode 13 beta 5）。

### 新 API

苹果今年为 CloudKit API 做了大幅的更新，给所有的回调式异步方法都添加了 Async/Await 版本。同时，也为 Core Data with
CloudKit 更新并添加了不少方法以支持数据共享。在上篇文章中，我们已经提到，苹果大幅增强了 NSPersistentCloudContainer
的存在感，新添加的方法，大多都是增加在 NSPersistentCloudContainer 中。

- acceptShareInvitations

参与者接受邀请，该方法运行在 AppDelegate 中

- share

为托管对象创建 CKShare

- fetchShares (in:)

获取持久化存储中的所有 CKShare

- fetchShares (matching:)

获取指定托管对象的 CKShare

- fetchParticipants

通过 CKUserIdentity. LookupInfo 获取共享关系中的 Participant 信息。比如通过 email 或电话号码进行查找

- persistUpdatedShare

更新本地 Catch 中的 CKShare。在开发者通过代码修改 CKShare 后，应将经过网络更新后的 CKShare 持久化到本地的 Catch
中，目前的 UICloudSharingController 缺少了这个步骤，导致停止更新后出现 Bug。

- purgeObjectsAndrecordsInZone

删除指定的自定义区域，并删除本地对应的所有托管对象。在当前版本中（XCode 13 beta 5），所有者停止更新后，并没有完成足够的善后工作。导致本地
Catch 中仍保存 CKShare，该托管对象无法唤起
UICloudSharingController，网络端的数据仍旧保存在为共享创建的自定义区域中（应该移回正常的自定义 Zone）。

### UICloudShareingController

![IMG_1886](https://cdn.fatbobman.com/IMG_1886.png)

UICloudShareingController 是 UIKit 提供的一个用于从 CloudKit
共享记录中添加和删除人员的视图控制器。开发者仅需少量的代码，便可以拥有以下功能：

- 邀请人们查看或协作共享记录

- 设置访问权限，确定谁可以访问共享记录（只有被邀请的人或有共享链接的任何人）。

- 设置一般或个别权限（只读或读/写）。

- 取消一个或多个参与者的访问权限

- 停止参与（如果用户是参与者）。

- 停止与所有参与者共享（如果用户是共享记录的所有者）。

UICloudSharingController 提供了两个构造方法，分别用于已经生成了 CKShare 和没有生成 CKShare 的情况。

在 SwiftUI 下，用于尚未生成 CKShare 情况的构造方法在使用 UIViewControllerRepresentable
包装时异常，因此，推荐在 SwiftUI 下首先使用代码（ `share` ）手动为托管对象生成 CKShare，然后使用另一个针对已生成
CKShare 的构造方法。

UICloudSharingController 提供了若干的委托方法，我们需要在其中做一些停止共享后的善后工作。

当前版本（Xcode 13 beta 5）的 UICloudSharingController 仍有 Bug，希望能够尽快修复。

## 示例

> 我写了一个 Demo 放在 [ Github
> ](https://github.com/fatbobman/ShareData_Demo_For_CoreDataWithCloudKit)
> 上，本文中仅对其中重点进行说明。

### 项目设置

#### info. plist

在 info. plist 添加 `CKSharingSupported` ，为应用程序添加打开共享链接的能力。Xcode 13 可以直接在 `info` 中添加。

![image-20210911162206667](https://cdn.fatbobman.com/image-20210911162206667.png)

#### Signing&Capablilities

与同步本地数据一样，在 `Signing&Capabilities` 中添加对应的功能（iCloud、background），并添加
CKContainer。

![image-20210911162525003](https://cdn.fatbobman.com/image-20210911162525003-1348726.png)

### 设置 AppDelegate

为了让应用程序能够接受共享邀请，我们必须在 UIApplicationDelegate 中响应传入的共享元数据。在 UIKit lifeCycle
模式下，只需要在 AppDelegate 中的添加类似如下代码即可：

        func application(_ application: UIApplication, userDidAcceptCloudKitShareWith cloudKitShareMetadata: CKShare.Metadata) {
            let shareStore = CoreDataStack.shared.sharedPersistentStore
            let persistentContainer = CoreDataStack.shared.persistentContainer
            persistentContainer.acceptShareInvitations(from: [cloudKitShareMetadata], into: shareStore, completion: { metas,error in
                if let error = error {
                    print("accepteShareInvitation error :\(error)")
                }
            })
        }

使用 NSPersistentCloudContainer 的 `acceptShareInvitations` 方法接收 CKShare.
Metadata。

在 SwiftUI lifeCycle 模式下，该响应发生在 `UIWindowSceneDelegate` 中。因此需要在 AppDelegate
中进行转接。

    final class AppDelegate:NSObject,UIApplicationDelegate{
        func application(_ application: UIApplication,
                         configurationForConnecting connectingSceneSession: UISceneSession,
                         options: UIScene.ConnectionOptions) -> UISceneConfiguration {
            let sceneConfig = UISceneConfiguration(name: nil, sessionRole: connectingSceneSession.role)
            sceneConfig.delegateClass = SceneDelegate.self
            return sceneConfig
        }
    }

    final class SceneDelegate:NSObject,UIWindowSceneDelegate{
        func windowScene(_ windowScene: UIWindowScene, userDidAcceptCloudKitShareWith cloudKitShareMetadata: CKShare.Metadata) {
            let shareStore = CoreDataStack.shared.sharedPersistentStore
            let persistentContainer = CoreDataStack.shared.persistentContainer
            persistentContainer.acceptShareInvitations(from: [cloudKitShareMetadata], into: shareStore, completion: { metas,error in
                if let error = error {
                    print("accepteShareInvitation error :\(error)")
                }
            })
        }
    }

### Core Data Stack

CoreDataStack 的设置基本上同前几篇文章中的设置类似，需要注意的是，为了方便判断持久化存储，在 Stack 层面添加了 `privatePersistentStore` 和 `sharedPersistentStore`
，保存本地的私有数据库持久化存储以及共享数据库持久化存储。

            let dbURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!

            let privateDesc = NSPersistentStoreDescription(url: dbURL.appendingPathComponent("model.sqlite"))
            privateDesc.configuration = "Private"
            privateDesc.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: ckContainerID)
            privateDesc.cloudKitContainerOptions?.databaseScope = .private

            guard let shareDesc = privateDesc.copy() as? NSPersistentStoreDescription else {
                fatalError("Create shareDesc error")
            }
            shareDesc.url = dbURL.appendingPathComponent("share.sqlite")
            let shareDescOption = NSPersistentCloudKitContainerOptions(containerIdentifier: ckContainerID)
            shareDescOption.databaseScope = .shared
            shareDesc.cloudKitContainerOptions = shareDescOption

本地共享数据库是使用私有数据库的 Description Copy 出来的。分别为两个持久化存储设定 URL，并为共享 Description 设置 `shareDescOption.databaseScope = .shared`

为 Stack 添加了便捷方法，方便视图中的逻辑判断。

例如：

下面的代码是判断托管托管对象是否为共享数据。为了加快判断，首先判断该数据是否保存在本地共享数据库中，其次才使用 `fetchShares`
检查是否已经生成 CKShare。

        func isShared(objectID: NSManagedObjectID) -> Bool {
            var isShared = false
            if let persistentStore = objectID.persistentStore {
                if persistentStore == sharedPersistentStore {
                    isShared = true
                } else {
                    let container = persistentContainer
                    do {
                        let shares = try container.fetchShares(matching: [objectID])
                        if shares.first != nil {
                            isShared = true
                        }
                    } catch {
                        print("Failed to fetch share for \(objectID): \(error)")
                    }
                }
            }
            return isShared
        }

下面的代码是判断当前用户是否为共享数据的所有者：

        func isOwner(object: NSManagedObject) -> Bool {
            guard isShared(object: object) else { return false }
            guard let share = try? persistentContainer.fetchShares(matching: [object.objectID])[object.objectID] else {
                print("Get ckshare error")
                return false
            }
            if let currentUser = share.currentUserParticipant, currentUser == share.owner {
                return true
            }
            return false
        }

### 包装 UICloudSharingController

想更多地了解 UIViewControllerRepresentable 的使用方法，请阅读我的另一篇文章 [ 在 SwiftUI 中使用 UIKit 视图
](/zh/posts/uikitinswiftui/) 。

对 UICloudShareingController 的包装并不困难，但需要注意以下几点：

- 需保证被共享的托管对象已经创建了 CKShare。

由于 UICloudShareingController 针对没有创建 CKShare 的构造器用于
UIViewControllerRepresentable 后表现异常，对于首次共享的托管对象，我们需要在代码中先为其创建 CKShare。创建
CKShare 通常需要几秒钟，对用户体验有一定影响。我在 Demo 中也展示了另一种不通过 UIViewControllerRepresentable
调用 UICloudSharingController 的方式。

创建 CKShare 的代码如下：

    func getShare(_ note: Note) -> CKShare? {
            guard isShared(object: note) else { return nil }
            guard let share = try? persistentContainer.fetchShares(matching: [note.objectID])[note.objectID] else {
                print("Get ckshare error")
                return nil
            }
            share[CKShare.SystemFieldKey.title] = note.name
            return share
        }

- 需要保证 CKShare 的 `CKShare.SystemFieldKey.title` 元数据有值，否则将无法通过邮件、信息等进行共享。内容可以自己定义，能够表示清楚你要共享的内容即可

  func makeUIViewController(context: Context) -> UICloudSharingController {
  share[CKShare.SystemFieldKey.title] = note.name
  let controller = UICloudSharingController(share: share, container: container)
  controller.modalPresentationStyle = .formSheet
  controller.delegate = context.coordinator
  context.coordinator.note = note
  return controller
  }

- Coordinator 的生命周期要长于 UIViewControllerRepresentable。

由于共享操作需要网络操作，通常数秒之后才能返回结果。UICloudSharingController 在发送共享链接后即会销毁，如果 Coordinator
被定义在 UIViewControllerRepresentable 中，会导致返回结果后，无法回调委托方法。

- 委托方法 `itemTitle` 需要返回内容，否则邮件共享无法唤醒

- 在委托方法 `cloudSharingControllerDidStopSharing` 中处理停止共享的善后问题

### 发起共享

在对托管对象调用 UICloudSharingController 前需要首先判断是否已经为其创建了 CKShare，如果没有需要先创建
CKShare。对已经共享的托管对象调用
UICloudSharingController，视图将显示当前共享关系的所有参与者信息，并可修改共享方式以及用户权限。

            if isShared {
                  showShareController = true
              } else {
                  Task.detached {
                     await createShare(note)
                          }
              }

采用 `Task.detached` 避免生成 CKShare 时导致线程阻塞。

另外，Demo 中还有一个直接调用 UICloudSharingController 的方式（已被注释掉），这种方式的用户体验更好，不过手段不是很
SwiftUI 化。

    private func openSharingController(note: Note) {
            let keyWindow = UIApplication.shared.connectedScenes
                .filter { $0.activationState == .foregroundActive }
                .map { $0 as? UIWindowScene }
                .compactMap { $0 }
                .first?.windows
                .filter { $0.isKeyWindow }.first

            let sharingController = UICloudSharingController {
                (_, completion: @escaping (CKShare?, CKContainer?, Error?) -> Void) in

                stack.persistentContainer.share([note], to: nil) { _, share, container, error in
                    if let actualShare = share {
                        note.managedObjectContext?.performAndWait {
                            actualShare[CKShare.SystemFieldKey.title] = note.name
                        }
                    }
                    completion(share, container, error)
                }
            }

            keyWindow?.rootViewController?.present(sharingController, animated: true)
        }

### 检查权限

在应用程序中，对托管对象进行修改删除操作前，请务必首先判断操作权限。只对有读写权限的数据开启修改功能。

       if canEdit {
             Button {
                withAnimation {
                    stack.addMemo(note)
                  }
             }
             label: {
                 Image(systemName: "plus")
                  }
       }

        func canEdit(object: NSManagedObject) -> Bool {
            return persistentContainer.canUpdateRecord(forManagedObjectWith: object.objectID)
        }

> 可以在我的 [ Github
> ](https://github.com/fatbobman/ShareData_Demo_For_CoreDataWithCloudKit)
> 上下载全部的代码。

## 调试须知

相较于同步本地数据库、同步公共数据库，调试共享数据的难度更大，对开发者的心态考验也更多。

由于无法在模拟器上进行调试，开发者需要准备至少两台拥有不同 iCloud 账户的设备。

可能是仍处于测试阶段，共享同步的响应速度要远慢于单纯的同步本地私有数据库。通常在本地创建一个数据，需要数十秒才能同步到云端的私有数据库。参与者在接收同步邀请后，两台设备的
CKShare 数据也需要一段时间才能刷新。

如果感觉一定时间后数据仍未同步，请将应用程序切换至后台再切换回来，有些时候甚至需要对应用程序进行冷启动。

另外，某些已知 Bug 也会导致异常状况，请在调试前首先阅读下面的已知问题，避开我在调试时踩过的坑。

## 已知问题

1. 共享时，如设置成任何人可接收，参与者将无法获取到共享前托管对象的关系数据，且只有在共享的托管对象修改后（或添加新的关系数据后）才会在参与者的应用程序中显示。不知道是 Bug 还是苹果有意为之。

2. 共享时，如设置成任何人可接收，尽量不要直接在 UICloudSharingController 中通过信息、邮件等方式发送到另一个有效的 iCloud 账户上，否则大概率无法打开该共享链接，会显示共享已取消。可以选择拷贝链接然后再通过信息、邮件发送即可解决该问题。

3. 尽量通过信息或系统邮件打开共享链接（将启动 Deep link）。其他的手段可能会直接通过浏览器访问该链接，导致无法接受邀请。

4. 记录所有者通过 UICloudSharingController 停止某个参与者的共享权限后，UICloudSharingController 无法正常刷新修改后的 CKShare，导致无法再次唤醒 UICloudSharingController。由于没有对应的委托方法，因此当前没有直接的解决方案。正常的逻辑是，在修改 CKShare 后，服务器返回新的 CKShare，通过 `persistUpdatedShare` 更新本地 Catch

5. 数据所有者通过 UICloudSharingController 停止共享后（停止全部共享），UICloudSharingController 会出现与前一条类似的问题——不会删除本地 Catch 中 CKShare。这个问题目前可以通过在 `cloudSharingControllerDidStopSharing` 中，对停止共享的托管对象进行 Deep Copy（深拷贝，包含所有关系数据），然后再执行 `purgeObjectsAndRecordsInZone` 解决。如果数据量较多，该解决方案的执行时间会较长。希望苹果可以推出更加直接的善后方法。

6. 所有者取消某个参与者的共享权限后，参与者的 CKShare 刷新不完整。参与者设备上的共享数据可能会消失（在应用程序下次冷启动后一定会消失），也可能不消失。此时如果参与者对共享数据进行操作，会导致应用程序崩溃，影响用户体验。

7. 参与者通过 UICloudSharingController 取消自己的共享后，CKShare 刷新不完全，现象同上一条一样。不过该问题可以在 `cloudSharingControllerDidStopSharing` 通过删除参与者设备上的托管对象来解决。

其中，4、5、7 条都可以通过创建自己的 UICloudSharingController 实现得以避免。

所有的问题和异常我都已经向苹果提交了 feedback。如果你在调试中也出现了类似或其他的异常情况，希望也能及时提交
feedback，督促并帮助苹果及时改正。

## 总结

尽管仍未完全成熟，但使用 Core Data with CloudKit 来共享数据仍是一个令人惊喜的功能。我对其在 [ 健康笔记 3
](/healthnotes/) 中的表现充满了期待和信心。

从开启本系列文章开始，完全没有想到整个过程竟需耗费如此多的时间和精力。不过从整理和写作过程中我也受益颇多，对之前掌握不扎实的知识通过反复的强化加深了认识。

# 聊聊 Combine 和 async-await 之间的合作

在 Xcode 13.2 中，苹果完成了 async/await 的向前部署（Back-deploying）工作，将最低的系统要求降低到了 iOS
13（macOS Catalina），这一举动鼓舞了越来越多的人开始尝试使用 async/await
进行开发。当大家在接触了异步序列（AsyncSequence）后，会发现它同 Combine 的表现有些接近，尤其结合近两年 Combine
框架几乎没有什么变化，不少人都提出了疑问：苹果是否打算使用 AsyncSequence 和 AsyncStream 替代 Combine。

恰巧我在最近的开发中碰到了一个可能需要结合 Combine 和 async/await 的使用场景，通过本文来聊聊 Combine 和
async/await 它们之间各自的优势、是否可以合作以及如何合作等问题。

## 需要解决的问题

在最近的开发中，我碰到了这样一个需求：

- 在 app 的生命周期中，会不定期的产生一系列事件，事件的发生频率不定、产生的途径不定
- 对每个事件的处理都需要消耗不小的系统资源，且需要调用系统提供的 async/await 版本的 API
- app 对事件的处理结果时效性要求不高
- 需要限制事件处理的系统消耗，避免同时处理多个事件
- 不考虑使用 GCD 或 OperationQueue

对上述的需求稍加分析，很快就可以确立解决问题的方向：

- Combine 在观察和接收事件方面表现的非常出色，应该是解决需求第一点的不二人选
- 在解决方案中必然会使用到 async/await 的编程模式

需要解决的问题就只剩下两个：

- 如何将事件处理串行化（必须处理完一个事件后才能处理下一个事件）
- 如何将 Combine 和 async/await 结合使用

## Combine 和 AsyncSequence 之间的比较

由于 Combine 同 AsyncSequence 之间存在不少相似之处，有不少开发者会认为 AsyncSequence 可能取代 Combine，例如：

- 两者都允许通过异步的方式处理未来的值
- 两者都允许开发者使用例如 map、flatMap 等函数对值进行操作
- 当发生错误时，两者都会结束数据流

但事实上，它们之间还是有相当的区别。

### 事件的观察与接收

Combine 是为响应式编程而生的工具，从名称上就可以看出，它非常擅长将不同的事件流进行变形和合并，生成新的事件流。Combine
关注于对变化的响应。当一个属性发生变化，一个用户点击了按钮，或者通过 NotificationCenter 发送了一个通知，开发者都可以通过 Combine
提供了的内置工具做出及时处理。

通过 Combine 提供的
Subject（PassthroughSubject、CurrentValueSubject），开发者可以非常方便的向数据流中注入值，当你的代码是以命令式风格编写的时候，Subject
就尤为显得有价值。

在 async/await 中，通过 AsyncSequence，我们可以观察并接收网络流、文件、Notification 等方面的数据，但相较于
Combine，仍缺乏数据绑定以及类似 Subject 的数据注入能力。

在对事件的观察与接收方面，Combine 占有较大优势。

### 关于数据处理、变形的能力

仅从用于数据处理、变形的方法数量上来看，AsyncSequence 相较 Combine 还是有不小的差距。但 AsyncSequence 也提供了一些
Combine 尚未提供，且非常实用的方法和变量，例如：characters、lines 等。

由于侧重点不同，即使随着时间的推移两者增加了更多的内置方法，在数据处理和变形方面也不会趋于一致，更大的可能性是不断地在各自擅长的领域进行扩展。

### 错误处理方式

在 Combine 中，明确地规定了错误值 Failure 的类型，在数据处理链条中，除了要求 Output
数据值类型一致外，还要求错误值的类型也要相互匹配。为了实现这一目标，Combine
提供了大量的用于处理错误类型的操作方法，例如：mapError、setFailureType、retry 等。

使用上述方法处理错误，可以获得编译器级别的保证优势，但在另一方面，对于一个逻辑复杂的数据处理链，上述的错误处理方式也将导致代码的可读性显著下降，对开发者在错误处理方面的掌握要求也比较高。

async/await 则采用了开发者最为熟悉的 throw-catch 方式来进行错误处理。基本没有学习难度，代码也更符合大多数人的阅读习惯。

两者在错误处理上功能没有太大区别，主要体现在处理风格不同。

### 生命周期的管理

在 Combine 中，从订阅开始，到取消订阅，开发者通过代码可以对数据链的生命周期做清晰的定义。当使用 AsyncSequence
时，异步序列生命周期的表述则没有那么的明确。

### 调度与组织

在 Combine 中，开发者不仅可以通过指定调度器（scheduler），显式地组织异步事件的行为和地点，而且 Combine
还提供了控制管道数量、调整处理频率等多维度的处理手段。

AsyncSequence 则缺乏对于数据流的处理地点、频率、并发数量等控制能力。

> 下文中，我们将尝试解决前文中提出的需求，每个解决方案均采用了 Combine + async/await 融合的方式。

## 方案一

在 Combine 中，可以使用两种手段来限制数据的并发处理能力，一种是通过设定 flatMap 的 maxPublishers，另一种则是通过自定义
Subscriber。本方案中，我们将采用 flatMap 的方式来将事件的处理串行化。

在 Combine 中调用异步 API，目前官方提供的方法是将上游数据包装成 Future Publisher，并通过 flatMap 进行切换。

在方案一中，通过将 flatMap、Deferred（确保只有在订阅后 Future 才执行）、Future 结合到一起，创建一个新的
Operator，以实现我们的需求。

    public extension Publisher {
        func task<T>(maxPublishers: Subscribers.Demand = .unlimited,
                         _ transform: @escaping (Output) async -> T) -> Publishers.FlatMap<Deferred<Future<T, Never>>, Self> {
            flatMap(maxPublishers: maxPublishers) { value in
                Deferred {
                    Future { promise in
                        Task {
                            let output = await transform(value)
                            promise(.success(output))
                        }
                    }
                }
            }
        }
    }

    public extension Publisher where Self.Failure == Never {
        func emptySink() -> AnyCancellable {
            sink(receiveValue: { _ in })
        }
    }

> 鉴于篇幅，完整的代码（支持 Error、SetFailureType）版本，请访问 [ Gist
> ](https://gist.github.com/fatbobman/45ead2eac52c5f6f18f9f51cf294745f)
> ，本方案的代码参考了 Sundell 的 [ 文章 ](https://www.swiftbysundell.com/articles/calling-
> async-functions-within-a-combine-pipeline/) 。

使用方法如下：

    var cancellables = Set<AnyCancellable>()

    func asyncPrint(value: String) async {
        print("hello \(value)")
        try? await Task.sleep(nanoseconds: 1000000000)
    }

    ["abc","sdg","353"].publisher
        .task(maxPublishers:.max(1)){ value in
            await asyncPrint(value:value)
        }
        .emptySink()
        .store(in: &cancellables)
    // Output
    // hello abc
    // 等待 1 秒
    // hello sdg
    // 等待 1 秒
    // hello 353

假如将将上述代码中的 `["abc","sdg","353"].publisher` 更换成 PassthoughSubject 或
Notification ，会出现数据遗漏的情况。这个状况是因为我们限制了数据的并行处理数量，从而导致数据的消耗时间超过了数据的生成时间。需要在
Publisher 的后面添加 buffer，对数据进行缓冲。

    let publisher = PassthroughSubject<String, Never>()
    publisher
        .buffer(size: 10, prefetch: .keepFull, whenFull: .dropOldest) // 缓存数量和策略根据业务的具体情况确定
        .task(maxPublishers: .max(1)) { value in
            await asyncPrint(value:value)
        }
        .emptySink()
        .store(in: &cancellables)

    publisher.send("fat")
    publisher.send("bob")
    publisher.send("man")

## 方案二

在方案二中，我们将采用的自定义 Subscriber 的方式来限制并行处理的数量，并尝试在 Subscriber 中调用 async/await 方法。

创建自定义 Subscriber：

    extension Subscribers {
        public class OneByOneSink<Input, Failure: Error>: Subscriber, Cancellable {
            let receiveValue: (Input) -> Void
            let receiveCompletion: (Subscribers.Completion<Failure>) -> Void

            var subscription: Subscription?

            public init(receiveCompletion: @escaping (Subscribers.Completion<Failure>) -> Void,
                 receiveValue: @escaping (Input) -> Void) {
                self.receiveCompletion = receiveCompletion
                self.receiveValue = receiveValue
            }

            public func receive(subscription: Subscription) {
                self.subscription = subscription
                subscription.request(.max(1)) // 订阅时申请数据量
            }

            public func receive(_ input: Input) -> Subscribers.Demand {
                receiveValue(input)
                return .max(1) // 数据处理结束后，再此申请的数据量
            }

            public func receive(completion: Subscribers.Completion<Failure>) {
                receiveCompletion(completion)
            }

            public func cancel() {
                subscription?.cancel()
                subscription = nil
            }
        }
    }

在 `receive(subscription: Subscription)` 中，使用 `subscription.request(.max(1))` 设定了订阅者订阅时请求的数据量，在 `receive(_ input: Input)` 中，使用 `return .max(1)`
设定了每次执行完 `receiveValue` 方法后请求的数据量。通过上述方式，我们创建了一个每次申请一个值，逐个处理的订阅者。

但当我们在 `receiveValue` 方法中使用 Task 调用 async/await
代码时会发现，由于没有提供回调机制，订阅者将无视异步代码执行完成与否，调用后直接会申请下一个值，这与我们的需求不符。

在 Subscriber 中可以通过多种方式来实现回调机制，例如回调方法、Notification、@Published 等。下面的代码中我们使用
Notification 进行回调通知。

    public extension Subscribers {
        class OneByOneSink<Input, Failure: Error>: Subscriber, Cancellable {
            let receiveValue: (Input) -> Void
            let receiveCompletion: (Subscribers.Completion<Failure>) -> Void

            var subscription: Subscription?
            var cancellable: AnyCancellable?

            public init(notificationName: Notification.Name,
                        receiveCompletion: @escaping (Subscribers.Completion<Failure>) -> Void,
                        receiveValue: @escaping (Input) -> Void) {
                self.receiveCompletion = receiveCompletion
                self.receiveValue = receiveValue
                cancellable = NotificationCenter.default.publisher(for: notificationName, object: nil)
                    .sink(receiveValue: { [weak self] _ in self?.resume() })
                    // 在收到回调通知后，继续向 Publisher 申请新值
            }

            public func receive(subscription: Subscription) {
                self.subscription = subscription
                subscription.request(.max(1))
            }

            public func receive(_ input: Input) -> Subscribers.Demand {
                receiveValue(input)
                return .none // 调用函数后不继续申请新值
            }

            public func receive(completion: Subscribers.Completion<Failure>) {
                receiveCompletion(completion)
            }

            public func cancel() {
                subscription?.cancel()
                subscription = nil
            }

            private func resume() {
                subscription?.request(.max(1))
            }
        }
    }

    public extension Publisher {
        func oneByOneSink(
            _ notificationName: Notification.Name,
            receiveCompletion: @escaping (Subscribers.Completion<Failure>) -> Void,
            receiveValue: @escaping (Output) -> Void
        ) -> Cancellable {
            let sink = Subscribers.OneByOneSink<Output, Failure>(
                notificationName: notificationName,
                receiveCompletion: receiveCompletion,
                receiveValue: receiveValue
            )
            self.subscribe(sink)
            return sink
        }
    }

    public extension Publisher where Failure == Never {
        func oneByOneSink(
            _ notificationName: Notification.Name,
            receiveValue: @escaping (Output) -> Void
        ) -> Cancellable where Failure == Never {
            let sink = Subscribers.OneByOneSink<Output, Failure>(
                notificationName: notificationName,
                receiveCompletion: { _ in },
                receiveValue: receiveValue
            )
            self.subscribe(sink)
            return sink
        }
    }

调用：

    let resumeNotification = Notification.Name("resume")

    publisher
        .buffer(size: 10, prefetch: .keepFull, whenFull: .dropOldest)
        .oneByOneSink(
            resumeNotification,
            receiveValue: { value in
                Task {
                    await asyncPrint(value: value)
                    NotificationCenter.default.post(name: resumeNotification, object: nil)
                }
            }
        )
        .store(in: &cancellables)

由于需要回调才能完成整个处理逻辑，针对本文需求，方案一相较方案二明显更优雅。

方案二中，数据处理链是可暂停的，很适合用于需要触发某种条件才可继续执行的场景。

## 方案三

在前文中提到过，苹果已经为 Notification 提供了 AsyncSequence 的支持。如果我们只通过 NotificationCenter
来发送事件，下面的代码就直接可以满足我们的需求：

    let n = Notification.Name("event")
    Task {
        for await value in NotificationCenter.default.notifications(named: n, object: nil) {
            if let str = value.object as? String {
                await asyncPrint(value: str)
            }
        }
    }

    NotificationCenter.default.post(name: n, object: "event1")
    NotificationCenter.default.post(name: n, object: "event2")
    NotificationCenter.default.post(name: n, object: "event3")

简单的难以想象是吗？

遗憾的是，Combine 的 Subject 和其他的 Publisher 并没有直接遵循 AsyncSequence 协议。

但今年的 Combine 为 Publisher 增加了一个非常小但非常重要的功能——values。

values 的类型为 AsyncPublisher，其符合 AsyncSequence 协议。设计的目的就是将 Publisher 转换成
AsyncSequence。使用下面的代码便可以满足各种 Publisher 类型的需求：

    let publisher = PassthroughSubject<String, Never>()
    let p = publisher
            .buffer(size: 10, prefetch: .keepFull, whenFull: .dropOldest)
    Task {
        for await value in p.values {
            await asyncPrint(value: value)
        }
    }

因为 AsyncSequence 只能对数据逐个处理，因此我们无需再考虑数据的串行问题。

将 Publisher 转换成 AsyncSequence 的原理并不复杂，创建一个符合 AsyncSequence 的结构，将从 Publihser
中获取的数据通过 AsyncStream 转送出去，并将迭代器指向 AsyncStream 的迭代器即可。

我们可以用代码自己实现上面的 values 功能。下面我们创建了一个 sequence，功能表现同 values 类似。

    public struct CombineAsyncPublisher<P>: AsyncSequence, AsyncIteratorProtocol where P: Publisher, P.Failure == Never {
        public typealias Element = P.Output
        public typealias AsyncIterator = CombineAsyncPublisher<P>

        public func makeAsyncIterator() -> Self {
            return self
        }

        private let stream: AsyncStream<P.Output>
        private var iterator: AsyncStream<P.Output>.Iterator
        private var cancellable: AnyCancellable?

        public init(_ upstream: P, bufferingPolicy limit: AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded) {
            var subscription: AnyCancellable?
            stream = AsyncStream<P.Output>(P.Output.self, bufferingPolicy: limit) { continuation in
                subscription = upstream
                    .sink(receiveValue: { value in
                        continuation.yield(value)
                    })
            }
            cancellable = subscription
            iterator = stream.makeAsyncIterator()
        }

        public mutating func next() async -> P.Output? {
            await iterator.next()
        }
    }

    public extension Publisher where Self.Failure == Never {
        var sequence: CombineAsyncPublisher<Self> {
            CombineAsyncPublisher(self)
        }
    }

> 完整代码，请参阅 [ Gist
> ](https://gist.github.com/fatbobman/09954daa67f8f78cb11c0ff9f8bcb318)
> ，本例的代码参考了 Marin Todorov 的 [ 文章 ](https://trycombine.com/posts/combine-async-
> sequence-1/)

sequence 在实现上和 values 还是有微小的不同的，如果感兴趣的朋友可以使用下面的代码，分析一下它们的不同点。

    let p = publisher
        .print()  // 观察订阅器的请求情况。 values 的实现同方案二一样。
        // sequence 使用了 AsyncStream 的 buffer，因此无需再设定 buffer

    for await value in p.sequence {
        await asyncPrint(value: value)
    }

## 总结

在可以预见的未来，苹果一定会为 Combine 和 async/await 提供更多的预置融合手段。或许明后年，前两种方案就可以直接使用官方提供的 API
了。

# 用 Publish 创建博客（三）—— 插件开发

我们不仅可以利用 Publish 内置的接口来开发插件进行扩展，同时还可以使用 Publish
套件中其他的优秀库（Ink、Plot、Sweep、Files、ShellOut
等）来完成更多的创意。本文将通过几个实例（添加标签、增加属性、用代码生成内容、全文搜索、命令行部署）在展示不同扩展手段的同时向大家介绍 Publish
套件中其他的优秀成员。在阅读本文前，最好能先阅读 [ 用 Publish 创建博客（一）——入门 ](/zh/posts/publish-1/) 、 [ 用
Publish 创建博客（二）——主题开发 ](/zh/posts/publish-2/) 。对 Publish
有个基本了解。本文篇幅较长，你可以选择自己感兴趣的实战内容阅读。

## 基础

### PublishingContext

在 [ 用 Publish 创建博客（一）——入门 ](/zh/posts/publish-1/) 中我们介绍过 Publish 有两个 Content
概念。其中 `PublishingContext` 作为根容器包含了你网站项目的全部信息（ `Site` 、 `Section` 、 `Item` 、 `Page` 等）。在对 Publish 进行的大多数扩展开发时，都需要和 `PublishingContext`
打交道。不仅通过它来获取数据，而且如果要对现有数据进行改动或者添加新的 `Item` 、 `Page` 时（在 `Content` 中采用不创建
`markdown` 文件的方式）也必须要调用其提供的方法。比如 `mutateAllSections` 、 `addItem` 等。

### Pipeline 中的顺序

Publish 会逐个执行 Pipeline 中的 `Step` , 因此必须要在正确的位置放置 `Step` 和 `Plugin`
。比如需要对网站的所有数据进行汇总，则该处理过程应该放置在 `addMarkdownFiles` （数据都被添加进 `Content`
）之后；而如果想添加自己的部署（ `Deploy` ），则应放置在生成所有文件之后。下面会通过例子具体说明。

## 热身

> 下面的代码，以放置在 `Myblog` （第一篇中创建，并在第二篇中进行了修改）项目里为例。

### 准备

请将

    try Myblog().publish(withTheme: .foundation)

换成

    try Myblog().publish(using: [
        .addMarkdownFiles(), //导入 Content 目录下的 markdown 文件，并解析添加到 PublishingContent 中
        .copyResources(), //将 Resource 内容添加到 Output 中
        .generateHTML(withTheme:.foundation ), //指定模板
        .generateRSSFeed(including: [.posts]), //生成 RSS
        .generateSiteMap() //生成 Site Map
    ])

### 创建 Step

我们先通过官方的一个例子了解一下 `Step` 的创建过程。当前导航菜单的初始状态：

![image-20210203121214511](https://cdn.fatbobman.com/publish-3-changetitle-
old.png)

下面的代码将改变 SectionID。

    //当前的 Section 设置
    enum SectionID: String, WebsiteSectionID {
            // Add the sections that you want your website to contain here:
            case posts //rawValue 将影响该 Section 对应的 Content 的目录名。当前的目录为 posts
            case about //如果改成 case abot = "关于" 则目录名为“关于”，所以通常会采用下方更改 title 的方法
     }

    //创建 Step
    extension PublishingStep where Site == Myblog {
        static func addDefaultSectionTitles() -> Self {
          //name 为 step 名称，在执行该 Step 时在控制台显示
            .step(named: "Default section titles") { context in //PublishingContent 实例
                context.mutateAllSections { section in //使用内置的修改方法
                    switch section.id {
                    case .posts:
                        section.title = "文章"  //修改后的 title，将显示在上方的 Nav 中
                    case .about:
                        section.title = "关于"
                    }
                }
            }
        }
    }

将 `Step` 添加到 `main.swift` 的 `pipeline` 中：

        .addMarkdownFiles(),
        .addDefaultSectionTitles(),
        .copyResources(),

添加该 `Step` 后的导航菜单：

![image-20210203123545306](https://cdn.fatbobman.com/publish-3-title-new.png)

### Pipeline 中的位置

如果将 `addDefaultSectionTitles` 放置在 `addMarkdownFiles` 的前面，会发现 `posts` 的
title 变成了

![image-20210203123440066](https://cdn.fatbobman.com/publish-3-changetitle-
wrong-position.png)

这是因为，当前的 `Content--posts` 目录中有一个 `index.md` 文件。 `addMarkdownFiles`
会使用从该文件中解析的 `title` 来设置 `posts` 的 `Section.title` 。解决的方法有两种：

1. 向上面那样将 `addDefaultSectionTitles` 放置在 `addMarkdownFiles` 的后面
2. 删除掉 `index.md`

### 等效的 Plugin

在 [ 用 Publish 创建博客（一）——入门 ](/zh/posts/publish-1/) 中提过 `Step` 和 `Plugin`
在作用上是等效的。上面的代码用 `Plugin` 的方式编写是下面的样子：

    extension Plugin where Site == Myblog{
        static func addDefaultSectionTitles() -> Self{
            Plugin(name:  "Default section titles"){
                context in
                context.mutateAllSections { section in
                    switch section.id {
                    case .posts:
                        section.title = "文章"
                    case .about:
                        section.title = "关于"
                    }
                }
            }
        }
    }

在 `Pipeline 中` 使用下面的方式添加：

        .addMarkdownFiles(),
        .copyResources(),
        .installPlugin(.addDefaultSectionTitles()),

它们的效果完全一样。

## 实战 1：添加 Bilibili 标签解析

Publish 使用 [ Ink ](https://github.com/JohnSundell/Ink) 作为 `markdown` 的解析器。 `Ink` 作为 Publish 套件的一部分，着重点在 `markdown` 到 `HTML` 的高效转换。它让使用者可以通过添加 `modifier` 的方式，对 `markdown` 转换 `HTML` 的过程进行定制和扩展。 `Ink` 目前并不支持全部的 `markdonw` 语法，太复杂的它不支持（而且语法支持目前是锁死的，如想扩充必须 fork `Ink` 代码，自行添加）。

在本例中我们尝试为如下 `markdown` 的 `codeBlock` 语法添加新的转义功能：

![image-20210203142914881](https://cdn.fatbobman.com/publish-3-bilibili-
mardown-code.png)

`aid` 为 B 站视频的 `aid` 号码， `danmu` 为 `弹幕` 开关

让我们首先创建一个 `Ink` 的 `modifier`

    /*
    每个 modifier 对应一个 markdown 语法类型。
    目前支持的类型有：metadataKeys,metadataValues,blockquotes,codeBlocks,headings
             horizontalLines,html,images,inlineCode,links,lists,paragraphs,tables
    */
    var bilibili = Modifier(target: .codeBlocks) { html, markdown in
         // html 为 Ink 默认的 HTML 转换结果，markdown 为该 target 对应的原始内容
         // firstSubstring 是 Publish 套件中的 Sweep 提供的快速配对方法。
        guard let content = markdown.firstSubstring(between: .prefix("```bilibili\n"), and: "\n```") else {
            return html
        }
        var aid: String = ""
        var danmu: Int = 1
        // scan 也是 Sweep 中提供另一种配对获取方式，下面的代码是获取 aid: 和换行之间的内容
        content.scan(using: [
            Matcher(identifier: "aid: ", terminator: "\n", allowMultipleMatches: false) { match, _ in
                aid = String(match)
            },
            Matcher(identifiers: ["danmu: "], terminators: ["\n", .end], allowMultipleMatches: false) {
                match,
                _ in
                danmu = match == "true" ? 1 : 0
            },
        ])
        //modifier 的返回值为 HTML 代码，本例中我们不需要使用 Ink 的默认转换，直接全部重写
        //在很多的情况下，我们可能只是在默认转换的 html 结果上做出一定的修改即可
        return
            """
            <div style="position: relative; padding: 30% 45% ; margin-top:20px;margin-bottom:20px">
            <iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=\(aid)&page=1&as_wide=1&high_quality=1&danmaku=\(danmu)" frameborder="no" scrolling="no"></iframe>
            </div>
            """
    }

通常情况下，我们会将上面的 `modifier` 包裹在一个 `Plugin` 中，通过 `installPlugin`
来注入，不过现在我们直接创建一个新的 `Step` 专门来加载 `modifier`

    extension PublishingStep{
        static func addModifier(modifier:Modifier,modifierName name:String = "") -> Self{
            .step(named: "addModifier \(name)"){ context in
                context.markdownParser.addModifier(modifier)
            }
        }
    }

现在就可以在 `main.swift` 的 `Pipeline` 中添加了

    .addModifier(modifier: bilibili,modifierName: "bilibili"), //bilibili 视频
    .addMarkdownFiles(),

`modifier` 在添加后并不会立即使用，当 Pipeline 执行到 `addMarkdownFiles` 对 `markdown`
文件进行解析时才会调用。因此 `modifier` 的位置一定要放在解析动作的前面。

`Ink` 允许我们添加多个 `modifier` ，即使是同一个 `target` 。因此尽管我们上面的代码是占用了对 `markdown` 的 `codeBlocks` 的解析，但只要我们注意顺序，就都可以和平共处。比如下面：

     .installPlugin(.highlightJS()), //语法高亮插件，也是采用 modifier 方式，对应的也是 codeBlock
     .addModifier(modifier: bilibili), //在这种状况下，bilibili 必须在 highlightJS 下方。

`Ink` 将按照 `modifier` 的添加顺序来调用。添加该插件后的效果

![publish-3-bilibili-videodemo](https://cdn.fatbobman.com/publish-3-bilibili-
videodemo.png)

上面代码在我提供的 [ 范例模板 ](https://github.com/fatbobman/PublishThemeForFatbobmanBlog)
中可以找到

通过 `modifier` 扩展 `markdown` 到 `HTML` 的转义是 Publish 中很常见的一种方式。几乎所有的语法高亮、 `style` 注入等都利用了这个手段。

## 实战 2：为 Tag 添加计数属性

在 Publish 中，我们只能获取 `allTags` 或者每个 `Item` 的 `tags` ，但并不提供每个 `tag`
下到底有几个 `Item` 。本例我们便为 `Tag` 增加 `count` 属性。

    //由于我们并不想在每次调用 tag.count 的时候进行计算，所以一次性将所有的 tag 都提前计算好
    //计算结果通过类属性或结构属性来保存，以便后面使用
    struct CountTag{
        static var count:[Tag:Int] = [:]
        static func count<T:Website>(content:PublishingContext<T>){
            for tag in content.allTags{
              //将计算每个 tag 下对应的 item, 放置在 count 中
                count[tag] =  content.items(taggedWith: tag).count
            }
        }
    }

    extension Tag{
        public var count:Int{
            CountTag.count[self] ?? 0
        }
    }

创建一个调用在 `Pipeline` 中激活计算的 `Plugin`

    extension Plugin{
        static func countTag() -> Self{
            return Plugin(name: "countTag"){ content in
                return CountTag.count(content: content)
            }
        }
    }

在 `Pipeline` 中加入

    .installPlugin(.countTag()),

现在我们就可在主题中直接通过 `tag.count` 来获取所需数据了，比如在主题方法 `makeTagListHTML` 中：

    .forEach(page.tags.sorted()) { tag in
           .li(
           .class(tag.colorfiedClass), //tag.colorfieldClass 也是通过相同手段增加的属性，在文章最后会有该插件的获取地址
                  .a(
                   .href(context.site.path(for: tag)),
                   .text("\(tag.string) (\(tag.count))")
                   )
              )
      }

显示结果

![image-20210203104002714](https://cdn.fatbobman.com/publish-3-tagCount.png)

## 实战 3：将文章按月份汇总

在 [ Publish 创建博客（二）——主题开发 ](/zh/posts/publish-2/) 中我们讨论过目前 Publish
的主题支持的六种页面，其中有对 `Item` 以及 `tag` 的汇总页面。本例演示一下如何用代码创建主题不支持的其他页面类型。

本例结束时，我们将让 Publish 能够自动生成如下的页面：

![publish-3-dateAchive](https://cdn.fatbobman.com/publish-3-dateAchive-2343299.png)

    //创建一个 Step
    extension PublishingStep where Site == FatbobmanBlog{
        static func makeDateArchive() -> Self{
            step(named: "Date Archive"){ content in
                var doc = Content()
                 /*创建一个 Content，此处的 Content 是装载页面内容的，不是 PublishingContext
                  Publish 在使用 addMarkdownFiles 导入 markdown 文件时，会为每个 Item 或 Page 创建 Content
                  由于我们是使用代码直接创建，所以不能使用 markdown 语法，必须直接使用 HTML
                 */
                doc.title = "时间线"
                let archiveItems = dateArchive(items: content.allItems(sortedBy: \.date,order: .descending))
                 //使用 Plot 生成 HTML，第二篇文章有 Plot 的更多介绍
                let html = Node.div(
                    .forEach(archiveItems.keys.sorted(by: >)){ absoluteMonth in
                        .group(
                            .h3(.text("\(absoluteMonth.monthAndYear.year) 年、(absoluteMonth.monthAndYear.month) 月")),
                            .ul(
                                .forEach(archiveItems[absoluteMonth]!){ item in
                                    .li(
                                        .a(
                                            .href(item.path),
                                            .text(item.title)
                                        )
                                    )
                                }
                            )
                        )
                    }
                )
                //渲染成字符串
                doc.body.html = html.render()
                //本例中直接生成了 Page，也可以生成 Item，Item 需在创建时指定 SectionID 以及 Tags
                let page = Page(path: "archive", content:doc)
                content.addPage(page)
            }
        }
        //对 Item 按月份汇总
        fileprivate static func dateArchive(items:[Item<Site>]) -> [Int:[Item<Site>]]{
            let result = Dictionary(grouping: items, by: {$0.date.absoluteMonth})
            return result
        }
    }

    extension Date{
        var absoluteMonth:Int{
            let calendar = Calendar.current
            let component = calendar.dateComponents([.year,.month], from: self)
            return component.year! * 12 + component.month!
        }
    }

    extension Int{
        var monthAndYear:(year:Int,month:Int){
            let month = self % 12
            let year = self / 12
            return (year,month)
        }
    }

由于该 `Step` 需要对 `PublishingContent` 中的所有 `Item` 进行汇总，所以在 `Pipeline`
中应该在所有内容都装载后再执行

    .addMarkdownFiles(),
    .makeDateArchive(),

上面的代码可以在 [ Github
](https://github.com/fatbobman/Archive_Article_By_Month_Publish_Plugin) 下载。

## 实战 4：给 Publish 添加搜索功能

谁不想让自己的 Blog 支持全文搜索呢？对于多数的静态页面来说（比如 github. io），是很难依靠服务端来实现的。

下面的代码是在参照 [ local-search-engine-in-Hexo ](https://github.com/wzpan/hexo-
generator-search) 的方案实现的。 `local-search-engin` 提出的解决方式是，将网站的全部需检索文章内容生成一个 `xml` 或 `json` 文件。用户搜索前，自动从服务端下载该文件，通过 javascript 代码在本地完成搜索工作。 [ javascripte
代码 ](https://github.com/wzpan/hexo-theme-
freemind/blob/master/source/js/search.js) 使用的是 `hexo-theme-freemind` 创建的。另外
Liam Huang 的这篇 [ 博客 ](https://liam.page/2017/09/21/local-search-engine-in-
Hexo-site/) 也给了我很大的帮助。

最后实现的效果是这样的：

video

创建一个 `Step` 用来在 `Pipeline` 的末端生成用于检索的 `xml` 文件。

    extension PublishingStep{
        static func makeSearchIndex(includeCode:Bool = true) -> PublishingStep{
            step(named: "make search index file"){ content in
                let xml = XML(
                    .element(named: "search",nodes:[
                        //之所以将这个部分分开写，是因为有时候编译器对于复杂一点的 DSL 会 TimeOut
                        //提示编译时间过长。分开则完全没有问题。这种情况在 SwiftUI 中也会遇到
                        .entry(content:content,includeCode: includeCode)
                    ])
                )
                let result = xml.render()
                do {
                    try content.createFile(at: Path("/Output/search.xml")).write(result)
                }
                catch {
                    print("Failed to make search index file error:\(error)")
                }
            }
        }
    }

    extension Node {
        //这个 xml 文件的格式是 local-search-engin 确定的，这里使用 Plot 把网站内容转换成 xml
        static func entry<Site: Website>(content:PublishingContext<Site>,includeCode:Bool) -> Node{
            let items = content.allItems(sortedBy: \.date)
            return  .forEach(items.enumerated()){ index,item in
                .element(named: "entry",nodes: [
                    .element(named: "title", text: item.title),
                    .selfClosedElement(named: "link", attributes: [.init(name: "href", value: "/" + item.path.string)] ),
                    .element(named: "url", text: "/" + item.path.string),
                    .element(named: "content", nodes: [
                        .attribute(named: "type", value: "html"),
                        //为 Item 增加了 htmlForSearch 方法
                        //由于我的 Blog 的文章中包含不少代码范例，所以让使用者选择是否在检索文件中包含 Code。
                        .raw("<![CDATA[" + item.htmlForSearch(includeCode: includeCode) + "]]>")
                    ]),
                    .forEach(item.tags){ tag in
                        .element(named:"tag",text:tag.string)
                    }
                ])
            }
        }
    }

我需要再称赞一下 [ Plot ](https://github.com/JohnSundell/Plot) ，它让我非常轻松地完成了 `xml`
的创建工作。

    extension Item{
        public func htmlForSearch(includeCode:Bool = true) -> String{
            var result = body.html
            result = result.replacingOccurrences(of: "]]>", with: "]>")
            if !includeCode {
            var search = true
            var check = false
            while search{
                check = false
                //使用 Ink 来获取配对内容
                result.scan(using: [.init(identifier: "<code>", terminator: "</code>", allowMultipleMatches: false, handler: { match,range in
                    result.removeSubrange(range)
                    check = true
                })])
                if !check {search = false}
            }
            return result
        }
    }

创建 `搜索框` 和 `搜索结果容器` :

    //里面的 id 和 class 由于要和 javascript 配合，需保持现状
    extension Node where Context == HTML.BodyContext {
        //显示搜索结果的 Node
        public static func searchResult() -> Node{
            .div(
                .id("local-search-result"),
                .class("local-search-result-cls")
            )
        }

        //显示搜索框的 Node
        public static func searchInput() -> Node{
            .div(
            .form(
                .class("site-search-form"),
                .input(
                    .class("st-search-input"),
                    .attribute(named: "type", value: "text"),
                    .id("local-search-input"),
                    .required(true)
                    ),
                .a(
                    .class("clearSearchInput"),
                    .href("javascript:"),
                    .onclick("document.getElementById('local-search-input').value = '';")
                )
            ),
            .script(
                .id("local.search.active"),
                .raw(
                """
                var inputArea       = document.querySelector("#local-search-input");
                inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
                inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
                """
                )
            ),
                .script(
                    .raw(searchJS) //完整的代码后面可以下载
                )
            )
        }
    }

本例中，我将搜索功能设置在标签列表的页面中（更多信息查看 [ 主题开发 ](/zh/posts/publish-2/) ），因此在 `makeTagListHTML` 中将上面两个 `Node` 放到自己认为合适的地方。

由于搜索用的 javascript 需要用到 `jQuery` ，所以在 `head` 中添加了 jQuery 的引用（通过覆写了 `head`
，当前只为 `makeTagListHTML` 添加了引用）。

在 Pipeline 中加入

    .makeSearchIndex(includeCode: false), //根据自己需要决定是否索引文章中的代码

完整的代码可以在 [ Github ](https://github.com/fatbobman/local-search-engine-for-
Publish) 下载。

## 实战 5：部署

最后这个实例略微有点牵强，主要是为了介绍 Publish 套件中的另外一员 [ ShellOut
](https://github.com/JohnSundell/ShellOut) 。

`ShellOut` 是一个很轻量的库，它的作用是方便开发者从 Swift 代码中调用脚本或命令行工具。在 Publish 中，使用 `publish
deploy` 进行 Github 部署的代码便使用了这个库。

    import Foundation
    import Publish
    import ShellOut

    extension PublishingStep where Site == FatbobmanBlog{
        static func uploadToServer() -> Self{
            step(named: "update files to fatbobman.com"){ content in
                print("uploading......")
                do {
                    try shellOut(to: "scp -i ~/.ssh/id_rsa -r  ~/myBlog/Output web@112.239.210.139:/var/www")
                    //我是采用 scp 部署的，你可以用任何你习惯的方式
                }
                catch {
                    print(error)
                }
            }
        }
    }

在 `main.swift` 添加：

    var command:String = ""
    if CommandLine.arguments.count > 1 {
        command = CommandLine.arguments[1]
    }

    try MyBlog().publish(
      .addMarkdownFiles(),
      ...
      .if(command == "--upload", .uploadToServer())
    ]

执行 `swift run MyBlog --upload` 即可完成网站生成+上传（MyBlog 为你的项目名称）

## 其他的插件资源

目前 Publish 的插件和主题在互联网上能够找到的并不很多，主要集中在 [ Github 的#publish-plugin
](https://github.com/topics/publish-plugin?l=swift) 上。

其中使用量比较大的有：

- [ SplashPublishPlugin ](https://github.com/JohnSundell/SplashPublishPlugin) 代码高亮
- [ HighlightJSPublishPlugin ](https://github.com/alex-ross/HighlightJSPublishPlugin) 代码高亮
- [ ColorfulTagsPublishPlugin ](https://github.com/Ze0nC/ColorfulTagsPublishPlugin) 给 Tag 添加颜色

如果想在 Github 上分享你制作的 plugin，请务必打上 `publish-plugin` 标签以便于大家查找

## 最后

就在即将完成这篇稿件的时候，手机上收到了 `赵英俊`
因病过世的新闻。英年早逝，令人唏嘘。回想到自己这些年经历的治疗过程，由衷地感觉平静、幸福的生活真好。

在使用 Publish 的这些天，让我找到了装修房子的感觉。虽然不一定做的多好，但网站能按自己的想法逐步变化真是乐趣无穷。

# 健康笔记 2.0 正式版完成了！

经过了大半年的积累和准备，持续了 2 个月的开发，健康笔记 2.0 在昨天上线了。

本次开发，我重写了健康笔记的全部代码，最后的结果个人还是比较满意的。

苹果在 2020 年无论从 iOS, Swift, SwiftUI 还是 Xcode 几个方面改进还是显著的，对我的帮助很大。

无论从功能、性能、UI 表现上，2.0 版都比 1.0 版有了较大提高。

在这里可以下载 [ ![pic](https://cdn.fatbobman.com/appStoreIcon.svg)
](https://apps.apple.com/us/app/health-notes-2/id1534513553)

# SwiftUI 与 Core Data —— 安全地响应数据

保证应用不因 Core Data
的原因导致意外崩溃是对开发者的起码要求。本文将介绍可能在视图中产生严重错误的原因，如何避免，以及在保证视图对数据变化实时响应的前提下如何为使用者提供更好、更准确的信息。由于本文会涉及大量前文中介绍的技巧和方法，因此最好一并阅读。

- [ SwiftUI 与 Core Data —— 问题 ](/zh/posts/modern-core-data-problem/)
- [ SwiftUI 与 Core Data —— 数据定义 ](/zh/posts/modern-core-data-data-definition/)
- [ SwiftUI 与 Core Data —— 数据获取 ](/zh/posts/modern-core-data-fetcher/)

> 可以在 [ 此处 ](https://github.com/fatbobman/Todo) 获取演示项目 Todo 的代码

## 托管对象与可选值

Core Data 实体属性的可选性理念早于 Swift 的存在，允许属性暂时无效。例如，当你创建一个带有字符串属性的新对象时，初始值（
在没有默认值的情况下 ）是 nil，这在对象被验证之前（ 通常在 save 时 ）是没有问题的。

当开发者在模型编辑器中为属性设置了默认值（ 取消可选 ），在 Xcode 自动生成的托管对象类定义代码中仍会将不少类型声明为可选值类型。通过手动修改类型（
将 String? 修改为 String ）当声明代码可以部分改善在视图中使用托管对象的友善度。

相较于将具有默认值的属性声明为可选值类型（ 例如 String ），数值属性的声明则更加令人困惑。例如下面的 count 属性（ Integer 16
）在模型编辑器中被设定为可选，但在生成的代码中仍将为非可选值类型（ Int 16 ）。

![image-20221212090247999](https://cdn.fatbobman.com/image-20221212090247999.png)

![image-20221212090306573](https://cdn.fatbobman.com/image-20221212090306573.png)

而且，开发者无法通过更改声明代码将该属性类型修改为 Int 16? 。

![image-20221212090739291](https://cdn.fatbobman.com/image-20221212090739291.png)

这意味着，开发者在实体的某些属性类型上将失去 Swift 中一个极有特色且功能强大的可选值能力。

之所以出现上述的情况，是因为 Xcode 中模型编辑器中的 optional 并非对应 Swift 语言中的可选值。Core Data 受限于
Objective-C 中可表达的类型限制，在即使使用了标量转换的情况下（ Scalar ）也不具备与 Swift 原生类型对应的能力。

如果取消标量类型，我们可以让模型编辑器生成支持可选值的特定类型（ 例如 NSNumber? ）：

![image-20221212092612578](https://cdn.fatbobman.com/image-20221212092612578.png)

![image-20221212092628708](https://cdn.fatbobman.com/image-20221212092628708.png)

开发者可以通过为托管对象声明计算属性实现在 NSNumber? 与 Int 16? 之间的转换。

可能开发者会有这样的疑问，假如某个实体的属性在模型中被定义为可选，且在托管对象的类型声明中也为可选值类型（ 例如上方的 timestamp 属性
），那么如果在可以保证 save 时一定有值的情况下，是否可以在使用中使用 `!` 号对其进行强制解包？

事实上，在 Xcode 自带的 Core Data 模版中，就是这样使用的。

![image-20221212101526366](https://cdn.fatbobman.com/image-20221212101526366.png)

但这确实是正确的使用方式吗？是否会有严重的安全隐患？在 timestamp 对应的数据库字段有值的情况下，timestamp 一定会有值吗？是否会有 nil
的可能？

## 删除与响应式编程

托管对象的实例创建于托管上下文中，且仅能安全运行于其绑定的托管上下文所在的线程之中。每个托管对象都对应着持久化存储中的一条数据（ 不考虑关系的情况下 ）。

为了节省内存，托管对象上下分通常会积极释放（ retainsRegisteredObjects 默认为 false
）失去引用的托管对象实例所占用的空间。也就是说，如果一个用于显示托管对象实例数据的视图被销毁了，那么假如没有其他的视图或代码引用视图中显示的托管对象实例，托管上下文将从内存中将这些数据占用的内存释放掉。

> 在 retainsRegisteredObjects 为 true
> 的情况下，托管对象会在内部保留对该对象的强引用，即使没有外部代码引用该托管对象实例，对象实例也不会被销毁。

从另一个角度来看，即使在托管上下文中使用 `delete` 方法删除该实例在数据库中对应的数据，但如果该托管对象实例仍被代码或视图所引用，Swift
并不会销毁该实例，此时，托管对象上下文会将该实例的 managedObjectContext 属性设置为 nil
，取消其与托管上下文之间的绑定。此时如果再访问该实例的可选值类型属性（ 例如之前一定有值的 timestamp ），返回值则为 nil
。强制解包将导致应用崩溃。

如今的 Core
Data，随着云同步以及持久化存储历史跟踪的普及，数据库中的某个数据可能在任意时刻被其他的设备或同一个设备中使用该数据库的其他进程所删除。开发者不能像之前那样假设自己对数据具备完全的掌控能力。在代码或视图中，如果不为随时可能已被删除的数据做好安全准备，问题将十分地严重。

回到 Xcode 创建的 Core Data 模版代码，我们做如下的尝试，在进入 NavigationLink 后一秒钟删除该数据：

    ForEach(items) { item in
        NavigationLink {
            Text("Item at \(item.timestamp!, formatter: itemFormatter)")
                .onAppear{
                    // 在进入 NavigationLink 后一秒钟删除该数据
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1){
                        viewContext.delete(item)
                        try! viewContext.save()
                    }
                }
        } label: {
            Text(item.timestamp!, formatter: itemFormatter)
        }
    }

![coreData-optional-demo1_2022-12-12_11.16.51.2022-12-12
11_18_34](https://cdn.fatbobman.com/coreData-optional-
demo1_2022-12-12_11.16.51.2022-12-12%2011_18_34.gif)

完全没有问题！并没有出现崩溃的情况。难道我们上面的论述都是错误的？

由于在 Core Data 模版代码中，只使用了一行代码来声明次级视图：

    Text("Item at \(item.timestamp!, formatter: itemFormatter)")

因此在 ContentView 的 ForEach 中，item 并不会被视为一个可以引发视图更新的 Source of truth （ 通过 Fetch
Request 获取的 items 为 Source of truth ）。在删除数据后，即使 item 的内容发生了变化，也并不会引发该行声明语句（
Text ）刷新，从而不会出现强制解包失败的情况。随着 FetchRequest 的内容发生变化，List 将重新刷新，由于 NavigationLink
对应的数据不复存在，因此 NavigationView 自动返回了根视图。

不过，通常我们在子视图中，会用 ObservedObject
来标注托管对象实例，以实时响应数据变动，因此如果我们将代码调整成正常的编写模式就能看出问题所在了：

    struct Cell:View {
        @ObservedObject var item:Item // 响应数据变化
        @Environment(\.managedObjectContext) var viewContext
        var body: some View {
            Text("Item at \(item.timestamp!, formatter: itemFormatter)")
                .onAppear{
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1){
                        viewContext.delete(item)
                        try! viewContext.save()
                    }
                }
        }
    }

    List {
        ForEach(items) { item in
            NavigationLink {
                Cell(item: item) // 传递托管对象
            } label: {
                Text(item.timestamp!, formatter: itemFormatter)
            }
        }
        .onDelete(perform: deleteItems)
    }

![coreData-optional-demo2_2022-12-12_11.29.10.2022-12-12
11_31_10](https://cdn.fatbobman.com/coreData-optional-
demo2_2022-12-12_11.29.10.2022-12-12%2011_31_10.gif)

在删除了数据后，托管上下文会将 item 的 manageObjectContext 设置为 nil。此时受 item 的
ObjectWillChangePublisher 驱动，Cell 视图将刷新，强制解包将导致应用崩溃。

只需采用提供备选值的方式，即可避免上述问题的出现。

    Text("Item at \(item.timestamp ?? .now, formatter: itemFormatter)")

如果使用我们在 [ SwiftUI 与 Core Data —— 数据定义 ](/zh/posts/modern-core-data-data-
definition/) 一文中讨论的 ConvertibleValueObservableObject 协议呢？在 convertToValueType
中为属性提供备选值，是否可以避免出现崩溃的情况？答案是，原始的版本仍可能会出现问题。

数据被删除后，托管对象实例的 manageObjectContext 被设置为 nil 。由于
AnyConvertibleValueObservableObject 符合 ObservableObject 协议，一样会引发 Cell
视图的更新，在新的一轮渲染中，如果我们限定 convertToGroup
将转换过程运行于托管对象上下文所在的线程中，由于无法获取上下文信息，转换将失败。假设我们不限定转换过程运行的线程，备选值的方式对于由视图上下文创建的托管对象实例仍将有效（
但有可能会出现其它的线程错误 ）。

为了让 ConvertibleValueObservableObject 协议能够满足各种场景，我们需要做如下的调整：

    public protocol ConvertibleValueObservableObject<Value>: ObservableObject, Equatable, Identifiable where ID == WrappedID {
        associatedtype Value: BaseValueProtocol
        func convertToValueType() -> Value? // 将返回类型修改为 Value？
    }

    public extension TestableConvertibleValueObservableObject where ObjectWillChangePublisher == ObservableObjectPublisher {
        ...

        func convertToValueType() -> WrappedValue? { // 修改成返回 Value？
            _wrappedValue
        }
    }

    public class AnyConvertibleValueObservableObject<Value>: ObservableObject, Identifiable where Value: BaseValueProtocol {

        public var wrappedValue: Value? { // 修改成返回 Value？
            _object.convertToValueType()
        }
    }

如此一来，便可以通过在视图代码使用 `if let` 来保证不会出现上文提到的崩溃问题：

    public struct Cell: View {
        @ObservedObject var item: AnyConvertibleValueObservableObject<Item>

        public var body: some View {
            if let item = item.wrappedValue {
               Text("Item at \(item.timestamp, formatter: itemFormatter)")
            }
        }
    }

为了做到可以支持在任意托管上下文线程中进行转换，convertToValueType 中的实现将为（ 以 Todo 中的 TodoGroup 为例 ）：

    extension C_Group: ConvertibleValueObservableObject {
        public var id: WrappedID {
            .objectID(objectID)
        }

        public func convertToValueType() -> TodoGroup? {
            guard let context = managedObjectContext else { // 判断是否能获取上下文
                return nil
            }
            return context.performAndWait { // 在上下文的线程中执行，保证线程安全
                TodoGroup(
                    id: id,
                    title: title ?? "",
                    taskCount: tasks?.count ?? 0
                )
            }
        }
    }

由于同步版本的 performAndWait 并不支持返回值，我们需要对其作一定的增强：

    extension NSManagedObjectContext {
        @discardableResult
        func performAndWait<T>(_ block: () throws -> T) throws -> T {
            var result: Result<T, Error>?
            performAndWait {
                result = Result { try block() }
            }
            return try result!.get()
        }

        @discardableResult
        func performAndWait<T>(_ block: () -> T) -> T {
            var result: T?
            performAndWait {
                result = block()
            }
            return result!
        }
    }

在响应式编程中，开发者不应假设每个部件均能处于理想环境中，需要尽力确保它们能够任何情况下均保证安全稳定，如此才能保证整个系统的稳定运转。

## 为已删除的托管对象实例提供正确的备选内容

一定会有人对本节的题目感到奇怪，数据已经删除了，还需要提供什么信息？

在上节的演示中，当数据被删除后（ 通过 onAppear 闭包中的延迟操作 ），NavigationView
会自动返回到根视图中。在这种情况下，持有该数据的视图将伴随着数据删除一并消失。

但在非常多的情况下，开发者并不会使用演示中使用的 NavigationLink 版本，为了对视图拥有更强地控制力，开发者通常会选择具备可编程特性的
NavigationLink
版本。此时，当数据被删除后，应用并不会自动退回至根视图。另外，在其他的一些操作中，为了保证模态视图的稳定，我们通常也会将模态视图挂载到 List
的外面。例如：

    @State var item: Item?

    List {
        ForEach(items) { item in
            VStack {
                Text("\(item.timestamp ?? .now)")
                Button("Show Detail") {
                    self.item = item // 显示模态视图
                    // 模拟延迟删除
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2){
                        viewContext.delete(item)
                        try! viewContext.save()
                    }
                }
                .buttonStyle(.bordered)
            }
        }
        .onDelete(perform: deleteItems)
    }
    // 模态视图
    .sheet(item: $item) { item in
        Cell(item: item)
    }

    struct Cell: View {
        @ObservedObject var item: Item
        var body: some View {
            // 方便看清楚变化。 当 timestamp 为 nil 时，将显示当前时间
            Text("\((item.timestamp ?? .now).timeIntervalSince1970)")
        }
    }

运行上面的代码，在数据被删除后，Sheet 视图中的 item 会因 managedObjectContext 为 nil
而使用备选数据，如此一来会让用户感到疑惑。

![coreData-optional-demo3_2022-12-12_14.20.17.2022-12-12
14_21_06](https://cdn.fatbobman.com/coreData-optional-
demo3_2022-12-12_14.20.17.2022-12-12%2014_21_06.gif)

我们可以通过保留有效值的方式避免出现上述的问题。

    struct Cell: View {
        let item: Item // 无需使用 ObservedObject
        /*
        如果使用的是 MockableFetchRequest ，则为
        let item: AnyConvertibleValueObservableObject<ItemValue>
        */
        @State var itemValue:ItemValue?
        init(item: Item) {
            self.item = item
            // 初始化时，获取有效值
            self._itemValue = State(wrappedValue: item.convertToValueType())
        }
        var body: some View {
            VStack {
                if let itemValue {
                    Text("\((itemValue.timestamp).timeIntervalSince1970)")
                }
            }
            .onReceive(item.objectWillChange){ _ in
                // item 发生变化后，如果能转换成有效值，则更新视图
                if let itemValue = item.convertToValueType() {
                    self.itemValue = itemValue
                }
            }
        }
    }

    public struct ItemValue:BaseValueProtocol {
        public var id: WrappedID
        public var timestamp:Date
    }

    extension Item:ConvertibleValueObservableObject {
        public var id: WrappedID {
            .objectID(objectID)
        }

        public func convertToValueType() -> ItemValue? {
            guard let context = managedObjectContext else { return nil}
            return context.performAndWait{
                ItemValue(id: id, timestamp: timestamp ?? .now)
            }
        }
    }

![coreData-optional-demo4_2022-12-12_14.20.17.2022-12-12
14_21_06](https://cdn.fatbobman.com/coreData-optional-
demo4_2022-12-12_14.20.17.2022-12-12%2014_21_06.gif)

## 在视图之外传递值类型

在上节的代码中，我们为子视图传递都是托管对象实例本身（ AnyConvertibleValueObservableObject 也是对托管对象实例的二度包装
）。但在类 Redux 框架中，为了线程安全（ Reducer 未必运行于主线程，详细请参阅之前的文章 ）我们不会将托管对象实例直接发送给
Reducer，而是传递转换后的值类型。

> 下面的代码来自 Todo 项目中 TCA Target 的 TaskListContainer. swift

![image-20221212162439240](https://cdn.fatbobman.com/image-20221212162439240.png)

尽管值类型帮助我们规避了可能存在的线程风险，但又出现了视图无法对托管对象实例的变化进行实时响应的新问题。通过在视图中获取值类型数据对应的托管对象实例，便可以既保证安全，又保持了响应的实时性。

为了演示方便，仍以普通的 SwiftUI 数据流举例：

    @State var item: ItemValue? // 值类型

    List {
        ForEach(items) { item in
            VStack {
                Text("\(item.timestamp ?? .now)")
                Button("Show Detail") {
                    self.itemValue = item.convertToValueType() // 传递值类型
                    // 模拟延迟修改内容
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                        item.timestamp = .now
                        try! viewContext.save()
                    }
                }
                .buttonStyle(.bordered)
            }
        }
        .onDelete(perform: deleteItems)
    }
    .sheet(item: $itemValue) { item in
        Cell(itemValue: item) // 参数为值类型
    }

    struct Cell: View {
        @State var itemValue: ItemValue // 值类型
        @Environment(\.managedObjectContext) var context

        var body: some View {
            VStack {
                if let itemValue {
                    Text("\((itemValue.timestamp).timeIntervalSince1970)")
                }
            }
            // 在视图中获取对应的托管对象实例，并实时响应变化
            .task { @MainActor in
                guard case .objectID(let id) = itemValue.id else {return}
                if let item = try? context.existingObject(with: id) as? Item {
                    for await _ in item.objectWillChange.values {
                        if let itemValue = item.convertToValueType() {
                            self.itemValue = itemValue
                        }
                    }
                }
            }
        }
    }

以我个人的经验来说，为了确保线程安全，托管对象只应在视图之间进行传递，同时用于视图显示的数据最好也只在视图之内进行获取。任何可能脱离视图的传递过程都应使用托管对象实例对应的值类型版本。

## 在更改数据时进行二次确认

为了避免对主线程造成过多的影响，我们通常会在私有上下文中进行会对数据产生变化的操作。将操作方法的参数设置为值类型，将迫使开发者在对数据进行操作时（
添加、删除、更改等 ）首先需要确认对应数据（ 数据库中 ）是否存在。

例如（ 代码来自 Todo 项目中 DB 库中的 CoreDataStack. swift ）：

    @Sendable
    func _updateTask(_ sourceTask: TodoTask) async {
        await container.performBackgroundTask { [weak self] context in
            // 首先确认 task 是否存在
            guard case .objectID(let taskID) = sourceTask.id,
                  let task = try? context.existingObject(with: taskID) as? C_Task else {
                self?.logger.error("can't get task by \(sourceTask.id)")
                return
            }
            task.priority = Int16(sourceTask.priority.rawValue)
            task.title = sourceTask.title
            task.completed = sourceTask.completed
            task.myDay = sourceTask.myDay
            self?.save(context)
        }
    }

通过 existingObject ，我们将确保只在数据有效的情况下才进行下一步的操作，如此可以避免操作已被删除的数据而造成的意外崩溃情况。

## 下文介绍

在下篇文章中，我们将探讨有关模块化开发的问题。如何将具体的托管对象类型以及 Core Data 操作从视图、Features 中解耦出来。

# HowTo —— SwiftUI2.0 如何使用 Label

> SwiftUI 2.0 中新增了 Label 控件，方便我们添加由图片和文字组成的标签

## 基本用法

    Label("Hello World",systemImage:"person.badge.plus")

![image-20200709174029886](https://cdn.fatbobman.com/howto-swiftui-label1.png)

## 支持自定义标签风格

    import SwiftUI

    struct LabelTest: View {
        var body: some View {
            List(LabelItem.labels(),id:\.id){ label in
                Label(label.title,systemImage:label.image)
                    .foregroundColor(.blue)
                    .labelStyle(MyLabelStyle(color:label.color))
            }
        }
    }

    struct MyLabelStyle:LabelStyle{
        let color:Color
        func makeBody(configuration: Self.Configuration) -> some View{
           HStack{
                configuration.icon //View, 不能精细控制
                    .font(.title)
                    .foregroundColor(color) //颜色是叠加上去的，并不能准确显示
                configuration.title  //View, 不能精细控制
                    .foregroundColor(.blue)
                Spacer()
            }.padding(.all, 10)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(Color.yellow)
            )
        }
    }

    struct LabelItem:Identifiable{
        let id = UUID()
        let title:String
        let image:String
        let color:Color
        static func labels() -> [LabelItem] {
            return [
           LabelItem(title: "Label1", image: "pencil.tip.crop.circle.badge.plus", color: .red),
           LabelItem(title: "df", image: "person.crop.circle.fill.badge.plus", color: .blue),
            ]
        }
    }

![image-20200709175339008](https://cdn.fatbobman.com/howto-swiftui-label2.png)

## 使用自己的 Label 控件，更多控制力

Label 能够提高开发效率，不过并不能精细控制，下面代码使用自定义 MyLabel，可以支持 SF 2.0 提供的彩色符号。

    import SwiftUI

    struct LabelTest: View {
        @State var multiColor = true
        var body: some View {
            VStack{
            Toggle("彩色符号", isOn: $multiColor).padding(.horizontal, 20)
            List(LabelItem.labels(),id:\.id){ label in
                  MyLabel(title:label.title,
                          systemImage:label.image,
                          color:label.color,
                          multiColor:multiColor)
            }
        }
    }

    struct LabelItem:Identifiable{
        let id = UUID()
        let title:String
        let image:String
        let color:Color
        static func labels() -> [LabelItem] {
            return [
           LabelItem(title: "Label1", image: "pencil.tip.crop.circle.badge.plus", color: .red),
           LabelItem(title: "df", image: "person.crop.circle.fill.badge.plus", color: .blue),
            ]
        }
    }

    struct MyLabel:View{
        let title:String
        let systemImage:String
        let color:Color
        let multiColor:Bool

        var body: some View{
            HStack{
                Image(systemName: systemImage)
                    .renderingMode(multiColor ? .original : .template)
                    .foregroundColor(multiColor ? .clear : color)
                Text(title)
                    .bold()
                    .foregroundColor(.blue)
                Spacer()
            }
            .padding(.all, 10)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(Color.yellow)
            )
        }
    }

![image-20200709180353538](https://cdn.fatbobman.com/howto-swiftui-label3.png)

# SwiftUI 的动画机制

大多初学者都会在第一时间惊叹于 SwiftUI 轻松实现各种动画效果的能力，但经过一段时间的使用后，他们会发现 SwiftUI
的动画并非像表面上看起来那样容易驾驭。开发者经常需要面对：如何动、怎么动、什么能动、为什么不动、为什么这么动、如何不让它动等等困扰。对 SwiftUI
的动画处理逻辑了解的不够深入是造成上述困扰的主要原因。本文将尝试对 SwiftUI 的动画机制做以介绍，以帮助大家更好地学习、掌握 SwiftUI
的动画，制作出满意的交互效果。

> 阅读本文前，读者最好已拥有在 SwiftUI 中使用动画编程的经历，或对 SwiftUI 动画的基本使用方法有一定的了解。可以在 [
> 此处获取本文的全部代码 ](https://github.com/fatbobman/BlogCodes/tree/main/Animation)

## SwiftUI 的动画是什么？

SwiftUI 采用了声明式语法来描述不同状态下的 UI 呈现，动画亦是如此。官方文档将 SwiftUI
的动画（Animations）定义为：创建从一个状态到另一个状态的平滑过渡。

在 SwiftUI 中，我们不能命令某个视图从一个位置移动到另一个位置，为了实现上述效果，我们需要声明该视图在状态 A 时所处的位置以及状态 B
时所处的位置，当由状态由 A 转到 B 时，SwiftUI 将使用指定的算法函数，为特定部件（如果该部件是可动画的话）提供用于生成平滑过渡而需的数据。

在 SwiftUI 中，实现一个动画需要以下三个要素：

- 一个时序曲线算法函数
- 将状态（特定依赖项）同该时序曲线函数相关联的声明
- 一个依赖于该状态（特定依赖项）的可动画部件

![animationThreeElements](https://cdn.fatbobman.com/animationThreeElements-1627470.png)

## 令人疑惑的 Animation 命名

### 时序曲线函数

SwiftUI 为时序曲线算法函数取了一个令人困惑的名字 —— Animation。或许用时序曲线或动画曲线来命名会更加贴切（譬如 Core
Animation 中的 CAMediaTimingFunction）。

该函数将动画的节奏定义为一条计时曲线，将起点数据沿计时曲线变换为终点数据。

    Text("Hello world")
        .animation(.linear(duration: 0.3), value: startAnimation)
        .opacity(startAnimation ? 0 : 1)

时序曲线函数（ Animation ） `linear(duration:0.3)` 意味着在 0.3 秒中对数据进行线性的转换（本例中为从 0 到
1）。

![linear_value_sheet](https://cdn.fatbobman.com/linear_value_sheet.png)

![image-20220504111032123](https://cdn.fatbobman.com/image-20220504111032123.png)

时序曲线函数（ Animation ） `easeInOut(duration:0.3)` 对应的数值变化：

![easeInOut_value_sheet](https://cdn.fatbobman.com/easeInOut_value_sheet.png)

![image-20220504110821144](https://cdn.fatbobman.com/image-20220504110821144.png)

时序曲线函数的工作仅为对数据进行插值变换，至于如何利用插值数据则是可动画部件的工作。

### VectorArithmetic

只有符合 VectorArithmetic 协议的数据类型方可被应用于时序曲线函数。SwiftUI
为我们提供了几种开箱即用的数据类型，例如：Float、Double、CGFloat 等。

    Text("Hello world")
        .animation(.linear(duration: 0.3), value: startAnimation)
        .opacity(startAnimation ? 0 : 1) // Double 类型，符合 VectorArithmetic 协议

其他的数据类型通过实现 VectorArithmetic 协议的要求，也可以为可动画部件提供动画数据。

Majid 的 [ The magic of Animatable values in SwiftUI
](https://swiftwithmajid.com/2020/06/17/the-magic-of-animatable-values-in-
swiftui/) 一文中，展示了如何让自定义类型满足 VectorArithmetic 协议。

## 将时序曲线函数与状态关联

只有通过某种形式将时序曲线函数（Animation）与某个（或多个）依赖项关联后，SwiftUI 才会在状态（ 被关联的依赖项
）变化时为动画生成插值数据。关联的方式有：视图修饰符 `animation` 或全局函数 `withAnimation` 。

SwiftUI 的动画异常（与开发者的预期不符）很多情况下均与错误的关联方式、错误关联位置等因素有关。

### 将修饰符 animation 放置在正确的位置上

代码一：

    @State var animated = false

    VStack {
        Text("Hello world")
            .offset(x: animated ? 200 : 0)
            .animation(.easeInOut, value: animated) // animation 的作用域为当前视图层次及其子视图

        Text("Fat")
            .offset(x: animated ? 200 : 0)
    }

![single_animation_2022-05-04_14.08.25.2022-05-04
14_09_34](https://cdn.fatbobman.com/single_animation_2022-05-04_14.08.25.2022-05-04%2014_09_34.gif)

代码二：

    VStack {
        Text("Hello world")
            .offset(x: animated ? 200 : 0)

        Text("Fat")
            .offset(x: animated ? 200 : 0)
    }
    .animation(.easeInOut, value: animated)

![both_animation_2022-05-04_14.05.54.2022-05-04
14_06_58](https://cdn.fatbobman.com/both_animation_2022-05-04_14.05.54.2022-05-04%2014_06_58.gif)

上述两段代码，因为 `animation` 在代码中的位置不同，导致了在其所关联的依赖项（ `animated`
）发生改变时，动画的行为产生了差异。在代码一中，只有 `Hello world` 会产生平滑的动画；代码二中 `Hello world` 和 `Fat` 两者都将产生平滑的动画。

同所有 SwiftUI 的视图修饰符一样，在代码中所处的位置决定了修饰符的作用对象和范围。 `animation`
的作用对象仅限于它所在视图层次及该层次的子节点。

上面两段代码没有对错之分。在某些场景下，我们可能需要在某一个依赖项（状态）发生改变时，所有依赖于该项目的内容都产生平滑动画（例如代码二），在其他场景中，可能又仅需部分内容产生平滑动画（例如代码一），通过调整
`animation` 的位置，就可以获得想要的效果。

### 只使用指定特定依赖项的 animation 版本

SwiftUI 提供了两个版本的 `animation` 修饰符：

    // 版本一，不指定特定依赖项
    func animation(_ animation: Animation?) -> some View

    // 版本二，指定特定的依赖项，上节代码中采用的方式
    func animation<V>(_ animation: Animation?, value: V) -> some View where V : Equatable

第一种方式在 SwiftUI 3.0 中已被标注弃用，它是在老版本 SwiftUI 中导致动画异常的元凶之一。此版本的 `animation`
会与所在视图层次和该视图层次的子节点的 **所有依赖项**
进行状态关联。视图和它子节点中的任何依赖项发生变化，都将满足启用动画插值计算的条件，并动画数据传递给作用范围内（视图和它子节点）的所有可动画部件。

比如，由于下面代码中的 `animation` 没指定特定的依赖项，因此，点击按钮后，位置与颜色都会产生平滑动画。

    struct Demo2: View {
        @State var x: CGFloat = 0
        @State var red = false
        var body: some View {
            VStack {
                Spacer()
                Circle()
                    .fill(red ? .red : .blue)
                    .frame(width: 30, height: 30)
                    .offset(x: x)
                    .animation(.easeInOut(duration: 1)) // 同时关联了 x 和 red 两个依赖项
    //                .animation(.easeInOut(duration: 1), value: x)  // 推荐采用分别关联的方式
    //                .animation(.easeInOut(duration: 1), value: red)

                Spacer()
                Button("Animate") {  // 闭包中改变了两个依赖项的值
                    if x == 0 {
                        x = 100
                    } else {
                        x = 0
                    }
                    red.toggle()
                }
            }
            .frame(width: 500, height: 300)
        }
    }

通过使用 `animation<V>(_ animation: Animation?, value: V)`
版本，我们可以只让位置或颜色两者之一产生平滑动画。在一次性修改多个依赖项时， `animation(_ animation: Animation?)`
极易产生不必要的动画，这也是它被废弃的主要原因。

在本例中，使用 `withAnimation` 也可以达到同样的效果，通过在 `withAnimation`
的闭包中修改特定的依赖项从而实现单独的动画控制。

    struct Demo2: View {
        @State var x: CGFloat = 0
        @State var red = false
        var body: some View {
            VStack {
                Spacer()

                Circle()
                    .fill(red ? .red : .blue)
                    .frame(width: 30, height: 30)
                    .offset(x: x)
                Spacer()
                Button("Animate") {
                    if x == 0 {
                        x = 100
                    } else {
                        x = 0
                    }
                    withAnimation(.easeInOut(duration: 1)) { // 只有颜色会平滑过渡
                        red.toggle()
                    }
                }
            }
            .frame(width: 500, height: 300)
        }
    }

### 为不同的依赖项关联不同的时序曲线函数

细心的朋友可能会发现，在上文中，当对时序曲线函数进行关联时，我使用的词语是“依赖项”而不是“状态”，这是因为视图的状态是它拥有的全部依赖项的总体呈现。 `witAnimation` 允许我们为同一个可动画部件的不同的依赖项设定不同的时序曲线函数。

    struct Demo4: View {
        @State var x: CGFloat = 0
        @State var y: CGFloat = 0
        var body: some View {
            VStack {
                Spacer()
                Circle()
                    .fill(.orange)
                    .frame(width: 30, height: 30)
                    .offset(x: x, y: y) // x、y 分别关联了不同的时序曲线函数
                Spacer()
                Button("Animate") {
                    withAnimation(.linear) {
                        if x == 0 { x = 100 } else { x = 0 }
                    }
                    withAnimation(.easeInOut) {
                        if y == 0 { y = 100 } else { y = 0 }
                    }
                }
            }
            .frame(width: 500, height: 500)
        }
    }

![dual_timing_function_2022-05-04_15.25.59.2022-05-04
15_27_18](https://cdn.fatbobman.com/dual_timing_function_2022-05-04_15.25.59.2022-05-04%2015_27_18.gif)

因为 `offset(x: x, y: y)` 中的 x 和 y 通过 `withAnimation`
关联了不同的时序曲线函数，因此在动画的过程中，横轴和纵轴的运动方式是不同的（ x 是线性的，y 是缓进出的）。

> 目前 `animation<V>(_ animation: Animation?, value: V)`
> 尚不支持对同一个可动画部件的不同的依赖项关联不同的时序曲线函数

除了可以关联种类不同的时序曲线函数外，SwiftUI 还允许关联的时序曲线函数拥有不同的作用时长。对同一个动画部件的不同依赖项关联不同时长函数时（
duration 不一致或启用了 repeatForever ），插值的计算逻辑将会变得更加复杂，不同的组合会有不同的结果，需慎重使用。

    Button("Animate") {
        withAnimation(.linear) {
            if x == 0 { x = 100 } else { x = 0 }
        }
        withAnimation(.easeInOut(duration: 1.5)) {
            if y == 0 { y = 100 } else { y = 0 }
        }
    }

![different_duration_2022-05-09_12.44.24.2022-05-09
12_45_01](https://cdn.fatbobman.com/different_duration_2022-05-09_12.44.24.2022-05-09%2012_45_01.gif)

### 谨慎使用 withAnimation

在 SwiftUI 没有提供 `animation<V>(_ animation: Animation?, value: V)`
（与特定依赖项关联）修饰符时， `withAnimation` 相较于 `animation(_ animation: Animation?)`
或许是更好的选择，至少它可以明确的将特定的依赖项与时序曲线函数关联起来。

不过现在除非有必要（例如需要关联不同的时序曲线函数），应优先考虑使用 `animation<V>(_ animation: Animation?,
value: V)` 。这是因为尽管 `withAnimation` 可以指定依赖项，但它缺乏 `animation(_ animation:
Animation?, value: V)` 的代码位置维度， `withAnimation` 会影响显示中的所有与该依赖项关联的视图，比如，很难用
`withAnimation` 实现代码一的效果。

另外需要注意的是，使用 `withAnimation` 时，必须明确地让依赖项出现在闭包中，否则 `withAnimation` 将不起作用。例如：

    struct Demo3: View {
        @State var items = (0...3).map { $0 }
        var body: some View {
            VStack {
                Button("In withAnimation") {
                    withAnimation(.easeInOut) {
                        items.append(Int.random(in: 0...1000))
                    }
                }
                Button("Not in withAnimation") { // 使用 Array 的扩展方法
                    items.appendWithAnimation(Int.random(in: 0...1000), .easeInOut)
                }
                List {
                    ForEach(items, id: \.self) { item in
                        Text("\(item)")
                    }
                }
                .frame(width: 500, height: 300)
            }
        }
    }

    extension Array {
        mutating func appendWithAnimation(_ newElement: Element, _ animation: Animation?) {
            withAnimation(animation) {
                append(newElement)
            }
        }
    }

虽然，在 Array 的扩展方法 `appendWithAnimation` 中使用了 `withAnimation` ，但由于 `withAnimation` 的闭包中没有包含特定的依赖项，因此并不会激活 SwiftUI 的动画机制。

## 让你的视图元素可动画（Animatable）

将时序曲线函数与特定的依赖进行关联，仅是完成了设置动画开启条件（特定依赖项发生改变）和指定插值算法这一步骤。至于如何利用这些动画数据（插值数据）生成动画，则是由与特定依赖项关联的可动画部件决定的。

通过遵循 Animatable 协议，可以让 View 或 ViewModifier 具备获得动画数据的能力（ AnimatableModifier
已被弃用）。很多 SwiftUI 的官方部件都已预先满足了该协议，例如： `offset` 、 `frame` 、 `opacity` 、 `fill` 等。

Animatable 协议的要求非常简单，只需实现一个计算属性 `animatableData`

    public protocol Animatable {

        /// The type defining the data to animate.
        associatedtype AnimatableData : VectorArithmetic

        /// The data to animate.
        var animatableData: Self.AnimatableData { get set }
    }

请注意，协议中规定 `animatableData` 的类型必须满足 VectorArithmetic 协议，这是因为时序曲线函数只能对满足
VectorArithmetic 协议的类型进行插值计算。

当可动画部件关联的依赖项发生变化时，SwiftUI 将通过指定的时序曲线函数进行插值计算，并持续调用与该依赖项关联的可动画部件的 `animatableData` 属性。

    struct AnimationDataMonitorView: View, Animatable {
        static var timestamp = Date()
        var number: Double
        var animatableData: Double { // SwiftUI 在渲染时发现该视图为 Animatable，则会在状态已改变后，依据时序曲线函数提供的值持续调用 animableData
            get { number }
            set { number = newValue }
        }

        var body: some View {
            let duration = Date().timeIntervalSince(Self.timestamp).formatted(.number.precision(.fractionLength(2)))
            let currentNumber = number.formatted(.number.precision(.fractionLength(2)))
            let _ = print(duration, currentNumber, separator: ",")

            Text(number, format: .number.precision(.fractionLength(3)))
        }
    }

    struct Demo: View {
        @State var startAnimation = false
        var body: some View {
            VStack {
                AnimationDataMonitorView(number: startAnimation ? 1 : 0) // 声明两种状态下的形态
                    .animation(.linear(duration: 0.3), value: startAnimation) // 关联依赖项和时序曲线函数
                Button("Show Data") {
                    AnimationDataMonitorView.timestamp = Date()
                    startAnimation.toggle() // 改变依赖项
                }
            }
            .frame(width: 300, height: 300)
        }
    }

上面这段代码清晰的展现了这个过程。

声明过程：

- 指定时序曲线函数 —— linear
- 将依赖项 startAnimation 与 linear 相关联
- AnimationDataMonitorView （可动画部件）符合 Animatable 且依赖了 startAnimation

动画处理过程：

- 点击按钮改变依赖项 startAnimation 的值
- SwiftUI 会立即完成对 startAnimation 值的改变（依赖值的改变发生在动画开始前，比如本例中，true 将立刻变成 false ）
- SwiftUI 发现 AnimationDataMonitorView 符合 Animatable 协议，使用 linear 进行插值计算
- SwiftUI 将按照设备的刷新率（ 60 fps/sec 或 120 fps/sec）持续使用 linear 的计算结果设置 AnimationDataMonitorView 的 animatableData 属性，并对 AnimationDataMonitorView 的 body 求值、渲染

通过设置在 body 中的打印语句，我们可以看到不同时间节点的的插值数据：

![animatable_data_demo_2022-05-04_17.32.01.2022-05-04
17_34_12](https://cdn.fatbobman.com/animatable_data_demo_2022-05-04_17.32.01.2022-05-04%2017_34_12.gif)

> 上文中的时序曲线函数数值变化表便由此代码生成

推荐几篇介绍 Animatable 用法的博文：

[ Advanced SwiftUI Animations – Part 1: Paths ](https://swiftui-
lab.com/swiftui-animations-part1/)

[ AnimatableModifier in SwiftUI
](https://swiftwithmajid.com/2021/01/11/animatablemodifier-in-swiftui/)

当可动画元素有多个可变依赖项时，需将 `animatableData` 设置为 AnimatablePair 类型，以便 SwiftUI
可以传递分属于不同依赖项的动画插值数据。

> AnimatablePair 类型符合 VectorArithmetic 协议，同时要求其包装的数值类型也需符合 VectorArithmetic 协议

下面的代码演示了 AnimatablePair 的使用方法，以及如何查看两个不同的时序曲线函数插值数据：

    struct AnimationDataMonitorView: View, Animatable {
        static var timestamp = Date()
        var number1: Double // 会发生变化
        let prefix: String
        var number2: Double // 会发生变化

        var animatableData: AnimatablePair<Double, Double> {
            get { AnimatablePair(number1, number2) }
            set {
                number1 = newValue.first
                number2 = newValue.second
            }
        }

        var body: some View {
            let duration = Date().timeIntervalSince(Self.timestamp).formatted(.number.precision(.fractionLength(2)))
            let currentNumber1 = number1.formatted(.number.precision(.fractionLength(2)))
            let currentNumber2 = number2.formatted(.number.precision(.fractionLength(2)))
            let _ = print(duration, currentNumber1, currentNumber2, separator: ",")

            HStack {
                Text(prefix)
                    .foregroundColor(.green)
                Text(number1, format: .number.precision(.fractionLength(3)))
                    .foregroundColor(.red)
                Text(number2, format: .number.precision(.fractionLength(3)))
                    .foregroundColor(.blue)
            }
        }
    }

    struct Demo: View {
        @State var startNumber1 = false
        @State var startNumber2 = false
        var body: some View {
            VStack {
                AnimationDataMonitorView(
                    number1: startNumber1 ? 1 : 0,
                    prefix: "Hi:",
                    number2: startNumber2 ? 1 : 0
                )
                Button("Animate") {
                    AnimationDataMonitorView.timestamp = Date()
                    withAnimation(.linear) {
                        startNumber1.toggle()
                    }
                    withAnimation(.easeInOut) {
                        startNumber2.toggle()
                    }
                }
            }
            .frame(width: 300, height: 300)
        }
    }

![animatable_dual_data_demo_2022-05-04_18.17.39.2022-05-04
18_18_51](https://cdn.fatbobman.com/animatable_dual_data_demo_2022-05-04_18.17.39.2022-05-04%2018_18_51.gif)

SwiftUI 在传递插值数据时非常聪明，只会将发生变化的依赖项通过 `animatableData` 传递给可动画元素。比如在上面的代码中，参数 `prefix` 不发生变化，因此在合成 `AnimatablePair` 数据时会自动跳过，只合成 `number1` 和 `number2`
。

当需要传递更多的参数时，可嵌套使用 AnimatablePair 类型，如：

    AnimatablePair<CGFloat, AnimatablePair<Float, AnimatablePair<Double, CGFloat>>>
    // newValue.second.second.first.

## 使用 Transaction 进行更精细的控制

用 SwiftUI 的官方语言来描述【将时序曲线函数与状态关联的过程】应该是：为视图声明事务（
Transaction）。事务提供了更加灵活的曲线函数类型设置方式以及动画开关和临时状态标识。

无论是修饰符 `animation` 还是全局函数 `withAnimation` ，实际上都是在视图中声明 Transaction
的快捷方法，内部分别对应着 `transaction` 和 `withTransaction` 。

比如， `withAnimation` 实际上对应的是：

    withAnimation(.easeInOut){
        show.toggle()
    }
    // 对应为
    let transaction = Transaction(animation: .easeInOut)
    withTransaction(transaction) {
        show.toggle()
    }

`animation(_ animation: Animation?)` 同样是通过 Transaction 来实现的：

    // 代码来自于 swiftinterface
    extension SwiftUI.View {
        @_disfavoredOverload @inlinable public func animation(_ animation: SwiftUI.Animation?) -> some SwiftUI.View {
            return transaction { t in
                if !t.disablesAnimations {
                    t.animation = animation
                }
            }
        }
    }

Transaction 提供的 disablesAnimations 和 isContinuous 可以帮助开发者更好的进行动画控制，例如：

- 动态选择需要关联的时序曲线函数

  Text("Hi")
  .offset(x: animated ? 100 : 0)
  .transaction {
  if position < 0 || position > 100 {
  $0.animation = .easeInOut
  } else {
  $0.animation = .linear
  }
  }

> `transaction` 的作用范围与关联的依赖项与不指定特定依赖项版本的 `animation` 是一样的，
> **它不具备与特定依赖项关联的能力** 。

    // 并不表示仅与 x 关联，作用域范围内的其他依赖项发生变化，同样会产生动画
    .transaction {
        if x == 0 {
            $0.animation = .linear
        } else {
            $0.animation = nil
        }
    }

    // 相当于
    .animation(x == 0 ? .linear : nil)

- disablesAnimations

  struct Demo: View {
  @State var position: CGFloat = 40
  var body: some View {
  VStack {
  Text("Hi")
  .offset(x: position, y: position)
  .animation(.easeInOut, value: position)

              Slider(value: $position, in: 0...150)
              Button("Animate") {
                  var transaction = Transaction() // 没有指定时序曲线函数，将保留原有设置（本例为 easeInOut）
                  if position < 100 { transaction.disablesAnimations = true }
                  withTransaction(transaction) { // withTransaction 可以禁止原有事务的时序曲线函数（由 animation 相关联），但无法屏蔽由 transaction 关联的时序曲线函数
                      position = 0
                  }
              }
          }
          .frame(width: 400, height: 500)
      }

  }

> `withTransaction` （通过设置 disablesAnimations 来屏蔽动画）+ `animation<V>(_
animation: Animation?, value: V)` 是比较成熟的搭配。

- isContinuous

  struct Demo: View {
  @GestureState var position: CGPoint = .zero
  var body: some View {
  VStack {
  Circle()
  .fill(.orange)
  .frame(width: 30, height: 50)
  .offset(x: position.x, y: position.y)
  .transaction {
  if $0.isContinuous {
                            $0.animation = nil // 拖动时，不设置时序曲线函数
                        } else {
                            $0.animation = .easeInOut(duration: 1)
                        }
                    }
                    .gesture(
                        DragGesture()
                            .updating($position, body: { current, state, transaction in
  state = .init(x: current.translation.width, y: current.translation.height)
  transaction.isContinuous = true // 拖动时，设置标识
  })
  )
  }
  .frame(width: 400, height: 500)
  }
  }

![isContinuous_2022-05-06 11.26.20.2022-05-06
11_27_42](https://cdn.fatbobman.com/isContinuous_2022-05-06%2011.26.20.2022-05-06%2011_27_42.gif)

> 官方文档中表示，部分控件如 Slider 会在拖动中自动设置 isContinuous
> ，但实测同描述并不相符。但我们可以自己在代码中利用它来设置临时状态。

另外，在某些场景下，可以通过 Transaction 来获取或设置有关动画的信息，如：

- UIViewRepresentableContext
- AsyncImage
- GestureState
- Binding 等

比如，为 Binding 设置 Transaction ：

    struct Demo: View {
        @State var animated = false
        let animation: Animation?

        var animatedBinding: Binding<Bool> { // 生成包含指定 Transaction 的 Binding 类型
            let transaction = Transaction(animation: animation)
            return $animated.transaction(transaction)
        }

        var body: some View {
            VStack {
                Text("Hi")
                    .offset(x: animated ? 100 : 0)

                Toggle("Animated", isOn: animatedBinding) // 点击时会自动产生动画效果
            }
            .frame(width: 400, height: 500)
        }
    }

    PlaygroundPage.current.setLiveView(Demo(animation: .easeInOut))

![binding_transaction_2022-05-06_11.33.10.2022-05-06
11_34_38](https://cdn.fatbobman.com/binding_transaction_2022-05-06_11.33.10.2022-05-06%2011_34_38.gif)

## 更多有关时序曲线函数与状态关联的注意事项

- SwiftUI 只会使用与可动画部件位置最近的关联（时序曲线函数和依赖）声明。

  Circle()
  .fill(red ? .red : .blue)
  .animation(.easeInOut(duration: 1), value: red) // 使用它
  .animation(.linear(duration: 3), value: red)

- withAnimation（ withTransaction ）指定的时序曲线函数并不能更改 animation 中关联的函数

  Circle()
  .fill(red ? .red : .blue)
  .animation(.easeInOut(duration: 1), value: red) // 使用它

  Button("Change red"){
  withAnimation(.linear(duration:3)){ // 作用域最大，意味着距离动画部件最远
  red.toggle()
  }
  }

- animation 和 withAnimation 应该二选一

- withTransaction 可以屏蔽 animation 关联的时序曲线函数

通过设置 disablesAnimations 可以禁用事务中原有的时序曲线函数（不可更改），详情见上节

- 采取恰当的动态设置时序曲线函数的方式

  // 方式一，与特定依赖关联，在仅有两种情况时比较适用
  .animation(red ? .linear : .easeIn , value: red)

  // 方式二， 可以处理更多的逻辑，但不与特定依赖关联
  .transaction{
  switch status{
  case .one:
  $0.animation = .linear
  case .two:
  $0.animation = .easeIn
  case .three:
  $0.animation = nil
  }
  }

  // 方式三，支持复杂逻辑，且与特定状态关联
  var animation:Animation?{
  // 即使闭包中出现多个不同的依赖项，也不会影响 animation 仅与指定的依赖相关联的特性
  switch status{
  case .one:
  $0.animation = .linear
  case .two:
  $0.animation = .easeIn
  case .three:
  $0.animation = nil
  }
  }

  .animation(animation , value: status)

  // 方式四，作用域大
  var animation:Animation?{
  switch status{
  case .one:
  $0.animation = .linear
  case .two:
  $0.animation = .easeIn
  case .three:
  $0.animation = nil
  }
  }

  withAnimation(animation){
  ...
  }

  // 方式五，作用域大
  var animation:Animation?{
  switch status{
  case .one:
  $0.animation = .linear
  case .two:
  $0.animation = .easeIn
  case .three:
  $0.animation = nil
  }
  }
  var transaction = Transaction(animation:animation)
  withTransaction(transaction){
  ...
  }

  // 等等

## 转场（ Transition ）

### 转场是什么

SwiftUI 的转场类型（ AnyTransition ）是对可动画部件的再度包装。当状态的改变导致 **视图树的分支** 发生变化时，SwiftUI
将使用其包裹的可动画部件对视图进行动画处理。

使用转场同样需要满足 SwiftUI 动画的三要素。

    struct TransitionDemo: View {
        @State var show = true
        var body: some View {
            VStack {
                Spacer()
                Text("Hello")
                if show {
                    Text("World")
                        .transition(.slide) // 可动画部件（包装在其中）
                }
                Spacer()
                Button(show ? "Hide" : "Show") {
                    show.toggle()
                }
            }
            .animation(.easeInOut(duration:3), value: show) // 创建关联依赖、设定时序曲线函数
            .frame(width: 300, height: 300)
        }
    }

因此，同所有的 SwiftUI 动画元素一样，转场也支持可中断动画。比如，在出场动画进行中时，将状态 show 恢复成 true ，SwiftUI
将会保留当前的分支状态（不会重新创建视图，参见本文附带的范例）。

### 自定义转场

在 SwiftUI 中实现自定义转场并不困难，除非需要创建炫酷的视觉效果，大多数情况下都可以通过使用 SwiftUI 已提供的可动画部件组合而成。

    struct MyTransition: ViewModifier { // 自定义转场的包装对象要求符合 ViewModifier 协议
        let rotation: Angle
        func body(content: Content) -> some View {
            content
                .rotationEffect(rotation) // 可动画部件
        }
    }

    extension AnyTransition {
        static var rotation: AnyTransition {
            AnyTransition.modifier(
                active: MyTransition(rotation: .degrees(360)),
                identity: MyTransition(rotation: .zero)
            )
        }
    }

    struct CustomTransitionDemo: View {
        @State var show = true
        var body: some View {
            VStack {
                VStack {
                    Spacer()
                    Text("Hello")
                    if show {
                        Text("World")
                            .transition(.rotation.combined(with: .opacity))
                    }
                    Spacer()
                }
                .animation(.easeInOut(duration: 2), value: show) // 在这里声明，Button 的文字将没有动画效果
                Button(show ? "Hide" : "Show") {
                    show.toggle()
                }
            }
    //        .animation(.easeInOut(duration: 2), value: show) // 如果在这里声明，对 Button 的文字同样有影响，结果如下图
            .frame(width: 300, height: 300)
            .onChange(of: show) {
                print($0)
            }
        }
    }

![custom_transition_2022-05-04_19.55.51.2022-05-04
19_56_55](https://cdn.fatbobman.com/custom_transition_2022-05-04_19.55.51.2022-05-04%2019_56_55.gif)

虽然 MyTransition 表面上并不符合 Animatable 协议，但其中的 `rotationEffect` （可动画
ViewModifier ）帮助我们实现了动画效果。

另外，我们也可以使用符合 Animatable 的 GeometryEffect（ 符合 ViewModifier 和 Animatable
）来创建复杂的转场效果。

更炫酷的转场定制方法请阅读 Javier 的文章 [ Advanced SwiftUI Transitions ](https://swiftui-
lab.com/advanced-transitions/) 。

## 状态、视图标识、动画

既然 SwiftUI 的动画是创建从一个状态到另一个状态的平滑过渡，那么我们必须对状态（依赖项）的改变可能导致的结果有正确的认识。

SwiftUI 对视图采用两种标识方式：结构性标识和显式标识。对于动画来讲，采用不同的标识方式所需注意的点不太一样。

### 结构性标识

下面两段代码尽管都是采用了结构性视图标识（ 以所在的视图层次位置和类型进行标识 ），但它们的意图是完全不同的。

    // 代码一
    if show {
        Text("Hello")  // 分支一
    } else {
        Text("Hello")  // 分支二
          .offset(y : 100)
    }

    // 代码二
    Text("Hello")
        .offset(y : show ? 100 : 0)  // 同一视图两种状态声明

代码一描述了在依赖项 show 发生变化时，SwiftUI 将在分支一和分支二中进行切换。此种情况下，我们可以通过 transition
来分别设定分支一和分支二的进出场动画（ 也可以在分支选择的外侧统一设定 Transition ），但无法要求分支一移动到分支二上面。

    // 代码一
    VStack{  //  使用布局容器
        if !show {
            Text("Hello")  // 分支一
               .transition(.scale)
        } else {
            Text("Hello")  // 分支二
              .offset(y : 100)
              .transition(.move(edge: .bottom))
        }
    }
    .animation(.easeIn, value: show)

![status_for_transition_2022-05-09_15.11.26.2022-05-09
15_12_10](https://cdn.fatbobman.com/status_for_transition_2022-05-09_15.11.26.2022-05-09%2015_12_10.gif)

上面的代码有两个需要注意的地方：

- 必须在条件判断语句的外侧使用 `animation` ，因为只有在 `if - else` 的外侧声明，作用域才会对 `show` 的判断有效
- 应使用布局容器（ VStack、ZStack、HStack 视图 ）包裹条件判断语句（ 不要使用 Group ）。由于两个分支视图在转场时会同时出现，因此只有在布局容器中才会正确的处理转场动画。Group 只能对其子元素进行统一设置，不具备处理两个分支视图同时出现的情况（会有一个视图分支的转场丢失）。

代码二描述了在 show 发生变化时同一个视图的不同状态（ `offset` 的 y 数值不同）。因此，在对时序曲线函数关联后，视图将从状态一（ y :
0 ）的位置移动到状态二（ y : 100）的位置。

    // 代码二
    Text("Hello")
        .offset(y : show ? 100 : 0)  // 同一视图两种状态声明
        .animation(.spring(), value: show)

![status_offset_2022-05-09_15.14.12.2022-05-09
15_14_45](https://cdn.fatbobman.com/status_offset_2022-05-09_15.14.12.2022-05-09%2015_14_45.gif)

> 有关视图的结构性标识的内容可以参阅 [ ViewBuilder 研究（下） —— 从模仿中学习 ](/zh/posts/viewbuilder2/)

### 显式标识

在 SwiftUI 中，为视图设置显式识别有两种方式：ForEach 和 id 修饰符。

- 给 ForEach 提供一个稳定且唯一的的 KeyPath 作为标识。

  struct Demo: View {
  @State var items = (0...100).map { $0 }
  var body: some View {
  VStack {
  List {
  ForEach(items, id: \.self) { item in // id: \.self 使用 element 作为 identifier
  Text("\(item)")
  }
  }
  .animation(.easeInOut, value: items)
  Button("Remove Second") {
  items.remove(at: 1)
  }
  Button("add Second") { // 在 items 中会出现相同的元素，破坏了标识的唯一性
  items.insert(Int.random(in: 0...100), at: 1)
  }
  }
  .frame(width: 400, height: 500)
  }
  }

items 是整数数组。上面的代码中使用了 `\.self` 作为标识依据。这意味着，当数组中出现了两个同样的元素（点击添加按钮），SwiftUI
将无法正确识别我们的意图 ——
究竟是想对那个元素（值相同意味着标识也相同）进行操作。因此有很大的可能因为对视图的识别错误，而产生动画异常。下面的动图中，当出现相同元素时，SwiftUI
给出了警告提示。

![foreach_id_error_2022-05-09_16.41.18.2022-05-09
16_43_22](https://cdn.fatbobman.com/foreach_id_error_2022-05-09_16.41.18.2022-05-09%2016_43_22.gif)

为 ForEach 提供具有唯一标识的数据源可有效避免因此而产生的动画异常。

    struct Item: Identifiable, Equatable {
        let id = UUID() // 唯一标识
        let number: Int
    }

    struct Demo: View {
        @State var items = (0...100).map { Item(number: $0) }
        var body: some View {
            VStack {
                List {  // 目前无法为 List 里的 item 指定 transition ，又一个没有在原始控件中很好兼容 SwiftUI 动画的例子。换成 ScrollView 可以支持指定 item 的转场
                    ForEach(items, id: \.id) { item in
                        Text("\(item.number)")
                    }
                }
                .animation(.easeInOut, value: items) // List 使用该关联来处理动画，而不是 ForEach
                Button("Remove Second") {
                    items.remove(at: 1)
                }
                Button("add Second") {
                    items.insert(Item(number: Int.random(in: 0...100)), at: 1)
                }
            }
            .frame(width: 400, height: 500)
        }
    }

- 修饰符 id 需要使用转场

修饰符 `id` 是另一种为视图提供显示标识的方式。当修饰符 id 的值发生变化时，SwiftUI
将其作用的视图从当前的视图结构中移除，并创建新的视图添加到原先所在的视图层次位置。因此，可以影响到它的动画部件也是 AnyTransaction 。

    struct Demo: View {
        @State var id = UUID()
        var body: some View {
            VStack {
                Spacer()
                Text("Hello \(UUID().uuidString)")
                    .id(id) // id 发生变化时 原视图移除，新视图移入
                    .transition(.slide)
                    .animation(.easeOut, value: id)
                Button("Update id") {
                    id = UUID()
                }
                Spacer()
            }
            .frame(width: 300, height: 300)
        }
    }

![id_transition_2022-05-09_16.58.42.2022-05-09
16_59_17](https://cdn.fatbobman.com/id_transition_2022-05-09_16.58.42.2022-05-09%2016_59_17-2086776.gif)

SwiftUI 目前在处理因 `id` 值变化而产生的视图转换的逻辑不太统一，如发现使用 `animation` 无法激活的转场（ 比如
opacity ），可以尝试使用 `withAnimation` 。

> 有关显性标识方面的内容可以参阅 [ 优化在 SwiftUI List 中显示大数据集的响应效率
> ](/zh/posts/optimize_the_response_efficiency_of_list/) 一文

## 遗憾与展望

理论上，一旦你掌握了 SwiftUI 的动画机制，就应该能轻松地驾驭代码，自由地控制动画。但现实是残酷的。由于 SwiftUI
是一个年轻的框架，很多的底层实现仍依赖对其他框架 API 的封装，因此不少场景下的使用体验仍充斥着割裂感。

### 控件的动画问题

SwiftUI 中的不少控件是采用对 UIKit（ AppKit ）控件进行封装实现的，当前的动画处理并不到位。

在 [ ViewBuilder 研究（下） —— 从模仿中学习 ](/zh/posts/viewbuilder2/) 一文中，我们展示了 SwiftUI 的
Text 是如何处理它的扩展方法的。尽管 UIViewRepresentableContext 已经为底层控件提供了动画控制所需的 Transaction
信息，但是当前 SwiftUI 的官方控件并没有对此进行响应。譬如说下面的代码是无法实现平滑过渡的。

    Text("Hello world")
        .foregroundColor(animated ? .red : .blue) // 基于 UIKit（AppKit）封装的控件的扩展几乎都无法实现动画控制
        .font(animated ? .callout : .title3)

虽然我们可以通过一些方法来解决这些问题，但不仅会加大工作量，同时也会损失部分性能。

Paul Hudson 在 [ How to animate the size of text
](https://www.hackingwithswift.com/quick-start/swiftui/how-to-animate-the-
size-of-text) 一文中演示了如何创建字体尺寸的平滑过渡动画。

下面的代码可以帮助 Text 实现文本颜色的平滑过渡。

    extension View {
        func animatableForeground(_ color: Color) -> some View {
            self
                .overlay(Rectangle().fill(color))
                .mask {
                    self
                        .blendMode(.overlay)
                }
        }
    }

    struct Demo: View {
        @State var animated = false
        var body: some View {
            VStack {
                Button("Animate") {
                    animated.toggle()
                }
                Text("Hello world")
                    .font(.title)
                    .animatableForeground(animated ? .green : .orange)
                    .animation(.easeInOut(duration: 1), value: animated)
            }
        }
    }

![animatable_color_of_text_2022-05-05_14.35.19.2022-05-05
14_36_15](https://cdn.fatbobman.com/animatable_color_of_text_2022-05-05_14.35.19.2022-05-05%2014_36_15.gif)

> 2022 年 6 月更新：SwiftUI 4.0 的 Text 通过新增的内容转场，提供了对上述方案的支持

为了区别 SwiftUI 原有的 Transition 概念，SwiftUI 4.0 将这种控件内部的动画转场称之为 content transition（
内容转场 ）。开发者可以通过 `.contentTransition` 设定内容转场模式：

    // SwiftUI 4.0 (iOS 16+, macOS 13+)
    struct ContentTransitionDemo: View {
        @State var change = false
        var body: some View {
            VStack{
                Button("Change"){
                    change.toggle()
                }
                .buttonStyle(.bordered)
                Spacer()
                Text("Hello, World!")
                    .font(change ? .body : .largeTitle)
                    .foregroundStyle( change ? Color.red.gradient : Color.blue.gradient)
                    .fontWeight(change ? .thin : .heavy)
                    .animation(.easeInOut, value: change)
            }
            .frame(height:100)
        }
    }

![contentTransition_demo1_2022-06-10_09.07.48.2022-06-10
09_08_58](https://cdn.fatbobman.com/contentTransition_demo1_2022-06-10_09.07.48.2022-06-10%2009_08_58.gif)

启用内容转场（ content transition ）仍需遵循 SwiftUI 动画的三要素，必须为动画设置时序曲线函数。

    Text("Hello, World!")
                    .font(change ? .body : .largeTitle)
                    .foregroundStyle( change ? Color.red.gradient : Color.blue.gradient)
                    .fontWeight(change ? .thin : .heavy)
                    .animation(.easeInOut, value: change)
                    .contentTransition(.opacity)  // 设置内容转场模式，默认为 interpolate

当前支持的 contentTransition 模式有：

- interpolate （ 默认值 ）

演示效果如上图。自动绘制插值动画。实现的逻辑和效果基本等同于上文中我们的自定义动画 Text

- opacity

![contentTransition_demo2_2022-06-10_09.18.06.2022-06-10
09_19_47](https://cdn.fatbobman.com/contentTransition_demo2_2022-06-10_09.18.06.2022-06-10%2009_19_47.gif)

- identity

![contentTransition_demo3_2022-06-10_09.25.27.2022-06-10
09_26_04](https://cdn.fatbobman.com/contentTransition_demo3_2022-06-10_09.25.27.2022-06-10%2009_26_04.gif)

也可以通过环境值来完成内容转场模式的设置：

                Text("Hello, World!")
                    .font(change ? .body : .largeTitle)
                    .foregroundStyle(change ? Color.red.gradient : Color.blue.gradient)
                    .fontWeight(change ? .thin : .heavy)
                    .animation(.easeInOut, value: change)
                    .environment(\.contentTransition, .opacity)  // 使用环境值设定
                    .environment(\.contentTransitionAddsDrawingGroup, true) // 启用 GPU 加速

如果想让你的自定义组件（ 对 UIKit 或 AppKit 组件的包装 ）也支持内容转场，需要在定义中查看环境值的设定，例如：

    struct CustomComponent: UIViewRepresentable {
        @Environment(\.contentTransition) var contentTransition
        @Environment(\.contentTransitionAddsDrawingGroup) var drawingGroup // 是否启用 GPU 加速渲染模式

        func makeUIView(context: Context) -> some UIView {
            switch contentTransition {
            case .opacity:
                break
            case .identity:
                break
            case .interpolate:
                break
            default:
                break
            }

            if drawingGroup {

            }
            return UIView()
        }

        func updateUIView(_ uiView: UIViewType, context: Context) {}
    }

所有显式或隐式使用到 Text 的组件均可以从 content transition 中受益，例如：

    Button("Click Me") {}
              .font(change ? .body : .largeTitle)
              .foregroundStyle(change ? Color.red.gradient : Color.blue.gradient)
              .fontWeight(change ? .thin : .heavy)
              .animation(.easeInOut, value: change)

### 控制器的动画问题

相较于控件动画，控制器的动画问题则更加难以解决。NavigationView、TabView、Sheet 等部件完全找不到原生的动画控制解决手段，即使调用
UIKit（ AppKit ） 代码，也只能对动画做细微的调整（比如控制动画开启）。手段与效果均与 SwiftUI 的原生动画能力有巨大的差距。

迫切地希望 SwiftUI 能在此方面有所突破。除了动画逻辑可以更 SwiftUI 化外，最好也能将 AnyTransition 用于控制器的过渡设定。

### 动画性能问题

响应式动画的反应略逊于命令式动画几乎是必然的。SwiftUI 在优化动画性能方面已经做出了一些努力（比如：Canvas、drawingGroup
）。希望随着代码的不断优化以及硬件的不断提升，会让这种差距的感知越来越小。

## 总结

- 动画是创建从一个状态到另一个状态的平滑过渡
- 声明一个动画需要三要素
- 掌握状态的变化所能导致的结果 —— 同一个视图的不同状态还是不同的视图分支
- 时序曲线函数与依赖的关联越精准，产生异常动画的可能性就越小
- 唯一且稳定的视图标识（无论是结构性标识还是显式标识）有助于避免动画异常

SwiftUI 的动画机制设计的还是相当优秀的，相信随着完成度的不断提高，开发者可以用更少的代码获得更加优秀的交互效果。

# 时隔多年，重新创建了博客

用 Hexo 创建了一个博客，主要记录自己在开发健康笔记过程中的一点心得和技术总结。

# 优化在 SwiftUI List 中显示大数据集的响应效率

拥有优秀的交互效果和手感，是很多 iOS
开发者长久以来坚守的原则。同样一段代码，在不同数据量级下的响应表现可能会有云泥之别。本文将通过一个优化列表视图的案例，展现在 SwiftUI
中查找问题、解决问题的思路，其中也会对 SwiftUI 视图的显式标识、@FetchRequest 的动态设置、List
的运作机制等内容有所涉及。本文的范例需运行在 iOS 15 及以上系统，技术特性也以 SwiftUI 3.0 为基础。

首先创建一个假设性的需求：

- 一个可以展示数万条记录的视图
- 从上个视图进入该视图时不应有明显延迟
- 可以一键到达数据的顶部或底部且没有响应延迟

## 响应迟钝的列表视图

通常会考虑采用如下的步骤以实现上面的要求：

- 创建数据集
- 通过 List 展示数据集
- 用 ScrollViewReader 对 List 进行包裹
- 给 List 中的 item 添加 id 标识，用于定位
- 通过 scrollTo 滚动到指定的位置（顶部或底部）

下面的代码便是按照此思路来实现的：

    struct ContentView: View {
        var body: some View {
            NavigationView {
                List {
                    // 通过一个 NavigationView 进入列表视图
                    NavigationLink("包含 40000 条数据的列表视图", destination: ListEachRowHasID())
                }
            }
        }
    }

    struct ListEachRowHasID: View {
        // 数据通过 CoreData 创建。创建了 40000 条演示数据。Item 的结构非常简单，记录容量很小。
        @FetchRequest(
            sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
            animation: .default
        )
        private var items: FetchedResults<Item>

        var body: some View {
            ScrollViewReader { proxy in
                VStack {
                    HStack {
                        Button("Top") {
                            withAnimation {
                                // 滚动到列表最上面的记录
                                proxy.scrollTo(items.first?.objectID, anchor: .center)
                            }
                        }.buttonStyle(.bordered)
                        Button("Bottom") {
                            withAnimation {
                                // 滚动到列表最下面的记录
                                proxy.scrollTo(items.last?.objectID)
                            }
                        }.buttonStyle(.bordered)
                    }
                    List {
                        ForEach(items) { item in
                            ItemRow(item: item)
                                // 给每行记录视图设置标识
                                .id(item.objectID)
                        }
                    }
                }
            }
        }
    }

    struct ItemRow: View {
        let item: Item
        var body: some View {
            Text(item.timestamp, format: .dateTime)
                .frame(minHeight: 40)
        }
    }
    // 满足 ForEach 的 Identifiable 需求
    extension Item: Identifiable {}

> 本文中的 [ 全部源代码可以在此处获取
> ](https://github.com/fatbobman/BlogCodes/tree/main/FetchRequestDemo)

在只拥有数百条记录的情况下，上面的代码运行的效果非常良好，但在创建了 40000 条演示数据后，该视图的响应状况如下：

![id_delay_demo_2022-04-23 12.22.44.2022-04-23
12_29_07](https://cdn.fatbobman.com/id_delay_demo_2022-04-23%2012.22.44.2022-04-23%2012_29_07.gif)

进入视图的时候有明显的卡顿（1 秒多钟），进入后列表滚动流畅且可无延迟的响应滚动到列表底部或顶部的指令。

## 找寻问题原因

或许有人会认为，毕竟数据量较大，进入列表视图有一定的延迟是正常的。但即使在 SwiftUI
的效能并非十分优秀的今天，我们仍然可以做到以更小的卡顿进入一个数倍于当面数据量的列表视图。

考虑到当前的卡顿出现在进入视图的时刻，我们可以将查找问题的关注点集中在如下几个方面：

- Core Data 的性能（ IO 或惰值填充 ）
- 列表视图的初始化或 body 求值
- List 的效能

### Core Data 的性能

@FetchRequest 是 NSFetchedResultsController 的 SwiftUI 包装。它会根据指定的 NSFetchReqeust
，自动响应数据的变化并刷新视图。上面的代码对应的 NSFetchRequest 如下：

    @FetchRequest(
            sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
            animation: .default
        )
    private var items: FetchedResults<Item>

    // 等效的 NSFetchRequest
    extension Item {
        static var fetchRequest:NSFetchRequest<Item> {
            let fetchRequest = NSFetchRequest<Item>(entityName: "Item")
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)]
            return fetchRequest
        }
    }

    // 相当于
    @FetchRequest(fetchRequest: Item.fetchRequest, animation: .default)
    var items:FetchedResults<Item>

此时 fetchRequest 的 returnsObjectsAsFaults 为默认值 false （托管对象为惰值状态），fetchBatchSize
没有设置 （会将所有数据加载到持久化存储的行缓冲区）。

通过使用 Instruments 得知，即便使用当前没有进行优化的 fetchRequest , 从数据库中将 40000
条记录加载到持久化存储的行缓冲所用的时间也只有 11 ms 左右。

![image-20220423145552324](https://cdn.fatbobman.com/image-20220423145552324.png)

另外，通过下面的代码也可以看到仅有 10 余个托管对象（ 显示屏幕高度所需的数据 ）进行了惰值化填充：

    func info() -> some View {
        let faultCount = items.filter { $0.isFault }.count
        return VStack {
            Text("item's count: \(items.count)")
            Text("fault item's count : \(faultCount)")
        }
    }

![image-20220425075620588](https://cdn.fatbobman.com/image-20220425075620588.png)

因此可以排除卡顿是由于 Core Data 的原因所导致的。

### 列表视图的初始化和 body 求值

如果对 SwiftUI 的 NavigationView 有一定了解的话，应该知道 SwiftUI 会对 NavigationLink
的目标视图进行预实例化（但不会对 body 求值）。也就是当显示主界面菜单时，列表视图已经完成了实例的创建（可以通过在 ListEachRowHasID
的构造函数中添加打印命令得以证明），因此也不应是实例化列表视图导致的延迟。

通过检查 ListEachRowHasID 的 body 的求值消耗时间，也没有发现任何的效率问题。

        var body: some View {
            let start = Date()
            ScrollViewReader { proxy in
                VStack {
                    ....
                }
            }
            let _ = print(Date().timeIntervalSince(start))
        }
    // 0.0004889965057373047

目前已经可以基本排除性能问题来源于 IO、数据库、列表视图实例化等因素，那么有极大的可能源自 SwiftUI 的内部处理机制。

### List 的效能

List 作为 SwiftUI 对 UITableView （ NSTableView ）的封装，大多数情况下它的性能都比较令人满意。在 [ SwiftUI
视图的生命周期研究 ](/zh/posts/swiftuilifecycle/) 一文中，我对 List
如何对子视图的显示进行优化做了一定的介绍。按照正常的逻辑，当进入列表视图 ListEachRowHasID 后 List 只应该实例化十几个 ItemRow
子视图 （ 按屏幕的显示需要 ），即便使用 scrollTo 滚动到列表底部，List 也会对滚动过程进行显示优化，滚动过程中至多实例化 100 多个
ItemRow 。

我们对 ItemRow 进行一定的修改以验证上述假设：

    struct ItemRow:View{
        static var count = 0
        let item:Item
        init(item:Item){
            self.item = item
            Self.count += 1
            print(Self.count)
        }
        var body: some View{
    //        let _ = print("get body value")
            Text(item.timestamp, format: .dateTime)
                .frame(minHeight:40)
        }
    }

重新运行，再次进入列表视图，我们竟然得到了如下的结果：

![itemRow_count_2022-04-23_16.39.41.2022-04-23
16_40_53](https://cdn.fatbobman.com/itemRow_count_2022-04-23_16.39.41.2022-04-23%2016_40_53.gif)

List 将所有数据的 itemRow 都进行了实例化，一共 40000 个。这与之前仅会实例化 10 - 20 个子视图的预测真是大相径庭。是什么影响了
List 对视图的优化逻辑？

在进一步排除掉 ScrollViewReader 的影响后，所有的迹象都表明用于给 scrollTo 定位的 id 修饰符可能是导致延迟的罪魁祸首。

在将 `.id(item.objectID)` 注释掉后，进入列表视图的卡顿立刻消失了，List 对子视图的实例化数量也完全同我们最初的预测一致。

![itemRow_withoutID_2022_04_23.2022-04-23
17_01_05](https://cdn.fatbobman.com/itemRow_withoutID_2022_04_23.2022-04-23%2017_01_05.gif)

现在摆在我们面前有两个问题：

- 为什么使用了 id 修饰符的视图会提前实例化呢？
- 不使用 `.id(item.objectID)` ，我们还有什么方法为列表两端定位？

## id 修饰符与视图的显式标识

想搞清楚为什么使用了 id 修饰符的视图会提前实例化，我们首先需要了解 id 修饰符的作用。

标识（ Identity ）是 SwiftUI 在程序的多次更新中识别相同或不同元素的手段，是 SwiftUI 理解你 app
的关键。标识为随时间推移而变化的视图值提供了一个坚固的锚，它应该是稳定且唯一的。

在 SwiftUI 应用代码中，绝大多数的视图标识都是通过结构性标识 （有关结构性标识的内容可以参阅 [ ViewBuilder 研究（下） ——
从模仿中学习 ](/zh/posts/viewbuilder2/) ）来实现的 ——
通过视图层次结构（视图树）中的视图类型和具体位置来区分视图。但在某些情况下，我们需要使用显式标识（ Explicit identity ）的方式来帮助
SwiftUI 辨认视图。

在 SwiftUI 中为视图设置显式标识目前有两种方式：

- 在 ForEach 的构造方法中指定

由于 ForEach 中的视图数量是动态的且是在运行时生成的，因此需要在 ForEach 的构造方法中指定可用来标识子视图的 KeyPath
。在我们的当前的例子中，通过将 Item 声明为符合 Identifiable 协议，从而实现了在 ForEach 中进行了默认指定。

    extension Item: Identifiable {}
    // NSManagedObject 是 NSObject 的子类。NSObject 为 Identifiable 提供了默认实现
    ForEach(items) { item in ... }
    // 相当于
    ForEach(items, id:\.id) { item in ... }

- 通过 id 修饰符指定

id 修饰符是另一个对视图进行显式标识的方式。通过它，开发者可以使用任何符合 Hashable 协议的值为视图设置显式标识。ScrollViewProxy
的 scrollTo 方法就是通过该值来找到对应的视图。另外如果 id 的标识值发生变化，SwiftUI
将丢弃原视图（生命周期终止及重置状态）并重新创建新的视图。

当仅通过 ForEach 来指定显示标识时，List 会对这些视图的显示进行优化，仅在需要显示时才会对其进行实例化。但一旦为这些子视图添加了 id
修饰符，这些视图将无法享受到 List 提供的优化能力 （ List 只会对 ForEach 中的内容进行优化）。

> id 修饰符标识是通过 IDViewList 对显式标识视图进行跟踪、管理和缓存，它与 ForEach 的标识处理机制完全不同。使用了 id
> 修饰符相当于将这些视图从 ForEach 中拆分出来，因此丧失了优化条件。

总之， **当前在数据量较大的情况下，应避免在 List 中对 ForEach 的子视图使用 id 修饰符** 。

虽然我们已经找到了导致进入列表视图卡顿的原因，但如何在不影响效率的情况下通过 scrollTo 来实现到列表端点的滚动呢？

## 解决方案一

从 iOS 15 开始，SwiftUI 为 List 添加了更多的定制选项，尤其是解除了对列表行分割线设置的屏蔽且添加了官方的实现。我们可以通过在
ForEach 的外面分别为列表端点设置显式标识来解决使用 scrollTo 滚动到指定位置的问题。

对 ListEachRowHasID 进行如下修改：

    struct ListEachRowHasID: View {
        @FetchRequest(
            sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
            animation: .default
        )
        private var items: FetchedResults<Item>

        @FetchRequest(fetchRequest: Item.fetchRequest1, animation: .default)
        var items1:FetchedResults<Item>

        init(){
            print("init")
        }

        var body: some View {
            ScrollViewReader { proxy in
                VStack {
                    HStack {
                        Button("Top") {
                            withAnimation {
                                proxy.scrollTo("top", anchor: .center)
                            }
                        }.buttonStyle(.bordered)
                        Button("Bottom") {
                            withAnimation {
                                proxy.scrollTo("bottom")
                            }
                        }.buttonStyle(.bordered)
                    }
                    List {
                        // List 中不在 ForEach 中的视图不享受优化，无论显示与否都会提前实例化
                        TopCell()
                            .id("top")
                            // 隐藏两端视图的列表分割线
                            .listRowSeparator(.hidden)
                        ForEach(items) { item in
                            ItemRow(item: item)
                        }
                        BottomCell()
                            .id("bottom")
                            .listRowSeparator(.hidden)
                    }
                    // 设置最小行高，隐藏列表两端的视图
                    .environment(\.defaultMinListRowHeight, 0)
                }
            }
        }
    }

    struct TopCell: View {
        init() { print("top cell init") }
        var body: some View {
            Text("Top")
                .frame(width: 0, height: 0) // 隐藏两端视图
        }
    }

    struct BottomCell: View {
        init() { print("bottom cell init") }  // 仅两端的视图会被提前实例化，其他的视图仅在需要时进行实例化
        var body: some View {
            Text("Bottom")
                .frame(width: 0, height: 0)
        }
    }

运行修改后的代码结果如下：

![onlyTopAndBottomWithID_2022-04-23_18.58.53.2022-04-23
19_02_53](https://cdn.fatbobman.com/onlyTopAndBottomWithID_2022-04-23_18.58.53.2022-04-23%2019_02_53.gif)

目前我们已经可以秒进列表视图，并实现了通过 scrollTo 滚动到指定的位置。

> 由于 id 修饰符并非惰性修饰符（ Inert modifier ），因此我们无法在 ForEach 中仅为列表的头尾数据使用 id
> 修饰符。如果你尝试通过 if 语句的方式利用判断来添加 id 修饰符，将进一步劣化性能（可在 [ ViewBuilder 研究（下） —— 从模仿中学习
> ](/zh/posts/viewbuilder2/) ）中找到原因 ）。 [ 范例代码
> ](https://github.com/fatbobman/BlogCodes/tree/main/FetchRequestDemo)
> 中也提供了这种实现方式，大家可以自行比对。

## 新的问题

细心的朋友应该可以注意到，运行解决方案一的代码后，在第一次点击 bottom 按钮时，大概率会出现延迟情况（并不会立即开始滚动）。

![scrollToBottomDelay_2022-04-24_07.40.24.2022-04-24
07_42_06](https://cdn.fatbobman.com/scrollToBottomDelay_2022-04-24_07.40.24.2022-04-24%2007_42_06.gif)

从控制台的打印信息可以得知，通过 scrollTo 滚动到指定的位置，List
会对滚动过程进行优化。通过对视觉的欺骗，仅需实例化少量的子视图即可完成滚动动画（同最初的预计一致），从而提高效率。

由于整个的滚动过程中仅实例化并绘制了 100 多个子视图，对系统的压力并不大，因此在经过反复测试后，首次点击 bottom 按钮会延迟滚动的问题大概率为当前
ScrollViewProxy 的 Bug 所致。

## 解决方案二

在认识到 ScrollViewProxy 以及在 ForEach 中使用 id 修饰符两者的异常表现后，我们只能尝试通过调用底层的方式来获得更加完美的效果。

> 除非没有其他选择，否则我并不推荐大家对 UIKit ( AppKit ) 控件进行重新包装，应使用尽可能微小的侵入方式对 SwiftUI
> 的原生控件进行补充和完善。

我们将通过 [ SwiftUI-Introspect ](https://github.com/siteline/SwiftUI-Introspect)
来实现在 List 中滚动到列表两端。

    import Introspect
    import SwiftUI
    import UIKit

    struct ListUsingUIKitToScroll: View {
        @FetchRequest(
            sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
            animation: .default
        )
        private var items: FetchedResults<Item>
        @State var tableView: UITableView?
        var body: some View {
            VStack {
                HStack {
                    Button("Top") {
                        // 使用 UITableView 的 scrollToRow 替代 ScrollViewReader 的 scrollTo
                        self.tableView?.scrollToRow(at: IndexPath(item: 0, section: 0), at: .middle, animated: true)
                    }.buttonStyle(.bordered)
                    Button("Bottom") {
                        self.tableView?.scrollToRow(at: IndexPath(item: items.count - 1, section: 0), at: .bottom, animated: true)
                    }.buttonStyle(.bordered)
                }
                List {
                    // 无需使用 id 修饰符进行标识定位
                    ForEach(items) { item in
                        ItemRow(item: item)
                    }
                }
                .introspectTableView(customize: {
                    // 获取 List 对应的 UITableView 实例
                    self.tableView = $0
                })
            }
        }
    }

至此我们已经实现了无延迟的进入列表视图，并在首次滚动到列表底部时也没有延迟。

![scrollByUITableView_2022-04-23_19.44.26.2022-04-23
19_46_20](https://cdn.fatbobman.com/scrollByUITableView_2022-04-23_19.44.26.2022-04-23%2019_46_20.gif)

希望 SwiftUI 在之后的版本中能够改善上面的性能问题，这样就可以无需使用非原生方法也能达成好的效果。

> 范例代码还提供了使用 @SectionedFetchRequest 和 section 进行定位的例子。

## 生产中的处理方式

本文为了演示 id 修饰符在 ForEach 中的异常状况以及问题排查思路，创建了一个在生产环境中几乎不可能使用的范例。如果在正式开发中面对需要在 List
中使用大量数据的情况，我们或许可以考虑下述的几种解决思路（ 以数据采用 Core Data 存储为例 ）：

### 数据分页

将数据分割成若干页面是处理大数据集的常用方法，Core Data 对此也提供了足够的支持。

    fetchRequest.fetchBatchSize = 50
    fetchRequest.returnsObjectsAsFaults = true // 如每页数据较少，可直接对其进行惰值填充，进一步提高效率
    fetchRequest.fetchLimit = 50 // 每页所需数据量
    fetchRequest.fetchOffset = 0 // 逐页变换  count * pageNumber

通过使用类似上面的代码，我们可以逐页获取到所需数据，极大地减轻了系统的负担。

### 升降序切换

对数据进行降序显示且仅允许使用者手工滚动列表。系统中的邮件、备忘录等应用均采用此种方式。

由于用户滚动列表的速度并不算快，所以对于 List 来说压力并不算大，系统将有足够的时间构建视图。

对于拥有复杂结构子视图（尺寸不一致、图文混排）的 List 来说，在数据量大的情况下，任何的大跨度滚动（ 例如直接滚动到列表底部 ）都会给 List
造成巨大的布局压力，有不小的滚动失败的概率。如果必须给用户提供直接访问两端数据的方式，动态切换 SortDescriptors 或许是更好的选择。

    @FetchRequest(
            sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
            animation: .default
        )
    private var items: FetchedResults<Item>

    // 在视图中切换 SortDescriptors
    $items.wrappedValue.sortDescriptors = [SortDescriptor(\Item.timestamp,order: .reverse)]

### 增量读取

通讯类软件（比如微信）往往采用初期仅显示部分最新数据，向上滚动后采用增量获取数据的方式来减轻系统压力。

- 不使用 @FetchRequest 或 NSFetchResultController 等动态管理方式，用数组来持有数据
- 通过设置 NSPredicate 、NSSortDescription 和 `fetchRequest.fetchLimit` 获取若干最新数据，将数据逆向添加入数组
- 在列表显示后率先移动到最底端（取消动画）
- 通过 refreshable 调用下一批数据，并继续逆向添加入数组

用类似的思路，还可以实现向下增量读取或者两端增量读取。

## 总结

相较于 UIKit ，已经推出了 3 年的 SwiftUI 仍有很多的不足。但回首最初的版本，现在我们已经可以实现太多以前无法想象的功能。期盼 6 月的
WWDC 会带来更多的好消息。

# MacBook Pro 使用体验

MacBook Pro 14’ 已经使用一周了，今天我们来聊聊这次换机的过程以及对新机器的感受。

## 选购

在本次换机器之前，我的主力开发机是一台 2019 年出的 iMac 27’（ i 9 3.6 GHz、RX 580 8 GB、64 GB
内存）。纯粹从性能的角度来说，直到今天也是够用的。促使我产生更换机器的念头主要有以下两点原因：

- 疫情管控已经结束，今年开始会多出去走走
- 风扇噪音

我是一个对噪声比较敏感的人，iMac 在 CPU 到达 70 度时，会加大风扇的转速，严重影响使用感受。而且由于一些系统或非系统方面的原因，在 macOS
下，很容易因为某个进程出现问题而达到上述阈值，我已不胜其扰。

从去年开始就一直盼望苹果能推出基于 M 系列的 iMac 27’ ，但目前看来机会越来越渺茫。借着本次 MacBook 更换到 M 2
芯片时，决定切换到已许久不用的笔记本生态。

选机过程很顺利，16 寸太大（ 尽管只有极少的移动需求，但仍感觉太大、太重 ），13 寸又是老款，因此 14 寸是比较合适的选择。我并没有过多的 GPU
性能需求，即使最低配置的 CPU 也应能胜任这几年的工作。但出于长久以来的火力恐惧症，64 GB 内存仍是必须的，因此只能选择 Max 版本的 CPU（
被刀法精准地切中 ）。

3 月 2 日在苹果官网下的单，被告知将在 11 日左右到达，但在 6
日便收到了机器。不知道算是人品爆发还是当前的需求不旺。总之由于机器意外地提前送达，十分仓促地购买了一些与之有关的配件，有些产品的选择并不理想。

## 转移资料

之前的 iMac 从使用以来一直没有重装过系统，每次都是直接更新的。或多或少存在并开启了一些无用服务。另一方面考虑到本次更换是从 Intel 切换到 M 2
上，因此放弃了使用系统提供的转移功能，采用了手动搬家模式。

由于文档、代码都有备份，因此这方面转移没有任何难度。不过在其他方面还是有几点需要记录的（ 为今后提个醒 ）：

- 密钥文件

几年使用下来，机器中保存了不少用于连接各种服务、服务器的密钥文件。之前没做整理，本次转移资料时，一并对它们进行了统一管理。

- 网络工具

之前一直使用的是 ShadowSocks + Proxifier 的组合，本次切换成 Clash X Pro。相较之前的搭配，Clash X Pro
使用起来更加地方便，但配置起来则没有 Proxifier 那么直观。ClashX 和 Proxifier 没有办法共存，两者之间会冲突。

- 使用注册码的软件

相较从 App Store
购买的软件，那些只能在其网站上购买的软件在转移过程中则稍显麻烦一些。需要首先从旧机器上注销掉，然后才能在新机器上进行安装。我完全尊重这些开发者不提供 App
Store 版本的选择，不过还是希望 App Store 能更加有活力一些，吸引更多的软件在其上进行销售。

- 已经购买但不再更新的软件

在安装软件的过程中，发现之前在 App Store 购买的一些软件已经不再提供下载了。好在将这些 App 从旧机器上直接拷贝过来后，App Store
仍会认证它们是已经购买过的软件，可以顺利使用。

## 体验

![IMG_2673](https://cdn.fatbobman.com/IMG_2673.png)

- 安静！除了暂时尚未体验到的移动需求外，安静就是本次更换行为的最大收获。另外本次也同时将用于时间机器的外置硬盘换成了 NVMe SSD，在提升性能的同时，完全消除了由硬盘所产生的噪音。
- 性能够用。因为我不做什么太能体现机器性能的操作，因此并没有感觉到性能方面明显的提升。考虑到这是在温度控制如此优秀的情况下展现的性能，表现令人满意。
- 刘海并没有想象中那么难适应。但对菜单图标确实会有一些影响。目前采用 [ iBar ](https://www.better365.cn/ibar.html) 进行管理。

![image-20230314144106509](https://cdn.fatbobman.com/image-20230314144106509.png)

- 尝试在不通电的情况下使用了一段时间，续航没有想象中那么惊艳（ 主要使用 Xcode ），但应该也是当前的优秀水平。根据 [ @jyrnan ](https://twitter.com/jyrnan) 的建议，安装了 AIDente Pro 对电池进行管理。说实话，这种产品的效果主要还是依赖每个人的使用习惯。对于一些几乎没有移动需求的使用者来说，或许效果会明显一点。
- MacBook 在从休眠状态唤醒后，会有相当概率出现“磁盘没有正常推出”的通知（ 不会自动消除 ）。尽管出现了上述通知，但外置硬盘仍处于正常的使用状态中。就是提示很烦人。在尝试并购买了几款软件后， [ @广东 小 ](https://twitter.com/2tmz7wxnsTp4T5p) 向我提供了他开发的开源软件 [ Bian-Kill ](https://github.com/xiaogdgenuine/BIAN-Killer) 。虽然仍无法完全避免这些恼人的提醒，但是 Bian-Kill 可以帮助使用者在提醒出现后立即自动清除，算是对改善使用体验起到了不小的作用。
- 屏幕亮度十分令人满意，在强光下，也有很好的表现。我临时配置的显示器亮度明显不足（ 号称 HDR 400 ），有了考虑 Studio Display 的想法（ 冲动是魔鬼 ）。另外，在由睡眠状态唤醒后，外置显示器需要较长时间才能有显示，不知道 Studio Display 是否存在这个问题。
- 键盘手感不错，对于像我这种十分喜欢 Magic Keyboard 手感的人来说，可以实现无缝衔接。
- M 系统彻底抛弃了老的蓝牙协议，我很喜欢使用的 A 1016 已经没有办法连接了，十分遗憾。
- 不知是适配的问题还是系统的问题，MacBook Pro 在竖屏上显示偶尔会出现异常。例如屏保状态只显示一半屏幕，Developer App 下，播放视频也会出现旋转并且错位。

## 总结

总体下来，这是一次愉快的更新过程。期待未来它在移动场景下的表现。今年是该多出去走走了。

# 在 Spotlight 中展示应用中的 Core Data 数据

本文将讲解如何通过 NSCoreDataSpotlightDelegate（WWDC 2021 版本）实现将应用程序中的 Core Data 数据添加到
Spotlight 索引，方便用户查找并提高 App 的曝光率。

## 基础

### Spotlight

自 2009 年登陆 iOS 以来，经过 10 多年的发展，Spotlight（聚焦）已经从苹果系统的官方应用搜索变成了一个包罗万象的功能入口，用户对
Spotligh 的使用率及依赖程度也在不断地提升。

在 Spotlight 中展示应用程序中的数据可以显著地提高应用的曝光率。

### Core Spotlight

从 iOS 9 开始，苹果推出了 Core Spotlight 框架，让开发者可以将自己应用的内容添加到 Spotlight 的索引中，方便用户统一查找。

为应用中的项目建立 Spotlight 索引，需要以下步骤：

- 创建一个 CSSearchableItemAttributeSet（属性集）对象，为你要索引的项目设置适合的元数据（属性）。
- 创建一个 CSSearchableItem（可搜索项）对象来表示该项目。每个 CSSearchableItem 对象均设有唯一标识符，方便之后引用（更新、删除、重建）
- 如果有需要，可以为项目指定一个域标识符，这样就可以将多个项目组织在一起，便于统一管理
- 将上面创建的属性集（CSSearchableItemAttributeSet）关联到可搜索项（CSSearchableItem）中
- 将可搜索项添加到系统的 Spotlight 索引中

开发者还需要在应用中的项目发生修改或删除时及时更新 Spotlight 索引，让使用者始终获得有效的搜索结果。

### NSUserActivity

NSUserActivity
对象提供了一种轻量级的方式来描述你的应用程序状态，并将其用于以后。创建这个对象来捕获关于用户正在做什么的信息，如查看应用程序内容、编辑文档、查看网页或观看视频等。

当使用者从 Spotlight 中搜索到你的应用程序内容数据（可搜索项）并点击后，系统将启动应用程序，并向其传递一个同可搜索项对应的
NSUserActivity 对象（activityType 为
CSSearchableItemActionType），应用程序可以通过该对象中的信息，将自己恢复到一个适当的状态。

比如，用户在 Spotlight 中通过关键字查询邮件，点击搜索结果后，应用将直接定位到该邮件并显示其详细信息。

### 流程

结合上面对于 Core Spotlight 和 NSUserActivity 的介绍，我们用代码段简单地梳理一下流程：

#### 创建可搜索项

    import CoreSpotlight

    let attributeSet = CSSearchableItemAttributeSet(contentType: .text)
    attributeSet.displayName = "星球大战"
    attributeSet.contentDescription = "在很久以前，一个遥远的银河系，肩负正义使命的绝地武士与帝国邪恶黑暗势力作战的故事。"

    let searchableItem = CSSearchableItem(uniqueIdentifier: "starWar", domainIdentifier: "com.fatbobman.Movies.Sci-fi", attributeSet: attributeSet)

#### 添加至 Spotlight 索引

            CSSearchableIndex.default().indexSearchableItems([searchableItem]){ error in
                if let error = error {
                    print(error.localizedDescription)
                }
            }

![image-20210922084725675](https://cdn.fatbobman.com/image-20210922084725675-2271647.png)

#### 应用程序从 Spotlight 接收 NSUserActivity

SwiftUI life cycle

            .onContinueUserActivity(CSSearchableItemActionType){ userActivity in
                if let userinfo = userActivity.userInfo as? [String:Any] {
                    let identifier = userinfo["kCSSearchableItemActivityIdentifier"] as? String ?? ""
                    let queryString = userinfo["kCSSearchQueryString"] as? String ?? ""
                    print(identifier,queryString)
                }
            }

    // Output : starWar 星球大战

UIKit life cycle

        func scene(_ scene: UIScene, continue userActivity: NSUserActivity) {
            if userActivity.activityType == CSSearchableItemActionType {
                if let userinfo = userActivity.userInfo as? [String:Any] {
                    let identifier = userinfo["kCSSearchableItemActivityIdentifier"] as? String ?? ""
                    let queryString = userinfo["kCSSearchQueryString"] as? String ?? ""
                    print(identifier,queryString)
                }
            }
        }

#### 更新 Spotlight 索引

方式同新增索引完全一样，必须保证 `uniqueIdentifier` 一致。

            let attributeSet = CSSearchableItemAttributeSet(contentType: .text)
            attributeSet.displayName = "星球大战（修改版）"
            attributeSet.contentDescription = "在很久以前，一个遥远的银河系，肩负正义使命的绝地武士与帝国邪恶黑暗势力作战的故事。"
            attributeSet.artist = "乔治·卢卡斯"

            let searchableItem = CSSearchableItem(uniqueIdentifier: "starWar", domainIdentifier: "com.fatbobman.Movies.Sci-fi", attributeSet: attributeSet)

            CSSearchableIndex.default().indexSearchableItems([searchableItem]){ error in
                if let error = error {
                    print(error.localizedDescription)
                }
            }

![image-20210922091534038](https://cdn.fatbobman.com/image-20210922091534038.png)

#### 删除 Spotlight 索引

- 删除指定 `uniqueIdentifier` 的项目

          CSSearchableIndex.default().deleteSearchableItems(withIdentifiers: ["starWar"]){ error in
              if let error = error {
                  print(error.localizedDescription)
              }
          }

- 删除指定域标识符的项目

          CSSearchableIndex.default().deleteSearchableItems(withDomainIdentifiers: ["com.fatbobman.Movies.Sci-fi"]){_ in }

删除域标识符的操作是递归的。上面的代码只会删除所有 `Sci-fi` 组别，而下面的代码将删除应用程序中全部的电影数据

    CSSearchableIndex.default().deleteSearchableItems(withDomainIdentifiers: ["com.fatbobman.Movies"]){_ in }

- 删除应用程序中的全部索引数据

          CSSearchableIndex.default().deleteAllSearchableItems{ error in
              if let error = error {
                  print(error.localizedDescription)
              }
          }

## NSCoreDataCoreSpotlightDelegate 实现

NSCoreDataCoreSpotlightDelegate 提供了一组支持 Core Data 同 Core Spotlight
集成的方法，极大地简化了开发者在 Spotlight 中创建并维护应用程序中 Core Data 数据的工作难度。

在 WWDC 2021 中，NSCoreDataCoreSpotlightDelegate 得到进一步升级，通过持久化历史跟踪，开发者
**将无需手动维护数据的更新、删除，Core Data 数据的任何变化都将及时地反应在 Spotlight 中** 。

### Data Model Editor

要在 Spotlight 中索引应用中的 Core Data 数据，首先需要在数据模型编辑器中对需要索引的实体（Entity）进行标记。

- 只有标记过的实体才能被索引
- 只有被标记过的实体属性发生变化，才会触发索引

![image-20210922101458785](https://cdn.fatbobman.com/image-20210922101458785-2276899.png)

比如说，你的应用中创建了若干的 Entity，不过只想对其中的 `Movie` 进行索引，且只有当 `Movie` 的 `title` 和 `description` 发生变化时才会更新索引。那么只需要开启 `Movie` 实体中 `title` 和 `dscription` 的 `Index in Spotlight` 即可。

> Xcode 13 中废弃了 Store in External Record File 并且删除了在 Data Model Editor 中设置
> DisplayName。

### NSCoreDataCoreSpotlightDelegate

当被标记的实体记录数据更新时（创建、修改），Core Data 将调用 NSCoreDataCoreSpotlightDelegate 中的 `attributeSet` 方法，尝试获得对应的可搜索项，并更新索引。

    public class DemoSpotlightDelegate: NSCoreDataCoreSpotlightDelegate {
        public override func domainIdentifier() -> String {
            return "com.fatbobman.CoreSpotlightDemo"
        }

        public override func attributeSet(for object: NSManagedObject) -> CSSearchableItemAttributeSet? {
            if let note = object as? Note {
                let attributeSet = CSSearchableItemAttributeSet(contentType: .text)
                attributeSet.identifier = "note." + note.viewModel.id.uuidString
                attributeSet.displayName = note.viewModel.name
                return attributeSet
            } else if let item = object as? Item {
                let attributeSet = CSSearchableItemAttributeSet(contentType: .text)
                attributeSet.identifier = "item." + item.viewModel.id.uuidString
                attributeSet.displayName = item.viewModel.name
                attributeSet.contentDescription = item.viewModel.descriptioinContent
                return attributeSet
            }
            return nil
        }
    }

- 如果你的应用程序中需要索引多个 Entity，在 `attributeSet` 中需首先判断托管对象的具体类型，然后为其创建对应的可搜索项数据。
- 对于特定的数据，即使被标记成可索引，也可以通过在 attributeSet 中返回 nil 将其排除在索引之外
- identifier 中最好设置成可以同你的记录对应的标识（identifier 是元数据，并非 CSSearchableItem 的 `uniqueIdentifier` ），方便你在之后的代码中直接利用它。
- 如不特别指定域标识符，默认系统会使用 Core Data 持久存储的标识符
- 应用中的数据记录被删除后，Core Data 将自动从 Spotlight 中删除其对应的可搜索项。

> CSSearchableItemAttributeSet 具有众多的可用元数据。比如，你可以添加缩略图（ `thumbnailData`
> ），或者让用户可以直接拨打记录中的电话号码（分别设置 `phoneNUmbers` 和 `supportsPhoneCall`
> ）。更多信息，请看 [ 官方文档
> ](https://developer.apple.com/documentation/corespotlight/cssearchableitemattributeset)

### CoreDataStack

在 Core Data 中启用 NSCoreDataCoreSpotlightDelegate 有两个先决条件：

- 持久化存储的类型为 Sqlite
- 必须启用持久化历史跟踪（Persistent History Tracking）

因此在 Core Data Stack 中需要使用类似如下的代码：

    class CoreDataStack {
        static let shared = CoreDataStack()

        let container: NSPersistentContainer
        let spotlightDelegate:NSCoreDataCoreSpotlightDelegate

        init() {
            container = NSPersistentContainer(name: "CoreSpotlightDelegateDemo")
            guard let description = container.persistentStoreDescriptions.first else {
                        fatalError("###\(#function): Failed to retrieve a persistent store description.")
            }

            // 启用持久化历史跟踪
            description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
            description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)

            container.loadPersistentStores(completionHandler: { (storeDescription, error) in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })

            // 创建索引委托
            self.spotlightDelegate = NSCoreDataCoreSpotlightDelegate(forStoreWith: description, coordinator: container.persistentStoreCoordinator)

            // 启动自动索引
            spotlightDelegate.startSpotlightIndexing()
        }
    }

对于已经上线的应用程序，在添加了 NSCoreDataCoreSpotlightDelegate 功能后，首次启动时，Core Data
会自动将满足条件（被标记）的数据添加到 Spotlight 索引中。

> 上述代码中，只开启了持久化历史跟踪，并没有对失效数据进行定期清理，长期运行下去会导致数据膨胀，影响执行效率。如想了解更多有关持久化历史跟踪信息，请阅读
> [ 在 CoreData 中使用持久化历史跟踪 ](/zh/posts/persistenthistorytracking/) 。

### 停止、删除索引

如果想重建索引，应该首先停止索引，然后再删除索引。

           stack.spotlightDelegate.stopSpotlightIndexing()
           stack.spotlightDelegate.deleteSpotlightIndex{ error in
               if let error = error {
                      print(error)
               }
           }

> 另外，也可以使用上面介绍的方法，直接使用 CSSearchableIndex 来更精细的删除索引内容。

### onContinueUserActivity

NSCoreDataCoreSpotlight 在创建可搜索项（CSSearchableItem）时会使用托管对象的 uri 数据作为 `uniqueIdentifier` ，因此，当用户点击 Spotlight 中的搜索结果时，我们可以从传递给应用程序的 NSUserActivity 的
userinfo 中获取到这个 uri。

由于传递给应用程序的 NSUserActivity 中仅提供有限的信息（ `contentAttributeSet` 为空），因此，我们只能依靠这个
uri 来确定对应的托管对象。

SwiftUI 提供了一种便捷的方法 `onConinueUserActivity` 来处理系统传递的 NSUserActivity。

    import SwiftUI
    import CoreSpotlight
    @main
    struct CoreSpotlightDelegateDemoApp: App {
        let persistenceController = PersistenceController.shared

        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environment(\.managedObjectContext, persistenceController.container.viewContext)
                    .onContinueUserActivity(CSSearchableItemActionType, perform: { na in
                        if let userinfo = na.userInfo as? [String:Any] {
                            if let identifier = userinfo["kCSSearchableItemActivityIdentifier"] as? String {
                                let uri = URL(string:identifier)!
                                let container = persistenceController.container
                                if let objectID = container.persistentStoreCoordinator.managedObjectID(forURIRepresentation: uri) {
                                if let note = container.viewContext.object(with: objectID) as? Note {
                                    // 切换到 note 对应的状态
                                } else if let item = container.viewContext.object(with: objectID) as? Item {
                                   // 切换到 item 对应的状态
                                }
                            }
                        }
                    })
            }
        }
    }

- 通过 userinfo 中的 `kCSSearchableItemActivityIdentifier` 键获取到 `uniqueIdentifier` （Core Data 数据的 uri）
- 将 uri 转换成 NSManagedObjectID
- 通过 objectID 获取到托管对象
- 根据托管对象，设置应用程序到对应的状态。

> 我个人不太喜欢这种将处理 NSUserActivity 的逻辑嵌入视图代码的做法，如果想在 UIWindowSceneDelegate 中处理
> NSUserActivity，请参阅 [ Core Data with CloudKit （六） —— 创建与多个 iCloud 用户共享数据的应用
> ](/zh/posts/coredatawithcloudkit-6/) 中关于 UIWindowSceneDelegate 的用法。

### CSSearchQuery

CoreSpotlight 中还提供了一种在应用程序中查询 Spotlight 的方案。通过创建 CSSearchQuery，开发者可以在
Spotlight 中搜索当前应用已被索引的数据。

        func getSearchResult(_ keyword: String) {
            let escapedString = keyword.replacingOccurrences(of: "\\", with: "\\\\").replacingOccurrences(of: "\"", with: "\\\"")
            let queryString = "(displayName == \"*" + escapedString + "*\"cd)"
            let searchQuery = CSSearchQuery(queryString: queryString, attributes: ["displayName", "contentDescription"])
            var spotlightFoundItems = [CSSearchableItem]()
            searchQuery.foundItemsHandler = { items in
                spotlightFoundItems.append(contentsOf: items)
            }

            searchQuery.completionHandler = { error in
                if let error = error {
                    print(error.localizedDescription)
                }
                spotlightFoundItems.forEach { item in
                    //  do something
                }
            }

            searchQuery.start()
        }

- 首先需要对搜索关键字进行安全处理，对 `\` 进行转义
- `queryString` 的查询形式同 NSPredicate 很类似，比如上面代码中就是查询所有 `displayName` 中含有 keyword 的数据（忽视大小写、音标字符），详细信息请查阅 [ 官方文档 ](https://developer.apple.com/documentation/corespotlight/cssearchquery)
- attributes 中设置了返回的可搜索项（CSSearchableItem）中需要的属性（例如可搜索项中有十个元数据内容，只需返回设置中的两个）
- 当获得搜索结果时将调用 `foundItemsHandler` 闭包中的代码
- 配置好后用 `searchQuery.start()` 启动查询

> 对于使用 Core Data 的应用来说，直接通过 Core Data 查询或许是更好的方式。

## 注意事项

### 失效日期

默认情况下，CSSearchableItem 的失效日期（ `expirationDate` ）为 30
天。也就是说，如果一个数据被添加到索引中，如果在 30 天内没有发生任何的变动（更新索引），那么 30 天后，我们将无法从 Spotlight
中搜索到这个数据。

解决的方案有两种：

- 定期重建 Core Data 数据的 Spotlight 索引

方法为停止索引——删除索引——重新启动索引

- 为 CSSearchableItemAttributeSet 添加失效日期元数据

正常情况下，我们可以为 NSUserActivity 设置失效日期，并将 CSSearchableItemAttributeSet 同其进行关联。但
NSCoreDataCoreSpotlightDelegate 中只能设置 CSSearchableItemAttributeSet。

官方并没有公开 CSSearchableItemAttributeSet 的失效日期属性，因此无法保证下面的方法一直有效

            if let note = object as? Note {
                let attributeSet = CSSearchableItemAttributeSet(contentType: .text)
                attributeSet.identifier = "note." + note.viewModel.id.uuidString
                attributeSet.displayName = note.viewModel.name
                attributeSet.setValue(Date.distantFuture, forKey: "expirationDate")
                return attributeSet
            }

> setValue 会自动将 CSSearchableItemAttributeSet 中的 `_kMDItemExpirationDate` 设置成
> `4001-01-01` ，Spotlight 会将 `_kMDItemExpirationDate` 的时间设置为
> NSUserActivity 的 `expirationDate`

### 模糊查询

Spotlight 支持模糊查询。比如输入 `xingqiu` 便可能在搜索结果中显示上图的“星球大战”。不过苹果并没有在 CSSearchQuery
中开放模糊查询的能力。如果希望用户在应用内获得同 Spotlight 类似的体验，还是通过创建自己的代码在 Core Data 中实现比较好。

另外，Spotlight 的模糊查询只对 `displayName` 有效，对 `contentDescription` 没有效果

### 字数限制

CSSearchableItemAttributeSet 中的元数据是用来描述记录的，并不适合保存大量的数据。 `contentDescription`
目前支持的最大字符数为 300。如果你的内容较多，最好截取真正对用户有用的信息。

### 可搜索项数量

应用的可搜索项需控制在几千条之内。超出这个量级，将严重影响查询性能

## 总结

希望有更多的应用认识到 Spotlight 的重要性，尽早登陆这个设备应用的重要入口。

# 掌握 Core Data 中的关系：实战

在之前的文章 [ 掌握 Core Data 中的关系：基础 ](/zh/posts/mastering-relationships-in-core-
data-fundamentals/) 中，我们已经对 Core Data 中的关系基本概念和使用原则进行了探讨。本文将在此基础上进一步，分享关于处理
Core Data 关系的一些实用经验和技巧。目的是为了帮助开发者更有效地利用 Core Data 框架的关系功能，提高开发的灵活性和效率。

> 本文旨在为已具备一定 Core Data 关系知识和实践经验的读者提供进阶理解和应用的视角，并非旨在提供一个全面的教程。

## 可选值

在 Xcode 的模型编辑器中定义实体属性时，开发者应区分编辑器中的 `Optional` 选项和 Swift 语言中的 `Optional`
类型，两者并非一回事。在 Core Data 中， `Optional` 选项意味着相应的 SQLite 字段可以接受 NULL 值。而 Swift
中的 `Optional` 类型则是一种语言层面的特性，表示变量可能为 `nil` 。在 Core Data 模型中，这两种 `Optional` 的使用取决于具体场景和开发者的需求，并不需要严格对应。

在 Core Data 中，如果模型端的某个属性被标记为 `Optional` ，则在相应的 Swift 代码中，这个属性可以被定义为 `Non-
Optional` 。这种做法提供了更多的灵活性，允许开发者根据实际应用场景来决定是否在代码中使用 Swift 的 `Optional` 类型。

> 有关 Core Data 可选值方面更详尽的内容，请阅读 [ Ask Apple 2022 中与 Core Data 有关的问答 (下）
>
> > ](/zh/posts/core-data-of-ask-
> > apple-2022-2/#%E5%AE%9E%E4%BD%93%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E9%80%89%E6%80%A7)
> > 。

举例来说，假设有 `Item` 和 `Tag` 两个实体，它们之间是 `One-to-One` 关系。在使用 Core Data with
CloudKit 时，这些关系在模型编辑器中必须标记为 `Optional`
。但在实际应用中，如果这两个实体的实例之间总是彼此关联，即它们的关系总是有值的，那么在 Swift
代码中，可以将它们调整为非可选类型。这样做的好处是，可以在代码中更方便地访问这些属性，无需频繁解包。

![Item_Model](https://cdn.fatbobman.com/image-20240107103248579.webp)

![Tag_Model](https://cdn.fatbobman.com/image-20240107103307135.webp)

Core Data 默认生成的代码如下：

    extension Item {
        @NSManaged public var timestamp: Date?
        @NSManaged public var tag: Tag?  // Optional
    }

    extension Tag {
        @NSManaged public var name: String?
        @NSManaged public var item: Item? // Optional
    }

但你可以根据实际情况将它们调整为非可选类型：

    extension Item {
        @NSManaged public var timestamp: Date
        @NSManaged public var tag: Tag  // Non-Optional
    }

    extension Tag {
        @NSManaged public var name: String // None-Optional
        @NSManaged public var item: Item // Non-Optional
    }

这样，就可以更加方便的在代码中获取数据了， **这样调整的前提是开发者必须确保在读取属性前已经给属性进行了赋值** ：

    Text(item.tag.name)

## Core Data 集合类型的 Swift 化

在处理 Core Data 的 `to-Many` 关系时，尤其是涉及有序关系时，调整其在 Swift 代码中的表示方式可带来显著的好处。

例如，考虑将 `tag` 改成有序的对多关系 `tags` ：

![Tags_Model](https://cdn.fatbobman.com/image-20240107110234842.webp)

Core Data 自动生成的代码如下：

    extension Item {
        @NSManaged public var timestamp: Date?
        @NSManaged public var tags: NSOrderedSet?
    }

为了提高代码的可读性和易用性，我们可以考虑将 `NSOrderedSet?` 类型转换为 `Array<Tag>`
。这样的调整不仅减少了解包处理的需要，而且使得 `tags` 属性更加符合 Swift 语言的习惯用法，如使用下标和迭代器进行访问。

    extension Item {
        @NSManaged public var timestamp: Date?
        @NSManaged public var tags: Array<Tag>
    }

调整后，我们可以更方便地在 Swift 中操作这些数据，例如（ Array 符合 RandomAccessCollection 协议 ）：

    ForEach(item.tags){ tag in
        Text(tag.name ?? "")
    }

值得注意的是，在处理非有序的 `to-Many` 关系时，将其转换为 `Array`
类型可能并非最佳选择。这主要是因为非有序集合的本质特性以及它们在 Core Data 中的管理方式。在 Core Data 中，非有序关系通常以 `NSSet` 表示，这直观反应了集合的无序性和元素的唯一性。如果转换为 `Array`
类型，这些关键特性可能会在字面上丢失。因此，对于非有序关系，使用 Swift 中的 `Set` 类型通常是更合适的选择。

例如，对于 `Item` 实体的 `tags` 属性，如果它是非有序的可选的 `to-Many` 关系，可以在 Swift 中这样表示：

    extension Item {
        @NSManaged public var timestamp: Date?
        @NSManaged public var tags: Set<Tag>
    }

这种方式既保持了集合的无序性和唯一性，又使得代码更加符合 Swift 的使用习惯，提高了代码的可读性。

## Count

在处理 `to-Many` 关系时，经常需要获取关联对象的数量。虽然直接使用 `.count`
属性是一种常见方法，但开发者还可以考虑使用派生属性（Derived Attribute）来更高效地获取这一计数。

例如，在下图所示的情况中，我们为 `TodoList` 实体创建了一个名为 `count` 的派生属性。这样，开发者可以通过简单地访问 `todolist.count` 来直接获取与 `TodoList` 相关联的 `items`
对象的数量。这种方法使得获取关联对象数量变得直观且高效。

![Derived](https://cdn.fatbobman.com/image-20211025183247335.webp)

相较于直接调用关系的 `.count`
属性，使用派生属性来计算数量通常更加高效。这是因为派生属性采用了不同的统计机制——它们在写入数据时计算并保存计数值，而在读取数据时则直接使用这个预先计算好的值。这种机制特别适用于那些读操作远多于写操作的场景。

然而，派生属性的一个重要限制在于，它们仅能统计已经持久化的数据量。这意味着如果有数据尚未被保存到持久化存储中，即处于暂存状态，这些数据将不会被派生属性的计数所考虑。因此，在使用派生属性时，开发者需要留意这一点，确保他们的数据处理逻辑考虑到了这种统计方式的这一特性。

> 想要更深入了解派生属性的使用方法，建议阅读 [ 《如何在 Core Data 中使用 Derived 和 Transient 属性》
> ](/zh/posts/derivedandtransient/) ，这篇文章详细介绍了派生属性的应用技巧。

## 管理非有序的 to-Many 数据

在许多实际应用场景中， `to-Many` 关系往往是无序的，这一点在使用 Core Data with CloudKit
时尤为明显，因为它不支持有序关系。

当直接通过关系属性获取数据（如下面的示例代码所示），Core Data 并不能保证返回数据的顺序：

    let tags = Array(items.tags)

> Core Data 在底层绝大多数情况下都会使用 SQLite 数据库来存储数据。在数据库中，除非明确指定排序顺序，否则记录的检索顺序是不确定的。

因此，为了保证获取非有序的 `to-Many` 数据时结果的一致性，建议不要直接使用关系属性。相反，应当创建一个包含谓词和排序条件的 `NSFetchRequest` 来执行查询，如下所示：

    func fetchTagsBy(item:Item) -> [Tag] {
        let request = NSFetchRequest<Tag>(entityName: "Tag")
        request.predicate = NSPredicate(format: "item = %@", item)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Tag.name, ascending: true)]
        return (try? viewContext.fetch(request)) ?? []
    }

在 SwiftUI 开发中，推荐将展示 `to-Many` 数据的界面单独封装成独立的视图，并通过 `@FetchRequest`
来获取数据。这种做法不仅确保了数据获取顺序的稳定性，还能及时响应数据变化，并使视图更新更加高效：

    struct TagsList: View {
        @FetchRequest var tags: FetchedResults<Tag>
        init(item: Item) {
            let request = NSFetchRequest<Tag>(entityName: "Tag")
            request.predicate = NSPredicate(format: "item = %@", item.objectID) // 使用 NSManagedObject 和 NSManagedObjectID ，生成的 SQL 指令都一样
            request.sortDescriptors = [NSSortDescriptor(keyPath: \Tag.name, ascending: true)]
            _tags = FetchRequest(fetchRequest: request)
        }

        var body: some View {
            List(tags) { tag in
                TagDetail(tag: tag)
            }
        }
    }

    struct TagDetail: View {
        @ObservedObject var tag: Tag
        var body: some View {
            Text(tag.name)
        }
    }

## 对多关系与子查询

在上一篇文章中，我们提到关系可以在某些场景下提高查询效率，并丰富查询手段。Core Data 中的子查询（SubQuery）功能正是这一场景的典型示例。

子查询是 Core Data
框架中一种高效的查询技术，它允许开发者在一个已有的查询结果集上执行更为复杂的查询。这在处理复杂的数据模型时尤其有用，特别是当需要根据关联对象的属性来进行过滤时。

子查询的基本格式如下所示：

    SUBQUERY(collection, $x, condition)

- `collection` 是要查询的集合，通常是一个对多关系属性。
- `$x` 是一个变量代表集合中的每个元素（ 可以任意设定名称 ）。
- `condition` 是应用于集合中每个元素的条件。

举个例子，假设我们想要获取所有至少有一个 `Tag` 名称以 “A” 开头的所有的 `Item` 。可以使用以下的 NSPredicate 表达式：

    NSPredicate(format: "SUBQUERY(tags, $tag, $tag.name BEGINSWITH 'A').@count > 0")

使用 Swift 高阶函数在内存中进行同样的操作对应如下的代码：

    let result = items.filter { item in
        item.tags.contains { tag in
            tag.name.hasPrefix("A")
        }
    }

子查询是直接在 SQLite 端执行的，这意味着无论是在性能上还是在内存占用上，都比在内存中进行筛选要高效得多。此外，所有的筛选和排序操作也建议在
SQLite
端进行，即通过使用精心设计的谓词和排序条件来实现。这样的做法不仅提高了数据处理的效率，还有助于减轻应用程序内存的负担，特别是在处理大型数据集时。

## 接下来

在本文中，我们探讨了在实际开发场景中应用 Core Data
关系的一系列技巧。实际上，一旦开发者掌握了关系的基础理论和内部机制，他们就能不断地在实践中总结和发掘出更适合自己项目的方法和经验。

下一篇文章将专注于 Core Data 的后继框架 — SwiftData。我们不仅会探究 SwiftData
在处理数据关系方面的变化，还会审视这些变化的适用性，特别是在其首个版本中如何有效避免关系操作带来的潜在性能问题。

# 聊一下 SwiftUI 中的 List 和 ForEach

在 SwiftUI 中使用 List 可以非常方便快速的制作各种列表。List 其实就是对 UITableView 进行的封装（更多 List
的具体用法请参阅 [ List 基本用法 ](https://zhuanlan.zhihu.com/p/110749923) ).

在 List 中添加动态内容，我们可以使用两种方式

### 直接使用 List 自己提供的动态内容构造方法

      List(0..<100){ i in
        Text("id:\(id)")
      }

### 在 List 中使用 ForEach

      List{
        ForEach(0..<100){ i in
          Text("id:\(id)")
        }
      }

在碰到我最近出现的问题之前，我一直以为上述两种用法除了极个别的区别外，基本没有什么不同。

当时知道的区别：

### 使用 ForEach 可以在同一 List 中，添加多个动态源，且可添加静态内容

      List{
        ForEach(items,id:\.self){ item in
          Text(item)
        }
        Text("其他内容")
        ForEach(0..<10){ i in
          Text("id:\(i)")
        }
      }

### 使用 ForEach 对于动态内容可以控制版式

      List{
        ForEach(0..<10){ i in
          Rectangle()
            .listRowInsets(EdgeInsets()) //可以控制边界 insets
        }
      }

      List(0..<10){ i in
         Rectangle()
            .listRowInsets(EdgeInsets())
            // 不可以控制边界 insets.   .listRowInsets(EdgeInsets()) 在 List 中只对静态内容有效
      }

基于以上的区别，我在大多数的时候均采用 ForEach 在 List 中装填列表内容，并且都取得了预想的效果。

但是在最近我在开发一个类似于 iOS 邮件 app 的列表时发生了让我无语的状态——列表卡顿到完全无法忍耐。

通过下面的视频可以看到让我痛苦的 app 表现

只有十条记录时的状态。非常丝滑

     List{
        ForEach(0..<10000){ i in
            Cell(id: i)
              .listRowInsets(EdgeInsets())
              .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
            }
        }

10000 条记录的样子

在 10 条记录时一切都很完美，但当记录设置为 10000 条时，完全卡成了 ppt 的状态。尤其是 View 初始化便占有了大量的时间。

起初我认为可能是我写的滑动菜单的问题，但在自己检查代码后排出了这个选项。为了更好的了解在 List 中 Cell 的生命周期状态，写了下面的测试代码。

        struct Cell:View{
            let id:Int
            @StateObject var t = Test()
            init(id:Int){
                self.id = id
                print("init:\(id)")
            }
            var body: some View{
                Rectangle()
                    .fill(Color.blue)
                    .overlay(
                        Text("id:\(id)")
                    )
                    .onAppear{
                        t.id = id
                    }
            }

            class Test:ObservableObject{
                var id:Int = 0{
                    didSet{
                        print("get value \(id)")
                    }
                }
                init(){
                    print("init object")
                }
                deinit {
                    print("deinit:\(id)")
                }
            }
        }

        class Store:ObservableObject{
            @Published var currentID:Int = 0
        }

执行后，发现了一个奇怪的现象： **在 List 中，如果用 ForEach 处理数据源，所有的数据源的 View 竟然都要在 List
创建时进行初始化，这完全违背了 tableView 的本来意图** .

将上面的代码的数据源切换到 List 的方式进行测试

     List(0..<10000){ i in
            Cell(id: i)
              .listRowInsets(EdgeInsets())
              .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
        }

熟悉的丝滑又回来了。

**ForEach 要预先处理所有数据，提前准备 View. 并且初始化后，并不自动释放这些 View（即使不可见）! **具体可以使用上面的测试代码通过
Debug 来分析。

不流畅的原因已经找到了，不过由于 List 处理的数据源并不能设置 listRowInsets, 尤其在 iOS 14 下，苹果非常奇怪的屏蔽了不少通过
UITableView 来设置 List 的属性的途径，所以为了既能保证性能，又能保证显示需求，只好通过自己包装 UITableView
来同时满足上述两个条件。

好在我一直使用 [ SwiftUIX ](https://github.com/SwiftUIX/SwiftUIX)
这个第三方库，节省了自己写封装代码的时间。将代码做了进一步调整，当前的问题得以解决。

     CocoaList(item){ i in
               Cell(id: i)
               .frame(height:100)
               .listRowInsets(EdgeInsets())
               .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
           }.edgesIgnoringSafeArea(.all)

通过这次碰到的问题，我知道了可以在什么情况下使用 ForEach. 通过这篇文章记录下来，希望其他人少走这样的弯路。

**后记：**

我已经向苹果反馈了这个问题，希望他们能够进行调整吧（最近苹果对于开发者的 feedback 回应还是挺及时的，Xcode 12 发布后，我提交了 5 个
feedback, 已经有 4 个获得了反馈，3 个在最新版得到了解决）.

**遗憾：**

目前的解决方案使我失去了使用 ScrollViewReader 的机会。

# WWDC 2023 我期待 Core Data 带来的新变化

上周，我在博客中列出了我对今年 WWDC 中期待看到的 SwiftUI 方面的变化。这周，我想继续分享我对 Core Data 的期待。

## Swift 重制版

紧迫性：3 实现可能性：0.5（ 总分 5 分 ）

在最近两三年中，每当 WWDC 临近时，总有开发者在网上预测（更多的是期望）苹果能够推出完全基于 Swift 的 Core Data
实现。然而，理性地说，目前各个方面条件尚不成熟。一方面，作为一个被广泛使用的具有持久化能力的对象图管理框架，苹果对其的调整必定会非常谨慎；另一方面，尽管
Core Data 的实现有些过时，但仍然可以稳定地与许多新框架、新服务配合使用，苹果对其进行革命性调整的动力也不足；最后，当前的 Swift
语言以及其他与 Core Data 配合使用的框架仍未具备支持创建纯 Swift 实现的能力。

从 SwiftUI 的经验可以看出，当苹果打算启动 Core Data 的 Swift 化时，我们必然能够从 Swift 社区的提案中看到端倪。

尽管如此，我仍然对基于 Swift 实现的 Core Data 充满了向往，期盼这一天早日到来。说不定，Swift 重制版能够让其具有跨平台能力。

## 用 Swift 重制部分 API

紧迫性：5 实现可能性：4.5（ 总分 5 分 ）

虽然我认为苹果不会在短时间内实现 Core Data 的 Swift 化，但与之配套的框架和 API 的 Swift 化工作已经持续进行了几年。

目前，基于 Swift 实现的 API 包括：FetchRequest（ 在 SwiftUI 框架中 ）和 SortDescriptor。

在不久前推出的 [ swift-foundation ](https://github.com/apple/swift-foundation)
中，Predicate 已经被提及，预计将在下半年实现。如果苹果能将其他一些 API（例如：NSExpression 等）也用 Swift 实现，届时再对
Swift 语言进行有针对性的增强，基于 Swift 实现的 Core Data 将应运而生。

## 支持更多 SQLite 新特性

紧迫性：4 实现可能性：3.5（ 总分 5 分 ）

尽管 Core Data 当前支持四种存储模式，但是绝大多数开发者仍然将 SQLite 作为首选的存储类型。苹果也很清楚这种情况，因此在最近几年为 Core
Data 开发的一些新增功能上，也仅支持 SQLite。

然而，苹果已经很久没有对 Core Data 的 SQLite 支持进行增强了。就我个人而言，SQLite 所能实现的全文检索和原生的 JSON
查询能力都是我迫切需要的。

我希望上述功能能在最近一两年内被 Core Data 所采纳。

## 更好的 Model Editor 体验

紧迫性：4 实现可能性：4（ 总分 5 分 ）

近年来，除了为某些新功能添加必要的配套外，苹果基本上放弃了对 Xcode 中的 Model Editor 进行改善。尤其是在 Xcode 14
中，苹果移除了数据模型的关系图编辑器，这一点让我感到非常困惑。

尽管我并不经常使用这个功能，但是相对于其他持久化框架，Core Data 最大的优势或特点就是其对关系的管理能力。这也是 Core Data
被认为是对象图管理框架而非持久化框架的主要原因之一。

即使不能对 Model Editor 进行强化，也不应该抹杀其原有的优势。

我仍然衷心希望 Xcode 团队不要放弃 Model Editor，并进一步增强其功能。功能，改善其使用体验。

## 完善 Core Data with CloudKit 的部分 API

紧迫性：5 实现可能性：4（ 总分 5 分 ）

在 Core Data with CloudKit
推出的前三年，苹果以每年一大步的速度推进该框架的发展。目前已拥有了私有库同步、公共库同步、共享数据等众多功能。可以说，相较于 Core Data
框架本身，苹果在推动 Core Data 云端同步的工作上的成绩是有目共睹的。

不过比较遗憾的是，去年并没有延续这种发展势头，没有继续推出新的功能，也没有对之前出现的一些问题进行改进。

尤其是共享数据这一功能，因为本身 API 的一些不完善，始终没有被开发者广泛采用。

Core Data with CloudKit
目前已经是苹果生态的一把利器，基于其开发的应用具备了相当的平台排他性。苹果应该利用好之前创造的优势，进一步增强该功能，至少让当前所有的功能都能被正常地使用。

## 改善 Core Data with CloudKit 的同步表现

紧迫性：5 实现可能性：3.5（ 总分 5 分 ）

随着采用 Core Data with CloudKit 的应用增加，使用者创建的数据也急剧膨胀。因此，网络同步效率差的问题也越来越明显。

作为开发者，我理解基于成本的考量，官方有意控制了数据同步的频率和数量，但考虑到如此多的应用已将 Core Data with CloudKit
作为其同步框架，苹果是否可以考虑为开发者或用户提供更多的选择。

例如，允许开发者或使用者通过额外支付一定的费用获得更好、更快的同步服务。

当然，如果苹果能对 iCloud 服务进行整体的性能升级，让所有的开发者和用户都能免费获得收益，那将是最好的结果。

## 总结

俗话说，“爱之深责之切”。作为 Core Data 的重度使用者，我衷心希望苹果能够继续发扬这个拥有悠久历史的框架，焕发其第二春。

# 如何在 Xcode 下预览含有 Core Data 元素的 SwiftUI 视图

从 SwiftUI 诞生之日起，预览（Canvas Preview
）一直是个让开发者又爱又恨的功能。当预览正常工作时，它可以极大地提高开发效率；而预览又随时可能因为各种莫名其妙的原因崩溃，不仅影响开发进程，同时又让开发者感到沮丧（很难排查出导致预览崩溃的故障）。

在预览含有 Core Data 元素的视图时崩溃的出现次数会愈发频繁，在某种程度上可能已经影响了开发者在 SwiftUI 中使用 Core Data
的热情。

结合两年来我在 SwiftUI 中使用 Core Data 的经验和教训，我们将在本文中探讨：

- 导致 SwiftUI 预览崩溃的部分原因
- 如何在之后的开发中避免类似的崩溃出现
- 如何在 Xcode 中安全可靠地预览含有 Core Data 元素的 SwiftUI 视图

> 如果你了解更多有关 Preview 的工作原理，请阅读 [ 构建稳定的预览视图 —— SwiftUI 预览的工作原理 ](/en/posts/how-
> swiftui-preview-works/)

## 预览

### 预览是模拟器

预览是模拟器，是一个高度优化且精简的模拟器。

预览在 Xcode 中的 **工作原理** 同标准的模拟器十分接近。但为了让它可以即时响应 SwiftUI
视图的变化，苹果对其做出了不少的修改。如果说标准的模拟器可以涵盖真实设备的 90%的功能，那么用于预览的模拟器可能只能提供 50%的设备拟真度。

用于预览的模拟器同样使用沙盒机制，具有同标准设备（或模拟器）一致的目录结构。

预览模拟器不支持控制台输出显示、不支持断点调试，即使在动态预览模式下（支持交互的预览模式），我们也不会在 Xcode
中获得任何代码中的控制台输出内容。因此在预览发生问题时，用于排查故障的手段很有限。

在明确了预览是模拟器的概念后，很多在预览中出现的问题，就有了新的解决思路。

### 导致视图无法预览的原因不仅仅是当前视图中的代码

同标准模拟器运行项目一样，在针对某个视图进行预览时，预览模拟器需要项目整体的代码均能够正常编译。其他视图、方法、声明等的代码错误，都可能会导致你无法预览当前的视图。

在排查视图预览崩溃的原因时，一定不能只关注当前视图或临近视图的代码，其他代码中的错误可能才是罪魁祸首。通常此种情况下，会影响很多的视图，甚至全部的视图都不能预览。

### 用于修复标准模拟器故障的经验同样适用于排查预览故障

在使用标准模拟器进行程序调试时，我们会碰到由于模拟器的原因产生的各种奇异状况。通常在这种情况下，我们可能会采用如下的方式来尝试解决：

- 删除模拟器上的应用程序重新安装运行
- 清除编译缓存（Clean Build Folder）
- 删除项目对应的派生数据（Derived Data）
- 重置模拟器
- 在模拟器设备管理器中删除模拟器再重新添加

上述的手段，多数也都适用于修复某些情况下的预览崩溃。预览模拟器没有提供管理入口，我们通常需要使用更加简单粗暴的方式来实现上面的修复作业。

预览模拟器的数据被保存在 `/Users/你的用户名/Library/Developer/Xcode/UserData/Previews`
目录下，在其中你会看到数量众多由 UUID 命名的若干子目录。在预览仍可正常使用的情况下，通过在视图代码中加入：

    Text("\(FileManager.default.urls(for: .applicationDirectory, in: .userDomainMask).first!)")

可以在预览视图中看到对应的 UUID 目录名（必须在动态预览模式下才会显示）。

![image-20210827150544279](https://cdn.fatbobman.com/image-20210827150544279-0047945.png)

通过清空对应的目录，即可完成上面的 1、4、5 项。

如果你的预览已经不好用了，且无法通过例如文件修改时间等手段判断对应目录，删除掉全部的目录也未尝不可。

> 有时需要重启 Xcode 甚至重启系统才会恢复正常

## SwiftUI 下的 Core Data

### SwiftUI App life cycle

从 Xcode 12 开始，开发者可以在 Xcode 中使用 SwiftUI 原生的应用程序生命周期创建项目。项目的执行入口采用了同视图定义类似的代码形式。

    @main
    struct PreviewStudyApp: App {
        var container = PersistenceController.shared.previewInBundle

        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environment(\.managedObjectContext, container.viewContext)
            }
        }
    }

我们需要在 `App` 中完成诸如 `CoreDataStack`
实例创建或引用、环境注入等准备工作。作为项目代码的根结构，它的编译、执行的时间都早于其他的代码。

### 环境注入

SwiftUI
提供了多种途径在视图之间传递数据。其中通过环境值（EnvironmentValue）或环境对象（EnvironmentObject）传递数据是其中使用量较大的两种方式。SwiftUI
预设了大量同系统有关的环境值，通过设置或响应这些数据，我们可以修改系统配置或读取系统信息。

SwiftUI 视图采用树状结构组织，在任意节点视图上注入的环境数据都将影响该节点的所有子视图。对于当前视图的环境注入，必须在其祖先视图中完成。

如果视图中声明了对某个环境数据的依赖，而忘记在其祖先视图中注入，并不会导致编译错误。应用程序在运行至该视图时会直接崩溃。

SwiftUI 提供的 `managedObjectContext` 环境值为在视图中使用或操作 Core Data 元素提供了基础和便利。

### Redux-like

SwiftUI + Combine 是苹果推出的声明+响应式结构方案。SwiftUI 应用程序的开发逻辑非常类似于 Redux
设计模式。通过采用单向数据流的方式，将视图描述同数据逻辑进行分离。

在这种模式下，通常我们不会在视图中执行复杂的行为（同视图描述无关），通过向 `Store` 发送 `Action` 让 `Reducer`
完成程序的 `State` 调整，视图仅仅是对当前状态的一种呈现。

因此，通常不推荐在视图中直接获取或操作 `Core Data` 数据（非常简单的应用除外）。将需求发送给 `Store`
，数据经过处理和加工后再提交给 `State` ，视图往往使用的并非 `Core Data` 框架产生的原生数据（比如说托管对象）。

`@FetchRequest` 是个例外。虽然它完全破坏了单向数据流的逻辑和美感，但由于它过分的好用，因此在 SwiftUI 的开发中仍被广泛的采用。

## 常见的 Core Data 元素视图预览故障

在应用程序可以正常执行的情况下，真正由于 Core Data 因素导致的预览崩溃的原因其实并不多。

### 忘记注入上下文

含有 Core Data 元素的视图预览崩溃的情况相当比例都是由于忘记在环境值中注入持久化存储上下文（ `NSManagedObjectContext`
）而导致的。

如果你的视图中使用了 `@Environment(\.managedObjectContext) var viewContext` 或者 `@FetchRequest` ，请务必检查该视图对应的 `PreviewProvider` 中，是否为预览视图提供了正确的上下文注入，例如：

    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
               .environment(\.managedObjectContext,
                            PersistenceController.shared.previewInMemory.viewContext)
        }
    }

### 错误的使用单例

有些开发者比较喜欢在 `CoreDataStack` 中使用单例，比如上面的代码 `PersistenceController.shared.previewInMemory.viewContext`
便是通过单例完成了在预览视图中的上下文注入。

由于前文中提到的 SwiftUI App life cycle
的独特性，你无法在根视图中使用单例来注入持久化上下文。比如下面的代码会在运行中报错（编译中不报错）：

    @main
    struct PreviewStudyApp: App {
        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environment(\.managedObjectContext,
                                 PersistenceController.shared.container.viewContext)
            }
        }
    }

而且这种错误会导致你全部含有 Core Data 元素的视图崩溃。

> 预览也是模拟器，会执行应用程序的全部代码。当 `App` 执行出错后，所有的视图都不能正常预览。

正确的方式是，在 App 中先对 `CoreDataStack` 的单例进行引用，然后再注入：

    @main
    struct PreviewStudyApp: App {
        var container = PersistenceController.shared.container

        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environment(\.managedObjectContext, container.viewContext)
            }
        }
    }

> 除了不能在 `App` 中使用 `CoreDataStack` 的单例外，在代码的其他部分都是可以正常使用的，包括 `Preview`

### 其他常见的 Core Data 故障

当我们对 Core Data 的 DataModel 进行修改时，如果结构修改过大且没有设置 Mapping 的情况下，Core Data
将无法对数据进行自动迁移，从而导致应用程序运行错误。此种情况下，通常我们会在模拟器中删除
App，重新安装运行即可解决问题。由于预览也是模拟器，在它的沙盒中同样可能出现类似的问题。可以使用上文中关于预览模拟器的修复方法来尝试解决。

### 错误使用了 Preview 的修饰符

对于含有 Core Data 元素的视图，在预览中使用 `preview` 专用修饰符（ `Modifier` ）须谨慎。某些 `Modifier` 会导致预览模拟器处于更加受限的运行状态。例如：

    struct Test_Previews: PreviewProvider {
        static var previews: some View {
            Test()
                .environment(\.managedObjectContext,
                             PersistenceController.shared.previewInMemory.viewContext)
                .previewLayout(.sizeThatFits)
        }
    }

添加了 `.previewLayout` 后，将无法正常预览含有 Core Data 元素的视图。

### 可以预览但是有错误提示

有时含有 Core Data 元素的视图在预览时会出现如下的错误提示：

![image-20210827191644251](https://cdn.fatbobman.com/image-20210827191644251-0063005.png)

将预览切换到动态模式通常就可以正常显示。

在某些情况下，即使感觉上预览是正常（实际上数据没有刷新），通过切换到动态模式也会强制 Core Data 数据刷新。

## 为 SwiftUI 预览提供 Core Data 数据

本节中，我们将介绍几种为预览组织 Core Data 数据的方式，提高 SwiftUI+Core Data 的开发效率。

> 本节中介绍的方案，不仅适用于预览，同样也适用于 Unit Test。演示代码可以在 [ 此处下载
> ](https://github.com/fatbobman/CoreDataInPreview)

### 不使用 Core Data 元素

最好的防止出错的手段就是不给错误机会。SwiftUI 通常采用 Redux 的开发模式，通过将获取到的 Core Data 数据转换成标准的 Swift
结构从而避免在视图中使用托管对象上下文或托管对象。

比如我们有一个 Student 的托管对象：

    @objc(Student)
    public class Student: NSManagedObject {
        @NSManaged public var name: String?
        @NSManaged public var age: Int32
    }

通过原生 Swift 结构来进行数据交换

    struct StudentViewModel {
        var name:String
        var age:Int
    }

    extension Student{
        var viewModel:StudentViewModel{
            .init(name: name ?? "",
                  age: Int(age))
        }
    }

为 `StudentRowView` 视图创建一个 `Connect` （也可以叫 `Controller` ）视图进行数据转换。直接在 `StudentRowView` 视图中使用 Swift 结构数据。

    struct StudentRowViewConnect:View{
        let student:Student
        var body: some View{
            StudentRowView(student: student.viewModel)
        }
    }

    struct StudentRowView:View{
        let student:StudentViewModel
        var body: some View{
            Text("\(student.name)'s age is \(student.age)")
        }
    }

    struct StudentRowView_Previews_2: PreviewProvider {
        static var previews: some View {
            let student = StudentViewModel(name: "fat", age: 18)
            StudentRowView(student: student)
        }
    }

这种方式不仅避免了预览崩溃的可能，同时由于转换后的 `ViewModel` 的属性类型可控（无需类型转换、无需判定可选值等），便于在代码中使用。

> 尽管 SwiftUI 的 Redux
> 模式有诸多优点，但由于只存在视图这一种表现形式，因此在视图描述中经常会参杂不少的数据计算、整理的工作。通过为此种类型的视图添加一个专门用来处理数据的父视图，可以有效的将两种逻辑分割开来。本例仅为演示，通常
> Connect 视图的数据准备工作会复杂的多。

### 直接使用托管对象

当然，我们仍然可以直接给视图传递托管对象。为了便于在预览中重复使用，我们可以在 `CoreDataStack`
或其他你认为合适的地方提前创建好用于预览的数据，在预览时直接调用即可。

    struct RowView: View {
        let item: Item
        var body: some View {
            VStack {
                Text("Item at \(item.timestamp!, formatter: itemFormatter)")
            }
        }
    }

    struct RowView_Previews: PreviewProvider {
        static var previews: some View {
            RowView(item: PersistenceController.shared.samepleItem)
        }
    }
    // 预置演示数据
    extension PersistenceController {
        var samepleItem: Item {
            let context = Self.shared.previewInMemory.viewContext
            let item = Item(context: context)
            item.timestamp = Date().addingTimeInterval(30000000)
            return item
        }
    }

### 内存数据库

从 Xcode 12 开始，苹果在预置的 `CoreDataStack` 模版 `Persistence.swift` 中已经添加了 `inMemory` 选项，为预览创建了专用的 `Container` 。这种创建内存数据库的形式在 Unit Test 中已经被使用很久了。

CoreData 支持四种持久化存储类型：Sqlite、XML、二进制、内存。 **不过我们在`CoreDataStack`
中创建的基于内存的持久化存储仍然是 `Sqlite` 类型 ** 。是将数据文件保存在 `/dev/null` 的 `Sqlite`
类型。此种内存数据库除了不能持久化外同标准 Sqlite 数据库功能完全一样。内存中的 Sqlite 数据库执行效率稍高于正常的 Sqlite
数据库，并没有巨大的差别。

Xcode 的 Core Data 模版将 `inMemory` 同标准 Sqlite 的 `Container`
定义混在一起的，我个人还是喜欢将其独立出来。

        lazy var previewInMemory: NSPersistentContainer = {
            let container = NSPersistentContainer(name: modelName)
            container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: "/dev/null")
            container.loadPersistentStores(completionHandler: { _, error in

                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
            let viewContext = container.viewContext
          // 创建演示数据
            for _ in 0..<10 {
                let newItem = Item(context: viewContext)
                newItem.timestamp = Date()
            }
            do {
                try viewContext.save()
            } catch {
                let nsError = error as NSError
                fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
            }
            return container
        }()

        lazy var container: NSPersistentContainer = {
            let container = NSPersistentContainer(name: modelName)
            container.loadPersistentStores(completionHandler: { _, error in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
            return container
        }()

在完成了持久化容器的创建后，代码在数据库中创建了用于预览的演示数据。批量创建的数据有利于用于使用了 `@FetchRequest` 的视图在预览中调用。

    struct ContentView: View {
        @FetchRequest(
            sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
            animation: .default
        )
        private var items: FetchedResults<Item>

        var body: some View {
            ...
        }
    }
    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
                .environment(\.managedObjectContext,
                             PersistenceController.shared.previewInMemory.viewContext)
        }
    }

> 使用此种方式的数据模型通常不复杂，否则创建演示数据就需要非常多的代码量。

### 预置复杂数据的 Bundle 数据库

对于拥有复杂数据模型的应用该如何创建用于预览的演示数据呢？

我目前在开发使用 SwiftUI+CoreData 的应用程序时，将 CoreData 部分的开发同应用程序的 UI 构建是完全分离的。在完成了各种处理
CoreData 数据的方法后，通常会创建一些非常简陋的视图或 Unit Test 来验证代码以及创建测试数据集。这样在进行 UI
开发的时候，我已经可以有一个可用来演示的数据库文件了。

使用打印、查看调试输出、 `po NSHomeDirectory()` 等手段，可以获取到模拟器中的数据库文件 `URL` 。将三个数据库文件（包括
`wal` 和 `shm` ）一并拖入项目中，创建一个使用 `Bundle` 中数据库文件的 `NSPersistentContainer`
，方便我们预览使用了复杂数据模型的视图。

![image-20210827202250305](https://cdn.fatbobman.com/image-20210827202250305-0066971.png)

        lazy var previewInBundle: NSPersistentContainer = {
            let container = NSPersistentContainer(name: modelName,managedObjectModel: Self.model())
            guard let url = Bundle.main.url(forResource: "PreviewStudy", withExtension: "sqlite") else {
                fatalError("无法从 Bundle 中获取数据库文件")
            }
            container.persistentStoreDescriptions.first?.url = url
            container.loadPersistentStores(completionHandler: { _, error in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
            return container
        }()

在预览中使用 `previewInBundle`

    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
                .environment(\.managedObjectContext,
                             PersistenceController.shared.previewInBundle.viewContext)
        }
    }

尽管 Bundle 是只读的，但我们仍然可以在标准模拟器或动态预览模式下添加修改数据。在重启应用或重启预览后，数据会恢复成 Bundle
中的原始数据集（有时在预览模式下数据不会立即复原，需在几次动态模式切换后才会恢复）。

### Bundle 数据库加强版

上面的 Bundle 数据库方便了开发者预览拥有复杂数据模型的视图。不过由于 Bundle
是只读的，你在动态预览中修改创建的数据并不会被真正的持久化。如果确有持久化的需要，可以使用下面的方案。将 Bundle 中的数据库文件保存到 `Catch` 目录中。

    lazy var previewInCatch: NSPersistentContainer = {
            let container = NSPersistentContainer(name: modelName,managedObjectModel: Self.model())
            let fm = FileManager.default
            let DBName = "PreviewStudy"

            guard let sqliteURL = Bundle.main.url(forResource: DBName, withExtension: "sqlite"),
                  let shmURL = Bundle.main.url(forResource: DBName, withExtension: "sqlite-shm"),
                  let walURL = Bundle.main.url(forResource: DBName, withExtension: "sqlite-wal")
            else {
                fatalError("无法从 Bundle 中获取数据库文件")
            }
            let originalURLs = [sqliteURL, shmURL, walURL]

            let storeURL = fm.urls(for: .cachesDirectory, in: .userDomainMask).first!

            let sqliteTargetURL = storeURL.appendingPathComponent(sqliteURL.lastPathComponent)
            let shmTargetURL = storeURL.appendingPathComponent(shmURL.lastPathComponent)
            let walTargetURL = storeURL.appendingPathComponent(walURL.lastPathComponent)

            let tragetURLs = [sqliteTargetURL, shmTargetURL, walTargetURL]

            zip(originalURLs, tragetURLs).forEach { originalURL, targetURL in
                do {
                    if fm.fileExists(atPath: targetURL.path) {
                        if Self.alwaysCopy {
                            try fm.removeItem(at: targetURL)
                            try fm.copyItem(at: originalURL, to: targetURL)
                        }
                    } else {
                        try fm.copyItem(at: originalURL, to: targetURL)
                    }
                } catch let error as NSError {
                    fatalError(error.localizedDescription)
                }
            }

            container.persistentStoreDescriptions.first?.url = sqliteTargetURL
            container.loadPersistentStores(completionHandler: { _, error in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
            return container
        }()

### 通过 EntityDescription 直接创建托管对象实例

实际上，在 Core Data 中，我们可以仅依靠从 NSManagedObjectModel 中获取到对应的
EntityDescription，而不需要创建容器或上下文，就可以创建托管对象实例。虽然使用这种方式创建的托管对象实例不对应任何持久化数据，但完全可以用于预览这种场景。

    extension PersistenceController {
        static let itemByEntityDescription: Item = {
            // get Item entity description from Data Model
            guard let entityDescription = model().entitiesByName["Item"] else {
                fatalError()
            }
            let item = Item(entity: entityDescription, insertInto: nil)
            item.timestamp = Date.now
            return item
        }()
    }

    RowView(item: PersistenceController.itemByEntityDescription)

## 总结

本文的演示代码可以在 [ 此处下载 ](https://github.com/fatbobman/CoreDataInPreview)

在我两年的 SwiftUI+Core Data 使用中，痛苦和快乐始终相伴而行。只要始终保持用心、耐心、平常心，再加上一点点运气，总会找到解决问题的方法。

# 了解 SwiftUI 的 onChange

从 iOS 14 开始，SwiftUI 为视图提供了 onChange 修饰器，通过使用
onChange，我们可以在视图中对特定的值进行观察，并在其更改时触发操作。本文将对 onChange 的特点、用法、注意事项以及替代方案做以介绍。

## 如何使用 onChange

onChange 的定义如下：

    func onChange<V>(of value: V, perform action: @escaping (V) -> Void) -> some View where V : Equatable

onChange 在发现特定值发生变化时，将调用闭包中的操作。

    struct OnChangeDemo:View{
        @State var t = 0
        var body: some View{
            Button("change"){
                t += 1
            }
            .onChange(of: t, perform: { value in
                print(value)
            })
        }
    }

点击 Button，t 将加一，onChange 将对 t 值进行比较，如果值发生改变，将调用闭包打印新值。

在闭包中可以进行副作用操作，或者修改视图中的其他可变内容。

传递到闭包中的值（例如上面的 value）是不可变的，如果需要修改，请直接更改视图中的可变值（t）。

onChange 的闭包是运行在主线程上的，应避免在闭包中执行运行时间长的任务。

## 如何获取被观察值的 OldValue

onChange 允许我们通过闭包捕获的方式获取被观察值的旧值（oldValue）。例如：

    struct OldValue: View {
        @State var t = 1
        var body: some View {
            Button("change") {
                t = Int.random(in: 1...5)
            }
            .onChange(of: t) { [t] newValue in
                let oldValue = t
                if newValue % oldValue == 2 {
                    print("余值为 2")
                } else {
                    print("不满足条件")
                }
            }
        }
    }

由于闭包中捕获了 t，因此需使用 `self.t` 方能调用视图中的 t。

对于结构类型，捕获时需使用结构实例，而不能直接捕获结构中的属性，例如：

    struct OldValue1:View{
        @State var data = MyData()
        var body: some View{
            Button("change"){
                data.t = Int.random(in: 1...5)
            }
            .onChange(of: data.t){ [data] newValue in
                let oldValue = data.t
                if newValue % oldValue == 2 {
                    print("余值为 2")
                } else {
                    print("不满足条件")
                }
            }
        }
    }

    struct MyData{
        var t = 0
    }

换成 `[data.t]` 将提示如下错误：

    Fields may only be captured by assigning to a specific name

对于引用类型，捕获时需添加 `weak` 。

## onChange 可以观察哪些值

任何符合 Equatable 协议的类型都可被 onChange 所观察。对于可选值，只要 Wrapped 符合 Equatable 即可。

通常我们会使用 onChange 来观察@State，@StateObject 或@ObservableObject
包装数据的变化。但在某些特定的场景下，我们也可以用 onChange 来观察并非为视图 Source of truth 的数据。例如：

    struct NonStateDemo: View {
        let store = Store.share
        @State var id = UUID()
        var body: some View {
            VStack {
                Button("refresh") {
                    id = UUID()
                }
                .id(id)
                .onChange(of: store.date) { value in
                    print(value)
                }
            }
        }
    }

    class Store {
        var date = Date()
        var cancellables = Set<AnyCancellable>()
        init(){
            Timer.publish(every: 3,  on: .current, in: .common)
                .autoconnect()
                .assign(to: \.date, on: self)
                .store(in: &cancellables)
        }

        static let share = Store()
    }

Store 并非可以引发视图刷新的元素，通过点击 Button 改变 id 来刷新视图。

本例看起来有些无厘头，但它为揭示 onChange 的特点提供了很好的启示。

## onChange 的特点

在 onChange 推出之际，大多数人将其视为@State 的 didSet 实现。但事实上两者间有很大的差异。

didSet 在 **值发生改变** 即调用闭包中的操作，无论新值与旧值是否不同。例如

    class MyStore{
        var i = 0{
            didSet {
                print("oldValue:\(oldValue),newValue:\(i)")
            }
        }
    }

    let store = MyStore()
    store.i = 0

    //oldValue:0,newValue:0

onChange 有其自身的运行逻辑。

在上节的例子中，尽管 Store 中的 date 每三秒会发生一次改变，但并不会引起视图的重新绘制。通过点击按钮强制重绘视图，onChange 才会被触发。

如果在三秒之内多次点击按钮，控制台并不会打印更多的时间信息。

**被观察值的变化并不会触发 onChange，只有在每次视图重绘时 onChnage 才会触发。onChange
触发后会比较被观察值的变化，只有新旧值不一致时，才会调用 onChange 闭包中的操作。**

## 关于 onChange 的 FAQ

### 视图中可以放置多少个 onChange

任意多个。不过由于 onChange 的闭包运行在主线程中，因此最好限制 onChange 的使用量，避免影响视图的渲染效率。

### 多个 onChange 的执行顺行

严格按照视图树的渲染顺序，下面的代码中，onChange 的执行顺序为从内到外：

    struct ContentView: View {
        @State var text = ""
        var body: some View {
            VStack {
                Button("Change") {
                    text += "1"
                }
                .onChange(of: text) { _ in
                    print("TextField1")
                }
                .onChange(of: text) { _ in
                    print("TextField2")
                }
            }
            .onChange(of: text, perform: { _ in
                print("VStack")
            })
        }
    }

    // Output:
    // TextField1
    // TextField2
    // VStack

### 多个 onChange 观察同一个值

在一个渲染周期内，观察同一个值的 onChange， **无论顺序与否，获得的被观察值的新旧值均相同** 。不会因为更早顺序前的 onChange
对值的内容进行更改而变化。

    struct InOneLoop: View {
        @State var t = 0
        var body: some View {
            VStack {
                Button("change") {
                    t += 1 // t = 1
                }
                // onChange1
                .onChange(of: t) { [t] newValue in
                    print("onChange1: old:\(t) new:\(newValue)")
                        self.t += 1
                }
                // onChange2
                .onChange(of: t) { [t] newValue in
                    print("onChange2 old:\(t) new:\(newValue)")
                }
            }
        }
    }

输出为：

    render loop
    onChange1: old:3 new:4
    onChange2 old:3 new:4
    render loop
    onChange1: old:4 new:5
    onChange2 old:4 new:5
    render loop
    onChange(of: Int) action tried to update multiple times per frame.

在每个 loop 循环中，onChange 2 的内容并没有因为 onChange 1 对 t 进行了修改而变化。

### 为什么 onChange 会报错

在上面的代码中，在输出的最后，我们获得了 `onChange(of: Int) action tried to update multiple times
per frame.` 的错误提示。

这是因为，由于我们在 onChange 中对被观察值进行了修改，而修改将再次刷新视图，从而导致了无限循环。SwiftUI 为了避免 app
锁死而采取的保护机制——强制中断了 onChange 的继续执行。

至于允许的循环次数没有明确的约定，上面例子中由 Button 激发的变化通常会限制在 2 次，而由 onAppear 激发的变化则可能在 6-7 次。

    struct LoopTest: View {
        @State var t = 0
        var body: some View {
            let _ = print("frame")
            VStack {
                Text("\(t)")
                    .onChange(of: t) { _ in
                        t += 1
                        print(t)
                    }
                    .onAppear(perform: { t += 1 })
            }
        }
    }

输出：

     frame
     2
     frame
     3
     frame
     4
     frame
     5
     frame
     6
     frame
     7
     frame
     onChange(of: Int) action tried to update multiple times per frame.

因此我们需要尽量避免在 onChange 中对被观察值进行修改，如确有必要，请使用条件判断语句来限制更改次数，保证程序按预期执行。

## onChange 的替代方案

本节中我们将介绍几个同 onChange 类似的实现，它们同 onChange 的行为并不完全一样，有各自的特点和合适的场景。

### task (id:)

SwiftUI 3.0 中新增了 task 修饰器，task 将在视图出现时以异步的方式运行闭包中的内容，同时在 id 值发生变化时，重启任务。

在 task 闭包中的任务单元足够简单时，其表现同 onChange 类似，相当于 onAppear + onChange 的组合。

    struct AsyncTest: View {
        @State var t: CGFloat = 0
        var body: some View {
            let _ = print("frame")
            VStack {
                Text("\(t)")
                    .task(id: t) {
                        t += 1
                        print(t)
                    }
            }
        }
    }

输出：

    frame
    1.0
    frame
    2.0
    ...

但有一点需要特别注意，由于 task 的闭包是异步运行的，理论上其并不会对视图的渲染造成影响，因此 SwiftUI 将不会限制它的执行次数。本例中，task
的闭包中的任务将不断运行，Text 中的内容也将不断变化（如果将 task 换成 onChange 则会被 SwiftUI 自动中断）。

### Combine 版本的 onChange

在 onChange 没有推出之前，多数人会利用 Combine 框架来实现类似 onChange 的效果。

    import Combine
    struct CombineVersion: View {
        @State var t = 0
        var body: some View {
            VStack {
                Button("change") {
                    t += 1
                }
            }
            .onAppearAndOnChange(of: t, perform: { value in
                print(value)
            })
        }
    }

    public extension View {
        func onAppearAndOnChange<V>(of value: V, perform action: @escaping (_ newValue: V) -> Void) -> some View where V: Equatable {
            onReceive(Just(value), perform: action)
        }
    }

它的行为类似 onAppear + onChange 的组合。最大的不同是，此种方案并不会比较被观察值是否发生改变（新旧值不一样）。

    struct CombineVersion: View {
        @State var t = 0
        @State var n = 0
        var body: some View {
            VStack {
                Text("\(n)")
                Button("change n"){
                    n += 1
                    t += 0
                }
            }
            .onAppearAndOnChange(of: t, perform: { value in
                print("combine \(t)")
            })
            .onChange(of: t){ value in
                print("onChange \(t)")
            }
        }
    }

onChange 的闭包因为 t 的内容没有发生变化将不会被调用，而 onAppearAndOnChange 的闭包将在每次 t 赋值时均被调用。

有的时候，这种行为恰是我们所需的。

### Binding 版本的 onChange

此种方式只能针对 Binding 类型的数据，通过在 Binding 的 Set 中添加一层逻辑，实现对内容变化的响应。

    extension Binding {
        func didSet(_ didSet: @escaping (Value) -> Void) -> Binding<Value> {
            Binding(get: { wrappedValue },
                    set: { newValue in
                        self.wrappedValue = newValue
                        didSet(newValue)
                    })
        }
    }

    struct BindingVersion2: View {
        @State var text = ""
        var body: some View {
            Form {
                TextField("text:", text: $text.didSet { print($0) })
            }
        }
    }

可能你会觉得多此一举，完全可以使用 onChange 来实现，但采用 Binding 的方式让我们有了在 **数据修改前**
进行判断操作的可能，使用得当将极大地减少视图的刷新。

例如，我们还可以对新数据进行提前判断以决定是否更改原值：

    extension Binding {
        func conditionSet(_ condition: @escaping (Value) -> Bool) -> Binding<Value> {
            Binding(get: { wrappedValue },
                    set: { newValue in
                        if condition(newValue) {
                            self.wrappedValue = newValue
                        }
                    })
        }
    }

请注意，此种方式并不能同支持 Binding
的系统控件很好的配合使用，因为系统控件并不会因为我们限制了数值的修改而产生对应的效果（系统控件中还保留了一套自己的数据，除非强制刷新视图，否则并不会保证同外部的数据完全同步）。例如下面的代码，表现同你预期的行为会有出入。

    struct BindingVersion3: View {
        @State var text = ""
        var body: some View {
            Form {
                Text(text)
                TextField("text:", text: $text.conditionSet { text in
                    return text.count < 5
                })
            }
        }
    }

## 总结

onChange
为我们在视图中进行逻辑处理提供了便利，了解它的特点与限制，选择合适的场景使用它。在必要的情况下，将逻辑处理与视图分离，以保证视图的渲染效率。

# StateObject 与 ObservedObject

StateObject 是在 SwiftUI 2.0 中才添加的属性包装器，它的出现解决了在某些情况下使用 ObservedObject
视图会出现超预期的问题。本文将介绍两者间的异同，原理以及注意事项。

## 先说结论

StateObject 和 ObservedObject 两者都是用来订阅可观察对象（ 符合 ObservableObject 协议的引用类型
）的属性包装器。当被订阅的可观察对象通过内置的 Publisher 发送数据时（ 通过 @Published 或直接调用其
objectWillChange. send 方法 ），StateObject 和 ObservedObject 会驱动其所属的视图进行更新。

ObservedObject 在视图的存续期间只保存了订阅关系，而 StateObject 除了保存了订阅关系外还保持了对可观察对象的强引用。

基于 Swift 的 ARC（ 自动引用计数 ）机制，StateObject
保证了可观察对象的生存期必定不小于视图的存续期，从而确保了在视图的存续期内数据的稳定。

而由于 ObservedObject 只保存了订阅关系，一旦被订阅的可观察对象的生存期小于视图的存续期，视图会出现各种不可控的表现。

相信有人会提出这样的疑问，难道下面代码中的 testObject 对应的实例，其存续时间会小于视图的存续时间吗？

    struct DemoView: View {
        @ObservedObject var testObject = TestObject()
        var body: some View {
            Text(testObject.name)
        }
    }

在某些情况下，确实会是这样。下文中将详细探讨其中的原因。

## 原理

### ARC

Swift 使用自动引用计数（ ARC ）来跟踪和管理引用类型实例的内存使用情况。只要还有一个对类实例的强引用存在，ARC
便不会释放该实例占用的内存。换而言之，一旦对实例的强引用为 0 ，该实例将被 Swift 销毁，其所占用的内存也将被收回。

StateObject 通过保持一个对可观察对象的强引用，确保了该对象实例的存续期不小于视图的存续期。

### 订阅与 Cancellable

在 Combine 中，当使用 sink 或 assign 来订阅某个 Publisher
时，必须要持有该订阅关系，才能让这个订阅正常工作，订阅关系被包装成 AnyCancellable 类型，开发者可以通过调用 AnyCancellable 的
cancel 方法手动取消订阅。

    var cancellable: AnyCancellable?
    init() {
        cancellable = NotificationCenter.default.publisher(for: .AVAssetContainsFragmentsDidChange)
            .sink { print($0) }
    }

    var cancellable = Set<AnyCancellable>()
    init() {
        NotificationCenter.default.publisher(for: .AVAssetContainsFragmentsDidChange)
            .sink { print($0) }
            .store(in: &cancellable)
    }

除了可以从订阅者一方主动取消订阅关系外，如果 Publisher 不复存在了，订阅关系也将自动解除。

ObservedObject 和 StateObject 两者都保存了视图与可观察对象的订阅关系，在视图存续期内，它们都不会主动取消这个订阅，但
ObservedObject 无法确保可观察对象是否会由于被销毁而提前取消订阅。

### 描述、实例与视图

SwiftUI 是一个声明式的框架，开发者用代码来声明（ 描述 ）想要的 UI 呈现。例如下面便是一个有关视图的声明（ 描述 ）：

    struct DemoView:View{
        @StateObject var store = Store()
        var body: some View{
            Text("Hello \(store.username)")
        }
    }

当 SwiftUI 开始创建以该描述生成的视图时，大致会进行如下的步骤：

- 创建一个 DemoView 的实例
- 进行与该视图有关的一些准备工作（ 例如依赖注入 ）
- 对该实例的 body 属性求值
- 渲染视图

从 SwiftUI 的角度来说，视图是对应着屏幕上某个区域的一段数据，它是通过调用某个根据描述该区域的声明所创建的实例的 body 属性计算而来。

视图的生存期从其被加载到视图树时开始，至其被从视图树上移走结束。

在视图的存续期中，视图值将根据 source of truth （ 各种依赖源 ）的变化而不断变化。SwiftUI 也会在视图存续期内因多种原因，
**不断地依据描述该区域的声明创建新的实例** ，从而保证始终能够获得准确的计算值。

由于实例是会反复创建的，因此，开发者必须用特定的标识（ @State、@StateObject 等 ）告诉 SwiftUI
，某些状态是与视图存续期绑定的，在存续期期间是唯一的。

当将视图加载到视图树时，SwiftUI 会根据当时采用的实例将需要绑定的状态（ @State、@StateObject、onReceive 等 ）托管到
SwiftUI 的托管数据池中，之后无论实例再被创建多少次，SwiftUI 始终只使用首次创建的状态。也就是说，为视图绑定状态的工作只会进行一次。

> 请阅读 [ SwiftUI 视图的生命周期研究 ](/zh/posts/swiftuilifecycle/) 一文，了解更多有关视图与实例之间的关系

### 属性包装器

Swift 的属性包装器（ Property Wrappers
）在管理属性存储方式的代码和定义属性的代码之间添加了一层分离。一方面它方便开发者将一些通用的逻辑统一封装起来，作用于给定的数据之上，另一方面如果开发者对某个属性包装器的用途不甚了解，那么就可能会出现看到的和实际上的不一致的情况（
理解偏差 ）。

很多情况下，我们需要从视图的角度来理解 SwiftUI 的属性包装器名称，例如：

- ObservedObject （ 视图订阅某个可观察对象 ）
- StateObject（ 订阅某个可观察对象，并持有其强引用 ）
- State（ 持有某个值 ）

ObservedObject 和 StateObject 两者通过满足 DynamicProperty 协议从而实现上面的功能。在 SwiftUI
将视图添加到视图树上时，调用 \_makeProperty 方法将需要持有的订阅关系、强引用等信息保存到 SwiftUI 内部的数据池中。

> 请阅读 [ 避免 SwiftUI 视图的重复计算
> ](/zh/posts/avoid_repeated_calculations_of_swiftui_views/) 一文，了解更多有关
> DynamicProperty 的实现细节

## ObservedObject 偶尔出现灵异现象的原因

如果使用类似 `@ObservedObject var testObject = TestObject()` 这样的代码，有时会出现灵异现象。

> 在 [ @StateObject 研究 ](/zh/posts/stateobject/) 一文中，展示了因错误使用 ObservedObject
> 而引发灵异现象的代码片段

出现这种情况是因为一旦，在视图的存续期中，SwiftUI 创建了新的实例并使用了该实例（ 有些情况下，创建新实例并不一定会使用 ），那么，最初创建的
TestObject 类实例将被释放（ 因为没有强引用 ），ObservedObject 中持有的订阅关系也将无效。

某些视图，或许是由于其所处的视图树的层级很高（ 例如根视图 ），或者由于其本身的生存期较短，抑或者它受其他状态的干扰较少。上述条件促使了在该视图的存续期内
SwiftUI 只会创建一个实例。这也是 `@ObservedObject var testObject = TestObject()`
并非总会失效的原因。

## 注意事项

- 避免创建 `@ObservedObject var testObject = TestObject()` 这样的代码

原因上文中已经介绍了。ObservedObject 的正确用法为： `@ObservedObject var testObject:TestObject` 。通过从父视图传递一个可以保证存续期长于当前视图存续期的可观察对象，从而避免不可控的情况发生

- 避免创建 `@StateObject var testObject:TestObject` 这样的代码

与 `@ObservedObject var testObject = TestObject()` 类似， `@StateObject var
testObject:TestObject`
偶尔也会出现与预期不符的状况。例如，在某些情况下，开发者需要父视图不断地生成全新的可观察对象实例传递给子视图。但由于子视图中使用了 StateObject
，它只会保留首次传入的实例的强引用，后面传入的实例都将被忽略。尽量使用 `@StateObject var testObject =
TestObject()` 这样不容易出现歧义表达的代码

- 轻量化视图中使用的引用类型的构造方法

无论使用 ObservedObject 还是 StateObject
抑或不添加属性包装器，在视图中声明的类实例，都会随着视图描述实例的创建而一遍遍地被多次创建。不在它的构造方法中引入无关的操作可以极大地减轻系统的负担。对于数据的准备工作，可以使用
onAppear 或 task ，在视图加载时进行。

## 何时选择使用 ObservedObject

虽然本文已经详细探讨了 StateObject 和 ObservedObject 的工作原理，但还未触及一个核心问题：ObservedObject
究竟何时才是最佳选择？在哪些场景下，它的使用才显得尤为重要？

先简化一些复杂的概念，StateObject 的一个显著特点是其实例的唯一性。换句话说，一旦使用了
@StateObject，标注的对象实例在其所属视图的整个生命周期中将保持唯一。这意味着，即便视图本身经历了更新（即视图的构造方法被重新调用），该对象实例也不会重新创建。这正是
ObservedObject 与 StateObject 最关键的区别所在。

而对于 ObservedObject 来说，它的一大特色是 **在视图的整个生命周期中，@ObservedObject 可以灵活地切换并关联不同的实例**
。例如，在 NavigationSplitView 中，侧边栏（sidebar）可能列出了多个遵循 ObservableObject
协议的不同实例，而详细视图（detail
view）则响应这些实例中的一个。通过在侧边栏中选择不同实例，详细视图可以动态地更换其数据源，尽管视图本身得到了更新，但并未重建。

以下代码示例进一步阐释了这一点：

    class NVStore:ObservableObject {
        var item:Item?
        @Published var id = UUID()

        class Item:ObservableObject {
            let id:Int
            init(id: Int) {
                self.id = id
            }
        }
    }

    struct NVTest:View {
        @StateObject var store = NVStore()
        var body: some View {
            NavigationSplitView {
                List(0..<10){ i in
                    Button{
                        store.item = .init(id: i)
                        store.id = UUID()
                    } label: {
                        Text("\(i)")
                    }
                }
            } detail: {
                if let item = store.item {
                    NVDetailView(item: item)
                }
            }
        }
    }

    struct NVDetailView:View {
        @State var id = UUID()
        @ObservedObject var item:NVStore.Item
        var body: some View {
            VStack {
                Text("\(id)")
                Text("\(item.id)")
            }
        }
    }

这意味着，在处理多对一关系的场景中，选择 ObservedObject 是最恰当且有效的策略。

## 总结

StateObject 和 ObservedObject
是我们经常会使用的属性包装器，它们都有各自擅长的领域。了解它们内涵不仅有助于选择合适的应用场景，同时也对掌握 SwiftUI 视图的存续机制有所帮助。

# SwiftData 实战：用现代方法构建 SwiftUI 应用

在之前的文章 [ SwiftData 中的并发编程 ](/zh/posts/concurret-programming-in-swiftdata/)
中，我们深入探讨了 SwiftData
提出的创新并发编程模式，包括它的原理、核心操作及相关的注意事项。这种优雅的编程解决方案赢得了不少赞誉。然而，随着更多开发者在实际的 SwiftUI
应用中尝试使用 SwiftData，他们遇到了一些挑战：尤其在启用 Swift 的严格并发检查后，发现 SwiftData 基于 Actor
的并发模型与传统的应用构建方法很难融合。本文将采用类似教程的方式阐述如何将 SwiftData 与现代编程理念相结合，顺畅地融入 SwiftUI
应用之中，同时提供策略来应对目前开发者面临的挑战。

## 什么是所谓的现代方法？

在探讨现代编程方法时，虽然不同的开发者可能会有不同的见解，但有些核心原则是广泛认同的。在使用 SwiftData 构建 SwiftUI
应用的上下文中，我认为现代编程方法至少应满足以下几个关键标准：

- **模块化** ：通过将数据定义和操作逻辑封装在独立的模块中，我们不仅能增强代码的可读性和可维护性，还能促进功能的重用。模块化是确保项目结构清晰、灵活应对未来变化的基石。
- **全面可测试** ：确保每一个数据操作都通过彻底的单元测试是至关重要的。这种做法保证了代码的可靠性和稳定性，同时也使得持续集成和部署过程更加顺畅。
- **线程安全** ：在并发编程中保持数据的完整性和一致性是极其重要的。有效的线程安全措施不仅防止了数据冲突和竞态条件，而且符合 Swift 的严格并发标准，确保应用的高性能和稳定运行。
- **与架构无关** ：一个强大的数据管理模块应当灵活适应不同的架构设计，无论是 SwiftUI 自身的数据注入机制还是整合其他第三方框架，都应无缝对接，展现出高度的适应性。
- **支持预览** ：SwiftUI 的预览功能是其开发体验中的一大亮点，允许开发者即时看到界面变化。因此，确保数据层支持这一功能，对于加快开发流程和提高效率至关重要。
- **数据展示与操作分离** ：在遵循 SwiftUI 的响应式设计原则的同时，有效地分离数据展示与操作逻辑。通过 `@Query` 直观地展示数据并响应变化，而将创建、更新、删除等操作交由 SwiftData 的新并发模式处理，这样既提升了效率，又充分利用了 SwiftUI 响应式框架的优势。

为了更好地理解本文所讨论的概念，并实际看到这些现代编程方法在实践中的应用，我准备了一个演示项目。你可以通过访问以下 GitHub 仓库来获取完整的项目代码：

[ 访问演示项目代码 ](https://github.com/fatbobman/SwiftDataConcurrencyDemo)

该项目包含了使用 SwiftData 在 SwiftUI 应用中实现的示例，展示了如何按照文章中介绍的现代编程标准来构建应用。

## 创建数据管理模块

长久以来，将数据管理逻辑抽离出主项目，封装到一个独立的模块中，一直是一个广受推崇的做法。许多开发者在使用 Core Data
的项目中也采纳了这种模式。然而，与 SwiftData 相比，Core Data 在模块化方面给开发者带来了额外的挑战。这主要是由于 Core Data
在构建数据模型时使用图形化的模型编辑器，而数据模型本身则存储为独立的文件，它们会在应用的不同生命周期阶段以不同的文件扩展名被加载。这种对外部模型文件的依赖，在很大程度上减弱了开发者将数据管理代码模块化的意愿。

而
SwiftData，它的纯代码声明方式极大地简化了这一过程，实际上已经没有借口不将数据管理逻辑独立化了。这种方法不仅简化了代码的维护，而且还增加了代码的可移植性和可重用性。

考虑到数据管理模块通常与特定项目高度相关，在展示项目中我在项目的当前目录下创建一个新的 Swift Package，而不是为它建立一个单独的仓库。

首先创建一个名为 `DataProvider` 的包。在其 `Package.swift` 文件中，我们启用了 Swift
的严格并发检查功能，确保并发代码的安全性：

    .target(
      name: "DataProvider",
      swiftSettings: [
        .enableExperimentalFeature("StrictConcurrency"),
      ]
    ),

![image-20240316210229483](https://cdn.fatbobman.com/image-20240316210229483-zipic.png)

在这个独立的模块中，我们将完成数据模型的定义、数据操作逻辑的实现以及相关的测试工作。这样的结构不仅清晰地划分了应用的不同关注点，还使得维护和测试工作变得更加高效。

## 构建数据模型

在 SwiftData 中，构建数据模型的方法与定义 Swift 的基础类型极为相似，仅需通过纯代码即可完成。在我们的演示项目中，我们定义了一个简洁的模型
`Item` ：

    @Model
    public final class Item {
      public var timestamp: Date
      public var createTimestamp: Date

      public init(timestamp: Date) {
        self.timestamp = timestamp
        createTimestamp = .now
      }
    }

需要注意的是，采用 SwiftData
的纯代码建模方式意味着，一旦应用部署后需要修改数据模型或进行数据迁移，我们必须手动管理所有版本的数据模型。因此，尽管目前我们的模型版本只有一个，最好从一开始就规划好数据迁移的策略。

为此，我们首先定义一个用于表示模型版本的枚举，并通过 `CurrentScheme` 类型别名将其标记为当前使用的版本：

    public typealias CurrentScheme = SchemaV1

    public enum SchemaV1: VersionedSchema {
      public static var versionIdentifier: Schema.Version {
        .init(1, 0, 0)
      }

      public static var models: [any PersistentModel.Type] {
        [Item.self]
      }
    }

接下来，我们将 `Item` 类的声明嵌入到 `SchemaV1` 中，并通过类型别名保持名称的连贯性：

    public typealias Item = SchemaV1.Item

    extension SchemaV1 {
      @Model
      public final class Item {
        public var timestamp: Date
        public var createTimestamp: Date

        public init(timestamp: Date) {
          self.timestamp = timestamp
          createTimestamp = .now
        }
      }
    }

在我们的演示项目中，为了简化学习过程，我们没有进一步扩展数据模型。但在实际应用中，开发者可以通过扩展来为数据模型增加预设的谓词、排序规则或
FetchDescriptor 等信息，详见 [ 此示例代码
](https://gist.github.com/fatbobman/6dc873ae18bb28cd1ccc521b3f56cefb) 。

现在，无论是在模块内还是外部，我们都可以使用 `Item` 来引用这个版本的数据模型。若未来模型有变更，我们可以轻松地引入新的 Schema 版本，比如
`SchemaV2` ，并相应地调整类型别名，以适应新的模型结构。

> 要深入了解 SwiftData 数据模型的构建原理，请参阅 [ 揭秘 SwiftData 的数据建模原理 ](/zh/posts/unveiling-
> the-data-modeling-principles-of-swiftdata/) 。此外，若对 SwiftData
> 的数据模型迁移方法感兴趣，可阅读 [ 这篇文章 ](/zh/posts/what-s-new-in-core-data-in-
> wwdc23/#%E9%98%B6%E6%AE%B5%E5%BC%8F%E8%BF%81%E7%A7%BB-staged-migration)
> ，其中介绍了迁移策略和实施步骤。

## SwiftData 同样需要 Stack

在 Core Data 项目中，开发者习惯于构建一个类似于 Stack 的结构，用以集中管理持久化容器的声明和数据操作逻辑。SwiftData
显著简化了这一过程，允许开发者通过直接调用例如 `.modelContainer(for: Item.self)`
的简洁方式来快速构建容器并进行数据注入。那么，在使用 SwiftData 的场景下，是否还需要维护一个类似于 Stack 的结构呢？

尽管接下来我们将采用 `@ModelActor` 宏来封装数据操作逻辑，但构建一个类似于 Stack
的结构依然十分重要。这样的结构不仅为应用的不同部分统一提供容器和 `@ModelActor` 实现，而且在尝试结合 SwiftData 和 Core
Data 双框架模式的项目中尤为关键，因为它可以在同一位置处理两种框架的容器构建。

在我们的演示项目里，我们定义了一个 `DataProvider` 类。这个类在功能上类似于 Core Data 项目中常用的 `CoreDataStack` ：

    public final class DataProvider: Sendable {
      public static let shared = DataProvider()

      public let sharedModelContainer: ModelContainer = {
        let schema = Schema(CurrentScheme.models)
        let modelConfiguration = ModelConfiguration(schema: schema, isStoredInMemoryOnly: false)

        do {
          return try ModelContainer(for: schema, configurations: [modelConfiguration])
        } catch {
          fatalError("Could not create ModelContainer: \(error)")
        }
      }()

      public init() {}
    }

在这里，构建 schema 时直接利用了 `CurrentScheme.models` 提供的类型信息。此外，若数据模型需要迁移，相应的迁移逻辑也将在
`sharedModelContainer` 的初始化闭包中实现。

> 请阅读 [ 掌握 Core Data Stack ](/zh/posts/masteringofcoredatastack/) ，了解更多 Core
> Data Stack 的构建技巧。

## 用 @ModelActor 封装数据操作逻辑

SwiftData 提供了 `@ModelActor` 宏，鼓励开发者利用这一功能来创建一个 Actor 类型，进而在其中封装数据操作逻辑。对于我们的
`Item` 类型，我们定义了创建、更新和删除数据项的相关逻辑：

    @ModelActor
    public actor DataHandler {
      @discardableResult
      public func newItem(date: Date) throws -> PersistentIdentifier {
        let item = Item(timestamp: date)
        modelContext.insert(item)
        try modelContext.save()
        return item.persistentModelID
      }

      public func updateItem(id: PersistentIdentifier, timestamp: Date) throws {
        guard let item = self[id, as: Item.self] else { return }
        item.timestamp = timestamp
        try modelContext.save()
      }

      public func deleteItem(id: PersistentIdentifier) throws {
        guard let item = self[id, as: Item.self] else { return }
        modelContext.delete(item)
        try modelContext.save()
      }
    }

在实现这些功能时，有几点需要特别注意：

- 更新和删除操作仅接受 `PersistentIdentifier` 作为参数。
- 创建新的 Item 实例后，该方法会返回新创建对象的 `PersistentIdentifier` 。虽然在许多实际应用场景中这个返回值可能不常用，但它在进行单元测试时非常有用，提供了一种有效的方式来引用和测试新创建的数据实体。

> 为深入理解 `@ModelActor` 的用法及其在 SwiftData 中的角色，请参考文章 [ SwiftData 中的并发编程
> ](/zh/posts/concurret-programming-in-swiftdata/) 。

## 编写测试

尽管基于测试驱动开发（TDD）的逻辑通常推荐先编写测试再实现功能，但在我们的演示项目中，我们会在完成数据操作逻辑后才构建测试单元。

首先，我们设置一个专用于测试的辅助函数，确保每个测试用例都能使用一个干净的数据库环境：

    enum ContainerForTest {
      static func temp(_ name: String, delete: Bool = true) throws -> ModelContainer {
        let url = URL.temporaryDirectory.appending(component: name)
        if delete, FileManager.default.fileExists(atPath: url.path) {
          try FileManager.default.removeItem(at: url)
        }
        let schema = Schema(CurrentScheme.models)
        let configuration = ModelConfiguration(url: url)
        let container = try! ModelContainer(for: schema, configurations: configuration)
        return container
      }
    }

该辅助函数为每个测试用例创建独立的数据库，数据库名称基于测试函数的名称。默认情况下，它会在每次测试前删除旧的数据文件。

下面是一个测试用例，用于验证创建新的 `Item` 实例的功能：

    final class DataProviderTests: XCTestCase {
      @MainActor
      func testNewItem() async throws {
        // Arrange
        let container = try ContainerForTest.temp(#function)
        let hander = DataHandler(modelContainer: container)

        // ACT
        let date = Date(timeIntervalSince1970: 0)
        try await hander.newItem(date: date)

        // Assert
        let fetchDescriptor = FetchDescriptor<Item>()
        let items = try container.mainContext.fetch(fetchDescriptor)

        XCTAssertNotNil(items.first, "The item should be created and fetched successfully.")
        XCTAssertEqual(items.count, 1, "There should be exactly one item in the store.")

        if let firstItem = items.first {
          XCTAssertEqual(firstItem.timestamp, date, "The item's timestamp should match the initially provided date.")
        } else {
          XCTFail("Expected to find an item but none was found.")
        }
      }
    }

测试流程概述：

- 初始化一个新的、干净的数据库实例。
- 利用 `DataHandler` 添加新的数据项。
- 通过容器的 `mainContext` 从数据库中检索 `Item` 数据。
- 断言检索到的数据是否符合预期。

需要特别注意的是：

- 测试用例用 `@MainActor` 标注，以允许直接使用容器的 `mainContext` 。
- 创建和检索数据在不同的上下文中进行，以确保逻辑的准确性并模拟实际应用中的使用场景。
- 删除测试功能时，可以利用新创建数据项的返回值 `PersistentIdentifier` 来简化流程，避免重复从数据库检索数据。
- 返回的 `PersistentIdentifier` 应在相同的上下文中使用，特别是在它仍然是临时状态的情况下。对于跨上下文的操作，可能需要重新检索数据以获取持久化的标识符。

关于测试效率的顾虑：根据实际经验，即使是创建新数据库文件的测试方法也能在短时间内顺利完成大量测试，开发者无需担心其对测试性能的影响。

## 为注入做好准备

在完成了演示项目中对数据操作的全面测试后，下一步是考虑如何将 `DataHandler`
以安全且符合现代编程模式的方式，让项目中的其他代码轻松访问或进行注入。

为此，在 `DataProvider` 类中，我们定义了以下方法：

    public func dataHandlerCreator() -> @Sendable () async -> DataHandler {
      let container = sharedModelContainer
      return { DataHandler(modelContainer: container) }
    }

此辅助函数提供了一种安全的方法来创建 `DataHandler` 实例，这在启用 Swift 的严格并发检查功能时尤其关键。

在演示项目中，我们使用了将 `DataHandler`
创建函数注入到视图环境的做法。这种思路不仅限于通过环境值注入的方式，也适用于其他各种架构设计。例如，在使用 The Composable
Architecture (TCA) 时，可以采用相似的策略来定义 `DependencyKey` ，以便实现依赖注入的目的。此外，鉴于 `DataProvider` 本身符合 `Sendable`
协议，它也可以直接用作依赖注入的源，在某些场景下这种做法同样有效。这种灵活性允许开发者根据具体的应用架构需求，选择最合适的注入和依赖管理策略。

通过扩展 SwiftUI 的 `EnvironmentValues` ，我们能够将 `DataHandler` 的生成逻辑无缝集成到 SwiftUI
的环境中，从而为视图层提供强大的数据操作功能：

    public struct DataHandlerKey: EnvironmentKey {
      public static let defaultValue: @Sendable () async -> DataHandler? = { nil }
    }

    extension EnvironmentValues {
      public var createDataHandler: @Sendable () async -> DataHandler? {
        get { self[DataHandlerKey.self] }
        set { self[DataHandlerKey.self] = newValue }
      }
    }

至此，我们已经完成了数据管理模块的所有准备工作，现在可以将其集成到项目中，并开始利用这一模块了。

## 始终使用一个实例还是每次创建新的实例

在使用 SwiftData 进行开发时，我建议避免在 `DataProvider` 中持有一个长期共享的 `DataHandler`
实例。相反，在每个业务逻辑场景中独立创建新的实例或许是更好的选择。这种方法有几个优点：

首先，考虑到现代设备的性能已经非常出色，动态创建一个新的 `DataHandler`
实例的开销通常是可以接受的，不会对应用的响应速度或效率产生负面影响。

其次，由于 SwiftData
在某些方面如错误处理和合并策略等配置上的缺失，为每次数据操作创建一个新的独立实例可以简化异常处理的复杂度。这样，每个实例都是自包含的，操作互不干扰，从而降低了出错的风险，并使得代码更加清晰、易于维护。

## 将数据模块集成到项目中

在项目中引入 Package 后，我们可以开始在应用中使用它，为视图提供 `container` 和 `DataHandler` 生成方法。

    import DataProvider
    import SwiftData
    import SwiftUI

    @main
    struct SwiftDataConcurrencyDemoApp: App {
      let dataProvider = DataProvider.shared

      var body: some Scene {
        WindowGroup {
          ContentView()
            .environment(\.createDataHandler, dataProvider.dataHandlerCreator())
        }
        .modelContainer(dataProvider.sharedModelContainer)
      }
    }

此代码段将 `DataProvider` 的实例集成到了 SwiftUI 应用的主入口。我们通过 `.environment` 修饰器注入 `createDataHandler` 方法，使其在 `ContentView` 及其子视图中可用。

在 `ContentView` 中，我们实现了添加新数据项的功能，如下所示：

    struct ContentView: View {
      @Environment(\.modelContext) private var modelContext
      @Environment(\.createDataHandler) private var createDataHandler
      @Query(sort: \Item.createTimestamp, animation: .smooth) private var items: [Item]

      var body: some View {
        NavigationSplitView {
          List {
            ForEach(items) { item in
              ItemView(item: item)
            }
          }
          .toolbar {
            ToolbarItem {
              Button(action: addItem) {
                Label("Add Item", systemImage: "plus")
              }
            }
          }
        } detail: {
          Text("Select an item")
        }
      }

      @MainActor
      private func addItem() {
        let createDataHandler = createDataHandler
        Task.detached {
          if let dataHandler = await createDataHandler() {
            try await dataHandler.newItem(date: .now)
          }
        }
      }
    }

关键点概述：

- 使用 `@Environment(\.createDataHandler)` 将创建 `DataHandler` 的方法引入视图。
- 为了符合 Swift 的严格并发检查，我们需用 `@MainActor` 标注 `addItem` 函数。
- 利用 `Task.detached` 创建一个分离的任务，确保在非主线程上创建 `DataHandler` 实例，并进行数据操作，从而避免阻塞 UI。

通过这种方式，数据管理逻辑与视图逻辑分离，保持了代码的清晰性和可维护性，同时也利于异步数据处理和更新界面。

## 构建独立视图来展示数据

继列表视图之后，我们接下来将构建用于展示 `Item` 数据详细信息的独立视图。在 `ItemView` 中，我们利用 `createDataHandler` 环境变量来创建 `DataHandler` 实例，分别处理数据的删除和更新操作。所有 `DataHandler` 实例的操作都在非主线程上进行，以确保界面的流畅性不受数据处理过程的影响。

    struct ItemView: View {
      @Environment(\.createDataHandler) private var createDataHandler
      let item: Item
      var body: some View {
        VStack {
          Text("\(item.timestamp.timeIntervalSince1970)")
          HStack {
            Button("Update Timestamp") {
              let id = item.id
              let date = Date.now
              let createDataHandler = createDataHandler
              Task.detached {
                if let dataHandler = await createDataHandler() {
                  try? await dataHandler.updateItem(id: id, timestamp: date)
                }
              }
            }
            Button("Delete") {
              let id = item.id
              let createDataHandler = createDataHandler
              Task.detached {
                if let dataHandler = await createDataHandler() {
                  try? await dataHandler.deleteItem(id: id)
                }
              }
            }
          }
        }
        .buttonStyle(.bordered)
      }
    }

现在，我们就可以在模拟器中完整的运行项目并实现数据的添加与删除了。

## 是否还需要数据转换层？

在传统的 Core Data
项目中，通常会创建一个值类型的数据转换层，这一层主要作用是将托管对象（引用类型）转换为更适合视图使用的值类型，这有助于提高数据处理的安全性和简化视图的数据绑定。

在 SwiftData 中，模型本身就是用纯 Swift 类型构建的，加上 SwiftData 的 `PersistentModel` 采用 `Observation`
框架提供的观察机制，这一机制为每个属性提供了观察能力，确保了视图能精准响应数据变化。如果在视图中对这些数据进行转换，会破坏此观察机制，增加不必要的视图更新，因此，建议在视图中直接使用
SwiftData 中定义的数据模型。

然而，这并不意味着在所有场景下都不需要数据转换层。实际上，在创建或更新数据时，使用基于值类型的数据模型可以更加安全和高效，尤其在涉及数据比对和测试时。

虽然在演示项目中我们没有提供转换层的数据类型，但在实际应用的开发过程中，开发者应根据具体需求考虑是否引入这一层。这种设计决策应基于项目的具体需求，考虑到数据安全、开发效率以及是否能够提升整体的代码质量和可维护性。

## 为预览做准备

在 SwiftUI
开发中，预览是一个不可或缺的功能，它可以大大提高开发效率。因此，为预览配置适当的环境是至关重要的。我们通常推荐使用基于内存的数据库用于预览场景，这就要求我们需要对
`DataProvider` 进行适当的调整。

首先，我们在 `DataProvider` 中添加以下代码，以初始化一个非持久化的 `ModelContainer` ，专门用于预览环境：

    public let previewContainer: ModelContainer = {
      let schema = Schema(CurrentScheme.models)
      let modelConfiguration = ModelConfiguration(schema: schema, isStoredInMemoryOnly: true)
      do {
        return try ModelContainer(for: schema, configurations: [modelConfiguration])
      } catch {
        fatalError("Could not create ModelContainer: \(error)")
      }
    }()

接着，我们修改 `dataHandlerCreator` 函数，使其能够根据需求选择使用持久化或非持久化的容器：

    public func dataHandlerCreator(preview: Bool = false) -> @Sendable () async -> DataHandler {
      let container = preview ? previewContainer : sharedModelContainer
      return { DataHandler(modelContainer: container) }
    }

为了在预览中有效利用这些配置，我们通常会创建一个专用的预览包装视图，它不仅准备预览环境，还可以构建演示数据。以下是一个示例，展示了如何为 `ItemView` 构建一个预览容器：

    #if DEBUG
      struct ItemViewPreviewContainer: View {
        @Environment(\.createDataHandler) var createDataHandler
        @Query var items: [Item]
        var body: some View {
          VStack {
            if let item = items.first {
              ItemView(item: item)
            }
          }
          .task {
            if let dataHander = await createDataHandler() {
              let _ = try? await dataHander.newItem(date: .now)
            }
          }
        }
      }
    #endif

    #Preview {
      let dataProvider = DataProvider()
      return ItemViewPreviewContainer()
        .environment(\.createDataHandler, dataProvider.dataHandlerCreator(preview: true))
        .modelContainer(dataProvider.previewContainer)
    }

当配置 `ItemViewPreviewContainer` 的预览环境时，确保使用专门为预览准备的 `container` 和 `DataHandler` 创建函数。这样可以保证预览环境是隔离的，不会影响到实际的应用数据，同时提供了一种快速高效的方式来演示和测试视图。

## 新的问题：数据更新后视图没有刷新

如果你跟随本文构建自己的代码，可能会遇到一个问题：在 `ItemView`
中点击更新数据的按钮时，界面上的数据并没有相应地更新。考虑到我们的单元测试能够正常通过，且数据更新逻辑本身没有问题，那么这个问题是怎么引起的呢？

这实际上是由当前 SwiftData 的一个已知 Bug 导致的，当满足以下两个条件时，会出现数据更新后视图未刷新的情况：

- 数据更新逻辑被封装在 `ModelActor` 中。
- 使用独立的视图来展示和响应数据的变化（例如，当我们将展示代码做如下调整，通过直接使用 `Text` 显示数据时，可以明显看到更新后的区别）：

  List {
  ForEach(items) { item in
  VStack {
  Text("\(item.timestamp.timeIntervalSince1970)")
  ItemView(item: item) // don't change after update
  }
  }
  }

这个问题已有多位使用 `ModelActor`
的开发者向我提出，我当时给出的解决方案并不理想，主要是通过为数据展示视图增加额外的参数来实现更新感知。这种方法局限性较大，且可能会丢失首次更新的变化。本文将探讨其他可能的解决方案。

    struct ItemView: View {
      @Environment(\.createDataHandler) private var createDataHandler
      let item: Item
      let date: Date
      var body: some View {
         ....
      }
    }

    ItemView(item: item, date: item.timestamp)

> 我已经向苹果提交了反馈（ `FB13689240` ），希望问题能够尽早得到修复。

## 解决思路

为了解决数据更新后视图不刷新的问题，我们首先会考虑以下两种方法：

1. 避免使用独立视图来展示和响应数据。
2. 将数据更新逻辑从 `DataHandler` 中剥离，并直接在 `mainContext` 中修改数据。

显然，出于维护现有架构模式和测试流程的考虑，这两种方法都不是我们所希望的。但是，如果在 `mainContext`
中执行数据更新操作可以避免视图不刷新的问题，那么我们是否可以考虑创建一个专门用于数据更新操作的 `DataHandler` 实例，它直接使用 `mainContext` 呢？

> `mainContext` 是由 `ModelContainer` 实例提供的，它被标注了 `@MainActor`
> 只能在主线程中使用。我们在视图中通过 `@Qurey` 检索数据时便是通过这个上下文。

Swift 的宏（Macro）功能为这种思路提供了实现的可能性。通过探索由 `@ModelActor`
宏生成的代码，我们可以洞察其背后的实现机制，并据此进行必要的调整。

观察 `@ModelActor` 宏生成的 `DataHandler` 初始化方法：

    public init(modelContainer: SwiftData.ModelContainer) {
        let modelContext = ModelContext(modelContainer)
        self.modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)
        self.modelContainer = modelContainer
    }

这个初始化方法通过 `ModelContext(modelContainer)` 创建了一个新的 `ModelContext` 实例，并设定
Actor 的执行环境与此上下文相关联（ 使用相同的线程 ）。因此，我们可以考虑为 `DataHandler`
添加一个新的构造方法，这样就可以在不大幅度调整当前开发模式的前提下，提供一个解决方案。

## 临时解决方案

我们的这个临时方案涉及对 `DataHandler` 类的扩展和对 `DataProvider` 的调整，以确保在主线程上的 `mainContext` 进行数据更新操作。

首先，我们为 `DataHandler` 添加一个新的构造方法：

    @MainActor
    public init(modelContainer: ModelContainer, mainActor _: Bool) {
      let modelContext = modelContainer.mainContext
      modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)
      self.modelContainer = modelContainer
    }

此构造函数通过 `@MainActor` 标注确保能够将 `modelContainer.mainContext` 与 Actor
的执行器直接绑定。我们引入了一个未使用的参数来避免与现有构造函数签名冲突。

然后，在 `DataProvider` 中添加一个新的辅助方法，用于生成绑定到 `mainContext` 的 `DataHandler`
实例：

    public func dataHandlerWithMainContextCreator(preview: Bool = false) -> @Sendable @MainActor () async -> DataHandler {
      let container = preview ? previewContainer : sharedModelContainer
      return { DataHandler(modelContainer: container, mainActor: true) }
    }

接下来，我们定义一个新的环境键，并扩展 `EnvironmentValues` 以注入新的辅助方法：

    public struct MainActorDataHandlerKey: EnvironmentKey {
      public static let defaultValue: @Sendable @MainActor () async -> DataHandler? = { nil }
    }

    extension EnvironmentValues {
      public var createDataHandlerWithMainContext: @Sendable @MainActor () async -> DataHandler? {
        get { self[MainActorDataHandlerKey.self] }
        set { self[MainActorDataHandlerKey.self] = newValue }
      }
    }

在应用的根视图中，我们注入这个新的环境值：

    WindowGroup {
      ContentView()
        .environment(\.createDataHandler, dataProvider.dataHandlerCreator())
        // new
        .environment(\.createDataHandlerWithMainContext, dataProvider.dataHandlerWithMainContextCreator())
    }

在 `ItemView` 中，我们引入并使用这个新环境值来执行数据更新操作：

    struct ItemView: View {
      @Environment(\.createDataHandler) private var createDataHandler
      @Environment(\.createDataHandlerWithMainContext) private var createDataHandlerWithMainContext
      let item: Item
      var body: some View {
        VStack {
          Text("\(item.timestamp.timeIntervalSince1970)")
          HStack {
            Button("Update Timestamp") {
              updateItemTimestamp()
            }
    				....
          }
        }
        .buttonStyle(.bordered)
      }

      @MainActor
      private func updateItemTimestamp() {
        let id = item.id
        let date = Date.now
        Task { @MainActor in
          if let dataHandler = await createDataHandlerWithMainContext() {
            try? await dataHandler.updateItem(id: id, timestamp: date)
          }
        }
      }
    }

确保预览环境也注入了相应的环境值：

    #Preview {
      let dataProvider = DataProvider()
      return ItemViewPreviewContainer()
        .environment(\.createDataHandler, dataProvider.dataHandlerCreator(preview: true))
        .environment(\.createDataHandlerWithMainContext, dataProvider.dataHandlerWithMainContextCreator(preview: true))
        .modelContainer(dataProvider.previewContainer)
    }

通过这种方式，我们可以保证数据更新操作会在一个绑定到主线程 `mainContext` 的 `DataHandler`
实例中进行，而其他操作仍在非主线程执行。虽然这需要我们为更新操作进行特别的处理，但这是在不改变原有架构的前提下的一个可行的妥协方案。我希望这个问题可以尽快被官方修复。

> **特别提醒** ：自首个版本（iOS 17.0）起，SwiftData
> 几乎在每个版本中都对一些已知问题进行了修复，同时也可能引入了新的问题。因此，当你运行文章中提供的 Demo
> 项目，而项目运行在不同的系统版本或使用不同版本的 Xcode
> 编译时，可能会遇到与预期不一致的结果（比如，点击添加按钮后无法看到新数据，或应用被推到后台时崩溃等）。我们还需等待苹果对这些问题进行进一步的修复。尽管如此，我相信文章中介绍的数据操作逻辑本身是正确的。为了确保在当前项目中以稳定、可靠的方式使用本文介绍的方法，请通过
> `createDataHandlerWithMainContext` 创建所有的 `DataHandler` （即使用主上下文来构建 `DataHandler` ）。

## 总结

在这篇文章中，我们探讨了如何采用新思维来构建使用 SwiftData 的 SwiftUI
应用。当我们开始使用新框架时，特别是那些在旧有框架基础上发展起来的框架，我们不能仅仅将旧有的经验和习惯直接移植过来。我们需要深入思考如何利用新框架的优势，同时融入最新的编程理念，以打造更加高效、现代化的应用。

框架的每次更新不仅是一项挑战，也是一个机遇。它要求开发者离开舒适区，重新审视和学习新工具的潜力和最佳实践。通过这样做，我们不仅能够提升个人技能，还能够为用户提供更好的产品。SwiftData
作为一个现代化的数据管理框架，给予了开发者更大的灵活性和更强大的功能，使得数据处理更加直观和高效。

随着 Swift 和 SwiftUI 的不断进化，结合像 SwiftData
这样的框架，开发者被赋予了创造出更加安全、更加响应式、更加丰富和更具互动性应用的能力。因此，紧跟最新的开发趋势，并学会利用这些新工具的强大功能，将是每一个致力于提升自身技能和产品质量的开发者的必经之路。

# 如何在 Core Data 中使用 Derived 和 Transient 属性

## 前言

使用过 Core Data 的开发者，一定会在编辑 Data Model 时看到过右侧的属性面板中的 Derived 和 Transient
两个属性。关于这两个属性的文档不多，大多的开发者并不清楚该如何使用或在何时使用该属性。文本将结合我的使用体验，对 Derived 和 Transient
两个属性的功能、用法、注意事项等内容作以介绍。

## Derived

### 什么是 Derived 属性

从 iOS 13 开始，苹果在 Core Data 中添加了 Derived（派生属性），它的名称已经表明了该属性的含义——
该属性的值从一个或多个其他的属性的值派生而来。

通俗地说，就是在创建或修改托管对象实例时，Core Data 将自动为派生属性生成值。值将根据预设的派生表达式（Derived
Expression）通过其他的属性值计算而来。

### Derived 属性的功能

下面通过一个具体的例子方便大家理解派生属性的功能。

项目中有两个 Entity，TodoList 和 Item，Todolist 同 Item 是一对多关系（To-many），Item 同 TodoList
之间是一对一关系（To-one）

![image-20211025175712406](https://cdn.fatbobman.com/image-20211025175712406.png)

在之前如果我们要查看每个 TodoList 下有多少个 Item，可以使用如下代码：

    let count = todolist.items.count

使用 Derived 派生属性后，我们将可以通过如下代码获取 Item 的个数。

    let count = todolist.count

### 如何设置 Derived 属性

通常我们需要在 Core Data 的数据模型编辑器（Data Model Editor）中设置派生属性，如下图，我们为上面的例子中的 TodoList
创建派生属性 count

![image-20211025183247335](https://cdn.fatbobman.com/image-20211025183247335.png)

- 为 TodoList 创建名为 count 的属性
- 选择 Derived
- 将 Derivation 设置为 items.@count （计算 items 关系对应的数据个数）

开发者可以根据需要设定派生属性的类型和派生表达式，目前支持的派生表达式有以下几种形式：

- 仅仅复制内容

通常使用在 to-one 的关系中，比如上面的例子中，我们可以使用派生表达式 `todolist.name` ，为 Item 设置一个
todolistName 的 Derived 属性，用于保存该 Item 对应的 TodoList 的名称。复制的属性类型没有特别的限制。

- 将某个属性（类型为字符串）经过变换保存

仅支持类型为 String 的属性，可以使用在同一个 Entity 中的不同属性或者 to-one 的 Entity 属性中。支持 `uppercase:` 、 `lowercase:` 以及 `canonical:` 三种方法。通过保存字符串的变体，提供搜索效率。例如，保存 TodoList 的
name 的小写版本的派生表达式为 `lowercase:(todolist.name)` 。

- 计算对多关系的 count 和 sum

计算对多关系（to-many）对象的个数或计算指定属性的求和值。使用@sum 时，要求对应的属性必须为可计算值类型。例如计算一个实体名称为
Student，属性名为 age 的总和值的表达式为 `student.age.@sum` 。

- 当前时间

保存 SQLite 更新托管对象对应的数据记录的操作日期。通常用于类似 lastModifiedDate 之类的时间戳。派生表达式为 `now()` 。

通常我们将 Derived 同 Optional 配合使用，如果不选取 Optional
则需要做一点特殊处理才能让程序正常执行。在下文的注意事项中有具体说明。

如果手动编写 NSManagedObject 代码，Derived 属性的写法同其他属性也完全一致（仍需在 Data Model Editor
中设置），例如上文中的 count 可以使用如下代码定义：

    @NSManaged var count: Int

### Derived 数据的更新机制

#### 派生数据的值是谁计算的

派生数据的值是由 SQLite 直接计算并更新的。

Derived 值的计算是 Core Data 中为数不多的几个直接使用 SQLite 内置机制来完成的操作，并非由 Swift（或 Objective -
C） 代码计算而来。

例如，now () 的表达式，Core Data 在创建数据表时将产生类似如下的 SQL 代码：

SQL

Copy code

Copied!

    CREATE TRIGGER IF NOT EXISTS Z_DA_ZITEM_Item_update_UPDATE AFTER UPDATE OF Z_OPT ON ZITEM FOR EACH ROW BEGIN UPDATE ZITEM SET ZUPDATE = NSCoreDataNow() WHERE Z_PK = NEW.Z_PK; SELECT NSCoreDataDATriggerUpdatedAffectedObjectValue('ZITEM', Z_ENT, Z_PK, 'update', ZUPDATE) FROM ZITEM WHERE Z_PK = NEW.Z_PK; END'

@count 对应的代码：

    UPDATE ZITEM SET ZCOUNT = (SELECT IFNULL(COUNT(ZITEM), 0) FROM ZATTACHEMENT WHERE ZITEM = ZITEM.Z_PK);

因此在相同功能的情况下，使用 SQL 的效率是高于 Swift（或 Objective - C）的。

> Core Data 中，通常需要从持久化存储获取结果后，返回到上下文，再经过计算然后持久化。中间有多次的 IO 过程，影响了效率。

#### 派生数据什么时候更新

因为是由 SQLite 直接处理的，所以只有在数据持久化时 SQLite
才会更新对应的派生数据。只在上下文中处理不持久化的话是不会获得正确的派生值的。持久化的行为可以是通过使用代码 `viewcontext.save()`
，或者通过网络同步等方式激发。

### Derived 的优缺点

#### 优点

- 效率高

由于其特有的更新机制，所以对于值的处理效率更高，且不会有多余的处理动作（只在持久化时才进行更新）。

- 逻辑简洁清晰

使用得当的情况下，配置所需代码更少，表达更清晰。例如 `now()`

#### 缺点

- 支持的表达式有限

SQLite 能够支持的表达式非常有限，无法满足更复杂的业务需要。

- 对于不了解 Derived 的开发者来说，代码更难阅读

Derived 的配置是在 Data Model Editor 中进行的，仅阅读代码将无法获悉该数据的来源和处理方式。

### Derived 的替代方案

#### 计算属性

对于使用频率不高的属性值，为托管对象创建计算属性或许是更好的选择，例如上文中计算 TodoList 的 Item 数量。

    extension TodoList {
        var count:Int { items.count }
    }

#### willSave

使用 NSManagedObject 的 willSave 方法，在数据持久化前，为指定属性设置值。例如：

    extension Item {
        override func willSave() {
          super.willSave()
          setPrimitiveValue(Date(), forKey: #keyPath(Item.lastModifiedDate))
      }
    }

Derived 同上述两种方式均有各自的优缺点，请根据具体的使用场景来选择合适的方案。

### Derived 的注意事项

在配置 Derived 属性时，如果不选择 Optional，直接执行代码的话，在添加数据时会得到类似如下的错误：

    Fatal error: Unresolved error Error Domain=NSCocoaErrorDomain Code=1570 "count is a required value."

这是因为，由于该属性并非可选值，所以 Core Data
要求我们为派生属性默认值，但是由于派生属性是只读的，因此我们无法在代码中直接为托管对象实例的派生属性赋值。

解决的方法是，通过在 awakeFromInsert 中为派生属性设置初始化值，即可通过 Core Data 的属性有效性检查。

    extension TodoList {
        override func awakeFromInset(){
            super.awakeFromInsert()
            setPrimitiveValue(0, forKey: #keyPath(Todolist.count))
        }
    }

设置的 value 可以是任意值（需要符合类型要求），因为在持久化时，SQLite 将生成新的值覆盖掉我们的初始化值。

## Transient

### 什么是 Transient 属性

Transient（瞬态属性）是一种不可持久化的属性。作为托管对象定义的一部分，Core Data 会跟踪 Transient
属性的变化，并设置对应的托管对象和托管对象上下文状态，但属性中的内容将不会被保存到持久化存储器中，也不会在持久化存储中创建对应的字段。

除了不能持久化外，瞬态属性同其他的 Core Data 属性没有什么区别，支持全部的可用数据类型，以及 Optional，Default Value
等选项。

### 如何设置 Transient 属性

相较于 Derived，瞬态属性设置非常简单，只需要勾选 Transient 即可。

![image-20211025201846952](https://cdn.fatbobman.com/image-20211025201846952.png)

### 为什么使用 Transient

既然 Transient 不可持久化，为什么我们要使用 Data Model Editor 来创建它呢？

我们可以通过代码直接为托管对象创建存储属性，例如：

    @objc(Test)
    public class Item: NSManagedObject {
      var temp:Int = 0
    }

    extension Item
        @NSManaged public var createDate: Date?
        @NSManaged public var title: String?

    }

    let item = Item(context:viewContext)
    item.temp = 100

上面的代码，无论我们如何修改 item 的 temp 属性，都不会让 Core Data 感知到。

托管对象的托管属性（使用@NSManaged 标示）是由 Core Data 来托管的，Core Data
将持续跟踪托管对象中的托管属性来设置相应的状态。使用 Transient 属性，Core Data 在该属性内容发生变化时将托管对象实例的
hasChanges 以及托管对象上下文的 hasChanges 设置为 true，这样无论是@FetchRequest 还是
NSFetchedResultsController 都将会自动反应数据的变化。

因此，当我们不需要持久化但又要能够 dirty 状态时，Transient 就成了唯一的选择。

### Transient 值的初始化

由于 Transient 属性是不可持久化的，因此每当含有 Transient 属性的托管对象实例出现（Fetch、Create、Undo
等情况）在上下文中时，其瞬态属性都将恢复到初始值。

尽管在 Data Model Editor 中，我们可以为 Transient 设置默认值，但很多场景下，我们需要根据情况或其他数据计算并创建
Transient 的初始值。我们可以选择在如下的时机来设置：

- awakeFromFetch

为惰值状态（Fault）的实例填充数据时

- awakeFromInsert

创建托管对象实例时

- awake (fromSnapshotEvents:NSSnapshotEventType)

从快照中载入实例时

在这些方法中设置 Transient 或其他属性时，应使用原始访问器方法来设置数据，避免触发 KVO 观察器通知。例如：

    setPrimitiveValue("hello",forKey:#keyPath(Movie.title))

### Transient 属性使用举例

绝大多数的 Core Data 书籍中，即使提到了 Transient 属性也通常是一带而过。作者通常会表示自己没有遇到合适的 Transient
使用案例。

我也是在不久前，才遇到第一个符合 Transient 特点的应用场景。

在开发 [ 【健康笔记 3.0】 ](/healthnotes/) 的过程中，我有一处地方需要对一个包含很多关系和记录的托管对象实例进行 Deep
Copy（复制其下的全部关系数据），复制后的实例将在复制完成后替换掉原来的实例（为了解决网络数据共享中遇到的特殊需求）。因为使用了@FetchRequest，因此在复制过程中的
1-2 秒钟，UI 列表中会出现两个同样的数据记录，会给使用者带来困惑。

如果使用持久化方案，我可以为该数据创建一个用来表示显示与否的属性，例如 visible。通过在复制操作前后设置该属性并配置 Predicate
来解决列表重复问题。

但由于该场景的使用次数非常少（很多用户可能完全不会使用到），因此创建一个可持久性字段将非常浪费。

因此，我为该托管对象创建了一个名为 visible 的 Transient 属性，既避免了重复显示，同时又不会浪费存储空间。

### 其他关于 Transient 的注意事项

- NSManagedObjectContext 的 refreshAllObjects 将重置 Transient 内容
- 如果仅需要查看托管对象可持久性属性是否有改变可以使用 hasPersistentChangedValues
- 不要在 NSPredicate 中使用 transient 属性作为限制条件

      @FetchRequest(entity: Test.entity(),
                    sortDescriptors: [NSSortDescriptor(keyPath: \Test.title, ascending: true)],
                    predicate: NSPredicate(format: "visible = true"))
      var tests: FetchedResults<Test>

上面代码的使用方式是错误的，如果想仅显示 visible == true 的数据，可以使用如下方式：

        @FetchRequest(entity: Test.entity(),
                      sortDescriptors: [NSSortDescriptor(keyPath: \Test.title, ascending: true)])

        ForEach(tests) { test in
             if test.visible {
                 row(test: test)
             }
        }

## 总结

Core Data
作为一个历史悠久的框架，包含了不少非常有用但不被人熟知的功能。即使只是泛泛了解一下这些功能，不仅可以开阔思路，说不定在某个场合它就会成为解决问题的利器。

# @AppStorage 研究

## 前言

在苹果生态的应用中，开发者或多或少都会使用到 UserDefaults。我个人习惯将可被用户自定义的配置信息（精度、单位、色彩等）保存在
UserDefaults 中。随着配置信息的增加，在 SwiftUI 视图中使用的 @AppStorage 越来越多。

在 [ 【健康笔记 3】 ](/healthnotes/) 中，我计划开放更多的自定义选项给用户，简单的算下来要有 40-50
项，在配置视图中更会将所有用到的 UserDefaults 内容都注入进代码。

本文探讨的是如何优雅、高效、安全地在 SwiftUI 中使用 @AppStorage，在不借助第三方库的情况下，解决当前 @AppStorage
使用中出现的痛点：

- 支持的数据类型少
- 声明繁琐
- 声明容易出现拼写错误
- 大量 @AppStorage 无法统一注入

## @AppStorage 基础指南

@AppStorage 是 SwiftUI 框架提供的一个属性包装器，设计初衷是创建一种在视图中保存和读取 UserDefaults
变量的快捷方法。@AppStorage 在视图中的行为同 @State 很类似，其值变化时将导致与其依赖的视图无效并进行重新绘制。

@AppStorage 声明时需要指定在 UserDefaults 中保存的键名称（Key）以及默认值。

    @AppStorage("username") var name = "fatbobman"

`userName` 为键名称， `fatbobman` 是为 `username` 设定的默认值，如果 UserDefaults 中的 `username` 已经有值，则使用保存值。

如果不设置默认值，则变量的为可选值类型

    @AppStorage("username") var name:String?

默认情况下使用的是 UserDefaults. standard，也可以指定其他的 UserDefaults。

    public extension UserDefaults {
        static let shared = UserDefaults(suiteName: "group.com.fatbobman.examples")!
    }

    @AppStorage("userName",store:UserDefaults.shared) var name = "fat"

对 UserDefaults 操作将直接影响对应的 @AppStorage

    UserDefaults.standard.set("bob",forKey:"username")

上述代码将更新所有依赖 `@AppStorage("username")` 的视图。

UserDefaults 是一种高效且轻量的持久化方案，它有以下不足：

- 数据不安全

它的数据相对容易提取，所以不要保存和隐私有关的重要数据

- 持久化时机不确定

为了效率的考量，UserDefaults
中的数据在发生变化时并不会立即持久化，系统会在认为合适的时机才将数据保存在硬盘中。因此，可能发生数据不能完全同步的情况，严重时有数据彻底丢失的可能。尽量不要在其中保存会影响
App 执行完整性的关键数据，在出现数据丢失的状况下，App 仍可根据默认值正常运行

尽管 @AppStorage 是作为 UserDefaults 的属性包装器存在的，但 @AppStorage 并没有支持全部的 `property
list` 数据类型，目前仅支持：Bool、Int、Double、String、URL、Data（UserDefaults 支持更多的类型）。

## 增加 @AppStorage 支持的数据类型

除了上述的类型外，@AppStorage 还支持符合 `RawRepresentable` 协议且 `RawValue` 为 `Int` 或 `String` 的数据类型。通过增加 `RawRepresentable` 协议的支持，我们可以在 @AppStorage
中读取存储原本并不支持的数据类型。

下面的代码添加了对 `Date` 类型的支持：

    extension Date:RawRepresentable{
        public typealias RawValue = String
        public init?(rawValue: RawValue) {
            guard let data = rawValue.data(using: .utf8),
                  let date = try? JSONDecoder().decode(Date.self, from: data) else {
                return nil
            }
            self = date
        }

        public var rawValue: RawValue{
            guard let data = try? JSONEncoder().encode(self),
                  let result = String(data:data,encoding: .utf8) else {
                return ""
            }
           return result
        }
    }

使用起来和直接支持的类型完全一致：

    @AppStorage("date") var date = Date()

下面的代码添加了对 `Array` 的支持：

    extension Array: RawRepresentable where Element: Codable {
        public init?(rawValue: String) {
            guard let data = rawValue.data(using: .utf8),
                  let result = try? JSONDecoder().decode([Element].self, from: data)
            else { return nil }
            self = result
        }

        public var rawValue: String {
            guard let data = try? JSONEncoder().encode(self),
                  let result = String(data: data, encoding: .utf8)
            else {
                return "[]"
            }
            return result
        }
    }





    @AppStorage("selections") var selections = [3,4,5]

对于 `RawValue` 为 `Int` 或 `String` 的枚举类型，可以直接使用，比如：

    enum Options:Int{
        case a,b,c,d
    }

    @AppStorage("option") var option = Options.a

## 安全和便捷的声明（一）

@AppStorage 的声明方式有两个令人不悦的地方：

- 每次都要设定 Key（字符串）
- 每次都要设定默认值

而且开发者很难享受到代码自动补全和编译时检查带来的快捷、安全的体验。

较好的解决方案是将 @AppStorage 集中声明，并在每个视图中通过引用注入。 **鉴于 SwiftUI
的刷新机制，我们必须要在集中声明、单独注入后仍需保留 @AppStorage 的`DynamicProperty` 特征——当 UserDefaults
的值发生变动时刷新视图。 **

下面的代码能满足以上的要求：

    enum Configuration{
        static let name = AppStorage(wrappedValue: "fatbobman", "name")
        static let age = AppStorage(wrappedValue: 12, "age")
    }

在视图中使用方法如下：

    let name = Configuration.name
    var body:some View{
         Text(name.wrappedValue)
         TextField("name",text:name.projectedValue)
    }

`name` 和直接在代码中通过 @AppStorage 声明的效果类似。不过付出的代价就是需要将 `wrappedValue` 和 `projectedValue` 明确标注出来。

> 是否有不标注 `wrappedValue` 和 `projectedValue`
> 又能达到上述结果的实现方案呢？在安全和便捷的声明（二）中我们将尝试使用另一种解决途径。

## 集中注入

在介绍另一种便捷声明方式之前，我们先聊一下集中注入的问题。

【健康笔记 3】目前面临着前言中所描述的情况，配置信息内容很多，如果单独注入会很麻烦。我需要找到一种可以集中声明、一并注入的方式。

在安全和便捷的声明（一）中使用的方法对于单独注入的情况是满足的，但如果我们想统一注入的话就需要其他的手段了。

> 我并不打算将配置数据汇总到一个结构体中并通过支持 `RawRepresentable`
> 协议统一保存。除了数据转换导致的性能损失外，另一个重要问题是，如果出现数据丢失的情况，逐条保存的方式还是可以保护绝大多数的用户设定的。

在基础指南中，我们提到 @AppStorage 在视图中的表现同 @State 非常类似；不仅如此，@AppStorage
还有一个官方文档从没提到的神奇特质，\*\*在 ObservableObject 中具有同@Published 一样的特性——其值发生变化时会触发 `objectWillChange` 。这个特性只发生在 @AppStorage 身上，@State、@SceneStorage 都不具备这个能力。

~~目前我无法从文档或暴露的代码中找到这一特性原因，因此以下的代码并不能获得官方的长期保证~~

> 感谢网友 hstdt 的反馈，苹果在 [ 官方文档 ](https://developer.apple.com/documentation/ios-
> ipados-release-notes/ios-ipados-14_5-release-notes) 中已明确提到了 @AppStorage
> 支持上述特定（ 14.5 以上支持 ）

> 2022 年 5 月更新：关于 @AppStorage 和 @Published 调用包裹其的类实例的 objectWillChange 的原理，请参阅
> [ 为自定义属性包装类型添加类 @Published 的能力 ](/zh/posts/adding-published-ability-to-
> custom-property-wrapper-types/) 。

    class Defaults: ObservableObject {
        @AppStorage("name") public var name = "fatbobman"
        @AppStorage("age") public var age = 12
    }

视图代码：

    @StateObject var defaults = Defaults()
    ...
    Text(defaults.name)
    TextField("name",text:defaults.$name)

不仅代码整洁了许多，而且由于只需要在 `Defaults` 中声明一次，极大的降低了由于字符串拼写错误而出现的不易排查的 Bug。

> `Defaults` 中使用的是 `@AppStorage` 的声明方式，而 `Configuration` 中使用的是 `AppStorage` 的原始构造形式。变化的目的是为了能够保证视图更新机制的正常运作。

## 安全和便捷的声明（二）

**集中注入** 中提供的方法已经基本解决了我在当前使用 @AppStorage 中碰到的不便，不过我们还可以尝试另一种优雅、有趣的逐条声明注入的方式。

首先修改一下 `Defaults` 的代码

    public class Defaults: ObservableObject {
        @AppStorage("name") public var name = "fatbobman"
        @AppStorage("age") public var age = 12
        public static let shared = Defaults()
    }

创建一个新的属性包装器 `Default`

    @propertyWrapper
    public struct Default<T>: DynamicProperty {
        @ObservedObject private var defaults: Defaults
        private let keyPath: ReferenceWritableKeyPath<Defaults, T>
        public init(_ keyPath: ReferenceWritableKeyPath<Defaults, T>, defaults: Defaults = .shared) {
            self.keyPath = keyPath
            self.defaults = defaults
        }

        public var wrappedValue: T {
            get { defaults[keyPath: keyPath] }
            nonmutating set { defaults[keyPath: keyPath] = newValue }
        }

        public var projectedValue: Binding<T> {
            Binding(
                get: { defaults[keyPath: keyPath] },
                set: { value in
                    defaults[keyPath: keyPath] = value
                }
            )
        }
    }

现在我们可以在视图中采用如下代码来逐个声明注入了：

    @Default(\.name) var name
    Text(name)
    TextField("name",text:$name)

逐个注入且无需标注 `wrappedValue` 和 `projectedValue` 。由于使用 `keyPath`
，避免了可能出现的字符串拼写错误问题。

鱼和熊掌不可兼得，上述的方法还是不十分完美——会出现过度依赖的情况。即使你只在视图中注入了一个 UserDefaults 键值（比如 `name`
），但当 `Defaults` 中其他未注入的键值内容发生变动时（ `age` 发生变化），依赖 `name` 的视图也同样会被刷新。

不过由于通常情况下配置数据的变化频率很低，所以并不会对 App 造成什么性能负担。

## 总结

本文提出了几个在不采用第三方库的情况下，解决 @AppStorage 痛点的方案。为了保证视图的刷新机制，分别采用的不同的实现方式。

SwiftUI 中即使一个不起眼的环节也有不少乐趣值的我们探索。

# 健康笔记 2.0 开发随笔（二）

本周的由于其他琐事的原因，每天能够用于开发的时间基本上只能保证 2-3 个小时，所以进展不大。不过好在我也没有明确的进度指标。

由于 2.0 在功能上同 1.0 的区别并不太大，所以在功能需求设计上不需要花费太多的时间。这半年来我自己也基本总结了一个自己用起来比较顺手的 MVVM
框架所以在最开始的 1 周，并不用太费力变完成了一个最简陋 ui 的原型版。

尽管叫原型版，但数据流、数据库操作等待基础代码都是要用于正式版中的。

在上周，苹果发布了 Xcode 12 的 beta 5, 其中提供了在 SwiftUI lifecycle 下的 CoreData
模版。所用的思路和我现在差不多。都是使用 static 来保证上下文的唯一性。另外苹果也提供了一个用于 preview 的思路，创建了一个 in-
memory 的 Sqllite. 这个也和我现在的途径差距不大，我现在是直接通过生成 Sample NSManageObject 给 Preview
来实现的。反正都是可以在 preview 中比较好的支持 CoreData 数据。

preview 在 Xcode 12 中得到了很大的加强，崩溃的机率明显下降很多。我目前几乎所有的 View 都可以完美的 preview 出来。

本次升级我对于 app 的 UI 的还是有点企图心的，最初也希望能够制作成一个比较有风格的 app.
不过在仔细权衡过后，还是放弃了。放弃的理由也十分简单，对于个人开发者或者小型团队开发者，如果没有好的审美判断力、美工执行力、交互逻辑的设计能力，一个貌似具有个人风格的设计很可能会以惨败告终。

最终还是决定以 iOS 的原生 UIKit
基础上来进行设计。不过即使苹果的原生控件已经比较有美感，不过想要好的色彩搭配、合适的布局、顺畅的交互仍然不是一件容易的事情。

专业的事情还是要找专业的解决方案。最终，我在 gumroad. com 上找到了一个自己比较喜欢的控件设计包 [ **Figma iOS UI kit**
](https://gumroad.com/l/iostoolkit) , 以 99 美金买了下来。

这个包的比较适合开发 iOS 原生的 app. 由于它同时提供了 light 和 dark 两个模式下的对应 Demo, 所以指导性还是很强的。

在研究这个模版的设计文件过程中我才发现，一个看似简单的控件其实里面有着非常多的细节。我试图在 SwiftUI 中在保证性能的情况下，实现更多的细节。

这是我目前一部分 View 的设计稿

![截屏 2020-08-24 下午 3.53.25](https://cdn.fatbobman.com/healthnotes-develop-
memo-2-1.jpg)

![截屏 2020-08-24 下午 3.54.24](https://cdn.fatbobman.com/healthnotes-develop-
memo-2-2.jpg)

目前已经针对完成的这一小部分开始编写代码了。之所以在没有完全完成设计的情况下便开始写代码，主要的原因是为了检查我在代码上对设计的还原度，同时也看一下当前的设计在实际运行状况下是否合理，以便总结经验完成下一步的全面设计。

_figma 功能上同 Sketch 差不多，而且最低门槛还是免费的。不过它对于网络的外网连接状况要求比较高。_

在编写代码的时候，还是能够明显感觉到和设计之间的差别的，有些地方要做取舍，有些地方在实机上的显示又不尽如人意。只有不断的磨合才能增长经验。

![截屏 2020-08-24 下午 4.13.08](https://cdn.fatbobman.com/healthnotes-develop-
memo-2-3.jpg)

总体而言使用 Figma 或 Sketch 进行的设计在 SwiftUI 中的还原度还是很高的。开发难度也不大。

在本周开发过程中，出现了一个让我比较头疼的地方，不过最终还是解决了。

在 2.0 中，我打算使用类似 iOS 邮件程序的侧滑菜单进行交互，不过当数据量增大时，显示变得异常卡顿。最终发现了问题出在 List 中不正确的使用了
ForEach. 具体关于这部分的内容，我已经记录在了另一篇文章中 [ 聊一下 SwiftUI 中的 List 和 ForEach
](/zh/posts/swiftui-list-foreach/) .

# 探讨 SwiftUI 中的属性包装器：@FetchRequest、@SectionedFetchRequest、@Query、@Namespace、@Bindable

在本文中，我们将对 `@FetchRequest` 、 `@SectionedFetchRequest` 、 `@Query` 、 `@Namespace` 和 `@Bindable` 等属性包装器进行探讨。这些属性包装器涵盖了在视图中对 Core Data 和 SwiftData
数据进行检索以及在视图中创建命名空间等功能。

> 本文旨在提供对这些属性包装器的主要功能和使用注意事项的概述，而非详尽的使用指南。

- [ @State、@Binding、@StateObject、@ObservedObject、@EnvironmentObject、@Environment ](/zh/posts/exploring-key-property-wrappers-in-swiftui/)
- [ @AppStorage、@SceneStorage、@FocusState、@GestureState、@ScaledMetric ](/zh/posts/exploring-swiftui-property-wrappers-2/)
- [ @UIApplicationDelegateAdaptor, @AccessibilityFocusState, @FocusedObject, @FocusedValue, @FocusedBinding ](/zh/posts/exploring-swiftui-property-wrappers-4/)

## 1\. @FetchRequest

在 SwiftUI 中， `@FetchRequest` 用于在视图中检索 Core Data
的实体数据。它可以简化从持久化存储中检索数据的过程，并在数据发生变化时自动更新视图。

### 1.1 基本用法

    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
        predicate: nil,
        animation: .default)
    private var items: FetchedResults<Item>

    List {
        ForEach(items) { item in
            if let timestamp = item.timestamp {
                NavigationLink {
                    Text("Item at \(timestamp, format: .dateTime)")
                } label: {
                    Text(timestamp, format: .dateTime)
                }
            }
        }
    }

### 1.2 主要功能

- `@FetchRequest` 使得从 Core Data 中检索数据变得简单直接。开发者可以定义实体类型、排序描述符和谓词来过滤结果。
- 在 Core Data 中的数据发生任何变动时， `@FetchRequest` 能够自动更新其检索结果，确保视图与数据间的实时同步。
- 与 SwiftUI 的声明式编程模型紧密结合， `@FetchRequest` 提供了一种更为自然和流畅的方式，用于将数据驱动的界面融入应用中。

### 1.3 注意事项与使用技巧

- 在使用 `@FetchRequest` 前，确保当前视图环境中已注入了托管对象上下文。
- 下面的示例展示了如何在构造器中根据特定参数设置过滤和排序条件：

  @FetchRequest
  private var items: FetchedResults<Item>
  init(startDate:Date,endDate:Date) {
  let predicate = NSPredicate(format: "timestamp >= %@ AND timestamp <= %@", startDate as CVarArg,endDate as CVarArg)
  \_items = FetchRequest(
  entity: Item.entity(),
  sortDescriptors: [.init(key: #keyPath(Item.timestamp), ascending: true)],
  predicate: predicate
  )
  }

- 从 iOS 15 起，开发者可在视图中动态调整 `@FetchRequest` 的过滤和排序条件。但需注意，在 `.onAppear` 和 `.task` 中，此方法不适用。它通常用于根据用户操作动态更新视图。

  Button("abc") {
  $items.nsPredicate.wrappedValue = .init(value: false)
  $items.sortDescriptors.wrappedValue = [.init(\Item.timestamp, order: .reverse)]
  }

- 若要进行更复杂的配置，推荐使用 NSFetchRequest 实例创建 `@FetchRequest` ：

  extension Item {
  static let noFaultRequest: NSFetchRequest = {
  let request = NSFetchRequest<Item>(entityName: "Item")
  request.predicate = nil
  request.sortDescriptors = [.init(keyPath: \Item.timestamp, ascending: true)]
  request.returnsObjectsAsFaults = false
  return request
  }()
  }

  @FetchRequest(fetchRequest: Item.noFaultRequest)
  private var items: FetchedResults<Item>

- `@FetchRequest` 中的 `animation` 参数决定了数据变化时界面更新的动画效果。 `.none` 和 `nil` 均表示无动画。
- 使用 List 展示数据时，List 会忽略 `@FetchRequest` 设置的动画效果，而使用组件默认动画。
- 开发者可以用 `withAnimation` 函数覆盖 `@FetchRequest` 中设定的动画效果，如下所示：

  withAnimation(.none) {
  let newItem = Item(context: viewContext)
  newItem.timestamp = Date()

      do {
          try viewContext.save()
      } catch {
      }

  }

- `@FetchRequest` 是 SwiftUI 对 NSFetchedResultsController 的封装，其主要功能和性能与后者基本一致。
- 与 NSFetchedResultsController 相同， `@FetchRequest` 仅支持返回 NSManagedObject 类型的集合，不支持其他 NSFetchRequestResult 类型（如数字、NSManagedObjectID、字典）。
- `@FetchRequest` 的生命周期与视图的存续期紧密相关。它在视图加载到视图树时开始检索数据，并在视图移除时停止。
- 相比在 ViewModel 中获取 Core Data 实体数据， `@FetchRequest` 更紧密地与视图的生命周期绑定，几乎无首次加载延迟。
- 在首次获取数据后， `@FetchRequest` （NSFetchedResultsController）会根据托管对象上下文的合并信息更新数据集。因此，基于 `fetchLimit` 的设置无法保证在后续数据变化时始终有效。
- 关于 `@FetchRequest` 的工作原理，详见 [ SwiftUI 与 Core Data —— 数据获取 ](/zh/posts/modern-core-data-fetcher/) 。
- FetchedResults 是 NSFetchRequestResult 的封装，遵循 RandomAccessCollection 协议，允许通过下标方式访问数据。
- FetchedResults 提供了一个 `publisher` 属性，一旦结果集数据发生变化，该 Publisher 会发送整个数据集。因此，不建议订阅此属性以监控数据集变化，以避免冗余操作。
- 在 SwiftUI 开发中，推荐将展示 `to-Many` 数据的界面单独封装成独立的视图，并通过 `@FetchRequest` 来获取数据。这种做法不仅确保了数据获取顺序的稳定性，还能及时响应数据变化，并使视图更新更加高效。详情请参阅 [ 掌握 Core Data 中的关系：实战 ](/zh/posts/mastering-relationships-in-core-data-practical/) 。

## 2\. @SectionedFetchRequest

在 SwiftUI 中， `@SectionedFetchRequest` 属性包装器提供了一种便捷的方式来处理并展示按照特定标准分组的 Core
Data 查询结果。这使得开发者能够在界面上以分组形式展示复杂的数据结构。

### 2.1 基本用法

以下是一个 `@SectionedFetchRequest` 的基本使用示例：

![image-20240122162612483](https://cdn.fatbobman.com/image-20240122162612483.png)

    @SectionedFetchRequest(
        entity: Item.entity(),
        sectionIdentifier: \Item.categoryID,
        sortDescriptors: [
            .init(keyPath: \Item.categoryID, ascending: true),
            .init(keyPath: \Item.timestamp, ascending: true),
        ]
    )
    var sectionItems: SectionedFetchResults<Int16, Item>

    ForEach(sectionItems) { section in
        Section(header: Text("\(section.id)")) {
            ForEach(section) { item in
                Row(item: item)
            }
        }
    }

这段代码演示了如何根据 `Item` 实体的 `categoryID` 属性创建一个分组的 `SectionedFetchRequest`
，并根据预设的规则进行排序。

`SectionedFetchResults` 是一个包含两个泛型参数的结构体。第一个参数定义了用作分组标识（section
identifier）的属性类型，而第二个参数指定了托管对象的实体类型

### 2.2 主要功能

- `@SectionedFetchRequest` 允许开发者按照特定属性将查询结果分组，从而在 SwiftUI 视图中以分组形式展示。

- 除了支持分组外，其他特征与 `@FetchRequest` 基本一致。

### 2.3 注意事项与使用技巧

- 大部分适用于 `@FetchRequest` 的注意事项和技巧同样适用于 `@SectionedFetchRequest` 。
- 使用 `@SectionedFetchRequest` 时，必须指定一个用于分组的属性，该属性类型应能被清晰地用于分区，如 String 或 Int 类型。
- 为确保分组的准确顺序，构建 `sortDescriptors` 时，应将用于 `sectionIdentifier` 的属性作为第一排序选项：

  sortDescriptors: [
  .init(keyPath: \Item.categoryID, ascending: true),
  .init(keyPath: \Item.timestamp, ascending: true),
  ]

- 对于难以进行精确分组的属性类型，建议为实体创建一个专门的属性以便分类。例如，可以为 `timestamp` 增加一个 Int16 类型的 `year` 属性，以便按年份进行分组。
- 在 SwiftUI 中，嵌套的 `ForEach` 可能会影响惰性容器的性能优化。通过添加 `Section` ，可以避免 `ForEach` 的递归展开，提高性能。具体细节可参考 [ Demystify SwiftUI performance ](https://developer.apple.com/videos/play/wwdc2023/10160/) 。例如，在以下代码中，如果去除 `Section` ，SwiftUI 将一次性为结果集中的每个数据项构建子视图：

  ForEach(sectionItems) { section in
  // Section(header: Text("\(section.id)")) {
  ForEach(section) { item in
  Row(item: item)
  }
  // }
  }

## 3\. @Query

在 SwiftUI 中， `@Query` 用于在视图中检索 SwiftData
的实体数据。它可以简化从持久化存储中检索数据的过程，并在数据发生变化时自动更新视图。

### 3.1 基本用法

    @Query(sort: \Item.timestamp, animation: .default)
    private var items: [Item]

### 3.2 注意事项与使用技巧

- `@Query` 可以被视为 SwiftData 环境中 `@FetchRequest` 的对应版本。然而，与 `@FetchRequest` 不同的是， `@Query` 不支持在视图内动态修改查询的谓词和排序条件。
- `@FetchRequest` 与 `@Query` 之间的对比如下：
  - Core Data 的 NSFetchRequest 对应于 SwiftData 的 [ FetchDescriptor ](https://developer.apple.com/documentation/swiftdata/fetchdescriptor) 。
  - NSSortDescriptor 对应于 [ SortDescriptor ](https://developer.apple.com/documentation/foundation/sortdescriptor) （后者也可用于 `@FetchRequest` ）。
  - NSPredicate 对应于 Foundation 的 [ Predicate ](https://developer.apple.com/documentation/foundation/predicate) 。
  - 参数方面， `@FetchRequest` 的 predicate 对应于 `@Query` 的 filter。
- 在 `@Predicate` 宏中，不可以直接调用外部方法、函数或计算属性。应先在宏外计算好数值，再作为谓词条件在宏中使用：

  // 示例一：错误方式
  @Query
  private var items: [Item]

  init() {
  let predicate = #Predicate<Item>{
  $0.timestamp < Date.now // 无法编译
  }
  \_items = Query(
  filter: predicate,
  sort:\Item.timestamp,
  order: .forward,
  animation: .default
  )
  }

  // 示例一：正确方式
  let now = Date.now
  let predicate = #Predicate<Item>{
  $0.timestamp < now
  }

  // 示例二：错误方式
  init(item: Item) {
  let predicate = #Predicate<Item>{
  $0.timestamp < item.timestamp // 无法编译
  }
  \_items = Query(
  filter: predicate,
  sort:\Item.timestamp,
  order: .forward,
  animation: .default
  )
  }

  // 示例二：正确方式
  init(item: Item) {
  let startDate = item.timestamp
  let predicate = #Predicate<Item>{
  $0.timestamp < startDate
  }
  }

- SwiftData 并未提供类似于 NSFetchedResultsController 的功能，用于在视图外部进行数据检索并根据数据变化自动更新数据集。对于这种需求，可以考虑使用 Persistent History Tracking。更多详情请参考 [ 如何通过 Persistent History Tracking 观察 SwiftData 的数据变化 ](/zh/posts/persistent-history-tracking-in-swiftdata/) 。

> 在上文中介绍的三个属性包装器都是在 SQLite 端执行数据的筛选、排序和分组操作，这种做法在效率和系统资源占用方面都优于在内存中使用 Swift
> 的高阶函数进行相同操作。

## 4\. @Namespace

`@Namespace` 属性包装器用于创建一个唯一标识符，使得我们可以对视图或元素进行有效的分组和区分。

### 4.1 基本用法

    @Namespace private var namespace

### 4.2 主要功能

- 每个 `@Namespace` 属性包装器都将创建一个唯一标识符，该标识符在创建后在其生命周期中保持不变。
- `@Namespace` 通常会结合其他的 `id` 信息共同为视图进行标注。这种方式可以在不改变 `id` 的情况下，为视图增加更多的可识别信息。

### 4.3 注意事项与使用技巧

- 创建了 `@Namespace` 标识符之后，你可以将其传递到其他视图中使用：

  struct ParentView: View {
  @Namespace var namespace
  let id = "1"
  var body: some View {
  VStack {
  Rectangle().frame(width: 200, height: 200)
  .matchedGeometryEffect(id: id, in: namespace)
  SubView3(namespace: namespace, id: id)
  }
  }
  }

  struct SubView: View {
  let namespace: Namespace.ID
  let id: String
  var body: some View {
  Rectangle()
  .matchedGeometryEffect(id: id, in: namespace, properties: .size, isSource: false)
  }
  }

- 虽然开发者在多数情况下会将 `@Namespace` 与 `matchedGeometryEffect` 结合使用，但重要的是要理解 `@Namespace` 本身仅扮演着标识符的角色，并不直接参与几何信息处理或动画过渡的具体实现。
- `@Namespace` 不仅限于与 `matchedGeometryEffect` 搭配使用，还可以用于其他元素或视图修饰器，如 `accessibilityRotorEntry` 、 `AccessibilityRotorEntry` 、 `accessibilityLinkedGroup` 、 `prefersDefaultFocus` 和 `defaultFocus` 。
- 在使用 `@Namespace` 的场景中，通常会出现标注视图和读取视图信息的操作成对出现的模式：

  // 示例一：
  Rectangle().frame(width: 200, height: 200)
  .matchedGeometryEffect(id: id, in: namespace) // 标注视图
  Rectangle()
  .matchedGeometryEffect(id: id, in: namespace, properties: .size, isSource: false) // 读取带有特定 namespace + id 的视图的几何信息

  // 示例二：
  VStack {
  TextField("email", text: $email)
  .prefersDefaultFocus(true, in: namespace) // 标注视图，该视图为 namespace 中默认获得焦点的视图

      SecureField("password", text: $password)

      Button("login") {
        ...
      }

  }
  .focusScope(namespace) // 读取 namespace 命名空间中具备默认焦点的视图信息，并将焦点设置与其上

- 允许为同一视图应用多个不同的 `namespace + id` 组合。例如，在下面的代码中，我们使用了相同的 `id` 但不同的 `namespace` ，为同一个 `TrendView` 添加了标注。这样做为两个不同的可访问性转子（Rotor）提供了独立的标识：

  struct TrendsView: View {
  let trends: [Trend]

      @Namespace private var customRotorNamespace
      @Namespace private var countSpace

      var body: some View {
          VStack {
              ScrollViewReader { scrollView in
                  List {
                      ForEach(trends, id: \.id) { trend in
                          TrendView(trend: trend)
                              .accessibilityRotorEntry(id: trend.id, in: customRotorNamespace) // 标识1
                              .accessibilityRotorEntry(id: trend.id, in: countSpace) // 标识2
                              .id(trend.id)
                      }
                  }
                  .accessibilityRotor("Negative trends") {
                      ForEach(trends, id: \.id) { trend in
                          if !trend.isPositive {
                              AccessibilityRotorEntry(trend.message, trend.id, in: customRotorNamespace) {
                                  scrollView.scrollTo(trend.id)
                              }
                          }
                      }
                  }
                  .accessibilityRotor("Count"){
                      ForEach(trends,id:\.id){ trend in
                          if trend.count % 2 == 0 {
                              AccessibilityRotorEntry("\(trend.count)", trend.id, in: countSpace) {
                                  scrollView.scrollTo(trend.id)
                              }
                          }
                      }
                  }
              }
          }

      }

  }

> 有关 `AccessibilityRotorEntry` 的更多信息，请参阅 [ Accessibility rotors in SwiftUI
> ](https://swiftwithmajid.com/2021/09/14/accessibility-rotors-in-swiftui/) 。

- 当使用 `ForEach` 时，我们通常会使用 `ForEach` 提供的标识符作为 `id` ，并通过结合不同的 `namespace` 为相同的视图或元素提供多种不同的标识。例如上面的代码。

- 在任何给定时间，应该只存在一个唯一的 `namespace + id` 组合。例如，在下面的代码中，如果运行，将会产生一个警告，因为存在多个使用相同 `namespace + id` 组合的视图：

  struct AView:View {
  @Namespace var namespace
  var body: some View {
  VStack {
  Rectangle()
  .matchedGeometryEffect(id: "111", in: namespace)
  Rectangle()
  .matchedGeometryEffect(id: "111", in: namespace)
  }
  }
  }

  // Multiple inserted views in matched geometry group Pair<String, ID>(first: "111", second: SwiftUI.Namespace.ID(id: 88)) have `isSource: true`, results are undefined.

- 当与 `matchedGeometryEffect` 结合使用时，可以让多个视图共享同一个被标注视图的几何信息。在以下代码中，两个下方的 `Rectangle` 将与第一个 `Rectangle` 的位置重叠，因为它们共享了标记为 `namespace + "111"` 的视图的位置信息：

  struct AView:View {
  @Namespace var namespace
  var body: some View {
  VStack {
  Rectangle()
  .matchedGeometryEffect(id: "111", in: namespace)
  Rectangle().fill(.red)
  .matchedGeometryEffect(id: "111", in: namespace,properties: .position, isSource: false)
  Rectangle().fill(.blue)
  .matchedGeometryEffect(id: "111", in: namespace,properties: .position, isSource: false)
  }
  }
  }

- 在模态视图中使用 `matchedGeometryEffect` 时，若无法正确获取几何信息，这通常是由于 SwiftUI 的一个已知问题，而非 `@Namespace` 的问题。一个解决方案是将视图放入导航容器内。这样做可以确保在模态视图（如 sheet 或 fullscreenCover）中正确获取几何信息。

  // 问题示例：无法获取几何信息
  struct NaviTest: View {
  @Namespace var namespace

      @State var show = false
      var body: some View {
          VStack {
              Button("Show") {
                  show.toggle()
              }
              .sheet(isPresented: $show) {
                  VStack {
                      Rectangle()
                          .fill(.cyan)
                          .matchedGeometryEffect(id: "1", in: namespace, properties: .size, isSource: false)
                  }
                  .frame(width: 300, height: 300)
              }
              Rectangle().fill(.orange).frame(width: 100, height: 200).matchedGeometryEffect(id: "1", in: namespace)
          }
      }

  }

  // 解决方案：在导航容器内可以正确获取几何信息
  NavigationStack {
  VStack {
  Button("Show") {
  show.toggle()
  }
  .sheet(isPresented: $show) {
  VStack {
  Rectangle()
  .fill(.cyan)
  .matchedGeometryEffect(id: "1", in: namespace, properties: .size, isSource: false)
  }
  .frame(width: 300, height: 300)
  }
  Rectangle().fill(.orange).frame(width: 100, height: 200).matchedGeometryEffect(id: "1", in: namespace)
  }
  }

> 想了解更多关于 `matchedGeometryEffect` 的细节，请参考 [ MatchedGeometryEffect – Part 1
> (Hero Animations) ](https://swiftui-lab.com/matchedgeometryeffect-part1/) 。

## 5\. @Bindable

`@Bindable` 属性包装器为创建可观察（Observable）对象实例的可变属性绑定（Binding）提供了一种便捷且高效的方式。

### 5.1 基本用法

    @Observable
    class People {
        var name: String
        var age: Int
        init(name: String, age: Int) {
            self.name = name
            self.age = age
        }
    }

    struct PeopleView: View {
        @State var people = People(name: "fat", age: 18)
        var body: some View {
            VStack {
                Text("\(people.name) \(people.age)")
                PeopleName(people: people)
                PeopleAge(people: people)
            }
        }
    }

    struct PeopleName: View {
        @Bindable var people: People // 用法一
        var body: some View {
            TextField("Name", text: $people.name)
        }
    }

    struct PeopleAge: View {
        let people: People
        var body: some View {
            @Bindable var people = people // 用法二
            TextField("Age:", value: $people.age, format: .number)
        }
    }

### 5.2 注意事项与使用技巧

- `@Bindable` 专门用于符合 `Observation.Observable` 协议的类型，适用于那些通过 `@Observable` 宏或 `@Model` 宏声明的类型。
- 目前，在将 `@Bindable` 应用于 SwiftData 的 PersistentModel 实例时需特别小心。特别是当 `autoSave` 功能被激活时，它可能会导致稳定性问题。预计在未来的更新中，这一问题能得到解决和改进。

## 总结

至此，我们已经介绍了 SwiftUI 中的 16 种不同属性包装器。之后还将用一篇文章对剩下的属性包装器的功能进行探讨，敬请期待。

# SwiftData 中的关系：变化与注意事项

在之前的两篇文章 [ 掌握 Core Data 中的关系：基础 ](/zh/posts/mastering-relationships-in-core-
data-fundamentals/) 和 [ 掌握 Core Data 中的关系：实战 ](/zh/posts/mastering-
relationships-in-core-data-practical/) 中，我们详细探讨了 Core Data
中关系的概念和技巧。虽然这些知识在很大程度上同样适用于 Core Data 的继任者 SwiftData，但 SwiftData
在关系处理上也引入了一些显著的变化。本文将重点介绍 SwiftData 在关系方面发生的变化，以及由此带来的潜在挑战和值得注意的细节。

## 从“由里至表”到“由表及里”的变革

在 SwiftData 的众多创新中，最引人注目的莫过于允许开发者通过纯代码直接声明数据模型。在 Core Data 中，开发者需要先在 Xcode
的数据模型编辑器里创建数据模型（对应 NSManagedObjectModel），然后才是编写或自动生成 NSManagedObject 子类代码。

这一过程本质上是从模型（“里”）到类型代码（“表”）的转换。开发者能在一定程度上调整类型代码，例如将 `Optional` 改为 `Non-
Optional` 或将 `NSSet` 改为 `Set` ，从而优化开发体验，只要这些修改不影响 Core Data 在代码与模型之间的映射。

SwiftData 的纯代码声明方式彻底改变了这一流程。在 SwiftData 中，类型代码和数据模型的声明是同步进行的，或者更准确地说，SwiftData
会根据开发者声明的类型代码自动生成相应的数据模型。声明方式由传统的“由里至表”转变为了“由表及里”。

这种变化在大多数情况下都是正面的，但对于某些具体应用场景，开发者需要调整他们之前的开发习惯和技巧。例如，在之前的文章 [ 《掌握 Core Data
中的关系：实战》 ](/zh/posts/mastering-relationships-in-core-data-practical/)
中提到的将数据模型声明为 `Optional` 的关系对应的代码修改为 `Non-Optional` 的技巧，在 SwiftData
中将不再适用。模型将严格遵循类型代码的声明创建：

    @Model
    final class Item {
        var timestamp: Date = Date.now
        var tag: Tag?
        init(timestamp: Date) {
            self.timestamp = timestamp
        }
    }

    @Model class Tag {
        var name: String
        var items: [Item] = []
        init(name: String) {
            self.name = name
        }
    }

在这段代码中， `var tag: Tag?` 表明 `tag` 关系是可选的。如果我们去掉 `?` ，那么在对应的数据模型中， `tag`
关系将变为非可选。同样， `var items: [Item] = []` 指出 `items` 关系是非可选的。

## 关系可以设置默认值的误区

在 Core Data 中，与其他类型的属性不同，开发者无法为关系设置默认值。这一限制在 SwiftData 中同样适用。然而，SwiftData
当前的声明方式可能会误导开发者认为可以为关系设置默认值。以以下代码为例：

    @Model
    final class Item {
        var timestamp: Date = .now
        var tag: Tag = Tag(name: "hello")
        init(timestamp: Date) {
            self.timestamp = timestamp
        }
    }

    @Model class Tag {
        var name: String
        var items: [Item] = []
        init(name: String) {
            self.name = name
        }
    }

乍一看， `var tag: Tag = Tag(name: "hello")` 和 `var items: [Item] = []`
似乎都在为关系设置默认值。但实际上并非如此。

首先，尽管 `var tag: Tag = Tag(name: "hello")`
这段代码可以编译通过，但它会在运行时产生错误，错误提示为：“Failed to find any currently loaded container
for Tag”。至于 `var items: [Item] = []` ，虽然不会报错，但这并不代表它在为 `items` 设置了有效的默认值。

在之前的文章 [ 《揭秘 SwiftData 的数据建模原理》 ](/zh/posts/unveiling-the-data-modeling-
principles-of-swiftdata/) 中，我们详细探讨了 SwiftData
是如何根据声明的代码创建数据模型的。无论是通过字面量赋值，还是通过构造方法赋值，这些操作都只是在创建了托管对象实例之后进行的。也就是说，在创建托管对象的过程中，并不会生成“预期”的默认值（关系对象）。

## 在构造方法中创建关系数据

在过去几个月中，我接触了许多使用 SwiftData 框架编写代码的开发者。其中，特别是那些没有 Core Data
开发经验的开发者，他们常常采用类似于以下的实现方式：

    @Model
    final class Item {
        var timestamp: Date
        var tag: Tag?
        init(timestamp: Date, name: String) {
            self.timestamp = timestamp
            tag = Tag(name: name)
        }
    }

    @Model class Tag {
        var name: String
        var item: Item?
        init(name: String) {
            self.name = name
        }
    }

从这种普遍的实践方式可以看出，SwiftData 在改变数据模型定义模式上取得了显著的成功。由于 `@Model`
宏要求必须定义构造方法，开发者往往会按照标准的 Swift
类型定义的模式，在一个实体的构造方法中直接生成另一个实体的数据。这种方法不仅简洁、直观，而且在构造方法中创建的实体数据也无需额外地插入到 `ModelContext` 中：

    let newItem = Item(timestamp: Date(),name: "hello")
    modelContext.insert(newItem)

这一实践反映了 SwiftData 对传统数据模型定义方式的重大简化和改进。它使得关系数据的创建更符合 Swift
语言的本质风格，同时也降低了开发者的学习曲线，尤其是对于那些初次接触数据持久化框架的开发者而言。

> 在构造方法中创建的关系数据同样不属于默认值。

## SwiftData 中的逆向关系设置及其困惑

在之前的文章 [ 《掌握 Core Data 中的关系：基础》 ](/zh/posts/mastering-relationships-in-core-
data-fundamentals/) 中，我们讨论了逆向关系的重要性。在 Core Data 中，开发者需要在 Xcode
的模型编辑器中显式地为双向关系设置逆向关系，并且若未设置，Xcode 会发出警告。而在 SwiftData
中，逆向关系的设置规则并不那么明确。在某些情况下，即使开发者未使用 `@Relationship(inverse:)` 设置逆向关系，SwiftData
也可能自动为模型添加。

通过我的实验，我发现 SwiftData 对逆向关系的处理规则如下：

- **One-to-One（一对一）** ：当两端都是 `Optional` 时，SwiftData 会自动添加逆向关系。例如：

  @Model
  final class Item {
  var timestamp: Date
  var tag: Tag? // Optional
  init(timestamp: Date) {
  self.timestamp = timestamp
  }
  }

  @Model class Tag {
  var name:String
  var item: Item？// Optional
  init(name: String) {
  self.name = name
  }
  }

- **One-to-One（一对一）** ：若一端不为 `Optional` ，则需要开发者明确设置逆向关系（在任一侧设置即可）。例如：

  @Model
  final class Item {
  var timestamp: Date
  @Relationship(inverse:\Tag.item)
  var tag: Tag?
  init(timestamp: Date, name: String) {
  self.timestamp = timestamp
  }
  }

  @Model class Tag {
  var name: String
  var item: Item
  init(name: String,item:Item) {
  self.name = name
  self.item = item
  }
  }

- **One-to-Many（一对多）** ：两端都是 `Optional` 时 SwiftData 会自动设置逆向关系；一端不为 `Optional` 时，需要开发者明确设置逆向关系
- **Many-to-Many（多对多）** ：两端都为或任意一段为 `Optional` 时，SwiftData 会自动设置；若两端均为 `Non-Optional` ，则需要开发者明确设置。

总的来说，除了 `Many-to-Many` 情况外，在 `One-to-One` 和 `One-to-Many` 关系中，只要任意一端不为 `Optional` ，就需要显式设置逆向关系。

虽然这些规则不算过于复杂，但为了避免潜在的问题，建议开发者在声明模型时始终明确设置逆关系。

## 丢失的 Core Data with CloudKit 兼容性自动检查

当我们需要在应用中为 Core Data 开启云存储功能（即 Core Data with CloudKit）时，在创建数据模型阶段，就必须根据 Core
Data with CloudKit 的要求对模型进行一些特定的调整。例如，必须设置逆向关系、不能使用 `Deny` 删除规则等。

在 Core Data 的环境下，即使没有为项目启用 iCloudKit 功能，只要在 Xcode 的 Configuration 中勾选 `Used
with CloudKit` 选项，Xcode 就会自动检查当前数据模型是否符合 Core Data with CloudKit
的标准，并相应地给出提示。

然而，在 SwiftData 中，开发者首先需要为项目启用 CloudKit 功能并指定 CloudKit 容器。只有在运行应用后，如果模型不符合 Core
Data with CloudKit 的规范，才会收到模型错误的通知。

因此，对于那些已经启用或计划未来启用 Core Data with CloudKit 功能的开发者来说，应尽早在项目中设置相应的 CloudKit
选项。这样做可以避免因为模型不规范而导致未来需要进行大规模的代码更新。

> 关于 Core Data with CloudKit 对模型的具体要求，可参阅文章 [ 《Core Data with
> CloudKit：同步本地数据库到 iCloud 私有数据库》 ](/zh/posts/coredatawithcloudkit-2/) 。

## Array 创新还是陷阱

### 使用 Array 表示无序对多关系，字面意义存疑

SwiftData 在处理多对多关系时的一大变革是要求开发者直接使用数组（Array）来声明关系。与 Core Data 不同的是， `@Model`
宏不会为对多数据操作创建独立的方法，而是允许开发者直接对数组进行操作：

    @Model
    final class Item {
        var timestamp: Date
        var tags: [Tag] = []
        init(timestamp: Date, name: String) {
            self.timestamp = timestamp
        }
    }

    item.tags.append(tag)

对于这种变化，许多开发者的反馈是积极的。他们认为这大大提升了代码的字面清晰度，使模型声明和数据操作更加符合 Swift 语言的特性。

开发团队可能认为统一使用 Array 声明有序或无序的对多关系会降低 SwiftData 的学习门槛，因此没有采用 Set
来声明无序的多对关系。我个人对使用 Array 表示无序的对多关系持有保留意见，因为 Array
使代码失去了对数据元素唯一性和无特定顺序性的直观表达。因此，对开发者（尤其是初学者）来说，必须明确无序对多关系返回的顺序是不保证的（即使使用了
Array）。开发者应考虑采用在 “实战” 一文中介绍的更可控的对多关系数据获取方式。

### 通过数组操作多对关系数据的效率问题

在 Core Data 中，对于对多关系，Xcode 会自动生成一些专门的操作方法，例如 `addToTags(_ value: Tag)` 和 `removeFromTags(_ value: Tag)`
等。与使用多个特定方法相比，从形式上讲，直接使用熟悉的数组方法来操作多对关系数据似乎是一种进步。然而，在 SwiftData
的首个版本中，这种实现方式在某些场景下可能会导致严重的性能问题。

考虑以下代码示例：

    @Model
    final class Item {
        var timestamp: Int
        @Relationship(deleteRule: .cascade,inverse: \Tag.item)
        var tags:Array<Tag> = []

        init(timestamp: Int) {
            self.timestamp = timestamp
        }
    }

    @Model
    final class Tag {
        var name:String
        var item:Item?

        init(name: String) {
            self.name = name
        }
    }

    // Create One Item and One Hunderd Tags
    measure {
        let item = Item(timestamp: 100)
        context.insert(item)
        for i in 0..<100 {
            let tag = Tag(name: "\(i)")
            item.tags.append(tag)
        }
        try? context.save()
    }

在这个例子中， `Item` 和 `Tag` 之间是一对多关系。我们创建了一个 `Item` 实例和 100 个 `Tag` 实例，并通过
`item.tags.append(tag)` 建立关联。

与之对应的 Core Data 代码在执行相同操作时的平均耗时为 **0.003 秒** ，而上述 SwiftData 的代码平均耗时为 **0.106
秒** 。

虽然可以理解 SwiftData 作为封装层会有一些性能损耗，但超过 30 倍的时间差异仍然令人震惊。更为惊人的是，将循环增加到 1000 和 10000
时，时间差异更为显著：

将循环调整至 1000，700 多倍多时间差:

- 当循环次数为 1000：
  - Core Data: **0.012 秒**
  - SwiftData: **9.080 秒**
- 当循环次数为 10000：
  - Core Data: **0.082 秒**
  - SwiftData: 抱歉，我实在是没有耐心等下去了

这种显著的性能差异表明，尽管 SwiftData 在表面上简化了多对关系的操作，但在处理大量数据时，其效率远不及 Core Data。

### 问题的根源在哪里？

通过探究 SwiftData 与 Core Data 在添加多对关系数据时的差异，我们可以找出潜在的性能问题原因。

两者最显著的区别在于创建关系的方法：SwiftData 使用 `item.tags.append(tag)` ，而 Core Data 使用 `item.addToTags(tag)` 。在 Core Data 中，通过使用专门生成的 `item.addToTags`
方法，框架可以直接识别即将被添加的关系对象。相反，SwiftData 采用标准数组操作，这意味着在执行 `append`
操作后，必须比较新的值（追加后的 `item.tags` ）和旧的值（追加前的 `item.tags`
）来确定新增的对象。结果是，随着数组中数据量的增加，性能会出现指数级劣化。

为验证这一假设，我检查了 SwiftData 的接口文件，发现开发团队仅为 Array 类型增加了以下扩展：

    public protocol RelationshipCollection {
      associatedtype PersistentElement : SwiftData.PersistentModel
    }

    extension Swift.Array : SwiftData.RelationshipCollection where Element : SwiftData.PersistentModel {
      public typealias PersistentElement = Element
    }

这段代码仅表明需要使用数组来声明多对关系，并没有为数组操作（如 `append` ）定制特别的处理。

那么，如果从 `One` 端来创建关系，效率是否会有所提高呢？我们可以调整代码测试这一点：

    let context = sharedModelContainer.mainContext
    measure {
        let item = Item(timestamp:.now)
        context.insert(item)
        for i in 0..<1000 {
            let tag = Tag(name: "\(i)")
            tag.item = item
        }
        try? context.save()
        print(item.tags?.count ?? "null")
    }

在进行 1000 次循环后，SwiftData 的平均用时为 **4.350 秒** ，而 Core Data 仅为 **0.011 秒** 。虽然
SwiftData 的用时有所下降，但与 Core Data 相比仍有显著差距。

这表明，即使从“一”端创建关系，SwiftData 似乎仍然会自动处理“多”端的 Array 数据，从而造成性能损耗。

> 我还尝试了创建没有逆向关系的模型版本，发现运行时间几乎没有差异。这说明 SwiftData 在处理多对关系的 Array
> 数据时，并不受是否设置逆向关系的影响。

### 解决方案

面对 SwiftData 中多对关系数据操作的性能问题，一个可能的解决方案是减少对数组的操作次数，从而提高执行效率。

我们可以通过以下代码调整来尝试解决这一问题：

    let context = sharedModelContainer.mainContext
    measure {
        let item = Item(timestamp:.now)
        context.insert(item)
        var tags = [Tag]()
        for i in 0..<1000 {
            let tag = Tag(name: "\(i)")
            tags.append(tag)
        }
        item.tags?.append(contentsOf: tags)
        try? context.save()
        print(item.tags?.count ?? "null")
    }

在这种方法中，我们先将所有创建的 `Tag` 实例保存在一个临时数组中，然后一次性将这些 `Tag` 实例添加到 `item.tags` 中。

实验显示，在进行 1000 次循环操作后，SwiftData 的平均用时降低至 **0.069570 秒** ，相比之前有了显著提升，效率提高了约 130
倍。然而，与 Core Data 在相同操作下的平均用时 **0.012 秒** 相比，SwiftData 仍然存在一定的差距。

这个例子表明，在处理 `One-to-Many` 或 `Many-to-Many`
类型的关系时，应尽量减少对对多关系数组的操作次数，尽可能将多次操作合并为一次性完成。

至于 SwiftData 的性能问题是否能够最终得到解决，还取决于未来 SwiftData 版本是否会在这方面进行专门的优化。

> 你可以在 [ 此处
> ](https://github.com/fatbobman/BlogCodes/tree/main/ToManyPerformance)
> 获取所有的本文所有的测试代码

## 总结

在本文中，我们探讨了 SwiftData 在处理数据关系方面的变化，并分析了其中可能引起的性能问题。虽然 SwiftData 仍然基于 Core Data
的底层结构，但它已经展现出了自己独特的特性和新的使用方式。这些变化意味着，之前针对 Core Data 的一些技巧和实践，在 SwiftData
中可能需要进行适当的调整和重新考量。

SwiftData 为开发者提供了一种更加现代和直观的方式来处理数据关系，但这也伴随着新的挑战和学习需求。开发者需要不断适应 SwiftData
的特点，灵活运用新的策略和技术，以充分利用其提供的便利并改善性能。

# 一些适合 SwiftUI 初学者的教程

经常有朋友咨询，学习 SwiftUI
的最佳路径是什么？考虑到每个人的技术背景、学习能力、工作经验均不一样，因此很难说哪种学习方式或哪些资料是适合他本人的。不过随着这个问题被反复提起，最终还是想尝试整理一些资料给对
SwiftUI 感兴趣的朋友。本文将介绍一些对学习者技术基础要求较低（ 甚至可以零基础 ）的教程。

> 本文仅介绍我本人阅读并了解过的一些资料，并且仅介绍具备一定完整体系的教程。另请阅读 [ SwiftUI 专栏 #6 文件工具与网站
> ](https://www.ethanhuang13.com/p/swiftui-6-doc-tools?utm_source=email)
> 一文，了解如何查询与 SwiftUI 有关的 API

## Hacking with Swift

![image-20220919151336102](https://cdn.fatbobman.com/image-20220919151336102.png)

Paul Hudson 撰写了大量有关 Swift、SwiftUI 方面的书籍和教程。在他的网站 Hacking with Swift
中，提供了大量优秀的免费内容。 [ 100 Days of SwiftUI
](https://www.hackingwithswift.com/100/swiftui) 便是面向 SwiftUI 初学者的一个合集。

作者为学习者订立了两项规则：

- 每天花费一个小时阅读或观看该教程，并编写 SwiftUI 代码
- 每天将你的进度发布到社交媒体上，监督与自我监督

教程中还包含了 Swift 语言基础（ 1 - 15 天 ）方面的知识，为零基础的使用者创建了学习的可能。

教程中包含了视频、文档以及代码等内容，对于英语能力欠缺的学习者，浏览器自带的翻译工具已足够理解教程中的文档内容（ 文档国内有中文搬运
）。视频部分国内的网站已有搬运（ 有机翻字幕，也有 up 主提供了实用中文语音的重新讲解 ）。

## AppCoda

![swiftui-book-website-cover](https://cdn.fatbobman.com/swiftui-book-website-
cover.png)

《精通 SwiftUI 》是 AppCoda 出版的《 Mastering SwiftUI 》一书的中文版。本书的前四章可以 [ 免费阅读
](https://www.appcoda.com.tw/learnswift/) 。

该书是为没有任何程式经验、想要学习 SwiftUI 开发的初学者而撰写的。涉及的内容不少，但不要被书名中的“精通”所迷惑。

## Design Code

![image-20220919154335906](https://cdn.fatbobman.com/image-20220919154335906.png)

或许是因为 Meng To 的设计师背景，因此他开发的课程在视觉上十分精美。Meng To 会从设计师的角度出发调动每位学习者的学习欲望，学习他的 [
SwiftUI ](https://designcode.io/swiftui-handbook) 课程将获得很高的成就感。

Design Code 的教程并不完全适合零基础的使用者，学习者最好有一点（ 真的只需要一点
）技术背景。全部的课程都以视频的方式呈现，对于学习者的英文能力还是有一些的要求的（ 有中文搬运 ）。

## Big Mountain

![image-20220919155034753](https://cdn.fatbobman.com/image-20220919155034753.png)

Big Mountain 出版的电子书以卡片的形式进行教学。对于有一点基础的学习者来说，这种方式十分地直观。

网站上目前提供了一本 200 页的 [ 免费书籍 ](https://www.bigmountainstudio.com/free-swiftui-
book) 。

我个人很欣赏这种创作形式，目前我在 Twitter 上发布的 Tips 多少也受到了这种形式的影响。

## Raywenderlich

![image-20220919161227670](https://cdn.fatbobman.com/image-20220919161227670.png)

老牌的技术书籍出版公司，网站上提供了大量的课程（ 相当一部分是免费的 ）。

Raywenderlich 的 [ SwiftUI Apprentice
](https://www.raywenderlich.com/books/swiftui-apprentice/)
一书是针对初学者撰写的，全书的前三分之一部分可以免费阅读。

另外，Raywenderlich 的网站上有非常多针对 [ SwiftUI 的免费教程
](https://www.raywenderlich.com/library?q=swift+ui&domain_ids%5B%5D=1&subscription_types%5B%5D=free&subscription_types%5B%5D=beginner&difficulties%5B%5D=beginner)
，建议你从较旧的教程看起。

> Raywenderlich 与 Hacking with Swift 的免费教程仍附有完整的 Xcode 项目文档，这一点对于初学者特别友好

## Kodeco

> 2023 年 8 月更新

![image-20230818065923710](https://cdn.fatbobman.com/image-20230818065923710.png)

2022 年底，Raywenderlich 更名为 Kodeco。它在 2023 年 8 月，发布了免费的电子书 [ SwiftUI Cookbook
](https://www.kodeco.com/books/swiftui-cookbook) 。这本书较为系统的对 SwiftUI
进行了介绍，并提供了丰富的示例代码。

## 苹果官方教程

![image-20220919161650342](https://cdn.fatbobman.com/image-20220919161650342.png)

苹果对于 SwiftUI 的推广也算尽心尽力，它史无前例地为 SwiftUI 创建了一个十分 [ 精美的教程
](https://developer.apple.com/tutorials/swiftui#drawing-and-animation) （
创建该教程的技术最终演变为 [ DocC ](https://developer.apple.com/documentation/docc) ）。

该教程提供了保姆级的提示能力，可以为开发者展示开发过程中的每一个步骤。

比较遗憾的是，尽管该教程制作得十分精良，但调性过于高冷，代入感不强。

## 嘉夫和子然的工作室

![image-20220919162232057](https://cdn.fatbobman.com/image-20220919162232057.png)

在油管和 B 站上都有频道。他的视频教程 [ 使用 SwiftUI 开发 iOS App 新手教程
](https://www.bilibili.com/video/BV16L411H7xN) 是为初学者准备的，共 29
个视频。虽然每集只有几分钟，但教学的脉络十分清晰。

鉴于观看完整教程所需的时间不长，初学者可以在通览全部的视频对 SwiftUI 有个整体了解后，再决定下一步的学习方向和内容。

## ChaoCode

![image-20220919163439868](https://cdn.fatbobman.com/image-20220919163439868.png)

油管中文女 up 主 Jane 的视频教程（ [ Jane 的 B 站频道 ](https://space.bilibili.com/1911023449)
）。我个人最欣赏的是作者对于视频节奏的把握。

她的频道中有关于 SwiftUI 的视频，但在此我推荐的是她的 [ Swift 基础篇和中级篇系列
](https://www.youtube.com/watch?v=GIt1BJJNdTI&list=PLXM8k1EWy5kiAD0o69R00b7I62ZVUyfJJ)
。这个系列相对比较完整，对于初学者掌握 SwiftUI 也十分必要。

如果你选择学习 100 Days of SwiftUI 教程，建议在学习初期（ 1 - 15 天 ），可以搭配该系列教程一并观看。

> 更新：Jane 在 ChaoCode 上创建了新的系列课程 —— [ SwiftUI 新手入门课程
> ](https://www.bilibili.com/video/BV1TV4y1K7Ew/) ，想学习 SwiftUI 的朋友一定要赶快看看。

## Kavsoft

![image-20220919164639228](https://cdn.fatbobman.com/image-20220919164639228.png)

完全不适合初学者，但又对初学者有莫大作用的 [ 油管频道 ](https://www.youtube.com/c/Kavsoft/playlists) （
B 站有搬运 ）。

Kavsoft 制作的视频特点是全程无讲解 + 快放，有关交互效果方面的内容既有实用性又包含相当的炫技成分。

无论选择学习本文上面介绍的哪个教程，初学者都需要一段时间才能撰写具备一定功能的应用。在学习疲倦的时候，可以看看 Kavsoft
制作的视频放松一下心情，将其充作 “精神氮泵”。

## 总结

Paul Hudson 说，学习编程是一场马拉松，不是短跑。不要为了 “学得更快” 而冲在前面，因为你很有可能会迷失方向。慢慢来！

> 请用合适的行为感谢你所使用的教程的原作者

# Core Data with CloudKit （一） —— 基础

在 WWDC 2019 上，苹果为 `Core Data` 带了一项重大的更新——引入了 `NSPersistentCloudKitContainer` 。这意味着无需编写大量代码，使用 `Core Data with CloudKit` 可以让用户在他所有的苹果设备上无缝访问应用程序中的数据。

`Core Data` 为开发具有结构化数据的应用程序提供了强大的对象图管理功能。CloudKit 允许用户在登录其 iCloud
账户的每台设备上访问他们的数据，同时提供一个始终可用的备份服务。 `Core Data with CloudKit`
则结合了本地持久化+云备份和网络分发的优点。

2020 年、2021 年，苹果持续对 `Core Data with CloudKit`
进行了强化，在最初仅支持私有数据库同步的基础上，添加了公有数据库同步以及共享数据库同步的功能。

我将通过几篇博文介绍 `Core Data with CloudKit` 的用法、调试技巧、控制台设置并尝试更深入地研究其同步机制。

## Core Data with CloudKit 的局限性

- **只能运行在苹果的生态**

不同于其他的跨平台解决方案， `Core Data with CloudKit` 只能运行于苹果生态中，并且只能为苹果生态的用户提供服务。

- **测试门槛较高**

需要有一个 [ Apple Developer Program ](https://developer.apple.com/programs/)
账号才能在开发过程中访问 `CloudKit` 服务和开发团队的 `CKContainer` 。另外，在模拟器上的运行效果也远没有在真机上可靠。

## Core Data with CloudKit 的优点

- **几乎免费**

开发者基本上不需要为网络服务再额外支付费用。私有数据库保存在用户个人的 iCloud
空间中，公共数据库的容量会随着应用程序使用者的增加而自动提高，最高可增加到 1 PB 存储、10 TB 数据库存储，以及每天 200 TB
流量。之所以说几乎免费，毕竟苹果会扣取 15-30%的 app 收益。

- **安全**

一方面苹果通过沙盒容器、数据库区隔、加密字段、鉴权等多种技术手段保证了用户的数据安全。另一方面，鉴于苹果长期以来在用户中树立的隐私捍卫者的形象，使用 `Core Dat with CloudKit` 可以让用户对你的应用程序增加更多的信任。

事实上，正是在 WWDC 2019 年看到这个功能后，我才有了开发 [ 【健康笔记】 ](/healthnotes/)
的原动力——既保证数据隐私又能长久的保存数据。

- **集成度高、用户感知好**

鉴权、分发等都是无感的。用户不需要进行任何额外的登录便可享受全部的功能。

## Core Data

`Core Data` 诞生于 2005 年，它的前身 `EOF` 在 1994 年便已经获得的不少用户的认可。经过了多年的演进， `Core
Data` 已经发展的相当成熟。作为对象图和持久化框架，几乎每个教程都会告诉你，不要把它当作数据库，也不要把它当作 `ORM` 。

`Core Data` 的功能包括但不限于：管理序列化版本、管理对象生命周期、对象图管理、SQL
隔离、处理变更、持久化数据、数据内存优化以及数据查询等。

`Core Data` 提供的功能繁多，但对于初学者并不十分友好，拥有陡峭的学习曲线。最近几年苹果也注意到了这个问题，通过添加 `PersistentContainer` 极大的降低了 `Stack` 创建的难度； `SwiftUI` 及 `Core Data 模版`
的出现让初学者也可以较轻松地在项目中使用其强大的功能了。

## CloudKit

在苹果推出 `iCloud` 之后的几年中，开发者都无法将自己的应用程序同 `iCloud` 结合起来。这个问题直到 2014 年苹果推出了 `CloudKit` 框架后才得到解决。

`CloudKit` 是数据库、文件存储、用户认证系统的集合服务，提供了在应用程序和 `iCloud 容器`
之间的移动数据接口。用户可以在多个设备上访问保存在 `iCloud` 上的数据。

`CloudKit` 的数据类型、内在逻辑和 `Core Data` 有很大的不同，需要做一些妥协或处理才能将两者的数据对象进行转换。事实上，当 `CloudKit` 一经推出，开发者就强烈希望两者之间能够进行便捷的转换。在推出 `Core Data with CloudKit`
之前，已经有第三方的开发者提供了将 `Core Data` 或其他数据的对象（比如 `realm` ）同步到 `CloudKit`
的解决方案，这些方案中的大多数目前仍在提供支持。

依赖于之前推出的 [ 持久化历史追踪 ](/zh/posts/persistenthistorytracking/) 功能，苹果终于在 2019
年提供了自己的解决方案 `Core Data with CloudKit` 。

## Core Data 对象 vs CloudKit 对象

两个框架都有各自的基础对象类型，相互之间并不能被一一对应。在此仅对本文涉及的一些基础对象类型做简单的介绍和比较：

- **NSPersistentContainer vs CKContainer**

`NSPersistentContainer` 通过处理托管对象模型（ `NSManagedObjectModel` ），对持久性协调器（ `NSPersistentStoreCoordinator` ）和托管对象上下文（ `NSManagedObjectContext`
）进行统一的创建和管理。开发者通过代码创建其的实例。

`CKContainer` 则和应用程序的沙盒逻辑类似，在其中可以保存结构化数据、文件等多种资源。每个使用 `CloudKit`
的应用程序应有一个属于自己的 `CKContainer` （通过配置，一个应用程序可以对应多个 `CKContainer` ，一个 `CKContainer` 也可以服务于多个应用程序）。开发者通常不会在代码中直接创建新的 `CKConttainer` ，一般通过 `iCoud
控制台` 或在 `Xcode Target` 的 `Signing&Capabilities` 中创建。

- **NSPersistentStore vs CKDatabase/CkRecordZone**

`NSPersistentStore` 是所有 `Core Data` 持久存储的抽象基类，支持四种持久化的类型（ `SQLite` 、 `Binary` 、 `XML` 和 `In-Memory` ）。在一个 `NSPersistentContainer` 中，通过声明多个的 `NSPersistentStoreDescription` ，可以持有多个 `NSPersistentStore 实例` （可以是不同的类型）。 `NSPersistentStore` 没有用户鉴权的概念，但可以设置只读或读写两种模式。由于 `Core Data with CloudKit` 需要
[ 持久化历史追踪 ](/zh/posts/persistenthistorytracking/) 的支持，因此只能同步将 `SQLite`
作为存储类型的 `NSPersistentStore` ，在设备上，该 `NSPersistentStore 的实例` 将指向一个 `SQLite
数据库文件` 。

在 `CloudKit` 上，结构化的数据存储只有一种类型，但采用了 **两个维度** 对数据进行了区分。

从用户鉴权角度， `CKDatabase` 分别提供了三种形式的数据库：私有数据库、公有数据库、共享数据库。应用程序的使用者（已经登录了 `iCloud` 账号）只能访问自己的私有数据库，该数据库的数据保存在用户个人的 `iCloud`
空间中，其他人都不可以对其数据进行操作。在公共数据库中保存的数据可以被任何授权过的应用程序调用，即使 app 的使用者没有登录 `iCloud`
账户，应用程序仍然可以读取其中的内容。应用程序的使用者，可以将部分数据共享给其他的同一个 `app`
的使用者，共享的数据将被放置在共享数据库中，共享者可以设置其他用户对于数据的读写权限。

数据在 `CKDatabase` 中也不是以零散的方式放置在一起的，它们被放置在指定的 `RecordZone`
中。我们可以在私有数据库中创建任意多的 `Zone` （公共数据库和共享数据库只支持默认 `Zone` ）。当 `CKContainer`
被创建后，每种数据库中都会默认生成一个名为 `_defaultZone` 的 `CKRecordZone` 。

因此，当我们保存数据到 CloudKit 数据库时，不仅需要指明数据库（私有、公有、共享）类型，同时也需要标明具体的 `zoneID` （当保存到 `_defaultZone` 时无需标记）。

- **NSManagedObjectModel vs Schema**

`NSManagedObjectModel` 是托管对象模型，标示着 `Core Data`
对应的数据实体（Enities）。绝大多数情况下，开发者都是使用 `Xcode` 的 `Data Model Editor`
来对其进行的定义，定义会被保存在 `xcdatamodeled` 文件中，其中包含了实体属性、关系、索引、约束、校验、配置等等信息。

当在应用程序中启用 `CloudKit` 后，将在 `CKContainer` 创建一个 `Schema` 。 `Schema`
中包括记录类型（ `Record Type` ）、记录类型类型之间可能存在的关系、索引以及用户权限。

除了直接在 `iCloud` 控制台创建 `Schema` 的内容外，也可以通过在代码中创建 `CKRecord` ，让 `CloudKit` 自动为我们创建或更新 `Schema` 中对应的内容。

`Schema` 中有权限的设定（ `Security Roles` ），可以分别为 `world` 、 `icloud` 以及 `creator` 设定不同的读写权限。

- **Entities vs Record Types**

尽管我们通常会强调 `Core Data` 不是数据库，但实体（ `Enitities`
）与数据库中的表非常相似。我们在实体中描述对象，包括其名称、属性和关系。最终将其描述成 `NSEntityDescription` 并汇总到 `NSManagedObjectModel` 中。

在 `CloudKit` 中用 `Record Types` 描述数据对象的名称、属性。

`Enitiy` 中有大量的信息可以配置，但 `Record Types` 只能对应描述其中的一部分。由于两方无法一一对应，因此在设计 `Core
Data with CloudKit` 的数据对象时要遵守相关规定（具体规定将在下一篇文章中探讨）。

- **Managed Object vs CKRecord**

托管对象（ `Managed Object` ）是表示持久存储记录的模型对象。托管对象是 `NSManagedObject`
或其子类的实例。托管对象在托管对象上下文（ `NSManagedObjectContext`
）中注册。在任何给定的上下文中，托管对象最多有一个实例对应于持久存储中的给定记录。

在 `CloudKit` 上，每条记录被称作为 `CKRecord` 。

我们不需要关心 `Managed Object` 的 `ID` （ `NSMangedObjectID` ）的创建过程， `Core Data` 将为我们处理一切，但对于 `CKRecord` ，多数情况下，我们需要在代码中明确为每条记录设定 `CKRecordIdentifier`
。作为 `CKRecord` 的唯一标识， `CKRecordIdentifier` 被用于确定该 `CKRecord`
在数据库的唯一位置。如果数据保存在自定义的 `CKRecordZone` ，我们也需要在 `CKRecord.ID` 中指明。

- **CKSubscription**

`CloudKit` 是云端服务，它要同一 `iCloud` 账户的不同设备（私有数据库）或者使用不同 `iCloud`
账号的设备（公共数据库）的数据变化做出相应的反馈。

开发者通过 `CloudKit` 在 `iCloud` 上创建 `CKSubscription` , 当 `CKContainer`
中的数据发生变化时，云端服务器会检查该变化是否满足某个 `CKSubscription` 的触发条件，在条件满足时，对订阅的设备发送远程提醒（ `Remote Notification` ）。这就是当我们在 `Xcode Target` 的 `Signing&Capabilities`
中添加上 `CloudKit` 功能时，会 `Xcode` 自动添加 `Remote Notification` 的原因。

在实际使用中，需要通过 `CKSubscription` 的三个子类完成不同的订阅任务：

`CKQuerySubscription` ，当某个 `CKRecord` 满足设定的 `NSPercidate` 时推送 `Notification` 。

`CKDatabaseSubscription` ，订阅并跟踪数据库（ `CKDatabase`
）中记录的创建、修改和删除。该订阅只能用于私有数据库和共享数据库中自定义的 `CKRecordZone` ，并只会通知 `订阅的创建者`
。在以后的文章中，我们可以看到 `Core Data with CloudKit` 是如何在私有库中使用该订阅的。

`CKRecordZoneNotification` ，当用户、或者在某些情况下， `CloudKit` 修改该区域（ `CKRecordZone` ）的记录时，记录区的订阅就会执行，例如，当记录中某个字段的值发生变化时。

对于 `iCloud` 服务器推送的远程通知，应用程序需要在 `Application Delegate` 中做出响应。多数情况下， `远程提醒` 可以采用 `静默通知` 的形式，为此开发者需要在的应用程序中启用 `Backgroud Modes` 的 `Remote
notifications` 。

## Core Data with CloudKit 的实现猜想

结合上面介绍的基础知识，让我们尝试推测一下 `Core Data with CloudKit` 的实现过程。

以私有数据库同步为例：

- 初始化：

  1. 创建 `CKContainer`
  2. 根据 `NSManagedObjectModel` 配置 `Schema`
  3. 在私有数据库中创建 ID 为 `com.apple.coredata.cloudkit.zone` 的 `CKRecordZone`
  4. 在私有数据库上创建 `CKDatabaseSubscription`

- 数据导出（将本地 `Core Data` 数据导出到云端）

  1. `NSPersistentCloudKitContainer` 创建后台任务响应 `持久化历史跟踪` 的 `NSPersistentStoreRemoteChange` 通知
  2. 根据 `NSPersistentStoreRemoteChange` 的 `transaction` ，将 `Core Data` 的操作转换成 `CloudKit` 的操作。比如对于新增数据，将 `NSManagedObject` 实例转换成 `CKRecord` 实例。
  3. 通过 `CloudKit` 将转换后的 `CKRecord` 或其他 `CloudKit 操作` 传递给 `iCloud` 服务器

- 服务器端

  1. 按顺序处理从远端设备提交的 `CloudKit 操作数据`
  2. 根据初始化创建的 `CKDatabaseSubscription` 检查该操作是否导致私有数据库的 `com.apple.coredata.cloudkit.zone` 中的数据发生变化
  3. 对所有创建 `CKDatabaseSubscription` 订阅的设备（同一 `iCloud` 账户）分发远程通知

- 数据导入（将远程数据同步到本地）

  1. `NSPersistentCloudKitContainer` 创建的后台任务响应云端的 `静默推送`
  2. 向云端发送刷新操作要求并附上上次操作的 `令牌`
  3. 云端根据每个设备的 `令牌` ，为其返回自上次刷新后数据库发生的变化
  4. 将远端数据转换成本地数据（删除、更新、添加等）
  5. 由于 `视图上下文` 的 `automaticallyMergesChangesFromParen` 属性设置为真，本地数据的变化将自动在 `视图上下文` 中体现出来

上述步骤中省略了所有技术难点及细节，仅描述了大概的流程。

## 总结

本文中，我们简单介绍了关于 `Core Data` 、 `CloudKit` 以及 `Core Data with CloudKit`
的一点基础知识。在下一篇文章中我们将探讨如何使用 `Core Data with CloudKit` 实现 **本地数据库和私有数据库的同步** 。

PS：介绍如何使用 NSPersistentContainer 的文章并不少，但同其他 Core Data
的功能一样，用好并不容易。在两年多的使用中，我便碰到不少问题。借着今年打算在 [ 【健康笔记 3】 ](/healthnotes/) 中实现 `共享数据库` 功能的机会，我最近较系统地重新学习了 `Core Data with CloudKit`
并对其知识点进行了梳理。希望通过这个系列博文能让更多的开发者了解并使用 `Core Data with Cloudkit` 功能。

# 深入了解 SwiftUI 5 中 ScrollView 的新功能

在 SwiftUI 5.0 中，苹果大幅强化了 ScrollView 功能。新增了大量新颖、完善的
API。本文将对这些新功能进行介绍，希望能够让它们更多、更早的帮助到有需要的开发者。

> 可以在 [ 此处
> ](https://github.com/fatbobman/BlogCodes/tree/main/NewFeaturesOfScrollView)
> 获取完整的演示代码

## contentMargins

    public func contentMargins(_ edges: Edge.Set = .all, _ length: CGFloat?, for placement: ContentMarginPlacement = .automatic) -> some View

为可滚动容器的内容或滚动指示器（Scroll Indicator）添加外边距（Margin）。

- 不限于 ScrollView，支持所有可滚动容器（包括 List、TextEditor 等）。
- 将可滚动容器内的所有子视图视为一个整体，并为其添加 margin。之前在 List 或 TextEditor 中实现类似操作是十分困难的。
- 默认的 ContentMarginPlacement（. automatic）将导致指示器与内容之间的长度不一致。如果想保持长度一致，应使用 `.scrollContent` 。
- 适用于作用域内的所有可滚动容器。

  struct ContentMarginsForScrollView: View {
  @State var text = "Hello world"
  var body: some View {
  VStack {
  ScrollView(.horizontal) {
  HStack {
  CellView(color: .yellow)
  // a custom overlay view for easy display of auxiliary information
  .idView("leading")
  ForEach(0 ..< 5) { i in
  CellView()
  .idView(i)
  }
  CellView(color: .green)
  .idView("trailing")
  }
  }

              // Also affected by contentMargins
              TextEditor(text: $text)
                  .border(.red)
                  .padding()
                  .contentMargins(.all, 30, for: .scrollContent)
          }
          // Applies to all scrollable containers within the scope
          .contentMargins(.horizontal, 50, for: .scrollContent)
      }

  }

![contentMargins_demo_2023-06-12_11.02.35.2023-06-12
11_04_43](https://cdn.fatbobman.com/contentMargins_demo_2023-06-12_11.02.35.2023-06-12%2011_04_43.gif)

## safeAreaPadding

为视图的安全区域添加内嵌。在某些场景下，其效果与 safeAreaInset 十分相似。例如，在下面的代码中，为 ScrollView 的 leading
方向添加安全区域的两种方式效果是一致的。

    struct SafeAreaPaddingDemo: View {
        var body: some View {
            VStack {
                ScrollView {
                    ForEach(0 ..< 20) { i in
                        CellView(width: nil)
                            .idView(i)
                    }
                }
                .safeAreaPadding(.leading,20)
                // .safeAreaInset(edge: .leading){
                //       Color.clear.frame(width:20)
                //  }
            }
        }
    }

- 该属性不仅适用于可滚动视图，而适用于所有类型的视图。
- 它只会影响最近的一个视图。
- 对于全面屏的额外安全区域，safeAreaInset 和 safeAreaPadding 的处理逻辑不一致。

例如，下面的两种实现中，ScrollView 的底部空间是不同的。

使用 safeAreaInset：

    ScrollView {
        ForEach(0 ..< 20) { i in
            CellView(width: nil)
                .idView(i)
        }
    }
    .safeAreaInset(edge: .bottom){
        Text("Bottom View")
            .font(.title3)
            .foregroundColor(.indigo)
            .frame(maxWidth: .infinity, maxHeight: 40)
            .background(.green.opacity(0.6))
    }

![image-20230612112714343](https://cdn.fatbobman.com/image-20230612112714343.png)

使用 safeAreaPadding：

    ZStack(alignment: .bottom) {
        ScrollView {
            ForEach(0 ..< 20) { i in
                CellView(width: nil)
                    .idView(i)
            }
        }
        .safeAreaPadding(.bottom, 40)

        Text("Bottom View")
            .font(.title3)
            .foregroundColor(.indigo)
            .frame(maxWidth: .infinity, maxHeight: 40)
            .background(.green.opacity(0.6))
    }

![image-20230612112755403](https://cdn.fatbobman.com/image-20230612112755403.png)

> 阅读 [ 掌握 SwiftUI 的 Safe Area ](/zh/posts/safearea/) 一文，了解更多有关安全区域的内容。

## scrollIndicatorsFlash

控制滚动指示器

使用 `scrollIndicatorsFlash(onAppear: true)` 可以在滚动视图出现时使其滚动指示器短暂闪烁。

使用 `scrollIndicatorsFlash(trigger:)` 可以在提供的值更改时，修饰符作用域范围内的所有可滚动容器的滚动指示器短暂闪烁。

    struct ScrollIndicatorsFlashDemo: View {
        @State private var items = (0 ..< 50).map { Item(n: $0) }
        var body: some View {
            VStack {
                Button("Remove First") {
                    guard !items.isEmpty else { return }
                    items.removeFirst()
                }.buttonStyle(.bordered)
                ScrollView {
                    ForEach(items) { item in
                        CellView(width: 100, debugInfo: "\(item.n)")
                            .idView(item.n)
                            .frame(maxWidth:.infinity)
                    }
                }
                .animation(.bouncy, value: items.count)
            }
            .padding(.horizontal,10)
            .scrollIndicatorsFlash(onAppear: true)
            .scrollIndicatorsFlash(trigger: items.count)
        }
    }

![scrollIndicatorFlash_demo_2023-06-12_13.44.03.2023-06-12
13_44_40](https://cdn.fatbobman.com/scrollIndicatorFlash_demo_2023-06-12_13.44.03.2023-06-12%2013_44_40.gif)

## scrollClipDisable

scrollClipDisable 用于控制是否对滚动内容应用裁剪以适应滚动容器的边界。

当 scrollClipDisable 为 false 时，滚动内容会被裁剪以适应滚动容器边界。任何超出边界的部分将不会显示。

当 scrollClipDisable 为 true 时，滚动内容不会被裁剪。它可以延伸超出滚动容器的边界，从而显示更多内容。

- 仅适用于 ScrollView
- 适用于作用域内的所有可滚动容器

  struct ScrollClipDisableDemo: View {
  @State private var disable = true
  var body: some View {
  VStack {
  Toggle("Clip Disable", isOn: $disable)
  .padding(20)
  ScrollView {
  ForEach(0 ..< 10) { i in
  CellView()
  .idView(i)
  .shadow(color: .black, radius: 50)
  }
  }
  }
  .scrollClipDisabled(disable)
  }
  }

![scrollClipDisable_demo_2023-06-12_13.58.10.2023-06-12
13_58_50](https://cdn.fatbobman.com/scrollClipDisable_demo_2023-06-12_13.58.10.2023-06-12%2013_58_50.gif)

## scrollTargetLayout

此修饰符用于配合下文介绍的 `scrollTargetBehavior( ViewAlignedScrollTargetBehavior 模式）` 或
`scrollPosition(id:)` 使用。

应将此修饰符应用于 ScrollView 中包含主要重复内容的布局容器，如 LazyHStack 或 VStack。

    @State private var isEnabled = true

    ScrollView {
        LazyVStack {
            ForEach(items) { item in
                CellView(width: 200, height: 140)
                    .idView(item.n)
            }
        }
        .scrollTargetLayout(isEnabled: isEnabled)
    }

## defaultScrollAnchor

使用此修饰符可以指定滚动视图内容最初可见部分的锚点。它只影响滚动视图的初始状态，一次性设置。通常用于实现类似初始状态从底部显示的 IM 应用、从
trailing 开始显示数据等情况。通过 UnitPoint 可以同时设置两个轴向的初始位置。

    struct ScrollPositionInitialAnchorDemo: View {
        @State private var show = false
        @State private var position: Position = .leading
        var body: some View {
            VStack {
                Toggle("Show", isOn: $show)
                Picker("Position", selection: $position) {
                    ForEach(Position.allCases) { p in
                        Text(p.rawValue).tag(p)
                    }
                }
                .pickerStyle(.segmented)
                if show {
                    ScrollView(.horizontal) {
                        LazyHStack {
                            ForEach(0 ..< 10000) { i in
                                CellView(debugInfo: "\(i)")
                                    .idView(i)
                            }
                        }
                    }
                    .defaultScrollAnchor(position.unitPoint)
                }
            }
            .padding()
        }

        enum Position: String, Identifiable, CaseIterable {
            var id: UnitPoint { unitPoint }
            case leading, center, trailing
            var unitPoint: UnitPoint {
                switch self {
                case .leading:
                    .leading
                case .center:
                    .center
                case .trailing:
                    .trailing
                }
            }
        }
    }

![scrollPostion_initialAnchor_demo_2023-06-12_14.37.09.2023-06-12
14_37_47](https://cdn.fatbobman.com/scrollPostion_initialAnchor_demo_2023-06-12_14.37.09.2023-06-12%2014_37_47.gif)

> 尽管使用此修饰符实现初始定位十分容易，但当数据集很大时，仍然会有较严重的性能问题。可采用 [ 优化在 SwiftUI List 中显示大数据集的响应效率
> ](/zh/posts/optimize_the_response_efficiency_of_list/) 一文中介绍的方式来解决。

## scrollPostion (id:)

使用此修饰符可以让滚动视图滚动到特定的位置。可以将其理解为 ScrollViewReader 的简化版本。

- 仅适用于 ScrollView
- 当 ForEach 中的数据源遵循 Identifiable 协议时，无需显式使用 `id` 修饰符设置标识
- 与 scrollTargetLayout 配合使用，可以获取当前的滚动位置（视图标识）
- 不支持锚点设定，固定锚点为子视图的 center
- 正如 [ 优化在 SwiftUI List 中显示大数据集的响应效率 ](/zh/posts/optimize_the_response_efficiency_of_list/) 一文所提到的，当数据集很大时，也会出现性能问题。

  struct ScrollPositionIDDemo: View {
  @State private var show = false
  @State private var position: Position = .trailing
  @State private var items = (0 ..< 500).map {
  Item(n: $0)
  }

      @State private var id: UUID?

      var body: some View {
          VStack {
              Picker("Position", selection: $position) {
                  ForEach(Position.allCases) { p in
                      Text(p.rawValue).tag(p)
                  }
              }
              .pickerStyle(.segmented)
              Text(id?.uuidString ?? "").fixedSize().font(.caption2)
              ScrollView(.horizontal) {
                  LazyHStack {
                      ForEach(items) { item in
                          CellView(debugInfo: "\(item.n)")
                              .idView(item.n)
                      }
                  }
              }
              .scrollPosition(id: $id)
              .scrollTargetLayout()
          }
          .animation(.default, value: id)
          .padding()
          .frame(height: 300)
          .task(id: position) {
              switch position {
              case .leading:
                  id = items.first!.id
              case .center:
                  id = items[250].id
              case .trailing:
                  id = items.last!.id
              }
          }
      }

  }

![scrollPositionID_demo_2023-06-12_15.38.35.2023-06-12
15_39_13](https://cdn.fatbobman.com/scrollPositionID_demo_2023-06-12_15.38.35.2023-06-12%2015_39_13.gif)

对应的 ScrollViewReader 版本：

    ScrollViewReader { proxy in
        ScrollView(.horizontal) {
            LazyHStack {
                ForEach(items) { item in
                    CellView(debugInfo: "\(item.n)")
                        .idView(item.n)
                        .id(item.id)
                }
            }
        }
        .task(id: position) {
            switch position {
            case .leading:
                proxy.scrollTo(items.first!.id)
            case .center:
                proxy.scrollTo(items[250].id)
            case .trailing:
                proxy.scrollTo(items.last!.id)
            }
        }
    }

ScrollViewReader 和 scrollPostion (id:) 的内部实现原理应该差不多。但是，ScrollViewReader 可用于
List 中，还可设置锚点。scrollPostion (id:) 与 scrollTargetLayout 配合使用时，可获取当前滚动位置（标识）。

## scrollTargetBehavior

scrollTargetBehavior 用于设置 ScrollView 的滚动行为：分页还是与子视图对齐。

使用 `.scrollTargetBehavior(.paging)` 可以使 ScrollView 分页滚动，每次滚动一页（即 ScrollView
的可视尺寸）。

    LazyVStack {
        ForEach(items) { item in
            CellView(width: 200, height: 140)
                .idView(item.n)
        }
    }
    .scrollTargetBehavior(.paging)

![scrollTarget_paging_demo_2023-06-12_15.55.29.2023-06-12
15_55_55](https://cdn.fatbobman.com/scrollTarget_paging_demo_2023-06-12_15.55.29.2023-06-12%2015_55_55.gif)

当设置为 .scrollTargetBehavior (. viewAligned) 时，需要与 scrollTargetLayout
一同使用。滚动停止时，容器顶端将与子视图的顶部对齐（在垂直模式下）。开发者可以通过控制 scrollTargetLayout 的启用与否来开关
viewAligned 的行为。

    struct ScrollTargetBehaviorDemo: View {
        @State var items = (0 ..< 100).map { Item(n: $0) }
        @State private var isEnabled = true
        var body: some View {
            VStack {
                Toggle("Layout enable", isOn: $isEnabled).padding()
                ScrollView {
                    LazyVStack {
                        ForEach(items) { item in
                            CellView(width: 200, height: 95)
                                .idView(item.n)
                        }
                    }
                    .scrollTargetLayout(isEnabled: isEnabled)
                }
                .border(.red, width: 2)
            }
            .scrollTargetBehavior(.viewAligned)
            .frame(height: 300)
            .padding()
        }
    }

![scrollTarget_viewAligned_demo_2023-06-12_16.11.06.2023-06-12
16_11_42](https://cdn.fatbobman.com/scrollTarget_viewAligned_demo_2023-06-12_16.11.06.2023-06-12%2016_11_42.gif)

通过 `.scrollTargetBehavior(.viewAligned(limitBehavior:))` 我们可以定义对齐滚动目标行为的机制。

- `.automatic` 是默认行为，在紧凑的水平尺寸类中受限，否则不受限。
- `.always` 始终限制可滚动视图的数量。
- `.never` 不限制可滚动视图的数量。

同时，通过 ViewAlignedScrollTargetBehavior ，开发者还可以基于系统提供的目标覆盖滚动视图的滚动位置（ 尚未仔细研究实现细节
）。

## NamedCoordinateSpace. scrollView

在 SwiftUI 5 中，苹果新增了 NamedCoordinateSpace 类型，方便用户命名坐标系，并提供了预置的 .scrollView
坐标系（仅支持
ScrollView）。通过这个坐标系，开发者可以非常容易地获取子视图与滚动视图之间的位置关系。利用这些信息，我们可以轻松地实现很多效果，尤其是配合另一个新
API，visualEffect 修饰符。

    struct CoordinatorDemo: View {
        var body: some View {
            ScrollView {
                ForEach(0 ..< 30) { _ in
                    CellView()
                        .overlay(
                            GeometryReader { proxy in
                                if let distanceFromTop = proxy.bounds(of: .scrollView)?.minY {
                                    Text(distanceFromTop * -1, format: .number)
                                }
                            }
                        )
                }
            }
            .border(.blue)
            .contentMargins(30, for: .scrollContent)
        }
    }

![scrollView_coodinatorName_demo_2023-06-12_17.28.22.2023-06-12
17_28_54](https://cdn.fatbobman.com/scrollView_coodinatorName_demo_2023-06-12_17.28.22.2023-06-12%2017_28_54.gif)

与使用 `.coordinateSpace(.named("MyScrollView"))` 设置的坐标系不同，预设的 `.scrollView`
坐标系可以正确处理 `contentMargins` 创建的 margin。

    ScrollView {
        ForEach(0 ..< 30) { _ in
            CellView()
                .overlay(
                    GeometryReader { proxy in
                        if let distanceFromTop = proxy.bounds(of: .named("MyScrollView"))?.minY {
                            Text(distanceFromTop * -1, format: .number)
                        }
                    }
                )
        }
    }
    .border(.blue)
    .contentMargins(30, for: .scrollContent)
    // margin not recognized
    .coordinateSpace(.named("MyScrollView"))

![image-20230612173216588](https://cdn.fatbobman.com/image-20230612173216588.png)

> `bounds(of coordinateSpace: NamedCoordinateSpace) -> CGRect?` 是今年新增的
> API，用于获取指定坐标空间的边界矩形。

## scrollTransition

其实，在很多场景下，我们并不需要通过 `NamedCoordinateSpace.scrollView` 获取非常精确的位置关系。苹果为我们提供了另一个
API，可以简化上述过程。

当子视图滑入和滑出包含它的滚动视图的可视区域时， `scrollTransition` 会对该视图应用给定的过渡动画，并在不同阶段之间平滑地过渡。

目前定义了三种阶段状态（ `Phase` ）：

- `topLeading` : 视图滑入滚动容器的可见区域
- `identity` : 表示视图目前在可见区域中
- `bottomTrailing` : 视图滑出滚动容器的可见区域

`scrollTransition` 的 `transition` 闭包要求你返回一个符合 [ VisualEffect
](https://developer.apple.com/documentation/swiftui/visualeffect) 协议的类型（ `VisualEffect` 协议定义了一种不影响视图布局的效果类型，苹果已经让很多 Modifier 符合了该协议）。

    struct ScrollTransitionDemo: View {
        @State var clip = false
        var body: some View {
            ZStack(alignment: .bottom) {
                ScrollView {
                    ForEach(0 ..< 30) { i in
                        CellView()
                            .idView(i)
                            .scrollTransition(.animated) { content, phase in
                                content
                                    .scaleEffect(phase != .identity ? 0.6 : 1)
                                    .opacity(phase != .identity ? 0.3 : 1)
                            }
                    }
                }
                .frame(height: 300)
                .scrollClipDisabled(clip)
                Toggle("Clip", isOn: $clip)
                    .padding(16)
            }
        }
    }

![scrollTransition_demo_2023-06-12_19.19.19.2023-06-12
19_20_18](https://cdn.fatbobman.com/scrollTransition_demo_2023-06-12_19.19.19.2023-06-12%2019_20_18.gif)

> 可以将 scrollTransition 视为 NamedCoordinateSpace. scrollView 和
> visualEffect（视图修饰符）的缩减版本，用于更方便地实现效果。

## 总结

我完全没有想到，在 SwiftUI 5 中，苹果对 ScrollView 进行了全面增强。值得赞赏的是，他们不仅提供了一些一直期待的功能，而且在 API
的设计和实现完成度上都非常出色。

就我个人而言，在 SwiftUI 5 中，ScrollView 的原生方案已经能够满足大多数需求，因此我们将看到更多人采用 ScrollView +
LazyStack 的组合方式。

# HowTo —— 使用 onOpenURL 处理 Universal Links

SwiftUI 2.0 由于可以采用新的代码架构（Life Cycle SwiftUI App）来组织 app, 因此提供了 onOpenURL 来处理
Univeresal Links。不同于在 AppDelegate 或 SceneDelegate 中的解决方案，onOpenURL 作为一个 view
modifier，你可以在任意 View 上注册你的 app 的 URL 处理机制。关于如何为自己的 app 创建 URL Scheme，请参阅 [
苹果的官方文档 ](https://developer.apple.com/documentation/uikit/inter-
process_communication/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app)
。

## 基本用法

    VStack{
       Text("Hello World")
    }
    .onOpenURL{ url in
        //做点啥
    }

## 示例代码

首先在项目中设置 URL

![URL](https://cdn.fatbobman.com/howto-swiftui-onOpenURL-URL.png)

    import SwiftUI

    struct ContentView: View {
        @State var tabSelection:TabSelection = .news
        @State var show = false
        var body: some View {
            TabView(selection:$tabSelection){
                Text("News")
                    .tabItem {Image(systemName: "newspaper")}
                    .tag(TabSelection.news)
                Text("Music")
                    .tabItem {Image(systemName: "music.quarternote.3")}
                    .tag(TabSelection.music)
                Text("Settings")
                    .tabItem {Image(systemName: "dial.max")}
                    .tag(TabSelection.settings)
            }
            .sheet(isPresented: $show) {
                Text("URL 调用参数错误")
            }
            .onOpenURL { url in
                let selection = url.host
                switch selection{
                case "news":
                    tabSelection = .news
                case "music":
                    tabSelection = .music
                case "settings":
                    tabSelection = .settings
                default:
                    show = true
                }
            }
        }
    }

    enum TabSelection:Hashable{
        case news,music,settings
    }

> macOS 目前暂不支持，应该会在正式版本提供。

你的浏览器不支持本视频

## 特别注意

- onOpenURL 只有在项目采用 Swift App 的方式管理 Life Cycle 才会响应

- 在代码中可以添加多个 onOpenURL，注册在不同的 View 上，当采用 URL 访问时，每个闭包都会响应。这样可以针对不同的 View 做出各自需要的调整。

# Core Data with CloudKit（五）—— 同步公共数据库

本文将介绍如何通过 `Core Data with CloudKit` 将公共数据库同步到本地，在本地创建 `Core Data` 数据库镜像。

## 三种 CloudKit 数据库

介绍一下 `CloudKit` 中的三种数据库：

### 公共数据库

公共数据库存放的是开发者希望任何人都能够访问的数据。不可以在公共数据库中添加自定义 `Zone` ，所有的数据都保存在默认的区域中。无论用户是否有 `iCloud` 账户，都可以通过应用程序或 `CloudKit Web` 服务访问其中的数据。公共数据库的内容在 `CloudKit`
仪表台是可见的。

公共数据库的数据容量计入应用程序的 `CloudKit` 存储配额。

### 私有数据库

这是 `iCloud` 用户存储个人数据的地方，用户将不希望公众看到的内容通过应用程序保存在这里。只有在登录了 `iCloud`
账户后，用户才可以访问其中的数据。默认情况下，只有用户本人才能访问自己的私有数据库中的内容（可将部分内容分享给其他的 `iCloud`
用户）。用户对数据拥有全部的操作权限（创建、查看、更改、删除）。私有数据库中的数据在 `CloudKit` 仪表台中是不可见的，对开发者是完全保密的。

开发者可以在私有数据库中创建自定义区域，便于组织管理数据。

私有数据库的数据容量计入用户的 `iCloud` 存储配额。

### 共享数据库

`iCloud` 用户在共享数据库中看到的数据，是其他的 `iCloud`
用户共享给你的数据投影，这些数据仍然保存在其他人各自的私有数据库中。你不拥有这些数据，并且只有在拥有必要权限的情况下才能查看和修改内容。只有已经登录了 `iCloud` 账户，此数据库才可用。

例如你将某条数据共享给某个用户，该数据仍保存在你的私有数据库中，但被共享者由于你的授权可以在他的共享数据库中看到该记录，且只能依据你设定的权限进行操作。

共享数据库中不可以自定义区域。其中的数据在 `CloudKit` 仪表台中不可见。

共享数据库的容量计入应用程序的 `CloudKit` 存储配额。

## 一样的名词、不一样的含义

在 [ Core Data with CloudKit（二） ](/zh/posts/coredatawithcloudkit-2/)
中，我们介绍了如何同步本地数据库到 `iCloud` 私有数据库，本篇我们谈的是如果将共享数据库同步到本地。尽管两篇文章都在聊关于 **同步**
的话题，但这 **两个同步的内在含义和逻辑是不一样的** 。

**同步本地数据到私有数据库** ，本质上讲仍是一个标准的 `Core Data`
项目，开发者从模型设计到代码开发，同开发【仅支持本地持久化数据库的项目】没有不同。 `CloudtKit`
仅起到一个将数据同步到用户其他设备的桥梁作用。在绝大多数的情况下，开发者在使用托管对象时可以完全不考虑私有数据库以及 `CKRecord` 的存在。

将 **公共数据库同步到本地** ，则完全不同。公共数据库是网络数据库概念。标准逻辑为开发者在 `CloudKit` 仪表台上创建 `Record
Type` ，通过仪表台或客户端向公共数据库添加 `CKRecord` 记录，客户端通过访问服务器获取网络数据记录。 `Core Data with
CloudKit` 方便我们利用已有的 `Core Data`
知识来完成这一过程。同步到本地的数据，是服务器端公共数据库的镜像，在本地通过对托管对象数据的操作间接完成对服务器端 `CKRecord` 记录的操作。

> 后面讨论的鉴权，尽管操作对象为托管对象或本地持久化存储，但检查的却是网络端的记录或数据库。

## 公共数据库 vs 私有数据库

我们从几个维度来比较一下公共数据库和私有数据库。

### 鉴权

在不考虑数据共享的情况下，私有数据库中的数据只有用户自己（已登录 `iCloud`
账户）可以访问。用户作为数据的创建者拥有所有的操作权限。私有数据库的鉴权规则非常简单：

![image-20210812153836921](https://cdn.fatbobman.com/image-20210812153836921-8753918.png)

在 [ iCloud 仪表台 ](/zh/posts/coredatawithcloudkit-3/)
一文中，我们介绍了安全角色的概念。系统为公共数据库创建了 3 个预置角色： `World` 、 `Authenticated` 以及 `Creator` 。在公共数据库中，鉴权时需要考虑用户是否已登录 `iCloud` 账户、是否为数据记录的创建者等多种因素。

![image-20210812154950463](https://cdn.fatbobman.com/image-20210812154950463-8754592.png)

- 每个用户都可以读取记录（无论是否登录账户）
- 每个已登录账户的用户都可以创建记录
- 已登录用户只能修改或删除自己创建的记录

通过标准 `CloudKit API` 来判断权限除了代码量较多外，鉴权时间也较长（每次都需要访问服务器才能获得结果）。 `Core Data
with CloudKit` 通过在本地备份 `CKRecord` 的元数据的方式，完美解决了鉴权效率问题，并提供了便捷 `API`
供开发者调用。

我们可以通过类似的代码来判断，用户是否对当前的托管对象（ `ManagedObject` ）有修改删除的权限：

    let container = PersistenceController.shared.container

    if container.canUpdateRecord(forManagedObjectWith:item.objectID) {
        // 修改或删除 itme
    }

最近两年，苹果不断提升 `NSPersistentCloudKitContainer`
的存在感，为它添加了不少重要的方法。这些方法不仅可以用于公共数据库或其中的托管对象，还可以用于其他类型的数据库或数据（私有数据库、本地数据库、共享数据等）。

- `canUpdateRecord` 和 `canDeleteRecord`

获取是否具有修改数据的权限。在以下情况都将返回 true：

    1. ` objectID ` 是临时对象标识符（意味着还没有被持久化）。
    2. 包含托管对象的持久化存储不适用 ` CloudKit ` （不用于同步的本地数据库）。
    3. 持久化存储管理私有数据库（用户对私有数据库拥有全部权限）
    4. 持久化存储管理公共数据库，并且用户是该记录的创建者，或者 ` Core Data ` 尚未将托管对象更新到 ` iCloud ` 中。
    5. 持久化存储管理共享数据库，并且用户拥有更改数据的权限。

_实际使用中`canDeleteRecord` 返回的结果不准，目前推荐大家只使用 `canUpdateRecord` _

**`canUpdateRecord` 返回 `false`
，并非意味着你无法从本地存储删除数据，只意味你并不拥有该托管对象对应的网络记录的修改权限 ** 。

- `canModifyMangedObject(in:NSPersistentStore)`

指示是否可以可以更改特定的持久化存储。

使用此方法确定用户能否将记录写入 `CloudKit` 数据库。比如当用户没有登录 `iCloud` 账户时，无法写入管理公共数据库的持久化存储。

**同样的`canModifyManagedObjects` 返回 `false` ，也并非意味着你不可以在本地的 `sqlite`
文件中写入数据，仅意味着你不拥有对该持久化存储对应的网络存储的修改权限 ** 。

> 由于本地数据和持久化存储是没有权限概念的，开发者很可能编写出尽管没有网络端的权限但仍在本地进行了错误操作的代码。这在同步公共数据库和同步共享数据库的项目中是十分危险的。如果你对一个没有网络端权限的数据记录进行了修改或删除，网络端会拒绝你的请求，
> `Core Data with CloudKit` 在收到拒绝后会停止之后所有同步工作。因此
> **在编写同步公共数据库或共享数据库的项目时，必须在确保拥有对应的权限后再对数据进行操作** 。

### 同步机制

从 `export` （将本地数据更改同步至服务器）这一侧讲，无论是同步私有数据库还是公共数据库，表现都是一样的。 `Core Data with
CloudKit` 会在本地数据发生变化后，立即将变化同步给服务器。是一种即时的单向行为。

从 `import` （将网络数据的更改同步至本地）角度来将，私有数据库和公共数据库的机制则完全不同。

在 [ 基础 ](/zh/posts/coredatawithcloudkit-1/) 和 [ CloudKit 仪表台
](/zh/posts/coredatawithcloudkit-3/) 两篇文章，我们已经介绍了私有数据库的同步机制：

- 客户端在服务器订阅 `CKDatabaseSubscription`
- 服务器端在私有数据库自定义 `Zone` 的内容发生变化后，向客户端推送静默远程提醒
- 客户端收到提醒后，通过 `CKFetchRecordZoneChangesOperation` 向服务器端请求变更数据
- 服务器端在比对令牌后，将令牌更新的变动数据同步给客户端

整个过程有来有往，两方配合共同完成。

由于公共数据库的一些技术限制，上述的机制无法适用于公共数据库的同步。

- 公共数据库不能自定义 `Zone`
- 没有自定义 `Zone` 则不能订阅 `CKDatabaseSubscription`
- `CKFetchrecordZoneChangesOperation` 利用了私有数据库的专有技术，公共数据库只能采用 `CKQureyOperation`
- 公共数据库没有墓碑机制，无法记录全部的用户操作（删除）

由于上述原因， `Core Data with CloudKit` 只能采用轮询方式（ `poll for changes`
）来获取公共数据库的变化数据。

当应用程序启动时或每运行 30 分钟， `NSPersistentCloudKitContainer` 都会通过 `CKQurey`
操作来查询公共数据库的变化并进行获取数据。 `import` 过程是由客户端发起，服务器端响应。

此种同步机制将限制适用场景， **只有即时性不高的数据才适合保存在公共数据库中** 。

### 数据模型

由于同步机制不同，在为公共数据库设计数据模型时须考虑以下几点：

- **复杂度**

公共数据库使用 `CKQureyOperation` 查询自上次以来的服务器端变化，它的效率远低于 `CKFetchRecordZoneChangesOperation` 。如果能控制 `ManagedObjectModel`
的实体、属性数量则查询所需的 `Request` 越少，执行效率越高。如无特殊需要，应尽可能减少公共数据库的模型复杂度。

- **墓碑**

私有数据库在收到客户端发送的记录删除操作后，会立即将服务器端的记录删除，并保存删除操作的墓碑标志。其他的客户端设备通过 `CKFetchRecordZoneChangesOperation`
获取变更时，私有数据库将变更记录（包括墓碑）一并发送给客户端。客户端根据墓碑指示删除掉本地对应的数据记录，从而保证数据的一致性。

公共数据库也会在收记录删除操作后，立即删除掉服务器端的记录。不过由于公共数据库没有墓碑机制，因此当其他的客户端向它查询是否有数据变化时，公共数据库只会将新增或更改的记录变化告诉客户端设备，无法将删除操作通知给客户端。这意味着，我们无法将删除操作从一个设备传递给另一个设备，两个设备的公共数据库本地镜像将出现差异。

我们在设计公共数据库数据模型时，通过添加一个类似墓碑（比如 `isDeleted` ）的属性，尽可能地避免这种差异。

    // "删除"时，将 isDelete 设置为 true
    if container.canUpdateRecord(forManagedObjectWith:item.objectID){
        item.isDeleted = true
        try! viewContext.save()
    }

调用数据时，只获取 `isDeleted` 为 `false` 的记录。

    @FetchRequest(
            sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
            predicate: NSPredicate(format: "%K = false", #keyPath(Item.isDelete)),
            animation: .default
    )
    private var items: FetchedResults<Item>

> 记录并没有被真正删除，只是被屏蔽了。公共数据库可以将记录修改操作在设备间传递，在保证了设备之间数据一致同时，也实现了对数据的”删除”。被”删除”的数据在本地和服务器端仍然占据空间，需谨慎地选择清空其占据空间的时机。

### 存储配额

私有数据库的数据是保存在用户个人的 `iCloud` 空间中的，占用的是其个人空间的容量配额。如果该用户的 `iCloud`
空间满了，数据将不能够继续通过网络在各个设备间进行同步。用户可以通过清理个人空间或选择更大的空间方案来解决这个问题。

公共数据库的数据容量占用的是你的应用程序的空间配额。苹果给每一款支持 `CloudKit` 的应用都提供了基础的空间容量，限制如下：10 GB 的 `Asset` 存储，100 MB 的数据库，每月 2 GB 数据传输量以及每秒 40 次的查询请求。空间、流量、请求数都会根据你应用程序的活跃用户数（16
月内使用过应用）的提高而提高，至多会增加到 10 PB、10 TB、每天 200 TB 的级别。

尽管绝大多数的应用程序都不会超过这些限额，但是作为开发者还是应该尽可能的减少空间的使用量，提高数据响应效率。

`Core Data with CloudKit`
对公共数据库的同步是将整个公共库在本地保存一个镜像，因此，如果不能很好的控制数据量，应用程序对用户设备的占用将十分恐怖。上文采取的”删除”方法还将进一步侵占网络和设备空间。

开发者在项目设计之初就应该考虑好清空伪”删除”数据的时机。

我们无法保证清空一定会发生在所有的客户端都已经同步了”删除”状态，在不影响应用程序业务逻辑的情况下，适当允许设备间的数据不一致是可以接受的。

开发者可以根据应用程序的平均使用频率，在客户端对一定时间前”删除”的数据进行清除操作。尽管 `Core Data with CloudKit`
在本地保存了托管对象对应的 `CKRecord` 元数据，但没有给开发者提供
API。为了删除方便，我们可以在模型中添加”删除”时间属性，配合清除时的查询工作。

## 公共数据库的适用场合

通过 `CloudKit` 调用公共数据库和通过 `Core Data with CloudKit`
同步公共数据库两者的技术特点不同，考虑的侧重点也不一样。

我个人推荐以下几种场合适于使用 `Core Data with CloudKit` 同步公共数据库：

- 只读不写

比如提供模版、初始数据、新闻提醒等。

公共数据库数据的创建、修改、删除均由开发者通过仪表台或特定的应用操作，用户的应用程序仅读取公共数据库的内容，不创建也不更改。

- 仅处理一条记录

应用程序仅创建一条和用户或设备关联的数据，并仅对该条数据进行内容更新。

通常应用在记录和设备关联的状态或用户（可关联）的状态或数据。例如游戏高分排行榜（仅保存用户的最高分数）。

- 只创建不修改

日志类的场景。用户负责创建数据，并不特别依赖数据本身。应用程序定期清除掉本地的过期数据。通过 `CloudKit Web`
服务或其他的特定应用对公共数据库记录进行查询或备份并定期清除。

> 开发者在考虑使用 `Core data with CloudKit` 同步公共数据库数据时，一定要仔细考虑各方利弊，选择合适的应用场景。

## 同步公共数据库

本节大量涉及了 [ Core Data with CloudKit（二）——同步本地数据库到 iCloud 私有数据库
](/zh/posts/coredatawithcloudkit-2/) 和 [ Core Data with CloudKit（三）——CloudKit
仪表台 ](/zh/posts/coredatawithcloudkit-3/) 中的知识，请阅读上述两篇文章后再继续。

### 项目配置

在项目中配置公共数据库同配置私有数据库几乎完全一致。

- 在项目 `Target` 的 `Signing&Capabilities` 中添加 `iCloud`
- 选择 `CloudKit` 并添加 `Container`

_如果在项目中仅使用公共数据库，可以不添加`Background Mode` 的 `Remote notifications` 功能 _

### 使用 NSPersistentCloudKitContainer 创建本地镜像

- 在 `Xcode Data Model Editor` 中创建新的 `Configuration` ，并将你想公开的实体（ `Entity` ）添加到这个新配置中。
- 在你的 `Core Data Stack` 中（比如模版项目的 `Persistenc.swift` ）添加如下代码：

  let publicURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!.appendingPathComponent("public.sqlite")
  let publicDesc = NSPersistentStoreDescription(url: publicURL)
  publicDesc.configuration = "public" //Configuration 名称
  publicDesc.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: "your.public.containerID")
  publicDesc.cloudKitContainerOptions?.databaseScope = .public

代码非常熟悉？那就对了。事实上，同步公共数据库只比同步私有数据库多了一行代码：

    publicDesc.cloudKitContainerOptions?.databaseScope = .public

> `databaseScope` 是苹果 2020 年为 `cloudKitContainerOptions` 新添加的属性。默认值为 `.private` ，因此同步私有库时无需设置。

就这？

是的，就这。其他配置都和同步私有数据库一样。将 `Descriptioin` 添加到 `persistentStoreDescriptions`
，配置上下文，有需要的话配置 [ Persistent History Tracking
](/zh/posts/persistenthistorytracking/) 。

### 配置仪表台

由于 `NSPersistentCloudKitContainer` 对公共数据的获取方式（ `CKQurey` ）和对私有数据的获取方式（ `CKFetchRecordZoneChangesOperation` ）不同，我们还需要在 `CloudKit` 仪表台上对 `Schema`
进行一定的修改，才能保证程序的正常运行。

在 `CloudKit` 仪表台中，选择 `Indexes` ，为 **每个** 用于公共数据库的 `Record Type` 添加两个索引：

![image-20210813153127111](https://cdn.fatbobman.com/image-20210813153127111-8839888.png)

> 在写本文的时候，当我使用 `Xcode 13 beta5` 构建演示项目时发现，还需要再增加一个索引才能正常同步公共数据库。如果你使用 `Xcode 13` 请在仪表台多添加一个索引 `Sortable` 。

![image-20210813153521321](https://cdn.fatbobman.com/image-20210813153521321-8840122.png)

## 其他

### 初始化 Schema

**按照上文操作，进行至在`CloudKit` 仪表台上添加索引时，你会发现没有 `Record Type`
供你添加索引。这是因为我们并没有在网络数据库端初始化 `Schema` 。 **

在网络端初始化 Schema 有两种方法：

- 创建一个托管对象数据并将其同步到服务器端

服务器在收到数据后，如发现没有对应的 `Record Type` 会自动为其创建

- 使用 `initializeCloudKitSchema`

`initializeCloudKitSchema` 让我们可以在不创建数据的情况下就可以在服务器端初始化 `Schema` 。在 `Core
Data Stack` 中添加下面代码：

    try! container.initializeCloudKitSchema(options: .printSchema)

运行项目后，我们就可以在仪表台上看到项目中对应的 `Record Type` 了。

**该代码只需执行一次，在初始化后将其删除或注释掉。**

另外我们也可以在单元测试中使用 `initializeCloudKitSchema` 验证 `Model` 是否符合同步模型的兼容需求。

    let result = try! container.initializeCloudKitSchema(options: .dryRun)

符合兼容需求 `result` 为真。 `.dryRun` 意味着仅在本地检查，并不在服务器端实际初始化。

### 多容器、多配置

在之前的文章我们已经提及，可以在一个项目中关联多个 `CloudKit` 容器，一个容器也可以对应多个应用程序。

如果你的项目同时使用私有数据库和公共数据库，并且两个容器不一致，除了在项目中对两个容器都进行关联外，在代码中，也需要为 `Description`
设置正确的 `ContainerID` 。

    let publicDesc = NSPersistentStoreDescription(url: publicURL)
    publicDesc.configuration = "public"
    publicDesc.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: "public.container")
    publicDesc.cloudKitContainerOptions?.databaseScope = .public

    let privateDesc = NSPersistentStoreDescription(url: privateURL)
    privateDesc.configuration = "private"
    privateDesc.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: "private.container")

公共数据库的 `NSPersistentStoreDescription` 的 `URL` 同私有数据库的 `URL`
必须是不同的（也就是要创建两个 `sqlite` 文件），协调器无法多次加载同一个 `URL` 。

    let publicURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!.appendingPathComponent("public.sqlite")

    let privateURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!.appendingPathComponent("private.sqlite")

### Xcode 13 beta

`Xcode 13 beta` 好像对 `CloudKit` 模块做了未公开的调整。在 `Xcode 13 beta5` 下使用 `Core
Data with CloudKit` 会出现很多奇怪的警告。现阶段，最好使用 `Xcode 12` 来进行本文测试。

## 总结

`本地数据同步至私有数据库` 和 `同步公共数据库`
在代码中的实现是极为相似的，开发者不要被这种假象所迷惑，一定要认清同步机制的本质，这样才能更好的设计数据模型，规划业务逻辑。

我将在 `Xcode 13` 稳定后继续完成本系列的下一篇——同步共享数据库。

# 玩转 Xcode Playground（下）

在 [ 上文 ](/zh/posts/xcodeplayground1/) 中，我们介绍了有关 Xcode Playground 在创建、配置、Quick
Look、实时视图等方面的知识。本文将对 Xcode Playground 做更进一步的研究，着重于辅助代码、资源管理、使用 Playground
探索软件包和 Xcode 项目等更有深度内容。

## 辅助代码与资源

### Xcode Playground 的包结构及文件添加

Xcode Playground 项目并不依赖项目配置文件，Page、辅助代码、资源文件、调用权限等均通过 `.playground`
包内的目录结构来进行管理。

#### 单 Page 情况时

创建一个新的 Xcode Playground 项目后，默认的包文件结构如下（右键点击 Playground 项目文件，选择显示包内容）：

![image-20211230091237554](https://cdn.fatbobman.com/image-20211230091237554.png)

![image-20211230091344661](https://cdn.fatbobman.com/image-20211230091344661.png)

新创建的项目只有一个 Page，Xcode Playground 会将 Page 同 Playground 项目的内容合并显示。Contents.
swift 为当前唯一 Page 的主代码内容。尽管在 Xcode 的导航栏中显示了 Sources 和 Resources ，但由于当前两者均没有内容，
`.playground` 包中并没有为其创建目录。

Sources 目录是存放辅助代码（也被称为共享代码）的地方。开发者通常将自定义类型、预设方法、测试片段、前文中提到的自定义 Quick
Look、自定义实时视图类型等内容，保存成 Swift 代码文件，放置在 Sources 目录中。

辅助代码有多种添加方式，可以直接将代码文件在 Xcode 中拖拽到导航栏的 Sources 项目中；或者在 Finder 里将代码文件拷贝到 Sources
目录中；或者在 Sources 上点击右键，直接创建新的 Swift 代码文件。

Resources 目录是用来存放 Page 的主代码（Contents.
swift）以及辅助代码中需要使用到的各类资源文件，例如：图片、声音、JSON、Assets 资产等等。添加的方式同添加辅助代码类似。

_资源文件只能被保存在 Resources 目录或其子目录中，辅助代码也只能被保存在 Sources 目录或其子目录中。_

当我们向 Sources 或 Resources 目录中添加内容后，Playground 将会自动在 `.playground` 包中创建对应的目录。

![image-20211230101032174](https://cdn.fatbobman.com/image-20211230101032174.png)

![image-20211230101053762](https://cdn.fatbobman.com/image-20211230101053762.png)

#### 多 Page 情况时

相对于只有一个 Page 的 Xcode Playground 项目，当包含多个 Page 时，目录结构将发生显著的变化。

![image-20211230101344202](https://cdn.fatbobman.com/image-20211230101344202.png)

为上文创建的 Playground 项目添加新的 Page 后，Playground 项目（NewPlaygrounds）和 Page
将被分开显示。我们将最初的 Page 命名为 Page 1，将新的 Page 命名为 Page 2。

此时在 Xcode 导航栏中可以看到。在项目层级（NewPlaygrounds）下包含有 Sources 和 Resources，同时在每个 Page
下也包含各自的 Sources 和 Resources。此时。 `.playground` 包中的结构将变成如下状态：

![image-20211230101710642](https://cdn.fatbobman.com/image-20211230101710642.png)

原来在根目录下的 Contents. swift 文件不见了，新增了 Pages 目录，并在其中添加了两个与 Page 名称对应的 `.xcplaygroundPage` 包文件。进一步查看 `.xcplaygroundpage` 包内容，可以看到各自拥有一个 Contents.
swift（Page 的主代码文件）。

在 Xcode 中为 Page 1 添加辅助代码和资源文件，Page 1. xcplaygroundpage 包中的内容也将发生改变。

![image-20211230102401629](https://cdn.fatbobman.com/image-20211230102401629.png)

![image-20211230102456108](https://cdn.fatbobman.com/image-20211230102456108.png)

需要注意的是：

- 当添加新的 Page 时，最初在单 Page 状况下添加的辅助代码和资源文件将被保留在项目层级的 Sources 和 Resources 目录中
- 在多 Page 状况删除 Page，即使仅剩一个 Page ，目录结构也不会重新回到 Playground 项目创建时的状态（单 Page），仍将保持多 Page 情况下的目录结构

### 辅助代码的管理和调用

在 Xcode Playground 中，可以将每个 Page 视作一个独立的 mini app（相互之间没有关联），每个 Sources
目录也都被视为一个 Module。

以上文创建的项目为例：

- 项目层级的 Sources 将被编译成 NewPlaygrounds_Sources（项目名称 + `_Sources` ）模块，Page 1 的 Sources 将被编译成 Page 1_PageSources（页面名称 + `_PageSources` ）模块。

- Playground 将为 Page 1 的辅助代码，隐式导入 NewPlaygrounds_Sources

- Playground 将为 Page 1 的主代码（Contents. swift）隐式导入 NewPlaygrounds_Sources 和 Page 1_PagesSources 模块

通俗的来说，在全部 Page 的辅助代码中，均可调用项目的辅助代码。在每个 Page 的主代码中，均可调用项目的辅助代码以及当前 Page 的辅助代码。

因为基于了 Module 的方式进行管理，因此， **只有定义为 public 的代码，才能被非本模块的代码所调用** 。

在项目层级的 Sources 目录 Helper. swift 文件添加如下方法：

    import Foundation

    public func playgroundName() -> String {
        "NewPlaygrounds"
    }

在 Page 1 的 Sources 目录 Page 1 Code. swift 中添加如下方法：

    import Foundation

    public func pageName() -> String {
        playgroundName() + " Page1"
    }

在 Page 1 的主代码中，可以直接调用项目辅助代码模块或 Page 1 辅助代码模块的 public 代码：

    let playgourndName = playgroundName()
    let currentName = pageName()

![image-20211230110445909](https://cdn.fatbobman.com/image-20211230110445909.png)

Playground 会为我们隐式导入所需模块，无需自行 import。当然，你也可以在不同的代码中手动 import 对应的模块以加深理解。

同 Page 的主代码不同，辅助代码并不支持 Playground 的逐行执行、Quick Look 等功能。Playground 在运行 Page
主代码前，会率先完成辅助代码的编译工作（自动）。

其他关于辅助代码需要注意的事项：

- Page 的主代码或辅助代码不可以调用其他 Page 的辅助代码
- 由于每个 Page 可以单独设置运行环境（iOS 或 macOS），因此辅助代码应该与运行环境相兼容，尤其当在一个项目中包含不同运行环境的 Page 时，务必确保项目的辅助代码在不同平台上都可运行。

### 资源文件的组织和注意事项

资源采用同辅助代码一样的目录组织形式，分为 Playground 项目可共享资源和 Page 的专属资源。

保存在项目根目录的 Resource 的资源文件，可以被各个 Page 的主代码及 Page 的辅助代码使用。保存在 Page 的 Resources
目录中的资源，只能被所属 Page 的主代码及辅助代码使用。

Playground 在执行 Page 的代码时，并没有将项目资源和 Page 资源分开存放，而是为每个 Page
创建了一个用来汇总资源的目录，并在其中为该 Page 可用的资源一一创建了链接（替身）。因此， **如果项目资源文件同 Page
专属资源文件重名了，Playground 将无法同时支持两个资源** 。

正因为 Playground 将当前 Page 可访问的资源都汇总到一个目录中，因此，无论是项目资源还是 Page 专属资源，在 Page 主代码或
Page 的辅助代码中，都可以使用 `Bundle.main` 来访问。

下面的代码，可以获取 Page 1 可用资源的汇总目录：

    let url = Bundle.main.url(forResource: "pic", withExtension: "png")

![image-20211230135813553](https://cdn.fatbobman.com/image-20211230135813553.png)

![image-20211230135933606](https://cdn.fatbobman.com/image-20211230135933606.png)

name. json 是 Page 1 的专属资源，pic. png
是项目的资源。都被集中到一起（因此，如果出现重名的话，正常情况下只有专属资源的内容可以被使用）。

Assets 文件（ `.xcassets` ）略有特殊。每个 Page 只能支持一个 Assets。如果 Page 的专属资源中没有 Assets，则
Page 可以使用项目资源中的 Assets。如果 Page 资源中包含了 Assets，无论项目资源中的 Assets 名称如何，都将被忽略。

> 当前，Playground 在处理资源文件更名和删除上有一个 Bug（至少存在于 Xcode 12、Xcode 13 中）。如果在 Xcode
> 中对资源文件进行更名，Playground
> 将在保存替身的目录中为新名称创建一个替身，但并不会删除原来名称的替身。如果将资源文件删除，对应的替身文件并不会删除。因此会出现即使资源名称同代码中调用的名称不符（代码中仍使用原来名称），但仍可获取到文件的情况。目前并没有找到可以重置该替身目录的方法，如需要，可以定位到该目录手动删除无效的替身文件。

在 Swift Playground 中，无法为每个 Page 单独添加资源，所有的资源都会被放置在项目层的 Resources 目录中。如确有为单个
Page 添加资源的需求，可以在 Xcode 或 finder 上添加好后，再于 Swift Playground 中打开。

Playground 会对某些特定格式的资源做预处理（编译），例如 `.xcassets` 、 `.mlmodel` ，处理后的资源可以直接在
Playground 中进行配置和管理。

### 如何使用本地化文件（主要用于 Swift Playgrounds）

同 SPM 对于本地化管理方式类似，只需要在资源文件目录中创建所需语言的目录（例如 `en.lproj` 、 `zh-CN.lproj`
），便可在目录中添加对应语言的字符串文件和资源文件。

![image-20211230144902042](https://cdn.fatbobman.com/image-20211230144902042.png)

当 Swift Playgrounds 执行 Page 的代码时，将根据当前系统的设定，调用正确的资源。

> Xcode Playground 中并没有提供便捷的运行环境区域设置功能。开发者可以使用 UITraitCollection 来对 Xcode
> Playground 中的 iOS 模拟器做一定程度的设置。

### 如何测试 Core Data 代码

如果想在 Playground 中学习和测试 Core Data 的各项功能，需要注意如下事项：

- Playground 不支持 `.xcdatamodeld` 格式的配置文件。需要先在 Xcode 中创建一个 Core Data 项目，编辑好所需的 `.xcdatamodeld` 文件后，编译该项目。将编译后程序包中的 `.momd` 拷贝到 Playground 的资源目录中

![image-20211230151310187](https://cdn.fatbobman.com/image-20211230151310187.png)

- Playground 并不支持自动生成托管对象定义。可以在 Xcode 项目中，使用 Create NSManagedObject Subclass 生成对应的代码，并将代码拷贝到 Playground 的辅助代码中（在定义不复杂的情况下，也可以直接手写）。

![image-20211230151034118](https://cdn.fatbobman.com/image-20211230151034118.png)

## 文档

### 在代码中添加可渲染标注文档

相较标准的 Xcode 项目，Playground 可以对 Page 主代码中特定的标注文档进行渲染。

在 Playground 中添加可渲染标注文档非常简单，只需要在标准的注释标识符后面添加 `:` 即可。

    import Foundation

    /*:
     # Title
     ## Title2
     ### Title3
     * Line 1
     * Line 2
    */

    //: **Bold** *Italic*

    //:[肘子的 Swift 记事本](https://fatbobman.com)

    //:![图片，可以设置显示大小](pic.png width="400" height="209")

    /*:
        // 代码片段
        func test() -> Stirng {
            print("Hello")
        }

     */

    print("Hello world")

在 Xcode 中，通过点击右侧的 Render Documentation 来设置是否启用文档渲染功能。

![image-20211230162340492](https://cdn.fatbobman.com/image-20211230162340492.png)

启用后，上面的代码将显示成如下样式：

![image-20211230162519229](https://cdn.fatbobman.com/image-20211230162519229.png)

> 目前尚不支持在文档标准中使用 Assets 中的图片。

Swift Playgrounds 中渲染文档功能将会一直启用，无法关闭。

> 更多关于可渲染标注代码的资料，请参阅苹果的 [ 官方文档
> ](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html#//apple_ref/doc/uid/TP40016497-CH2-SW1)
> 。

### 如何在多个 Page 之间导航

在多 Page 的状况下，可以在 Page 的主代码中，通过标注实现在各个 Page 之间的导航。

#### 前后导航

下面的代码可实现按导航栏顺序的前后跳转。

    //: [Previous](@previous)

    import Foundation

    var greeting = "Hello, playground"

    //: [Next](@next)

![image-20211230164205461](https://cdn.fatbobman.com/image-20211230164205461.png)

渲染后的状态

![image-20211230164227785](https://cdn.fatbobman.com/image-20211230164227785.png)

在 Page 3 中点击 Previous，将跳转到 Page 2。但点击 Next 将不会发生变化（因为 Page 3 已经是最后一页）。

#### 导航到指定 Page

可以通过直接指定 Page 名称的方式，跳转到指定的页面

    import Foundation

    var greeting = "Hello, playground"

    //: [页面 1](Page1)

    //: [页面 2](Page2)

![image-20211230164542340](https://cdn.fatbobman.com/image-20211230164542340.png)

### 如何隐藏代码（Swift Playgrounds Only）

Swift Playground 具有极强的娱乐和教育属性，提供了若干特殊的标注方法来增强其在课件制作、展示方面的能力。最初这些标注只能用于 `.playgroundbook` ，目前已经可以用于 `.playground` 中。

隐藏代码的作用是，只在 Swift Playground
的代码区域中显示需要使用者了解的代码。将其他暂时无需使用者理会的代码隐藏起来（仍会执行，只是不显示）。

    //#-hidden-code
    import SwiftUI
    import PlaygroundSupport
    var text = "Hello world"
    let view = Text(text).foregroundColor(.red)
    PlaygroundPage.current.setLiveView(view)
    //#-end-hidden-code

    text = "New World"

上面的代码，在 Swift Playground 中只会显示最后一行代码。 `//#-hidden-code` 和 `//#-end-hidden-
code` 之间的代码将被隐藏。

![image-20211230165753928](https://cdn.fatbobman.com/image-20211230165753928.png)

### 如何设置可编辑代码区域（Swift Playgrounds Only）

通过在 Page 代码中设定可编辑区域，使用者将只能在指定的编辑区域中修改代码。

    //#-hidden-code
    import SwiftUI
    import PlaygroundSupport
    var text = "Hello world"
    let view = Text(text).foregroundColor(.red)
    PlaygroundPage.current.setLiveView(view)
    //#-end-hidden-code

    //#-editable-code
    text = "New World"
    //#-end-editable-code
    // 修改字体
    view.font(.title)

使用 `//#-editable-code` 和 `//#-end-editable-code` 来设定可编辑区域。

![image-20211230170228566](https://cdn.fatbobman.com/image-20211230170228566.png)

使用者只能修改矩形框中的代码。可编辑区域外的代码，例如下方的 `view.font(.title)` 显示但不可修改。

> 隐藏代码和设定修改区域在制作交互式文档中的作用巨大，希望 Xcode Playground 能尽早支持上述的标注。

## 使用 Xcode Playground 探索软件包和项目

从 Xcode 12 开始，苹果将 Playground 和 Xcode 的协作带到了全新的高度。通过两者之间的深度整合，Xcode Playground
可以轻松地实现对 SPM 库、Xcode Project 以及 WorkSpace 中的代码、资源进行调用和测试。

### Playground in SPM

库开发者通过在基于 SPM 管理的库中添加 Playground 项目，提供可交互的文档和范例，帮助使用者快速掌握库的用法。

在 WWDC 的专题中，苹果的 Playground 项目开发人员希望未来 Swift 第三方库都可以附带一个基于 Playground 的交互式文档。

在库中添加 Playground 非常简单，在任意位置添加 Playground 项目（ `.playground` ）即可。

![image-20211230185815511](https://cdn.fatbobman.com/image-20211230185815511.png)

使用注意事项：

1. 在 Playground 代码中需要引入库文件

2. 只能调用库中标记为 public 的代码

3. 不能调用库中的资源

4. 不能使用库中调用库中资源的代码

5. 在执行 Playground 代码前，需选择正确的 Target（Target 应与 Playground 设置的运行环境相匹配）

6. 启用 Build Active Scheme，在切换 Target 时自动编译库文件

![image-20211230191332517](https://cdn.fatbobman.com/image-20211230191332517.png)

相较于其他几点，第 4 点略微难理解一点。Playground 在执行 Page 代码的时候尽管会率先将库编译完成，但并没有为库设置正确的资源
Bundle，如果库中的代码尝试调用库资源的时候会报错。目前只适用于无需调用库资源文件的代码。

![image-20211230190514926](https://cdn.fatbobman.com/image-20211230190514926.png)

### Playground with Project

使用注意事项：

1. 在不开启 Import App Types 的情况下，必须导入项目才可调用项目中可公开调用的代码（public）
2. 在开启了 Import App types 的情况下，无需导入项目即可调用项目中的代码（非 Private）
3. 可以调用项目中导入的第三方 Package
4. 不可直接使用项目中的资源
5. 可以通过调用项目中使用项目资源的代码，间接获取项目中的资源
6. 在执行 Playground 代码前，需选择正确的 Target（Target 应与 Playground 设置的运行环境相匹配）
7. 启用 Build Active Scheme，在切换 Target 时自动编译库文件
8. 在执行 Playground 代码前，应确保当前 Target 已经编译

相较 Playground in SPM，不同点包括：

- 开启 Import App Type 后，可以直接使用项目中的代码（无需 public ）
- 可以导入当前 Target 中使用到的其他第三方 Package。
- 通过项目中的代码，可以间接调用项目中的资源

![image-20211230193408447](https://cdn.fatbobman.com/image-20211230193408447.png)

下图中，在项目 MyPlayDemo 中，包含有如下代码（方法、变量都非 public）：

    import Foundation
    import UIKit

    func abc() {
        print("abc")
    }

    let a = 100

    // 读取项目 Assets 中的图片
    func getProjectImage() -> UIImage? {
        UIImage(named: "abc")
    }

在 Playground 中，无需 import 项目名称，可以直接使用项目中的代码（需启用 Import App Types）。

PlaygroundPackageDemo 是当前 Target 中添加的 Package，也可以在 Playground 中直接导入。

![image-20211230193640999](https://cdn.fatbobman.com/image-20211230193640999.png)

### Playground with WorkSpace

有时候，你可能想在工作区中创建 Playground 来测试多个项目或框架。

在 WorkSpace 中使用 Playground 的注意事项：

1. 每个 Page 中只能执行工作区中的一个项目的代码
2. 每个 Page 中可以导入工作区中已编译好且同当前 Page 运行环境兼容的 Package（Package 可以是从不同的的项目中导入）
3. 不可以直接使用项目中的资源
4. 可以通过项目中的代码，间接获取项目中的资源
5. 只能调用具有公开权限的代码（public）
6. 在执行当前 Page 的代码前，需保证当前代码导入的项目、库都已编译完成
7. 在执行当前 Page 的代码前，将 Target 切换到当前代码导入的项目的兼容 Target

![image-20211230204457662](https://cdn.fatbobman.com/image-20211230204457662.png)

上图中，WorkSpace 中有两个项目（DemoiOS 13 和 MyPlayDemo）。

Page 1 中导入了 MyPlayDemo 项目，以及 MyPlayDemo 的依赖项 PlaygroundPackageDemo，项目 DemoiOS
13，以及 SwiftUIOverlayContainer（项目 DemoiOS 13 的依赖项）。

不过只能执行一个项目中的代码（但是可以执行另一个项目中依赖项的代码）。

Playground in SPM、Projcet、WorkSpace 之间并不冲突，你可以直接执行任何层级的 Playground 项目。

![image-20211230205122196](https://cdn.fatbobman.com/image-20211230205122196.png)

### 在 Swift Playgrounds 中使用第三方库

Swift Playground 并不支持直接为 `.playground` 添加第三方库。但可以通过将第三方库 Source 目录下的代码拷贝到
Playground 的 Sources 目录中，实现对第三方库的部分支持。

此种方式仅适用于不使用库资源的第三方库。

![image-20211230205936953](https://cdn.fatbobman.com/image-20211230205936953.png)

上图中，将 [ Plot ](https://github.com/JohnSundell/Plot) 库代码拷贝到了 Playground 的项目
Sources 目录中。全部 Page 均可直接调用 Plot API 而无需导入。

## 总结

不要小看 Xcode Playground，它具有远超想象的能力和效率。

# Ask Apple 2022 中与 Core Data 有关的问答 (上)

Ask Apple 为开发者与苹果工程师创造了在 WWDC 之外进行直接交流的机会。本文对本次活动中与 Core Data
有关的一些问答进行了整理，并添加了一点个人见解。本文为上篇。

## Q&A

### 是否可以在 Core Data 中存储照片

Q：你好，我看到一些网站建议 Core Data 不应该用于保存照片，也许他们没注意到可以使用 “使用外部存储选项（ use external
storage ）“？我正在开发一个应用程序，用户可能一周左右拍一次照片。保存到 Core Data
中或保存到目录哪种更合适？我不想保存到照片库中，因为用户可能不想让别人轻易看到这些照片。

A：在 Core Data 中使用外部存储是可以的。你也可以在 Core Data 中存储一个 URL ，然后自己管理的文件。如果你打算将 URL
传递给其他框架，比如媒体播放器，那么你就应该采用后一种方式。

> 在 Core Data 中开启 Allows External Storage 后， [ 二进制的读取效率是有保障的
> ](https://www.sqlite.org/intern-v-extern-blob.html) 。Core Data 会将大于一定尺寸（ 100
> KB ）的文件保存在文件系统中，并且仅在 BLOB 字段中保存该文件的文件名。文件被保存在与 SQLite 数据库同级创建的一个隐藏目录（
> \_EXTERNAL_DATA ）下。很遗憾， Core Data 并没有提供直接返回这些文件 URL 的 API（ 或将 BLOB 转换成以某种 URL
> 访问的方式 ），因此，当需要将数据以 URL 的方式进行传递时，就需要先将数据写到临时目录后才能进行。因此，是否保存在 Core Data
> 中，取决于你的具体使用场景。对于需要同步的应用来说，如果采用在 Core Data 中保存 URL
> 并将数据保存到目录的方式，需要自己实现外置数据的同步。

### 切换 iCloud 后是否会清空本地数据

Q：在使用 Core Data with CloudKit 的情况下，当用户注销设备上的 iCloud
账户时，NSPersistentCloudKitContainer 将收到删除本地数据的指示。这是有意为之的吗？

A：是的。 NSPersistentCloudKitContainer 在 iCloud 帐户和存储中的数据之间强制执行严格绑定。

> 在 [ 实时切换 Core Data 的云同步状态 ](/zh/posts/real-time-switching-of-cloud-syncs-
> status/) 一文，我介绍过一种实验方法，在某些情况下可以尝试保留这些数据。但最好还是让应用保持 Core Data
> 原有的设计模式。考虑到两者间的强绑定策略，同时为了进一步节省用户的备份空间，可以考虑将 Core Data 数据的 SQLite 文件的
> isExcludedFromBackup（ 取消文件级的云同步 ） 属性设置为 false ，避免多次备份。

### 如何禁用/启用网络同步

Q：对于想要禁用/启用 CloudKit 存储的用户，是否有推荐的方法让应用程序可以实现此操作。

A：不可以。用户可以从应用程序的设置/系统设置中修改应用的 iCloud 同步选项。你可以创建一个没有
NSPersistentCloudKitContainerOptions 描述的
NSPersistentCloudKitContainer，如此一来它将不会进行同步。但是由于 NSPersistentCloudKitContainer
强制将 iCloud 中的数据绑定到持久存储文件。没有办法告诉 NSPersistentCloudKitContainer
在帐户消失后保留本地数据（当用户在禁用该 App 的 iCloud 同步时会发生这种情况 ）。

> 在使用单 Container 的情况下，开发者可以通过 UserDefaults 的方式，控制应用程序在下次冷启动时，是否启用网络同步功能（ 通过设置
> cloudKitContainerOptions 与否 ）。如想实现可实时切换的同步状态，可参阅 [ 实时切换 Core Data 的云同步状态
> ](/zh/posts/real-time-switching-of-cloud-syncs-status/) 一文。

### 如何处理 Container 创建失败

Q：优雅地处理 container. loadPersistentStores 闭包中的错误的方法是什么？ Apple 模板（ Xcode 提供的 Core
Data 模版 ）中有一个 fatalError，并提示它不应该在生产中使用，但如果我的 Core Data Stack
没有正确实例化，我的用户无法对我的应用程序做任何事情。

A：通常这些错误是由于未测试的架构迁移、错误的文件保护等级、磁盘空间不足等原因导致。在这些情况下，应进入恢复步骤以使应用程序再次处于可用状态。另一种方法是向用户显示
UI 存在问题并且需要进行重置。我们的应用程序模板无法为您的应用程序制作良好的 UI，而这几乎就是在此闭包中需要做的事情。

> 在 SwiftUI 中，我们通常会使用 environment 为视图树注入视图上下文，一旦 loadPersistentStores 出现错误导致
> container 无法正常创建，那么调用上下文的注入将会失败，导致无法进入 UI 界面。如需要处理这种情况，就需要在主视图（ 或使用 Core
> Data 功能的根视图 ）对 Container 的状态进行判断（ 通常是在 loadPersistentStores 闭包中修改状态
> ），转入失败提示逻辑。

### 共享数据出现错误

Q：我的问题是关于 Core Data with CloudKit 的。我已经成功使用 NSPersistentCloudKitContainer
实现了用户跨设备同步数据，但在共享数据方面的运气要差得多。我已经查看了两个相关的示例项目，现在可以进行到创建新共享的地步，但是任何管理现有共享的尝试（
即添加人员等 ）似乎总是失败。我在控制台中看到了一些神秘的消息，例如“创建与 PPT 通信所需的 CFMessagePort
时出错”。如果我说尝试进行数据共享，如果 CKShare 不存在，它可以工作 - 万岁！但是，如果我第二次共享并且 CKShare
已经存在，它只会出现永远旋转的风火轮。这既出现于 UICloudSharingController，也出现于较新的
ShareLink/CKShareTransferRepresentation 版本。在示例代码中也看到了类似的问题。我的问题是 -
此种使用方式是否存在已知问题？有什么特别要记住的吗？

A：请使用 sysdiagnose 提交反馈报告以及受影响设备的存储文件。

_不止你一个人。我们在 CKShare 和 NSPersistentCloudKitContainer 上也遇到了很多麻烦。例如，从符合
Transferable 的结构中共享 URL 实例根本不起作用。 ShareLink 只是显示一个空的弹出窗口（ 另一个开发者的吐槽 ）_ 。

> 十分遗憾，苹果在为 Core Data with Cloud
> 添加了数据共享功能后，并没有进一步改善它的表现。目前共享数据的使用体验并不能令人满意。想了解如何共享数据以及了解当前它的限制请阅读 [ 创建与多个
> iCloud 用户共享数据的应用 ](/zh/posts/coredatawithcloudkit-6/) 一文。

### 保存音视频数据的建议方式

Q：在使用 Core Data with CloudKit 时，对于处理音频文件或图像文件存储，是否有任何推荐的方法。我知道对于较大的数据，最好将其存储在
CoreData 本身之外。

A：这取决于它们的大小。假如尺寸超过 100 MB，尽量考虑自己管理文件数据。开发者可以考虑将非常大的文件创建为 CKAsset ，在他们的
NSPersistentCloudKitContainer 同步对象中保存一个外键，以便他们可以查找。这种方法可以减少同步的下载数据量（ 节省设备存储容量
）并允许按需下载。

> 这是 Core Data with CloudKit 与纯 CloudKit API 相结合的一种方式。以图像举例，开发者可以考虑只在 Core
> Data 中保存一个小尺寸的缩率图，将大尺寸图片通过 CloudKit API 以 CKAsset 的方式保存在云端（ 在对应的 Core Data
> 数据中保存一个外链 ），用户在点击图片时，才会从云端将数据下载到本地，并保存在一个缓存目录中。

### 是否有最大同步尺寸或数量限制

Q：Core Data with CloudKit 是否最大同步尺寸限制？我在一个应用程序中尝试它，该应用程序有 30,000 多条记录，但它们无法从
Mac （ 开发状态 ）同步到 iPhone（ 开发状态 ）。

A：如果没有更多细节，很难确定。 NSPersistentCloudKitContainer 和 CloudKit
可以支持比某些限制（如设备存储）多两个数量级的数据。

> 理论上，可以同步的数量和尺寸只上取决于用户的 iCloud 可用容量。在某些情况下，开发者需要在 macOS 上手动开启应用的 iCloud 同步选项（
> 尤其是在开发阶段 ），否则无法与其他的设备进行同步。

### 如何重置本地数据

Q：想象一下，Core Data 正使用 NSPersistentCloudKitContainer
在所有设备上同步我的应用程序数据。假若其中一台设备出现某种故障，需要从云中的数据重置该设备的数据（ 并且有该设备的数据
）。我的应用程序中是否有任何方法可以重置数据的本地缓存副本以假装它是新设备并让 CoreData 再次从云中获取所有数据？

A：使用 NSPersistentStoreCoordinator 的 destroyPersistentStore (at:type:options:)
方法，彻底销毁本地数据库。

> 销毁数据库后，还需要重新在本地创建新的数据库。相较于开发者使用文件管理的方式删除 SQLite 数据，这种方法更加地安全。另外，数据库迁移也可以通过
> NSPersistentStoreCoordinator 的 migratePersistentStore (\_:to:options:type:)
> 方法来实施。

### 如何保存枚举类型

Q：在 Core Data 中存储 Swift 枚举（ 有或没有关联值 ）的推荐方法是什么？

A：一种可能的解决方案是将枚举存储为 Transformable 以处理关联值的情况。在没有枚举值的情况下，通过 rawValue 可以将其转换为 Core
Data 支持的任意属性类型之一。

> 使用 Transformable 处理包含关联值的枚举有一定的局限性，1、有一定的性能损失；2、无法在 Core Data
> 中通过谓词对其进行查询。如果你对查询有特别的需求的话，可以将枚举类型中关联数据打散，在实体中，将所有的关联值都定义成属性，并增加一个与枚举对应的类型属性，在托管对象中定义一个枚举类型的计算属性，通过它对数据进行转换。虽然这种方式会浪费一定的存储空间，但具备转换效率高和可查询的优势。

### 是否可以显示同步进度并手动触发同步

Q：使用 NSPersistentCloudKitContainer 时，是否可以确定当前同步状态或手动触发同步？我希望能够在 UI
中显示进度视图，以便首次启动应用程序的用户可以看到他们的数据正在从云中下载。

A：NSPersistentCloudKitContainerEvent
填补了这个角色。您可以根据需要将通知侦听器绑定到事件以更新和显示状态。无法主动触发同步。

> NSPersistentCloudKitContainer 提供了一个 eventChangedNotification 通知，该通知将在
> import、export、setup 三种状态切换时会提醒我们。严格意义上，我们很难仅通过切换通知来判断当前同步的实际状态。更多内容请参阅 [
> Core Data with CloudKit（四）—— 调试、测试、迁移及其他
> ](/zh/posts/coredatawithcloudkit-4/) 。

### 是否必须添加新版本的 Model

Q：我们什么时候需要添加新的 CoreData model 版本？我看到关于轻量级迁移的相互矛盾的建议，为每个版本添加一个新版本是否更安全？

A：在每个版本中添加一个新的托管对象模型会更安全，但是如果您从一个版本到另一个版本的更改经过充分测试以表明适用于轻量级迁移推断，那么单个托管对象模型就足够了。

> 对于已经上线的应用，最好还是采用手动添加一个新的版本的模式。除了更加安全外，也方便跟踪旧版本模型的变化。

### SwiftUI 下如何使用 FetchedResultsController

Q：是否有在 SwiftUI 应用程序中使用 Core Data 的任何实践或建议？假如广泛使用 Core Data，是否仍应该坚持使用
UIKit。例如，FetchedResultsController 是否有对应的 SwiftUI 版本？

A：在 SwiftUI 中使用 CoreData 没有问题。您可以通过 [ @FetchRequest
](https://developer.apple.com/documentation/swiftui/fetchrequest) 从存储中获取检索结果。

> @FetchRequest 是个让人又爱又恨的东西。它很好用，几乎是在视图中获取数据的首选。但对于 Redux-like
> 框架的使用者来说，它更像一个破坏者，让大量的数据游离于应用的单一状态之外。让单一状态框架与 @FetchRequest 更好地结合目前仍是一个课题。

### 运行 initializeCloudKitSchema 方法的时机

Q：在使用 Core Data with CloudKit 时，如果我在 Core Data Stack 中编辑持久化存储（
例如，为共享对象添加新的持久化存储 ），而不触及实体及其属性，我应该运行 initializeCloudKitSchema 吗？

A：只有对托管对象模型进行更改时才需要 initializeCloudKitSchema。一旦它针对 CKContainer
运行，该容器中的所有数据库都将具有相同的 Schema（ 公共/私有/共享 ）。

> initializeCloudKitSchema 通常是在开发阶段使用的一种方法，而且只需要在数据模型创建或变化后使用一次。当 CKContainer
> 已经创建了对应的 Schema 后，应该在你的代码中删除或注释掉该行代码。另外，initializeCloudKitSchema 还提供了一个
> dryRun 选项，用于在单元测试中检查数据模型是否满足 CloudKit 的要求（ 只比对不上传 ）。

### 多线程的调试手段

Q：调试 Core Data 在多线程方式下的访问错误/崩溃的最佳方式是什么？我一直在使用 `-com.apple.CoreData.Logging.stderr 1` 和 `-com.apple.CoreData.ConcurrencyDebug 1` 参数来提供帮助。还有其他建议吗？

A：ASAN 也将有助于捕获并发问题导致的内存错误。

> 参阅 [ 关于 Core Data 并发编程的几点提示 ](/zh/posts/concurrencyofcoredata/) 了解更多细节。

### 在 App Group 中如何立即反应变化

Q：当通过应用程序扩展（例如，SiriKit/AppIntents ）向存储提交更改时，保证更改立即反映在可能已经运行的主应用程序中的最佳方式是什么（
反之亦然 ）？在应用程序和扩展程序中同时使用 NSPersistentContainer 的 viewContext
是否安全/推荐，或者应使用后台上下文的工作？在我的设置中，存储被保存到一个应用程序组目录中，以允许从应用程序和扩展程序访问，所以我认为每个进程都将利用各自的容器来访问它。

A：这可以使用 [ 本文
](https://developer.apple.com/documentation/coredata/sumption_relevant_store_changes)
中提到方法，通过设置你的 NSPersistentStoreDescription 远程更改选项来实现。

> 持久化历史跟踪正是为类似需求准备的解决方案。参阅 [ 在 CoreData 中使用持久化历史跟踪
> ](/zh/posts/persistenthistorytracking/) 一文，了解更多实现细节。

### 避免在小组件中执行复杂任务

Q：我们遇到了一系列崩溃，因为我们在一个 Widget 进程和一个应用程序进程中启动了相同的 CoreData
堆栈。通常这可以正常工作，但是一旦存储需要迁移（ 我们进行轻量级迁移
），就会出现某种竞争状况，导致应用程序或小组件进程发生崩溃。在一次崩溃之后，迁移似乎可以正常工作，并且没有发生再次崩溃。是否有一个很好的解决方案如何解决这些崩溃？我们不确定
CoreData 是否正确处理了这件事，或者我们是否需要检测迁移并解决这些崩溃问题。

A：不应赋予 Widget 执行轻量级/推断迁移的能力。只有应用程序应该这样做。如果 Widget 遇到需要迁移的 CoreData Store，则
Widget 应重定向以启动应用程序。实际上，小部件永远不会从操作系统获得足够的资源来完成迁移。

> 小组件的运行资源有限，譬如持久化历史事务清除的操作也不应该在小组件中进行处理。

### 持久化历史事务的删除时机

Q：在 [ Consuming Relevant Store Changes
](https://developer.apple.com/documentation/coredata/consuming_relevant_store_changes)
的“清除历史记录”中提到：“因为持久历史跟踪事务会占用磁盘空间，所以确定一个清理策略以在不再需要它们时将其删除”。但是，没有给出明确的提示关于如何在不影响
CloudKit 正确性的情况下以安全的方式清除历史。给出的示例是删除所有超过 7 天的事务。但是，为什么是 7 天？为什么不是 14
天？非常希望一个可靠而具体的示例，说明如何安全地清除历史数据以防止磁盘空间浪费。

A：清除历史记录是由客户决定的。通常，应用每年或每半年清除一次历史记录。你的特定应用程序的写入速率可能需要不同的时间窗口，但是当使用
NSPersistentCloudKitContainer 清除历史记录时，可能会强制将存储文件数据全面同步到 CloudKit，因此不建议经常这样做。

> 无论进行清除的时间间隔为多少，我都不建议开发者清除 CloudKit 为自动同步创建的历史事务（
> 绝大多数情况下，NSPersistentCloudKitContainer 会在确保同步完成后自动进行删除 ）。在进行删除操作时，应在
> NSPersistentHistoryChangeRequest 中，忽略掉由系统产生的事务，只删除应用程序或程序组产生的事务。具体内容请参阅 [ 在
> CoreData 中使用持久化历史跟踪 ](/zh/posts/persistenthistorytracking/) 一文。

### 如何为 NSDictionary 创建模型

Q：我有一个 NSDictionary 值，需要存储在 Core Data 中。使用 Transformable 属性或 Binary Data
属性来存储它，哪个方案更好？ Binary Data 可以选择外部存储，而且我不相信
Transformable。当从存储获取数据时，这两个选项是否都会被加载到内存中？或者支持懒加载（ fault ）？不确定哪个更好用。

A：两者会有相同的内存状况。理想情况下的答案是“两者都不是好的选择” 。如果可能的话，你应该为字典建模（ 使用 Core Data
的方式，创建两个实体，通过关系来映射这个字典 ）。

> 很多情况下，不应将传统的数据组织方式照搬到 Core Data 的 Model 中。尽量用适于 Core Data
> 架构的方式来设计数据结构。尽管可能会有一定的性能损失和容量浪费，但对总体收益会更加有利。例如上面的情况，使用关系的方式来处理有如下优势：1、支持查询；2:
> 在开启同步的情况下，每次修改仅需同步修改部分；3: 无需担心转换性能。

### 是否必须设置逆关系

Q：在数据模型中设置关系的逆关系（ 通常在创建关系时都会设置对应的逆关系 ）有多重要？是否有可以不设置逆关系的相关例子？

A：定义逆向关系使得管理你的图表更容易（ 比如，设置一个“父级”会自动为对象添加为一个“子级” ），并且还允许你委托给 Core Data 进行图表清理（
比如，你想删除一个 “发票” 同时也删除其所有 “项目”
）。如果您不需要这些语义，则不需要逆向，但大多数情况下，双向遍历都很有用。值得注意的是，如果您想使用 CloudKit
同步，则需要明确逆向关系。我强烈建议为所有关系设置逆向关系，直到它对性能产生重大影响时再考虑删除它。

> Core Data with CloudKit 为了突破 CloudKit API 中对于关系数量（ CKRecord. Reference 不能超过
> 750 个 ）的限制，采用了双向关联的方式。因此，只有明确逆关系，Core Data with CloudKit 才能在云端创建正确的 Schema。

### NSPersistentStore 的元数据

Q：NSPersistentStore 的元数据是否保存在磁盘上？可以用其了解设备是否执行了某种云迁移或其他活动吗？

A：Core Data 将元数据存储在存储文件本身中。此元数据归 Core Data
所有，不建议你更改它。如果你愿意，可以将自己的元数据存储在存储文件中，但请注意你的密钥不要与现有的 Core Data
拥有的密钥重叠。元数据受到与存储文件的其余内容相同的数据保护。

> 在有一段时间（ 主要针对文档应用 ），开发者喜欢通过自定义元数据来保存一些选项以方便跨设备使用。阅读 [ Core Data 是如何在 SQLite
> 中保存数据的 ](/zh/posts/tables_and_fields_of_coredata/) 一文，了解更多有关 Core Data
> 元数据的内容。

### 是否有必要同步中间数据

Q：当我使用 Core Data with CloudKit 时，快速保存数千个 GPS 位置的最佳方法是什么？当数据很多时，它会达到服务器极限。

> 冗长的讨论。提问者开发的是一款锻炼用途的应用，他需要在使用者锻炼期间存储所有的位置（坐标、速度、路线、时间戳），以便可以绘制一条折线。但并不需要在所有的设备上保留这些
> GPS 信息（ 仅需要保存对这些数据的汇总信息 ）。苹果的工程师建议他通过创建另一个 Configuration 的方式，将这些数据保存在本地存储中（
> 不进行同步 ），只将汇总后的信息保存在同步存储中。阅读 [ 同步本地数据库到 iCloud 私有数据库
> ](/zh/posts/coredatawithcloudkit-2/) 一文，了解如何通过创建多个 Configuration
> 实现有选择性地同步数据。

### 如何加密数据库

Q：如果我使用 NSPersistentStoreFileProtectionKey: FileProtectionType. complete
来加密我的数据库，当用户将手机数据备份到 iCloud 后，它会以加密格式存储吗？还是仅在设备上加密？

A：NSFileProtection 仅影响设备上数据的加密状态。

> 从 iOS 15 开始，可以在 Model Editor 中将属性启用加密选项（ 不支持老版本的 Model 升级）。在使用 Core Data
> with CloudKit 时，该属性的值将在 iCloud 中以加密的形式进行保存。Core Data 目前并不支持对 SQLite 进行加密。

### NSExpression 的 Bug

Q：我应该如何看待 NSExpression 中的 CAST 函数？这是我应该积极使用的功能吗？例如，如果我写 `CAST(now(),
'NSNumber')` 意图在当前时间做数学运算，我会收到 “Don’t know how to cast to NSNumber” 的错误。

A：这是一个很好的问题。我们建议您将其发布在开发者论坛中，Apple 工程师将在此进行整周的监控，并能够为您提供进一步的帮助。这似乎值得一个错误报告

> 使用 NSExpressionDescription ，可以在 SQLite 中对记录进行一定的计算，并将计算结果通过
> NSFetchRequestResult 进行返回。阅读 [在 Core Data 中查询和使用 count 的若干方法](在 Core Data
> 中查询和使用 count 的若干方法) 一文，查看使用案例。

### 合并策略 or 选择性更新

Q：当前我们的 Core Data Stack 采用了 NSMergeByPropertyStoreTrumpMergePolicy
合并策略，它本质上是替换一个已经存储在我们存储中并在从 API 中拉下时由唯一约束标识的对象。另一种方法是通过获取请求（ fetch request
）确定对象是否已经存在，如果存在，则更新现有记录，如果不存在则创建新记录。在 Apple 看来，哪种方式是处理记录创建和更新的首选方式？

A：每种方法都有优点和缺点。一般来说，首先获取记录（ 通过 Core Data 在存储中检查数据是否存在
）往往非常昂贵。如果您必须这样做，则必须批量获取。在此流程中一次获取一条记录将非常缓慢。

> 如果 Core Data 内置的合并策略无法满足你的需求时，创建自定义合并策略或许是不错的选择。

### 在多对多关系中创建谓词

Q：我的视频实体与标签具有多对多关系，并且我有一个带有一些标签 ID 的数组。我想获取在这组标签 ID 中至少有一个标签的所有视频。如何创建一个
NSPredicate 来表示这个？

A：或许可以尝试一下 `ANY tag.name IN %@` 。

> %@ 对应的是标签数组。应该用 Core Data 的逻辑来组织数据并创建谓词，Core Data 会将谓词转换成对应的 SQL 语句。

### 动态修改 @FetchRequest 的配置

Q：在 SwiftUI 应用程序中，如何基于 @AppStorage 值创建 @FetchRequest？用例是：当我打开 Focus 过滤器时，我将
@AppStorage 值更改为用户希望在我的应用程序中看到的标签列表。如果我可以创建一个带有与此 @AppStorage 的值相关联的谓词的
@FetchRequest，则谓词将自动更新，并更新我的视图。目前我无法做到这一点，哪种解决方法能获得类似的结果？

A：@FetchRequest 的谓词属性是一个 Binding，它会在更改时重绘视图。

> 从 Swift 3.0 开始，FetchRequest 支持在视图中动态修改它的谓词和排序描述。例如上面的问题，可以通过在 task (id:) 中更改
> request 的配置。

### uriRepresentation

Q：我现在正在为我的应用程序实现一个 URL 方案，我想提供一个打开特定 Core Data 对象的 URL。有没有比在我的 URL 方案中使用 `NSManagedObject.objectID.uriRepresentation().absoluteString` 作为标识符更好的方法。

A：我想这也是我会做的。

> 使用 NSPersistentStoreCoordinator 的 managedObjectID (forURIRepresentation: )
> 方法，可以将 URL 转换回对应的 NSManageObjectID。阅读 [ 在 Spotlight 中展示应用中的 Core Data 数据
> ](/zh/posts/spotlight/) ，了解更多细节。

### 在同步状态下，如何进行大版本迁移

Q：嗨，在使用 Core Data 和 CloudKit 堆栈时遇到了一个关于迁移的问题。如果我们不再关心本地数据，是否可以从与 CloudKit
同步的数据模型中删除未使用的实体？在我们的例子中，我们首先从实体中删除所有数据（ 也就是将该数据迁移到新实体
），然后从项目中删除该实体，因为我们可以确定所有用户都已升级。

A：是的，但是，旧版本的应用程序会做什么？从用户角度，旧版本将写入新版本从未见过的数据，而新版本将写入旧版本从未见过的数据。您将如何向您的用户解释这种差异？

> 在使用 Core Data with CloudKit 时，对数据模型最好采用只增不改不减的调整原则。如果确实需要对数据模型有破坏性的修改，最好创建两个
> Container（ 分别使用不同的 Model ），在使用者确保原始数据都同步到本地后，再将旧数据转换至新的 Container 之上。

### 是否可以为共享数据创建单独的 CKRecordZone

Q：我有一个基于文档的应用程序。每个文档都是一个包含唯一 Core Data 存储的包。我想使用 Core Data 的内置 CloudKit 同步 API
分别同步每个文档。如何为每个文档创建唯一的 CKRecordZone ？

A：当前的 NSPersistentCloudKitContainer 不支持这样的用法。

> 或许可以考虑使用纯粹的 CloudKit API 来实现他的需求。

### 是否可以使用 @unchecked Sendable 标注 NSManagedObjectID

Q：在可以确保 NSManagedObjectID 不是临时状态的情况下，是否可以使用 @unchecked Sendable 对其进行标注。

A：它应该是。请提交错误报告。

> 在 Core Data 中，NSManagedObjectID 是线程安全的。通过向其他的上下文传递 ID，并通过该 ID
> 在不同线程的上下文中获取托管对象，这样可以确保应用不会出现崩溃。

## 总结

Ask Apple 中有关 Core Data
的问题应该不是太多，我提的几个问题都获得了解答。希望苹果今后可以经常性地举办类似的活动，大家也应该更踊跃地进行参与。

# Core Data with CloudKit（四）—— 调试、测试、迁移及其他

本文聊一下在开发 `Core Data with CloudKit` 项目中常见的一些问题，让大家少走弯路、避免踩坑。

## 控制台日志信息

![log](https://cdn.fatbobman.com/log.gif)

一个支持 `Core Data with CloudKit` 的项目，控制台输出将常态化地成为上图状态。

每个项目面对的情况不同且信息中的废话较多，因此我仅就可能的信息种类做一下归纳。

### 正常情况的信息

- **初始化信息**

代码启动后，通常首先出现在控制台的便是 `NSPersistentCloudKitContainer` 展示的初始化信息。包括：成功在指定 `url` 创建了容器，成功启用了 `NSCloudKitMirroringDelegate` 同步响应等。如果是首次运行项目，还会有成功在 `iCloud` 上创建了 `Schema` 之类的提示。

- **数据模型迁移信息**

如果本地和服务器端的数据模型不一致，会出现迁移提醒。有时即使本地的 `Core Data` 模型和 `iCloud` 上的模型一致，也会看到类似 `Skipping migration for 'ANSCKDATABASEMETADATA' because it already has a column
named 'ZLASTFETCHDATE'` 之类的信息，表示无需迁移。

- **数据同步信息**

会详细描述导入、导出的具体的内容，信息比较好理解。应用程序端或服务器端任何数据发生变动都会出现对应的信息。

- **持久化历史跟踪信息**

`NSPersistentCloudKitContainer` 使用持久化历史跟踪来管理导入导出事务，在数据同步信息的左右经常会伴随包含 `NSPersistentHistoryToken` 之类的提示。另外类似 `Ignoring remote change notification
because the exporter has already caught up to this transaction: 11 / 11 -
<NSSQLCore: 0x7ff73e4053b0>` 的信息也是持久化历史跟踪产生的，容易让人误以为总有事务没有处理。关于 `Persistent
History Tracking` 可以阅读我另一篇文章 [ 在 CoreData 中使用持久化历史跟踪
](/zh/posts/persistenthistorytracking/) 。

### 可能的不正常情况的信息

- **初始化错误**

比较常见的有，无法创建或读取 `sqlite` 文件产生的本地 `url` 错误以及 `CKContainerID` 权限问题。如果 `url` 指向 `appGroupContainer` ，一定要确认 `appGroupID` 正确，且 `app` 已获得 `group`
权限。 `CKContainerID` 权限问题通常使用 [ 之前文章 ](/zh/posts/coredatawithcloudkit-2/)
中提到的重置 `Certificates,Identifiers&Profiles` 中的配置来解决。

- **模型迁移错误**

正常情况下， `Xcode` 不会让你生成同 `CloudKit` 的 `Schema` 不兼容的 `ManagedObjectModel`
，所以多数情况下，都是由于在开发环境下，本地的数据模型和服务器端的数据模型不匹配导致的问题（比如更改了某个属性名称、或者使用了较老的开发版本等）。在确认代码版本正确的情况下，可采取删除本地
`app` ，重置 `CloudKit`
端开发环境的方法来解决。但如果你的应用程序已经上线，应尽量避免此类问题的发生可能。请考虑后文中的更新数据模型提供的模型迁移策略。

- **合并冲突**

请检查是否设置了正确的合并冲突策略 `NSMergeByPropertyObjectTrumpMergePolicy` ？是否从 `CloudKit` 控制台对数据做出了错误的修改？如仍处于开发阶段，可采用和上面一样的方式解决。

- **iCloud 账号或网络错误**

`iCloud` 没登录， `iCloud` 服务器没响应，iCloud 账号受限等。以上问题多数都是开发人员这端无法解决的。 `NSPersistentCloudKitContainer` 会在 `iCloud`
账户登录后自动恢复同步。在代码中进行账号状态检查，并提醒用户登录账号。

## 关闭日志输出

在确认同步功能代码已正常工作的情况下，如无法忍受控制台的信息轰炸，可尝试关闭 `Core Data with CloudKit`
的日志输出。调试任何使用 `Core Data` 的项目，我都推荐大家为项目添加如下的默认参数：

![image-20210810152755744](https://cdn.fatbobman.com/image-20210810152755744-8580476.png)

- **-com.apple.CoreData.ConcurrencyDebug**

及时发现由托管对象或上下文线程错误而导致的问题。执行任何可能导致错误的代码时，应用程序会立刻崩溃，帮助在开发阶段清除隐患。启用后，控制台会显示 `CoreData: annotation: Core Data multi-threading assertions enabled.`

- **-com.apple.CoreData.CloudKitDebug**

`CloudKit` 调试信息输出级别，从 1 开始，数字越大信息愈详尽

- **-com.apple.CoreData.SQLDebug**

`CoreData` 发送到 `SQLite` 的实际 `SQL`
语句，1——4，数值越大越详细。输出提供的信息在调试性能问题时很有用——特别是它可以告诉你什么时候 `Core Data`
正在执行大量的小提取（例如当单独填充 `fault` 时）。

- **-com.apple.CoreData.MigrationDebug**

迁移调试启动参数将使您在控制台中了解迁移数据时的异常情况。

- **-com.apple.CoreData.Logging.stderr**

信息输出开关

设置 `-com.apple.CoreData.Logging.stderr 0` ，所有的同数据库有关日志信息都将不再输出。

## 关闭网络同步

在程序开发阶段，我们有时候并不想被数据同步所打扰。增加网络同步控制参数方便提高专注力。

当 `NSPersistentCloudKitContainer` 载入没有配置 `cloudKitContainerOptions` 的 `NSPersistentStoreDescription` 时，它的行为同 `NSPersistentContainer`
是一致的。通过使用类似下面的代码，可在调试中控制是否启用数据网络同步功能。

    let allowCloudKitSync: Bool = {
            let arguments = ProcessInfo.processInfo.arguments
            guard let index = arguments.firstIndex(where: {$0 == "-allowCloudKitSync"}),
                  index + 1 < arguments.count - 1 else {return true}
            return arguments[index + 1] == "1"
        }()

    if allowCloudKitSync {
                cloudDesc.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: "iCloud.fatobman.blog.SyncDemo")
            } else {
                cloudDesc.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
                cloudDesc.setOption(true as NSNumber,
                                    forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
            }

因为 `NSPersistentCloudKitContiner` 会自动启用持久化历史跟踪的，如没有设置 `NSPersistentCloudKitContainerOptions` ，必须在代码中显式启用 `Persistent History
Tracking` ，否则数据库会变成只读。

![image-20210810155946312](https://cdn.fatbobman.com/image-20210810155946312-8582387.png)

设置为 `0` 将关闭网络同步。

本地数据库的更改在恢复同步功能后，仍将会同步到服务器端。

## 同步不正常

当网络同步不正常时，请先尝试做以下检查：

- 网络连接是否正常
- 设备是否已登录 `iCloud` 账户
- 同步私有数据库的设备是否登录的是同一个 `iCloud` 账号
- 检查日志，是否有错误提示，尤其是服务器端的
- 模拟器不支持后台静默推送，将模拟器中的 `app` 切换至后台再切换回来，看看是否有数据

如果还是找不到原因的话，请泡壶茶、听听歌、看看远方，过一会可能就好了。

苹果服务器抽风的频率并不低，推送延迟不必惊讶。

## 检查用户账户状态

`NSPersistentCloudKitContainer` 会在 `iCloud` 账号可用时自动恢复网络同步。通过代码检查用户的 `iCloud` 账户登录情况，在应用程序中提醒用户进行账户登录。

调用 `CKContainer.default().accountStatus` 检查用户 `iCloud` 账号状态，订阅 `CKAccountChanged` ，在登录成功后取消提醒。譬如

        func checkAccountStatus() {
            CKContainer.default().accountStatus { status, error in
              DispatchQueue.main.async {
                switch status {
                case .available:
                   accountAvailable = true
                default:
                   accountAvailable = false
                }
                if let error = error {
                    print(error)
                }
              }
            }
        }

## 检查网络同步状态

`CloudKit` 没有提供详尽的网络同步状态 `API` ，开发者无法获得例如有多少数据需要同步、同步进度等信息。

`NSPersistentCloudKitContainer` 提供了一个 `eventChangedNotification` 通知，该通知将在
`import` 、 `export` 、 `setup` 三种状态切换时提醒我们。严格意义上，我们很难仅通过切换通知来判断当前同步的实际状态。

在实际的使用中，对用户感知影响最大的是数据导入状态。当用户在新设备上安装了应用程序，并且已经在网络上保存有较多数据时，面对完全没有数据的应用程序用户会感到很茫然。

数据会在应用程序启动后 20-30 秒开始导入，如果数据量较大，用户很可能会在 1-2 分钟后才会在 UI 上看到数据（批量导入通常会在整批数据都导入后才会
`merge` 到上下文中）。因此为用户提供足够的提示尤为重要。

在实际使用中，当导入状态结束后，会切换到其他的状态。利用类似如下的代码，尝试给用户提供一点提示。

    @State private var importing = false
    @State private var publisher = NotificationCenter.default.publisher(for: NSPersistentCloudKitContainer.eventChangedNotification)

    var body:some View{
      VStack{
         if importing {
            ProgressView()
         }
      }
      .onReceive(publisher){ notification in
         if let userInfo = notification.userInfo {
            if let event = userInfo["event"] as? NSPersistentCloudKitContainer.Event {
                if event.type == .import {
                  importing = true
                }
                else {
                  importing = false
                }
             }
          }
       }
    }

> 当应用程序被切到后台时，同步任务仅能继续执行 30
> 秒左右，在切换回前台后数据会继续进行同步。因此当数据较多时，需做好用户的提示工作（比如保持在前台，或让用户继续等待）。

## 创建默认数据集

有的应用程序会为用户提供一些默认的数据，比如说起始数据集，或者演示数据集。如果提供的数据集是放置在可同步的数据库中时需要谨慎处理。比如，已经在一台设备上创建了默认数据集并进行了修改，当在新设备上再次安装并运行应用程序时，处理不当可能导致数据被异常覆盖，或者重复。

- **确认数据集是否一定需要被同步**

如无需同步可以考虑采用 [ 同步本地数据库到 iCloud 私有数据库 ](/zh/posts/coredatawithcloudkit-2/)
一文中，有选择的同步数据解决方案。

- **如数据集必须要同步**

  1. 最好引导用户手动点击创建默认数据按钮，让用户自行判断是否需要再度创建。

  2. 也可在应用程序首次运行时，利用 `CKQuerySubscription` 通过查询特定记录判断网络数据库中是否已有数据（此方法是在前几天和一个网友交流时他采用的方法，不过该网友对返回响应并不满意，用户感知不太好）。

  3. 或许可考虑通过使用 `NSUbiquitousKeyValueStore` 进行判断。

> 2、3 两种方式都需要保证网络及账号状态正常的情况下才能检查，让用户自行判断或许最为简单。

## 移动本地数据库

已经在 `AppStore` 上架的应用程序，在某些情况下有移动本地数据库到其他 `URL` 的需求。比如，为了让 `Widget`
也可以访问数据库，我将 [ 健康笔记 ](/healthnotes/) 的数据库移动到了 `appGroupContainerURL` 。

如果使用 `NSPersistentContainer` ，可以直接调用 `coordinator.migratePersistentStore`
即可安全完成数据库文件的位置转移。但如果对 `NSPersistentCloudKitContainer` 加载的 `store`
调用此方法，则必须强制退出应用程序后再次进入方可正常使用（虽然数据库文件被转移，但迁移后会告知加载 `CloudKit container`
错误，无法进行同步。需重启应用程序才能正常同步）。

因此正确的移动方案是，在创建 `container` 之前，采用 `FileManager` 将数据库文件移动到新位置。需同时移动 `sqlite` 、 `sqlite-wal` 、 `sqlite-shm` 三个文件。

类似如下代码：

    func migrateStore() {
            let fm = FileManager.default
            guard !FileManager.default.fileExists(atPath: groupStoreURL.path) else {
                return
            }

            guard FileManager.default.fileExists(atPath: originalStoreURL.path) else {
                return
            }

            let walFileURL = originalStoreURL.deletingPathExtension().appendingPathExtension("sqlite-wal")
            let shmFileURL = originalStoreURL.deletingPathExtension().appendingPathExtension("sqlite-shm")
            let originalFileURLs = [originalStoreURL, walFileURL, shmFileURL]
            let targetFileURLs = originalFileURLs.map {
                groupStoreURL
                    .deletingLastPathComponent()
                    .appendingPathComponent($0.lastPathComponent)
            }

            // 将原始文件移动到新的位置。
            zip(originalFileURLs, targetFileURLs).forEach { originalURL, targetURL in
                do {
                    try fm.moveItem(at: originalURL, to: targetURL)
                } catch error {
                    print(error)
                }
            }
    }

## 更新数据模型

在 [ CloudKit 仪表台 ](/zh/posts/coredatawithcloudkit-3/) 一文，我们已经探讨过 `CloudKit`
的两种环境设置。一旦将 `Schema` 部署到生产环境，开发者便无法对记录类型和字段进行重命名或者删除。
**必须仔细规划你的应用程序，保证其在对数据模型进行更新时仍做到向前兼容** 。

不可以随心所欲地修改数据模型，对实体、属性尽量做到：只加、不减、不改。

可以考虑以下的模型更新策略：

### 增量更新

以增量的方式添加记录类型或向现有记录类型添加新字段。

采用这种方式，旧版本的应用程序仍可以访问用户创建的记录，但不是每个字段。

请确保新增的属性或实体都只服务于新版本的新功能，且即使没有这些数据，新版本程序仍可可正常运行（如此时用户仍使用旧版本更新数据，新添加的实体和属性都不会有内容）。

### 增加 version 属性

这个策略是上一个策略的加强版。通过一开始在实体上添加 `version`
属性，对实体进行版本控制，通过谓词仅提取与应用程序当前版本兼容的记录。旧版本程序将不会提取新版本创建的数据。

例如，实体 `Post` 具备 `version` 属性

    // 当前的数据版本。
    let maxCompatibleVersion = 3

    context.performAndWait {
        let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: "Post")

        // 提取不大于当前版本的数据
        fetchRequest.predicate = NSPredicate(
            format: "version <= %d",
            argumentArray: [maxCompatibleVersion]
        )

        let results = context.fetch(fetchRequest)
    }

### 锁定数据，提示升级

利用 `version` 属性，应用程序可以很容易知道当前的版本已经不满足数据模型的需要。它可以禁止用户修改数据，并提示用户更新应用程序版本。

### 创建新 CKContainer 及新的本地存储

如果你的数据模型发生了巨大的变化，采用上述方式已经很难处理，或者上述方式会造成巨大的数据浪费时，可以为应用程序添加一个新的关联容器，并通过代码将原始数据转移到新容器上。

大概的流程为：

- 在应用程序中添加新的 `xcdatamodeld` （此时应该有两个模型，旧模型对应旧容器，新模型对应新容器）
- 为应用程序添加新的关联容器（同时使用两个容器）
- 判断是否已经迁移，如果没有迁移则让应用程序通过旧模型和容器正常运行
- 让用户选择迁移数据（提醒用户须确保旧数据都已经同步到本地再执行迁移）
- 通过代码将旧数据转移到新容器和本地存储中，标记迁移完成（使用两个 `NSPersistentCloudKitContainer` ）
- 切换数据源

> 无论采用上述哪种策略，都应该不计一切代价避免数据丢失、混乱。

## 总结

本文中的问题，是我在开发过程中碰到并已尝试解决的。其他的开发者还会碰到更多的未知情况，只要能掌握其规律，总是可以找到解决之法。

在下一篇文章中，我们聊一下 **同步公共数据库**

# 几个在 SwiftUI 中使用惰性容器的技巧和注意事项

在 SwiftUI 的框架中，惰性布局容器，如 List 和
LazyVStack，提供了一种高效展示大型数据集的方法。这些容器的设计精妙，它们仅在必要时才动态地构建和加载视图，从而显著优化了应用的性能和内存使用效率。本文将探讨一些实用技巧和重要注意事项，旨在赋予开发者利用
SwiftUI 惰性容器时增强应用响应性和资源管理的能力。

## 自定义遵循 RandomAccessCollection 的实现

在某些情况下，我们的数据源可能无法直接与 SwiftUI 的 ForEach 构造器兼容。由于 ForEach 需要数据源遵循 `RandomAccessCollection` 协议以支持高效的随机访问索引操作, 因此我们需要为不兼容的数据源自定义一个遵循该协议的数据类型,
从而优化性能和内存使用。

以 [ Swift Collection ](https://github.com/apple/swift-collections) 库中的
OrderedDictionary 为例, 它结合了字典高效的键值存储和有序集合的特性。如果直接将它转换为数组, 可能会导致不必要的内存增加,
尤其在处理大型数据集时更为明显。通过自定义一个符合 RandomAccessCollection 协议的类型, 我们可以有效地管理内存,
同时保持高效的数据处理能力。

下面是一个实现和使用这样自定义集合的示例:

    // 创建 DictDataSource,符合 RandomAccessCollection 的最小实现
    final class DictDataSource<Key, Value>: RandomAccessCollection, ObservableObject where Key: Hashable {
        typealias Index = Int

        private var dict: OrderedDictionary<Key, Value>

        init(dict: OrderedDictionary<Key, Value>) {
            self.dict = dict
        }

        var startIndex: Int {
            0
        }

        var endIndex: Int {
            dict.count
        }

        subscript(position: Int) -> (key: Key, value: Value) {
            dict.elements[position]
        }
    }

    // 使用方式
    let responses: OrderedDictionary<Int, String> = [
        200: "OK",
        403: "Access forbidden",
        404: "File not found",
        500: "Internal server error",
    ]

    struct OrderedCollectionsDemo: View {
        @StateObject var dataSource = DictDataSource(dict: responses)
        var body: some View {
            List {
                ForEach(dataSource, id: \.key) { element in
                    Text("\(element.key) : \(element.value)")
                }
            }
        }
    }

通过这种方式, 我们不仅优化了大型数据集的处理效率, 还减少了内存占用, 提高了应用的整体响应能力。除了 OrderedDictionary,
其他自定义数据结构如链表、树等, 同样可以通过类似方式实现随机访问的数据源适配器, 以更好地配合 ForEach 的使用。

## 实现无限数据加载

在开发过程中，我们经常遇到需要实现无限数据加载的场景，这意味着根据用户的滚动或需求动态地加载新的数据集。这种机制不仅有助于优化内存使用，还能显著提升用户体验，特别是在处理大量数据时。

通过引入自定义的 `RandomAccessCollection` 实现，我们可以直接在数据源层面嵌入动态加载逻辑。以下展示的 `DynamicDataSource` 类遵循 `RandomAccessCollection` 协议，并在数据接近末尾时自动触发更多数据的加载。

    struct Item: Identifiable, Sendable {
      let id = UUID()
      let number: Int
    }

    final class DynamicDataSource: RandomAccessCollection, ObservableObject {
      typealias Element = Item
      typealias Index = Int

      @Published private var items: [Item]
      private var isLoadingMoreData = false
      private let threshold = 10 // 设置触发加载更多数据的阈值

      init(initialItems: [Item] = []) {
        items = initialItems
      }

      var startIndex: Int {
        items.startIndex
      }

      var endIndex: Int {
        items.endIndex
      }

      func formIndex(after i: inout Int) {
        i += 1
        // 触发条件，在访问到小于最后数据 10 的索引值数据时加载新数据
        if i >= (items.count - threshold) && !isLoadingMoreData && !items.isEmpty {
          loadMoreData()
        }
      }

      subscript(position: Int) -> Item {
        items[position]
      }

      private func loadMoreData() {
        guard !isLoadingMoreData else { return }

        isLoadingMoreData = true

        // 模拟异步加载新数据
        Task {
          try? await Task.sleep(for: .seconds(1.5))
          let newItems = (0 ..< 30).map { _ in Item(number: Int.random(in: 0 ..< 1000)) }
          await MainActor.run { [weak self] in
            self?.items.append(contentsOf: newItems)
            self?.isLoadingMoreData = false
          }
        }
      }
    }

在视图中的使用演示如下，随着用户的滚动，新数据会被动态加载到列表中：

    struct DynamicDataLoader: View {
      @StateObject var dataSource = DynamicDataSource(initialItems: (0 ..< 50).map { _ in Item(number: Int.random(in: 0 ..< 1000)) })
      var body: some View {
        List {
          ForEach(dataSource) { item in
            Text("\(item.number)")
          }
        }
      }
    }

通过上述方法，我们成功实现了动态数据加载逻辑与视图渲染逻辑的分离，从而使代码结构更加清晰和易于维护。这种实现模式的适用性极广，不仅可以用于数据模拟，还能轻松扩展以适应更多实际需求，如从网络加载数据、实现数据的分页加载。

## `id` 修饰器对 List 懒加载机制的影响

在 SwiftUI 中，List 视图依赖懒加载机制来优化性能和用户体验。懒加载机制确保只有在子视图即将出现在可视区域时，SwiftUI
才会创建这些视图的实例并将它们加载到视图树中。然而，在一些特定情况下，这一优化机制可能会被意外破坏，尤其是当子视图使用了 `id` 修饰器时。

考虑下面的示例，我们给 `ItemSubView` 添加了 `id` 修饰器。结果是，List
会立即为所有项目实例化子视图，虽然它只为当前可见的子视图渲染内容（ 对 body 求值 ）：

    struct LazyBrokenView: View {
      @State var items = (0 ..< 50).map { Item(number: $0) }
      var body: some View {
        List {
          ForEach(items) { item in
            ItemSubView(item: item)
              .id(item.id)
          }
        }
      }
    }

    struct ItemSubView: View {
      let item: Item
      init(item: Item) {
        self.item = item
        print("\(item.number) init")
      }

      var body: some View {
        let _ = print("\(item.number) update")
        Text("\(item.number)")
          .frame(height: 30)
      }
    }

尽管 List 的懒加载机制仅对可见视图渲染，但在数据量庞大时，立即实例化所有子视图会导致巨大的性能开销，严重影响应用的初始加载效率。

> 如果在使用 `ScrollViewReader` 或需要唯一标识视图的其他场合中不得不使用 `id`
> ，应考虑采用其他方法来减轻懒加载特性的损失。更多优化技巧，请参阅 [ 优化在 SwiftUI List 中显示大数据集的响应效率
> ](/zh/posts/optimize_the_response_efficiency_of_list/) 。

虽然 `id` 修饰器会影响 List 的懒加载特性，但它在 `LazyVStack` 、 `LazyVGrid`
等其他惰性布局容器中的使用是安全的。

此外，WWDC2023 中引入的 `ScrollView` 的新功能，如 `scrollPosition(id:)` ，在 List 中也会触发类似
`id` 的效果，处理大数据集时应谨慎使用这些特性。更多细节可参考 [ 深入了解 SwiftUI 5 中 ScrollView 的新功能
](/zh/posts/new-features-of-scrollview-in-swiftui5/) 。

综上所述，在充分利用 SwiftUI
的惰性容器优势时，我们必须注意这些潜在的陷阱，特别是在需要展示大量数据的场景中，否则可能会严重影响应用程序的性能和用户体验。

## 在惰性容器中，SwiftUI 仅保留 ForEach 子视图最顶层的状态

在 SwiftUI 的惰性容器使用中，特别是当子视图由多层视图结构组成并通过 `ForEach`
构建时，一个重要的细节需要注意：这些视图在离开可视区域并再次出现时，SwiftUI 只会保留最顶层视图中的状态。

这意味着，在如下代码示例中， `RootView` 作为 `ForEach` 循环中的子视图，包含了另一个视图 `ChildView` 。根据
SwiftUI 的设计，当 `RootView` 离开后重新进入可视区域，只有位于 `RootView` 中的状态会被保持，而嵌套在 `ChildView` 内部的状态将被重置：

    struct StateLoss: View {
      var body: some View {
        List {
          ForEach(0 ..< 100) { i in
            RootView(i: i)
          }
        }
      }
    }

    struct RootView: View {
      @State var topState = false
      let i: Int
      var body: some View {
        VStack {
          Text("\(i)")
          Toggle("Top State", isOn: $topState)
          ChildView()
        }
      }
    }

    struct ChildView: View {
      @State var childState = false
      var body: some View {
        VStack {
          Toggle("Child State", isOn: $childState)
        }
      }
    }

我最初认为这种行为应该是 Bug，但根据与苹果工程师的交流反馈，这实际上是一种有意为之的设计决策。从 SwiftUI
的设计哲学来看，这种选择有其合理性。为了在渲染效率和资源消耗之间取得平衡，保持子视图树中所有状态对于拥有复杂视图树和大量子视图的惰性容器来说，可能会大大降低效率。因此，决定仅维护最顶层子视图的状态，算是一种合理的设计选择。

因此，对于拥有多层且状态丰富的子视图结构，推荐的做法是将所有相关状态提升到顶层视图中，以确保状态的正确保持：

    struct RootView: View {
      @State var topState = false
      @State var childState = false
      let i: Int
      var body: some View {
        VStack {
          Text("\(i)")
          Toggle("Top State", isOn: $topState)
          ChildView(childState: $childState)
        }
      }
    }

    struct ChildView: View {
      @Binding var childState: Bool
      var body: some View {
        VStack {
          Toggle("Child State", isOn: $childState)
        }
      }
    }

这样的做法不仅遵循 SwiftUI 的设计原则，还确保了即使在复杂的视图层次中，应用的状态也能被正确管理和保留。

## 针对特定类型的状态, SwiftUI 释放内存资源不够积极

在 Swift 开发者的普遍认识中，将可选值类型的变量设置为 `nil`
应当能够触发系统回收原有数据占用的资源。因此，一些开发者在面对可能造成重大资源占用的惰性视图时, 尝试利用此机制来节省内存。下面的示例展示了这种做法：

    struct MemorySave: View {
      var body: some View {
        List {
          ForEach(0 ..< 100) { _ in
            ImageSubView()
          }
        }
      }
    }

    struct ImageSubView: View {
      @State var image: Image?
      var body: some View {
        VStack {
          if let image {
            image
              .resizable()
              .frame(width: 200, height: 200)
          } else {
            Rectangle().fill(.gray.gradient)
              .frame(width: 200, height: 200)
          }
        }
        .task {
          // 模拟加载不同的图片
          if let uiImage = createImage() {
            image = Image(uiImage: uiImage)
          }
        }
        .onDisappear {
          // 在离开可视区域时，设置为 nil
          image = nil
        }
      }

      func createImage() -> UIImage? {
        let colors: [UIColor] = [.black, .blue, .yellow, .cyan, .green, .magenta]
        let color = colors.randomElement()!
        let size = CGSize(width: 1000, height: 1000)
        UIGraphicsBeginImageContextWithOptions(size, false, 0)
        color.setFill()
        UIRectFill(CGRect(origin: .zero, size: size))
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return image
      }
    }

尽管状态被设置为 `nil` ，但在惰性容器中，某些特定类型的数据（如 `Image` 、 `UIImage`
等）并不会立即释放其占用的内存空间，除非完全离开该惰性容器视图。这种情况下，通过转换状态类型，可以改善资源回收的积极性：

    struct ImageSubView: View {
      @State var data:Data?
      var body: some View {
        VStack {
          if let data,let uiImage = UIImage(data: data) {
            Image(uiImage: uiImage)
              .resizable()
              .frame(width: 200, height: 200)
          } else {
            Rectangle().fill(.gray.gradient)
              .frame(width: 200, height: 200)
          }
        }
        .task {
          // 模拟加载不同的图片，转换成的 Data 类型
          if let uiImage = await createImage() {
            data = uiImage
          }
        }
        .onDisappear {
          data = nil
        }
      }

      func createImage() async -> Data? {
        let colors: [UIColor] = [.black, .blue, .yellow, .cyan, .green, .magenta]
        let color = colors.randomElement()!
        let size = CGSize(width: 1000, height: 1000)
        UIGraphicsBeginImageContextWithOptions(size, false, 0)
        color.setFill()
        UIRectFill(CGRect(origin: .zero, size: size))
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return image?.pngData()
      }
    }

在上述代码中，通过改变状态持有的类型为 `Optional<Data>` ，使得在状态设为 `nil`
后系统能够正常回收占用的资源，从而改善了内存使用情况。

> 详细的分析和问题探讨可以参见 [ SwiftUI + Core Data App 的内存占用优化之旅 ](/zh/posts/memory-usage-
> optimization/) 。

通过这种方法，我们可以有效地控制内存使用，特别是在大量数据或资源被惰性视图加载时，确保应用的性能和响应速度。

> 一些读者可能会考虑利用本文介绍的惰性容器仅保留最顶层状态的特性来解决内存占用问题。然而，遗憾的是，对于这些特定的类型，即使状态被“遗忘”，它们所占用的内存也不会被及时释放。因此，这种方法并不适用于解决特定类型内存不被积极释放的问题。

## 总结

虽然 SwiftUI
为开发者提供了极大的便利，使得创建动态和响应式的用户界面变得更加简单，但正确地理解和利用其惰性布局容器的工作机制，仍然是开发高效、性能优异的 SwiftUI
应用的关键。希望本文能够帮助开发者更好地掌握这些技巧，优化 SwiftUI 应用，确保既能提供丰富的功能，又能保持流畅的用户体验和高效的资源使用。

# SwiftUIOverlayContainer ——可以实现各种自定义样式弹出视图的 SwitUI 库

SwiftUI 目前可以提供 sheet, fullScreenCover, alert, actionsheet 等弹出视图用于丰富 UI
交互。不过种类还是有些单调。为了能够更方便的编写各种弹出式窗口的代码，我写了一个简单的 SwiftUI 库 ——
SwiftUIOverlayContainer。

> SwiftUIOverlayContainer 已经更新至 2.0 版本，详情请看 [ SwiftUIOverlayContainer 2.0
> ](/zh/posts/swifui-overlay/)

SwiftUIOverlayContainer
本身并不提供任何预置的视图样式，不过通过它，你有充分的自有度来实现自己需要的视图效果。OverlayContainer
的主要目的在于帮助你完成动画、交互、样式定制等基础工作，使开发者能够将时间和精力仅需投入在视图本身的代码上。

[ SwiftUIOverlayContainer
](https://github.com/fatbobman/SwiftUIOverlayContainer)

你的浏览器不支持本视频

库代码已经修改可以直接在 Xcode 11 下使用

代码思路受到了 [ PartialSheet
](https://link.zhihu.com/?target=https%3A//github.com/AndreaMiotto/PartialSheet)
很大的影响，并使用了其部分代码。

## 使用方法

- Add a **OverlayContainerManager** instance as an _environment object_ to your Root View in you _SceneDelegate_ or App

  @main
  struct Test: App {
  let manager = OverlayContainerManager()
  var body: some Scene {
  WindowGroup {
  ContentView()
  .environmentObject(manager)
  }
  }
  }

- Add the **OverlayView** to your _Root View_ , and if you want give it a style. In your RootView file at the end of the builder add the following modifier:

  struct ContentView: View {

      var body: some View {
         ...
         .addOverlayContainer(style: <OverlayContainerStyle>)
      }

  }

- In anyone of your views add a reference to the _environment object_ and than just call the `showOverlayView<T>(_ onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping () -> T) where T: View` func whenever you want like this:

  @EnvironmentObject var manager: OverlayContainerManager

  ...

  Button(action: {
  self.manager.showOverlayView({
  print("dismissed")
  }) {
  VStack{
  Text("This is Overlay View")
  }
  }
  }, label: {
  Text("Show overlyView")
  })

### 样式说明

    let style2 = OverlayContainerStyle(
                                       alignment: .leading,  //容器对齐位置
                                       coverColor: Color.gray.opacity(0.3), //覆盖色
                                       shadow:.init (color: Color.black.opacity(0.3), radius: 20, x: 2, y: 0), //阴影样式
                                       blur: nil,  //模糊样式
                                       animation: .easeInOut ,  //动画曲线
                                       transition:.move(edge:.leading),  //进出动画效果
                                       animatable: true,  //是否显示动画
                                       autoHide: nil,  //是否自动隐藏，可设置秒数
                                       enableDrag: true,  //是否允许滑动取消，目前只支持 .leading,.trailing,.bottom,.top
                                       clickDismiss: true) //是否支持显示后，点击屏幕其他位置取消

更多具体应用，请参看代码 DEMO

# ObservableObject 研究 —— 想说爱你不容易

本文主要研究在 SwiftUI 中，采用单一数据源 (Single Source of Truth) 的开发模式，ObservableObject
是否为最佳选择。是否可以在几乎不改变现有设计思路下进行新的尝试，以提高响应效率。最后提供了一个仍采用单一数据源设计思路但完全弃用
ObservableObject 的方式。

> 请不要被本文的名称所误导。本文撰写于 SwiftUI 问世的第二年，内容主旨是探讨在当时的情况下，如何减少因 ObservableObject
> 所带来的不必要的视图更新，后面我还创作了另外两篇有关优化方面的内容： [ 避免 SwiftUI 视图的重复计算
> ](/zh/posts/avoid_repeated_calculations_of_swiftui_views/) 、 [ 深度解读
> Observation —— SwiftUI 性能提升的新途径 ](/zh/posts/mastering-observation/)

## 单一数据源

我是在去年阅读王巍写的 [ 《SwiftUI 与 Combine 编程》 ](https://objccn.io/products/swift-ui)
才第一次接触到 **单一数据源** 这一概念的。

- 将 app 当作一个状态机，状态决定用户界面。

- 这些状态都保存在一个 Store 对象中，被称为 State。

- View 不能直接操作 State，而只能通过发送 Action 的方式，间接改变存储在 Store 中的 State。

- Reducer 接受原有的 State 和发送过来的 Action，生成新的 State。

- 用新的 State 替换 Store 中原有的状态，并用新状态来驱动更新界面。

![Redux 架构](https://cdn.fatbobman.com/observableObject-study-reduximage.gif)

在该书中结合作者之前 Redux、RxSwift 等开发经验，提供了一个 SwiftUI 化的范例程序。之后我也继续学习了一些有关的资料，并通过阅读
Github 上不少的开源范例，基本对这一方式有所掌握，并在 [ 健康笔记
](https://apps.apple.com/cn/app/id1534513553) 中得以应用。总的来说，当前在 SwiftUI
框架下，大家的实现手段主要的不同都体现在细节上，大的方向、模式、代码构成基本都差不多：

- Store 对象遵守 ObservableObject 协议

- State 保存在 Store 对象中，并使用 @Published 进行包装。从而在 State 发生变化时通知 Store

- Store 对象通过 @ObservedObject 或 @EnvironmentObject 与 View 建立依赖

- Store 对象在 State 变化后通过 objectWillChange 的 Pbulisher 通知与其已建立依赖关系的 View 进行刷新

- View 发送 Action -> Recudcer (State, Action) -> newState 周而复始

- 由于 SwiftUI 的双向绑定机制，数据流并非完全单向的

- 在部分视图中可以结合 SwiftUI 通过的其他包装属性如@FetchRequest 等将状态局部化

后两项是利用 SwiftUI 的特性，也可以不采用，完全采用单向数据流的方式

基于以上方法，在 SwiftUI 中进行单一数据源开发是非常便利的，在多数情况下执行效率、响应速度都是有基本保证的。不过就像我在上一篇文章 [ @State
研究 ](/zh/posts/swiftui-state/) 中提到过的， **当随着动态数据量的增大、与 Store 保有依赖关系的 View
数量提高到一定程度后，整个 app 的响应效率便会急剧恶化。**

恶化的原因主要有以下几点：

1. 对于遵循 ObservableObject 对象的依赖注入时机
2. View 的精细化
3. 依赖通知接口唯一性。State（状态集合）中任何的单一元素发生变化都将通知所有与 Store 有依赖的 View 进行重绘。

我就以上几点逐条进行分析。

## 对于遵循 ObservableObject 对象的依赖注入时机

在 [ @State 研究 ](/zh/posts/swiftui-state/) 中的
**什么时候建立的依赖？**章节中，我们通过了一段代码进行过@State 和@ObservedObject
对于依赖注入时机的推测。结果就是通过使用@ObservedObject 或@EnvironmentObject 进行的依赖注入，编译器没有办法根据当前
View 的具体内容来进行更精确的判断，只要你的 View 中进行了声明，依赖关系变建立了。

    struct MainView: View {
        @ObservedObject var store = AppStore()

        var body: some View {
            print("mainView")
            return Form {
                SubView(date: $store.date)
                Button("修改日期") {
                    self.store.date = Date().description
                }
            }
        }
    }

    struct SubView: View {
        @Binding var date: String
        var body: some View {
            print("subView")
            return Text(date)
        }
    }

    class AppStore:ObservableObject{
        @Published var date:String = Date().description
    }

执行后输出如下：

    mainView
    subView
    mainView
    subView
    ...

更详细的分析请参见 [ @State 研究 ](/zh/posts/swiftui-state/)

**即使你只在 View 中发送 action，并没有显示 State 中的数据或使用其做判断，该 View
也会被强制刷新。甚至，如果你像我一样，忘了移除在 View 中的声明，View 也同样会被更新。**

如果类似的 View 比较多，你的 app 将会出现大量的无效更新。

## View 的精细化

这里所指的 View 是你自己构建的遵循 View 协议的结构体。

在 SwiftUI 下开发，无论是主观还是客观都需要你将 View 的表述精细化，用更多的子 View
来组成你的最终视图，而不是把所有的代码都尽量写在同一个 View 上。

### 主观方面

- 更小的耦合性

- 更强的复用性

### 客观方面

#### ViewBuilder 的设计限制

FunctionBuilder 作为 Swift 5.1 的重要新增特性，成为了 SwiftUI 声明式编程的基础。它为在 Swift 代码中实现 DSL
带来了极大的便利。不过作为一个新生产物，它目前的能力还并不十分的强大。目前它仅提供非常有限的逻辑语句。

    if {} else {}
    if {}
    ? :
    ForEach //唯一的循环能力，有诸多的限制

> SwiftUI 2 中已经提供了 `switch if let` 等更方便的判断语句

在编写代码中，为了能够实现更多逻辑和丰富的 UI，我们必须把代码分散到各个 View 中，再最终合成。否则你会经常获得无法使用过多逻辑等等的错误提示。

#### 以 Body 为单位的优化机制

SwiftUI 为了减少 View 的重绘其实做了大量的工作，它以 View 的 body 为单位进行非常深度的优化（body 是每个 View
的唯一入口；View 中使用 `func -> some View` 无法享受优化，只有独立的 View 才可以）。SwiftUI
在程序编译时便已将所有的 View 编译成 View 树，它尽可能的只对必须要响应状态变化的 View（@State
完美的支持）进行重绘工作。用户还可以通过自行设置 Equatable 的比对条件进一步优化 View 重绘策略。

#### Xcode 的代码实时解析能力限制

如果你在同一个 View 中写入了过多的代码，Xcode 的代码提示功能几乎就会变得不可用了。我估计应该是解析 DSL 本身的工作量非常大，我们在 View
body 中写的看起来不多的描述语句，其实后面对应的是非常多的具体代码。Xcode 的代码提示总会超出了它合理的计算时间而导致故障。此时只需把 View
分解成几个 View，即使仍然在同一个文件中，Xcode 的工作也会立刻正常起来。

#### 预览的可靠性限制

新的预览功能本来会极大的提升布局及调试效率，但由于其对复杂代码的支持并不完美，将 View 分割后，通过使用合适的 Preview
控制语句可以高效、无错的对每个子 View 进行独立预览。

从上面几点看，无论从任何角度，更精细化的 View 描述都是十分合适的。

**但由于在单一数据源的情况下，我们将会有更多的 View 和 Store 建立依赖。众多的依赖将使我们无法享受到 SwiftUI 提供的 View
更新优化机制。**

有关 View 优化的问题大家可以参考 [ 《SwiftUI 编程思想》 ](https://objccn.io/products/thinking-in-
swiftui) 一书中 View 更新机制的介绍，另外 [ swiftui-lab ](https://swiftui-
lab.com/equatableview/) 上也有探讨 Equality 的文章。

## 依赖通知接口唯一性

State（状态集合）中任何的单一元素的变化都将通知所有与 Store 有依赖的 View 进行重绘。

使用@Published 对 State 进行了包装。在 State 的值发生变化后，其会通过 Store（ObservableObject 协议）提供的
ObjectWillChangePublisher 发送通知，所有与其有依赖的 View 进行刷新。

    class AppStore:ObservableObject{
        @Published var state = State()
          ...
    }

    struct State{
        var userName:String = ""
        var login:Bool = false
        var selection:Int = 0
    }

对于一个并不复杂的 State 来说，尽管仍有无效动作，但整体效率影响并不大，但是如果你的 app 的 State 里面内容较多，更新较频繁，View
的更新压力会陡然增大。尤其 State 中本来很多数据的变化性是不高的，大量的 View 只需要使用变化性低的数据，但只要 State
发生任何改动，都将被迫重绘。

## 如何改善

在发现了上述的问题后，开始逐步尝试找寻解决的途径。

### 第一步减少注入依赖

针对只要声明则就会形成依赖的的问题，我第一时间想到的就是减少注入依赖。首先不要在代码中添加不必要的依赖声明；对于那些只需要发送 Action 但并不使用
State 的 View，将 store 定义成全部变量，无需注入直接使用。

    //AppDelegate 中
    lazy var store = Store()

    //
    let store = (UIApplication.shared.delegate as! AppDelegate).store
    struct ContentView:View{
      var body:some View{
        Button("直接使用 Action"){
          store.dispatch(.test)
        }
      }
    }

    //其他需要依赖注入的 View 则正常使用
    struct OtherView:View{
      @EnvironmentObject var store:Store
      var boyd:some View{
        Text(store.state.name)
      }
    }

#### 第二步将无必要性的状态区域化

听起来这条貌似背离了单一数据源的思想，不过其实在 app 中，有非常多的状态仅对当前 View 或小范围的 View
有效。如果能够合理的进行设计，这些状态信息在自己的小区域中完全可以很好地自我管理，自我维持。没有必要统统汇总到 State 中。

在区域范围内来创建被维持一个小的状态，主要可以使用以下几种手段：

- 善用@State

在 [ @State 研究 ](/zh/posts/swiftui-state/) 这篇文章中，我们讨论了 SwiftUI 对于@State
的优化问题。如果设计合理，我们可以将无关大局的信息，保存在局部 View。同时通过对@State 的二度包装，我们同样可以完成所需要的副作用。该 View
的子 View 如果使用了@Binding，也只对局部的 View 树产生影响。

另外也可以将常用的 View 修饰通过 ViewModifier 进行包装。ViewModifier 可以维持自己的@State，可以自行管理状态。

- 创建自己的@EnviromentKey 或 PreferenceKey，仅注入需要的 View 树分支

同 EnviromentObject 类似，注入 EnviromentKey 的依赖也是显性的

          @Environment(\.myKey) var currentPage

我们可以通过以下方式，更改该 EnvironmentKey 的值，但作用范围仅针对当前 View 下面的子 View 分支

        Button("修改值"){
        self.currentPage = 3
      }
      SubView()
          .environment(\.myKey, currentPage)

EnvironmentObject 也是可以在任意某个分支注入依赖的，不过由于其是引用类型，通常任何分支的改动，都仍然会对整个 View
树其他的使用者造成影响。

同理，我们也可以使用 PreferenceKey，只将数据注入到当前 View 之上的层级。

值类型无论如何都要比引用类型都更可控些。

- 在当前 View 使用 SwiftUI 提供的其他包装属性

我现在最常使用的 SwiftUI 的其他包装属性就属@FetchRequest 了。除了必要的数据放置于 State 中，我对于 CoreDate
的大多数据需求都通过该属性包装器来完成。@FetchRequest
目前有不足之处，比如无法进行更精细的批量指定、明确惰性状态、获取限制等，不过相对于它带来的便利性，我还是完全可以接受的。FetchRequest
完全可以实现同其他 CoreData NSFetchRequest 一样的程序化 Request 设定，结合上面的方式同样可以将 Request 生成器放在
Store 中而不影响当前 View。

          struct SideView: View {
          @Environment(\.managedObjectContext)
          var context

          @State var search: Search?

          var body: some View {
              VStack(alignment: .leading) {
                  SearchView(
                      onSearch: self.onSearch
                  )
                  InsideListView(fetchRequest: makeFetchRequest())  //根据上面的 search 来生成不同谓词对应的 fetchrequest.
              }
          }

          private func makeFetchRequest() -> FetchRequest<Book> {
              let predicate: NSPredicate?
              if let search = search {
                  let textPredicate = NSPredicate(format: "string CONTAINS[cd] %@", search.text)
                  let appPredicate = NSPredicate(format: "appName == %@", search.app)
                  let typePredicate = NSPredicate(format: "type == %@", search.type)

                  var predicates: [NSPredicate] = []
                  if search.text.count >= 3 {
                      predicates.append(textPredicate)
                  }

                  if search.app != Constants.all {
                      predicates.append(appPredicate)
                  }

                  if search.type != Constants.all {
                      predicates.append(typePredicate)
                  }

                  predicate = NSCompoundPredicate(andPredicateWithSubpredicates: predicates)
              } else {
                  predicate = nil
              }

              return FetchRequest<Book>(
                  entity: Book.entity(),
                  sortDescriptors: [
                      NSSortDescriptor(keyPath: \Book.date, ascending: false)
                  ],
                  predicate: predicate
              )
          }

          private func onSearch(_ search: Search) {
              if search.text.count < 3 && search.type != Constants.all && search.app != Constants.all {
                  self.search = nil
              } else {
                  self.search = search
              }
          }
      }

      private struct InsideListView: View {
          @Environment(\.managedObjectContext)
          var context

          var fetchRequest: FetchRequest<Book>    //只声明，内容需要由调用者来设定

          var body: some View {
              List(items) {
                  ForEach
             }
          }

          private var items: FetchedResults<Book> {
              fetchRequest.wrappedValue
          }
      }

我相信，下一步 SwiftUI 应该还会提供更多的直接将状态控制在局部的包装器。

#### 第三步和 ObservedObject 说再见

只要我们的 View 还需要依赖单一数据源的 State，前面我们做努力就都付之东流了。但坚持单一数据源的设计思路又是十分明确的。由于任何状态的变化
ObservedObject 只有通过 ObjectWillChangePublisher 这一个途径来通知与其依赖的
View，因此我们如果要解决这个问题，只能放弃使用 ObservedObject，通过自己创建视图和 State
中每个独立元素的依赖关系，完成我们的优化目的。

Combine 当然是首选。我希望达到的效果如下：

- State 仍然以目前的形式保存在 Store 中，整个程序的结构基本和使用 ObservedObject 一样
- State 中每个元素可以自己通知与其依赖的 View 而不通过@Published
- 每个 View 可以根据自己的需要同 State 中的元素建立依赖关系，State 中其他无关的变化不会导致其被强制刷新
- State 中的数据仍然支持 Binding 等操作，而且能够支持各种形式的结构设定

基于以上几点，我最终采用了如下的解决方案：

1、Store 不变，只是去掉了 ObservedObject

    class Store{
      var state = AppState()
      ...
    }

2、State 结构如下

    struct AppState{
      var name = CurrentValueSubject<String,Never>("肘子")
      var age = CurrentValueSubject<Int,Never>(100)
    }

通过使用 CurrentValueSubject 来创建指定类型的 Publisher。

3、通过如下方式注入

    //当前 View 只需要显示 name
    struct ContentView:View{
      @State var name:String = ""
      var body:some View{
        Form{
          Text(name)
        }
        .onReceive(store.state.name, perform: { name in
                    self.name = name
                })
      }
    }

我们需要显式的在每个 View 中把需要依赖的元素单独通过。onReceive 获取并保存到本地。

4、修改 State 中的值

    //基于 View-> Action 来修改 State 的机制
    extension Store{
      //例程并非遵循 action，不过也是调用 Store，意会即可
      fune test{
         state.name.value = "大肘子"
      }
    }

    //在上面的 ContentView 中添加
    Button("修改名字"){
      store.test()
    }

5、支持 Binding

    extension CurrentValueSubject{
        var binding:Binding<Output>{
            Binding<Output>(get: {self.value}, set: {self.value = $0})
        }
    }
    //使用 binding

    TextField("姓名",text:store.state.name.binding)

6、对结构体支持 Binding

    struct Student{
        var name = "fat"
        var age = 18
    }

    struct AppState{
          var student = CurrentValueSubject<Student,Never>(Student())
    }

    extension CurrentValueSubject{
        func binding<Value>(for keyPath:WritableKeyPath<Output,Value>)->Binding<Value>{
                   Binding<Value>(get: {self.value[keyPath:keyPath]},
                                  set: { self.value[keyPath:keyPath] = $0})
        }
    }

    //使用 Binding
    TextField("studentName:",text: store.state.student.binding(for: \.name))

7、对于更复杂的 State 元素设计的 Binding 支持。如果你却有必要在 State 中创建以上 Binding
方式无法支持的格式可以通过使用我另一篇文章中 [ @State 研究 ](/zh/posts/swiftui-state/)
最后创建的增强型@MyState 来完成特殊的需要，你对本地的 studentAge 做的任何改动都将自动的反馈到 State 中

    struct ContentView:View{
      @MyState<String>(wrappedValue: String(store.state.student.value.age), toAction: {
            store.state.student.value.age = Int($0) ?? 0
        }) var studentAge
      var body:some View{
         TextField("student age:",text: $studentAge)
      }
    }

至此我们便达成了之前设定的全部目标。

- 只对原有的程序结构做微小的调整

- State 中每个元素都会在自改动时独立的发出通知

- 每个 View 可以只与自己有关的 State 中的元素创建依赖

- 对 Binding 的完美支持

#### 追加：减少代码量

在实际的使用中，上述解决方案会导致每个 View 的代码量有了一定的增长。尤其是当你忘了写。onReceive
时，程序并不会报错，但同时数据不会实时响应，反倒增加排查错误的难度。通过使用属性包装器，我们可以将 Publisher
订阅和变量声明合二为一，进一步的优化上述的解决方案。

    @propertyWrapper
    struct ObservedPublisher<P:Publisher>:DynamicProperty where P.Failure == Never{
        private let publisher:P
        @State var cancellable:AnyCancellable? = nil

        @State public private(set) var wrappedValue:P.Output
        private var updateWrappedValue = MutableHeapWrapper<(P.Output)->Void>({ _ in })

        init(publisher:P,initial:P.Output) {
            self.publisher = publisher
            self._wrappedValue = .init(wrappedValue: initial)

            let updateWrappedValue = self.updateWrappedValue
            self._cancellable = .init(initialValue:  publisher
                .delay(for: .nanoseconds(1), scheduler: RunLoop.main)
                .sink(receiveValue: {
                    updateWrappedValue.value($0)
                }))
        }

        public mutating func update() {
            let _wrappedValue = self._wrappedValue
            updateWrappedValue.value = {
                _wrappedValue.wrappedValue = $0}
        }

    }

    public final class MutableHeapWrapper<T> {
        public var value: T

        @inlinable
        public init(_ value: T) {
            self.value = value
        }
    }

上面的代码来自于开源项目 SwiftUIX，我对其进行了很小修改使其能够适配 CurrentValueSubject

使用方法

    @ObservedPublisher(publisher: store.state.title, initial: "") var title

至此，我们进一步的减少了代码量，并且基本消除了由于漏写。onReceive 而可能出现的问题。

上述代码我已经放到了 [ Github ](https://github.com/fatbobman/MySingleSoureOfTruthDemo)

## 总结

之所以进行这方面的探讨是由于我的 app 出现了响应的粘滞（和我心目中 iOS 平台上该有的丝滑感有落差）。在研究学习的过程中也让我对 SwiftUI
的有了进一步的认识。无论我提出的思路是否正确，至少整个过程让我获益匪浅。

在我做这方面学习的过程中，恰好也发现了另外一位朋友提出了类似的观点，并提出了他的解决方案。由于他之前有 RxSwift
上开发大型项目的经验，他的解决方案使用了快照（SnapShot）的概念。注入方式采用 EnvironmetKey，对于 State
元素的无效修改（比如说和原值相同）做了比较好的过滤。可以到 [ 他的博客 ](https://nalexn.github.io/swiftui-
observableobject/) 查看该文。

最后希望 Apple 能够在将来提供更原生的方式解决以上问题。

# 在 CoreData 中使用持久化历史跟踪

## 前言

> **2022 年 2 月更新** ：我已经重写了代码，并将其整理成库 [ PersistentHistoryTrackingKit
> ](https://github.com/fatbobman/PersistentHistoryTrackingKit) 以方便大家使用。

知道持久化历史跟踪功能已经有一段时间了，之前简单地浏览过文档但没有太当回事。一方面关于它的资料不多，学习起来并不容易；另一方面也没有使用它的特别动力。

在计划中的 [ 【健康笔记 3】 ](/healthnotes/) 中，我考虑为 App 添加 Widget 或者其他的
Extentsion，另外我也打算将 WWDC 21 上介绍的 NSCoreDataCoreSpotlightDelegate 用到 App
的新版本中。为此就不得不认真地了解该如何使用持久化历史跟踪功能了。

## 什么是持久化历史跟踪（Persistent History Tracking）

> 使用持久化历史跟踪（Persistent History Tracking）来确定自启用该项功能以来，存储（Store）中发生了哪些更改。 ——
> 苹果官方文档

在 CoreData 中，如果你的数据保存形式是
Sqlite（绝大多数的开发者都采用此种方式）且启用了持久化历史跟踪功能，无论数据库中的数据有了何种变化（删除、添加、修改等），调用此数据库并注册了该通知的应用，都会收到一个数据库有变化的系统提醒。

## 为什么要使用它

持久化历史跟踪目前主要有以下几个应用的场景：

- 在 App 中，将 App 的批处理（BatchInsert、BatchUpdate、BatchDelete）业务产生的数据变化合并到当前的视图上下文（ViewContext）中。

批处理是直接通过协调器（PersistentStoreCoordinator）来操作的，由于该操作并不经过上下文（ManagedObejctContext），因此如果不对其做特别的处理，App
并不会及时的将批处理导致的数据变化在当前的视图上下文中体现出来。在没有 Persistent History Tracking
之前，我们必须在每个批处理操作后，使用例如 `mergeChanegs` 将变化合并到上下文中。在使用了 Persistent History
Tracking 之后，我们可以将所有的批处理变化统一到一个代码段中进行合并处理。

- 在一个 App Group 中，当 App 和 App Extension 共享一个数据库文件，将某个成员在数据库中做出的修改及时地体现在另一个成员的视图上下文中。

想象一个场景，你有一个汇总网页 Clips 的 App，并且提供了一个 Safari Extentsion 用来在浏览网页的时候，将合适的剪辑保存下来。在
Safari Extension 将一个 Clip 保存到数据库中后，将你的 App（Safari 保存数据时，该 App
已经启动且切换到了后台）切换到前台，如果正在显示 Clip 列表，最新的（由 Safari Extentsion 添加）Clip
并不会出现在列表中。一旦启用了 Persistent History Tracking，你的 App
将及时得到数据库发生变化的通知、并做出响应，用户便可以在第一时间在列表中看到新添加的 Clip。

- 当使用 PersistentCloudKitContainer 将你的 CoreData 数据库同 Cloudkit 进行数据同步时。

Persistent History Tracking 是实现 CoreData 同 CloudKit 数据同步的重要保证。无需开发者自行设定，当你使用
PersistentCloudKitContainer 作为容器后，CoreData 便已经为你的数据库启用了 Persistent History
Tracking 功能。不过除非你在自己的代码中明确声明启用持久化历史跟踪，否则所有网络同步的数据变化都并不会通知到你的代码，CoreData
会在后台默默地处理好一切。

- 当使用 NSCoreDataCoreSpotlightDelegate 时。

在今年的 WWDC 2021 上，苹果推出了 NSCoreDataCoreSpotlightDelegate，可以非常便捷的将 CoreData 中的数据同
Spotlight 集成到一起。为了使用该功能，必须为你的数据库开启 Persistent History Tracking 功能。

## Persistent History Tracking 的工作原理

为持久化存储启用 Persistent History Tracking 后，你的应用程序将开始为 Core Data
的持久化存储中发生的任何更改创建事务记录（ Transaction ）。无论该事务是由何种方式（通过上下文还是不经过上下文）产生的，由那个 App 或
Extension 产生，都将事无巨细的记录下来。

所有的变化都会被保存在你的 Sqlite 数据库文件中，苹果在 Sqlite 中创建了几个表，用来记录了 Transaction 对应的各类信息。

![image-20210727092416404](https://cdn.fatbobman.com/image-20210727092416404-7349058.png)

苹果并没有公开这些表的具体结构，不过我们可以使用 Persistent History Tracking 提供的 API
来对其中的数据进行查询、清除等工作。

> 如果有兴趣也可以自己看看这几个表的内容，苹果将数据组织的非常紧凑的。 `ATRANSACTION` 中是尚未消除的 transaction， `ATRANSACTIONSTRING` 中是 author 和 contextName 的字符串标识， `ACHANGE`
> 是变化的数据，以上数据最终转换成对应的 ManagedObjectID。

Transaction 将按照产生顺序被自动记录。我们可以检索特定时间后发生的所有更改。你可以通过多种表达方式来确定这个时间点：

- 基于令牌（Token）
- 基于时间戳（Timestamp）
- 基于交易本身（Transaction）

一个基本的 Persistent History Tracking 处理流程如下：

1. 响应 Persistent History Tracking 产生的 NSPersistentStoreRemoteChange 通知
2. 检查从上次处理的时间戳后是否仍有需要处理的 Transaction
3. 将需要处理的 Transaction 合并到当前的视图上下文中
4. 记录最后处理的 Transaction 时间戳
5. 择机删除已经被合并的 Transaction

## App Groups

在继续聊 Persisten History Tracking 之前，我们先介绍一下 App Groups。

由于苹果对 App 采取了严格的沙盒机制，因此每个 App，Extension 都有其自己的存储空间。它们只能读取自己沙盒文件空间的内容。如果我们想让不同的
App，或者在 App 和 Extension 之间共享数据的话，在 App Groups 出现之前只能通过一些第三方库来进行简单的数据交换。

为了解决这个问题，苹果推出了自己的解决方案 App Groups。App Group 让不同的 App 或者 App&App Extension
之间可以通过两种方式来共享资料（必须是同一个开发者账户）：

- UserDefauls
- Group URL（Group 中每个成员都可以访问的存储空间）

绝大多数的 Persistent History Tracking 应用场合，都是发生在启用了 App Group 的情况下。因此了解如何创建 App
Grups、如何访问 Group 共享的 UserDefaults、如何读取 Group URL 中的文件非常有必要。

### 让 App 加入 App Groups

在项目导航栏中，选择需要加入 Group 的 Target，在 Signing&Capabilities 中，点击 `+` ，添加 App Group
功能。

![image-20210726193034435](https://cdn.fatbobman.com/image-20210726193034435-7299035.png)

在 App Groups 中选择或者创建 group

![image-20210726193200091](https://cdn.fatbobman.com/image-20210726193200091-7299122.png)

_只有在 Team 设定的情况下，Group 才能被正确的添加。_

App Group Container ID 必须以 `group.` 开始，后面通常会使用逆向域名的方式。

如果你有开发者账号，可以在 App ID 下加入 App Groups

![image-20210726193614636](https://cdn.fatbobman.com/image-20210726193614636-7299375.png)

其他的 App 或者 App Extension 也都按照同样的方式，指定到同一个 App Group 中。

### 创建可在 Group 中共享的 UserDefaults

    public extension UserDefaults {
        /// 用于 app group 的 userDefaults, 在此处设定的内容可以被 app group 中的成员使用
        static let appGroup = UserDefaults(suiteName: "group.com.fatbobman.healthnote")!
    }

`suitName` 是你在前面创建的 App Group Container ID

在 Group 中的 App 代码中，使用如下代码创建的 UserDefaults 数据，将被 Group 中所有的成员共享，每个成员都可以对其进行读写操作

    let userDefaults = UserDefaults.appGroup
    userDefaults.set("hello world", forKey: "shareString")

### 获取 Group Container URL

     let groupURL = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "group.com.fatbobman.healthnote")!

对这个 URL 进行操作和对于 App 自己沙盒中的 URL 操作完全一样。Group 中的所有成员都可以在该文件夹中对文件进行读写。

> 接下来的代码都假设 App 是在一个 App Group 中，并且通过 UserDefaults 和 Container URL 来进行数据共享。

## 启用持久化历史跟踪

启用 Persistent History Tracking 功能非常简单，我们只需要对 NSPersistentStoreDescription
`进行设置即可。

以下是在 Xcode 生成的 CoreData 模版 `Persistence.swift` 中启用的例子：

       init(inMemory: Bool = false) {
            container = NSPersistentContainer(name: "PersistentTrackBlog")
            if inMemory {
                container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: "/dev/null")
            }

            // 添加如下代码：
            let desc = container.persistentStoreDescriptions.first!
            // 如果不指定 desc.url 的话，默认的 URL 当前 App 的 Application Support 目录
            // FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
            // 在该 Description 上启用 Persistent History Tracking
            desc.setOption(true as NSNumber,
                           forKey: NSPersistentHistoryTrackingKey)
            // 接收有关的远程通知
            desc.setOption(true as NSNumber,
                           forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
             // 对 description 的设置必须在 load 之前完成，否则不起作用
            container.loadPersistentStores(completionHandler: { (storeDescription, error) in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
        }

如果创建自己的 Description，类似的代码如下：

            let defaultDesc: NSPersistentStoreDescription
            let groupURL = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "group.com.fatbobman.healthnote")!
            // 数据库保存在 App Group Container 中，其他的 App 或者 App Extension 也可以读取
            defaultDesc.url = groupURL
            defaultDesc.configuration = "Local"
            defaultDesc.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
            defaultDesc.setOption(true as NSNumber,
                                  forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
            container.persistentStoreDescriptions = [defaultDesc]

            container.loadPersistentStores(completionHandler: { _, error in
                if let error = error as NSError? {
                }
            })

Persistent History Tracking 功能是在 description 上设置的，因此如果你的 CoreData 使用了多个 `Configuration` 的话，可以只为有需要的 `configuration` 启用该功能。

## 响应持久化存储跟踪远程通知

    final class PersistentHistoryTrackingManager {
        init(container: NSPersistentContainer, currentActor: AppActor) {
            self.container = container
            self.currentActor = currentActor

            // 注册 StoreRemoteChange 的响应
            NotificationCenter.default.publisher(
                for: .NSPersistentStoreRemoteChange,
                object: container.persistentStoreCoordinator
            )
            .subscribe(on: queue, options: nil)
            .sink { _ in
                // notification 的内容没有意义，仅起到提示需要处理的作用
                self.processor()
            }
            .store(in: &cancellables)
        }

        var container: NSPersistentContainer
        var currentActor: AppActor
        let userDefaults = UserDefaults.appGroup

        lazy var backgroundContext = { container.newBackgroundContext() }()

        private var cancellables: Set<AnyCancellable> = []
        private lazy var queue = {
            DispatchQueue(label: "com.fatbobman.\(self.currentActor.rawValue).processPersistentHistory")
        }()

        /// 处理 persistent history
        private func processor() {
            // 在正确的上下文中进行操作，避免影响主线程
            backgroundContext.performAndWait {
                // fetcher 用来获取需要处理的 transaction
                guard let transactions = try? fetcher() else { return }
                // merger 将 transaction 合并当当前的视图上下文中
                merger(transaction: transactions)
            }
        }
    }

我简单的解释一下上面的代码。

我们注册 `processor` 来响应 `NSNotification.Name.NSPersistentStoreRemoteChange` 。

每当你的数据库中启用 Persistent History Tracking 的 Entity 发生数据变动时， `processor`
都将会被调用。在上面的代码中，我们完全忽视了 `notification` ，因为它本身的内容没有意义，只是告诉我们数据库发生了变化，需要
processor 来处理，具体发生了什么变化、是否有必要进行处理等都需要通过自己的代码来判断。

所有针对 Persistent History Tracking 的数据操作都放在 `backgroundContext` 中进行，避免影响主线程。

`PersistentHistoryTrackingManager` 是我们处理 Persistent History Tracking 的核心。在
CoreDataStack 中（比如上面的 persistent. swift），通过在 init 中添加如下代码来处理 Persistent
History Tracking 事件

    let persistentHistoryTrackingManager : PersistentHistoryTrackingManager
    init(inMemory: Bool = false) {
      ....
      // 标记当前上下文的 author 名称
        container.viewContext.transactionAuthor = AppActor.mainApp.rawValue
        persistentHistoryTrackingManager = PersistentHistoryTrackingManager(
                            container: container,
                            currentActor: AppActor.mainApp //当前的成员
       )
    }

因为 App Group 中的成员都可以读写我们的数据库，为了在接下来的处理中更好的分辨到底是由那个成员产生的
Transaction，我们需要创建一个枚举类型来对每个成员进行标记。

    enum AppActor:String,CaseIterable{
        case mainApp  // iOS App
        case safariExtension //Safari Extension
    }

按照自己的需求来创建成员的标记。

## 获取需要处理的 Transaction

在接收到 `NSPersistentStoreRemoteChange` 消息后，我们首先应该将需要处理的 Transaction
提取出来。就像在前面的工作原理中提到的一样，API 为我们提供了 3 种不同的方法：

    open class func fetchHistory(after date: Date) -> Self
    open class func fetchHistory(after token: NSPersistentHistoryToken?) -> Self
    open class func fetchHistory(after transaction: NSPersistentHistoryTransaction?) -> Self

获取指定 **时间点之后** 且满足条件的 Transaction

这里我更推荐使用 `Timestamp` 也就是 `Date` 来进行处理。主要有两个原因：

- 当我们用 UserDefaults 来保存最后的记录时， `Date` 是 UserDefaults 直接支持的结构，无需进行转换
- `Timestamp` 已经被记录在 Transaction 中（表 `ATRANSACTION` ），可以直接查找，无需转换，而 Token 是需要再度计算的

通过使用下面的代码，我们可以获取当前 sqlite 数据库中，所有的 Transaction 信息：

    NSPersistentHistoryChangeRequest.fetchHistory(after: .distantPast)

这些信息包括任意来源产生的 `Transaction` ，无论这些 `Transaction` 是否是当前 App 所需要的，是否已经被当前 App
处理过了。

在上面的处理流程中，我们已经介绍过需要通过时间戳来过滤不必要的信息，并保存最后处理的 `Transaction` 时间戳。我们这些信息保存在
UserDefaults 中，方便 App Group 的成员来共同处理。

    extension UserDefaults {
        /// 从全部的 app actor 的最后时间戳中获取最晚的时间戳
        /// 只删除最晚的时间戳之前的 transaction，这样可以保证其他的 appActor
        /// 都可以正常的获取未处理的 transaction
        /// 设置了一个 7 天的界限。即使有的 appActor 没有使用（没有创建 userdefauls）
        /// 也会至多只保留 7 天的 transaction
        /// - Parameter appActors: app 角色，比如 healthnote ,widget
        /// - Returns: 日期（时间戳）, 返回值为 nil 时会处理全部未处理的 transaction
        func lastCommonTransactionTimestamp(in appActors: [AppActor]) -> Date? {
            // 七天前
            let sevenDaysAgo = Date().addingTimeInterval(-604800)
            let lasttimestamps = appActors
                .compactMap {
                    lastHistoryTransactionTimestamp(for: $0)
                }
            // 全部 actor 都没有设定值
            guard !lasttimestamps.isEmpty else {return nil}
            let minTimestamp = lasttimestamps.min()!
            // 检查是否全部的 actor 都设定了值
            guard lasttimestamps.count != appActors.count else {
                //返回最晚的时间戳
                return minTimestamp
            }
            // 如果超过 7 天还没有获得全部 actor 的值，则返回七天，防止有的 actor 永远不会被设定
            if minTimestamp < sevenDaysAgo {
                return sevenDaysAgo
            }
            else {
                return nil
            }
        }

        /// 获取指定的 appActor 最后处理的 transaction 的时间戳
        /// - Parameter appActore: app 角色，比如 healthnote ,widget
        /// - Returns: 日期（时间戳）, 返回值为 nil 时会处理全部未处理的 transaction
        func lastHistoryTransactionTimestamp(for appActor: AppActor) -> Date? {
            let key = "PersistentHistoryTracker.lastToken.\(appActor.rawValue)"
            return object(forKey: key) as? Date
        }

        /// 给指定的 appActor 设置最新的 transaction 时间戳
        /// - Parameters:
        ///   - appActor: app 角色，比如 healthnote ,widget
        ///   - newDate: 日期（时间戳）
        func updateLastHistoryTransactionTimestamp(for appActor: AppActor, to newDate: Date?) {
            let key = "PersistentHistoryTracker.lastToken.\(appActor.rawValue)"
            set(newDate, forKey: key)
        }
    }

由于 App Group 的成员每个都会保存自己的 `lastHistoryTransactionTimestamp` ，因此为了保证 `Transaction` 能够被所有成员都正确合并后，再被清除掉， `lastCommonTransactionTimestamp`
将返回所有成员最晚的时间戳。 `lastCommonTransactionTimestamp` 在清除合并后的 `Transaction`
时，将被使用到。

有了这些基础，上面的代码变可以修改为：

    let fromDate = userDefaults.lastHistoryTransactionTimestamp(for: currentActor) ?? Date.distantPast
    NSPersistentHistoryChangeRequest.fetchHistory(after: fromDate)

通过时间戳，我们已经过滤了大量不必关心的 `Transaction` 了，但在剩下的 `Transaction`
中都是我们需要的吗？答案是否定的，至少有两种情况的 Transaction 我们是不需要关心的：

- 由当前 App 本身上下文产生的 `Transaction`

通常 App 会对自身通过上下文产生的数据变化做出即时的反馈，如果改变化已经体现在了视图上下文中（主线程
ManagedObjectContext），则我们可以无需理会这些 Transaction。但如果数据是通过批量操作完成的，或者是在 `backgroudContext` 操作，且并没有被合并到视图上下文中，我们还是要处理这些 Transaction 的。

- 由系统产生的 Transaction

比如当你使用了 PersistentCloudKitContainer 时，所有的网络同步数据都将会产生 `Transaction` ，这些 `Transaction` 会由 CoreData 来处理，我们无需理会。

基于以上两点，我们可以进一步缩小需要处理的 `Transaction` 范围。最终 fetcher 的代码如下：

    extension PersistentHistoryTrackerManager {
        enum Error: String, Swift.Error {
            case historyTransactionConvertionFailed
        }
        // 获取过滤后的 Transaction
        func fetcher() throws -> [NSPersistentHistoryTransaction] {
            let fromDate = userDefaults.lastHistoryTransactionTimestamp(for: currentActor) ?? Date.distantPast
            NSPersistentHistoryChangeRequest.fetchHistory(after: fromDate)

            let historyFetchRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: fromDate)
            if let fetchRequest = NSPersistentHistoryTransaction.fetchRequest {
                var predicates: [NSPredicate] = []

                AppActor.allCases.forEach { appActor in
                    if appActor == currentActor {
                        // 本代码假设在 App 中，即使通过 backgroud 进行的操作也已经被即时合并到了 ViewContext 中
                        // 因此对于当前 appActor，只处理名称为 batchContext 上下文产生的 transaction
                        let perdicate = NSPredicate(format: "%K = %@ AND %K = %@",
                                                    #keyPath(NSPersistentHistoryTransaction.author),
                                                    appActor.rawValue,
                                                    #keyPath(NSPersistentHistoryTransaction.contextName),
                                                    "batchContext")
                        predicates.append(perdicate)
                    } else {
                        // 其他的 appActor 产生的 transactions，全部都要进行处理
                        let perdicate = NSPredicate(format: "%K = %@",
                                                    #keyPath(NSPersistentHistoryTransaction.author),
                                                    appActor.rawValue)
                        predicates.append(perdicate)
                    }
                }

                let compoundPredicate = NSCompoundPredicate(type: .or, subpredicates: predicates)
                fetchRequest.predicate = compoundPredicate
                historyFetchRequest.fetchRequest = fetchRequest
            }
            guard let historyResult = try backgroundContext.execute(historyFetchRequest) as? NSPersistentHistoryResult,
                  let history = historyResult.result as? [NSPersistentHistoryTransaction]
            else {
                throw Error.historyTransactionConvertionFailed
            }
            return history
        }
    }

> 如果你的 App 比较单纯（比如没有使用 PersistentCloudKitContainer），可以不需要上面更精细的 `predicate`
> 处理过程。总的来说，即使获取的 `Transaction` 超出了需要的范围，CoreData 在合并时给系统造成的压力也并不大。

由于 fetcher 是通过 `NSPersistentHistoryTransaction.author` 和 `NSPersistentHistoryTransaction.contextName` 来对 `Transaction`
进行进一步过滤的，因此请在你的代码中，明确的在 `NSManagedObjectContext` 中标记上身份：

    // 标记代码中的上下文的 author，例如
    viewContext.transactionAuthor = AppActor.mainApp.rawValue
    // 如果用于批处理的操作，请标记 name，例如
    backgroundContext.name = "batchContext"

**清楚地标记 Transaction 信息，是使用 Persistent History Tracking 的基本要求**

## 将 Transaction 合并到视图上下文中

通过 fetcher 获取到了需要处理的 Transaction 后，我们需要将这些 Transaction 合并到视图上下文中。

合并的操作就很简单了，在合并后将最后的时间戳保存即可。

    extension PersistentHistoryTrackerManager {
        func merger(transaction: [NSPersistentHistoryTransaction]) {
            let viewContext = container.viewContext
            viewContext.perform {
                transaction.forEach { transaction in
                    let userInfo = transaction.objectIDNotification().userInfo ?? [:]
                    NSManagedObjectContext.mergeChanges(fromRemoteContextSave: userInfo, into: [viewContext])
                }
            }

            // 更新最后的 transaction 时间戳
            guard let lastTimestamp = transaction.last?.timestamp else { return }
            userDefaults.updateLastHistoryTransactionTimestamp(for: currentActor, to: lastTimestamp)
        }
    }

可以根据自己的习惯选用合并代码，下面的代码和上面的 `NSManagedObjectContext.mergeChanges` 是等效的：

    viewContext.perform {
       transaction.forEach { transaction in
          viewContext.mergeChanges(fromContextDidSave: transaction.objectIDNotification())
       }
    }

这些已经在数据库中发生但尚未反映在视图上下文中的 Transaction，会在合并后立即体现在你的 App UI 上。

## 清理合并后的 Transaction

所有的 Transaction 都被保存在 Sqlite 文件中，不仅会占用空间，而且随着记录的增多也会影响 Sqlite
的访问速度。我们需要制定明确的清理策略来删除已经处理过的 Transaction。

同 `fetcher` 中使用 `open class func fetchHistory(after date: Date) -> Self`
类似，Persistent History Tracking 同样为我们准备了三个方法用来做清理工作：

    open class func deleteHistory(before date: Date) -> Self
    open class func deleteHistory(before token: NSPersistentHistoryToken?) -> Self
    open class func deleteHistory(before transaction: NSPersistentHistoryTransaction?) -> Self

删除指定 **时间点之前** 且满足条件的 Transaction

清理策略可以粗旷的也可以很精细的，例如在苹果官方文档中便采取了一种比较粗旷的清理策略：

    let sevenDaysAgo = Date(timeIntervalSinceNow: TimeInterval(exactly: -604_800)!)
    let purgeHistoryRequest =
        NSPersistentHistoryChangeRequest.deleteHistory(
            before: sevenDaysAgo)

    do {
        try persistentContainer.backgroundContext.execute(purgeHistoryRequest)
    } catch {
        fatalError("Could not purge history: \(error)")
    }

删除一切 7 天前的 Transaction，无论其 author 是谁。事实上，这个看似粗旷的策略在实际使用中几乎没有任何问题。

在本文中，我们将同 fetcher 一样，对清除策略做更精细的处理。

    import CoreData
    import Foundation

    /// 删除已经处理过的 transaction
    public struct PersistentHistoryCleaner {
        /// NSPersistentCloudkitContainer
        let container: NSPersistentContainer
        /// app group userDefaults
        let userDefault = UserDefaults.appGroup
        /// 全部的 appActor
        let appActors = AppActor.allCases

        /// 清除已经处理过的 persistent history transaction
        public func clean() {
            guard let timestamp = userDefault.lastCommonTransactionTimestamp(in: appActors) else {
                return
            }

            // 获取可以删除的 transaction 的 request
            let deleteHistoryRequest = NSPersistentHistoryChangeRequest.deleteHistory(before: timestamp)

            // 只删除由 App Group 的成员产生的 Transaction
            if let fetchRequest = NSPersistentHistoryTransaction.fetchRequest {
                var predicates: [NSPredicate] = []

                appActors.forEach { appActor in
                    // 清理 App Group 成员创建的 Transaction
                    let perdicate = NSPredicate(format: "%K = %@",
                                                #keyPath(NSPersistentHistoryTransaction.author),
                                                appActor.rawValue)
                    predicates.append(perdicate)
                }

                let compoundPredicate = NSCompoundPredicate(type: .or, subpredicates: predicates)
                fetchRequest.predicate = compoundPredicate
                deleteHistoryRequest.fetchRequest = fetchRequest
            }

            container.performBackgroundTask { context in
                do {
                    try context.execute(deleteHistoryRequest)
                    // 重置全部 appActor 的时间戳
                    appActors.forEach { actor in
                        userDefault.updateLastHistoryTransactionTimestamp(for: actor, to: nil)
                    }
                } catch {
                    print(error)
                }
            }
        }
    }

之所以在我在 fetcher 和 cleaner 中设置了如此详尽的 predicate，是因为我自己是在 `PersistentCloudKitContainer` 中使用 Persistent History Tracking 功能的。Cloudkit
同步会产生大量的 Transaction，因此需要更精准的对操作对象进行过滤。

**CoreData 会自动处理和清除 CloudKit 同步产生的 Transaction，但是如果我们不小心删除了尚没被 CoreData 处理的
CloudKit Transaction，可能会导致数据库同步错误，CoreData 会清空当前的全部数据，尝试从远程重新加载数据。**

**因此，如果你是在`PersistentCloudKitContainer 上` 使用 Persistent History
Tracking，请务必仅对 App Group 成员产生的 Transaction 做清除操作。 **

如果仅是在 `PersistentContainer` 上使用 Persistent History Tracking，fetcher 和
cleaner 中都可以不用过滤的如此彻底。

在创建了 `PersistentHistoryCleaner` 后，我们可以根据自己的实际情况选择调用时机。

如果采用 `PersistentContainer` ，可以尝试比较积极的清除策略。在 `PersistentHistoryTrackingManager` 中添加如下代码：

        private func processor() {
            backgroundContext.performAndWait {
                ...
            }

            let cleaner = PersistentHistoryCleaner(container: container)
            cleaner.clean()
        }

这样在每次响应 `NSPersistentStoreRemoteChange` 通知后，都会尝试清除已经合并过的 Transaction。

不过我个人更推荐使用不那么积极的清除策略。

    @main
    struct PersistentTrackBlogApp: App {
        let persistenceController = PersistenceController.shared
        @Environment(\.scenePhase) var scenePhase
        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environment(\.managedObjectContext, persistenceController.container.viewContext)
                    .onChange(of: scenePhase) { scenePhase in
                        switch scenePhase {
                        case .active:
                            break
                        case .background:
                            let clean = PersistentHistoryCleaner(container: persistenceController.container)
                            clean.clean()
                        case .inactive:
                            break
                        @unknown default:
                            break
                        }
                    }
            }
        }
    }

比如当 app 退到后台时，进行清除工作。

## 总结

可以在 [ Github ](https://github.com/fatbobman/PersistentHistoryTrackingDemo)
下载本文的全部代码。

以下资料对于本文有着至关重要的作用：

- [ Practical Core Data ](https://donnywals.gumroad.com/l/practical-core-data)

Donny Wals 的这本书是我最近一段时间非常喜欢的一本 CoreData 的书籍。其中有关于 Persistent History Tracking
的章节。另外他的 [ Blog ](https://www.donnywals.com/the-blog/) 也经常会有关于 CoreData 的文章

- [ SwiftLee ](https://www.avanderlee.com)

Avanderlee 的博客也有大量关于 CoreData 的精彩文章， [ Persistent History Tracking in Core
Data ](https://www.avanderlee.com/swift/persistent-history-tracking-core-
data/) 这篇文章同样做了非常详细的说明。本文的代码结构也受其影响。

苹果构建了 Persistent History Tracking，让多个成员可以共享单个数据库并保持 UI
的及时更新。无论你是构建一套应用程序，或者是想为你的 App 添加合适的
Extension，亦或仅为了统一的响应批处理操作的数据，持久化历史跟踪都能为你提供良好的帮助。

Persistent History Tracking
尽管可能会造成一点系统负担，不过和它带来的便利性相比是微不足道的。在实际使用中，我基本上感受不到因它而导致的性能损失。

# 如何在 Core Data 中进行批量操作

Core Data 是 Apple 为其生态提供的拥有持久化功能的对象图管理框架。具备稳定（ 广泛应用于苹果的各类系统软件 ）、成熟（ Core Data
发布于 2009 年，其历史可以追溯到上世纪 90 年代 ）、开箱即用（ 内置于整个苹果生态系统 ）等特点。

Core Data
的优势主要体现在对象图管理、数据描述、缓存、延迟加载、内存管理等方面，但在对持久化数据的操作性能方面表现一般。事实上，在相当长的时间中，Core Data
的竞品总是喜欢通过各种图表来展现它们在数据操作性能上对 Core Data 的碾压之势。

Apple 于数年前起陆续提供了批量更新、批量删除以及批量添加等 API ，在相当程度上改善 Core Data 在处理大量数据时性能劣势。

本文将对 Core Data 的批量操作做以介绍，包括：原理、使用方法、高级技巧、注意事项等内容。

## 批量操作的使用方法

在官方文档中并没有对批量操作的使用方法进行过多的讲解，苹果为开发者提供了一个持续更新的 [ 演示项目
](https://developer.apple.com/documentation/swiftui/loading_and_displaying_a_large_data_feed)
来展示它的工作流程。本节将按照由易到难的顺序，逐个介绍批量删除、批量更新和批量添加。

### 批量删除

批量删除可能是 Core Data 所有批量操作中使用最方便、应用最广泛的一项功能了。

    func delItemBatch() async throws -> Int {
        // 创建私有上下文
        let context = container.newBackgroundContext()
        // 在私有上下文线程中执行（避免对视图线程造成影响）
        return try await context.perform {
            // 创建 NSFetchRequest ，其指明了批量删除对应的实体
            let request = NSFetchRequest<NSFetchRequestResult>(entityName: "Item")
            // 设置谓词，timestamp 早于三天前的所有 Item 数据 。 不设置谓词则意味着全部 Item 数据均 m
            request.predicate = NSPredicate(format: "%K < %@", #keyPath(Item.timestamp),Date.now.addingTimeInterval(-259200) as CVarArg)
            // 创建批量删除请求（ NSBatchDeleteRequest ）
            let batchDeleteRequest = NSBatchDeleteRequest(fetchRequest: request)
            // 设置返回结果类型
            batchDeleteRequest.resultType = .resultTypeCount
            // 执行批量删除操作
            let result = try context.execute(batchDeleteRequest) as! NSBatchDeleteResult
            // 返回批量删除的记录数量
            return result.result as! Int
        }
    }

上面的代码将从持久化数据中（ 数据库 ）删除所有属性 `timestamp` 早于当前日期三天前的 `Item`
实体数据。代码中的注释应该能够清楚地解释全部的批量删除操作过程。

其他需要注意的还有：

- 批量操作最好是在私有托管对象上下文线程中进行
- 如果不指定谓词（ NSPredicate ），意味着将删除所有的 Item 数据
- 所有的批量操作请求（ 删除、更新、添加，以及持久化历史跟踪使用的 NSPersistentHistoryChangeRequest ）都是 [ NSPersistentStoreRequest ](https://developer.apple.com/documentation/coredata/nspersistentstorerequest) 的子类
- 批量请求通过托管对象上下文发出（ `context.execute(batchDeleteRequest)` ），经由持久化存储协调器直接转发给持久化存储
- 通过 `resultType` 可以设置批量操作的返回结果类型。共三种：结果状态（ statusOnly ）、记录数量（ count ）、所有记录的 NSManagedObjectID ( objectIDs ) 。如果想在批量操作后在同一段代码中将数据变化合并到视图上下文，需要将结果类型设置为 resultTypeObjectIDs
- 如果多个持久化存储均包含同一个实体模型，那么可以通过 `affectedStores` 指定仅在某个（ 或某几个 ）持久化存储中进行批量操作。默认值为在所有持久化存储上操作。该属性在所有批量操作（删除、更新、添加）中作用均相同。关于如何让不同的持久化存储拥有同样的实体模型，请参阅 [ 同步本地数据库到 iCloud 私有数据库中 ](/zh/posts/coredatawithcloudkit-2/#%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84-configuration-%E4%B8%AD%E6%94%BE%E7%BD%AE%E5%90%8C%E4%B8%80%E4%B8%AA-entity) 的对应章节

除了通过 NSFetchRequest 来指定需要删除的数据外，还可以使用 NSBatchDeleteRequest
的另一个构造方法，直接指定需要删除数据的 NSManagedObjectID ：

    func batchDeleteItem(items:[Item]) async throws -> Bool {
        let context = container.newBackgroundContext()
        return try await context.perform {
            // 通过 [NSManagedObjectID] 创建 NSBatchDeleteRequest
            let batchDeleteRequest = NSBatchDeleteRequest(objectIDs: items.map(\.objectID))
            batchDeleteRequest.resultType = .resultTypeStatusOnly
            let result = try context.execute(batchDeleteRequest) as! NSBatchDeleteResult
            return result.result as! Bool
        }
    }

此种方式适合于数据或数据 ID 已被载入内存场景。需要注意的是， **所有的 NSManagedObjectID 对应的实体（ Entity ）必须一致**
，比如本例中均为 Item 。

批量删除对 Core Data 中的关系提供了有限度的支持，详细内容见下文。

### 批量更新

相较于批量删除，批量更新除了需要指定实体以及谓词外（ 可省略 ），还要提供需要更新的属性和值。

下面的代码将更新所有 `timestamp` 晚于三天前的 Item 数据，将其的 `timestamp` 更新为当前日期：

    func batchUpdateItem() async throws -> [NSManagedObjectID] {
        let context = container.newBackgroundContext()
        return try await context.perform {
            // 创建 NSBatchUpdateRequest ，设置对应的实体
            let batchUpdateRequest = NSBatchUpdateRequest(entity: Item.entity())
            // 设置结果返回类型，本例中返回所有更改记录的 NSManagedObjectID
            batchUpdateRequest.resultType = .updatedObjectIDsResultType
            let date = Date.now // 当前日期
            // 设置谓词，所有 timestamp 晚于三天前的记录
            batchUpdateRequest.predicate = NSPredicate(format: "%K > %@", #keyPath(Item.timestamp), date.addingTimeInterval(-259200) as CVarArg)
            // 设置更新字典 [属性：更新值] ，可以设置多个属性
            batchUpdateRequest.propertiesToUpdate = [#keyPath(Item.timestamp): date]
            // 执行批量操作
            let result = try context.execute(batchUpdateRequest) as! NSBatchUpdateResult
            // 返回结果
            return result.result as! [NSManagedObjectID]
        }
    }

需要注意如下事项：

- propertiesToUpdate 中，如属性名称拼写错误将导致程序崩溃
- propertiesToUpdate 中，如更新值类型错误将导致程序崩溃
- 批处理将忽略 Core Data 所有的值验证过程，无论是在数据模型编辑器中设置的，还是在 validateForXXXX 方法中添加的
- 批量更新无法实现在原值的基础上进行改动的情况，如需实现 `item.count += 1` 仍只能通过传统的手段
- 无法在批量更新中修改关系属性或关系属性的子属性
- 如果更新的实体为抽象实体，可以通过 `includesSubentities` 设置更新是否包含子实体
- 在批量更新操作中无法使用关键路径连接的方式设置谓词（ 批量删除支持关键路径连接 ）。比如下面的谓词在批量操作中就是非法的（ 假设 Item 有个 attachment 关系，Attachment 有 count 属性 ）： `NSPredicate(format: "attachment.count > 10")` 。

### 批量添加

下面的代码将创建给定数量（ `amount` ）的 Item 数据：

    func batchInsertItem(amount: Int) async throws -> Bool {
        // 创建私有上下文
        let context = container.newBackgroundContext()
        return try await context.perform {
            // 已添加的记录数量
            var index = 0
            // 创建 NSBatchInsertRequest ，并声明数据处理闭包。如果 dictionaryHandler 返回 false , Core Data 将继续调用闭包创建数据，直至闭包返回 true 。
            let batchRequest = NSBatchInsertRequest(entityName: "Item", dictionaryHandler: { dict in
                if index < amount {
                    // 创建数据。当前的 Item 只有一个属性 timestamp ，类型为 Date
                    let item = ["timestamp": Date().addingTimeInterval(TimeInterval(index))]
                    dict.setDictionary( item )
                    index += 1
                    return false // 尚未全部完成，仍需继续添加
                } else {
                    return true // index == amout , 已添加了指定数量（ amount ）的数据，结束批量添加操作
                }
            })
            batchRequest.resultType = .statusOnly
            let result = try context.execute(batchRequest) as! NSBatchInsertResult
            return result.result as! Bool
        }
    }

NSBatchInsertRequest 提供了三种添加新数据的构造方法：

1. `init(entityName: String, objects: [[String : Any]])`

该方法需要将所有的数据预先保存成字典数组，相较于其他两种方式会占用更大的内存空间

2. `init(entityName: String, dictionaryHandler: (NSMutableDictionary) -> Bool)`

上面例程中使用的方法。同批量更新一样，使用字典来构建数据

3. `init(entityName: String, managedObjectHandler: (NSManagedObject) -> Bool)`

相较于方法 2 ，由于采用了托管对象来构建数据，因此避免了可能出现的属性名称拼写及值的类型错误。但由于每次都需要实例化一个托管对象，理论上性能较方法 2
稍慢。相较于同样使用托管对象实例来新建数据的传统方式，方法 3 在内存占用上有巨大的优势（ 占用空间极小 ）

下面的代码采用了方法三：

    let batchRequest = NSBatchInsertRequest(entityName: "Item", managedObjectHandler: { obj in
        let item = obj as! Item
        if index < amount {
            // 通过属性赋值避免了通过字典添加可能导致的属性名称或值类型错误
            item.timestamp = Date().addingTimeInterval(TimeInterval(index))
            index += 1
            return false
        } else {
            return true
        }
    })

其他需要注意的事项：

- 通过字典创建数据时，如果可选属性的值为 nil，可以不在字典中添加
- 批量添加无法处理 Core Data 的关系
- 当多个持久化存储都包含同一个实体模型时，默认情况下，新创建的数据会写入到持久化存储协调器 persistentStores 属性中位置靠前的持久化存储中。可以通过 affectedStores 改变写入的持久化存储
- 通过在数据模型编辑器中设置约束，可以让批量添加具备批量更新（选择性）的能力。下文中会详细说明

### 将变化合并到视图上下文

由于批量操作是直接在持久化存储上完成的，因此必须通过某种方式将变化后的数据合并到视图上下文中，才能将变化在 UI 上体现出来。

可以采用如下两种方式：

- 启用持久化历史跟踪功能（ 当前的首选方式 ）

详细内容请参阅 [ 在 CoreData 中使用持久化历史跟踪 ](/zh/posts/persistenthistorytracking/)
。此种方式不仅可以让批量操作的变动在当前的应用中及时体现出来，而且可以让 App Group 的其他成员（ 共享数据库文件
），也能及时地对数据的变化作出反应

- 将合并操作集成在批量操作的代码中

下面的代码会将新添加的 Item 数据合并到视图上下文中

    func batchInsertItemAndMerge(amount: Int) async throws {
        let context = container.newBackgroundContext()
        try await context.perform {
            var index = 0
            let batchRequest = NSBatchInsertRequest(entityName: "Item", dictionaryHandler: { dict in
                if index < amount {
                    let item = ["timestamp": Date().addingTimeInterval(TimeInterval(index))]
                    dict.setDictionary(item)
                    index += 1
                    return false
                } else {
                    return true
                }
            })
            // 设置返回类型必须设置为 [NSManagedObjectID]
            batchRequest.resultType = .objectIDs
            let result = try context.execute(batchRequest) as! NSBatchInsertResult
            let objs = result.result as? [NSManagedObjectID] ?? []
            // 创建变动字典。根据数据变化类型，创建不同的键值对。插入：NSInsertedObjectIDsKey、更新：NSUpdatedObjectIDsKey、删除：NSDeletedObjectIDsKey。
            let changes: [AnyHashable: Any] = [NSInsertedObjectIDsKey: objs]
            // 合并变动
            NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [self.container.viewContext])
        }
    }

## 批量操作的快与省

无论是官方给出的数据，还是开发者的实际测试，Core Data 的批量操作相较于实现相同结果的传统方式（ 在托管对象上下文中使用托管对象
）来说都具有相当明显的优势 —— 执行速度快、内存占用小。那么其中的原因是什么呢？为了获得这些优势，“批量操作” 又是牺牲了哪些 Core Data
的重要特性呢？本节将上述问题做一点探讨。

### Core Data 中各个组件的协作

想搞清楚批量操作又快又省的原因，需要对 Core Data 的几大组件之间的协作规则以及数据在各个组件间传递的机制有一定了解。

以从 Core Data 中对获取的结果修改属性值为例，我们简单了解一下各组件之间的协作以及数据的流动（ 存储格式为 SQLite ）：

    let request = NSFetchRequest<Item>(entityName: "Item")
    request.predicate = NSPredicate(format: "%K > %@", #keyPath(Item.timestamp), date.addingTimeInterval(-259200) as CVarArg)
    let items = try! context.fetch(request)
    for item in items {
        item.timestamp = Date()
    }
    try! context.save()

1. 托管对象上下文 context（ NSManagedObjectContext ）通过调用 request（ NSFetchRequest ）的 `executeRequest()` 方法将 “获取请求” 传递给持久化存储协调器（ NSPersistentStoreCoordinator ）
2. 持久化存储协调器将 NSFetchRequest 转换成对应的 NSPersistentStoreRequest ，并调用自身的 `executeRequest(_:with:)` 方法，将 “获取请求” 和发起请求的 “上下文” 一并发送给所有的持久化存储（ NSPersistentStore ）
3. 持久化存储将 NSPersistentStoreRequest 转换成 SQL 语句，并把这个语句发送给 SQLite
4. SQlite 执行这个语句，将匹配查询条件的所有数据返回给持久化存储（ 包括对象 ID、每行数据的属性内容、数据版本等信息 ），持久化存储将其保存在行缓存中（ row catch ）
5. 持久化存储将从步骤 4 获取的数据实例化为托管对象（ 本例中实例化为 Item ），并把这些对象返回给持久化存储协调器，由于 NSFetchRequest 的 returnsObjectsAsFaults 默认值为 true，因此此时这些对象是惰值（ Fault ）形态的
6. 持久化存储协调器将步骤 5 中实例化的数据以托管对象数组的形式返回给发起请求的托管对象上下文
7. 如果上下文中有部分新数据或数据改动与本次获取的条件一致，上下文将一并考虑进来与步骤 6 的数据合并
8. items 变量获得最终满足条件的全部数据（ 此时数据为惰值形态 ）
9. 使用 item. timestamp 更新数据时，Core Data 会检查当前的托管对象是否为惰值 （ 本例中是 ）
10. 上下文向持久化存储协调器发起填充请求
11. 持久化存储协调器向持久化存储请求与当前对象关联的数据
12. 持久化存储在它的行缓存中查找数据，并返回（ 在本例中，数据已经被载入到行缓存中。假如在其他情况下，数据没在缓存中，持久化存储会通过 SQL 语句从 SQLite 中获取到对应的数据 ）
13. 持久化存储协调器将从持久化存储中获取的数据转交给上下文
14. 上下文用获得到的数据填充惰值状态的 item ，并用新数据替换掉原来的 timestamp
15. 上下文通过发送 NSManagedObjectContextWillSaveNotification 通知（ 由 save 方法引发 ），通知中包含了即将更新的对象集合
16. 对所有发生变动的 item 进行验证 （ 调用 Item 的 validateForUpdate 方法中的自定义验证代码以及模型编辑器中定义的验证条件 ），如验证失败则抛出错误
17. 调用所有需要更新的托管对象 （ item ）的 `willSave` 方法
18. 创建一个持久化存储请求（ NSSaveChangesRequest ）并调用持久化存储协调器的 `executeRequest(_:with:)` 方法
19. 持久化存储协调器将请求发送给持久化存储
20. 持久化存储对请求中的数据与持久化存储行缓存中的数据进行冲突检测。如果发生冲突（ 在我们于上下文更改数据的过程中，行缓存中的数据发生了变动 ）则按照合并策略进行处理
21. 将 NSSaveChangesRequest 翻译成对应的 SQL 语句发送给 SQLite 数据库（ SQL 语句会根据合并策略的不同而有所变化，在 SQlite 保存过程中还会再进行一次冲突检查 ）
22. SQLite 执行给定的 SQL 语句（ Core Data 在 SQLite 中对数据的处理也有其独特的地方，详情请阅读 [ Core Data 是如何在 SQLite 中保存数据的 ](/zh/posts/tables_and_fields_of_coredata/) ）
23. 在 SQLite 完成更新后，持久化存储会更新它的行缓存，将数据以及数据版本更新到当前状态
24. 调用所有更新后的 item 实例的 `didSave()` 方法
25. 抹除更新后的 item 和托管对象上下文的脏状态
26. 托管对象上下文发送 NSManagedObjectContextDidSaveNotification 通知。通知中包含了本次更新的对象集合

或许上面的步骤已经让你有点头痛，但事实上我们还是省略了相当多的细节。

这些烦琐的操作或许会造成 Core Data 在某些情况下的性能问题，但 Core Data
的强大也同样在这些细节中得以展现。不仅让开发者可以从多个维度、时机来处理数据，同时 Core Data
也将根据数据的状态在性能、内存占用等方面寻找合适的平衡。对于一个成熟的 Core Data 开发者，从整体的收益上来看，Core Data
相较于直接操作数据库或使用其他的 ORM 框架仍是有优势的。

### 批量操作为什么快

上面使用传统的方式实现的功能与本文之前介绍的批量更新代码完全一样。那么 Core Data 在使用批量更新代码时的内部操作过程是如何的呢？

1. 托管对象上下文通过 `execute` 将持久化存储查询请求（ NSBatchUpdateRequest ）发送给持久化存储协调器
2. 协调器直接将请求转发给持久化存储
3. 持久化存储将其转换成 SQL 语句，发送给 SQLite
4. SQLite 执行更新语句，并将更新后的记录 ID 回传给持久化存储
5. 持久化存储将 ID 转换成 NSManagedObjectID ，通过协调器回传给上下文

看到这里，我想无须再继续解释批量操作为什么相较于传统操作效率要更高了吧。

所谓有得必有失，Core Data 的批量操作是在放弃了大量的细节处理的基础上换取的效率提升。整个过程中，我们将失去检验、通知、回调机制、关系处理等功能。

因此，如果你的操作要求并不需要上述略过的能力，那么批量操作确实是非常好的选择。

### 批量操作为什么省

对于更新和删除操作来说，由于批量操作无须将数据提取到内存中（ 上下文、行缓存 ），因此整个操作过程中几乎不会造成什么内存的占用。

至于添加新数据的批量操作，dictionaryHandler 闭包（ 或 managedObjectHandler
闭包）会在每次构建一个数据后立即将其转换成对应的 SQL
语句并发送给持久化存储，在整个的创建过程中，内存中只会保留一份数据。相较于传统的方法需要在上下文中实例化所有的新添加数据的方式，内存占用也几乎可以忽略不计。

### 避免 WAL 文件溢出

由于批量操作对内存的占用极小，导致开发者在使用批量操作上几乎没有什么心理负担，从而容易在一次操作过程中执行过量的指令。默认情况下 Core Data 为
SQLite 启用了 WAL 模式，当 SQL 事务的量过大时，WAL 文件的尺寸会急速增加并达到 WAL
的预设检查点，容易造成文件溢出，从而导致操作失败。

因此开发者仍需控制每次批量操作的数据规模，如果确实有需要，可以通过设置持久化存储元数据（ [ NSSQLitePragmasOption
](https://developer.apple.com/documentation/coredata/nssqlitepragmasoption)
）的方式，修改 Core Data 的 SQLite 数据库的默认设置。

## 批量操作中的高级技巧

除了上文中介绍的能力外，批量操作中还有一些其他有用的技巧。

### 用约束来控制批量添加的行为

在 Core Data 中，通过在数据模型编辑器中将实体中某个属性（ 或某几个属性 ）设置为约束，以使此属性的值具有唯一性。

![image-20220605145151785](https://cdn.fatbobman.com/image-20220605145151785.png)

因为 Core Data 的唯一约束是依赖 SQLite 的特性实现的，因此批量操作也自然地拥有了这项能力。

假设，应用程序需要定期从服务器上下载一个巨大的 JSON 文件，并将其中的数据保存到数据库中。如果可以确定源数据中的某个属性是唯一的（ 例如
ID、城市名、产品号等等 ），那么可以在数据模型编辑器中将该属性设置为约束属性。当使用批量添加将 JSON 数据保存到数据库时，Core Data
将根据开发者设定的合并策略来进行操作（ 有关合并策略的详细内容，请参阅 [关于 Core Data 并发编程的几点提示]( [
https://fatbobman.com/zh/posts/concurrencyofcoredata/#设置正确的合并策略
](/zh/posts/concurrencyofcoredata/#%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5)
）的对应章节 )。比如说以新数据为准，或者以数据库中的数据为准。

Core Data 会根据是否在数据模型中开启了约束已经定义了何种合并策略来创建批量添加操作对应的 SQL 语句。例如下面的情况：

- 没有开启约束

SQL

Copy code

Copied!

    INSERT INTO ZQUAKE(Z_PK, Z_ENT, Z_OPT, ZCODE, ZMAGNITUDE, ZPLACE, ZTIME) VALUES(?, ?, ?, ?, ?, ?, ?)

- 开启了约束，并将合并策略设置为 NSErrorMergePolicy

此种状态下，新数据（ 约束属性一致 ）将忽略（ 不作改动 ）

SQL

Copy code

Copied!

    INSERT OR IGNORE INTO ZQUAKEZ_PK, Z_ENT, Z_OPT, ZCODE, ZMAGNITUDE, ZPLACE, ZTIME) VALUES(?, ?, ?, ?, ?, ?, ?)

- 开启了约束，并将合并策略设置为 NSMergeByPropertyObjectTrumpMergePolicy

在此种情况下，行为变成了更新

SQL

Copy code

Copied!

    INSERT INTO ZQUAKE(Z_PK, Z_ENT, Z_OPT, ZCODE, ZMAGNITUDE, ZPLACE, ZTIME) VALUES(?, ?, ?, ?, ?, ?, ?) ON CONFLICT(ZCODE) DO UPDATE SET Z_OPT = Z_OPT+1 , ZPLACE = excluded.ZPLACE , ZMAGNITUDE = excluded.ZMAGNITUDE , ZTIME = excluded.ZTIME

> 注意：创建约束与 Core Data with CloudKit 功能冲突，了解哪些属性或功能无法在 Core Data with CloudKit
> 下开启，请参阅 [ Core Data with CloudKit（二） —— 同步本地数据库到 iCloud 私有数据库
> ](/zh/posts/coredatawithcloudkit-2/#%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%90%8C%E6%AD%A5-model-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)

### 批量删除对 Core Data 关系的有限支持

在以下两种情况下，批量删除可以自动完成关系数据的清理工作：

- 采用了 Cascade 删除规则的关系

比如 Item 有一个名为 attachment 的关系（ 一对一或一对多 ），Item 端设定的删除规则为 Cascade 。在对 Item
进行批量删除时，Core Data 会自动将 Item 对应的 Attachment 数据一并删除

![image-20220605153333679](https://cdn.fatbobman.com/image-20220605153333679.png)

- 删除规则为 Nullify ，且关系为可选

比如 Item 有一个名为 attachment 的关系（ 一对一或一对多 ），Item 端设定的删除规则为 Nullify ，且关系为可选（
Optional ）。在对 Item 进行批量删除时，Core Data 会将 Item 对应的 Attachment 的关系 ID （ 对应 Item
）设置为 NULL（ 并不会删除这些 Attachment 数据 ）

![image-20220605154156584](https://cdn.fatbobman.com/image-20220605154156584.png)

或许正因为批量删除提供了对部分 Core Data 关系的支持，因此让它成为最常使用的批量操作。

## 总结

批量操作改善了某些场合下 Core Data 数据操作效率低、内存占用大的问题，使用得当，必将成为开发者的得力工具。

# SwiftUI 与 Core Data —— 数据获取

本文中我们将探讨在 SwiftUI 视图中批量获取 Core Data 数据的方式，并尝试创建一个可以使用 mock 数据的
FetchRequest。由于本文会涉及大量 [ 前文 ](/zh/posts/modern-core-data-data-definition/)
中介绍的技巧和方法，因此最好一并阅读。

- [ SwiftUI 与 Core Data —— 问题 ](/zh/posts/modern-core-data-problem/)
- [ SwiftUI 与 Core Data —— 数据定义 ](/zh/posts/modern-core-data-data-definition/)

## 创建可使用 Mock 数据的 FetchRequest

### FetchRequest 单向数据流的破坏者？

对于每一个在 SwiftUI 中使用 Core Data 的开发者来说，@FetchRequest 都是绕不开的话题。FetchRequest
极大地简化了在视图中获取 Core Data 数据的难度，配合 @ObservedObject（ 托管对象符合 ObservableObject 协议
），仅需几行代码，开发者便可以让视图实现对数据变化的实时响应。

但对于采用单向数据流方式的开发者，@FetchRequest 就像悬挂在头顶的达摩克利斯之剑，始终让其介怀。类 Redux 框架通常都建议开发者将整个
app 的状态合成到一个单一的结构实例中（ State ，符合 Equatable 协议 ），视图通过观察状态的变化（ 有些框架支持切片式的观察以改善性能
）而做出响应。而 @FetchRequest 将 app
中状态构成中的很大一部分从独立的结构实例中分拆出来，散落在多个视图之中。这几年不少开发者也尝试找寻更加符合 Redux 精神的替换方案，但效果都不理解。

我也做了不少的尝试，但最终发现似乎 FetchRequest 仍是当前 SwiftUI 中的最优解。简单介绍一下我探索过程（ 以 TCA 框架进行举例 ）：

- 在 Reducer 中获取并管理值数据

在 task（ 或 onAppear ）中通过发送 Action 启动一个长期的 Effect ，创建一个
NSFetchedResultsController 从 Core Data 中获取指定谓词的数据集。在
NSFetchedResultsControllerDelegate 实现中将托管对象转换成对应的值类型，并传递给 Reducer 。

在 State 中使用 IdentifiedArray 类型保存数据集，以便通过 .forEach 对 Reducer 进行拆分。

上述做法确实是完全符合 Redux 精神的一种方式，但由于在将托管对象转换到值类型这一过程中我们放弃了 Core Data
的懒加载这一特性，因此一旦数据量较多将导致严重的性能和内存占用问题。因此，只适合数据集较小的使用场景。

- 在 Reducer 中获取并管理 AnyConvertibleValueObservableObject

类似上面的方法，但省略了转换成值类型的过程，将托管对象包装成 AnyConvertibleValueObservableObject ，直接在 State
中保存引用类型。不过考虑到 TCA 在之后会将 Reducer 移出主线程，从线程安全的角度出发，最终放弃了该方案。

> 由于最终我们需要在视图中使用 AnyConvertibleValueObservableObject（ 托管对象
> ），因此数据的获取过程必须是在主线程上下文中进行的（ 数据绑定的上下文是 ViewContext ），Reducer 一旦从主线程中移出的话，意味着
> AnyConvertibleValueObservableObject 会被保存在非线程的 State
> 实例中。尽管在实践中，如果能在确保不访问托管对象的非线程安全属性的前提下，在非创建托管对象的线程中持有托管对象并不会出现崩溃的情况，但出于谨慎的考虑，我最终还是放弃了这种方式。

- 在 Reducer 中获取并管理 WrappedID

类似上面的方法，仅在 State 中保存线程安全的 WrappedID（ 包装后的 NSManagedObjectID ）。在视图中通过 WrappedID
获取到对应的 AnyConvertibleValueObservableObject
或值类型。尽管会增加一点视图的代码量，但这种方法无论从数据流的处理还是线程安全的角度来说几乎都是完美的。

不过，最终让我放弃上面所有尝试的原因还是因为性能问题。

- 任何 Core Data 数据的变化都将导致 app 的单一 State 发生改变，尽管 TCA 有切分机制，但随着应用复杂程度和数据量的增加，因对 State 进行比对而产生的性能问题将越发严重
- 创建 NSFetchedResultsController 并获取首批数据的操作是从 onAppear 中发起的，由于 TCA 的 Action 处理机制，数据的首次显示有可感知的延迟（ 效果远不如在视图中通过 FetchRequest 获取 ）
- 由于 TCA 的 Reducer 无法与视图的存续期自动绑定，上面的可感知延迟在每次触发 onAppear 时都将出现

最终，我决定放下心结，仍然采用在视图中使用类似 @FetchRequest 的方式来获取数据。通过新创建一个可以使用 Mock 数据的
FetchRequest ，实现了 [ SwiftUI 与 Core Data —— 问题 ](/zh/posts/modern-core-data-
problem/) 一文中提出的可测试、可预览、可模块化的目标。

### NSFetchedResultsController

NSFetchedResultsController 通过 NSFetchRequest 从 Core Data 中获取特定的数据集，并将数据集发送至符合
NSFetchedResultsControllerDelegate 协议实例中实现方法，以实现在屏幕上显示数据的目的。

简单地来说，NSFetchedResultsController 就是在首次获取数据集（ performFetch ）后，对
NSManagedObjectContextObjectsDidChange 以及
NSManagedObjectContextDidMergeChangesObjectIDs 通知进行响应，并根据通知内容（
insert、delete、update 等 ）自动更新内存中数据集。为了提高 UITableView（ UICollectionView
）的更新效率，NSFetchedResultsController 会将数据的变化分解成特定的动作（ NSFetchRequestResultType
）以方便开发者快速调整 UITableView 的显示内容（ 无需刷新全部的数据 ）。

遗憾的时，NSFetchedResultsController 为 UITableView 准备的基于 NSFetchRequestResultType
优化操作在 SwiftUI 中并不起作用。在 SwiftUI 中，ForEach 会根据数据标识（ Identifier
）自动处理视图的添加、删除等操作，因此，当在 SwiftUI 中使用 NSFetchedResultsController 时，只需要实现
NSFetchedResultsControllerDelegate 中的 `controllerDidChangeContent(_
controller: )` 方法即可。

### 自定义符合 DynamicProperty 协议的类型

在 SwiftUI 中，常见的可以作为 Source of truth 的类型均符合 DynamicProperty 协议。DynamicProperty
协议为数据提供了访问 SwiftUI 托管数据池的能力。通过未公开的 `_makeProperty` 方法，数据可以在 SwiftUI
数据池中申请空间进行保存并读取。这将有两个作用：

- 数据变化后将引发与其绑定的视图进行更新
- 由于底层数据并不保存在视图中，因此在视图存续期中 SwiftUI 可以随时创建新的视图描述实例而无需担心数据丢失

虽然苹果没有公开 `_makeProperty` 方法的具体细节，开发者无法自行向 SwiftUI 申请数据保存地址，但可以通过在自定义的类型中（ 符合
DynamicProperty 协议 ）使用系统提供的符合 DynamicProperty 协议的类型（ 如 State ）实现类似的效果。

在创建自定义 DynamicProperty 类型时，需要注意以下几点：

- 可以在自定义类型中使用环境值或环境对象

在视图被加载后，视图中所有符合 DynamicProperty 协议的类型也将一并具备访问环境数据的能力。但如果在视图尚未加载或没有提供环境值（
例如忘记注入环境对象，没有提供正确的视图上下文 ）的情况下访问环境数据，将引发应用崩溃。

- 当 SwiftUI 在视图存续期中重新创建视图描述实例时，自定义类型也将一并重新创建

在视图存续期中，如果 SwiftUI 创新创建了视图描述实例，那么无论视图描述（ 符合 View 协议的 Struct ）中的属性是否符合
DynamicProperty ，都将被重建。这意味着，必须将需要持久化的数据（ 与视图存续期一致 ）保存在系统提供的 DynamicProperty
类型中。

- 视图被 SwiftUI 加载后才会调用 update 方法

DynamicProperty 协议唯一公开的方法是 update ，SwiftUI 将在视图首次被加载以及符合 DynamicProperty
类型中的可引发视图更新的数据发生变化后调用该方法。由于类型的实例在视图存续期中可能会反复地被创建，因此对数据的准备（ 例如首次获取
NSFetchedResultsController 数据、创建订阅关系 ）以及更新工作都应在该方法中进行。

- 不可在 update 方法中同步地改变引发视图更新的数据

与 SwiftUI 在视图中更新 Source of truth 的逻辑一致，在一个视图更新周期中，不能对 Source of truth
再度更新。这意味着，尽管我们只能在 update 方法中更改数据，但必须要想办法错开该更新周期。

### MockableFetchRequest 的使用方法

MockableFetchRequest 提供与 FetchRequest 类似的动态获取数据的能力，但它有如下的特点：

- MockableFetchRequest 返回 AnyConvertibleValueObservableObject 类型的数据

MockableFetchRequest 中的 NSFetchedResultsController 会将数据直接转换为
AnyConvertibleValueObservableObject 类型，一方面可以在视图中直接享受前文中介绍的各种好处，另一方面也可以避免在视图中声明
MockableFetchRequest 时，使用具体的托管对象类型，有利于模块化开发。

     @MockableFetchRequest(\ObjectsDataSource.groups) var groups // 代码不会被具体的托管对象类型所污染

- 通过环境值切换数据源

在前文中，我们通过创建符合 TestableConvertibleValueObservableObject 协议的数据为一个包含单个
AnyConvertibleValueObservableObject 对象的视图提供了无需托管环境的预览能力。MockableFetchRequest
则为一个获取数据集的视图提供了无需托管环境预览一组数据的能力。

首先，我们需要创建一个符合 ObjectsDataSourceProtocol 协议的类型，通过让属性为 FetchDataSource 类型来指定数据源。

    // MockableFetchRequest 代码中已包含
    public enum FetchDataSource<Value>: Equatable where Value: BaseValueProtocol {
        case fetchRequest // 通过 MockableFetchRequest 中的 NSFetchedResultsController 获取数据
        case mockObjects(EquatableObjects<Value>) // 使用提供的 Mock 数据
    }

    public extension EnvironmentValues {
        var dataSource: any ObjectsDataSourceProtocol {
            get { self[ObjectsDataSourceKey.self] }
            set { self[ObjectsDataSourceKey.self] = newValue }
        }
    }

    // 开发者需要自定义的代码
    public struct ObjectsDataSource: ObjectsDataSourceProtocol {
        public var groups: FetchDataSource<TodoGroup>
    }

    public struct ObjectsDataSourceKey: EnvironmentKey {
        public static var defaultValue: any ObjectsDataSourceProtocol = ObjectsDataSource(groups: .mockObjects(.init([MockGroup(.sample1).eraseToAny()]))) // 设置默认的数据源来自 mock 数据
    }

可以在预览的时候对数据进行实时修改（ 详情请参阅 Todo 中的 [ GroupListContainer 代码
](https://github.com/fatbobman/Todo/blob/main/Todo-PureSwiftUI/Todo-
PureSwiftUI/GroupListContianer.swift) ）。

![image-20221203183414864](https://cdn.fatbobman.com/image-20221203183414864.png)

当应用运行于托管环境时，仅需提供正确的视图上下文，并将 dataSource 中的属性值修改成 fetchRequest 即可。

![image-20221203185621897](https://cdn.fatbobman.com/image-20221203185621897.png)

- 允许在构造方法中不提供 NSFetchRequest

当在视图中使用 @FetchRequest 时，我们必须在声明 FetchRequest 变量时设置 NSFetchRequest（ 或者
NSPredicate ）。如此一来，在将视图提取到一个单独的 Package 时，仍需导入包含具体 Core Data
托管对象定义的库，无法做到完全的解耦。在 MockableFetchRequest 中，无需在声明时提供
NSFetchRequest，可以在视图加载时，动态地为 MockableFetchRequest 提供所需的 NSFetchRequest（ [
详细演示代码
](https://github.com/fatbobman/Todo/blob/main/ViewLibrary/Sources/ViewLibrary/GroupList.swift)
）。

    public struct GroupListView: View {
        @MockableFetchRequest(\ObjectsDataSource.groups) var groups
        @Environment(\.getTodoGroupRequest) var getTodoGroupRequest

        public var body: some View {
            List {
                    ForEach(groups) { group in
                        GroupCell(
                            groupObject: group,
                            deletedGroupButtonTapped: deletedGroupButtonTapped,
                            updateGroupButtonTapped: updateGroupButtonTapped,
                            groupCellTapped: groupCellTapped
                        )
                    }
            }
            .task {
                guard let request = await getTodoGroupRequest() else { return } // 在视图加载时通过环境方法获取所需的 Request
                $groups = request // 动态对 MockableFetchRequest 设置
            }
            .navigationTitle("Todo Groups")
        }
    }

- 避免对不引发 ID 变化的操作更新数据集

当数据集的 ID 顺序或数量没有发生变化时，即使数据的属性值发生变化，MockableFetchRequest 也不会更新数据集。因为
AnyConvertibleValueObservableObject 本身符合 ObservableObject 协议，因此尽管
MockableFetchRequest 没有更新数据集，但视图仍会对 AnyConvertibleValueObservableObject
中的属性变化进行响应。这样可以减少 ForEach 数据集的变化频次，改善 SwiftUI 的视图效率。

- 提供了一个更加轻巧的 Publisher 以监控数据变化

原版的 FetchRequest 提供了一个 Publisher（ 通过投影值 ），会对每次的数据集变化做出响应。不过该 Publisher
的响应过于频繁，即使数据集中仅有一个数据的属性发生改变，也会下发数据集中的所有数据。MockableFetchRequest
对此进行了简化，仅会在数据集发生变化时，下发一个空的通知（ `AnyPublisher<Void, Never>` ）。

    public struct GroupListView: View {
        @MockableFetchRequest(\ObjectsDataSource.groups) var groups

        public var body: some View {
            List {
    		   ...
            }
            .onReceive(_groups.publisher){ _ in
                print("data changed")
           }
        }
    }

> 如果需要实现与 @FetchRequest 一样的效果，仅需提高 sender 属性的权限即可

下图为完全依赖 mock 数据创建的预览演示：

![mockableFetchRequest_demo_2022-12-04_11.12.46.2022-12-04
11_14_21](https://cdn.fatbobman.com/mockableFetchRequest_demo_2022-12-04_11.12.46.2022-12-04%2011_14_21.gif)

### MockableFetchRequest 代码说明

本节仅对部分代码进行说明， [ 完整代码请于此处查看
](https://github.com/fatbobman/Todo/blob/main/Core/Sources/Core/ModernCoreData/MockableFetchRequest.swift)
。

- 如何避免更新数据与 update 周期重合

在 MockableFetchRequest 中，我们通过一个类型为 `PassthroughSubject<[AnyConvertibleValueObservableObject<Value>], Never>` 的
Publisher，统一管理两个不同的数据源。通过使用 delay 操作符，便可以实现对数据的错峰更新。如有需要，也可以通过创建 Task
实现对数据的异步更新。

    cancellable.value = sender
        .delay(for: .nanoseconds(1), scheduler: RunLoop.main) // 延迟 1 纳秒即可
        .removeDuplicates {
            EquatableObjects($0) == EquatableObjects($1)
        }
        .receive(on: DispatchQueue.main)
        .sink {
            updateWrappedValue.value($0)
        }

- 用引用类型包装需要修改的数据，避免引发视图的不必要的更新

通过创建一个具有包装用途的引用类型来持有需要修改的数据（ 在 @State 中持有引用
），便可以达成如下目的：1、让数据的生命周期与视图生存期一致；2、数据可更改；3、更改数据不会引发视图更新。

      extension MockableFetchRequest {
          // 包装类型
          final class MutableHolder<T> {
              var value: T
              @inlinable
              init(_ value: T) {
                  self.value = value
              }
          }
      }

      public struct MockableFetchRequest<Root, Value>: DynamicProperty where Value: BaseValueProtocol, Root: ObjectsDataSourceProtocol {
          @State var fetcher = MutableHolder<ConvertibleValueObservableObjectFetcher<Value>?>(nil)

          func update() {
              ...
              // fetcher 是可持久的，修改 fetcher.value 不会引发视图更新
              if let dataSource = dataSource as? Root, case .fetchRequest = dataSource[keyPath: objectKeyPath], fetcher.value == nil {
                  fetcher.value = .init(sender: sender)
                  if let fetchRequest {
                      updateFetchRequest(fetchRequest)
                  }
              }
              ...
          }
      }

- 如何比较两个 `[AnyConvertibleValueObservableObject<Value>]` 是否相同

由于 Swift 无法直接对包含关联类型的数据进行相等比较，因此创建了一个中间类型 EquatableObjects ，并让其符合 Equatable
协议以方便对两个 `[AnyConvertibleValueObservableObject<Value>]` 数据进行比较，避免不必要的视图刷新。

      public struct EquatableObjects<Value>: Equatable where Value: BaseValueProtocol {
          public var values: [AnyConvertibleValueObservableObject<Value>]

          public static func== (lhs: Self, rhs: Self) -> Bool {
              guard lhs.values.count == rhs.values.count else { return false }
              for index in lhs.values.indices {
                  if !lhs.values[index]._object.isEquatable(other: rhs.values[index]._object) { return false }
              }
              return true
          }

          public init(_ values: [AnyConvertibleValueObservableObject<Value>]) {
              self.values = values
          }
      }

      // in MockableFetchRequest
      if let dataSource = dataSource as? Root, case .mockObjects(let objects) = dataSource[keyPath: objectKeyPath],
         objects != EquatableObjects(_values.wrappedValue)  // 去重
      {
          sender.send(objects.values)
      }

      ...

      cancellable.value = sender
          .delay(for: .nanoseconds(1), scheduler: RunLoop.main)
          .removeDuplicates {
              EquatableObjects($0) == EquatableObjects($1) // 去重
          }
          .receive(on: DispatchQueue.main)
          .sink {
              updateWrappedValue.value($0)
          }

- 通过操作底层数据解决无法在闭包中引入 self 的问题

在订阅闭包中使用底层数据，如此就可以绕过无法在结构体中引入 self 的问题。

    let values = _values  // 对应的类型是 State ，也就是 MockableFetchRequest 的 values 属性的底层数据
    let firstUpdate = firstUpdate
    let animation = animation
    updateWrappedValue.value = { data in
        var animation = animation
        if firstUpdate.value {
            animation = nil
            firstUpdate.value = false
        }
        withAnimation(animation) {
            values.wrappedValue = data // 对底层数据进行操作
        }
    }

### SectionedFetchRequest

我暂时没有对另一个获取数据的方法 SectionedFetchRequest 进行改动。主要的原因是尚未想好要如何地组织返回数据。

当前，SectionedFetchRequest 在数据量较大时会有较严重的性能问题。这是由于一旦 SwiftUI 的惰性容器中出现了多个 ForEach
，惰性容器将丧失对子视图的优化能力。任何数据的变动，惰性容器都将对所有的子视图进行更新而不是仅更新可见部分的子视图。

SectionedFetchRequest 返回的数据类型为 SectionedFetchResults ，可以将其视为一个以
SectionIdentifier 为键的有序字典。读取其数据必然会在惰性容器中使用多个 ForEach ，从而引发性能问题。

    @SectionedFetchRequest<String, Quake>(
        sectionIdentifier: \.day,
        sortDescriptors: [SortDescriptor(\.time, order: .reverse)]
    )
    private var quakes: SectionedFetchResults<String, Quake>

    List {
        ForEach(quakes) { section in
            Section(header: Text(section.id)) {
                ForEach(section) { quake in
                    QuakeRow(quake: quake)
                }
            }
        }
    }

我目前有两种构想：

- 将所有的数据以一个数组进行返回（ sectionIdentifier 为首要排序条件 ），并同时提供每个 Section 在返回数组中对应的起始 offset（ 或对应的 ID ）以及该 Section 中的数据量。
- 将所有的数据以一个数组进行返回（ sectionIdentifier 为首要排序条件 ），在每个 Section 头尾插入特定的 AnyConvertibleValueObservableObject 数据（ 因为 WrappedID 的存在，我们可以很容易创建 mock 数据 ）

无论上述哪种方式，开发者都需放弃使用 SwiftUI 原生的 Section 功能，在惰性容器中，根据提供的附加数据自行对数据做分段显示处理。

> Core Data 本身并不具备直接从 SQLite 中获取分组记录的能力，目前的实现方式是以 sectionIdentifier
> 为首要排序条件获取所有的数据。然后通过 propertyToGroupBy 对 sectionIdentifier 进行分组，获取每组的数据量（
> count ）。通过返回的统计信息，计算每个 Section 的偏移量。

## 本文总结及下文介绍

本文中我们创建了可以支持 mock 数据的 FetchRequest ，并简单介绍了在自定义符合 DynamicProperty
协议的类型时需要注意的事项。

在下一篇文章中，我们将探讨如何在 SwiftUI 中安全地响应数据，如何避免因为数据意外丢失而导致的行为异常以及应用崩溃。

# 玩转 Xcode Playground（上）

在 Swift 语言推出的同一年（2014 年），苹果就在 Xcode 中集成了 Playground 功能。相较标准的 Xcode
项目，Playground 启动更快、使用更轻巧，被广泛应用于 Swift 语言学习、框架 API
测试、快捷数据处理、汇集灵感等众多方面。本系列将介绍大量有关 Xcode Playground
的使用技巧，涉及稳定性、第三方库、资源管理、异步处理、文档标注等等方面，让你玩转 Playground，使其成为你工作学习中的利器。

## 创建与设置

### .playground vs .playgroundbook

在 Xcode 中创建的 Playground 项目被保存为以 `.playground` 为后缀的包（可以通过显示包内容查看其中的文件）。 `.playground` 可以直接在 Xcode 和 Swift Playgrounds 3. x 以上的版本打开。

`.playgroundbook` 是 Swift Playgrounds 特有的包格式，相较 `.playground`
，它包含了很多独有的功能，这些功能主要用于改善 Swift Playgrounds 在教育和娱乐方面的体验。 `.playgroundbook`
格式只能在 Swift Playgrounds 上打开。

> 更多关于最新 Swift Playgrounds 4 的介绍请阅读 [ Swift Playgrounds 4 娱乐还是生产力
> ](/zh/posts/swiftplaygrounds4/)

本系列介绍的技巧主要针对 Xcode Playground （也就是 `.playground` ），多数技巧同时适用于 Xcode 和 Swift
Playgrounds，仅适用于单独平台的技巧会做出明确地标注。

### 如何创建 Playground 项目

#### 在 Xcode 中创建 Playground 项目

在 Xcode 中，点击 File -> New -> Playground 即可创建一个格式为 `.playground` 的 Xcode
Playground 项目。

![image-20211223162302918](https://cdn.fatbobman.com/image-20211223162302918.png)

Playground 提供了数种预置模版，模版选择界面的系统设定（ iOS、macOS）仅影响模版代码，并不会自动设置 Page 的运行环境。

![image-20211223164000220](https://cdn.fatbobman.com/image-20211223164000220.png)

Xcode 可以打开 Playground 项目，也可以将 Playground 项目添加到 Project 或 Workspace 中（有助于测试 SPM
或调用 Project 中自定义的类型）。

#### 在 Swift Playgrounds 中创建 Playground 项目

在 Swift Playgrounds 4 中可以直接创建与 Xcode 兼容的 Playground 项目（ `.playground`
）。点击首页下方的【查看全部】，选择其中的 Xcode Playground。

![image-20211224160807063](https://cdn.fatbobman.com/image-20211224160807063.png)

_请注意：首页下方的 Playground 按钮创建的是`playgroundbook` 。 _

![image-20211223161945374](https://cdn.fatbobman.com/image-20211223161945374.png)

Swift Playgrounds 创建的项目，默认保存在 iCloud 云盘的 Playgrounds 目录中。尽量不要同时在 macOS 的 Xcode
和 iPad 的 Swift Playgrounds 上同时编辑一个项目，容易造成版本冲突。

### 如何创建多个 Playground Page

Playground 鼓励开发者每次只关注一个议题，通过将议题分散到不同的 Page 来帮助开发者组织代码和对应的资源。

新建的 Playground 项目默认只有一个 Page（单 Page 模式下，左侧的导航栏中 Page 和 Playground 项目将合并显示）。每个
Page 都可以设置对应的实时视图。

![image-20211223164606421](https://cdn.fatbobman.com/image-20211223164606421.png)

在 Xcode 中，通过 File 菜单或在导航栏 Playground 项目上点击右键，可以创建新的 Playground Page。

![image-20211223170027028](https://cdn.fatbobman.com/image-20211223170027028.png)

![image-20211223170047358](https://cdn.fatbobman.com/image-20211223170047358.png)

当不只有一个 Page 后，Playground 项目和 Page 将分开显示。

在 Swift Playgrounds 4 中，点击侧边栏的 `编辑` 按钮，进入编辑模式，点击 `+` 按钮可创建新的 Page。

![image-20211223175608008](https://cdn.fatbobman.com/image-20211223175608008.png)

可以调整 Page 顺序，并可修改每个 Page 的名称（不仅有助于标识，更方便在不同的 Page 中实现快速跳转）。

在单 Page 模式下，项目中只有一组 Sources 和 Resources 目录。在多 Page 模式下，除了项目根目录下的 Sources 和
Resources 外，每个 Page 也都有自己的 Sources 和 Resources 目录。

![image-20211223170801239](https://cdn.fatbobman.com/image-20211223170801239.png)

每个 Page 都应视为独立的 Module，Page A 中的代码不可被 Page B 调用。

### 如何调试代码

Playground 并不提供设置断点的功能，但是可以通过指定执行结束点或单步执行的方式来满足部分的调试需求。

在 Xcode 中，通过点击代码左侧行数上的执行按钮（需要按钮的颜色为蓝色）来指定当前执行的结束位置。

![image-20211223180328839](https://cdn.fatbobman.com/image-20211223180328839.png)

点击当前结束位置之后的蓝色执行按钮可以继续向下执行。点击代码编辑区域下方的执行按钮，将重新执行全部代码。

在输入新的代码后，可以采用输入 Shift-Return 的方式让 Playground
执行截至本行尚未执行的代码。此种方式在不希望反复执行长耗时代码段的情况下将非常有用（例如机器学习）。

在单步模式下，对于行首为蓝色执行按钮的代码进行修改，无需重置执行。如果修改了已经执行过的代码行（行首显示为灰色），必须重置 Playground
（点击代码编辑区域下方的执行按钮）才能反应出你做的更改。

Swift Playgrounds 没有提供设置执行结束位置的功能，但提供了单步执行的设定。点击屏幕下方的仪表按钮，可以设定调试方式。

![image-20211223180913086](https://cdn.fatbobman.com/image-20211223180913086.png)

### 提高 Xcode 下的运行稳定性（Xcode Only）

#### 设置运行环境

在 Xcode 中，可以在右侧的 Playground Settings 中设定 Playground 的运行环境。

![image-20211223144432779](https://cdn.fatbobman.com/image-20211223144432779.png)

在没有必须依赖 iOS 框架代码的情况下，将运行环境设置为 macOS 可以减少因 iOS 模拟器错误引发的不稳定状况。

当有多个 Playground Page 时，可以为每个 Page 单独设置对应的运行环境。

![image-20211223144916673](https://cdn.fatbobman.com/image-20211223144916673.png)

当有多个 Playground Page 时，点击最上方的项目名称，可以为所有 Page 一并设置成统一的运行环境

![image-20211223144934347](https://cdn.fatbobman.com/image-20211223144934347.png)

Swift Playgrounds 仅兼容运行环境为 iOS 的 Playground 项目。

#### 将运行方式改成手动

在运行方式被设置为自动模式时，每当你修改代码后，系统都会自动运行代码并显示结果。自动模式在代码内容较少且简单的情况下表现还不错，不过一旦代码较多且复杂后，自动运行模式将导致系统资源占用较多，且容易出现运行不稳定的情况。

![image-20211223150747157](https://cdn.fatbobman.com/image-20211223150747157.png)

长按代码编辑区域下方的执行按钮，可以在两种模式中进行选择。

在 Xcode 的配置中，可以为 Playground 指定适合的快捷键，提高操作效率。

![image-20211223151240337](https://cdn.fatbobman.com/image-20211223151240337.png)

### 如何查看结果栏

Playground 在 Xcode
中拥有一个独有的显示区域——结果栏，该区域不仅可以显示每行代码的当前值、历史状态，同时也会显示关于调用次数、文件信息等等内容。

![image-20211224091253473](https://cdn.fatbobman.com/image-20211224091253473.png)

例如上图中，55 行显示了图片的尺寸信息，57 行显示了 y 在当前行的值，59 行则显示了在循环中本行的执行次数。

![image-20211224091811968](https://cdn.fatbobman.com/image-20211224091811968.png)

当鼠标靠近右侧的屏幕图标时，将出现眼睛图标。点击眼睛图标将显示该行代码对应的 Quick Look 内容。点击屏幕图标可以将 Quick Look
内容显示在代码编辑区域中（内联显示）。

![image-20211224091947472](https://cdn.fatbobman.com/image-20211224091947472.png)

Quick Look 的内容可以在最新值、历史记录、图表模式间切换（可切换模式的数量将根据类型的不同而有所变化）。

![image-20211224092212674](https://cdn.fatbobman.com/image-20211224092212674.png)

Swift Playgrounds 中对于 Quick Look 的操作与 Xcode 类似，并可通过关闭【启用结果】来提高代码的执行效率。

### 如何创建自定义 Quick Look

苹果已经为不少的系统类型提供了 Playground 下的 Quick Look 支持。通过让其他的系统类型（主要集中于较新的
API）以及我们自定义的类型满足 CustomPlaygroundDisplayConvertible 协议，以提供 Quick Look 支持。

比如说，WWDC 2021 上新推出的 [ AttributedString ](/zh/posts/attributedstring/) 目前尚不支持
Quick Look ，但通过在 playgroundDescription 中将其转换为 NSAttributedString，就可以直接在
Playground 中显示正确的 Quick Look 了。

下图为，没有满足 CustomPlaygroundDisplayConvertible 协议的状况。AttributedString 的 Quick
Look 为结构体的 Dump 样式。

![image-20211224142839306](https://cdn.fatbobman.com/image-20211224142839306.png)

苹果为 NSAttributedString 提供了正确的 Quick Look 实现，将 AttributedString 转换成
NSAttributedString 以实现更好的显示效果。

    extension AttributedString: CustomPlaygroundDisplayConvertible {
        public var playgroundDescription: Any {
            NSAttributedString(self)
        }
    }

![image-20211224142915994](https://cdn.fatbobman.com/image-20211224142915994.png)

## PlaygroundSupport

### 什么是 PlaygroundSupport

PlaygroundSupport 是专门用于扩展 Playground 的框架。提供了在 Playground 中共享数据、管理实时视图、控制
Playground 运行模式等功能。

在需要的 Playground Page 的代码中通过 `import PlaygroundSupport` 导入框架。

### 如何获得异步执行的结果（Swift Playgrounds Only）

在老版本的 Xcode（Xcode 12、Xcode 13 已经解决了这个问题）以及 Swift Playgrounds
中，如果不经过特别的设定，Playground 并不会等待异步代码的返回结果，在完成了全部的代码调用后即结束执行。需要将 Playground
设置为无限执行模式后，才会在获得异步执行的结果后方终止运行状态。

在 Swift Playgrounds 中执行下面的代码并不会获得打印结果

    DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
        print("Hello world")
    }

需要导入 `PlaygroundSupport` ，并设置 needsIndefiniteExecution 为 true 。

    import PlaygroundSupport
    PlaygroundPage.current.needsIndefiniteExecution = true
    DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
        print("Hello world")
    }

_每个 Page 都需要单独设置，且不能在代码的最后设定。_

### 如何执行 async/await 代码

> 本节内容并不需要 PlaygroundSupport 的支持，但为了同【如何获得异步执行的结果】章节靠近，故放置在此处

在 Playground 中使用新的 async/await 代码时，需要导入 `_Concurrency` 方可正常运行代码。

    import _Concurrency

    Task {
        try await Task.sleep(nanoseconds: 2_000_000_000)
        print("Hello world")
    }

_在 Swift Playgrounds 中执行上述代码时，需要设置 needsIndefiniteExecution。_

### 如何创建实时视图

你可以使用实时视图来为 Playground 添加互动性，试验不同的用户界面元素，并建立自定义元素。通过导入 PlaygroundSupport
并将当前页面的实时视图设置为你的自定义视图或视图控制器，就可以将一个交互式实时视图添加到 Playground Page 中。

![image-20211224105528272](https://cdn.fatbobman.com/image-20211224105528272.png)

实时视图支持 SwiftUI 视图以及 UIKit（AppKit）的视图和视图控制器。SwiftUI 视图需要通过 setLiveView 来设定。

    import PlaygroundSupport
    import UIKit

    let lable = UILabel(frame: .init(x: 0, y: 0, width: 200, height: 100))
    lable.text = "Hello world"
    lable.textAlignment = .center
    lable.textColor = .red

    //PlaygroundPage.current.setLiveView(lable) UIKit 视图，两种设置方法都可以
    PlaygroundPage.current.liveView = lable

_在设置了实时视图后，Playground 会自动将 needsIndefiniteExecution 设置为 true。_

如果想通过代码终止执行，可以使用 `PlaygroundPage.current.finishExecution()`

> 在 Xcode 中，还可以通过 `PlaygroundPage.current.liveTouchBar` 来自定义 Touchbar。

### 如何让其他的类型实例在实时视图中显示

任何符合 PlaygroundLiveViewable 协议的类型，都可以被设置为实时视图。

下面的代码让 UIBezierPath 可以直接在动态视图中显示

![image-20211224140536980](https://cdn.fatbobman.com/image-20211224140536980.png)

    import PlaygroundSupport
    import UIKit

    let path = UIBezierPath()
    var point = CGPoint(x: 0, y: 0)
    path.move(to: point)
    point = CGPoint(x: 100, y: 0)
    path.addLine(to: point)
    point = CGPoint(x: 200, y: 200)
    path.addLine(to: point)

    extension UIBezierPath: PlaygroundLiveViewable {
        public var playgroundLiveViewRepresentation: PlaygroundSupport.PlaygroundLiveViewRepresentation {
            let frame = self.bounds
            let view = UIView(frame: frame)
            view.backgroundColor = UIColor(red: 1, green: 0, blue: 0, alpha: 1)
            let layer = CAShapeLayer()
            layer.path = self.cgPath
            view.layer.mask = layer
            return .view(view)
        }
    }

    PlaygroundPage.current.liveView = path

### 获取 Playground 的共享目录 （playgroundSharedDataDirectory）

playgroundSharedDataDirectory 指向一个可以在 Playground Page 之间共享资源的目录。

如果 Playground Page 被设置在 macOS 模式，该目录中的内容可以在不同的 Playground 项目 macOS 模式的 Page
中共享。如果 Playground Page 运行在 iOS 模式，该目录中的内容只能在同一个 Playground 项目的 iOS 模式的 Page
中共享（每个 Playground 项目都有各自对应的 iOS 模拟器，）。

    import PlaygroundSupport
    import AppKit

    let url = playgroundSharedDataDirectory.appendingPathComponent("playground1.png")
    if let data = try? Data(contentsOf: url) {
        _ = NSImage(data: data)
    }

在 macOS 下，该目录为用户文档目录下的 `Shared Playground Data` 子目录。系统并不会自动创建该目录，需要手动创建。

playgroundSharedDataDirectory 主要用于在 macOS 下保存多个 Playground 项目共同所需的数据。在单个
Playground 项目中，可以通过项目的 Resource 目录在 Page 间共享数据。

## 总结

在 [ 玩转 Xcode Playground（下） ](/zh/posts/xcodeplayground2/) 中，我们将着重介绍有关
SPM、资源管理、辅助代码、文档标注等方面的内容。

# 我正在使用中的博客创作工具

从 2020 年 4 月开始，截至本月，我的博客【肘子的 Swift 记事本】已创建 2
年了。这期间，使用过不少的工具以协助博客的创作。本文将对我正在使用中的应用工具（包含资料收集整理、文本编辑、截图及录屏、格式转换、图片编辑、图床管理等方面）做以介绍。

## 资料收集整理

### 印象笔记

> 高级账户 148 元/年

让我坚持使用 [ 印象笔记 ](https://www.yinxiang.com) 的动力便是它提供的 web clipper 工具—— [ 剪藏
](https://www.yinxiang.com/product/webclipper1/)
。剪藏让用户可以只保存部分的网页内容并且提供了保存自动翻译后的页面能力。我将印象笔记作为网络内容资料库，保存了大量有价值的内容，供日后查询和整理。遗憾的是，剪藏目前并没有提供
iOS 版本插件。

有一点需要吐槽，作为高级账户成员，印象笔记仍总是不断地提示我升级到专业版本，略影响使用感受。如果你每个月保存的内容不太多且无需在超过 2
台设备上登录，免费版应该可以满足大多数人的需求了。

![image-20220429091144548](https://cdn.fatbobman.com/image-20220429091144548.png)

### OneNote

> Office 365 家庭版，不到 400 元/年 （优惠后）

在 Office 365 提供的所有软件中，OneNote 对我来说是最有用的工具。无论是做学习笔记还是知识整理，几年来，我在 OneNote
中记录、整理了不少的内容。遗憾的是 macOS 版本无法使用 markdown 插件，因此我会以截图的方式记录代码片段（此种方式对空间的占用较大，幸好
OneDriver 提供了 1TB 的容量），并将保存完整的源代码文件以附件的形式添加在笔记中。由于 OneNote
对图片内文本的搜索准确度很好，因此并不会带来查找上的困难。

近几年 OneNote 基本上没有增加什么新的功能，不知道是不是微软将更多的精力都放在了即将发布的 Loop 上面。

![image-20220429091230243](https://cdn.fatbobman.com/image-20220429091230243.png)

## 文本编辑

### Typora

> 89 元

[ Typora ](https://typora.io) 的最大优势便是沉浸感。作为一个所见即所得的 Markdown 格式编辑器，Typora
为创作者提供了更加专注的写作环境。

Typora 转入收费模式后，在网络上引起了一些讨论，对我而言，当前的价格是对得起它的品质的。

![image-20220429090947550](https://cdn.fatbobman.com/image-20220429090947550.png)

### VSCode

> 免费

由于 Typora 缺乏插件机制以及 Git 版本控制能力（当前的版本管理是基于时间机器的），因此我使用 [ VSCode
](https://visualstudio.microsoft.com) 作为 markdown 文本的格式校验以及文件管理工具。

有两个 VSCode 的插件对我的帮助很大：

- [ markdownlint ](https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint)

检查 markdown 文件中的语法错误

- [ Pangu-Markdown ](https://marketplace.visualstudio.com/items?itemName=xlthu.Pangu-Markdown)

自动为英文添加空格，改善中英文的混排格式

![image-20220429090832604](https://cdn.fatbobman.com/image-20220429090832604.png)

## 截图及录屏

### QuickTime

> 免费

QuickTime 作为 macOS
的内置应用，提供了不错的截图和录屏能力。遗憾的是较少的选项和附加功能限制了它的能力上限。但通过它以原生分辨率（5K、6K）录制的屏幕视频，效果十分惊人。

![image-20220429091343815](https://cdn.fatbobman.com/image-20220429091343815.png)

另外，我也会使用 QuickTime 作为视频的剪裁和格式转换工具。

### iShot

> 29 元 / 年

[ iShot ](https://www.better365.cn/ishot.html)
是一个十分优秀的国产截屏软件，提供了截屏美化（阴影、设备边框）、即时标注等功能。它是我目前使用率最高的截屏工具。其免费版本提供的功能已经能够满足绝大多数使用者的需求了。本文中的截图都是使用
iShot 来完成的。

![image-20220429091417362](https://cdn.fatbobman.com/image-20220429091417362.png)

### Xcode Simulator

> 免费

在仅需获取模拟器截图或不需要录制设备外框的情况下，Simulator 是非常好的选择。不过由于缺乏定制能力，我几乎不会使用它的 Gif 动图录制功能。

![image-20220429091437825](https://cdn.fatbobman.com/image-20220429091437825.png)

### RocketSim PRO

> 99 美元/年

[ RocketSim PRO ](https://www.rocketsim.app) 是知名 Swift 博主 [ Antoine van der
Lee ](https://www.avanderlee.com) 开发的工具。最初的版本仅拥有模拟器录屏能力，经过快速的迭代升级（当前为 7.0
版本），目前则是添加了 UI 比对、Deep link
测试、模拟器应用权限设置等众多功能。正常情况下，免费版提供的功能已够不少开发者使用了，之所以购买了收费版本，一是为了获得更好的视频录制能力（可以集成录制设备边框），另外也是对该作者长期以来提供的优秀文章的感谢。

![image-20220429091543718](https://cdn.fatbobman.com/image-20220429091543718.png)

### CodeShot

> 5.99 美元

[ CodeShot ](https://codeshotapp.com) 是另一位优秀的 Swift 博主 [ Sarun
](https://sarunw.com) 开发的 mac
应用。它可以将代码片段转换成漂亮的图片以便在文章或社交媒体上分享。虽然已经有提供类似功能的网站，但我更喜欢使用原生的应用版本。

![image-20220429093740171](https://cdn.fatbobman.com/image-20220429093740171.png)

## 格式转换

### Gif Brewery

> 4.99 美元

[ GIF Brewery ](https://apps.apple.com/us/app/gif-brewery-3-by-
gfycat/id1081413713?mt=12&uo=4&app=apps) 是动图网站 gfcat 提供的 Gif 动图制作工具。尽管已经 3
年没有更新了，但即便在当前也难觅敌手。除了可以将视频转换成 Gif 动图外，还支持添加文字、标识编辑、视频录制、动图管理等众多功能。

![image-20220429091657780](https://cdn.fatbobman.com/image-20220429091657780.png)

### handBrake

> 免费且开源

[ handBrake ](https://handbrake.fr) 是一款支持众多音视频格式的编解码工具。高效、小巧且免费，几乎找不到缺点。

![image-20220429091833320](https://cdn.fatbobman.com/image-20220429091833320.png)

## 图片编辑

### 预览

> 免费

macOS 系统的内置应用——预览是我使用率最高的图片编辑工具。大多数情况下，它都是我更改视图尺寸的首选。

![image-20220429092834814](https://cdn.fatbobman.com/image-20220429092834814.png)

### Figma

> 个人免费版

[ Figma ](https://www.figma.com) 是我用来制作 Twitter card
和其他出现在博客中的矢量图的主要工具。免费版本已经完全能够满足我的需求。随着国内类似产品的不断完善，我最近正逐步切换到 pixso 上。

![image-20220429092949936](https://cdn.fatbobman.com/image-20220429092949936.png)

### Affinity Photo

> 168 元（疫情打折时价格）

疫情初期购买了 Affinity 的三件套（绝对良心价格 168 \* 3）。我主要用 [ Affinity Photo
](https://affinity.serif.com/en-gb/photo/) 对位图进行编辑和处理。相较于 Pixelmator
Pro，Affinity Photo 的功能设定和 UI 布局更接近于 PS 的使用习惯。

![image-20220429093111762](https://cdn.fatbobman.com/image-20220429093111762.png)

## 图床管理

### picGo

[ PicGo ](https://github.com/Molunerfinn/PicGo) 是一个用于快速上传图片并获取图片 URL
链接的工具，Typora 对其提供了完美的支持。事实上，在 PicGo 中完成了图床的设定后，我就没有再单独地开启过这个软件了。

![image-20220429093145410](https://cdn.fatbobman.com/image-20220429093145410.png)

### kodo Browser

[ 七牛 ](https://www.qiniu.com) 提供的官方文件管理器，仅在批量上传图片时使用。

![image-20220429093219705](https://cdn.fatbobman.com/image-20220429093219705.png)

## 总结

工欲善其事，必先利其器。趁手的工具可以帮助使用者做到事半功倍。

# 关于 Core Data 并发编程的几点提示

Swift 5.5 提供了盼望已久的 async/await 的功能，为多线程开发带来了前所未有的便利。但 Core Data
由于其特有的并发规则，使用不慎容易导致代码陷入不可控状态，因此让不少开发者对在 Core Data 中进行多线程开发产生了望而却步的情绪。本文将对 Core
Data 并发编程中几个常见的问题予以提示，以便开发者更好地了解 Core Data 的并发规则，充分享受 Core Data 提供的强大功能。

## 启用 Core Data 并发调试参数

开发者在 Core Data
中使用并发编程很容易碰到如下场景：程序在调试期间没有出现问题。程序上线后，由于使用者的增多，会出现无法预期、难以重现、定位麻烦的程序异常或崩溃。其中有不少是因错误的使用
Core Data 的并发编程而产生的。

为了将因违反 Core Data 并发规则导致的问题尽量扼杀在开发阶段，在使用 Core Data 框架时，务必在启动参数上添加 `-com.apple.CoreData.ConcurrencyDebug 1` 。该标志将迫使程序执行到理论上会导致并发异常的 Core Data
代码时，立刻抛出错误。做到及时发现，尽早解决。

![image-20211104164632098](https://cdn.fatbobman.com/image-20211104164632098.png)

下文中的部分代码片段，只有在开启该标志后才会抛出错误，否则超过 90%以上的几率都不会有异常表现（继续保留隐患）。

## 使用后台上下文减少主线程阻塞

无论硬件发展的多么迅速，操作系统、API 框架、各式服务总会想尽办法将其能力用尽榨干。尤其随着设备显示刷新率的不断提高，主线程（UI
线程）的压力也越来越大。通过创建后台托管对象上下文（私有队列上下文），降低 Core Data 对主线程的占用。

在 Core Data 中，我们可以创建两种类型的托管对象上下文（NSManagedObjectContext）——主队列上下文和私有队列上下文。

- 主队列上下文（NSManagedObjectContextConcurrencyType. mainQueueConcurrencyType ）

定义于且只能用于主队列上的托管对象上下文。从事同界面（UI）有关的工作，主要用来从持久化存储中获取 UI 显示所需数据。使用
NSPersistentContainer 来创建 Core Data Stack 时，container 的 viewContext
属性对应的便是主队列上下文。

- 私有队列上下文（NSManagedObjectContextConcurrencyType. privateQueueConcurrencyType）

顾名思义，私有队列上下文在创建时将创建它自己的队列，且只能在它自己创建的队列上使用。主要适用于执行时间较长，如果运行在主队列可能会影响 UI 响应的操作。

创建私有队列有两种方式：

    let backgroundContext = persistentContainer.newBackgroundContext() // 方式一

    persistentContainer.performBackgroundTask{ bgContext in  // 方式二
        ....
    }

如果该项操作的生命周期长、频次多，通常会采用方式一，创建一个专用于该事务的私有队列（比如 [ Persistent History Tracking
](/zh/posts/persistenthistorytracking/) ）。

如果该项操作执行频次少，可以使用方式二，临时创建一个私有队列，随用随弃（例如文件导入）。

通过不同队列的上下文进行数据操作是最常见的 Core Data 并发应用场景。

## 托管对象上下文和托管对象是队列绑定的

Core Data 是为多线程开发而设计的。然而，Core Data
框架下的对象并非都是线程安全的。其中，开发者接触最频繁、使用量最大的托管对象上下文（NSManagedObjectContext）和托管对象（NSManagedObject）恰好都不是线程安全的。

因此，在 Core Data 中进行并发编程时，请确保遵守以下规则：

- 托管对象上下文在初始化时被绑定到了与之相关的线程（队列）。
- 从托管对象上下文中检索的托管对象被绑定到了所属上下文所在的队列。

通俗的来说，就是上下文只能在自己被绑定的队列上执行才是安全的，托管对象亦然。

> 使用 Xcode 创建一个 Core Data 模版，在 ContextView. swift 中添加代码，开启 Core Data 并发调试标志。

下面的代码在执行时，将立即抛出错误：

    Button("context in wrong queue") {
        Task.detached { // 将其推到其它线程（非主线程）
            print(Thread.isMainThread) // false 当前不在主线程上
            let context = PersistenceController.shared.container.viewContext
            context.reset() //  在非主线程上调用主队列上下文的方法，绝大多数的操作都会报错
        }
    }

在非主线程上调用 viewContext 的方法时，程序会立即崩溃。

    Button("NSManagedObject in wrong context"){
        // 视图运行在主线程
        let backgroundContext = PersistenceController.shared.container.newBackgroundContext() // 创建了一个私有队列
        // 在主线程进行了本应在私有线程上进行的操作
        let item = Item(context: backgroundContext) // 在私有上下文中创建 item,item 被绑定在私有队列上
        item.timestamp = .now // 在主队列上赋值
    }

如果没有开启 Core Data 并发调试标识，上述代码在绝大多数的情况下都将正常运行，这正是此类错误难以发现的原因。

## 使用 perform 确保正确的队列

为了杜绝上面代码中的错误，我们必须将对托管对象上下文和托管对象的操作放入正确的队列中。

对于主队列上下文，由于它所在的队列是明确且固定的——主线程队列，因此，只要能够保证操作是在主队列中进行即可。例如：

    Button("context in wrong queue") {
            print(Thread.isMainThread) // true 视图队列为主队列
            let context = PersistenceController.shared.container.viewContext
            context.reset() // 在主线程上操作主线程上下文没有问题
    }

或者通过使用 `DispatchQueue.main.async` 、 `MainActor.run` 都可以确保操作是在主线程上进行。

但是，对于私有上下文，由于队列是私有的，只存在于 NSManagedObjectContext 实例的内部，因此只能通过 `perform` 或 `performAndwait` 方法来调用它。 `perform` 和 `performAndwait`
两者之间的区别为执行指定代码块的方式，异步或同步。

从 iOS 15（macOS Monterey）开始，Core Data 提供了上述方法的 async/await 版本。将两者合二为一，通过参数
schedule 来设置任务类型。immediate 即时计划任务，enqueued 排队计划任务。

    perform<T>(schedule: NSManagedObjectContext.ScheduledTaskType = .immediate, _ block: @escaping () throws -> T) async rethrows -> T

将上文导致崩溃的代码放入 perform 中执行即可排除错误。

    Button("context in wrong queue") {
        // 主队列
        Task.detached { // 推到其它队列（非主队列）
            print(Thread.isMainThread) // false
            let context = PersistenceController.shared.container.viewContext
            await context.perform { // 调整回 context 队列（本例中为主队列）
                context.reset()
            }
        }
    }

    Button("NSManagedObject in wrong context"){
        // 视图为主线程
        let backgroundContext = PersistenceController.shared.container.newBackgroundContext() // 创建了一个私有队列
        backgroundContext.perform {  // 在 backgroundContext 所在的私有队列中执行
            let item = Item(context: backgroundContext)
            item.timestamp = .now
        }
    }

> 除非开发者能够绝对保证代码运行于主队列中，且调用的是主队列上下文或属于该上下文的托管对象，否则最保险的方式是使用 perform 来杜绝出错。

## 通过 NSManagedObject 来查找上下文

在某些情况下，只能获得托管对象（NSManagedObject），通过从中获取托管对象上下文，保证在正确的队列中对其操作。

例如：

    // Item 为 NSManagedObject
    func delItem(item:Item) {
        guard let context = item.managedObjectContext else {return}
        context.perform {
            context.delete(item)
            try! context.save()
        }
    }

托管对象对应的上下文声明为 `unowned(unsafe)` ，请在确认上下文仍存在的情况下使用此种方式。

## 使用 NSManagedObjectID 进行传递

因为托管对象是同托管它的上下文绑定在同一个队列上，因此，无法在不同队列的上下文之间传递 NSManageObject。

对于需要在不同的队列中对同一个数据记录进行操作情况，解决方式是使用 NSManagedObjectID。

以上面删除 Item 的代码为例：假设该托管对象是在主队列中获取到的（在视图中通过@FetchRequest 或
NSFetchedResultsController），点击视图按钮，调用 delItem。为了减轻主线程的压力，在私有队列上进行数据删除操作。

调整后的代码：

    func delItem(id:NSManagedObjectID) {
        let bgContext = PersistenceController.shared.container.newBackgroundContext()
        bgContext.perform {
            let item = bgContext.object(with: id)
            bgContext.delete(item)
            try! bgContext.save()
        }
    }

或者仍采用 NSManagedObject 为参数

    func delItem(item:Item) {
        let id = item.objectID
        let bgContext = PersistenceController.shared.container.newBackgroundContext()
        bgContext.perform {
            let item = bgContext.object(with: id)
            bgContext.delete(item)
            try! bgContext.save()
        }
    }

> 细心的读者可能会疑惑，托管对象不是不能在其它队列上调用吗？从托管对象中获取 objectID 或 managedObjectContext
> 难道不会出问题？事实上，尽管托管对象上下文和托管对象绝大多数的属性、方法都是非线程安全的，但还是有个别属性是可以在其它线程上安全使用的。比如托管对象的
> objectID、managedObjectContext、hasChanges、isFault 等。托管对象上下文的
> persistentStoreCoordinator、automaticallyMergesChangesFromParent 等。

NSManagedObjectID 作为托管对象的紧凑通用标识符，被广泛使用于 Core Data
框架中。例如在批量操作、持久化历史跟踪、上下文通知等等方面都是以 NSManagedObjectID
作为数据标识的。但需要注意的是，它并不是绝对不变的。比如在托管对象创建后尚未持久化时，它将首先产生临时 ID，持久化后再转换回持久
ID；亦或者当数据库的版本或某些 meta 信息发生改变后也可能导致它发生变化（苹果没有公布它的生成规则）。

除非在程序运行时，否则不要将其作为托管对象的唯一标识（类似主键的存在），最好还是通过创建自己的 id 属性（例如 UUID）来实现。

如果确有将 ID 归档的需要，可以将 NSManagedObjectID 转换成 URI 表示。具体用例，请参阅 [ 在 Spotlight 中展示应用中的
Core Data 数据 ](/zh/posts/spotlight/)

> 前面例子中使用了 object (with: id) 来获取托管对象，其它通过 NSManagedObjectID 获取托管对象的上下文方法还有
> regiesterdObject、existingObject。它们的适用场合均有不同，详情见下表。

![image-20211104211037413](https://cdn.fatbobman.com/image-20211104211037413.png)

## 在不同的上下文之间合并更改

使用上面的 delItem
代码，在后台上下文中删除托管对象后，主线程上下文中的托管对象仍然存在。如果此时该数据显示在界面上的话，并不会发生变化。只有将一个上下文（本例为后台上下文）的更改合并到另一个上下文（主上下文）中，变化才会体现在界面中（@FetchRequest
或 NSFetchedResultsController）。

在 iOS 10 之前，合并上下文更改需要以下几个步骤：

- 添加一个观察者来监听 Core Data 发送的上下文已保存通知（Notification. Name. NSManagedObjectContextDidSave）
- 在观察者中，将通知的 userInfo 和要合并的上下文作为参数传递给 mergeChanges

  NotificationCenter.default.addObserver(forName:Notification.Name.NSManagedObjectContextDidSave, object: nil, queue: nil, using: merge)

  func merge(\_ notification:Notification) {
  let userInfo = notification.userInfo ?? [:]
  NSManagedObjectContext.mergeChanges(fromRemoteContextSave: userInfo, into: [container.viewContext])
  }

> 也可以使用 NSManagedObjectContext 实例的 mergeChanges 方法，逐个上下文合并。

在 iOS 10 版本，Core Data 为 NSManagedObjectContext 添加了
automaticallyMergesChangesFromParent 属性。

将上下文的 automaticallyMergesChangesFromParent 属性设置为 true，则该上下文会自动合并其它上下文的更改变化。在 [
Core Data with CloudKit（二） —— 同步本地数据库到 iCloud 私有数据库
](/zh/posts/coredatawithcloudkit-2/) 中可以看到如何通过
automaticallyMergesChangesFromParent 将网络数据的变化体现在用户界面中。

## 设置正确的合并策略

当使用了多个上下文或多个持久化存储协调器时，在保存处在不同环境的托管对象时就有可能发生冲突。

> 本节的合并策略中的合并，并非指上节中的上下文合并。是指将托管对象进行持久化时，为解决因托管对象乐观锁的版本不一致产生的保存冲突而进行的合并策略设置。

尽管并发不是保存冲突的必要条件，但在并发环境下非常容易发生保存冲突。

举个例子，方便大家对保存冲突有直观的了解：

- 主上下文中使用 fetch 从数据库中获取了托管对象 A（对应数据库中的数据 B）
- 使用 NSBatchUpdaterequest （不经过上下文）修改了数据库中的数据 B。
- 在主上下文中修改托管对象 A，尝试保存。
- 在保存时，A 的乐观锁版本号已经同数据库 B 新的版本号不一致了，发生了保存冲突。此时就需要根据设置的合并策略来解决如何取舍的问题。

使用 mergePolicy 设定合并冲突策略。如果不设置该属性，Core Data 会默认使用 NSErrorMergePolicy
作为冲突解决策略（所有冲突都不处理，直接报错），这会导致数据无法正确保存到本地数据库。

    viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy

Core Data 预设了四种合并冲突策略，分别为：

- NSMergeByPropertyStoreTrumpMergePolicy

逐属性比较，如果持久化数据和内存数据都改变且冲突，持久化数据胜出

- NSMergeByPropertyObjectTrumpMergePolicy

逐属性比较，如果持久化数据和内存数据都改变且冲突，内存数据胜出

- NSOverwriteMergePolicy

内存数据永远胜出

- NSRollbackMergePolicy

持久化数据永远胜出

如果预设的合并策略无法满足你的需要，也可以通过继承 NSMergePolicy 创建自定义的合并策略。

仍以上面的例子介绍策略：

- 数据 B 共有三个属性：name、age、sex
- 上下文中修改了 name 和 age
- NSBatchUpdaterequest 中修改了 age 和 sex
- 当前设置的合并策略为 NSMergeByPropertyObjectTrumpMergePolicy
- 最终的合并结果为 name 和 age 采用了上下文的修改，sex 保持了 NSBatchUpdaterequest 的修改。

## 总结

Core Data 有一套开发者应严守的规则，违背了它，Core Data 将让你体会深刻的教训。不过一旦掌握了这些规则，曾经的障碍将不再是问题。

# 打造可适配多平台的 SwiftUI 应用

本文是笔者参加 2023 年 4 月 20 日 “SwiftUI 技术沙龙（ 北京站 ）” 活动的分享内容。基于记忆整理而成。有关本次活动的情况，可以参阅
[ 我在北京参加 SwiftUI 技术沙龙 ](/zh/posts/attended-swiftui-salon-in-beijing/) 一文。

本次活动采用的是线下交流并辅以 live coding 的形式，因此内容的侧重点以及组织形式与以往的博客文章会有明显的不同。

## 开场白

大家好，我是肘子。今天我要和大家交流的主题是 —— 打造可适配多平台的 SwiftUI 应用。

## 电影猎手

我们先看一个例子，然后再进入今天的正题。

![image-20230424090248356](https://cdn.fatbobman.com/image-20230424090248356.png)

这是我为本次交流主题写的一个 Demo 应用 —— “ [ 电影猎手 ](https://github.com/fatbobman/MovieHunter)
”。100% 基于 SwiftUI 开发，目前支持三个平台： iPhone、iPad 和 macOS。

使用者可以通过它来浏览电影信息，包括正在上映以及即将上映的影片。并且可以根据口碑、评分、流行度、电影类型等维度查看想要了解的影片。

> ” [ 电影猎手 ](https://github.com/fatbobman/MovieHunter) ” 是一个专门为本次交流会准备的
> Demo，因此只完成了必须的部分。

相较于 iPhone 版本，iPad 版本除了为了利用更大的屏幕空间对布局做出了一定的调整外，还提供了多窗口运行的能力，使用者可以在每个窗口中独立进行操作。

![image-20230424090345471](https://cdn.fatbobman.com/image-20230424090345471.png)

mac 版本进行了更多符合 macOS 风格的适配，例如：使用了符合 mac
规范的设置视图、支持指针悬浮响应、菜单栏图标，并且支持创建新窗口并直接跳转到特定电影类别（基于数据驱动的 WindowGroup）。

![image-20230424090609933](https://cdn.fatbobman.com/image-20230424090609933.png)

受限于时间，本次交流中，我们不会对该应用的完整适配过程进行讨论，而是就两个我个人认为比较重要但又容易忽视的点进行交流。

## 兼容性

与不少跨平台框架所推崇的“Write once, run anywhere”不同，苹果对 SwiftUI 的定位是“Learn once, apply
anywhere”。

个人理解，SwiftUI 更像是一种编程哲学，掌握了它，便具备了很长一段时间内在苹果生态的不同平台上进行开发的能力。从另一个角度来看，用 SwiftUI
编写的代码，尽管大部分可以运行在不同的平台上，但有一部分则只能运行在特定平台上，而且往往这部分有平台限定的功能，最能体现平台所具有的特点和优势。

SwiftUI 通过设定了某些兼容性的限制，促使开发者在做多平台适配时，不得不考虑平台特点的不同，并根据这些不同来做有针对性的调整。

但是，如果开发者不能理解 SwiftUI 的这个“限制”，并提前做一些准备工作，可能会为之后的多平台开发工作带来一些隐患和增加不必要的工作量。

以“电影猎手”的 iPad 版本为例。在 iPad
中，使用者可以调整应用的窗口尺寸。为了让布局更贴合当前的窗口状态，我们通常会在视图中使用环境值来进行判断：

    @Environment(\.horizontalSizeClass) var sizeClass

根据 sizeClass 的当前状态，是 compact（紧凑）还是 regular（常规），来动态调整布局。

如果你的应用只打算适配 iPadOS，这样做是完全正确的。但是对于“电影猎手”这个应用来说，因为之后还需要适配 macOS 版本，使用这种方法便会出现问题。

因为 horizontalSizeClass 这个环境值无法在 macOS 中使用，UserInterfaceSizeClass 是
iOS（iPadOS）独有的概念。我们在视图代码中依赖这个环境值越多，将来需要做的调整也就越多。

![image-20230416170832640](https://cdn.fatbobman.com/image-20230416170832640.png)

为了避免在适配其他平台时重复调整代码，我们可以采用类似于 horizontalSizeClass
的方式（通过环境变量），创建一个可用于所有需要适配平台的自定义环境变量来解决这个问题。

首先创建一个 DeviceStatus 枚举类型：

    public enum DeviceStatus: String {
      case macOS
      case compact
      case regular
    }

在这个枚举类型中，除了 iOS 中出现的两种窗口状态外，我们还添加了 macOS 枚举项。

然后，创建类型为 DeviceStatus 的环境值：

    struct DeviceStatusKey: EnvironmentKey {
      #if os(macOS)
        static var defaultValue: DeviceStatus = .macOS
      #else
        static var defaultValue: DeviceStatus = .compact
      #endif
    }

    public extension EnvironmentValues {
      var deviceStatus: DeviceStatus {
        get { self[DeviceStatusKey.self] }
        set { self[DeviceStatusKey.self] = newValue }
      }
    }

通过条件编译语句 `#if os(macOS)` ，在 macOS 中，环境值被设置为对应的选项。我们还需要创建一个 View Modifier（
视图修饰器 ），以便能够在 iOS 中及时了解当前的窗口状态：

    #if os(iOS)
      struct GetSizeClassModifier: ViewModifier {
        @Environment(\.horizontalSizeClass) private var sizeClass
        @State var currentSizeClass: DeviceStatus = .compact
        func body(content: Content) -> some View {
          content
            .task(id: sizeClass) {
              if let sizeClass {
                switch sizeClass {
                case .compact:
                  currentSizeClass = .compact
                case .regular:
                  currentSizeClass = .regular
                default:
                  currentSizeClass = .compact
                }
              }
            }
            .environment(\.deviceStatus, currentSizeClass)
        }
      }
    #endif

当视图的 horizontalSizeClass 发生变化时，及时的更新我们自定义的 deviceStatus。最后再通过一个 View
Extension，将不同平台的代码组合在一起：

    public extension View {
      @ViewBuilder
      func setDeviceStatus() -> some View {
        self
        #if os(macOS)
        .environment(\.deviceStatus, .macOS)
        #else
        .modifier(GetSizeClassModifier())
        #endif
      }
    }

将 setDeviceStatus 应用在根视图上：

    ContentView:View {
        var body:some View {
          RootView()
              .setDeviceStatus()
        }
    }

至此，我们便拥有了在 iPhone、iPad 以及 macOS 中了解当前窗口状态的能力。

    @Environment(\.deviceStatus) private var deviceStatus

如果将来，我们需要适配更多的平台，只需要调整自定义环境值的设定便可以了。尽管仍需要调整视图代码，但相较于 horizontalSizeClass
来说，修改量将减少许多。

> setDeviceStatus 并非只能用于根视图，但至少应该使用在当前应用的最宽视图处。这是因为 horizontalSizeClass
> 只表示当前视图的横向尺寸类别，也就是说，如果在一个横向尺寸被限定的视图中（ 例如 NavigationSplitView 的 Sidebar 视图
> ）获取 horizontalSizeClass ，无论应用的窗口尺寸如何，当前视图的 sizeClass 只能为 compact。我们创建
> deviceStatus 的目的是用来观察当前应用的窗口状态，故此必须应用于最宽处。

在 SwiftUI 中，除了环境值外，另一个具备较多平台“限制”的部分就是视图的 Modifier。

例如，在准备开始适配“电影猎手”的 macOS 版本时（已完成 iPad 版本的适配），当添加好 macOS 的 destination
并进行编译后，你会发现 Xcode 出现了不少类似下面这种错误：

![image-20230416172647039](https://cdn.fatbobman.com/image-20230416172647039.png)

这是因为某些 View Modifier 并不支持 macOS。对于上面的这个错误提示，我们可以简单地使用条件编译语句将其屏蔽掉。

    #if !os(macOS)
        .navigationBarTitleDisplayMode(.inline)
    #endif

不过，如果类似的问题很多，我们不妨采用一个一劳永逸的方案。

在“电影猎手”中，navigationBarTitleDisplayMode 是一个经常被使用到的 Modifier ，我们可以创建一个 View
Extension 来处理不同平台下的兼容性问题：

    enum MyTitleDisplayMode {
        case automatic
        case inline
        case large
        #if !os(macOS)
            var titleDisplayMode: NavigationBarItem.TitleDisplayMode {
                switch self {
                case .automatic:
                    return .automatic
                case .inline:
                    return .inline
                case .large:
                    return .large
                }
            }
        #endif
    }

    extension View {
        @ViewBuilder
        func safeNavigationBarTitleDisplayMode(_ displayMode: MyTitleDisplayMode) -> some View {
            #if os(iOS)
                navigationBarTitleDisplayMode(displayMode.titleDisplayMode)
            #else
                self
            #endif
        }
    }

在视图中直接使用：

    .safeNavigationBarTitleDisplayMode(.inline)

如果你打算将应用引入更多的平台，提前准备一些解决兼容性的代码将会极大地改善之后的开发效率。这种做法不仅可以解决跨平台兼容性问题，还有其他好处：

- 可以改善视图中代码的整洁度（减少条件编译语句的使用）
- 可以改善 SwiftUI 在不同版本之间的兼容性

当然，要创建并使用这类代码，前提是开发者必须已经对 SwiftUI 在不同平台中的“限制”（ 每个平台的特点、优势、处理方式
）有了比较清晰的认识。盲目地使用这些解决兼容性的代码可能会破坏 SwiftUI 创建者的苦心，让开发者无法准确地体现不同平台的特色。

## 数据源

聊完兼容性后，我们再聊另一个在构建多平台应用初期容易忽略的问题：数据源（数据依赖）。

当我们将“电影猎手”从 iPhone 移植到 iPad 或 Mac
上时，除了屏幕可用空间更大之外，另一个显着的变化是使用者可以同时打开多个窗口，并可以在不同的窗口中对“电影猎手”进行独立的操作。

然而，如果我们直接将尚未进行多屏适配的 iPhone 版本的“电影猎手”运行于 iPad
上，会发现尽管可以同时开启多个“电影猎手”窗口，但所有的操作都是同步的，也就是在一个窗口中进行的操作同时会体现在另一个窗口中。这样就失去了多窗口存在的意义。

![RocketSim_Recording_iPad_Pro_11'_2023-04-24_09.26.09.2023-04-24
09_27_40](https://cdn.fatbobman.com/RocketSim_Recording_iPad_Pro_11'_2023-04-24_09.26.09.2023-04-24%2009_27_40.gif)

为什么会出现这种情况呢？

我们都知道 SwiftUI 是一个声明式框架。这不仅意味着开发者可以通过声明的方式来构造视图，而且场景（对应着独立的窗口）甚至整个 App
都是基于声明式代码来创建的。

    @main
    struct MovieHunterApp: App {
        @StateObject private var store = Store()
        var body: some Scene {
            WindowGroup {
                ContentView()
                   .environmentObject(store)
            }
        }
    }

在 Xcode 创建的 SwiftUI 项目模板中，WindowGroup 对应着一个场景声明。由于 iPhone
只支持单窗口模式，通常我们不会太注意它的存在，但在 iPadOS 以及 macOS 这些支持多窗口的系统中，则代表着，每次创建一个新窗口（在 macOS
中，通过菜单中的新建来创建新窗口），都将严格地按照 WindowGroup 的声明来进行。

在“电影猎手”中，我们在 App 的位置创建了 Store（保存应用状态以及主要处理逻辑的单元）的实例，并通过 `.environmentObject(store)` 注入到根视图中。这种通过 `environmentObject` 或 `environment` 来注入的信息，只能在为当前场景创建的视图树中被使用。

![image-20230424092927467](https://cdn.fatbobman.com/image-20230424092927467.png)

尽管系统在创建新场景（新窗口）时会为其创建一棵新的视图树，但由于为新场景的根视图注入的仍然是同一个 Store
实例，因此尽管场景不同，但在不同的窗口中获取的应用状态完全一致。

![image-20230424093006309](https://cdn.fatbobman.com/image-20230424093006309.png)

由于“电影猎手”采用了编程式导航，视图堆栈以及 TabView 的状态都保存在 Store 中，因此会出现操作同步的情况。

因此，如果我们打算将应用引入到一个支持多窗口平台的时候，最好能提前考虑到这种情况，想好如何组织应用的状态。

对于“电影猎手”当前的状态配置来说，我们可以通过将创建 Store 实例的位置移动到场景内来解决上述问题（将 MovieHunterApp 中与 Store
有关的代码移动到 ContentView 中）。

![image-20230424093127892](https://cdn.fatbobman.com/image-20230424093127892.png)

![image-20230424101327899](https://cdn.fatbobman.com/image-20230424101327899.png)

不过，这种在每个场景中创建独立的 Store 实例的方式并非适用于所有情况。在很多情况下，开发者只想在应用中保持一个 Store
实例。我将通过另一个简单的应用来展示这种场景。

> 我想很多读者此时都不会太赞同在每个场景中创建一个独立的 Store 实例这种做法。至于这种做法是否正确、是否符合当前流行的 Single source
> of truth 的理念，我们在之后还会继续探讨。

这是一个极为简单的 Demo —— [ SingleStoreDemo
](https://github.com/fatbobman/SingleStoreDemo) 。它只有一个 Store
实例并支持多窗口，使用者在每个窗口中都可以独立地切换 TabView，并且 TabView 的状态由唯一的 Store 实例持有。通过点击任意窗口中任意
Tab 中的 “Hit Me” 按钮来增加点击次数。点击次数显示在窗口的上方。

![RocketSim_Screenshot_iPad_Pro_11'_2023-04-24_10.15.30](https://cdn.fatbobman.com/RocketSim_Screenshot_iPad_Pro_11'_2023-04-24_10.15.30.jpeg)

我们在设计这个 App 的状态时，就要考虑到哪些是应用全局的状态，哪些是仅限于当前场景（窗口）的状态。

    struct AppReducer: ReducerProtocol {
        struct State: Equatable {
            var sceneStates: IdentifiedArrayOf<SceneReducer.State> = .init()
            var hitCount = 0
        }
    }

    struct SceneReducer: ReducerProtocol {
        struct State: Equatable, Identifiable {
            let id: UUID
            var tabSelection: Tab = .tab1
        }
    }

在应用的总 State 中，除了服务于全局的 `hitCount` 外，我们还为可能的多场景需求将场景的 State 独立出来。并通过 [
IdentifiedArray ](https://github.com/pointfreeco/swift-identified-collections)
来管理不同场景的 State。

当一个场景被创建后，通过 onAppear 里的代码，在 App State 中创建属于它自己的 State 数据，并在场景被删除时，通过
onDisappear 里的代码，将当前场景的 State 清除掉。

    .onAppear {
        viewStore.send(.createNewScene(sceneID)) // create new scene state
    }
    .onDisappear {
        viewStore.send(.deleteScene(sceneID)) // delete current scene state
    }

如此一来，便实现了通过一个 Store 实例，支持多窗口独立操作的需求。

> 详情，请自行查看 [ 代码 ](https://github.com/fatbobman/SingleStoreDemo)

在这里需要特别注意的是，不知道出于什么原因（或许与随机数的种子有关），通过同一个场景声明创建的根视图，如果使用@State 创建的 UUID
或随机数，即使在不同的窗口中，即使窗口创建的时间不同，UUID 或随机数的值是完全一样的。如此一来，便无法为不同的场景创建不同的状态集（当前的场景状态使用
UUID 作为标识符）。为了避免这种情况，需要在 onAppear 中重新生成新的 UUID 或随机数。

    .onAppear {
        sceneID = UUID()
        ...
    }

> 这个问题，同样出现在“电影猎手”中创建 [ overlayContainer
> ](https://github.com/fatbobman/SwiftUIOverlayContainer) 的场景中（ 用于显示全屏电影剧照
> ），也是采用上述的方法才得以解决。

虽然 SingleStoreDemo 使用 TCA 作为数据流框架，但这并不代表 TCA 在实现类似需求时有特别的优势。在 SwiftUI
中，只要理解了状态、声明和响应之间的关系，开发者就可以用任何想用的形式来组织数据。无论是将状态进行统一管理，还是分散在不同的视图中，都有各自的优势和意义。此外，SwiftUI
本身还为开发者提供了不少专门用于处理多场景模式下的属性包装器类型，例如：@AppStorage、@SceneStorage、@FocusedSceneValue、@FocusedSceneObject
等。

回过头来，我们再看一下“电影猎手”的多个 Store 实例的实现方式。难道“电影猎手”没有应用层面（全局）的状态需求吗？

当然不是。在“电影猎手”中，应用层面的大多数状态是由 @AppStorage 来管理的，而另外一些全局状态，则是通过 Core Data
来进行维护。也就是说，尽管“电影猎手”采用了为每个场景创建一个独立的 Store 实例的外在形式，但在底层逻辑上，与 SingleStore 的 TCA
实现本质上没有什么不同。

我认为，开发者应根据需要采用适宜的手段，而不必拘泥于某种特定的数据流理论或框架。

最后，我们来谈谈在将“电影猎手”适配到 macOS 时，碰到的另外一个与数据源有关的问题。

为了让“电影猎手”更符合 macOS 应用的规范，我们将视图移动到菜单项中，并在 mac 代码中取消了 TabView。

    @main
    struct MovieHunterApp: App {
        let stack = CoreDataStack.share
        @StateObject private var store = Store()
        var body: some Scene {
            WindowGroup {
             ...
            }

            #if os(macOS)
                Settings {
                    SettingContainer() // 声明设置视图
                }
            #endif
        }
    }

    // ContentView
    VStack {
        #if !os(macOS)
            TabViewContainer()
        #else
            StackContainer()
        #endif
    }

当做完这些改动后，您会发现，我们只能在设置中更改电影信息窗口的颜色模式和语言，而设置视图并不会像 iPhone 和 iPad 那样一并随之变化。

![iShot_2023-04-24_10.33.03.2023-04-24
10_34_15](https://cdn.fatbobman.com/iShot_2023-04-24_10.33.03.2023-04-24%2010_34_15.gif)

这是因为，在 macOS 中，使用 Settings 来声明 Settings 窗口同样是创建了一个新的场景，会创建一棵独立的视图树。在 iOS
中，我们通过在根视图（ ContentView ）中修改环境值的方式来更改颜色和语言，并不会对 macOS 的 Settings 场景产生影响。因此，在
macOS 中，我们需要单独为 Settings 视图来调整颜色和语言的环境值。

    struct SettingContainer: View {
        @StateObject var configuration = AppConfiguration.share
        @State private var visibility: NavigationSplitViewVisibility = .doubleColumn
        var body: some View {
            NavigationSplitView(columnVisibility: $visibility) {
              ...
            } detail: {
               ...
            }
            #if os(macOS)
            .preferredColorScheme(configuration.colorScheme.colorScheme)
            .environment(\.locale, configuration.appLanguage.locale)
            #endif
        }
    }

> 恰恰是由于采用了 @AppStorage 来管理全域状态，才能在不引入 Store 实例的情况下，轻松地完成设置窗口的适配工作。

## 总结

相较于为不同的平台调整视图布局，今天说到的问题并没那么起眼，容易忽视。

然而，只要了解这些要点的存在，并提前进行规划和准备，适配的过程就会更加顺利。开发者也就能够把更多精力投入到为用户打造不同平台的独特使用体验上。

以上就是今天交流的全部内容，谢谢大家的聆听，希望能对你有所帮助。

# HowTo —— SwiftU2.0 LazyVStack LazyHStack

SwiftUI 2.0 提供了 LazyVStack 和 LazyHStack，其作用是只有当 View 在可见区域内才进行渲染，这样可以大大大提高 app
执行效率。由于 VStack 或 HStack 导致的效率问题，在 [ SwiftUI List (3) —— List、Form、VStack
](https://zhuanlan.zhihu.com/p/111151515) 文章中有简单的比较。

## 基本用法

    struct LazyStack: View {
        var body: some View {
            ScrollView{
                LazyVStack{ //换成 VStack 作比较新数据创建的时机
                    ForEach(0...1000,id:\.self){ id in
                        Text(LazyItem(id:id).title)
                    }
                }
            }
        }
    }

    struct LazyItem{
        let id:Int
        let title:String
        init(id:Int){
            self.id = id
            self.title = "id:\(id)"
            print("init new object:\(id)")
        }
    }

## 使用 Lazy 特性创建不间断的列表显示

    import SwiftUI

    struct LazyStack: View {
        @State var list = (0...40).map{_ in Item(number:Int.random(in: 1000...5000))}
        @State var loading = false
        var body: some View {
            VStack{
            Text("count:\(list.count)")
            //数据数量，在 LazyVStack 下数据在每次刷新后才会增加，在 VStack 下，数据会一直增加。
            ScrollView{
                LazyVStack{ //换成 VStack 作比较
                    ForEach(list,id:\.id){ item in
                        Text("id:\(item.number)")
                            .onAppear {
                                moreItem(id: item.id)
                            }
                    }
                }
                if loading {
                    ProgressView()
                }
            }
        }

        func moreItem(id:UUID){
           //如果是最后一个数据则获取新数据
            if id == list.last!.id && loading != true {
                loading = true
                //增加延时，模拟异步数据获取效果
                DispatchQueue.main.asyncAfter(deadline: .now() + 1){
                    //数据模拟，也可获取网络数据
                    list.append(contentsOf: (0...30)
                                .map{_ in Item(number:Int.random(in: 1000...5000))})
                    loading = false
                }
            }

        }
    }

     struct Item:Identifiable{
        let id = UUID()
        let number:Int
    }

LazyHStack 的用法同 LazyVStack 一样

# SwiftUI 视图的生命周期研究

在 UIKit（AppKit）的世界中，通过框架提供的大量钩子（例如 viewDidLoad、viewWillLayoutSubviews
等），开发者可以将自己的意志注入视图控制器生命周期的各个节点之中，宛如神明。在 SwiftUI
中，系统收回了上述的权利，开发者基本丧失了对视图生命周期的掌控。不少 SwiftUI
开发者都碰到过视图生命周期的行为超出预期的状况（例如视图多次构造、onAppear 无从控制等）。

本文将作者对 SwiftUI 视图、SwiftUI 视图生命周期的理解和研究做以介绍，供大家一起探讨。

在进行更详尽说明之前，请大家先明确两个观点：

- SwiftUI 没有同 UIkit（AppKit）对应的视图与视图生命周期
- 应避免对 SwiftUI 视图的创建、body 的调用、布局与渲染等的时机和频率进行假设

## SwiftUI 的视图

在 SwiftUI 中，视图定义了一块用户界面，并以视图树的形式组织在一起，SwiftUI 通过解析视图树来创建合适的渲染。

在 SwiftUI 内部它会至少创建两种类型的树——类型树、视图值树

### 类型树

开发者通过创建符合 View 协议的结构体定义想要呈现的用户界面，结构体的 body 属性是一个带有众多泛型参数的庞大类型，SwiftUI
会将这些类型组织成一棵类型树。它包含了 app 生命周期中可能会出现在屏幕上的所有符合 View 协议的类型（即使可能永远不会被渲染）。

例如：

    struct ContentView:View{
        var body: some View{
            Group {
                if true {
                    Text("hello world")
                }
                else {
                    Text("Won't be rendered")
                }
            }
        }
    }

上面的代码将构建成如下的类型树：

    Group<_ConditionalContent<Text, Text>>

即使 `Text("Won't be rendered")` 永远都不会被显示，它仍然被包含在类型树中。

类型树在编译后就已经固定，在 app 的生命周期内都不会发生变化。

### 视图值树

在 SwiftUI 中， [ 视图是状态的函数
](https://developer.apple.com/videos/play/wwdc2019/226/) 。

开发者通过符合 View 协议的结构体来声明界面，SwiftUI 通过调用结构体实例的 body 获取对应的视图值。body
则根据用户的界面描述和对应的依赖（Source of truth）计算结果。

在 app 运行后进行第一次渲染时，SwiftUI 将依据类型树按图索骥，创建类型实例，实例的 body
根据初始状态计算视图值，并组织成视图值树。需要创建哪些实例，则是根据当时的状态决定的，每次的状态变化都可能会导致最终生成的视图值树不同（可能仅是某个节点的视图值发生变化，也可能是视图值树的结构都发生了巨大的变化）。

当 State 发生变化后，SwiftUI 会生成一棵新的视图值树（Source of truth
没有发生变化的节点，不会重新计算，直接使用旧值），并同老的视图值树进行比对，SwiftUI
将对其中有变化的部分重新布局渲染，并用新生成的视图值树取代老的视图值树。

视图值树通常只保存当前布局、渲染所需的内容（个别情况下，会缓存少数不参与布局、渲染的视图值），在 app 的生命周期中，随着 State
的变化而不断地变化。

### 什么是视图

开发者更习惯将符合 View 协议的结构体或结构体实例视作视图，而在 SwiftUI 的角度，视图值树上的节点内容，才是它所认为的视图。

## SwiftUI 视图的生命周期

大多介绍 SwiftUI 视图生命周期的文章，通常会将视图的生命周期描述成如下的链条：

初始化视图实例——注册数据依赖——调用 body 计算结果——onAppear——销毁实例——onDisapper

有了上面的关于视图的定义，我们再看这种关于生命周期的描述便会发现其中的问题——将两种视图类型视为一体，将不同类型的视图的生命周期强行混编到一条逻辑线上。

在 WWDC 2020 的 [Data Essentials in SwiftUI](Data Essentials in SwiftUI)
专题中，苹果特别指出： **视图的生命的周期与定义它的结构的生命周期是分开的** 。

因此，我们需要将开发者眼中的视图和 SwiftUI 眼中的视图分别对待，各自独立的分析其生命周期。

### 符合 View 协议的结构体实例的生命周期

#### 初始化

通过在结构体的构造函数中添加打印命令，我们很容易就可以获知 SwiftUI
创建了某个结构体的实例。如果你仔细分析构造函数的打印结果，你会发现创建结构体实例的时机和频率远超你的预期。

**想要获取 body 值一定要首先创建实例，但创建实例并非一定有获取 body 值的必要！**

- 在 SwiftUI 生成视图值树时，当发现没有对应的实例时，SwiftUI 会创建一个实例从而获取它的 body 结果。
- 在生成新的视图值树时，即使已经有可以对应的实例（该实例并未销毁），SwiftUI 仍可能会创建一个新的实例。但 SwiftUI 并非一定会从新的实例中获取 body 结果，如果之前的实例注册过数据依赖，视图值树仍可能会从原来的实例的 body 中获取结果。
- 在 NavigationView 中，如果在 NavigationLink 中使用了静态的目标视图，SwiftUI 将会为所有的目标视图创建实例，无论是否访问。
- 在 TabView 中，SwiftUI 在一开始就为所有 tab 对应的视图创建了实例。

类似上面的情况还有不少。这也就很好的解释了，很多开发者都会碰到某些视图莫名多次初始化的情况。这种情况可能是 SwiftUI
将第一个实例销毁后创建了一个新的实例，也可能是没有销毁第一个实例而直接创建了一个新的实例。

总之，SwiftUI 将根据它自身的需要，可能在任意的时间、创建任意数量的实例。开发者为了适应 SwiftUI
的这种特性，唯一可以做的就是让结构体的构造函数尽可能的简单。除了必要的参数设置外，不要做任何多余的操作。这样即使 SwiftUI
创建了多余的实例，也不会加大系统的负担。

#### 注册数据依赖

在 SwiftUI 中，状态（或者说是数据）是驱动 UI
的动力。为了让视图能够反映状态的变化，视图需要注册和其对应的依赖项。尽管在结构体的构造函数中，我们可以使用特定的属性包装器（例如@State、@StateObject
等）声明依赖项，但我并不认为注册数据依赖的工作是在初始化阶段进行的。主要的理由有三条：

- 注册依赖的负担并不小。比如，@ObservableObject 在每次创建依赖的时候都需要重新进行堆分配，消耗很大，并可能有会有丢失数据的风险。如果在构造方法中进行注册依赖的工作，将不符合创建轻量化构造方法的准则。
- 除了使用属性包装器外，SwiftUI 还为视图还提供了 onReceive、onChange、onOpenURL、onContinueUserActivity 等方式进行依赖注册。以上四种方式必须对 body 中的内容进行解析后才能完成。
- 下文中会提到，在视图值树的视图生命周期内，无论创建多少个实例都只会保留一份依赖项副本。当使用新实例时，SwiftUI 仍会将新的实例同原有的依赖项关联起来。

鉴于以上原因，注册视图依赖项的时机应该在初始化后，获得 body 结果之前。

#### 调用 body 计算结果

通过在 body 中添加类似如下的代码，我们可以在 SwiftUI 调用实例的 body 时获得通知：

    let _ = print("update some view")

计算 body 值是在主线程上进行的，并且 SwiftUI 必须在一个渲染周期内完成所有的计算、比较、布局等工作。为了避免造成 UI 卡顿，body
应设计成纯函数，只在其中创建简单的视图描述，将复杂的逻辑运算和副作用交给其他的线程来进行（比如在 Store 中将逻辑调度到其他线程或在视图中使用 task
将任务派遣到其他线程）。

#### 销毁

结构体并不提供析构方法，我们可以通过类似下面的代码观察结构体实例大致的销毁时机：

    class LifeMonitor {
        let name: String
        init(name: String) {
            self.name = name
            print("\(name) init")
        }

        deinit {
            print("\(name) deinit")
        }
    }

    struct TestView:View {
        let lifeMonitor:LifeMonitor
        init(){
            self.lifeMonitor = LifeMonitor(name:"testView")
        }
    }

通过观察，我们可以发现 SwiftUI 在处理结构体实例的销毁上也并没统一的规律。

比如类似如下的代码：

    ZStack {
        ShowMessage(text: "1")
            .opacity(selection == 1 ? 1 : 0)
        ShowMessage(text: "2")
            .opacity(selection == 2 ? 1 : 0)
    }

    struct ShowMessage:View{
        let text:String
        let lifeMonitor:LifeMonitor
        init(text:String){
            self.text = text
            self.lifeMonitor = LifeMonitor(name: text)
        }

        var body: some View{
            Text(text)
        }
    }

每次当 selection 在 1 和 2 之间切换时，SwiftUI 都会重新创建两个新的实例，并且将旧的实例销毁。

而如下的代码：

    TabView(selection: $selection) {
        ShowMessage(text: "1")
            .tag(1)
        ShowMessage(text: "2")
            .tag(2)
    }

SwiftUI 将只在最初创建两个 ShowMessage 的实例，无论如何切换 selection，TabView 将全程只使用这两个实例。

SwiftUI 可能随时销毁实例，并创建新的实例，也可能将实例保留较长的时间。总之，应避免对实例的创建、销毁的时机和频率进行假设。

### 视图值树中的视图的生命周期

#### 存活时间

同符合 View 协议的结构体实例的存活时间完全不确定相比，视图值树中的视图的生命周期则是容易判断的多。

每个视图值都有对应的标识符，视图值和标识符结合在一起代表屏幕上的某一块视图。在 Source of trueh
发生变化后，视图值也会随之发生变化，但由于标识符不变，则该视图将仍然存在。

通常情况下，SwiftUI 在需要渲染屏幕某个区域或需要该区域的数据配合布局时，会在视图值树上创建对应的视图。当不再需要其参与布局或渲染时视图将被销毁。

极个别情况下，尽管某些视图暂时不需要参与布局与渲染，但 SwiftUI 出于效率的考量，仍然会将其保留在视图值树上。比如在 List 和
LazyVStack 中，Cell 视图在创建之后即使滚动出屏幕不参与布局与渲染，但 SwiftUI 仍会保留这些视图的数据，直到 List 或
LazyVStack 被销毁。

@State 和@StateObject，它们的生命周期同视图的生命周期是一致的， **这里所说的视图，便是视图值树中的视图**
。如果感兴趣，可以使用@StateObject 来精确判断视图的生命周期。

#### onAppear 和 onDisappear

准确地说，视图值树中的视图，作为一个值在其生命周期中除了生死外，并没有其他的节点。但 onAppear 和 onDisappear
在行为表现上又确实与其有所关联。

需要注意的是，onAppear 和 onDisappear 中闭包的作用范围并非为包裹其的视图，而是其所附属视图，这点尤为重要！

SwiftUI 官方文档对 onAppear 和 onDisappear
的描述是：在此视图出现时执行的操作，在此视图消失时要执行的操作。这种描述与这两个修饰器在大多数场景下的行为很接近。因此，大家通常都会将其视作 UIKit
下的 viewDidAppear 和 viewDidDisappear 的 SwiftUI
版本，认为它们在生命周期中，只会出现一次。但，如果全方位分析它们的触发时机，便会发现它们的行为与描述并不完全相符。比如，在下面的几个场景中，onAppear
和 onDisappear 都将违背大多数认知：

- 在 ZStack 中，即使视图不显示，也同样会触发 onAppear，即使消失（不显示），也不会触发 onDisappear。视图保持存续状态

  ZStack {
  Text("1")
  .opacity(selection == 1 ? 1 : 0)
  .onAppear { print("1 appear") }
  .onDisappear { print("1 disappear") }
  Text("2")
  .opacity(selection == 2 ? 1 : 0)
  .onAppear { print("2 appear") }
  .onDisappear { print("2 disappear") }
  }

  // Output
  2 appear
  1 appear

- 在 List 或 LazyVStack 中，Cell 视图进入屏幕后触发 onAppear，滚动出屏幕后会触发 onDisappear，在 Cell 视图的存续期内可以多次触发 onAppear 和 onDisappear

  ScrollView {
  LazyVStack {
  ForEach(0..<100) { i in
  Text("\(i)")
  .onAppear { print("\(i) onAppear") }
  .onDisappear { print("\(i) onDisappear") }
  }
  }
  }

- 在 ScrollView + VStack 中，即使 Cell 视图没有显示在屏幕中，仍会触发 onAppear

  ScrollView {
  VStack {
  ForEach(0..<100) { i in
  Text("\(i)")
  .onAppear { print("\(i) onAppear") }
  .onDisappear { print("\(i) onDisappear") }
  }
  }
  }

类似的例子还有很多，比如 TabView、或者将 frame 设置为 zero 等等。

由此可以看出在视图的存续期内，可以多次触发 onAppear 和 onDisappear。onAppear 和 onDisappear 的触发条件并非以是否
appear 或被看见为依据。

因此，我认为应该以 **视图是否参与或影响了其父视图的布局作为 onAppear 和 onDisappear 的触发条件**
。如果用此条件来解释上面的情况便完全可以说的通了。

- ZStack 中，即使层被隐藏，但被隐藏层也必然会影响父视图 ZStack 的布局规划。同理，将显示层切换为隐藏层后，该层仍参与布局，因此，ZStack 的所有层都会在最开始就触发 onAppear，但不会触发 onDisappear。

- 在 List 和 LazyVStack 中，SwiftUI 出于效率的考虑，即使 Cell 视图移出显示范围，它的视图仍将保留在视图值树上（视图仍将存续）。因此，当 Cell 视图出现在显示范围内（影响容器布局）会触发 onAppear，移出显示范围（不影响容器布局）会触发 onDisappar。在其存续期内可以反复触发。

另外，由于 List 和 LazyVStack 的布局逻辑不同（List 的容器高度是固定的，LazyVStack
的容器高度是不固定的，向下预估的），两者触发 onDisappear 的时机点也不同。List 是上下两侧都会触发，LazyVStack 只有下方会触发。

- ScrollView + VStack 中，即使 Cell 视图没有出现在可见区域，但它在最开始就会参与容器的布局，因此会在创建初始便触发 onAppear，但无论如何滚动，所有的 Cell 视图始终会参与布局，因此并不会触发 onDisappear。

父视图恰恰是以该视图是否影响自身的布局为依据，来调用 onAppear 和 onDisappear
内的闭包，这也是为什么这两个修饰器的作用范围是父视图而不是视图本身。

#### task

task 有两种表现形式，一种与 onAppear 类似，另一种与 onAppear + onChange 类似（请参阅 [ 了解 SwiftUI 的
onChange ](/zh/posts/onchange/) ）。

同 onAppear 类似的版本，可以将其视为 onAppear 的异步版本。如果任务的执行时间较短，下面的代码也可以实现一样的效果：

    .onAppear {
        Task{
            ....
        }
    }

很多资料认为 task 与视图的生命周期相同，这是不准确的。更确切的表述应该是，当视图销毁时，将向 task
修饰器中的闭包发送任务取消的信号。至于是否取消，仍由 task 中的闭包自己决定。

    struct ContentView: View {
        @State var show = true
        var body: some View {
            VStack {
                if show {
                    Text("Hello, world!")
                        .padding()
                        .task{
                            var i = 0
                            while !Task.isCancelled {  // 尝试将本行代码改成 while true {
                                try? await Task.sleep(nanoseconds: 1_000_000_000)
                                print("task:",i)
                                i += 1
                            }
                        }
                        .onAppear{
                            Task{
                                var i = 0
                                while !Task.isCancelled {
                                    try? await Task.sleep(nanoseconds: 1_000_000_000)
                                    print("appear:",i)
                                    i += 1
                                }
                            }
                        }

                }
                Button("show"){
                    show.toggle()
                }
            }
        }
    }

## 两种生命周期之间的关联

本节，我们将在上述两种生命周期之间寻找联系，进行汇总。

为了方便叙述，下文中将【符合 View 协议的结构体实例】简称为【实例】，将【视图值树中的视图】简称为【视图】。

- 必须先创建实例，才能生成视图
- 创建的实例并非一定会用于生成视图
- 在视图的生命周期中，可能创建多个实例
- 在视图的生命周期中，实例可能随时被销毁
- 在视图的生命周期中，至少始终保有一个实例
- 第一个生成视图值的实例，将完成依赖项的建立工作
- 在视图的生命周期中，只有一个依赖项副本
- 在视图的生命周期中，无论创建多少个实例，同一时间只有一个实例可以连接到依赖项
- 依赖项为视图的 Source of truth

## 了解 SwiftUI 视图的生命周期的意义

SwiftUI 试图淡化视图生命周期的概念，在大多数场景下确实实现了它的设计目标。开发者即使不了解文本上述的内容，也可以让 SwiftUI
的代码在日常中发挥出不错的效率。但如果能够对视图的生命周期有更深入的了解，将可以帮助开发者在一些特定的场合提高代码的执行效率。下文将举几个例子。

### 轻量化的构造器

目前，很多 SwiftUI 的开发者都已经注意到了结构体实例会被多次创建的问题。尤其在 WWDC 2020
的专题中已经明确告知应创建尽可能轻量化的结构体构造器后，开发者已经将很多原本在构造器中进行的数据准备工作转移到了 onAppear 中进行。

这在相当程度上改善了因多次创建实例而引发的效率问题。

### 让复杂的任务仅执行一次

但是，onAppear 或 task 也并非只会执行一次，如何保证让某些负担较重的任务只在页面中执行一次呢？利用@State
的生命周期同视图的生命周期一致的特性，便可以很好的解决这个问题。

    struct TabViewDemo1: View {
        @State var selection = 1
        var body: some View {
            TabView(selection: $selection) {
                TabSub(idx: 1)
                    .tabItem { Text("1") }
                TabSub(idx: 2)
                    .tabItem { Text("2") }
            }
        }
    }

    struct TabSub: View {
        @State var loaded = false
        let idx: Int
        var body: some View {
            Text("View \(idx)")
                .onAppear {
                    print("tab \(idx) appear")
                    if !loaded {
                        print("load data \(idx)")
                        loaded = true
                    }
                }
                .onDisappear{
                    print("tab \(idx) disappear")
                }
        }
    }

    // OutPut
    tab 1 appear
    load data 1
    tab 2 appear
    load data 2
    tab 1 disappear
    tab 1 appear
    tab 2 disappear
    tab 2 appear
    tab 1 disappear
    tab 1 appear

### 减少视图的计算

在前文的视图值树介绍中我们提到，当 SwiftUI 重建该树时，如果树上某个节点（视图）的 Source of truth
没有发生变化，将不重新计算，直接使用旧值。利用这个特性，我们可以将视图结构体中的某些区域的定义拆分成可被节点承认的形式（符合 View
协议的结构体创建的视图），以提高视图树的刷新效率。

    struct UpdateTest: View {
        @State var i = 0
        var body: some View {
            VStack {
                let _ = print("root update")
                Text("\(i)")
                Button("change") {
                    i += 1
                }
                // circle 在每次刷新时都会重新计算
                VStack {
                    let _ = print("circle update")
                    Circle()
                        .fill(.red.opacity(0.5))
                        .frame(width: 50, height: 50)
                }
            }
        }
    }
    // Output
    root update
    circle update
    root update
    circle update
    root update
    circle update

将 Circle 拆分出来

    struct UpdateTest: View {
        @State var i = 0
        var body: some View {
            VStack {
                let _ = print("root update")
                Text("\(i)")
                Button("change") {
                    i += 1
                }
                UpdateSubView()
            }
        }
    }

    struct UpdateSubView: View {
        var body: some View {
            VStack {
                let _ = print("circle update")
                Circle()
                    .fill(.red.opacity(0.5))
                    .frame(width: 50, height: 50)
            }
        }
    }

    // Output
    root update
    circle update
    root update

## 总结

SwiftUI 作为一个年轻的框架，大家对它的了解还不够深入。随着官方文档、WWDC 专题的不断完善，更多隐藏在 SwiftUI
背后的原理和机制将被开发者所认识并掌握。

# GeometryReader ：好东西还是坏东西？

GeometryReader 自 SwiftUI
诞生之初就存在，它在许多场景中扮演着重要的角色。然而，从一开始就有开发者对其持负面态度，认为应尽量避免使用。特别是在最近几次 SwiftUI
更新中新增了一些可以替代 GeometryReader 的 API 后，这种观点进一步加强。本文将对 GeometryReader
的“常见问题”进行剖析，看看它是否真的如此不堪，以及那些被批评为“不符预期”的表现，是否其实是因为开发者的“预期”本身存在问题。

## 对 GeometryReader 的一些批评

开发者对 GeometryReader 的批评主要集中在以下两个观点：

- GeometryReader 会破坏布局：这种观点认为，由于 GeometryReader 会占用全部可用空间，因此可能会破坏整体的布局设计。
- GeometryReader 无法获取正确的几何信息：这种观点认为，在某些情况下，GeometryReader 无法获取精确的几何信息，或者在视图未发生变化（视觉上）的情况下，其获取的信息可能不稳定。

此外，有些观点认为：

- 过度依赖 GeometryReader 会导致视图布局变得僵化，失去了 SwiftUI 的灵活性优势。
- GeometryReader 打破了 SwiftUI 声明式编程的理念，使得需要直接操作视图框架，更接近命令式编程。
- GeometryReader 更新几何信息时资源消耗较大，可能会引发不必要的重复计算和视图重建。
- 使用 GeometryReader 需要编写大量的辅助代码来计算和调整框架，这会增加编码量，降低代码的可读性和可维护性。

这些批评并非全无道理，其中相当一部分已经通过新的 API 在 SwiftUI 版本更新后得到了改善或解决。然而，关于 GeometryReader
破坏布局、无法获取正确信息的观点，通常是由于开发者对 GeometryReader 的理解不足和使用不当引起的。接下来，我们将针对这些观点进行分析和探讨。

> 在本文发表之前，我发起了一个 [ 投票
> ](https://twitter.com/fatbobman/status/1719926573896544593) 询问大家对
> GeometryReader 的看法，从结果来看，对其持负面印象的比例较高。

![image-20231104120125753](https://cdn.fatbobman.com/image-20231104120125753.png)

## GeometryReader 是什么

在我们深入探讨上述负面观点之前，我们首先需要理解 GeometryReader 的功能以及设计这个 API 的原因。

这是苹果官方文档对于 GeometryReader 的定义：

> A container view that defines its content as a function of its own size and
> coordinate space.
>
> 一个容器视图，根据其自身大小和坐标空间定义其内容。

严格来讲，我并不完全赞同上述描述。这并非因为存在事实上的错误，而是这种表述可能会引起用户的误解。实际上，“GeometryReader”
这个名字更符合其设计目标： **一个几何信息读取器** 。

确切来说，GeometryReader 的作用主要是获取父视图的大小、frame 等几何信息。官方文档中的“定义其内容（ defines its
content ）”这一表述容易让人误以为 GeometryReader
的主要功能是主动影响子视图，或者说其获取的几何信息主要用于子视图，但实际上，它更应被视为一个获取几何信息的工具。这些信息是否应用到子视图完全取决于开发者。

如果一开始就把它设计成下面这样的方式，也许就能避免对它的误解和滥用。

    @State private proxy: GeometryProxy

    Text("Hello world")
        .geometryReader(proxy: $proxy)

如果改为基于 View Extension 的方式，我们可以将 geometryReader 的作用描述为：它提供了其所应用的视图的大小、frame
等几何信息，是视图获取 **自身** 几何信息的有效手段。这种描述可以有效地避免几何信息主要应用于子视图的误解。

对于为什么不采用 Extension 的方式，设计者可能考虑了以下两个因素：

- 通过 Binding 的方式向上传递信息，并不是当前官方 SwiftUI API 的主要设计方式。
- 将几何信息传递到上层视图，可能会引起不必要的视图更新。而向下传递信息，可以确保更新只在 GeometryReader 的闭包中进行。

## GeometryReader 是布局容器吗，它的布局逻辑是什么？

是，但是其行为有些与众不同。

当前，GeometryReader 以一个布局容器的形式存在，其布局规则如下：

- 它是一个多视图容器，其默认堆叠规则类似于 ZStack
- 将父视图的建议尺寸（ Proposed size ）作为自身的需求尺寸（ Required Size ）返回给父视图
- 将父视图的建议尺寸作为自身的建议尺寸传递给子视图
- 将子视图的原点（0,0）置于 GeometryReader 的原点位置
- 其理想尺寸（ Ideal Size）为 (10,10)

如果不考虑获取几何信息的功能，一个 GeometryReader 的布局行为与以下的代码很接近。

    GeometryReader { _ in
      Rectangle().frame(width: 50, height: 50)
      Text("abc").foregroundStyle(.white)
    }

大致等于：

    ZStack(alignment: .topLeading) {
        Rectangle().frame(width: 50, height: 50)
        Text("abc").foregroundStyle(.white)
    }
    .frame(
        idealWidth: 10,
        maxWidth: .infinity,
        idealHeight: 10,
        maxHeight: .infinity,
        alignment: .topLeading
    )

简单来说，GeometryReader
会占用父视图提供的所有空间，并将所有子视图的原点与容器的原点对齐（即放置在左上角）。这种非常规的布局逻辑是我不推荐将其直接用作布局容器的原因之一。

> GeometryReader 不支持对齐指南的调整，因此上面的描述使用了原点。

然而，这并不意味着不能将 GeometryReader 作为视图容器使用。在某些情况下，它可能比其他容器更适合。例如：

    struct PathView: View {
        var body: some View {
            GeometryReader { proxy in
                Path { path in
                    let width = proxy.size.width
                    let height = proxy.size.height

                    path.move(to: CGPoint(x: width / 2, y: 0))
                    path.addLine(to: CGPoint(x: width, y: height))
                    path.addLine(to: CGPoint(x: 0, y: height))
                    path.closeSubpath()
                }
                .fill(.orange)
            }
        }
    }

在绘制 Path 时，GeometryReader
提供的信息（尺寸，原点）正好满足我们的需求。因此，对于需要充满空间且采用原点对齐方式的子视图，GeometryReader 作为布局容器非常合适。

GeometryReader 将完全无视子视图提出的需求尺寸，在这一点上，它的处理方式与 overlay 和 background 对待子视图的方式一致。

在上面对 GeometryReader 的布局规则描述中，我们指出了它的 ideal size 是（10,10 ）。或许有些读者不太了解其含义，ideal
size 是指当父视图给出的建议尺寸为 nil 时（未指定模式），子视图返回的需求尺寸。如果对 GeometryReader
的这个设定不了解，可能会在某些场景下，开发者会感觉 GeometryReader 并没有如预期那样充满所有空间。

例如，执行以下代码，你只能得到一个高度为 10 的矩形：

    struct GeometryReaderInScrollView: View {
        var body: some View {
            ScrollView {
                GeometryReader { _ in
                    Rectangle().foregroundStyle(.orange)
                }
            }
        }
    }

![https://cdn.fatbobman.com/image-20231030192917562.png](https://cdn.fatbobman.com/image-20231030192917562.png)

这是因为 ScrollView 在向子视图提交建议尺寸时，其处理逻辑与大多数布局容器不同。在非滚动方向上，ScrollView
会向子视图提供该维度上的全部可用尺寸。而在滚动方向上，它向子视图提供的建议尺寸为 nil。由于 GeometryReader 的 ideal size 为
(10,10)，因此，在滚动方向上，其返回给 ScrollView 的需求尺寸即为 10。在这点上，GeometryReader 的行为与
Rectangle 一致。因此，可能会有开发者认为 GeometryReader
并没有按照预期充满全部的可用空间。但实际上，它的显示结果是完全正确的，这就是正确的布局结果。

因此，在这种情况下，通常我们只会使用拥有明确值维度的尺寸（ 建议尺寸有值 ），并以此为来计算另一维度的尺寸。

例如，如果我们想在 ScrollView 中以 16:9 的比例显示图片（即使图片自身的比例与此不符）：

    struct GeometryReaderInScrollView: View {
        var body: some View {
            ScrollView {
                ImageContainer(imageName: "pic")
            }
        }
    }

    struct ImageContainer: View {
        let imageName: String
        @State private var width: CGFloat = .zero
        var body: some View {
            GeometryReader { proxy in
                Image("pic")
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .onAppear {
                        width = proxy.size.width
                    }
            }
            .frame(height: width / 1.77)
            .clipped()
        }
    }

![https://cdn.fatbobman.com/image-20231030200535483.png](https://cdn.fatbobman.com/image-20231030200535483.png)

首先，我们使用 GeometryReader 获取 ScrollView 提供的建议宽度，并根据这个宽度计算出所需的高度。然后，通过 `frame`
调整 GeometryReader 向 ScrollView 提交的需求尺寸高度。这样，我们就能得到期望的显示结果。

在这个演示中，Image 正好满足了之前提出的充满空间且原点对齐的要求，因此直接使用 GeometryReader 作为布局容器是完全没有问题的。

> 本章节包含了许多关于 SwiftUI 的尺寸和布局的知识。如果你对此还不太了解，建议你继续阅读以下文章： [ SwiftUI 布局 —— 尺寸（上）
> ](/zh/posts/layout-dimensions-1/) 、 [ SwiftUI 布局 —— 尺寸（下）
> ](/zh/posts/layout-dimensions-2/) 、 [ SwiftUI 布局 —— 对齐 ](/zh/posts/layout-
> alignment/) 。

## 为什么 GeometryReader 无法获取正确的信息

一些开发者可能会抱怨，GeometryReader 无法获取正确的尺寸（总是返回 0,0），或者返回异常的尺寸（比如负数），导致布局错误。

为此，我们首先需要理解 SwiftUI 的布局原理。

SwiftUI
的布局是一个协商过程。父视图向子视图提供建议尺寸，子视图返回需求尺寸。父视图是否根据子视图的需求尺寸来放置子视图，以及子视图是否根据父视图给出的建议尺寸来返回需求尺寸，完全取决于父视图和子视图的预设规则。比如，对于
VStack
，它会在垂直维度上，分别向子视图发送具有明确值的建议尺寸、未指定的建议尺寸、最大建议尺寸以及最小建议尺寸的信息，并获得子视图在不同建议尺寸下的需求尺寸。VStack
会结合视图的优先级，它的父视图给其的建议尺寸，在摆放时对子视图提出最终的建议尺寸。

在一些复杂的布局场景中，或者在某些设备或系统版本中，布局可能需要经过几轮的协商才能获得最终稳定的结果，尤其是当视图需要依赖 GeometryReader
提供的几何信息来重新确定自己的位置和尺寸时。因此，这可能导致 GeometryReader
在获得稳定结果之前，不断向子视图发送新的几何信息。如果我们仍然使用上文代码中的信息获取方式，那么就无法获得变更后的信息：

    .onAppear {
        width = proxy.size.width
    }

因此，正确的获取信息的方式为：

    .task(id: proxy.size.width) {
        width = proxy.size.width
    }

这样，即使数据发生变化，我们也能持续更新数据。一些开发者表示，在屏幕方向发生变化时，无法获取新的信息，原因也是如此。 `task(id:)` 同时涵盖了
`onAppear` 和 `onChange` 的场景，是最可靠的数据获取方式。

另外，在某些情况下，GeometryReader 有可能返回尺寸为负数的数据。如果直接将这些负数数据传递给 `frame`
，就可能会出现布局异常（在调试状态下，Xcode 会用紫色的提示警告开发者）。因此，为了进一步避免这种极端情况，可以在传递数据时，将不符合要求的数据过滤掉。

    .task(id: proxy.size.width) {
        width = max(proxy.size.width, 0)
    }

由于 GeometryProxy 并不符合 Equatable 协议，同时也为了尽可能的减少因信息更新而导致的视图重新评估，开发者应该只传递当前需要的信息。

至于如何传递获取的几何信息（例如上文中使用的 @State 或是通过 PreferenceKey），则取决于开发者的编程习惯和场景需求。

通常，我们会在 `overlay` 或 `background` 中使用 GeometryReader + Color. clear
来获取并传递几何信息。这既保证了信息获取的准确性（尺寸、位置与要获取的视图完全一致），也不会在视觉上造成额外的影响。

    extension View {
        func getWidth(_ width: Binding<CGFloat>) -> some View {
            modifier(GetWidthModifier(width: width))
        }
    }

    struct GetWidthModifier: ViewModifier {
        @Binding var width: CGFloat
        func body(content: Content) -> some View {
            content
                .background(
                    GeometryReader { proxy in
                        let proxyWidth = proxy.size.width
                        Color.clear
                            .task(id: proxy.size.width) {
                                $width.wrappedValue = max(proxyWidth, 0)
                            }
                    }
                )
        }
    }

注意：如果想通过 PreferenceKey 传递信息，最好在 `overlay` 中进行。因为在某些系统版本中，从 `background`
传递的数据无法被 `onPreferenceChange` 获取到。

    struct GetInfoByPreferenceKey: View {
        var body: some View {
            ScrollView {
                Text("Hello world")
                    .overlay(
                        GeometryReader { proxy in
                            Color.clear
                                .preference(key: MinYKey.self, value: proxy.frame(in: .global).minY)
                        }
                    )
            }
            .onPreferenceChange(MinYKey.self) { value in
                print(value)
            }
        }
    }

    struct MinYKey: PreferenceKey {
        static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
            value = nextValue()
        }
        static var defaultValue: CGFloat = .zero
    }

在某些情况下，通过 GeometryReader 获取的值可能会使你陷入无尽的循环，从而导致视图的不稳定和性能损失，例如：

    struct GetSize: View {
        @State var width: CGFloat = .zero
        var body: some View {
            VStack {
                Text("Width = \(width)")
                    .getWidth($width)
            }
        }
    }

![https://cdn.fatbobman.com/unstable-Text-by-
GeometryReader_2023-10-30_22.16.35.2023-10-30%2022_17_21.gif](https://cdn.fatbobman.com/unstable-
Text-by-GeometryReader_2023-10-30_22.16.35.2023-10-30%2022_17_21.gif)

严格来说，这个问题的根源在于 Text。由于默认字体的宽度不是固定的，所以无法形成一个稳定的尺寸协商结果。解决方法很简单，可以通过添加 `.monospaced()` 或使用固定宽度的字体。

    Text("Width = \(width)")
        .monospaced()
        .getWidth($width)

> 字符抖动的示例来自于 SwiftUI-Lab 的 [ Safely Updating The View State ](https://swiftui-
> lab.com/state-changes/) 这篇文章。

## GeometryReader 的性能问题

只要了解 GeometryReader 获取几何信息的时机，就能理解其对性能的影响。作为一个视图，GeometryReader
只能在被评估、布局和渲染后，才能将获取的数据传递给闭包中的代码。这意味着，如果我们需要利用其提供的信息进行布局调整，必须先完成至少一轮的评估、布局和渲染过程，然后才能获取数据，并根据这些数据重新调整布局。这个过程将导致视图被多次重新评估和布局。

由于早期的 SwiftUI 缺少了 LazyGrid 等布局容器，开发者只能通过 GeometryReader
来实现各种自定义布局。当视图数量较多时，这将会导致严重的性能问题。

自从 SwiftUI 补充了一些之前缺失的布局容器后，GeometryReader 对性能的大规模影响已经有所减轻。特别是在允许自定义符合 Layout
协议的布局容器后，上述的问题已基本解决。与 GeometryReader 不同，满足 layout
协议的布局容器能够在布局阶段就获取到父视图的建议尺寸和所有子视图的需求尺寸。这样可以避免由于反复传递几何数据导致的大量视图的反复更新。

然而，这并不意味着在使用 GeometryReader 时没有需要注意的事项。为了进一步减少 GeometryReader
对性能的影响，我们需要注意以下两点：

- 只让少数视图受到几何信息变化的影响
- 仅传递所需的几何信息

以上两点符合我们优化 SwiftUI 视图性能的一贯原则，即控制状态变化的影响范围。

## 用 SwiftUI 的方式进行布局

由于对 GeometryReader
的负面看法，一些开发者会尝试寻找其他方式以避免使用它。不过，大家是否想过，其实在很多场景中，GeometryReader
本来就并非最优解。与其说避免使用，到不如说用更加 SwiftUI 的方式来进行布局。

GeometryReader 常用于需要限定比例的场景，例如让视图占据可用空间的 25%
宽度，或者像上文中根据给定的高宽比来计算高度。在处理类似需求时，我们应优先采用更符合 SwiftUI
的思维方式来考虑布局方案，而非依赖某个特定的几何数据进行计算。

例如，我们可以使用以下代码来满足上文中限定图片高宽比的需求：

    struct ImageContainer2: View {
        let imageName: String
        var body: some View {
            Color.clear
                .aspectRatio(1.77, contentMode: .fill)
                .overlay(alignment: .topLeading) {
                    Image(imageName)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                }
                .clipped()
        }
    }

    struct GeometryReaderInScrollView: View {
        var body: some View {
            ScrollView {
                ImageContainer2(imageName: "pic")
            }
        }
    }

通过 `aspectRatio` 创建一个符合高宽比的基底视图，然后将 `Image` 放置在 `overlay` 中。此外，由于 `overlay` 支持设置对齐指南，比起 GeometryReader，它可以更方便地调整图片的对齐位置。

另外，GeometryReader 经常用于按照一定比例分配两个视图的空间。对于这类需求，也可以通过其他手段处理（以下代码实现了宽度的 40% 和 60%
的分配，高度则取决于最高的子视图）：

    struct FortyPercent: View {
        var body: some View {
            Grid(horizontalSpacing: 0, verticalSpacing: 0) {
                // placeholder
                GridRow {
                    ForEach(0 ..< 5) { _ in
                        Color.clear.frame(maxHeight: 0)
                    }
                }
                GridRow {
                    Image("pic")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .gridCellColumns(2)
                    Text("Fatbobman's Swift Weekly").font(.title)
                        .gridCellColumns(3)
                }
            }
            .border(.blue)
            .padding()
        }
    }

![https://cdn.fatbobman.com/image-20231031103955150.png](https://cdn.fatbobman.com/image-20231031103955150.png)

不过，单纯就按照一定比例将两个视图置于特定空间（ 无视子视图尺寸 ）中这个需求而言，GeometryReader 至今仍是最优解之一。

    struct RatioSplitHStack<L, R>: View where L: View, R: View {
        let leftWidthRatio: CGFloat
        let leftContent: L
        let rightContent: R
        init(leftWidthRatio: CGFloat, @ViewBuilder leftContent: @escaping () -> L, @ViewBuilder rightContent: @escaping () -> R) {
            self.leftWidthRatio = leftWidthRatio
            self.leftContent = leftContent()
            self.rightContent = rightContent()
        }

        var body: some View {
            GeometryReader { proxy in
                HStack(spacing: 0) {
                    Color.clear
                        .frame(width: proxy.size.width * leftWidthRatio)
                        .overlay(leftContent)
                    Color.clear
                        .overlay(rightContent)
                }
            }
        }
    }

    struct RatioSplitHStackDemo: View {
        var body: some View {
            RatioSplitHStack(leftWidthRatio: 0.25) {
                Rectangle().fill(.red)
            } rightContent: {
                Color.clear
                    .overlay(
                        Text("Hello World")
                    )
            }
            .border(.blue)
            .frame(width: 300, height: 60)
        }
    }

![image-20231104145027741](https://cdn.fatbobman.com/image-20231104145027741.png)

本章并不是在暗示开发者应避免使用 GeometryReader，而是在提醒开发者，SwiftUI 还有许多其他的布局手段。

> 请阅读 [ 用 SwiftUI 的方式进行布局 ](/zh/posts/layout-in-swiftui-way/) 和 [ 在 SwiftUI
> 中实现视图居中的若干种方法 ](/zh/posts/centering_the_view_in_swiftui/)
> 两篇文章，以了解面对同一个需求，SwiftUI 有多种布局手段。

## 里子和面子：不同的尺寸数据

在 SwiftUI 中，有一些 modifier 是在布局之后，在渲染层面对视图进行的调整。在 [ SwiftUI 布局 —— 尺寸（ 下 ）
](/zh/posts/layout-dimensions-2/) 一文中，我们探讨过有关尺寸的“里子和面子”的问题。比如下面的代码：

    struct SizeView: View {
        var body: some View {
            Rectangle()
                .fill(Color.orange.gradient)
                .frame(width: 100, height: 100)
                .scaleEffect(2.2)
        }
    }

在布局时，Rectangle 的需求尺寸为 100 x 100，但在渲染阶段，经过 `scaleEffect` 的处理，最终将呈现一个 220 x
220 的矩形。由于 `scaleEffect` 是在布局之后调整的，因此即使创建一个符合 Layout
协议的布局容器，也无法获知其渲染尺寸。在这种情况下，GeometryReader 就发挥了它的作用。

    struct SizeView: View {
        var body: some View {
            Rectangle()
                .fill(Color.orange.gradient)
                .frame(width: 100, height: 100)
                .printViewSize()
                .scaleEffect(2.2)
        }
    }

    extension View {
        func printViewSize() -> some View {
            background(
                GeometryReader { proxy in
                    let layoutSize = proxy.size
                    let renderSize = proxy.frame(in: .global).size
                    Color.clear
                        .task(id: layoutSize) {
                            print("Layout Size:", layoutSize)
                        }
                        .task(id: renderSize) {
                            print("Render Size:", renderSize)
                        }
                }
            )
        }
    }

    // OUTPUT：
    Layout Size: (100.0, 100.0)
    Render Size: (220.0, 220.0)

`GeometryProxy` 的 `size` 属性返回的是视图的布局尺寸，而通过 `frame.size` 返回的则是最终的渲染尺寸。

## visualEffect：无需使用 GeometryReader 也能获取几何信息

考虑到开发者经常需要获取局部视图的 GeometryProxy，而不断地封装 GeometryReader 又显得过于繁琐，因此在 WWDC 2023
中，苹果为 SwiftUI 添加了一个新的 modifier： [ visualEffect
](https://developer.apple.com/documentation/swiftui/visualeffect) 。

`visualEffect` 允许开发者在不破坏当前布局的情况下（不改变其祖先和后代）直接在闭包中使用视图的
GeometryProxy，并对视图应用某些特定的 modifier。

    var body: some View {
        ContentRow()
            .visualEffect { content, geometryProxy in
                content.offset(x: geometryProxy.frame(in: .global).origin.y)
            }
    }

`visualEffect` 仅允许符合 VisualEffect 协议的 modifier
被使用于闭包当中，以保证安全和效果。简单来说，SwiftUI 让只作用于“面子”（ 渲染层面）的 modifier 符合了 VisualEffect
协议，禁止在闭包中使用所有能对布局造成影响的 modifier（ 例如：frame、padding 等）。

我们可以通过以下代码，创建一个 `visualEffect` 的粗糙仿制版本（没有限制可使用的 modifier 类型）：

    public extension View {
        func myVisualEffect(@ViewBuilder _ effect: @escaping @Sendable (AnyView, GeometryProxy) -> some View) -> some View {
            modifier(MyVisualEffect(effect: effect))
        }
    }

    public struct MyVisualEffect<Output: View>: ViewModifier {
        private let effect: (AnyView, GeometryProxy) -> Output
        public init(effect: @escaping (AnyView, GeometryProxy) -> Output) {
            self.effect = effect
        }

        public func body(content: Content) -> some View {
            content
                .modifier(GeometryProxyWrapper())
                .hidden()
                .overlayPreferenceValue(ProxyKey.self) { proxy in
                    if let proxy {
                        effect(AnyView(content), proxy)
                    }
                }
        }
    }

    struct GeometryProxyWrapper: ViewModifier {
        func body(content: Content) -> some View {
            content
                .overlay(
                    GeometryReader { proxy in
                        Color.clear
                            .preference(key: ProxyKey.self, value: proxy)
                    }
                )
        }
    }

    struct ProxyKey: PreferenceKey {
        static var defaultValue: GeometryProxy?
        static func reduce(value: inout GeometryProxy?, nextValue: () -> GeometryProxy?) {
            value = nextValue()
        }
    }

与 `visualEffect` 进行比较：

    struct EffectTest: View {
        var body: some View {
            HStack {
                Text("Hello")
                    .font(.title)
                    .border(.gray)

                Text("Hello")
                    .font(.title)
                    .visualEffect { content, proxy in
                        content
                            .offset(x: proxy.size.width / 2.0, y: proxy.size.height / 2.0)
                            .scaleEffect(0.5)
                    }
                    .border(.gray)
                    .foregroundStyle(.red)

                Text("Hello")
                    .font(.title)
                    .myVisualEffect { content, proxy in
                        content
                            .offset(x: proxy.size.width / 2.0, y: proxy.size.height / 2.0)
                            .scaleEffect(0.5)
                    }
                    .border(.gray)
                    .foregroundStyle(.red)
            }
        }
    }

![https://cdn.fatbobman.com/image-20231031145420378.png](https://cdn.fatbobman.com/image-20231031145420378.png)

## 总结

随着 SwiftUI 功能的不断完善，直接使用 GeometryReader 的情况可能会越来越少。然而，毫无疑问，GeometryReader 仍是
SwiftUI 中一个重要的工具。开发者需要正确地将其应用于适当的场景。

# 揭秘 SwiftData 的数据建模原理

在 SwiftData 的数项改进中，用纯代码声明数据模型无疑给 Core Data 开发者留下了深刻印象。本文将深入探讨 SwiftData
是如何通过代码创建数据模型的，使用了哪些新的语言特性，并展示了如何通过声明代码来创建 PersistentModel 实例。

## 三个事实

了解下述三个事实对于更好地掌握和理解 SwiftData 的建模原理以及为什么 SwiftData 会采用本文介绍的这些方法非常有帮助。

### SwiftData 是建立在 Core Data 之上的框架

尽管苹果极少强调 SwiftData 与 Core Data 之间的关系，但 SwiftData 框架建立在 Core Data
基础之上这一点仍是无可否认的事实。基于 Core Data 为 SwiftData 带来了几点好处：

- 数据库文件格式兼容，现有数据可以直接用新框架操作
- 继承了 Core Data 已有的稳定性验证，大幅减少潜在问题。

尽管 SwiftData 是以 Core Data 为基础的，但这并不意味着，在使用 SwiftData 进行开发时，仍需采用与 Core Data
一样的编程原则。由于 SwiftData 结合了众多 Swift 语言的最新特性，因此，在很多场合下，开发者需要用全新的思维来重新设计数据处理逻辑。

> 在 [ SwiftDataKit：让你在 SwiftData 中使用 Core Data 的高级功能 ](/zh/posts/use-core-
> data-features-in-swiftdata-by-swiftdatakit/) 一文中，我介绍了如何调用 SwiftData 元素背后对应的
> Core Data 对象的技巧。

### SwiftData 与 Swift 语言紧密关联，是 Swift 语言的先导者

近年来，苹果推出了多个以 Swift 为前缀的框架，例如 SwiftUI、Swift Charts、SwiftData 等。这种命名方式体现了这些框架与
Swift 语言的紧密结合。为了实现这些框架，苹果还积极推动 Swift
语言的发展，提出新的提案，并在框架中预先应用了尚未完全确定的特性。这些框架广泛采用了 Swift 的新功能，例如结构构造器（Result
Builder）、属性包装器（Property Wrapper）、宏（Macro）和初始化访问器（Init
Accessors）等，使其成为了新语言特性的先驱和试验场。

遗憾的是，些框架目前尚不存在跨平台和开源的可能。主要是因为它们依赖了苹果生态中的专有 API。这阻碍了利用这些优秀框架在其他平台上推广 Swift
语言的机会。

总的来说，SwiftData 等框架与 Swift 语言关系密切，并在采用新特性方面起到了引领作用。学习这些框架的同时也是在掌握 Swift 语言的新特性。

### 纯代码声明数据模型相对 Core Data 是一项进步但并非革命

尽管 SwiftData 采用的是纯代码声明数据模型的形式，给 Core Data 开发者带来了惊喜，但这在其他框架和语言中早已被应用。相较于 Core
Data，它有所进步，但不能算得上是彻底的革新。

然而，SwiftData 在实现这个概念上有其独特的创新之处。这主要得益于与 Swift 语言的紧密结合。通过创建并使用新出现的语言特性，SwiftData
以更简洁高效并符合现代编程思想的方式实现了声明式建模。

## 模型代码解析

在本节中，我们将对 SwiftData 的模型代码进行剖析，这些代码是以 Xcode 提供的 SwiftData
项目模板中的模型为基础，让我们揭开它神秘的面纱。

    @Model
    final class Item {
        var timestamp: Date = Date.now // 添加了默认值

        init(timestamp: Date) {
            self.timestamp = timestamp
        }
    }

### 宏（ Macro）的作用

如果不考虑宏标志 @Model，上面的代码与我们定义一个标准的 Swift 类完全一样。而 SwiftData 通过 @Model
宏，根据我们提供的简单表述，将其扩展为一个具备完整描述的数据模型。

在 Xcode 中展开宏，我们将可以看到经过宏扩展后的完整代码（@\_PersistedProperty 可以再次展开）。

![swiftData-model-macro-expand-demo_2023-10-01_15.53.39.2023-10-01
15_54_37](https://cdn.fatbobman.com/swiftData-model-macro-expand-
demo_2023-10-01_15.53.39.2023-10-01%2015_54_37.gif)

展开后完整的代码如下：

    public final class Item {
        // 用户定义的持久化属性
        public var timestamp: Date = Date.now {
            // 构造器访问器，在构造实例的过程中，为计算属性添加构造能力
            @storageRestrictions(accesses: _$backingData, initializes: _timestamp)
            init(initialValue) {
                _$backingData.setValue(forKey: \.timestamp, to: initialValue)
                _timestamp = _SwiftDataNoType()
            }
            get {
                _$observationRegistrar.access(self, keyPath: \.timestamp)
                return self.getValue(forKey: \.timestamp)
            }
            set {
                _$observationRegistrar.withMutation(of: self, keyPath: \.timestamp) {
                    self.setValue(forKey: \.timestamp, to: newValue)
                }
            }
        }

        // timestamp 对应的下划线版本，暂时未发现有实际用途
        @Transient
        private var _timestamp: _SwiftDataNoType = .init()

        // 用户自定义的构造器
        public init(timestamp: Date) {
            self.timestamp = timestamp
        }

        // 一个用来包装对应的托管对象（ NSManagedObject ）实例的类型，无需持久化（ @Transient ）
        @Transient
        private var _$backingData: any SwiftData.BackingData<Item> = Item.createBackingData()

        public var persistentBackingData: any BackingData<Item> {
            get {
                self._$backingData
            }
            set {
                self._$backingData = newValue
            }
        }

        // 为创建 Scheme 提供模型的元数据
        public static var schemaMetadata: [Schema.PropertyMetadata] {
            return [
                SwiftData.Schema.PropertyMetadata(name: "timestamp", keypath: \Item.timestamp, defaultValue: Date.now, metadata: nil),
            ]
        }

        // 从 backingData 构造 PersistentModel
        public init(backingData: any BackingData<Item>) {
            _timestamp = _SwiftDataNoType()
            self.persistentBackingData = backingData
        }

        // Observation 协议要求的观察注册器
        @Transient
        private let _$observationRegistrar: ObservationRegistrar = Observation.ObservationRegistrar()

        // 空类型，用于下划线版本的属性
        struct _SwiftDataNoType {}
    }
    // 遵守 PersistentModel 协议
    extension Item: SwiftData.PersistentModel {}
    // 遵守 Observable 协议
    extension Item: Observation.Observable {}

下文将详细描述生成的代码的细节。

### 模型元数据

在 Core Data 中，开发者可以通过 Xcode 提供的数据模型编辑器生成 XML 格式的 .xcdatamodeld
文件。这个文件保存了用于创建数据模型（NSManagedObjectModel）的描述信息。

> 阅读 [ CoreData 探秘 - 从数据模型构建到托管对象实例 ](/zh/posts/from-data-model-construction-
> to-managed-object-instances-in-core-data/) 一文，了解更多信息。

SwiftData 则通过 `Model` 宏，直接将上述描述信息集成在了声明代码的内部。

    public static var schemaMetadata: [Schema.PropertyMetadata] {
        return [
            SwiftData.Schema.PropertyMetadata(name: "timestamp", keypath: \Item.timestamp, defaultValue: Date.now, metadata: nil),
        ]
    }

每个符合 PersistentModel 协议的类都必须提供一个名为 schemaMetadata
的类属性。该属性详细记录了通过解析当前类型的持久化属性定义而生成的用于创建数据模型的元数据。

其中， `name` 对应数据模型的 Attribute Name， `keypath` 为当前类型对应属性的 KeyPath， `defaultValue` 对应属性在声明中设置的默认值（没有默认值，为 nil ），而 `metadata`
则包含了其他的信息，例如：关系描述、删除规则、原始名称等内容。

    @Attribute(.unique, originalName: "old_timestamp")
    var timestamp: Date = Date.now

    static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
      return [
        SwiftData.Schema.PropertyMetadata(name: "timestamp", keypath: \Item.timestamp, defaultValue: Date.now, metadata: SwiftData.Schema.Attribute(.unique, originalName: "old_timestamp"))
      ]
    }

> defaultValue 与开发者在 Xcode 模型编辑器中为 Attribute 创建的默认值功能一致。由于 SwiftData
> 允许数据模型的属性声明为更为复杂的类型（枚举，符合 Encoded 协议的结构体等），因此，SwiftData 在构建模型时将通过给定的 KeyPath
> 来映射对应的存储类型，而且每个 PropertyMetadata 并非一定对应 SQLite 中的一个字段（可能会根据类型创建多个字段）。

SwiftData 将直接读取类属性 `schemaMetadata` 来完成 Schema 乃至 ModelContainer 的创建。

    let schema = Schema([Item.self])

开发者可以使用 Core Data 的新 API `NSManagedObjectModel.makeManagedObjectModel` ，通过为
SwiftData 声明的模型代码来生成对应的 NSManagedObjectModel：

    let model = NSManagedObjectModel.makeManagedObjectModel(for: [Item.self])

### BackingData

每个 PersistentModel 实例的底层都对应了一个托管对象实例（ NSManagedObject ），它被包装在 `_DefaultBackingData` 类型中（ 符合 BackingData 协议 ）。

    @Transient
    private var _$backingData: any SwiftData.BackingData<Item> = Item.createBackingData()

    public var persistentBackingData: any BackingData<Item> {
        get {
            self._$backingData
        }
        set {
            self._$backingData = newValue
        }
    }

`createBackingData` 是 PersistentModel 协议提供的一个类方法，它通过获取 **已经加载的数据模型**
信息，创建一个符合 BackingData 协议的实例，比如： `_DefaultBackingData<Item>`

> 在调用 createBackingData 时，SwiftData 不能仅依赖当前类提供的 schemaMetadata
> 创建实例。换句话说，只有在创建了 ModelContainer 实例后，createBackingData 才能正确地构建
> PersistentModel 实例。这一点与 Core Data 不同，Core Data 可以仅通过 NSEntityDescription
> 信息（无需加载 NSManagedObjectModel）创建实例。

下面是 [ SwiftDataKit ](https://github.com/fatbobman/SwiftDataKit) 中用于从
BackingData 中获取对应 NSManagedObject 实例的代码：

    public extension BackingData {
        // Computed property to access the NSManagedObject
        var managedObject: NSManagedObject? {
            guard let object = getMirrorChildValue(of: self, childName: "_managedObject") as? NSManagedObject else {
                return nil
            }
            return object
        }
    }

    func getMirrorChildValue(of object: Any, childName: String) -> Any? {
        guard let child = Mirror(reflecting: object).children.first(where: { $0.label == childName }) else {
            return nil
        }

        return child.value
    }

通过下面的代码，可以看到：

    private var _$backingData: any SwiftData.BackingData<Item> = Item.createBackingData()

SwiftData 调用 `createBackingData` 来创建 `backingData` 的实例时，不需要 ModelContext（
NSMangedObjectContext ）的存在。其内部应该使用了如下的构建托管对象的方式：

    let item = Item(entity: Item.entity(), insertInto: nil)

这点也解释了，为什么在 SwiftData 中，我们创建一个 PersistentModel 实例后，必须显式的将其注册（ insert ）到某个
ModelContext 上面。

    let item = Item(timestamp:Date.now)
    modelContext.insert(item) // must insert into some modelContext

由于 backingData（ `_DafaultBackingData`
）没有公开的构造方法，我们无法通过托管对象实例来构建该数据。PersistentModel 中的另一个构造方法是为 SwiftData 内部将托管对象转换为
PersistentModel 提供的。

    public init(backingData: any BackingData<Item>) {
        _timestamp = _SwiftDataNoType()
        self.persistentBackingData = backingData
    }

### Init Accessors

通过观察完整的展开代码，timestamp 被宏代码转换成了一个具备构造器的计算属性。

    public var timestamp: Date = Date.now {
        @storageRestrictions(accesses: _$backingData, initializes: _timestamp)
        init(initialValue) {
            _$backingData.setValue(forKey: \.timestamp, to: initialValue)
            _timestamp = _SwiftDataNoType()
        }
        get {
            _$observationRegistrar.access(self, keyPath: \.timestamp)
            return self.getValue(forKey: \.timestamp)
        }
        set {
            _$observationRegistrar.withMutation(of: self, keyPath: \.timestamp) {
                self.setValue(forKey: \.timestamp, to: newValue)
            }
        }
    }

那么，SwiftData 在构建 PersistentModel 实例时，是如何为其构建当前值的呢？先看一下下面的代码：

    public init(timestamp: Date) {
        self.timestamp = timestamp
    }

    let item = Item(timestamp: Date.distantPast)

在 SwiftData 使用 `createBackingData` 创建 Item 实例时，首先会创建一个 timestamp 默认值为 `Date.now` 的 NSManagedObject 实例（通过 schemaMetadata 传递给 Schema，并包装在 backingData
中）。然后，通过初始化访问器（Init Accessors）为 timestamp 设置新的值（来自构造方法参数， `Date.distantPast`
）。

[ 初始化访问器 (Init Accessors) ](https://github.com/apple/swift-
evolution/blob/main/proposals/0400-init-accessors.md#init-accessors) 是 Swift
5.9 中新增加的功能。它将计算属性纳入初始化分析（definite initialization
analysis）。这样，在初始化方法中可以直接对计算属性赋值，它会转化成对应的存储属性的初始化值。

这段代码的含义是：

    @storageRestrictions(accesses: _$backingData, initializes: _timestamp)
    init(initialValue) {
        _$backingData.setValue(forKey: \.timestamp, to: initialValue)
        _timestamp = _SwiftDataNoType()
    }

- `accesses: _$backingData` 表示在 `init` 中会访问 `_$backingData` 这个存储属性。这意味着在调用本 `init` 访问器初始化 `timestamp` 之前，必须先初始化 `_$backingData` 。
- `initializes: _timestamp` 表示这个 `init` 访问器会初始化 `_timestamp` 这个存储属性。
- initialValue：对应传入构造方法参数的初始化值，本例中为 `Date.distantPast`

Init Accessors 作为 Swift 语言的新功能，相较属性包装器（ Property Wrapper
），提供了更统一、精细、明确和灵活的初始化模型。SwiftData
利用这一功能，在构造阶段对持久化属性进行显式赋值，减轻了开发者的工作量，也让模型代码的声明更符合 Swift 语言的逻辑。

### 与 Observation 框架融合

与 NSManagedObject 利用 Combine 框架提供的 Publisher 与 SwiftUI 的视图绑定不同，SwiftData 的
PersistentModel 采用了新的 Observation 框架。

> 请阅读 [ 深度解读 Observation —— SwiftUI 性能提升的新途径 ](/zh/posts/mastering-
> observation/) ，了解更多有关 Observation 框架的信息。

为了满足 Observation 框架的需求，SwiftData 为模型代码添加了以下内容：

    extension Item: Observation.Observable {}

    public final class Item {
        // 用户定义的持久化属性
        public var timestamp: Date = .now {
            ....
            get {
                _$observationRegistrar.access(self, keyPath: \.timestamp)
                return self.getValue(forKey: \.timestamp)
            }
            set {
                _$observationRegistrar.withMutation(of: self, keyPath: \.timestamp) {
                    self.setValue(forKey: \.timestamp, to: newValue)
                }
            }
        }

        ....

        // Observation 协议要求的观察注册器
        @Transient
        private let _$observationRegistrar: ObservationRegistrar = Observation.ObservationRegistrar()
    }

通过在持久化属性的 get 和 set 方法中使用 `_$observationRegistrar`
来注册和通知观察者，实现了以属性为粒度的观察机制。这样做可以大幅减少因为无关属性变动而导致的视图无效更新。

从上面的注册方法中可以得知，开发者 **必须显式调用持久化属性的 set 方法** ，才能让观察者获取到数据变化的通知（调用
withObservationTracking 的 onChange 闭包）。

### Get 和 Set 方法

PersistentModel 协议定义了一些 get 和 set 方法，并提供了默认实现。例如：

    public func getValue<Value, OtherModel>(forKey: KeyPath<Self, Value>) -> Value where Value : Decodable, Value : RelationshipCollection, OtherModel == Value.PersistentElement

    public func getTransformableValue<Value>(forKey: KeyPath<Self, Value>) -> Value

    public func setValue<Value>(forKey: KeyPath<Self, Value>, to newValue: Value) where Value : Encodable

    public func setValue<Value>(forKey: KeyPath<Self, Value>, to newValue: Value) where Value : PersistentModel

通过这些方法，开发者可以读取或写入某个持久化属性。请注意，使用上述的 set 方法（例如：setValue）给属性设置新的值将会绕过 Observation
框架，属性订阅者将无法得到属性发生变化的通知（视图不会自动刷新）。同样，如果用 SwiftDataKit 直接改写 PersistentModel
底层对应的 NSManagedObject 实例的持久化属性，也不会产生通知。

    item.setValue(forKey: \.timestamp, to: date) // 不通知 timestamp 的订阅者
    item.timestamp = date // 通知 timestamp 的订阅者

> BackingData 协议还提供了 get 和 set 方法的定义和默认实现。BackingData 提供的 setValue 方法只能修改
> PersistentModel 对应的底层 NSManagedObject 属性，与通过 SwiftDataKit
> 修改托管对象实例的效果类似。直接使用该方法将导致底层 NSManagedObject 的数据与表层 PersistentModel 数据不一致。

除了提供与 NSManagedObject 的 get 和 set 方法类似的功能外，PersistentModel 协议提供的 get 和 set
方法还要执行其他操作，例如将 PersistentModel 的一个属性对应到 NSManagedObject
的多个属性（当属性为复杂类型时），以及线程调度（确保线程安全）等任务。

### 其他

除了上述的内容外，PersistentModel 协议还声明了其他几个属性：

- hasChanges：表示是否发生了改变，与 NSManagedObject 的同名属性功能类似。
- isDeleted：表示是否已添加到 ModelContext 的删除列表，与 NSManagedObject 的同名属性功能类似。
- modelContext：当前 PersistentModel 所注册的 ModelContext，在未通过 `insert` 进行注册前，该值为 nil

与 NSManagedObject 相比，SwiftData 目前仅暴露了有限的 API。随着 SwiftData
的不断发展，可能会提供更多功能供开发者使用。

## 总结

本文通过详细剖析一段 SwiftData 简单模型的代码，深入解析了其实现原理，包括模型构建、PersistentModel
实例生成以及属性观察通知机制等。剖析的过程也是熟练运用一个框架的重要途径。

在代码解析的过程中，我们不仅加深了对 SwiftData 框架的认识，也对许多 Swift 语言的新特性有了更直观的了解，可谓一举两得。

# SwiftUI 视图与 @MainActor

越来越多的开发者开始尝试开启并发严格检查选项，为 Swift 6 的到来做准备。在收到的警告和错误中，有一部分是与 SwiftUI
的视图有关，其中很多都是由于开发者没有正确的理解和使用 `@MainActor` 造成的。本文将聊聊 `@MainActor` 的含义，以及在
SwiftUI 的视图中应用 `@MainActor` 的技巧和注意事项。

## 我的 PasteButton 不好用了

不久前，在我的 [ Discord ](https://discord.com/servers/zhou-zi-de-swiftji-shi-
ben-967978112509935657) 社区中，一位朋友反映在启用并发严格检查选项后，编译器对 `PasteButton` 给出了下面的错误：

    Call to main actor-isolated initializer 'init(payloadType:onPast:)' in a synchronous nonisolated context

![pasteButton-MainActor-
error-2024-03-13](https://cdn.fatbobman.com/pasteButton-MainActor-
error-2024-03-13.png)

查看 `PasteButton` 的声明后，我询问他是否将该视图代码放在 `body` 之外。得到肯定答复后，我让他为声明 `PasteButton` 的变量添加 `@MainActor` ，问题就解决了。

    @MainActor public struct PasteButton : View {
        @MainActor public init(supportedContentTypes: [UTType], payloadAction: @escaping ([NSItemProvider]) -> Void)

        @MainActor public init<T>(payloadType: T.Type, onPaste: @escaping ([T]) -> Void) where T : Transferable
        public typealias Body = some View
    }

那么，之前的问题出在哪里？为什么添加@MainActor 就能解决？

## 什么是 @MainActor

在 Swift 的并发模型中， `actor` 提供一种安全且易于理解的方式来编写并发代码。 `actor`
类似于类（class），但它专门用来解决并发环境下的数据竞争和同步问题。

    actor Counter {
        private var value = 0

        func increment() {
            value += 1
        }

        func getValue() async -> Int {
            return value
        }
    }

    let counter = Counter()
    Task {
      await counter.increment()
    }

`actor` 的魔法在于通过串行化访问来避免数据竞争，为并发操作提供了一条清晰、安全的路径。然而，这种隔离是局部的，仅限于特定的 `actor`
实例。Swift 进一步引入了 `GlobalActor` 概念，以在更广泛的范围内实现隔离。

`GlobalActor` 允许我们标记跨不同模块的文件中的代码，确保这些操作在相同的串行队列中执行，从而维持操作的原子性和一致性。

    @globalActor actor MyActor: GlobalActor {
        static let shared = MyActor()
    }

    @MyActor
    struct A {
      var name:String = "fat"
    }

    class B {
      var age:Int = 10
    }

    @MyActor
    func printInfo() {
      let a = A()
      let b = B()
      print(a.name,b.age)
    }

`@MainActor` 是 Swift 定义的一个特殊的 `GlobalActor` 。其职责是确保所有标记为 `@MainActor`
的代码都在同一串行队列中执行，并且这一切发生在主线程上。

    @globalActor actor MainActor : GlobalActor {
        static let shared: MainActor
    }

`@MainActor` 这一简洁而强大的特性，为我们曾经依赖 `DispatchQueue.main.async`
来处理的操作提供了一个类型安全且整合了 Swift 并发模型的方法。这不仅简化了代码，降低了出错率，还通过编译器的保护，确保了所有标记 `@MainActor` 的操作安全地在主线程上执行。

## View 协议与 @MainActor

在 SwiftUI
的世界里，视图（View）扮演着将应用程序状态以声明式方式展现在屏幕上的角色。这自然让人们假设，构成视图的所有代码都将在主线程中执行，毕竟，视图直接关联着用户界面的展现。

然而，探究 View 协议将揭示了一个细节：仅有 `body` 属性被显式地标记为 `@MainActor` 。这个发现意味着遵循 View
协议的类型，并不保证其整体运行在主线程上。除了 `body` 之外，编译器不会自动确保其他属性或方法在主线程中执行。

    public protocol View {
        associatedtype Body : View
        @ViewBuilder @MainActor var body: Self.Body { get }
    }

这一发现对于理解 SwiftUI 官方组件如 `PasteButton` 的使用尤为关键，因为它与大多数其他组件不同，被明确地标记为 `@MainActor` 。这表示， `PasteButton` 必须在同样被标记为 `@MainActor`
的上下文中使用，否则编译器将报错，指出不允许在非隔离的同步上下文中调用隔离于主线程的初始化器：

    struct PasteButtonDemo:View {
      var body: some View {
        VStack {
          Text("Hello")
          button
        }
      }

      var button:some View {
        PasteButton(payloadType: String.self){ str in // Call to main actor-isolated initializer 'init(payloadType:onPaste:)' in a synchronous nonisolated context
          print(str)
        }
      }
    }

为解决这一问题，简单地将 `button` 变量标记为 `@MainActor` 就可以顺利通过编译，因为这样做确保了 `button`
在一个符合要求的上下文中被初始化和使用：

    @MainActor
    var button:some View {
      PasteButton(payloadType: String.self){ str in
        print(str)
      }
    }

> 大多数 SwiftUI 组件都是值类型并符合 Sendable 协议，它们并未被显式标记为 `@MainActor` ，因此不会遇到 `PasteButton` 所面临的特定问题。

这个改动突显了在 SwiftUI 视图中使用 `@MainActor` 的重要性，同时也提醒开发者注意，不是所有视图相关的代码都默认运行在主线程中。

## 为 View 应用 @MainActor

或许有读者会想，我直接为 `PasteButtonDemo` 视图类型标注 `@MainActor` ，是不是就可以从根本上解决问题？

将整个 `PasteButtonDemo` 视图标注为 `@MainActor` 确实可以解决目前面临的问题。标注了 `@MainActor`
后，Swift 编译器就会假定该视图内的所有属性和方法均在主线程中执行，这样就无需对 `button` 进行单独的标注了。

    @MainActor
    struct PasteButtonDemo:View {
      var body: some View {
        ...
      }

      var button:some View {
        PasteButton(payloadType: String.self){ str in
          ...
        }
      }
    }

这种做法还带来了其他一些好处。比如，在利用 `Observation` 框架构建的可观察对象时，为了确保其状态更新在主线程进行，可以给可观察对象本身标注
`@MainActor` ：

    @MainActor
    @Observable
    class Model {
      var name = "fat"
      var age = 10
    }

然而，如果尝试按照官方文档建议，使用 `@State` 在视图中声明此可观察对象实例，就会遇到编译器警告：这在 Swift 6 中被视为错误。

    struct DemoView: View {
      @State var model = Model() // Main actor-isolated default value in a nonisolated context; this is an error in Swift 6
      var body: some View {
        NameView(model: model)
      }
    }

    struct NameView: View {
      let model: Model
      var body: some View {
        Text(model.name)
      }
    }

这种情况的发生是因为，默认情况下视图的实现并未标注为 `@MainActor` ，因此无法在视图中直接声明标注了 `@MainActor`
的类型。一旦 `DemoView` 被标注为 `@MainActor` ，上述问题便迎刃而解。

为进一步简化操作，我们还可以定义一个使用 `@MainActor` 标注的协议，让任何遵循该协议的视图自动继承主线程的执行环境：

    @MainActor
    protocol MainActorView: View {}

这样，任何实现了 `MainActorView` 协议的视图都保证其全部操作都在主线程上执行：

    struct AsyncDemoView: MainActorView {
      var body: some View {
        Text("abc")
          .task {
            await doSomething()
          }
      }

      func doSomething() async {
        print(Thread.isMainThread) // true
      }
    }

尽管为视图类型标注 `@MainActor`
似乎是个不错的解决方案，但这样会使所有声明在视图中的异步方法都必须在主线程执行，这可能不总是开发者所期望的。例如：

    @MainActor
    struct AsyncDemoView: View {
      var body: some View {
        Text("abc")
          .task {
            await doSomething()
          }
      }

      func doSomething() async {
        print(Thread.isMainThread) // true
      }
    }

若不进行 `@MainActor` 标注，我们便能更灵活地根据需要对属性和方法进行逐一标注：

    struct AsyncDemoView: View {
      var body: some View {
        Text("abc")
          .task {
            await doSomething()
          }
      }

      func doSomething() async {
        print(Thread.isMainThread) // false
      }
    }

因此，是否为视图类型标注 `@MainActor` 取决于实际的应用场景。

## @StateObject 的新用途

随着 Observation 框架成为新标准， `@StateObject` 的传统用途似乎变得不那么显著。然而，它仍然拥有一项特殊功能，让其仍可以在
Observation 时代发挥作用。正如我们之前讨论的，一个被 `@MainActor` 标注的 `@Observable`
可观察对象不能直接通过 `@State` 声明——除非整个视图也被标注为 `@MainActor` 。但是，有了 `@StateObject`
，我们就能巧妙地绕过这一限制。

考虑下面的示例，我们可以无需将整个视图标注为 `@MainActor` ，就能在视图中安全地引入被 `@MainActor` 标注的可观察对象：

    @MainActor
    @Observable
    class Model: ObservableObject {
      var name = "fat"
      var age = 10
    }

    struct StateObjectDemo:View {
      @StateObject var model = Model()
      var body: some View {
        VStack {
          NameView(model: model)
          AgeView(model: model)
          Button("update age"){
            model.age = Int.random(in: 0..<100)
          }
        }
      }
    }

这一实践的可行性源自于 `@StateObject` 的独特加载机制。在视图被实际加载之时， `@StateObject`
才会在主线程上调用其构造方法中的闭包。此外， `@StateObject` 的 `wrappedValue` 被标注为 `@MainActor`
，这保证了它能正确地初始化和使用被 `@MainActor` 标注的符合 `ObservableObject` 协议的类型。

    @frozen @propertyWrapper public struct StateObject<ObjectType>: SwiftUI.DynamicProperty where ObjectType: Combine.ObservableObject {
        @usableFromInline
        @frozen internal enum Storage {
            case initially(() -> ObjectType)
            case object(SwiftUI.ObservedObject<ObjectType>)
        }

        @usableFromInline
        internal var storage: SwiftUI.StateObject<ObjectType>.Storage
        @inlinable public init(wrappedValue thunk: @autoclosure @escaping () -> ObjectType) {
            storage = .initially(thunk)
        }

        @_Concurrency.MainActor(unsafe) public var wrappedValue: ObjectType {
            get
        }

        @_Concurrency.MainActor(unsafe) public var projectedValue: SwiftUI.ObservedObject<ObjectType>.Wrapper {
            get
        }

        public static func _makeProperty<V>(in buffer: inout SwiftUI._DynamicPropertyBuffer, container: SwiftUI._GraphValue<V>, fieldOffset: Swift.Int, inputs: inout SwiftUI._GraphInputs)
    }

这种方法的主要优势在于它既确保了可观察对象的生命周期安全，又完整地保留了其基于 Observation
框架的观察逻辑。这样，我们便能在不必将整个视图强制标注为 `@MainActor` 的情况下，灵活地使用被 `@MainActor`
标记的可观察类型。这为我们提供了一条既维护了视图灵活性，又不损害数据安全和响应逻辑的路径。在苹果官方提供更明确的在主线程上运行 `@State`
或调整视图声明的解决方案之前，这种做法是一个实用且有效的临时策略。

## 总结

在开启并发严格检查之后，许多开发者在面对一系列的警告和错误时可能会感到困惑和不知所措。其中一些人可能会采取根据提示逐个修改代码的方式来消除这些错误。然而，引入新的并发模型到项目中的根本目的远不止于“欺骗”编译器。实际上，开发者应当深入理解
Swift
的并发模型，并在更宏观的层面上重新审视自己的代码，以发现更优质、更安全的解决策略，而不是仅仅头痛医头、脚痛医脚。这种方法不仅能够提高代码的质量和可维护性，也能够帮助开发者在
Swift 的并发编程世界中更加自信和得心应手。

# 用 SwiftUI 的方式进行布局

最近时常有朋友反映，尽管 SwiftUI 的布局系统学习门槛很低，但当真正面对要求较高的设计需求时，好像又无从下手。SwiftUI
真的具备创建复杂用户界面的能力吗？本文将通过用多种手段完成同一需求的方式，展示 SwiftUI 布局系统的强大与灵活，并通过这些示例让开发者对
SwiftUI 的布局逻辑有更多的认识和理解。

> 可在 [ 此处
> ](https://github.com/fatbobman/BlogCodes/tree/main/LayoutInTheSwiftUIWay)
> 获取本文代码。

## 需求

不久前，在 [ 聊天室 ](https://discord.gg/ApqXmy5pQJ) 中，有网友提出了这样一个布局需求：

有两个竖向排列的视图。在初始状态时（ show == false ），视图一（ 红色视图 ）的底部与屏幕底部对齐，当 show == true 时，视图二（
绿色视图 ）的底部与屏幕底部对齐。

大致效果如下：

![layoutInSwiftUIWayDemo](https://cdn.fatbobman.com/layoutInSwiftUIWayDemo_2023-02-28_11.23.58.2023-02-28%2011_24_54.gif)

## 解决方案

对于上面的需求，相信不少读者都会在第一时间想出多个解决方案。下文中，我们将用 SwiftUI
布局系统提供的多种手段来实现该要求。在这些解决方案中，有些非常简单、直接，有些则会略显烦琐，曲折。我尽量让每种方案都采用不同的布局逻辑。

### 准备工作

我们首先将一些可复用的代码提取出来，以简化之后的工作：

    // 视图一
    struct RedView: View {
        var body: some View {
            Rectangle()
                .fill(.red)
                .frame(height: 600)
        }
    }

    // 视图二
    struct GreenView: View {
        var body: some View {
            Rectangle()
                .fill(.green)
                .frame(height: 600)
        }
    }

    // 状态切换按钮
    struct OverlayButton: View {
        @Binding var show: Bool
        var body: some View {
            Button(show ? "Hide" : "Show") {
                show.toggle()
            }
            .buttonStyle(.borderedProminent)
        }
    }

    extension View {
        func overlayButton(show: Binding<Bool>) -> some View {
            self
                .overlay(alignment: .bottom) {
                    OverlayButton(show: show)
                }
        }
    }

    // 获取视图尺寸
    struct SizeInfoModifier: ViewModifier {
        @Binding var size: CGSize
        func body(content: Content) -> some View {
            content
                .background(
                    GeometryReader { proxy in
                        Color.clear
                            .task(id: proxy.size) {
                                size = proxy.size
                            }
                    }
                )
        }
    }

    extension View {
        func sizeInfo(_ size: Binding<CGSize>) -> some View {
            self
                .modifier(SizeInfoModifier(size: size))
        }
    }

### 一、Offset

VStack + offset 是一个相当符合直觉的处理方式。

    struct OffsetDemo: View {
        @State var show = false
        @State var greenSize: CGSize = .zero
        var body: some View {
            Color.clear
                .overlay(alignment: .bottom) {
                    VStack(spacing: 0) {
                        RedView()
                        GreenView()
                            .sizeInfo($greenSize)
                    }
                    .offset(y: show ? 0 : greenSize.height)
                    .animation(.default, value: show)
                }
                .ignoresSafeArea()
                .overlayButton(show: $show)
        }
    }

代码提示：

- `Color.clear.ignoresSafeArea()` 将创建一个与屏幕尺寸一致的视图
- overlay 可以很好的控制建议尺寸，同时又可享受到便捷的对齐设置
- 通过 `animation(.default, value: show)` 使动画与特定的状态变化相关联

在上面的代码中，考虑到当 show == true 时，视图二（ 绿色视图 ）的底部必然与屏幕底部对齐，因此，将 overlay 的对齐指南设置为 `bottom` ，可以极大地简化我们的初始布局声明。以此布局为基础，通过 offset ，分别为两种状态进行了位移值描述。

我们也可以使用其他的修饰符（ 例如：padding、postion ）采用该布局思路实现上述需求。

    .offset(y: show ? 0 : greenSize.height) // 替换改行为
    .padding(.bottom, show ? 0 : -greenSize.height)

> 尽管在本例中，offset 和 padding 的视觉呈现一致，但当需要与其他视图一起进行布局时，两者之间还是有很大的不同。padding
> 是在布局层面进行的调整，添加 padding 后的视图，同时也会对其他视图的布局产生影响。offset
> 则是在渲染层面进行的位置调整，即使出现了位置变化，其他视图在布局时，并不会将其位移考虑在其中。有关这方面的内容，请参阅 [ SwiftUI 布局 ——
>
> > 尺寸（ 下 ） ](/zh/posts/layout-
> > dimensions-2/#%E9%9D%A2%E5%AD%90%E5%92%8C%E9%87%8C%E5%AD%90) 一文中“面子和里子”章节。

![padding-offset](https://cdn.fatbobman.com/image-20230228134936300.png)

### 二、AlignmentGuide

在 SwiftUI 中，开发者可以使用 alignmentGuide 修饰器来修改视图某个对齐指南的值（ 设置显式值 ）。由于 `Color.clear.overlay` 为我们提供了一个相当理想的布局环境，因此，通过分别修改在不同状态下两个视图的对齐指南，也能满足本文的需求。

    struct AlignmentDemo: View {
        @State var show = false
        @State var greenSize: CGSize = .zero
        var body: some View {
            Color.clear
                .overlay(alignment: .bottom) {
                    RedView()
                        .alignmentGuide(.bottom) {
                            show ? $0[.bottom] + greenSize.height : $0[.bottom]
                        }
                }
                .overlay(alignment: .bottom) {
                    GreenView()
                        .sizeInfo($greenSize)
                        .alignmentGuide(.bottom) {
                            show ? $0[.bottom] : $0[.top]
                        }
                }
                .animation(.default, value: show)
                .ignoresSafeArea()
                .overlayButton(show: $show)
        }
    }

在本解决方案中，我们将两个视图分别置于两个 overlay 层中，尽管在视觉上，两者之间仍呈垂直排列，但实际上两者之间并无关联。

无论为同一个视图添加多少层 overlay（ 或 background ），它们为子视图所提供的建议尺寸都是一致的（ 与原视图的尺寸一致
）。在上面的代码中，由于两个视图使用了同样的动画曲线设定，因此，在移动时并不会出现分离的情况。但如果为视图分别设定不同的动画曲线（ 例如：一个
linear、一个 easeIn ），状态切换时便无法保证视图之间的完全紧密。

> 有关建议尺寸、需求尺寸等内容，请参阅 [ SwiftUI 布局 —— 尺寸（ 上 ） ](/zh/posts/layout-dimensions-1/)
> 一文

### 三、NameSpace

从 3.0 版本（ iOS 15 ）开始，SwiftUI 提供了新的 NameSpace 以及 matchedGeometryEffect
修饰器，让开发者只需少量代码便可实现例如英雄动画这类的复杂需求。

严格意义上来说，NameSpace + matchedGeometryEffect 是对一组修饰器以及代码的统一封装。通过命名空间以及 ID
来保存特定视图的几何信息（ 位置、尺寸 ），并自动设置给其他有需求的视图。

    struct NameSpaceDemo: View {
        @State var show = false
        @Namespace var placeHolder
        @State var greenSize: CGSize = .zero
        @State var redSize: CGSize = .zero
        var body: some View {
            Color.clear
                // green placeholder
                .overlay(alignment: .bottom) {
                    Color.clear // GreenView().opacity(0.01)
                        .frame(height: greenSize.height)
                        .matchedGeometryEffect(id: "bottom", in: placeHolder, anchor: .bottom, isSource: true)
                        .matchedGeometryEffect(id: "top", in: placeHolder, anchor: .top, isSource: true)
                }
                .overlay(
                    GreenView()
                        .sizeInfo($greenSize)
                        .matchedGeometryEffect(id: "bottom", in: placeHolder, anchor: show ? .bottom : .top, isSource: false)
                )
                .overlay(
                    RedView()
                        .matchedGeometryEffect(id: "top", in: placeHolder, anchor: show ? .bottom : .top, isSource: false)
                )
                .animation(.default, value: show)
                .ignoresSafeArea()
                .overlayButton(show: $show)
        }
    }

在上面的代码中，我们在第一个 overlay 中绘制了一个与视图二尺寸一致的视图（ 不显示 ），并将其底边与屏幕底边对齐。通过 `matchedGeometryEffect` 分别为该站位视图的顶部和底部设置了两个标识符以保存信息。

让视图一、视图二在两个状态下分别使用对应的 ID 位置，即可实现本文需求。

> NameSpace + matchedGeometryEffect
> 是一个十分强大的组合，尤其擅长面对同时有位置及尺寸变化的场景。不过需要注意的是，NameSpace 只适用于在同一棵视图树中分享数据，如果出现了例如 [
> 一段因 @State 注入机制所产生的“灵异代码” ](/zh/posts/bug-code-by-state-inject/)
> 一文中提到了两棵树的情况，则无法实现几何信息的共享。

### 四、ScrollView

考虑到本文需求的动画形态（ 竖向滚动 ），使用 ScrollViewReader 提供的滚动定位功能，同样可以满足需求。

    struct ScrollViewDemo: View {
        @State var show = false
        @State var screenSize: CGSize = .zero
        @State var redViewSize: CGSize = .zero
        var body: some View {
            Color.clear
                .overlay(
                    ScrollViewReader { proxy in
                        ScrollView {
                            VStack(spacing: 0) {
                                Color.clear
                                    .frame(height: screenSize.height - redViewSize.height)
                                RedView()
                                    .sizeInfo($redViewSize)
                                    .id("red")
                                GreenView()
                                    .id("green")
                            }
                        }
                        .scrollDisabled(true)
                        .onAppear {
                            proxy.scrollTo("red", anchor: .bottom)
                        }
                        .onChange(of: show) { _ in
                            withAnimation {
                                if show {
                                    proxy.scrollTo("green", anchor: .bottom)
                                } else {
                                    proxy.scrollTo("red", anchor: .bottom)
                                }
                            }
                        }
                    }
                )
                .sizeInfo($screenSize)
                .ignoresSafeArea()
                .overlayButton(show: $show)
        }
    }

尽管都是垂直构图（ axis 为 vertical ），但 ScrollView 与 VStack 在处理各种尺寸的逻辑上还是有非常大的差别。

ScrollView 会使用父视图给定的全部建议尺寸创建滚动区域，但在询问其子视图的需求尺寸时只会提供理想尺寸。这意味着，在 ScrollView
中，子视图最好明确的设定尺寸（ 提出明确地需求尺寸 ）。因此，在上面的代码中，需要通过屏幕高度和视图一的高度差来计算上方的空白站位视图高度。

通过设定 `scrollTo` 的 anchor，在合理的要求下，我们可以让视图停在特定位置。 `scrollDisabled` （ 则让我们可以在
iOS 16+ 中屏蔽 ScrollView 的滚动手势 ）。

### 五、LayoutPriority

在 SwiftUI 中，设置视图优先级（ 使用 `layoutPriority` ）是一个好用但并不常用的功能。SwiftUI
在进行布局时，当布局容器给出的建议尺寸无法满足全部子视图的需求尺寸时，会根据子视图的 Priority，优先满足级别较高的视图的布局需求。

    struct LayoutPriorityDemo: View {
        @State var show = false
        @State var screenSize: CGSize = .zero
        @State var redViewSize: CGSize = .zero
        var body: some View {
            Color.clear
                .overlay(alignment: show ? .bottom : .top) {
                    VStack(spacing: 0) {
                        Spacer()
                            .frame(height: screenSize.height - redViewSize.height)
                            .layoutPriority(show ? 0 : 2)
                        RedView()
                            .sizeInfo($redViewSize)
                            .layoutPriority(show ? 1 : 2)
                        GreenView().layoutPriority(show ? 2 : 0)
                    }
                    .animation(.default, value: show)
                }
                .sizeInfo($screenSize)
                .ignoresSafeArea()
                .overlayButton(show: $show)
        }
    }

在上面的代码中，我们让 overlay 在两种状态时，采取不同的布局指南策略，并让视图具备不同的优先级状态（ 状态切换时 ），以此来获得想要的布局结果。

> 尽管 Spacer 给定了明确的尺寸，但在状态二时，受限于建议尺寸，其并不会参与布局。视图二同理

### 六、再战 AlignmentGuide

在上面使用 AlignmentGuide 的例子中，我们通过 GeometryReader
获取了视图二的高度信息，并通过设置显式对齐指南来完成了移动。从某种逻辑上来说，这种方式与 offset 类似，都需要获取到明确的位移值才能满足需要。

在本例中，尽管仍使用 AlignmentGuide，但无需获取具体尺寸值，便可达成目标。

    struct AlignmentWithoutGeometryReader: View {
        @State var show = false
        var body: some View {
            Color.clear
                .overlay(alignment: .bottom) {
                    GreenView()
                        .alignmentGuide(.bottom) {
                            show ? $0[.bottom] : 0
                        }
                        .overlay(alignment: .top) {
                            RedView()
                                .alignmentGuide(.top) { $0[.bottom] }
                        }
                        .animation(.default, value: show)
                }
                .ignoresSafeArea()
                .overlayButton(show: $show)
        }
    }

在上面的代码中，我们利用 overlay 嵌套 + alignmentGuide
的方式实现了将视图一的底边与视图二的顶部对齐绑定。因此，只需要在状态切换时，调整视图二的对齐指南即可（ 视图一将自动跟随视图二移动 ）。

此种方式在视觉上与通过 VStack 的实现类似，但两者在需求尺寸上有明显不同。VStack 的纵向需求尺寸为视图一与视图二的高度和，而通过 overlay
嵌套，纵向需求尺寸仅为视图二的高度（ 尽管视觉上视图一在视图二的上方且紧密相连 ）。

### 七、Transition

通过为视图设定 Transition（ 转场 ），在视图插入或将其移出视图树时，SwiftUI 将自动生成对应的动画效果。

    struct TransitionDemo:View {
        @State var show = false
        var body: some View {
            Color.clear
                .overlay(alignment:.bottom){
                    VStack(spacing:0) {
                        RedView()
                        if show {
                            GreenView()
                                .transition(.move(edge: .bottom))
                        }
                    }
                    .animation(.default, value: show)
                }
                .ignoresSafeArea()
                .overlayButton(show: $show) // 不能使用显式动画
        }
    }

请注意，转场对动画设定的位置、方式要求很高。稍不注意便会出现转场完全失效或部分失效的情况，例如在本例中，如果在 Button 中（ 切换 show 状态时
）添加 `withAnimation` 进行显式动画设定，将导致进入转场失效。

转场是 SwiftUI 提供的强大能力之一，可以极大地简化动画实现的难度。我写的视图管理器 [ SwiftUI Overlay Container
](/zh/posts/swiftuioverlaycontainer2/) ，便是建立在对转场功能的充分应用之上。

> 有关转场动画的更多内容，请参阅 [ SwiftUI 的动画机制
> ](/zh/posts/the_animation_mechanism_of_swiftui/) 一文

### 八、Layout 协议

在 4.0 版本中，SwiftUI 增加了 Layout
协议，通过该协议，开发者可以针对特定的场景，创建自定义布局容器。尽管当前的需求仅有两个视图，但我们仍然可以从中提炼出场景特性：在垂直排列的前提下，在特定状态时，指定视图的底部与容器视图的底部对齐。

    struct LayoutProtocolDemo: View {
        @State var show = false
        var body: some View {
            Color.clear
                .overlay(
                    AlignmentBottomLayout {
                        RedView()
                            .alignmentActive(show ? false : true) // 设定当前的活动视图
                        GreenView()
                            .alignmentActive(show ? true : false)
                    }
                    .animation(.default, value: show)
                )
                .ignoresSafeArea()
                .overlayButton(show: $show)
        }
    }

    struct ActiveKey: LayoutValueKey {
        static var defaultValue = false
    }

    extension View {
        func alignmentActive(_ isActive: Bool) -> some View {
            layoutValue(key: ActiveKey.self, value: isActive)
        }
    }

    struct AlignmentBottomLayout: Layout {
        func makeCache(subviews: Subviews) -> Catch {
            .init()
        }

        func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout Catch) -> CGSize {
            guard !subviews.isEmpty else { return .zero }
            var height: CGFloat = .zero
            for i in subviews.indices {
                let subview = subviews[i]
                if subview[ActiveKey.self] == true { // 获取活动视图
                    cache.activeIndex = i
                }
                let viewDimension = subview.dimensions(in: proposal)
                height += viewDimension.height
                cache.sizes.append(.init(width: viewDimension.width, height: viewDimension.height))
            }
            return .init(width: proposal.replacingUnspecifiedDimensions().width, height: proposal.replacingUnspecifiedDimensions().height)
        }

        func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout Catch) {
            guard !subviews.isEmpty else { return }
            var currentY: CGFloat = bounds.height - cache.alignmentHeight + bounds.minY // 初始 y 位置
            for i in subviews.indices {
                let subview = subviews[i]
                subview.place(at: .init(x: bounds.minX, y: currentY), anchor: .topLeading, proposal: proposal)
                currentY += cache.sizes[i].height
            }
        }
    }

    struct Catch {
        var activeIndex = 0
        var sizes: [CGSize] = []

        var alignmentHeight: CGFloat {
            guard !sizes.isEmpty else { return .zero }
            return sizes[0...activeIndex].map { $0.height }.reduce(0,+)
        }
    }

在上面的代码中，我们通过 `alignmentActive` （ LayoutValueKey ）指示当前与容器底部对齐的视图。

毋庸置疑，这是所有方案中最复杂的实现。不过，如果我们有类似的需求，使用该自定义容器将十分地便利。

    struct LayoutProtocolExample: View {
        let views = (0..<8).map { _ in CGFloat.random(in: 100...150) }
        @State var index = 0
        var body: some View {
            VStack {
                Picker("", selection: $index) {
                    ForEach(views.indices, id: \.self) { i in
                        Text("\(i)").tag(i)
                    }
                }
                .pickerStyle(.segmented)
                .zIndex(2)
                AlignmentBottomLayout {
                    ForEach(views.indices, id: \.self) { i in
                        RoundedRectangle(cornerRadius: 20)
                            .fill(.orange.gradient)
                            .overlay(Text("\(i)").font(.title))
                            .padding([.horizontal, .top], 10)
                            .frame(height: views[i])
                            .alignmentActive(index == i ? true : false)
                    }
                }
                .animation(.default, value: index)
                .frame(width: 300, height: 400)
                .clipped()
                .border(.blue)
            }
            .padding(20)
        }
    }

![自定义布局容器](https://cdn.fatbobman.com/layoutProtocol_2023-02-28_16.24.29.2023-02-28%2016_25_19.gif)

## 总结

同大多的布局框架一样，最终决定布局能力的上限主要取决于开发者。SwiftUI
为我们提供了众多的布局手段，只有充分地理解并掌握它们，方可从容应对复杂的布局需求。

# HowTo —— SwiftUI2.0 使用 ToolBar 替代 navigationbarItems

SwiftUI 2.0 为了实现更好的多平台支持同时需要兼顾 1.0 版本代码兼容性，提供了一些与已有控件功能上类似但名称和用法全新的控件。比如
ToolBar, navigationTitle 等。Toolbar 可以实现 navigationbarItems
的全部功能，并新增了在多平台下的适配。采用了全新的语法，代码更易阅读。

> **在当前的 Xcode Version 12.0 beta 2 (12 A 6163 b) 版本下，ToolBar 在 macOS
> 下仍然有非常多的问题。**

## 基本用法

    struct ToolBarTest: View {
        var body: some View {
          NavigationView{
            Text("ToolBar 演示")
                .toolbar{
                    ToolbarItem(placement:.automatic){
                        HStack(spacing:20){
                            Button(action:{print("wave")}){
                                Image(systemName: "waveform.path.badge.plus")
                                    .foregroundColor(.purple)
                                    .scaleEffect(1.5, anchor: .center)
                            }

                        }
                    }
                    //placement 设置放置位置，ToolBarItem 中的 View 解析不会完全和预期一致，不知道是特别限制还是 bug. 比如说无法显示多彩符号，无法使用 Spacer 等。
                    ToolbarItem(placement: .bottomBar){
                        HStack(spacing:100){
                            Button(action:{print("lt")}){
                                Image(systemName: "lt.rectangle.roundedtop.fill")
                                    .foregroundColor(.purple)
                                    .scaleEffect(1.5, anchor: .center)
                            }

                            Button(action:{print("rt")}){
                                Image(systemName: "rt.rectangle.roundedtop.fill")
                                    .foregroundColor(.purple)
                                    .scaleEffect(1.5, anchor: .center)
                            }
                        }
                    }
                }
            }
        }
    }

![截屏 2020-07-10 上午 9.01.52]( [ https://cdn.fatbobman.com/howto-swiftui-
toolbar-toolbar1.png ](https://cdn.fatbobman.com/howto-swiftui-toolbar-
toolbar1.png) width=300)

## 多平台适配

为了能够更好的适配多平台，placment 提供了 automatic 这样的多平台自适应选项。placement
有些值全平台可用，有些只支持部分平台，还有一部分的可在多平台运行不过只能在部分平台正确显示。

    import SwiftUI

    struct ToolBarTest: View {
        @State var placementSelection:Placement = .automatic
        @State var placement:ToolbarItemPlacement = .automatic
        @State var show = true
        var body: some View {
            NavigationView{
                VStack{
                    Picker("placement:",selection:$placementSelection){
                        ForEach(Placement.allCases,id:\.self){ placement in
                            Text(placement.rawValue)
                                .tag(placement)
                        }
                    }
                    .labelsHidden()
                    .padding(.all, 10)
                    .onChange(of: placementSelection) { value in
                        switch value{
                        case .automatic:
                            placement = .automatic
                        case .principal:
                            placement = .principal //iOS 不显示
                        case .navigation:
                            placement = .navigation
                        case .primaryAction:
                            placement = .primaryAction
                        case .status:
                            placement = .status //iOS 不显示
                        case .confirmationAction:
                            placement = .confirmationAction //iOS 不显示
                        case .cancellationAction:
                            placement = .cancellationAction //iOS 不显示
                        case .destructiveAction:
                            placement = .destructiveAction //iOS 不显示
                        #if os(iOS)
                        case .bottomBar:
                            placement = .bottomBar
                        //不知道为什么有 bug, 设置后不显示
                        //ToolbarItem(placement:.bottomBar) 可以显示
                        case .navigationBarLeading:
                            placement = .navigationBarLeading
                        case .navigationBarTrailing:
                            placement = .navigationBarTrailing
                        #endif
                        }
                    }
                    //在 macOS 下如果需要显式设置是否显示 ToolBar, 需要设置 id,iOS 下可以不用设置
                    //当前在 macOS 下，如果不显式关闭可能导致不同 View 的 ToolBar 混合到了一起，或者重复出现。不知道是否是 bug 还是设计逻辑
                    .toolbar(id:"ToolBar") {
                        ToolbarItem(id:"1",placement:placement,showsByDefault:show) {
                            Button("确定"){

                            }
                        }
                    }
                    .navigationTitle("Toolbar 演示")

                    #if os(macOS)
                    Toggle("显示 ToolBar",isOn:$show)
                    Spacer()
                    #endif
                } .frame(maxWidth:.infinity,maxHeight: .infinity)
            }

        }
    }

    enum Placement:String,CaseIterable{
        case automatic,principal,navigation
        case primaryAction,status,confirmationAction
        case cancellationAction,destructiveAction
        #if os(iOS)
        case navigationBarLeading,navigationBarTrailing,bottomBar
        #endif
    }

你的浏览器不支持本视频

> macOS 下不同 placement 的演示

**遗憾**

macOS 目前 bug 较多，ToolBarItem 对于 View 的解析还不完整，ToolBarContentBuilder 不支持逻辑判断。

# 我目前正在使用的 AI 服务

随着 ChatGPT 的火爆，生活中好像突然之间到处都充满了有关人工智能的话题。尽管对新技术、新事物已没有那么的狂热，同时对 AI
也持有谨慎的态度，但并不影响我将一些 AI 服务应用到自己的工作中，丰富自己的工具箱，提高工作效率。

## Github Copilot

Github Copilot 在推出时引起了轰动。当时便有人预言程序员这个行业即将灭亡。然而，从当前版本来看，Github Copilot
并没有逾越其副驾驶的身份，成为了不少开发者的好帮手，而不是竞争对手。

尽管 VSCode 对 [ Swift ](/zh/posts/swift-in-linux/) 的支持程度也不错，但对于习惯于使用 Xcode
的我来说，平时应用 Github Copilot 的时间并不多。不过随着 [ Copilot for Xcode
](https://github.com/intitni/CopilotForXcode) 项目的启动，这种情况发生了明显的改变。

> 有关 Copilot for Xcode 的安装与设置请阅读 [ 在 Xcode 使用 Copilot 幫忙寫程式
>
> > ](https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-
> > app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-xcode-%E4%BD%BF%E7%94%A8-copilot-%E5%B9%AB%E5%BF%99%E5%AF%AB%E7%A8%8B%E5%BC%8F-7e8761a206f4)

![copilot_demo_2023-04-10_09.19.47.2023-04-10
09_21_13](https://cdn.fatbobman.com/copilot_demo_2023-04-10_09.19.47.2023-04-10%2009_21_13.gif)

在多数情况下，我并不会完全照搬 Copilot 提供的代码，但是在创建一些常用的功能时，它确实提高了相当的效率。

尽管 Copilot for Xcode 中也集成了 OpenAI，不过我倒是更期待 Copilot X
的表现。在增加了更多交互能力的情况下，Copilot X 是否仍能恪守本分，成为开发者的好帮手。

## Notion AI

一两个月前，Notion 也提供了 AI 服务，并将其集成在文档的编辑流程中。

Notion 提供了一些预设的快捷指令，减少了使用者重复编写 Prompt 的时间。在 Notion 中，我最常使用的功能是：翻译、汇总、润色以及改变语气。

![notion_2023-04-10_09.48.19.2023-04-10
09_50_00](https://cdn.fatbobman.com/notion_2023-04-10_09.48.19.2023-04-10%2009_50_00.gif)

Notion AI 对中文的理解和处理已可以满足我的日常需求。例如，有时候会突然卡在某句话的表述上，感觉怎么说都不对劲，经过润色或改变口气，Notion
会帮我重整语序或切换成另一种表达方式，将我从困境中解放出来。

虽然用户可以像使用 ChatGPT 一样，让 Notion 回答其他类型的问题（ 例如让它编写代码 ），不过，在实际使用中，我通常会忽略掉这种能力，将
Notion AI 与其他（例如设置版式之类的）功能做相同对待。对我而言，这种使用方式更纯粹，更加符合使用习惯，更加能体现出 AI 在特定领域的助手定位。

相较于 ChatGPT，仅考虑文字处理方面，Notion AI 具备更好的响应效率，更低的使用价格，暂时也没有被服务提供方封禁的风险。

## Warp AI

作为一个终端应用程序，Warp 在这波人工智能浪潮中也适时地集成了 AI 服务，将其作为特色功能之一嵌入到使用流程中。

我会使用 `#` 切换到 AI 状态，让 Warp 帮我生成所需的终端命令（ 不限制使用次数 ）。

![warpAI_2023-04-10_09.41.44.2023-04-10
09_43_43](https://cdn.fatbobman.com/warpAI_2023-04-10_09.41.44.2023-04-10%2009_43_43.gif)

Warp 也提供了咨询不同种类问题的功能（ 点击右上角的 ⚡️），毕竟目前仍是免费服务，因此每天可提出的问题数量有一定的限制（ 100 条 ）。

![image-20230410120430903](https://cdn.fatbobman.com/image-20230410120430903.png)

与对待 Notion 的态度一样，我基本上只会在终端命令模式下询问与命令行有关的问题。清晰 AI 助手的定位，是我始终贯彻的宗旨。否则，太多的 AI
入口不仅没有提供效率，反而可能造成思维的过分发散，影响工作流程。

## MidJourney

相较于 Stable Diffusion，MidJourney 对于新手更加的友好，出图率更高。

我目前会在一些不是特别重要的项目中，直接使用它所生成的图片、图标以及其他资源。

> 下图中，我让 MidJoureny 生成了本文所需的 Twitter Card 图片

![MidJounery_demo.2023-04-10
10_45_07](https://cdn.fatbobman.com/MidJounery_demo.2023-04-10%2010_45_07.gif)

我曾尝试学习 Stable Diffusion，但是想要充分利用 SD 绝非易事。对于我这样不想在这此投入太多精力的人来说，MidJourney
就已经完全满足需求了。

即使 MidJourney 生成的图片再精美，由于受限于 prompt
的表达能力，在面对严肃的项目时，仍应与专业人士进行协作，这样才能获得更符合需求的结果。

对于设计从业人员来说，如果你只具备素材拼凑能力，那么 MidJourney、Stable Diffusion
这类服务确实可能会影响你的职业前途。但对于具备自己的美学理念和设计思路的设计师来说，这些服务只是众多工具中的一员，可以帮助你开拓思路、提高效率，但并非关键因素。

## ChatGPT

作为掀起此波 AI 话题浪潮的 ChatGPT，我对它的感受却是一分为二。

一方面，由于具备一定的语料投喂的能力，在进行交流时，有时确实会被它的表述所震撼；但另一方面，ChatGPT （ 或者其底层的 OpenAI API
），目前并不具备一个完整的产品特征，相较于上面的几种 AI 服务，它的定位并不清晰，会让我产生疑惑。

![openAI_2023-04-10_10.59.11.2023-04-10
11_00_52](https://cdn.fatbobman.com/openAI_2023-04-10_10.59.11.2023-04-10%2011_00_52.gif)

有时候，ChatGPT 的专业性会让你误以为它具备顾问的能力，但随后便会震惊于它的无厘头回答。作为产品，ChatGPT
目前并不合格，但作为技术展示，ChatGPT 确实让 OpenAI 站到了行业的顶端。

相信不久的将来，ChatGPT 将会越来越少地出现在普通用户面前，OpenAI（或其他 AI
底层服务商）将以基础服务商的形式，通过集成到其他产品中的方式，为用户提供有针对性的 AI 服务。

## 最后

> 本节，由 Notion 独立完成 😂，给出的命令是：为这篇文章添加一个结尾，要求体现出 AI 的未来，AI 的隐忧，以及让使用者无需过分担心 AI
> 会影响他们的就业

在未来，人工智能将会为人类创造更多的价值。AI 的快速发展，已经越来越多地融入到人们的生活中，为我们提供了更便捷、高效的服务。AI
的未来，我们可以期待它的进一步发展和应用，为我们的生活带来更多的便利和惊喜。

然而，我们也需要对 AI 的隐忧保持警惕。AI 的普及可能会导致一些职业的消失，这也是一些人对 AI 技术持谨慎态度的原因。但是，我们不用过分担心 AI
会影响我们的就业。人类社会的进步离不开技术的创新，AI
技术的发展只会带来更多的机遇和挑战。我们需要通过不断学习和提升自己的能力，适应时代的变化，从而在竞争中获得更多的优势。

因此，我们应该看到 AI 技术为我们带来的巨大价值，同时也要保持警惕，避免 AI
技术对我们的生活带来负面影响。在未来的道路上，让我们一起探索人工智能的更大潜力，为人类创造更美好的未来。

## 最后的最后

> 本节由人工（ 我 ）完成

对我来说，AI
不是洪水猛兽，也不是能够在短时间内改变人类文明的革命。我不会抗拒它，也不会过分推崇它。同大多新技术一样，数年后回过头来看，它们已彻底融入生活，人们会感叹由技术更新所带来的便利，同时也会唏嘘因变革所带来的时代阵痛。

# 移植五周年

这几天在医院对身体各方面进行了一次比较全面的检查，结果比较令人满意。一转眼，接受肾移植已经 5
周年了，写一篇博文，对这些年的身体以及治疗情况进行了一个汇总。

## 发病

在 30
岁左右进行体检时，已经发现肾功能指标不太理想，因此进行了有针对性的调整。但随着时间的推移和工作的繁忙，逐渐也放松了对健康的重视。尽管发病前几个月进行体检时，各方面的指标也还说得过去。但病来如山倒，对于肾脏疾病来说，后期恶化的速度是十分迅猛的。

当时手里有几个项目正在进行，资金的压力也比较大。尽管身体已经发出了明显的信号，但总想着再坚持一下，即使家人一再催促，我也始终没有进行必要的检查。直到几乎完全无法进食（吃任何东西都马上会吐）才不得已去了医院，确诊十分迅速，因为已经没有了讨论的必要。此时，肌酐在
2100+，血红蛋白 46，按照医生的话来说，能活着走到医院已经属于大惊喜了。

由于贫血严重，输了几次血，但血红蛋白并没有得到太大的改善。为了尽快进行较彻底的透析，在与医生商量后，尽管血红蛋白不足
60，还是强行进行了植入透析管的手术，开启了我的透析生涯。

## 透析

透析有两种形式：一种是血液透析（大多数人知道的透析方式），另一种是腹膜透析。血液透析通常在指定的血液透析中心（或医院）进行，每周三次，每次四个小时。腹膜透析则可以在家中进行，每天透析次数根据患者的身体情况而有所变化，通常为
2 到 5 次，每次透析液置换时间约为 20 分钟。

我选择了腹膜透析。相较于血液透析，腹膜透析的场地和时间更自由。另外，腹膜透析通常对残肾功能保护比较好，有利于日后的移植。腹膜透析也有两种方式，一种是手动，就是每天手工进行几次透析液的置换操作。另一种则是自动透析（APD），通常是每天临睡前将腹部的透析管连接到设备上。在患者睡眠的过程中，设备会进行多次的液体交换。早上醒来的时候便将腹透管与设备断开，白天与正常人一样可以自由行动。有这么多的优势，我自然会选择自动透析的方式。

理想很丰满，现实很残酷。透析后发现我的腹膜滲透能力不是太好。仅依赖夜间的透析机进行透析完全无法满足排出毒素和水分的需要。因此，在此基础上逐渐增加了白天的手动透析操作。到移植前，我白天需要进行
5 次手工操作，夜间进行 12 个小时的机器自动透析。已然创下了我所在地区的透析记录。

经过几个月的透析治疗，随着身体状况的逐步改善，家人便联系了移植医院，催促我进行移植手术。但是，处于某种考虑，当时我并没有太基于进行移植。在外人看来，透析是一种无趣、繁琐、束缚人的治疗方式，但对我来说，它是一种身心调理。在这几年的透析治疗中，我的心态发生了巨大的转变，变得更加平和从容。此外，透析还让我的生活变得十分有规律，为我日后的健康生活打下了基础。

## 移植

最终，在进行了四年的透析后，我选择进行肾移植。为了能够更好地应对这次手术，我在准备移植前已经进行了一年有针对性的锻炼。再加上之前有意无意地“错过”了几次移植的机会，在接到医院的电话时，我十分平静。内心很笃定手术会成功。

不过事情似乎没有想的那么顺利。手术当天还是出现了不理想的状况，本来只需要 4 到 6 个小时的手术进行了接近 10
个小时。而且在手术后的第五天，从很多指标上看，手术似乎出现了明显失败的迹象。最重要的是，医生怀疑移植肾出现了破碎的可能，于是又进行了一次手术。在第二次手术前，尽管从各方面的指标上来看问题不小，但我个人感觉异常良好，因此我是抱着十分轻松的心态接受第二次手术。事后从妻子的口中得知，当时医生已经让家人做最坏打算了。第二次手术进行的时间不比第一次少，而且同第一次一样，出现了十分严重的术后反应。经过
ICU 的洗礼，人没有太大的事情。好消息是，第二次手术确认了第一次手术没有太大的问题，移植肾也无大碍。

在突破了该医院移植的最长住院记录后，经过 35 天，我终于回到了家，进入了术后康复阶段。

## 康复

回到家后马上遇到了几个十分棘手的问题。

第一个是体能太差。这是因为在进行第二次手术后，创口部分又出现了一次比较严重的出血情况。为了加快速度，两个医生在加护病房中对创口进行了紧急处置。经过这次治疗，我被要求只能用一个姿势躺着。经过了
20 多天的卧床，虽然伤口问题不大了，但下肺萎缩严重。刚回到家一个月里，即使在静息的状态下，心率也在 100 以上。为了改善体能，我从手术后 2
个月便开始恢复体能锻炼，并将这个习惯一直保持至今，现在每天也会进行一到两个小时的健身。

第二个症状是神经震颤，这是药物他克莫司所具备的副作用，强度因人而异，而我显然是反应比较大的那个。当时手已经很难拿住筷子了，情况与帕金森症很类似。为了改善这种情况，我尝试每天写毛笔字，不是为了练字，主要是提高自己的控制力。随着药量的减少、身体对药物的逐步适应，在手术一年后，这个症状得到了明显的改善。目前除了做一些很精细的操作外，基本上看不出有什么异常。

第三点是脑子出现了问题。大量的麻醉以及短期内高剂量的激素治疗让我的思维出现了明显的窒塞。在手术后的三到四个月中，我几乎无法通过短信发出一段没有错误的文字，基本上是脑子知道想要什么，但表述总是有问题。好在自己对这种情况有清晰的认识，努力尝试通过阅读、思考、交流、学习来改善这种状况。学习
Swift、SwiftUI、Core Data 也是在这个背景下自己主动采用的一种治疗措施，想了解这段时间的情况，可以阅读 [ 老人新兵 —— 一款 iOS
APP 的开发手记 ](/zh/posts/healthnote_development_log_2020/) 一文。

应该说，几年的透析生活给了我相当大的帮助。在移植手术后的这几年，我保持了相当健康的生活方式和乐观的心态。经过数年的调养，身体的指标也越来越好。

这是我每个月经常性检查的一些指标，通过这些指标可以看出，我的肾功指标在移植后逐年好转直至正常。大多数移植患者的指标在移植后很短的时间（几天到几周）都会恢复正常，然后随着时间的推移逐渐再出现问题。而我至少到目前来看，指标还处于上升通道中。希望能够继续保持下去。

![image-20230530142243400](https://cdn.fatbobman.com/image-20230530142243400.png)

> 只有经过长时间的积累，才能看出数据的价值。使用“ [ 健康笔记 ](https://apps.apple.com/app/id1534513553)
> ”App，我不仅对自己的身体指标有了清晰的认识，而且这些数据给我和医生提供了重要的参考指标，让我能有针对性地调整身体。如果你或你的家人、朋友需要长期跟踪健康数据，可以尝试使用该应用程序。请注意，该应用程序最初是为我自己编写的，对新手不够友好，但功能非常实用。

## 未来

尽管这些年，身体出现了或多或少的问题，不过我还是非常幸运的。遇到了善良的器官捐赠者，有最爱我的家人，总能转危为安的运气、一直碰到不错的医护，以及获得了很多朋友的支持。

明年我就到了知天命的年龄，希望能以平和的心态继续积极、健康地生活下去，做一些自己想做并且对社会有意义的事情。

祝大家身体健康。

# SwiftUI 与 Core Data —— 数据定义

在上文中，我列举了一些在 SwiftUI 中使用 Core Data 所遇到的困惑及期许。在今后的文章中我们将尝试用新的思路来创建一个 SwiftUI +
Core Data 的 app，看看能否避免并改善之前的一些问题。本文将首先探讨如何定义数据。

## 从 Todo 开始

Todo 是我为这个系列文章准备的一个演示应用。我尽量让这个功能简单的 app 能够触及较多的 SwiftUI + Core Data
的开发场景。使用者可以在 Todo 中创建将要完成的工作（ Task ），并可以通过 Task Group 以实现更好地管理。

> 可以在 [ 此处 ](https://github.com/fatbobman/Todo) 获得 Todo
> 的代码。代码仍在更新中，可能会出现与文章中不完全一致的情况。

![Todo_demo_iPhone_14_Pro_2022-11-28_10.29.20.2022-11-28
10_35_07](https://cdn.fatbobman.com/Todo_demo_iPhone_14_Pro_2022-11-28_10.29.20.2022-11-28%2010_35_07.gif)

Todo 的代码有如下特点：

- 采用模块化开发方式，数据定义、视图、DB 实现均处于各自的模块中
- 除了用于串联的视图外，所有的细节视图均实现了与应用的数据流解耦。无需更改代码便可以适应不同的框架（ 纯 SwiftUI 驱动、TCA 或其他的 Redux 框架 ）
- 所有的视图均可以实现在不使用任何 Core Data 代码的情况下进行预览，并可对 Mock 数据进行动态响应

![image-20221128114700448](https://cdn.fatbobman.com/image-20221128114700448.png)

## 先有鸡还是先有蛋

Core Data 通过托管对象的方式来呈现数据（ 定义的工作是在数据模型编辑器中进行的
）。如此一来，开发者可以用自己熟悉的方式来操作数据而无需了解持久化数据的具体结构和组织方式。遗憾的是，托管对象对于以值类型为主的 SwiftUI
来说并不算友好，因此，不少开发者都会在视图中将托管对象实例转换成一个结构体实例以方便接下来的操作（ [ 如何在 Xcode 下预览含有 Core Data
元素的 SwiftUI 视图 ](/zh/posts/coredatainpreview/#%E4%B8%BA-
swiftui-%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B-core-data-%E6%95%B0%E6%8D%AE) ）。

因此，在传统的 Core Data 应用开发方式中，开发者为了创建上图中 Group Cell 视图，通常需要进行如下的步骤（ 以 Todo 应用中的
Task Group 举例 ）：

![image-20221128130041823](https://cdn.fatbobman.com/image-20221128130041823.png)

- 在 Xcode 的数据模型编辑器中创建实体 `C_Group` （ 包括与之有关系的其他实体 `C_Task` ）

![image-20221128124420013](https://cdn.fatbobman.com/image-20221128124420013.png)

- 如有必要可以通过更改托管对象 `C_Group` 代码（ 或添加计算属性 ）的方式改善托管对象的类型兼容度
- 定义方便在 SwiftUI 环境中使用的结构，并为托管对象创建扩展方法以实现转换

  struct TodoGroup {
  var title: String
  var taskCount: Int // 当前 Group 中包含的 Task 数量
  }

  extension C_Group {
  func convertToGroup() -> TodoGroup {
  .init(title: title ?? "", taskCount: tasks?.count ?? 0)
  }
  }

- 创建 GroupCell 视图

  struct GroupCellView:View {
  @ObservedObject var group:C_Group
  var body: some View {
  let group = group.convertToGroup()
  HStack {
  Text(group.title)
  Text("\(group.taskCount)")
  }
  }
  }

根据上述流程，即使我们不进行最初的建模工作，仅依靠结构体 TodoGroup 已经完全可以满足进行视图开发的需要。如此一来，流程顺序将改变为：

- 定义 TodoGroup 结构体
- 构建视图

此时视图可以简化为：

    struct GroupCellView:View {
        let group: TodoGroup
        var body: some View {
            HStack {
                Text(group.title)
                Text("\(group.taskCount)")
            }
        }
    }

在开发的过程中，我们可以根据需要随时调整 TodoGroup ，而无需过分考虑如何在 Core Data 以及数据库中组织数据（ 仍需要开发者有一定的
Core Data 编程基础，避免创建完全不切实际的数据格式 ）。在最后阶段（ 视图及其他逻辑处理都完成后 ）才进行 Core Data
数据的建模以及转换工作。

这一看似简单的转换 —— 从鸡（ 托管对象 ）到蛋（ 结构体 ）转换至从鸡（ 结构体 ）到蛋（ 托管对象 ），将完全颠覆我们之前习惯的开发流程。

## 托管对象的其他优势

在视图中用结构体直接表示数据固然方便，但我们仍不能忽略托管对象的其他优势。对于 SwiftUI 来说，托管对象具备两个非常显著的特点：

- 懒加载

托管对象的所谓托管是指：该对象被托管上下文所创建并持有。仅在需要的时候，才从数据库（ 或行缓存 ）中加载所需的数据。配合 SwiftUI 的懒加载容器（
List、LazyStack、LazyGrid ），可以完美地在性能与资源占用间取得平衡

- 实时响应变化

托管对象（ NSManagedObject ）符合 ObservableObject 协议，当数据发生变化时，可以通知视图进行刷新

因此无论如何，我们都应该在视图中保留托管对象的上述优点，如此，上面的代码将会演变成下面的模样：

    struct GroupCellViewRoot:View {
        @ObservedObject var group:C_Group
        var body:some View {
            let group = group.convertToGroup()
            GroupCellView(group:group)
        }
    }

很遗憾，好像一切又回到了原点。

为了保留 Core Data 的优势，我们不得不在视图中引入托管对象，引入了托管对象就不得不先建模，再转换。

是否可以创建一种既可保留托管对象优势同时又不用在代码中显式引入特定托管对象的方式呢？

## 面向协议编程

面向协议编程是贯穿 Swift 语言的基本思想，也是其主要特点之一。通过让不同的类型遵守相同的协议，开发者便可以从具体的类型中解放出来。

### BaseValueProtocol

回到 TodoGroup 这个类型。这个类型除了用于为 SwiftUI 的视图提供数据外，同时也会被用于为其他的数据流提供有效信息，例如，在类 Redux
框架中，通过 Action 为 Reducer 提供所需数据。因此，我们可以为所有的类似数据创建一个统一的协议 —— BaseValueProtocol。

    public protocol BaseValueProtocol: Equatable, Identifiable, Sendable {}

越来越多的类 Redux 框架要求 Action 符合 Equatable 协议，因此作为可能作为某个 Action
的关联参数的类型，也必须遵循该协议。同时考虑到未来 Reducer 有被移出主线程的趋势，让数据符合 Sendable
也能避免出现多线程方面的问题。由于每个结构体实例势必需要对应一个托管对象实例，让结构体类型符合 Identifiable 也能更好地为两者之间创建联系。

现在我们首先让 TodoGroup 来遵守这个协议：

    struct TodoGroup: BaseValueProtocol {
        var id: NSManagedObjectID // 一个可以联系两种之间的纽带，目前暂时用 NSManagedObjectID 代替
        var title: String
        var taskCount: Int
    }

在上面的实现中，我们用 NSManagedObjectID 作为 TodoGroup 的 id 类型，但由于 NSManagedObjectID
同样需要在托管环境中才能创建，因此在下文中，它将会被其他的自定义类型所取代。

### ConvertibleValueObservableObject

无论是首先定义数据模型还是首先定义结构体，最终我们都需要为托管对象提供转换至对应结构体的方法，因此我们可以认为所有能够转换成指定结构体（ 符合
BaseValueProtocol ）的托管对象应该都可以遵循下面的协议：

    public protocol ConvertibleValueObservableObject<Value>: ObservableObject, Identifiable {
        associatedtype Value: BaseValueProtocol
        func convertToValueType() -> Value
    }

例如：

    extension C_Group: ConvertibleValueObservableObject {
        public func convertToValueType() -> TodoGroup {
            .init(
                id: objectID, // 相互间对应的标识
                title: title ?? "",
                taskCount: tasks?.count ?? 0
            )
        }
    }

### 两者间的纽带 —— WrappedID

由于 NSManagedObjectID 的存在，上面的两个协议仍无法脱离托管环境（ 并非指 Core Data 框架
）。因此我们需要创建一种可以在托管环境和非托管环境中均能运行的中间类型用作两者的标识。

    public enum WrappedID: Equatable, Identifiable, Sendable, Hashable {
        case string(String)
        case integer(Int)
        case uuid(UUID)
        case objectID(NSManagedObjectID)

        public var id: Self {
            self
        }
    }

同样出于该类型可能被用于 Action 的关联参数以及作为 ForEach 中视图的显式标识，我们需要让该类型符合
Equatable、Identifiable、Sendable,、Hashable 这些协议。

由于 WrappedID 需要符合 Sendable ，因此上面的代码在编译时将出现如下警告（ NSManagedObjectID 不符合 Sendable
）：

![image-20221128142739129](https://cdn.fatbobman.com/image-20221128142739129.png)

庆幸的是，NSManagedObjectID 是线程安全的，可以被标注为 Sendable（ [ 这点已经在 Ask Apple 10
月的问答中得到了官方的确认 ](/zh/posts/core-data-of-ask-
apple-2022/#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-@unchecked-
sendable-%E6%A0%87%E6%B3%A8-nsmanagedobjectid) ）。添加如下代码即可消除上面的警告：

    extension NSManagedObjectID: @unchecked Sendable {}

让我们对之前的 BaseValueProtocol 和 ConvertibleValueObservableObject 进行调整：

    public protocol BaseValueProtocol: Equatable, Identifiable, Sendable {
        var id: WrappedID { get }
    }

    public protocol ConvertibleValueObservableObject<Value>: ObservableObject, Identifiable where ID == WrappedID {
        associatedtype Value: BaseValueProtocol
        func convertToValueType() -> Value
    }

截至目前我们创建了两个协议和一个新类型 ——
BaseValueProtocol、ConvertibleValueObservableObject、WrappedID
，不过好像看不出它们有什么具体的作用。

### 为 Mock 数据准备的协议 —— TestableConvertibleValueObservableObject

还记得我们最初的宗旨吗？在不创建 Core Data 模型的情况下，完成绝大多数的视图和逻辑代码。因此，我们必须能够让 GroupCellViewRoot
视图接受一种仅从结构体（ TodoGroup
）即可创建的与托管对象行为类似的通用类型。TestableConvertibleValueObservableObject 便是完成这一目标的基石：

    @dynamicMemberLookup
    public protocol TestableConvertibleValueObservableObject<WrappedValue>: ConvertibleValueObservableObject {
        associatedtype WrappedValue where WrappedValue: BaseValueProtocol
        var _wrappedValue: WrappedValue { get set }
        init(_ wrappedValue: WrappedValue)
        subscript<Value>(dynamicMember keyPath: WritableKeyPath<WrappedValue, Value>) -> Value { get set }
    }

    public extension TestableConvertibleValueObservableObject where ObjectWillChangePublisher == ObservableObjectPublisher {
        subscript<Value>(dynamicMember keyPath: WritableKeyPath<WrappedValue, Value>) -> Value {
            get {
                _wrappedValue[keyPath: keyPath]
            }
            set {
                self.objectWillChange.send()
                _wrappedValue[keyPath: keyPath] = newValue
            }
        }

        func update(_ wrappedValue: WrappedValue) {
            self.objectWillChange.send()
            _wrappedValue = wrappedValue
        }

        static func == (lhs: Self, rhs: Self) -> Bool {
            lhs._wrappedValue == rhs._wrappedValue
        }

        func convertToValueType() -> WrappedValue {
            _wrappedValue
        }

        var id: WrappedValue.ID {
            _wrappedValue.id
        }
    }

让我们定义一个 Mock 数据类型来检验成果：

    public final class MockGroup: TestableConvertibleValueObservableObject {
        public var _wrappedValue: TodoGroup
        public required init(_ wrappedValue: TodoGroup) {
            self._wrappedValue = wrappedValue
        }
    }

现在，在 SwiftUI 的视图中，MockGroup 将具备与 C_Group 几乎一样的能力，唯一不同的是，它是通过一个 TodoGroup
实例构建的。

    let group1 = TodoGroup(id: .string("Group1"), title: "Group1", taskCount: 5)
    let mockGroup = MockGroup(group1)

由于 WrappedID 的存在，mockGroup 可以在没有托管环境的情况下使用。

### AnyConvertibleValueObservableObject

考虑到 @ObservedObject 只能接受具体类型的数据（ 无法使用 any ConvertibleValueObservableObject
），因此我们需要创建一个类型擦除容器，让 C_Group 和 MockGroup 都能在 GroupCellViewRoot 视图中使用。

    public class AnyConvertibleValueObservableObject<Value>: ObservableObject, Identifiable where Value: BaseValueProtocol {
        public var _object: any ConvertibleValueObservableObject<Value>
        public var id: WrappedID {
            _object.id
        }

        public var wrappedValue: Value {
            _object.convertToValueType()
        }

        init(object: some ConvertibleValueObservableObject<Value>) {
            self._object = object
        }

        public var objectWillChange: ObjectWillChangePublisher {
            _object.objectWillChange as! ObservableObjectPublisher
        }
    }

    public extension ConvertibleValueObservableObject {
        func eraseToAny() -> AnyConvertibleValueObservableObject<Value> {
            AnyConvertibleValueObservableObject(object: self)
        }
    }

现在对 GroupCellViewRoot 视图进行如下调整：

    struct GroupCellViewRoot:View {
        @ObservedObject var group:AnyConvertibleValueObservableObject<TodoGroup>
        var body:some View {
            let group = group.wrappedValue
            GroupCellView(group:group)
        }
    }

我们已经完成了第一个与托管环境解耦的视图链条。

## 创建预览

    let group1 = TodoGroup(id: .string("Group1"), title: "Group1", taskCount: 5)
    let mockGroup = MockGroup(group1)

    struct GroupCellViewRootPreview: PreviewProvider {
        static var previews: some View {
            GroupCellViewRoot(group: mockGroup.eraseToAny())
                .previewLayout(.sizeThatFits)
        }
    }

![image-20221128145609968](https://cdn.fatbobman.com/image-20221128145609968.png)

或许会有人觉得，用了如此多的代码，最终仅为实现可以接受 Mock 数据的预览十分不划算。如果仅为达成此目的，直接对 GroupCellView
视图进行预览就好了，为什么要如此大费周章？

如果没有 AnyConvertibleValueObservableObject ，开发者仅能对应用中的部分视图进行预览（ 在不创建托管环境的情况下
），而通过 AnyConvertibleValueObservableObject
，我们则可以实现将所有的视图代码均从托管环境中解放出来的愿望。通过结合之后介绍的与 Core Data 数据操作进行解耦的方法，无需编写任何 Core
Data 代码，就可以实现完成应用中所有视图和数据操作逻辑代码的目标。而且全程可预览，可交互，可测试。

## 回顾

不要被上面的代码所迷惑，使用本文介绍的方式后，重新梳理的开发流程如下：

- 定义 TodoGroup 结构体

  struct TodoGroup: BaseValueProtocol {
  var id: WrappedID
  var title: String
  var taskCount: Int // 当前 Group 中包含的 Task 数量
  }

- 创建 TodoGroupView（ 此时已无需 TodoGroupViewRoot ）

  struct TodoGroupView:View {
  @ObservedObject var group:AnyConvertibleValueObservableObject<TodoGroup>
  var body:some View {
  let group = group.wrappedValue
  HStack {
  Text(group.title)
  Text("\(group.taskCount)")
  }
  }
  }

- 定义 MockGroup 数据类型

  public final class MockGroup: TestableConvertibleValueObservableObject {
  public var _wrappedValue: TodoGroup
  public required init(_ wrappedValue: TodoGroup) {
  self.\_wrappedValue = wrappedValue
  }
  }

  let group1 = TodoGroup(id: .string("id1"), title: "Group1", taskCount: 5)
  let mockGroup = MockGroup(group1)

- 创建预览视图

  struct GroupCellViewPreview: PreviewProvider {
  static var previews: some View {
  GroupCellView(group: mockGroup.eraseToAny())
  }
  }

## 下文介绍

在下篇文章中，我们将介绍如何在视图从 Core Data 中获取数据的操作这一过程中实现与托管环境解耦，创建一个可以接受 Mock 数据的自定义
FetchRequest 类型。

# 如何处理 SwiftData 谓词中的可选值

由于 SwiftData 更改了数据模型的创建机制，而且谓词创建也采用了基于模型代码的类型安全模式。因此，当开发者在为 SwiftData
构建谓词时会遇到大量的处理可选值的操作。本文将探讨在构建谓词时，处理可选值的一些技巧和注意事项。

## 从 “由里至表” 到 “由表及里” 的变革

在 SwiftData 的众多创新中，最引人注目的莫过于允许开发者通过纯代码直接声明数据模型。在 Core Data 中，开发者需要先在 Xcode
的数据模型编辑器里创建数据模型（对应 NSManagedObjectModel），然后才是编写或自动生成 NSManagedObject 子类代码。

这一过程本质上是从模型（“里”）到类型代码（“表”）的转换。开发者能在一定程度上调整类型代码，例如将 `Optional` 改为 `Non-
Optional` 或将 `NSSet` 改为 `Set` ，从而优化开发体验，只要这些修改不影响 Core Data 在代码与模型之间的映射。

SwiftData 的纯代码声明方式彻底改变了这一流程。在 SwiftData 中，类型代码和数据模型的声明是同步进行的，或者更准确地说，SwiftData
会根据开发者声明的类型代码自动生成相应的数据模型。声明方式由传统的“由里至表”转变为了“由表及里”。

## 可选值与 Predicate

在为 Core Data 创建谓词的操作中，谓词表达式与类型代码并无直接联系。谓词表达式中对应的是模型编辑器内定义的属性（ 数据模型
），而这些属性的“可选值”特性并不对应 Swift 语言中的可选类型概念，而是指 SQLite 字段是否可以为 `NULL`
。这意味着，当谓词表达式中出现了可为 NULL 的属性和一个非 NULL 值时，通常不需要考虑其可选性。

    public class Note: NSManagedObject {
        @NSManaged public var name: String?
    }

    let predicate = NSPredicate(format: "name BEGINSWITH %@", "fat")

然而，SwiftData 的出现改变了这一情况。由于 SwiftData 谓词的构建基于模型代码，其中的可选类型真正体现了 Swift
的可选值概念，这就要求我们在构建谓词时必须特别注意可选值的处理。

考虑以下 SwiftData 的代码实例，如果不适当处理可选值，将会导致编译错误：

    @Model
    final class Note {
      var name: String?
      init(name: String?) {
        self.name = name
      }
    }

    let predicate1 = #Predicate<Note> { note in
      note.name.starts(with: "fat")  // error
    }
    // Value of optional type 'String?' must be unwrapped to refer to member 'starts' of wrapped base type 'String'

    let predicate2 = #Predicate<Note> { note in
      note.name?.starts(with: "fat")  // error
    }
    // Cannot convert value of type 'Bool?' to closure result type 'Bool'

因此，在为 SwiftData 构建谓词时，正确处理可选值成为一个重要的考虑因素。

## 正确处理 SwiftData 中的可选值

SwiftData 的谓词构建虽与编写返回布尔值的闭包相似，但开发者仅可以在其中使用 [ 官方文档
](https://developer.apple.com/documentation/foundation/predicate)
中列出的操作符和方法，这些操作都将通过宏转换成相应的 `PredicateExpressions` 。对于上文中的可选类型的 `name`
属性，开发者可以采用以下方法进行处理：

### 方法 1：使用可选链和空合并运算符

通过结合可选链（ `?.` ）和空合并运算符（ `??` ），可以在属性为 `nil` 时提供一个默认的布尔值。

    let predicate1 = #Predicate<Note> {
      $0.name?.starts(with: "fat") ?? false
    }

### 方法 2：使用条件绑定

利用条件绑定（ `if let` ），可以在属性非空时执行特定逻辑，否则返回 `false` 。

    let predicate2 = #Predicate<Note> {
      if let name = $0.name {
        return name.starts(with: "fat")
      } else {
        return false
      }
    }

注意，在谓词的 body 中只能包含单一表达式。因此，尝试在 `if` 之外再返回一个值，将无法构建有效的谓词：

    let predicate2 = #Predicate<Note> {
      if let name = $0.name {
        return name.starts(with: "fat")
      }
      return false
    }

这里的限制指的是， `if else` 结构和 `if` 结构，都各自被视为一个单一的表达式，它们都有直接对应的 `PredicateExpressions` ，而在一个 `if` 结构之外的额外返回则对应两个不同的表达式。

尽管谓词闭包中只能包含一个表达式，通过嵌套使用仍可以构建复杂的查询逻辑。

### 方法 3：使用 `flatMap` 方法

`flatMap` 方法能够处理可选值，并在非 `nil` 时应用给定的闭包，其结果仍然可以使用空合并运算符提供默认值。

    let predicate3 = #Predicate<Note> {
      $0.name.flatMap { $0.starts(with: "fat") } ?? false
    }

> 以上提供了几种安全且有效的策略，以确保在 SwiftData 谓词构建中正确处理可选值，从而避免编译时或运行时错误，确保数据查询的准确性和稳定性。

### 错误的做法：使用强制解包

尽管开发者可能确信某属性非空，使用 `!` 进行强制解包在 SwiftData 谓词中仍可能导致运行时错误。

    let predicate = #Predicate<Note> {
      $0.name!.starts(with: "fat") // error
    }

    // Runtime Error: SwiftData.SwiftDataError._Error.unsupportedPredicate

### 不可处理的可选值

当前（截止 Xcode 15C500b），当数据模型包含对多关系且为可选时，上述方法均不起作用。例如：

    let predicate = #Predicate<Memo>{
          $0.assets?.isEmpty == true
    }

    // or

    let predicate = #Predicate<Memo>{ $0.assets == nil }

SwiftData 在将谓词转换成 SQL 指令后，都会出现运行时错误：

    error: SQLCore dispatchRequest: exception handling request: <NSSQLCountRequestContext: 0x6000038dc620> , to-many key not allowed here with userInfo of (null)

## 特殊情形下的可选值处理

在 SwiftData 中构建谓词时，尽管常规情况下需要采用特定方法来处理可选值，但存在一些特殊情况，其中的处理规则略有不同。

### 直接等值比较

当仅需对可选值进行等值（ `==` ）比较操作时，SwiftData
允许直接比较，无需额外处理可选性。这意味着即便属性是可选类型，也可以直接进行比较，如下所示：

    let predicate = #Predicate<Note> {
      $0.name == "root"
    }

同样，这一规则也适用于对象之间的可选关系属性比较。例如，在 `Item` 与 `Note` 构成的一对一可选关系中，可以直接进行比较（ 即使 `name` 也是可选类型 ）：

    let predicate = #Predicate<Item> {
      $0.note?.name == "root"
    }

### 可选链的特例

虽然当可选链中只包含一个 `?` 时，在等值比较中无需特别处理，但当涉及到包含多个 `?` 的情况时，尽管代码在编译、运行期间不报错，但
SwiftData 无法通过该谓词从数据库中检索出正确的结果。

考虑下面的场景，其中 `Item` 和 `Note` 之间存在一对一的可选关系， `Note` 与 `Parent`
之间也是一对一的可选关系：

    let predicate = #Predicate<Item> {
      $0.note?.parent?.persistentModelID == rootNoteID
    }

要解决这个问题，需要确保可选链中只包含一个 `?` 。这可以通过将部分可选链解包来实现，例如：

    let predicate = #Predicate<Item> {
      if let note = $0.note {
        return note.parent?.persistentModelID == rootNoteID
      } else {
        return false
      }
    }

或者：

    let predicate = #Predicate<Item> {
      if let note = $0.note, let parent = note.parent {
        return parent.persistentModelID == rootNoteID
      } else {
        return false
      }
    }

## 总结

在本文中，我们探讨了如何在 SwiftData 中正确处理谓词构建过程中的可选值问题。通过介绍不同的方法，包括使用可选链和空合并运算符、条件绑定、以及 `flatMap` 方法，我们提供了有效处理可选性的策略。同时，我们也指出了直接等值比较可选值时的特殊情况，以及在可选链中包含多个 `?`
时需要采取的特别处理措施。这些技巧和注意事项旨在帮助开发者避免常见的陷阱，确保能够构建出准确且高效的数据查询谓词，从而充分利用 SwiftData
的强大功能。

# 如何对 iOS 应用中的文本进行本地化

当我们使用一个英文 app 时，很多人第一时间会去查看是否有对应的中文版本。可见，在 app 中显示让使用者最亲切的语言文本是何等的重要。对于相当数量的
app 来说，如果能够将 UI 中显示的文本进行了本地化转换，基本上就完成了 app 的本地化工作。本文中，我们将探讨 iOS
开发中，如何实现显示文本的本地化工作。本文的 [ Demo
](https://github.com/fatbobman/LocalizationDemoForBlogPost) 采用 SwiftUI 编写。

## 文本本地化的原理

作为一个程序员，如果让你考虑设计一套逻辑对原始文本针对不同语言的进行本地化转换，我想大多数人都会考虑使用字典（键值对）的解决方案。苹果也是采取了同样的处理，通过创建针对不同语言的多个字典，系统可以轻松的查找出一个原始文本（键）对应的本地化文本（值）。比如：

    //en
    "hello" = "Hello";





    //zh
    "hello" = "你好";

这套方法就是本文中主要采取的针对文本的本地化手段。

系统在编译代码的时候，将 `可以进行本地化操作的文本` 进行了标记，当 app
运行在不同的语言环境（比如法文）时，系统会尝试尽量从法语的文本键值对文件中查找出对应的内容进行替换，如果找不到则会按照语言偏好列表的顺序继续查找。对于某些类型比如
`LocalizedStringKey` 上述动作时会自动完成，但是像代码中最常使用的 `String` ，则需要在代码中显式完成上述动作。

幸运的是，SwiftUI 的绝大多数控件（部分目前有 Bug）对于文本类型都会优先采用使用 `LocalizedStringKey`
的构造方法，这极大的减轻了开发者的手工处理工作量。

## 添加语言

对于当代的编程语言和开发环境来说，国际化开发能力都已是必备功能。当我们在 Xcode 中创建一个项目后，缺省情况下，该 app 仅针对其对应的
Development Language 进行开发。

因此我们必须首先让项目知道，我们将对项目进行本地化的操作、并选择对应的语言。

在 `Project Navigation` 中，点击 `PROJECT` ，选择 `Info` 可以在 `Localizations`
中进行语言的添加。

![image-20210624074810238](https://cdn.fatbobman.com/image-20210624074810238-4492091.png)

点击 + 号，选择我们将要增加的语言。

![image-20210623192036104](https://cdn.fatbobman.com/image-20210623192036104-4447237.png)

![image-20210623192106625](https://cdn.fatbobman.com/image-20210623192106625-4447268.png)

在这里我们只是告诉项目，我们将可能对列表中的语言进行本地化操作。但如何本地化、对哪些文件、资源进行本地化，我们还需要对其单独设置。

> 启用 Use Base Internationalization，Xcode 会修改你的项目文件夹结构。xib 和 storeyboard
> 文件将被移动到 Base. lproj 文件夹，而字符串元素将被提取到项目区域设置文件夹。该选项针对使用 storyboard 的开发方式，如果你采用
> SwiftUI 则无需关心。

_对于 UIKit 框架，Xcode 会让你选择`storyboard` 的关联方式，由于本文使用的 [ Demo 项目
](https://github.com/fatbobman/LocalizationDemoForBlogPost) 为全 SwiftUI 架构，因此
**不会** 有如下的画面。 _

![image-20210623200804552](https://cdn.fatbobman.com/image-20210623200804552-4450086.png)

## 创建文本字符串文件

在苹果的开发环境中，对应我们上文中提到的 `字符串文件` （文本键值对文件）的文件类型为 `.strings` 。我们可以在一个 app
中创建多个字符串文件，有些名字的字符串文件是有其特殊含义的。

- Localizable. strings

UI 默认对应的字符串文件。在不特别指明字符串文件名称的情况下，app 都将从 Localizable. strings 中获取对应的本地化文本内容

- InfoPlist. strings

对应 Info. plist 的字符串文件。通常用于 app 名称、权限警告提示等内容的本地化。

在 `Project Navigation` 中，我们选择新建文件

![image-20210624074918275](https://cdn.fatbobman.com/image-20210624074918275-4492159.png)

文件类型选择 `Strings File` ，将其命名为 Localizable. strings

![image-20210623202900471](https://cdn.fatbobman.com/image-20210623202900471-4451341.png)

![image-20210624075200921](https://cdn.fatbobman.com/image-20210624075200921-4492322.png)

此时的 `Localizable.strings` 文件并没有被本地化，当前你的项目中只有一个文件，在该文件中进行文本键值对的定义，仅会针对项目的 `开发语言` ，通过右侧的 `Localize...` 按钮，我们可以选择生成 `Localizable.strings`
对应的语言（语言列表为项目中添加语言设定的列表）文件。

![image-20210624075240203](https://cdn.fatbobman.com/image-20210624075240203-4492361.png)

将右侧的两个语言都勾选上后

![image-20210623203721043](https://cdn.fatbobman.com/image-20210623203721043-4451842.png)

左侧 `Project Navigation` 中的 Localizable. strins 将变成如下状态：

![image-20210623203836721](https://cdn.fatbobman.com/image-20210623203836721-4451918.png)

`English` 和 `Chinese` 目前是空文件状态，我们现在就可以在此创建对应的文本键值对了。

> 可以在此处下载 [ Demo ](https://github.com/fatbobman/LocalizationDemoForBlogPost)
> 项目

### 实战 1：汉化账单表格列名

![image-20210623204627826](https://cdn.fatbobman.com/image-20210623204627826-4452393.png)

本节我们尝试为 ITEM、QUANTITY、UNIT PRICE 和 AMOUNT 提供对应的中文本地化文本。

按照上面的键值对声明规则，我们在 `Localizable.Strings(Chinses)` 文件中添加如下内容：

    "ITEM" = "种类";
    "QUANTITY" = "数量";
    "UNIT PRICE" = "单价";
    "AMOUNT" = "合计";

打开 `TableView` ，在预览中添加本地化环境配置

     TableView()
                .environmentObject(Order.sampleOrder)
                .previewLayout(.sizeThatFits)
                .environment(\.locale,Locale(identifier: "zh"))

此时我们从 Preview 的区域会看到什么变化？ **什么都没有变！**

原因是，我们在 `字符串文件` 中设定的 `键` 是有问题的。我们在 app 呈现中看到的 `ITEM` 在 `TableView`
中对应的代码如下：

     HStack{
                Text("Item")
                    .frame(maxWidth:.infinity)
                Text("Quantity")
                    .frame(maxWidth:.infinity)
                Text("Unit Price")
                    .frame(maxWidth:.infinity)
                Text("Amount")
                    .frame(maxWidth:.infinity)
            }
            .foregroundStyle(.primary)
            .textCase(.uppercase) //转换成大写

`Text` 中会将 `Item` 用作查找的 Key，但是我们定义是 `ITEM` ，因此没有找到对应的值。注意：字符串文件中的 `键`
是 `大写小敏感` 的。

将 `chinese` 文件修改如下：

    "Item" = "种类";
    "Quantity" = "数量";
    "Unit Price" = "单价";
    "Amount" = "合计";

此时预览窗口中，我们可以看到汉化后的结果：

![image-20210623210332114](https://cdn.fatbobman.com/image-20210623210332114-4453413.png)

恭喜你，到这里你已经掌握了文本本地化的大部分内容。

_不知道大家注意没有，目前的`English` 文件是空的， `Chinese`
文件我们也只对四个内容设置了对应的本地化文本。所有我们没有设置的内容，app 都将显示我们在代码中设置的原始文本。 _

> 在字符串文件中进行定义时，很容易出现两个错误，1：错误的输入了中文标点，2: 忘记了后面的分号。

### 实战 2：汉化付款按钮

![image-20210623212059142](https://cdn.fatbobman.com/image-20210623212059142-4454460.png)

本节我们尝试将 `Pay for 4 drinks` 中的文字进行中文化。

该按钮在 `ButtonGroupView` 中的定义如下：

     Button {
          showPayResult.toggle()
        } label: {
          Text("Pay for \(order.totalQuantity) drinks")
        }

`Pay for \(order.totalQuantity) drinks` 该如何在 `Localizable.strings`
文件中设置对应的 `键` 呢？

对于这种使用了字符串插值的 `LocalizedString` ，我们需要使用 `字符串格式说明符` ，苹果的 [ 官方文档
](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/formatSpecifiers.html#//apple_ref/doc/uid/TP40004265)
为我们提供了详细的对照用法说明。

代码中， `order.totalQuantity` 对应的是 `Int` （Swift 在 64 位系统上 `Int` 对应的为 `Int64` ），因此我们需要在键值对中使用 `%lld` 来将其进行替换。在 `Chinese` 文件中做如下定义：

    "Pay for %lld drinks" = "为%lld 杯饮品付款";

![image-20210623213451585](https://cdn.fatbobman.com/image-20210623213451585-4455292.png)

这样我们就得到了想要的结果。当你尝试添加或减少饮料数量时，文本中的数量都会跟随变化。

> 请为你的插值选择正确对应的格式说明符，比如上面的例子如果设置为%d 的话将被系统认为是另一个键而无法完成转换。

### 实战 3：汉化 App 的程序名

在 Xcode 项目中，我们通常会在 `Info.plist` 文件中对一些特定的系统参数进行配置，比如说 `Bundle identifier`
、 `Bundle name` 等。如果需要对其中的一些配置进行本地化处理的话，我们可以使用上文中提到的 `InfoPlist.strings`

使用创建 `Localizable.strings` 文件同样的步骤，我们创建一个名为 `InfoPlist.strings`
的字符串文件（不要忘记为创建好的文件进行本地化操作，确认中文、英文都已被勾选）。

分别在 InfoPlist. strings 的 `Chinese` 和 `English` 文件中加入如下内容：

    //chinese
    "CFBundleDisplayName" = "肥嘟嘟酒吧";
    //english
    "CFBundleDisplayName" = "FatbobBar";

此时，再在模拟器或者真机上安装 app，app 的名称将会在不同的语言下显示对应的文字。

> 在最近两个版本的 Xcode 中，可以不直接设置 Info. plist，通常在 Target 的 Info 中查看或修改值

![image-20210624075411064](https://cdn.fatbobman.com/image-20210624075411064-4492452.png)

> 我们需要本地化的配置无需一定要出现在 info 或 Info. plist 中，只要我们在 InfoPlist. strings
> 中对其进行了本地化键值对设定，app 将会优先采用该设定。通常我们会在 InfoPlist. strings 中进行本地化的除了 app 的名称 `CFBundleDisplayName` 外，还有 `CFBundleName` 、 `CFBundleShortVersionString`
> 、 `NSHumanReadableCopyright` 以及各种系统权限的申请描述，比如 `NSAppleMusicUsageDescription` 、 `NSCameraUsageDescription` 等。更多关于 info.
> plist 参数的内容请查看 [ 官方文档
> ](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009248-SW1)

### 实战 4：本地化饮品名称

在 `Localizable(Chinese)` 字符串文件中添加如下内容

    "Orange Juice" = "橙汁";
    "Tea" = "茶";
    "Coffee" = "咖啡";
    "Coke" = "快乐水";
    "Sprite" = "透心凉";

_关于饮料的定义请查看`Model/Drink.swift` 代码 _

> 通过设置本地环境变量查看预览，或者将模拟器语言改成中文，亦或者在 Scheme 中将 App Lanuguage 改成中文。

执行 app，我们并没有获得预期的效果。饮品的名称并 **没有变成中文** 。此时通过查看 `Drink.swift`
我们可以找出原因：对于已经明确了的 `String` 类型，Text 是不会将其视作 `LocalizedStringKey` 的。

之前在 `ItemRowView` 中，我们通过如下代码显示饮品名称：

    Text(item.drink.name)
              .padding(.leading,20)
              .frame(maxWidth:.infinity,alignment: .leading)

而饮品的名称在 `Drink` 中的定义如下

    struct Drink:Identifiable,Hashable,Comparable{
        let id = UUID()
        let name:String //String 类型
        let price:Double
        let calories:Double

因此最简单的办法就是修改 `ItemRowView` 的代码

    Text(LocalizedStringKey(item.drink.name))
             .padding(.leading,20)
             .frame(maxWidth:.infinity,alignment: .leading)

> 在某些情况下，我们只能获得 `String` 类型数据，可能会经常做类似的转换

再次运行，你将可以看到表格中的饮品名称已经更改为正确的中文显示

![image-20210624090150062](https://cdn.fatbobman.com/image-20210624090150062-4496510.png)

同样对 `ItemListView` 中的代码进行修改：

    //将
    Button(drink.name)
    //改成
    Button(LocalizedStringKey(drink.name))

饮品添加列表的显示也正常了：

![image-20210624103137706](https://cdn.fatbobman.com/image-20210624103137706-4501898.png)

修改后的代码可以正常的显示饮料名称的中文了。

> 上面的方法在绝大多数的情况下都是很好的解决问题的手段，但并不适合完全依赖 `Export Localizations...`
> 生成用于本地化键值对的项目。

为了能够更精确的对本地化后的文本进行排序，我们也可以对 `Drink` 的比较函数做近一步修改：

    //将
    lhs.name < rhs.name
    //改为
    NSLocalizedString(lhs.name,comment: "") < NSLocalizedString(rhs.name,comment: "")

> `NSLocalizedString` 可以通过给定的文本 `键` 获取对应后的文本 `值`

将 `InfoView` 中的

    var list:String {
            order.list.map(\.drink.name).joined(separator: " ")
    }

改为：

    order.list.map{NSLocalizedString($0.drink.name, comment: "")}.joined(separator: " ")

![image-20210624104828379](https://cdn.fatbobman.com/image-20210624104828379-4502909.png)

> **我们难道不能直接当`Drink` 的 `name` 定义为 `LocalizedStringKey` 类型吗？ **
>
> 由于 `LocalizedStringKey` 不支持 `Identifiable` , `Hashable` , `Comparable` 协议，同时官方也没有提供任何 `LocalizedStringKey` 转换成 `String` 的方法。因此，如果我们想将 `name` 定义成 `LocalizedStringKey` 类型需要使用一些特殊手段（需通过 Mirror，本文就不展开介绍了）。

### 为本地化占位符添加位置索引

在声明本地化字符串时，相同类型的占位符在不同的语言中可能会出现语序不一样的情况。例如下面的日期和地点：

    // 英文
    Go to the hospital on May 3
    // 中文
    五月三日去医院

可以通过为占位符添加位置索引的方式，方便在不同语言版本的 Localizable. strings 文件中调整语序。例如：

    // Localizable.strings - en
    "GO %1$@ ON %2$@" = "Go to %1$@ on %2$@";
    "HOSPITAL" = "the hospital";

    // Localizable.strings - zh
    "GO %1$@ ON %2$@" = "%2$@去%1$@";
    "HOSPITAL" = "医院";

暂时我们只能通过 `String.localizedStringWithFormat` 方法按照位置索引顺序添加插值内容：

    var string:String{
        let formatString = NSLocalizedString("GO %1$@ ON %2$@", comment: "")
        let location = String(localized: "HOSPITAL", comment: "")
        return String.localizedStringWithFormat(
            formatString,
            location,
            Date.now.formatted(.dateTime.month().day())
        )
    }

    Text(string)

> 此种方式无法在预览中通过修改环境值实时查看变化（ 在模拟器或实机中均可正确可以 ）

## 创建字符串字典文件

一些在中文里并不会存在的困扰，在其他一些语言中却是不小的问题。比较典型的如 `复数` 。如果你的 app
只有英文版并且只需应对较少名词时，或许可以将复数规则写死在代码里面。比如：

    if cups <= 1 {
      cupstring = "cup"
    }
    else {
      cupstring == "cups"
    }

但这一方面不利于代码的维护，另一方面对于某些具有复杂复数规则的语言（比如俄语，阿拉伯语等）灵活性就太差了。

为了解决如何定义不同语言的复数规则，苹果在 `.strings` 之外又提供了另一种解决方案 `.stringdict` 字符串字典文件。

它是一个带有 `.stringsdict` 文件扩展名的属性列表文件，对它的操作和编辑其他的属性列表完全一样（比如 Info. plist）。

`.stringsdict`
最初是为了解决复数问题而提出的，不过这几年又陆续增加了针对不同的数值显示不同的文本（通常用于屏幕尺寸的变化），以及针对特定平台（iphone、ipad、mac、tvos）显示对应的文本等功能。

![image-20210624135629220](https://cdn.fatbobman.com/image-20210624135629220-4514191.png)

_上图中，我们分别制定了使用`NSStringLocalizedFormatKey` 的复数规则、 `NSStringVariableWidthRuleType` 可变宽度规则以及 `NSStringDeviceSpecificRuleType`
特定设备内容规则 _

`.stringdict` 的根节点为 `Strings Dictionary` ，我们的规则都需要建立在它之下。我们需要为每个规则首先建立一个 `Dictionary` 。上图中，三条规则分别对应的 `键` 为 `device %lld` 、 `GDP` 、 `book %lld
cups` 。程序在碰到满足这三个 `键` 定义的文本内容时，将使用其对应的规则来生成正确的本地化内容。

所以尽管看起来和 `.strings` 略有不同，但实际上内在的逻辑是一致的。

- 我们可以在其中制定任意数量的规则。
- 默认对应的字符串字典文件名为 `Localizable.stringsdict` 。
- `.stringdict` 的执行优先级高于 `.strings` ，比如我们在两个文件中都对 `GDP` 做了定义，则只会使用 `.stringdict` 对应的内容

### 制定复数规则

![编组@3x](https://cdn.fatbobman.com/%E7%BC%96%E7%BB%84@3x-4517241.png)

- 数量类别的含义取决于语言，并非所有语言都有相同的类别。

例如，英语只使用 `one` 和 `other` 类别来表示复数形式。阿拉伯语对 `zero` 、 `one` 、 `two` 、 `few` 、 `many` 、 `other` 类别有不同的复数形式。虽然俄语也使用 `many` 类别，但数字 `many`
类别中的规则与阿拉伯语规则不同。

- 除 `other` 外，所有类别都是可选的。

但是，如果您不为所有特定语言类别提供规则，您的文本在语法上可能不正确。相反，如果您为语言不使用的类别提供规则，则会忽略它并使用 `other`
格式字符串。

- 在 `zero` 、 `one` 、 `two` 、 `few` 、 `many` 、 `other` 格式字符串中使用 `NSStringFormatValueTypeKey` 格式说明符是可选的。比如上面的定义当数字为 1 时，返回的是 one cup，不需要必须包含对应的%lld

> 如何在各个语言中定义复数规则请查看 [ UNICODE 官方文档 ](https://unicode-org.github.io/cldr-
> staging/charts/latest/supplemental/language_plural_rules.html)

### 可变宽规则

![nsstringvariablewidthruletype_pic@3x](https://cdn.fatbobman.com/nsstringvariablewidthruletype_pic@3x-4517922.png)

同复数和设备规则不同，系统不会自动适配返回值，需要用户在定义本地化文本时显式的进行标注，比如：

    let gdp = (NSLocalizedString("GDP",comment: "") as NSString).variantFittingPresentationWidth(25)
    Text(gdp) //返回 GDP(Billon Dollor)
    let gdp = (NSLocalizedString("GDP",comment: "") as NSString).variantFittingPresentationWidth(100)
    Text(gdp) //返回 GDP(anything you want to talk about)

没有完全相同的数字时，将返回最接近的内容。

它的使用场景，我感觉并非不可替代。毕竟在代码上的参与量多了些。

### 特定设备规则

![nsstringdevicespecificruletype-
pic@3x](https://cdn.fatbobman.com/nsstringdevicespecificruletype-
pic@3x-4518788.png)

目前支持的设备类型有：appletv、apple watch、ipad、iphone、ipod、mac

使用者不需要在代码中进行介入，系统将根据使用者的硬件设备返回对应的内容

### 实战 5：重新设定付款按钮

使用复数规则完善付款按钮。

付款按钮的代码在 `ButtonView` 中：

    Button {
         showPayResult.toggle()
       } label: {
          Text("Pay for \(order.totalQuantity) drinks")
      }

我们需要对 `Pay for \(order.totalQuantity) drinks` 进行设置。

首先创建 `Localizable.stringsdict` 文件

![image-20210624152114132](https://cdn.fatbobman.com/image-20210624152114132-4519275.png)

![image-20210624152245613](https://cdn.fatbobman.com/image-20210624152245613-4519367.png)

对于英文来说，我们需要设置 zero、one、和 other 的情况。在 `English` 中进行如下设置：

![image-20210624152837921](https://cdn.fatbobman.com/image-20210624152837921-4519719.png)

中文，只需要设置 zero 和 other

![image-20210624153559265](https://cdn.fatbobman.com/image-20210624153559265-4520160.png)

调整订单数量，按钮将根据不同的语言、不同的订单数量返回对应的本地化文本

##

![stringdict_button](https://cdn.fatbobman.com/stringdict_button-4520139.png)

我们在实战 2 中曾经在 `Localizable.strings` 中为 `Pay for %lld drinks` 设置了键值对，但由于 `.stringdict` 的优先级更高，所以系统将优先使用 `NSStringPluralRuleType` 规则。

### 实战 6：戳我还是点我

根据不同的设备，在添加饮料的按钮上显示不同的内容。

比如，我们可以在 iphone、ipad 上显示 `tap` 、在 appletv 上显示 `select` 、在 mac 上显示 `click`

在 `Chinese` 中添加

![image-20210624154950158](https://cdn.fatbobman.com/image-20210624154950158-4520992.png)

在 `English` 中添加

![image-20210624155049064](https://cdn.fatbobman.com/image-20210624155049064-4521050.png)

![local_text_finish](https://cdn.fatbobman.com/local_text_finish-4521583-4521584.png)

## Formatter 格式化输出

仅对显示标签进行本地化是远远不够的。在应用中，还有大量的数字、日期、货币、度量单位、人名等等方面内容都有本地化的需求。

苹果投入了巨大的资源，为开发者提供了一个完整的解决方案——Formatter。

在今年（2021），苹果对 Formatter 做了进一步的升级，不仅提高了 Swift 下的调用便利性，而且推出了适合 Swift 下使用的
FormatStyle 协议。

> Formatter 涉及的内容非常多，单独编写一篇文章都未必介绍完全。下文中将通过 Demo 中的几个例子让大家有个基本的了解。

### 实战 7: 日期、货币、百分比

#### 日期

![image-20210926143214864](https://cdn.fatbobman.com/image-20210926143214864-2637936.png)

    Text(order.date,style: .date) //显示年月日
    Text(order.date.formatted(.dateTime.weekday())) //显示星期

在 Demo 中我们通过了两种方式来本地化日期的显示。

- Text 本身支持日期的格式化输出，不过这种方式可定制性不高。

- 使用了新的 FormatStyle 来链式定义输出内容：

`order.date.formatted(.dateTime.weekday())` 将只显示星期几

#### 货币

![image-20210926145606972](https://cdn.fatbobman.com/image-20210926145606972-2639368.png)

- 创建 NumberFormatter

        private func currencyFormatter() -> NumberFormatter {
            let formatter = NumberFormatter()
            formatter.numberStyle = .currency
            formatter.maximumFractionDigits = 2
            if locale.identifier != "zh_CN" {
                formatter.locale = Locale(identifier: "en-us")
            }
            return formatter
        }

Demo 中仅提供两种货币的价格，当系统的的区域的设置不是中国大陆的话，则将货币设置为美元。

- 在 Text 中应用 Formatter

  Text(NSNumber(value: item.amount),formatter:currencyFormatter() )

由于在 Text 中，Formatter 仅能用于 NSObject，因此需要将 Double 转换成 NSNumber。

目前 FormatStyle 提供的 Currency 可配置项太少，暂不采用。

#### 百分比

![image-20210926150144189](https://cdn.fatbobman.com/image-20210926150144189.png)

     Text(order.tax.formatted(.percent))

直接使用 formatStyle。

### 实战 8: 度量单位、序列

#### 卡路里

使用 MeasureMent 定义能量单位。一个测量对象 (MeasureMent object)
代表一个数量和测量单位。测量类型提供了一个编程接口，用于将测量值转换为不同的单位，以及计算两个测量值之间的和或差。

![image-20210926150326836](https://cdn.fatbobman.com/image-20210926150326836.png)

    init(name: String, price: Double, calories: Double) {
            self.name = String.localizedStringWithFormat(NSLocalizedString(name, comment: name))
            self.price = price
            self.calories = Measurement<UnitEnergy>(value:calories,unit: .calories) //设置时将原始数据设为 calorie
        }

测量对象同样可以进行数据计算：

        var totalCalories:Measurement<UnitEnergy>{
            items.keys.map{ drink in
                drink.calories * Double(items[drink] ?? 0)
            }.reduce(Measurement<UnitEnergy>(value: 0, unit: .calories), +)
        }

创建描述 MeasureMent 的 Formatter

        var measureFormatter:MeasurementFormatter{
            let formatter = MeasurementFormatter()
            formatter.unitStyle = .medium
            return formatter
        }

在 SwiftUI 中显示

    Text(order.totalCalories,formatter: measureFormatter)

#### 序列

![image-20210926151111505](https://cdn.fatbobman.com/image-20210926151111505.png)

![image-20210926151203232](https://cdn.fatbobman.com/image-20210926151203232.png)

创建符合不同语言习惯的连字方式（标点、和或等）。

        var list:String {
            order.list.map{NSLocalizedString($0.drink.name, comment: "")}.formatted(.list(type: .and))
        }

## 其他

### 使用 tabname 指定特定名称字符串文件

可以创建多个字符串文件，当该文件名不是 Localizabl 时，我们需要指明文件名称，比如 `Other.strings`

    Text("Item",tableName: "Other")

`tableName` 同样适用于 `.stringdict`

### 指定其他 Bundle 中的字符串文件

如果你的 app 中使用了包含多语言资源的其他 Bundle 时，可以指定使用其他 Bundle 中的字符串文件

    import MultiLanguPackage // ML
    Text("some text",bundle:ML.self)

在包含多语言资源的 Package 中，可以使用以下代码指定 Bundle

    Text("some text",bundle:Self.self)

### markdown 符号支持

苹果在 WWDC 2021 上，宣布可以在 Text 中直接使用部分 markdown 符号。比如：

    Text("**Hello** *\(year)*")

我们同样可以在字符串文件中使用 markdown 符号

    "**Hello** *%lld*" = "**你好** *%lld*"；

另外，新增的 `AttributedString` 类型可以为文本带来更多的创造性。

## 总结

本文原为我针对 iOS 的本地化主题系列文章中的一篇，不过由于琐事较多，始终没有最终完成。

其他内容，例如：资源本地化、本地化调试、本地化预览、本地化文件编辑、Formatter 深入研究等，今后再一同探讨。

# 博客暂时停更通知

我的博客【肘子的 Swift 记事本】已经上线 2 年了。撰写博客的初衷是想通过文字来记录自己的学习的过程、加深理解并将所得分享给其他的朋友。

从去年下半年开始，博文发表频率逐渐形成了每周至少一篇的局面，文章内容也逐渐脱离了个人学习笔记的形式。

越是撰写新的内容，越能够发现自己的不足。作为一个编程爱好者，我深知自己的基础知识相当薄弱，又该进行系统性充电了。

同去年上半年停更的原因一样，我打算用一段完整的时间来充实自己，并将自己近来的学习所得通过实践的形式得以消化。

本次停更估计会持续 2——3 个月的时间，中间如果确有值得分享的内容我也可能会临时发表。

停更期间我仍然会通过博客评论、邮件、Twitter 等方式同大家进行沟通。

# 一段因 @State 注入机制所产生的“灵异代码”

本文将通过一段可复现的“灵异代码”，对 State 注入优化机制、模态视图（ Sheet、FullScreenCover ）内容的生成时机以及不同上下文（
相互独立的视图树 ）之间的数据协调等问题进行探讨。

> 可在 [ 此处 ](https://github.com/fatbobman/BlogCodes/tree/main/StateInject)
> 获取本文代码

## 问题

不久之前，网友 Momo 6 在 [ 聊天室 ](https://discord.gg/ApqXmy5pQJ) 中咨询了如下一个 [ 问题
](https://stackoverflow.com/questions/73110567/how-state-variables-in-swiftui-
are-modified-and-rendered-in-different-views) ：

![image-20230222145532644](https://cdn.fatbobman.com/image-20230222145532644.png)

在下面的代码中，如果注释掉 ContentView 中的 `Text("n = \(n)")` 代码，在按下按钮后（ n 设置为
2），fullScreenCover 视图中 Text 显示的 n 仍为 1（ 预期为 2）。如果不注释这行代码，fullScreenCover 中将显示
`n = 2` （ 符合预期 ）。这是为什么？

    struct ContentView: View {
        @State private var n = 1
        @State private var show = false

        var body: some View {
            VStack {
                // 如果注释掉下面这行 Text 代码
                // 在按下 Button ( n = 2 ) 后 , full-screen 中的 Text 仍显示 n = 1

                // Text("n = \(n)") // 解除注释，sheet 中的 Text 将显示 n = 2

                Button("Set n = 2") {
                    n = 2
                    show = true
                }
            }
            .fullScreenCover(isPresented: $show) {
                VStack {
                    Text("n = \(n)")
                    Button("Close") {
                        show = false
                        print("n in fullScreenCover is", n) // 无论是否注释掉上面的 Text ，此处均打印为 2
                    }
                }
            }
        }
    }

> 为了演示清晰，我将 fullScreenCover 换成了 sheet（ 改动不影响上面所描述的现象 ）, 并为 Button 添加了
> ButtonStyle。

![question_2023-02-22_15.12.26.2023-02-22
15_15_32](https://cdn.fatbobman.com/question_2023-02-22_15.12.26.2023-02-22%2015_15_32.gif)

**此处建议暂停几分钟，看看你是否能想出其中的问题所在？**

## 问题构成

尽管看起来有些奇怪，但 Text 的添加与否，确实将影响 Sheet 视图中的显示内容。而出现这种现象的原因则是由 State 注入的优化机制、
Sheet（ FullScreenCover ）视图的生命周期以及新建上下文等几方面共同造成的。

### State 注入的优化机制

在 SwiftUI 中，对于引用类型，开发者可以通过 @StateObject、@ObservedObject 或 @EnvironmentObject
将其注入到视图中。通过这些方式注入的依赖，无论视图的 body 中是否使用了该实例的属性，只要该实例的 `objectWillChange.send()` 方法被调用，与其关联的视图都将被强制刷新（ 重新计算 body 值 ）。

与之不同的是，针对值类型的主要注入手段 @State，SwiftUI 则为其实现了高度的优化机制（ EnvironmentValue
没有提供优化，行为与引用类型注入行为一致 ）。这意味着，即使我们在定义视图的结构体中声明了使用 @State 标注的变量，但只要 body
中没有使用该属性（ 通过 ViewBuilder 支持的语法 ），即使该属性发生变化，视图也不会刷新。

    struct StateTest: View {
        @State var n = 10
        var body: some View {
            VStack {
                let _ = print("update")
                Text("Hello")
                Button("n = n + 1") {
                    n += 1
                    print(n)
                }
            }
        }
    }

在下方的动图中，在 Text 中不包含 n 的情况下，即使 n 值改变，StateTest 视图的 body 也不会重新计算。当在 Text 中添加 n
的引用后，每次 n 值发生变化，都将引发视图更新。

![stateTest_2023-02-22_16.44.55.2023-02-22
16_47_35](https://cdn.fatbobman.com/stateTest_2023-02-22_16.44.55.2023-02-22%2016_47_35.gif)

通过观察加载后视图的 State 源数据，我们可以看到，State 包含一个 \_wasRead 私有属性，在其与任意视图关联后，该值为 true。

![stateDump_2023-02-22_16.54.19.2023-02-22
16_56_09](https://cdn.fatbobman.com/stateDump_2023-02-22_16.54.19.2023-02-22%2016_56_09.gif)

回到我们当前的“问题”代码：

    struct ContentView: View {
        @State private var n = 1
        @State private var show = false

        var body: some View {
            VStack {
                // Text("n = \(n)") // 注释掉该行后，sheet 中的 n 显示为 1（ 并非预期中的 2 ）
                Button("Set n = 2") {
                    n = 2
                    show = true
                }
                .buttonStyle(.bordered)
            }
            .sheet(isPresented: $show) {
                VStack {
                    Text("n = \(n)")
                    Button("Close") {
                        show = false
                        print("n in fullScreenCover is", n)
                    }
                    .buttonStyle(.bordered)
                }
            }

        }
    }

当我们在 ContentView 中添加了 Text 后，Button 中对 n 的修改将引发 body 重新求值，注释后则不引发求值。这也就造成了是否添加
Text（ 在 body 中引用 n ），会影响 body 能否再度求值。

### Sheet（ FullScreenCover ）视图的生命周期

或许有人会问，在 sheet 的代码中，Text 同样包含了对 n 的引用。这个引用难道不会让 n 与 ContentView 视图之间建立关联吗？

与大多数的 View Extension 和 ViewModifier 不同，在视图中，通过 `.sheet` 或 `.fullScreenCover` 来声明的模态视图内容代码的闭包，只会在显示模态视图的时候才会被调用、解析（ 对闭包中的 View 进行求值 ）。

而其它通过视图修饰器声明的代码块，则会在主视图 body 求值时进行一定的操作：

- overlay、background 等，会在 body 求值时调用、解析（ 因为要与主视图一并显示 ）
- alert、contextMenu 等则会在 body 求值时调用（ 可以理解为创建实例 ），但只有在需要显示时才进行求值

这就是说，即使我们在 Sheet 代码块的 Text 中添加了对 n 的引用，但只要模态视图尚未显示，则 n 的 \_wasRead 仍为 false（
并没有与视图创建关联 ）。

为了演示上面的论述，我们将 Sheet 中的代码用一个符合 View 协议的结构体包装起来，以方便我们观察。

    struct AnalyticsView: View {
        @State private var n = 1
        @State private var show = false

        var body: some View {
            let _ = print("Parent View update") // 主视图 body 求值
            VStack {
                // Text("n = \(n)") // 注释掉该行后，sheet 中的 n 显示为 1（ 并非预期中的 2 ）
                Button("Set n = 2") {
                    n = 2
                    show = true
                }
                .buttonStyle(.bordered)
            }
            .sheet(isPresented: $show) {
                SheetInitMonitorView(show: $show, n: n)
            }
        }
    }

    struct AnalyticsViewPreview: PreviewProvider {
        static var previews: some View {
            AnalyticsView()
        }
    }

    struct SheetInitMonitorView: View {
        @Binding var show: Bool
        let n: Int
        init(show: Binding<Bool>, n: Int) {
            self._show = show
            self.n = n
            print("sheet view init") // 创建实例（ 表示 sheet 的闭包被调用 ）
        }

        var body: some View {
            let _ = print("sheet view update") // sheet 视图求值
            VStack {
                Text("n = \(n)")
                Button("Close") {
                    show = false
                    print("n in fullScreenCover is", n)
                }
                .buttonStyle(.bordered)
            }
        }
    }

![SplitSheetView_2023-02-22_17.25.22.2023-02-22
17_26_04](https://cdn.fatbobman.com/SplitSheetView_2023-02-22_17.25.22.2023-02-22%2017_26_04.gif)

通过输出内容我们可以看出，在首次对 ContextView 进行求值时（ 打印 `Parent View update` ），Sheet 代码块中的
SheetInitMonitorView 没有任何输出（ 意味着闭包没有被调用 ），只有在模态视图进行显示时，SwiftUI 才执行 `.sheet`
闭包中的函数，创建 Sheet 视图。

回到最初的代码：

    .fullScreenCover(isPresented: $show) {
        VStack {
            Text("n = \(n)")
            Button("Close") {
                show = false
                print("n in fullScreenCover is", n) // 无论是否注释掉上面的 Text ，此处均打印为 2
            }
        }
    }

尽管我们通过 `.fullScreenCover` 在 Text 中引用了 n , 但由于该段代码并不会在 ContextView
求值时被调用，因此也不会让 n 与 ContextView 创建关联。

> 在 ContextView 不包含 Text 的情况下，在 Sheet 显示后，n 的 \_wasRead 将转变为 true（ Sheet
> 视图显示后，方创建关联 ）。可以通过在 Button 中添加如下代码进行查看：

    Button("Set n = 2") {
        n = 2
        show = true
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1){ // 延迟已保证 Sheet 中的视图已完成创建
            dump(_n)
        }
    }

### Sheet 视图的上下文

当 SwiftUI 创建并显示一个 Sheet 视图时，并非在现有的视图树上创建分支，而是新建一棵独立的视图树。也就是说 Sheet
中的视图与原有视图分别处于不同的上下文中。

> 在 SwiftUI 早期的版本中，对于分别位于不同上下文的独立的视图树，开发者需要显式为 Sheet
> 视图树注入环境依赖。后期版本已为开发者自动完成该注入工作。

这意味着，相较于在原有视图树上创建分支，在新上下文中重建视图树的开销更大，需要进行的工作也更多。

而 SwiftUI 为了优化效率，通常会对若干操作进行合并。即使为新上下文中的视图进行的关联操作是在视图求值操作之前完成的，但由于 n
的变化与关联操作被集中在一个 Render Loop 中，这样会导致在关联之后并不会强制新关联的视图刷新（ 关联后，值并没有发生变化 ）。

## 现象分析

根据上文中介绍的内容，我们对本文代码的奇怪现象进行一个完整的梳理：

### 当 ContextView 中不包含 Text（ ContextView 没有与 n 创建关联 ）

- 程序运行，SwiftUI 对 ContextView 的 body 进行求值并渲染

- `.fullScreenCover` 的闭包此时并未被调用，但捕获了视图当前的 n 值 （ n = 1 ）

- 点击 Button 后，尽管 n 的内容发生变化，但 ContextView 的 body 并未重新求值

- 由于 show 转变为 true ，SwiftUI 开始调用 `.fullScreenCover` 的闭包，创建 Sheet 视图

尽管 show 也是通过 State 声明的，但 show 的变化并不会导致 ContextView 重新更新。这是因为在 `.fullScreenCover` 的构造方法中，我们传递的是 show 的 projectedValue（ Binding 类型 ）

- 由于合并操作的原因，在 Sheet 视图关联到 n 后，并不会重新更新

- Sheet 中的 Text 显示 n = 1

- 点击 Sheet 中的 Close 按钮，执行 Button 闭包，重新获得 n 的当前值（ n = 2 ），打印值为 2

### 当 ContextView 中包含 Text （ ContextView 与 n 之间创建了关联 ）

- 程序运行，SwiftUI 对 ContextView 的 body 进行求值并渲染
- `.fullScreenCover` 的闭包此时并未被调用，但捕获了视图当前的 n 值 （ n = 1 ）
- 点击 Button 后，由于 n 值发生了变化，ContextView 重新求值（ 重新解析 DSL 代码 ）
- 在重新求值的过程中， `.fullScreenCover` 的闭包捕获了新的 n 值 （ n = 2 ）
- 创建 Sheet 视图并渲染
- 由于 `.fullScreenCover` 闭包已经毕竟捕获了新值，因此 Sheet 的 Text 显示为 n = 2

也就是说，通过添加 Text，让 ContextView 与 n 创建了关联，在 n 变化后，ContextView 进行了重新求值，从而让 `fullScreenCover` 的闭包捕获了变化后的 n 值，并呈现了预期中的结果。

## 解决方案

在了解了“异常”的原因后，解决并避免再次出现类似的奇怪现象已不是难事。

### 方案一、在 DSL 中进行关联，强制刷新

原代码中，通过添加 Text 为 ContextView 和 n 之间创建关联便是一个可以接受的解决方案。

另外，我们也可以通过无需增加额外显示内容的方式来创建关联：

    Button("Set n = 2") {
        n = 2
        show = true
    }
    .buttonStyle(.bordered)
    // .id(n)
    .onChange(of:n){_ in } // id 或 onChange 均可以在不添加显示内容的情况下，创建关联

> 在 [ 创建自适应高度的 Sheet 的推文
> ](https://twitter.com/fatbobman/status/1584715584507637760?s=61&t=KMscJ8nzk9sreOXno95FIA)
> 中，我便使用过 id 来解决重制 Sheet 高度的问题。

### 方案二、使用 @StateObject 强制刷新

我们可以通过创建引用类型的 Source 来避免在不同上下文之间关联 State 可能出现的顺序错误。事实上，使用 @StateObject 相当于在
vm. n 发生变化后，强制视图重新计算。

    struct Solution2: View {
        @StateObject var vm = VM()
        @State private var show = false

        var body: some View {
            VStack {
                Button("Set n = 2") {
                    vm.n = 2
                    show = true
                }
                .buttonStyle(.bordered)
            }
            .sheet(isPresented: $show) {
                VStack {
                    Text("n = \(vm.n)")
                    Button("Close") {
                        show = false
                        print("n in fullScreenCover is", vm.n)
                    }
                    .buttonStyle(.bordered)
                }
            }
        }
    }

    class VM: ObservableObject {
        @Published var n = 1
    }

### 方案三、使用 Binding 类型，重获新值

我们可以将 Binding 类型视作一个对某值的 get 和 set 方法的包装。Sheet 视图在求值时，将通过 Binding 的 get 方法，获得
n 的最新值。

> Binding 中 get 方法对应的是 ContextView 中 n 的原始地址，无需经过为 Sheet
> 重新注入的过程，因此在求值阶段便可以获得最新值

    struct Solution3: View {
        @State private var n = 1
        @State private var show = false

        var body: some View {
            VStack {
                Button("Set n = 2") {
                    n = 2
                    show = true
                }
                .buttonStyle(.bordered)
            }
            .sheet(isPresented: $show) {
                SheetView(show: $show, n: $n)
            }
        }
    }

    struct SheetView:View {
        @Binding var show:Bool
        @Binding var n:Int
        var body: some View {
            VStack {
                Text("n = \(n)")
                Button("Close") {
                    show = false
                    print("n in fullScreenCover is", n)
                }
                .buttonStyle(.bordered)
            }
        }
    }

### 方案四、延迟更新数据

通过延迟修改 n 值（ 在 Sheet 视图求值并关联数据后再修改 ），强迫 Sheet 视图重新求值

    struct Solution4: View {
        @State private var n = 1
        @State private var show = false

        var body: some View {
            VStack {
                Button("Set n = 2") {
                    // 极小的延迟便可以达到效果
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.01 ){
                        n = 2
                    }
                    show = true
                }
                .buttonStyle(.bordered)
            }
            .sheet(isPresented: $show) {
                VStack {
                    Text("n = \(n)")
                    Button("Close") {
                        show = false
                        print("n in fullScreenCover is", n)
                    }
                    .buttonStyle(.bordered)
                }
            }
        }
    }

## 总结

尽管已经发展到 4.0 版本，但 SwiftUI
仍会出现一些与预期不符的行为。在面对这些“灵异现象”时，如果我们能对其进行更多的研究，那么不仅可以在今后避免类似的问题，而且在分析的过程中，也能对
SwiftUI 的各种运行机制有深入的掌握。

# 健康笔记 2.0 开发随笔（一）

> 健康笔记从 2020 年 1 月上线以来，至今已经过了大半年的时间（可以从 [ 老人新兵 —— 一款 iOS app 的开发手记
> ](/zh/posts/healthnote_development_log_2020/) 了解健康笔记 app 的由来）。在这段时间里，我对于
> Swift、SwiftUI、CoreData 等都有了进一步的了解和认识。在开发 1.0 版本时所面对的问题和疑惑多数都得到了解决。

最近随着 iOS 14 发布的临近，同时也想将这短时间来学习的知识进行更系统的整理和应用，于是便将健康笔记 2.0 的开发工作提上了日程，并已经着手进行中。

## 健康笔记 2.0 的规化

- 功能

健康笔记 1.0 目前的功能已基本能够满足我个人的日常使用，在上线这段时间内，我也根据用户提出的建议增加了部分新功能。因此在 2.0 上，App
核心功能的增加并不是太多，主要集中在两点：

- 数据类型

  1.0 中当前支持两种数据类型，一种是数字型（仅记录一个数字 + 日期），另一个是选项型（自定义选项内容 + 日期），在 2.0 中，新增了其他 5
  中数据类型包括：双数字型、数字选项型、起始时间型等。使用者可以记录生活中更多种类的内容。

- 数据导入导出

  1.0 中已经提供了对于数字卡片、条目等内容的数据各自的导出支持（csv, pdf, xslx）, 2.0
  版中将提供同一的导出入口，并将提供导入功能。用户可以有更多段选择保管并使用自己的数据，比如将自己创建的卡片分享给其他用户，或者重新导入自己保存的离线数据等。

既然是一次大版本的更新，虽然在功能上的改变并非太多，但在其他地方的变化还是会很大的，更多的变化都会在后文中提到。

## 开发环境、框架

Xcode 12 + SwiftUI 2.0，主要的原因如下：

- 从 WWDC 20 以来我一直在跟踪并学习 iOS 14 下的新特性（我的最近的文章大多都有关于此），以及 SwiftU 2.0 中提供的新功能。在规划初始，我打算在 2.0 中使用不少的新功能来完成自己的构思。由于 iOS 14 对于硬件的支持完全涵盖的之前 iOS 13 的机型，相信对于 iOS 13 的用户来说，更新的阻力不会太大。

- 当前的用户数并不多，历史包袱较小。从上线来，目前健康笔记的总下载量才刚刚超过 1000，因此让我可以轻装上阵，有较大的调整空间。

- 1.0 版本中很多的规划、设计不完善。最近几个月，我已经很少向 1.0 版本中增加新的功能了，主要原因就是最开始的结构设计不合理、代码混乱。如果强行添加更多的功能，只会导致留下更多的隐患，反倒不利于今后的调整。所以在 2.0 中，决定将之前的数据结构设计进行了较大的改变，将 1.0 的代码全部推翻重写。

- 数据迁移的问题。由于 1.0 的数据结构设计不佳，我打算在 2.0 中进行大变化，这样会导致 CoreData 的数据迁移面临严峻的考验。在 1.0 版本的数据小升级中，我已经领教到了 CoreData 的迁移机制所带来的便利性和难以控制的双面问题。尽管可以通过编写自己的 CoreData 迁移代码来解决结构大变化时所面临的难题，不过为了不留下隐患、给将来的扩充留下更自由的空间，还是决定放弃了使用 CoreData 的迁移机制。

- 我本来就打算在 2.0 中进一步加强数据的导入导出，所以对于 1.0 版本的用户，我将提供安全的数据迁移能力，平滑的过度到 2.0 上。

结果就是：用户将重新在 app store 上下载健康笔记 2.0 app（不是在 1.0 上更新），2.0 将支持 iOS 14、macOS 11
及以上的系统。之前的健康笔记 1.0 用户数据都可以安全方便的手动转移到 2.0 版本上。

- 支持多平台

  2.0 将支持 iPhone, iPad 和 macOS。

SwiftUI 本身对于多平台的支持就非常出色，不过为了能够在不同的硬件平台下更好的发挥其各自的特点，我还是决定为支持多平台做更多针对性的调整。

    * iPhone 下仍同 1.0 一样强制竖屏使用。

    * iPad 下强制横屏使用，并采用了和 iPhone 下完全不同的布局。

    * macOS 下不使用 Catalyst，而使用原生的 macOS target 进行编写。虽然加大了工作量，但可以更好的适配桌面操作，尤其是提供同手指操作完全不同键鼠交互逻辑，并采用更适合桌面平台的布局和控件操作。

    * 我在最近编写的 Swift 库中，基本上都提供了跨平台的支持。

    * 由于决定了进行完全的跨平台开发（uikit+appkit），因此在选择第三方库的限制将会更多。

- 多语种

健康笔记的本身的文字量并不多，因此单纯从文本内容的角度来看，多语种支持并不复杂。不过由于涉及了不少的数据显示、日期计算等，在真正进行多语种支持的时候还是遇到了不少挑战。

在目前的开发版本中，已经可以让用户在 app 中单独设置语言、时区而不完全依赖系统设定。

目前仍没有想好的多语种支持问题主要存在于 Demo 数据的加载上。我希望能找到一个工作量较小、数据量较小的解决方案。

## 代码结构

健康笔记 2.0 将代码完全推翻重写，其中极为重要的一个原因是我想实现一个自己认可的能适用于 SwiftUI 的 MVVM 结构。

我在开发 1.0 版本的时候才接触到
MVVM，在最初的开发过程中，基本上是按照别人提供的代码逻辑来完成的。在实际的使用中一方面发现了很多自己不理解或用起来不顺手的地方，同时在不断的学习中，也发现了很多传统
MVVM 不完适应 SwiftUI 框架的问题。最近几个月，我一直在学习并研究适用于 SwfitUI 的 MVVM 结构，2.0
的开发中这些学习结果将得到充分的检验机会。

Xcode 12 中提供了 SwiftUI lifecycle，从程序入口点，到 App Delegate、Scene Delegate
响应都有了彻底地改变，如何设计一个更适合 Swfit 2.0
的状态机在不少论坛进行了讨论和分析。我目前在开发中采用的结构对这些都做了有针对性的调整。并且为多平台，多语种都提供不错的响应支持。同时为了便于使用
Preview，对于 CoreData 的声明和注入也做了针对性的调整。

之后，我会专门写一篇关于这方面的文章和大家一起研究谈探讨。

我将在开发过程中，不定时地更新随笔。一方面对自己的思路进行一个梳理，同时也希望能够给其他的个人开发者提供一点参考。

# Vapor4 的安装与配置

> 本文介绍了如何在 mac 10.5.4 和 ubuntu 18.04 下安装 Vapor 命令行工具，创建 Vapor
> 项目，简单的调试项目以及如何部署到生产环境的过程。文中的运行环境为：Vapor 4, Swift 5.2, Catalina 10.5.4,
> Ubuntu 18.04

最近新开通了一个云服务器（Linux 系统），使用 [ Hexo ](https://hexo.io/zh-cn/index.html/)
创建了新的博客网页。考虑增加点简单的交互功能，所以需要在服务器端添加逻辑处理能力。由于近半年来基本上都是在使用 Swift，所以打算尝试一下 Server
Side Swift。没有太仔细选择各种框架，看过几个介绍 Vapor 使用的视频后，感觉不错，便开始尝试安装配置。

Vapor
的官方文档实在是有很大的问题，网上的不少心得、教程又有点陈旧（目前版本调整较大）。通过两天的折腾，终于基本上理出了脉络，初步搭建了开发和生产环境。

## 什么是 Vapor

[ Vapor ](https://github.com/vapor/vapor) 是一个使用 Swift 语言编写的 Web
网络框架，它是跨平台的（mac、Linux），用户可以使用 Swift 语言以及其丰富的第三方库来高效的完成多种网络服务。

    import Vapor

    let app = try Application()
    let router = try app.make(Router.self)

    router.get("hello") { req in
        return "Hello, world."
    }

    try app.run()

上面的代码变可以完成一个最基本的网络服务。访问 `http://localhost:8080/hello` 网页返回 _hello, world._

你可以在 mac 或 Linux 平台上开发，同时也可以将通过 Vapor 框架开发的项目部署到 mac 或 Linux 平台上。

## 什么是 Vaper 命令行工具

Vaper 命令行工具的作用有：

- 基于模板创建 Vaper 项目
- 配置、编译、运行项目
- 其他配合操作系统的一些功能

但它不是必须的，如果用户已经很熟悉 Vapor
的开发和配置，无论是在开发环境还是运行环境都可以不使用这个命令行工具。不过对于像我这样的新手来说，无疑它是一个好的帮手。

### 开发 Vaper 项目需要的资源

- mac 或 Linux ，我目前在 Catalina 10.5.4 和 Ubuntu 18.04 下都成功完成了配置
- Swift 语言环境，目前 Vapor 4 可以在 Swift 5.2 下运行
- web 服务器，我目前使用 Nginx （如果只是用于开发测试，也可以不配置）

## 安装 Swift

### Mac

在 mac 平台下，安装 Xcode 及 Xcode ommand Line Tools，Vapor 4 对 xcode 提供了非常友好的支持，可以像其他的
Swift 项目一样使用全部的 Xcode 的各种能力（比如断点调试）。

#### Ubuntu 18.04

    sudo apt-get install clang
    sudo apt-get install libcurl3 libpython2.7 libpython2.7-dev

    #从 swift.org 找到需要的文件

    wget https://swift.org/builds/swift-5.2.3-release/ubuntu1804/swift-5.2.3-RELEASE/swift-5.2.3-RELEASE-ubuntu18.04.tar.gz

    tar xzvf swift-5.2.3-RELEASE-ubuntu18.04.tar.gz
    sudo mv swift-5.2.3-RELEASE-ubuntu18.04 /usr/share/swift

    echo "export PATH=/usr/share/swift/usr/bin:$PATH" >> ~/.bashrc
    source  ~/.bashrc

我也使用过 Docker 安装 Swift 5.2，不过 Image 有点太大，需要 1.2 Gb 左右的空间。

    #Docker 安装 Swift 的方法。
    docker pull swift

## 安装 Vapor 命令行工具

### MacOS

Shell

Copy code

Copied!

    brew tap vapor/tap
    brew install vapor
    #我目前安装的是 vapor-beta
    #brew install vapor-beta
    #执行 vapor 测试一下
    vapor

### Ubuntu 1804

Ubuntu 下安装 Vapor toolbox 略微麻烦，主要是目前的 Vapor Toolbox 源文件有点问题需要做一些修改才能正常编译。

首先保证已成功安装 **Swift**

    cd ~
    git clone https://github.com/vapor/toolbox.git
    cd toolbox

在 Test 目录下创建一个 **LinuxMain. swift** 文件

    import XCTest
    @testable import AppTests
    XCTMain([testCase(AppTests.allTests)])

_**这个是 Swift SPM 需要的文件，上面我只写了个最简单的能够完成编译即可，不清楚为什么官方的 git 源不包含这个文件。** _

修改 Source/VaporToolbox/exec. swift 文件

在 36 行左右（当前版本）找到

    let spawned = posix_spawnp(&pid, argv[0], &fileActions, nil, argv + [nil], envp + [nil])

修改成

    guard let _argv0 = argv[0] else {
                fatalError("unwrap error")
            }
    let spawned = posix_spawnp(&pid, _argv, &fileActions, nil, argv + [nil], envp + [nil])

_**同样不清楚为什么代码会有这么一个错误。** _

完成上述修改后

    cd ~/toolbox
    swift build -c release --disable-sandbox
    sudo mv .build/release/vapor /usr/local/bin

_以上步骤在我本地的 Ubuntu 上已可正常编译，不过在我的腾讯云主机上，编译时会缺少一个相关库，添加上后即可正常编译。_

    sudo apt-get install libcurl4 -y

至此 Vapor Toolbox 安装完毕。

_Toolbox 的目录中包含了 Dockerfile，使用它可以直接将 toolbox 生成一个 Docker Image，并且系统会自动下载 Swift
的 Docker Image。不过我在 Ubuntu 上使用这种方法安装后（已配置 entrypoint），vapor 的 Image 没有名字，只有
container id，但是可以通过 id 来运行。个人目前不推荐这种方式。_

## 使用 Vapor 命令行工具

### 创建项目

    #vapor new <projectname> [--template]
    vapor new hello

使用缺省模板创建一个名为 hello 的 Vapor 项目。

创建的过程其实就是从 github 上 clone 一个模板，并可帮你进行简单配置。如果已经比较熟悉的话也可以不适用工具，直接从 github 上 [
克隆模板 ](https://github.com/vapor?q=template&type=&language=) 开始项目。

在 Mac 系统下，模板可以直接编译运行，不过 Linux 下，git 源仍然缺少 **LinuxMain. swift**
文件，按照上面的方法，在项目中加入该文件后方可编译。

clone 完成后，系统会有如下提示：

    Would you like to use Fluent? y
    数据库类型选择 #我选择了 sqllite

系统会根据你的选择直接在模板中创建好相应的代码。（ [ Fluent ](https://github.com/vapor/fluent) 是一个
Swift 写的 ORM）

### 编译项目

    cd ~/hello
    vapor build

我在 ubuntu 下执行** vapor new **可以正常执行，不过** vapor build **执行报错。因此就直接使用**swift
build** 来编译项目。其实 ** build** 和 **run** 都是直接调用的 **swift** 命令。

### 运行项目

    vapor run
    #系统显示，说明项目已正常启动。可以通过 http://127.0.0.1:8080 访问
    Environment(name: "development", arguments: [".build/x86_64-apple-macosx/debug/Run"])
    [ NOTICE ] Server starting on http://127.0.0.1:8080

可以在运行命令后面添加运行状态，对于部署尤为重要。

    vapor run --env prod
    # test prod dev 对应不同的状态，主要关系到是否显示操作日志等

如果是 Mac 系统，使用

    vapor xcode

直接打开 Xcode，然后就可以直接在 Xcode 下编辑、编译、调试、运行。

即使没有安装 Vapor Toolbox 也可以使用如下命令创建 Xcode 项目

    swift package generate-xcodeproj

按照上述的步骤安装后，无论在 Mac 上还是 Ubuntu 上我们都可以开始编写并运行自己的 Vapor 项目了。

## 模板项目简单分析

本节我们通过对模板代码的简单分析来快速感受一下 Vapor 的便捷。

我使用的是项目缺省模板，启用 Fluent，数据库选择的是 sqlite。

项目源文件存在 Sources 目录下。

![目录结构](https://cdn.fatbobman.com/vapor4-struct.png)

`main.swift` 作为程序的入口，创建了 Vapor 服务

`configure.swift` 中由于我们选择了使用 sqlite，因此系统为我们自动生成了使用数据库所需的代码。下列代码完成数据库的创建工作。

    app.migrations.add(CreateTodo())

为了能够完整的运行这个模板项目，我们需要在命令行执行

    vapor run migrate

系统将在项目根目录下完成 db. sqlite 里的表创建工作。如果没有执行这个步骤，访问 localhost: 8080/todos
将在得到如下的错误提示。

    [ ERROR ] error: no such table: todos

**Xcode 的用户也可以直接在 Scheme 中的 Arguments 添加 —auto-migrate 完成上述功能。**

**另外，最好在 Xcode 中将 Scheme — Run — Working Directory
设置成当前项目的根目录，这样无论使用命令行，还是直接使用 Xcode 都可以使用同一个 Sqlite 文件。**

    //app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory))

如果取消这一句的注释，Vapor 将提供对静态文件的支持。我们可以把静态文件放入项目根目录的 Public 目录中，即可访问。
127.0.0.1:8080/index. html 。如果和其他 WebServer 配合使用的话，我感觉还是用如 Nginx
来提供静态文件的支持比较好。

routes. swift 作为项目的核心，在其中完成网络的路由逻辑设定。

    import Fluent
    import Vapor

    func routes(_ app: Application) throws {
        /*
        访问  127.0.0.1:8080/  返回：It works!
        */
        app.get { req in
            return "It works!"
        }

        //   localhost:8080/hello    返回："Hello world"
        app.get("hello") { req -> String in
            return "Hello, world!"
        }

        let todoController = TodoController()
        /*
        以下操作我使用 postman 进行测试
        post 127.0.0.1:8080/todos body 内容：{"title":"东坡肘子"}  添加一条记录
        get 127.0.0.1:8080/todos 显示已添加的记录
        del 127.0.0.1:8080/todos/B508471F-FF5F-422C-B384-C300FD7B49D9 删除一条记录。id 使用显示记录获取
        */
        app.get("todos", use: todoController.index)
        app.post("todos", use: todoController.create)
        app.delete("todos", ":todoID", use: todoController.delete)
    }

更具体的应用就不展开了。不过仅从模板例程上我们便可以感觉到 Vapor 的便利和高效。

## 和 Nginx 配合使用

通过编辑 nginx 的配置文件，我们的 Vapor 项目便可以对外发布了。

nginx

Copy code

Copied!

    server {
            listen       80;
            server_name  localhost;

            location / {
              root   html;
              index   index.html index.htm;
              try_files  $uri @proxy;
            }

            location @proxy {
                   proxy_pass http://127.0.0.1:8080;
                   proxy_pass_header Server;
                   proxy_set_header Host $host;
                   proxy_set_header X-Real-IP $remote_addr;
                   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                   proxy_pass_header Server;
                   proxy_connect_timeout 3s;
                   proxy_read_timeout 10s;
    }

现在你就可以通过 `http://你的域名或地址/todos` 来访问你的项目。

我使用 Vapor 的目的是为了配合自己的博客，所以仍需配合我自己原有的页面使用，所以采用了如下的配置。

即使打开了 Vapor 的静态页面支持，如果我把 Vapor 项目配置在/的话（已取消 Vapor 对根的响应），仍然需要明确的输入 `http://我的域名/index.html` 才能访问到索引页面。没有办法才把他转到 /api/下。

nginx

Copy code

Copied!

    server {
            listen       80;
            server_name  localhost;

            location / {
                root   html;
                index  index.html index.htm;
            }

            location /api {
              root   html;
              index   index.html index.htm;
              try_files  $uri @proxy;
            }

            location @proxy {
                   proxy_pass http://127.0.0.1:8080;
                   proxy_pass_header Server;
                   proxy_set_header Host $host;
                   proxy_set_header X-Real-IP $remote_addr;
                   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                   proxy_pass_header Server;
                   proxy_connect_timeout 3s;
                   proxy_read_timeout 10s;
    }

如此配置后，需要对代码 routes. swift 进行改动后即可正常访问。

    app.get("api","hello") { req -> String in
            return "Hello, world!"
        }

如果谁知道如何设置能够直接将/转发到 Vapor 而又可以直接使用 [ http://我的域名
](http://%E6%88%91%E7%9A%84%E5%9F%9F%E5%90%8D) 来访问原有的页面烦请告知一下。

## 部署

### 修改运行端口

Vapor 4 对于指定运行端口和之前有了较大的区别。

在 main. swift 中做如下修改

    app.http.server.configuration.hostname = "127.0.0.1" //响应的地址 0.0.0.0
    app.http.server.configuration.port = 8000 //希望设定的端口
    try configure(app)

目前我没有找到如何在命令行下设置运行端口（Vapor 3 之前的方法好像已经不支持了）。如果有人了解烦请告知一下。

### 手动部署

由于我目前也还刚刚开始接触 Vapor，为了调试方便，我在本机的 Xcode 下进行开发。通过 github 作为中转，将本地的修改 commit 到
repository 上。手动在服务器端 fetch 并执行。在终端中执行的话当前终端将被任务锁定。

### Docker 部署

另外，Vapor 的模板本身已经生成了 Dockerfile。也可以直接将完成后的项目生成 Docker Image。这种方式可以将项目发布到任何支持
Docker 的平台（mac、Linux、windows 等）。不过通常只适用于已经开发完善后的部署。更多细节可查阅 [ 官方文档
](https://docs.vapor.codes/4.0/deploy/docker/)

### Supervisior

Vapor Toolbox 已提供了对 [ Supervisior ](http://supervisord.org) 的支持，可以很方便的通过
supervisor 来管理服务。

ubuntu 下安装 Supervisor

    sudo apt-get update
    sudo apt-get install supervisor

我们需要为每一个项目创建一个 supervisor 配置文件。创建/etc/supervisor/conf. d/hello. conf

    [program:hello]
    command=/home/parallels/hello/.build/release/Run serve --env production
    directory=/home/parallels/hello
    user=parallels
    stdout_logfile=/var/log/supervisor/%(program_name)-stdout.log
    stderr_logfile=/var/log/supervisor/%(program_name)-stderr.log

文件名是你的项目名。conf，目录指向你项目的根目录并设置好用户名

    command=/home/parallels/hello/.build/release/Run serve --env production

需确定已将项目编译成 release 版本，如果 vapor build 不好用，可以使用如下命令

    cd ~/hello
    swift build -c release

通过 supervisor 管理项目

    supervisorctl reread
    supervisorctl add hello
    supervisorctl start hello

也可以通过 supervisor 的配置来指定运行端口

在/etc/supervisor/conf. d/hello. conf 中加入

    environment=PORT=8123

修改 main. swift

    let port = Environment.get("PORT") ?? ""
    app.http.server.configuration.port = Int(port) ?? 8080

## 结语

希望本文能够对你开始使用 Vapor 4 带来一点帮助。同时也希望 Swift 能在更多的平台上有所表现。

Swift 已有更多的官方对 window 支持的迹象。

# SwiftUI TextField 进阶 —— 格式与校验

SwiftUI 的 TextField 可能是开发者在应用程序中最常使用的文本录入组件了。作为 UITextField（NSTextField）的
SwiftUI 封装，苹果为开发者提供了众多的构造方法和修饰符以提高其使用的便利性、定制性。但 SwiftUI
在封装中也屏蔽了不少的高级接口和功能，增加了开发者实现某些特定需要的复杂性。本文为【SwiftUI 进阶】系列文章中的一篇，在本文中，我将介绍如何在
TextField 中实现如下功能：

- 屏蔽无效字符
- 判断录入的内容是否满足特定条件
- 对录入的文本实时格式化显示

![textfieldDemo1](https://cdn.fatbobman.com/textfieldDemo1-3998601.gif)

> 本文的目的并非提供一个通用的解决方案，而是通过探讨几种思路，让读者可以在面对类似需求时有迹可循。

## 为什么不自己封装新的实现

对于很多从 UIKit 转到 SwiftUI 的开发者，当遇到 SwiftUI 官方 API 功能无法满足某些需求的情况下，非常自然地会想通过
UIViewRepresentable 来封装自己的实现（参阅 [ 在 SwiftUI 中使用 UIKit 视图
](/zh/posts/uikitinswiftui/) 了解更多内容）。在 SwiftUI 早期，这确实是十分有效的手段。不过随着 SwiftUI
的逐渐成熟，苹果为 SwiftUI 的 API 提供了大量独有功能。如果仅为了某些需求而放弃使用官方的 SwiftUI 方案有些得不偿失。

因此，在最近几个月的时间里，我逐渐抛弃了通过自行封装或使用其他第三方扩展库来实现某些需求思路。在为 SwiftUI 增加新功能时，要求自己尽量遵守以下原则：

- 优先考虑能否在 SwiftUI 原生方法中找到解决手段
- 如确需采用非原生方法，尽量采用非破坏性的实现，新增功能不能以牺牲原有功能为代价（需兼容官方的 SwiftUI 修饰方法）

以上原则，在 [ SheetKit——SwiftUI 模态视图扩展库 ](/zh/posts/sheetkit/) 和 [ 用
NavigationViewKit 增强 SwiftUI 的导航视图 ](/zh/posts/navigationviewkit/) 中均有体现。

## 如何在 TextField 中实现格式化显示

### 现有格式化方法

在 SwiftUI 3.0 中，TextField 新增了使用新老两种 Formatter 的构造方法。开发可以直接使用非 String
类型的数据（如整数、浮点数、日期等），通过 Formatter 来格式化录入的内容。例如：

    struct FormatterDemo:View{
        @State var number = 100
        var body: some View{
            Form{
                TextField("inputNumber",value:$number,format: .number)
            }
        }
    }

![textFieldDemo2](https://cdn.fatbobman.com/textFieldDemo2.gif)

不过非常遗憾的是，尽管我们可以设置最终格式化的样式，但是 TextField 并不能在文字录入过程中对文本进行格式化显示。只有当触发 submit
状态（commit）或失去焦点时，才会对文本进行格式化。行为与我们的最初的需求有一定差距。

### 可能的格式化解决思路

- 在录入过程中激活 TextField 内置的 Formatter，让其能够在文本发生变化时对内容进行格式化
- 在文本发生变化时调用自己实现的 Format 方法，对内容进行实时格式化

对于第一种思路，目前我们可以采用一种非正常手段即可激活实时格式化——替换或取消掉当前的 TextFiled 的 delegate 对象。

                TextField("inputNumber",value:$number,format: .number)
                    .introspectTextField{ td in
                        td.delegate = nil
                    }

上面的代码通过 [ SwiftUI-Introspect ](https://github.com/siteline/SwiftUI-Introspect)
实现了对指定的 TextField 身后对应的 UITextField 的 delegate
替换，即可完成实时格式化的激活工作。本文的方案一便是这种思路的具体实现。

第二种思路，则是不使用黑魔法，仅通过 SwiftUI 的原生方式，在录入文本发生变化时，对文本进行格式化。本文的方案二是该思路的具体实现。

## 如何在 TextField 中屏蔽无效字符

### 现有屏蔽字符方法

在 SwiftUI 中，可以通过设置仅使用特定的键盘类型来实现一定程度上的录入限制。比如，下面的代码将仅允许用户录入数字：

    TextField("inputNumber",value:$number,format: .number)
        .keyboardType(.numberPad)

然而，上述方案还是有相当的局限性的。

- 只支持部分类型的设备
- 支持的键盘类型有限

例如在 iPad 下 keyboardType 是无效的，在苹果鼓励应用程序对多设备类型支持的今天，让用户在不同的设备上享受到相同的体验至关重要。

另外，由于其支持键盘类型有限，在很多的应用场合都捉襟见肘。最典型的例子就是 `numberPad` 是不支持 `负号`
的，意味着它仅能适用于正整数。有些开发者可以通过自定义键盘或添加 `inputAccessoryView`
来解决，但对于其他没有能力或精力的开发者来说，如果能直接对录入的无效字符进行屏蔽则也是不错的解决方案。

### 可能的屏蔽字符解决思路

- 使用 UITextFieldDelegate 的 `textField` 方法
- 在 SwiftUI 的视图中，使用 `onChange` 在录入发生变化时进行判断并修改

第一种思路，仍需使用 Introspect 之类的方式，对 TextField 身后的 UITextField 进行侵入，替换掉它原有的 `textField` 方法，在其中进行字符判断。实践中，这种方式是最高效的手段，因为该判断发生在字符被 UITextField
确认之前，如果我们发现新添加的 `string` 不满足我们的设定的录入要求，可以直接返回 false，则最近录入的字符将不会显示在录入框中。

    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
            // 检查 string 是否满足条件
            if 满足条件 { return true } // 将新增字符添加到输入框
            else { return false}
     }

但是通过 Delegate 的方法，我们并不能选择保留部分字符，也就是说要不全部接受、要不都不接受（如果自行包装
UITextField，我们可以实现任何逻辑）。方案一采用了本思路。

第二种思路我们是支持选择性保存的，但是其也有局限性。由于 TextField 的 Formatter 构造方法采用了特别的包装方式，我们无法获得绑定值不是
`String` 时（例如整数、浮点数、日期等）的录入框内容的。因此，采用这种思路，我们只能使用字符串作为绑定类型，将无法享受到 SwiftUI
新的构造方法带来的便捷性。方案二采用了该思路。

## 如何在 TextField 中检查内容是否符合指定条件

相较上述两个目标，在 SwiftUI 中检查 TextField 内容是否符合指定条件是相当方便的。例如：

    TextField("inputNumber", value: $number, format: .number)
                    .foregroundColor(number < 100 ? .red : .primary)

_上面的代码在录入的数字小于 100 时会将文字显示颜色设置为红色。_

当然，我么也可以延续上面方案的思路，在 delegate 的 `textfield` 方法中对文本进行判断。不过这种方式对类型的适用性不强（非 `String` 类型需转换）。

## 其他需要注意的问题

在使用上面的思路进行实际编程前，我们还需要考虑其他几个问题：

### 本地化

本文提供的 [ 演示代码 ](https://github.com/fatbobman/TextFieldFomatAndValidateDemo)
中实现了对 `Int` 和 `Double` 两种类型的实时处理。尽管这两种类型基本上都是以数字为主，但在处理时仍需注意本地化问题。

对于不同地区的数字，其小数点和组分隔符可能是不一样的，例如：

    1,000,000.012 // 大多数地区
    1 000 000,012 // fr

因此，在判断有效字符时，我们需要通过 Locale 来获取该地区的 `decimalSeparator` 和 `groupingSeparator`
。

如果你需要判断的是日期或其他自定义格式数据，最好也在代码中提供针对本地化字符的处理过程。

### Formatter

SwiftUI 的 TextField 目前对新老两种 Formatter 都提供了对应的构造方法。我倾向于使用新的 Formatter API。其为旧
Formatter API 的 Swift 原生实现，提供了更便捷、更安全的的声明方式。关于新 Formatter 的更多资料请阅读 [ WWDC 2021
新 Formatter API：新老比较及如何自定义 ](/zh/posts/newformatter/) 。

不过，TextField 对新 Formatter 的支持目前仍有部分问题，因此在编写代码时需特别注意。例如

    @State var number = 100
    TextField("inputNumber", value: $number, format: .number)

在绑定值为 `Int` 的情况下，当录入的数字超多 19 个字符将产生溢出，导致程序崩溃（已提交
FB，估计之后的版本会有修正）。好在本文的演示代码中，提供了对录入字符数量的限制，可以暂时解决这个问题。

### 易用性

如果仅实现本文最初设定的目标其实并不复杂，不过实现方式最好能提供方便的调用手段并减少对原有代码的污染。

例如，下面的代码为方案一和方案二的调用方式。

    // 方案一
    let intDelegate = ValidationDelegate(type: .int, maxLength: 6)

    TextField("0...1000", value: $intValue, format: .number)
           .addTextFieldDelegate(delegate: intDelegate)
           .numberValidator(value: intValue) { $0 < 0 || $0 > 1000 }

    // 方案二
    @StateObject var intStore = NumberStore(text: "",
                                            type: .int,
                                            maxLength: 5,
                                            allowNagative: true,
                                            formatter: IntegerFormatStyle<Int>())

    TextField("-1000...1000", text: $intStore.text)
           .formatAndValidate(intStore) { $0 < -1000 || $0 > 1000 }

以上调用方法仍有很大的优化和集成的空间，例如对 TextField 二度包装（采用 View），在方案二使用属性包装器对数字和字符串进行桥接等。

## 方案一

> 可以在 [ Github ](https://github.com/fatbobman/TextFieldFomatAndValidateDemo)
> 上下载本文的 Demo 代码。文章中仅对部分代码进行说明，完整的实现请参照源代码。

方案一使用 TextField 的新 Formatter 构造方法：

    public init<F>(_ titleKey: LocalizedStringKey, value: Binding<F.FormatInput>, format: F, prompt: Text? = nil) where F : ParseableFormatStyle, F.FormatOutput == String

通过替换 delegate 来激活 TextField 内置的 Format 机制，在 delegte 的 `textfield` 方法中屏蔽无效字符。

屏蔽无效字符：

    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
            let text = textField.text ?? ""
            return validator(text: text, replacementString: string)
        }

    private func validator(text: String, replacementString string: String) -> Bool {
            // 判断有效字符
            guard string.allSatisfy({ characters.contains($0) }) else { return false }
            let totalText = text + string

            // 检查小数点
            if type == .double, text.contains(decimalSeparator), string.contains(decimalSeparator) {
                return false
            }

            // 检查负号
            let minusCount = totalText.components(separatedBy: minusCharacter).count - 1

            if minusCount > 1 {
                return false
            }
            if minusCount == 1, !totalText.hasPrefix("-") {
                return false
            }

            // 检查长度
            guard totalText.count < maxLength + minusCount else {
                return false
            }
            return true
    }

其中需要注意的是，不同的 Locale 将提供不同的有效字符集（ `characters` ）。

添加 View 扩展

    extension View {
        // 根据是否满足指定条件调整文字颜色
        func numberValidator<T: Numeric>(value: T, errorCondition: (T) -> Bool) -> some View {
            foregroundColor(errorCondition(value) ? .red : .primary)
        }
        // 替换 delegate
        func addTextFieldDelegate(delegate: UITextFieldDelegate) -> some View {
            introspectTextField { td in
                td.delegate = delegate
            }
        }
    }

## 方案二

方案二，采用了 SwiftUI 原生的方法来实现同样的目标，由于无法利用 TextField 内置的
Formatter、原始文本等功能，因此实现上要比方案一复杂一些。另外，为了能够实时校验录入字符，因此只能采用字符串类型作为 TextField
的绑定类型，在调用上也比方案一略显复杂（可以通过再次包装做进一步简化）。

为了保存一些暂存数据，我们需要创建一个符合 ObservableObejct 的类，来对数据进行统一管理

    class NumberStore<T: Numeric, F: ParseableFormatStyle>: ObservableObject where F.FormatOutput == String, F.FormatInput == T {
        @Published var text: String
        let type: ValidationType
        let maxLength: Int
        let allowNagative: Bool
        private var backupText: String
        var error: Bool = false
        private let locale: Locale
        let formatter: F

        init(text: String = "",
             type: ValidationType,
             maxLength: Int = 18,
             allowNagative: Bool = false,
             formatter: F,
             locale: Locale = .current)
        {
            self.text = text
            self.type = type
            self.allowNagative = allowNagative
            self.formatter = formatter
            self.locale = locale
            backupText = text
            self.maxLength = maxLength == .max ? .max - 1 : maxLength
        }

formatter 传递给 `NumberStore` ，并在 `getValue` 中调用。

    // 返回验证后的数字
        func getValue() -> T? {
            // 特殊处理（无内容、只有负号、浮点数首字母为小数点）
            if text.isEmpty || text == minusCharacter || (type == .double && text == decimalSeparator) {
                backup()
                return nil
            }

            // 用去除组分隔符后的字符串判断字符是否有效
            let pureText = text.replacingOccurrences(of: groupingSeparator, with: "")
            guard pureText.allSatisfy({ characters.contains($0) }) else {
                restore()
                return nil
            }

            // 处理多个小数点情况
            if type == .double {
                if text.components(separatedBy: decimalSeparator).count > 2 {
                    restore()
                    return nil
                }
            }

            // 多个负号情况
            if minusCount > 1 {
                restore()
                return nil
            }

            // 负号必须为首字母
            if minusCount == 1, !text.hasPrefix("-") {
                restore()
                return nil
            }

            // 判断长度
            guard text.count < maxLength + minusCount else {
                restore()
                return nil
            }

            // 将文字转换成数字，然后再转换为文字（保证文字格式正确）
            if let value = try? formatter.parseStrategy.parse(text) {
                let hasDecimalCharacter = text.contains(decimalSeparator)
                text = formatter.format(value)
                // 保护最后的小数点（不特别处理的话，转换回来的文字可能不包含小数点）
                if hasDecimalCharacter, !text.contains(decimalSeparator) {
                    text.append(decimalSeparator)
                }
                backup()
                return value
            } else {
                restore()
                return nil
            }
        }

在方案二中，除了需要屏蔽无效字符外，我们还需要自己处理 Format 的实现。新的 Formatter API 对字符串的容错能力非常好，因此，将文本先通过
parseStrategy 转换成数值，然后再转换成标准的字符串将能够保证 TextField 中的文字始终保持正确的显示。

另外，需要考虑到首字符为 `-` 以及最后字符为小数点的情况，因为 parseStrategy
会在转换后丢失这些信息，我们需要在最终的转换结果中重现这些字符。

View 扩展

    extension View {
        @ViewBuilder
        func formatAndValidate<T: Numeric, F: ParseableFormatStyle>(_ numberStore: NumberStore<T, F>, errorCondition: @escaping (T) -> Bool) -> some View {
            onChange(of: numberStore.text) { text in
                if let value = numberStore.getValue(),!errorCondition(value) {
                    numberStore.error = false // 通过 NumberStore 转存校验状态
                } else if text.isEmpty || text == numberStore.minusCharacter {
                    numberStore.error = false
                } else { numberStore.error = true }
            }
            .foregroundColor(numberStore.error ? .red : .primary)
            .disableAutocorrection(true)
            .autocapitalization(.none)
            .onSubmit { // 处理只有一个小数点的情况
                if numberStore.text.count > 1 && numberStore.text.suffix(1) == numberStore.decimalSeparator {
                    numberStore.text.removeLast()
                }
            }
        }
    }

同方案一将处理逻辑分散到多个的代码部分不同，方案二中，所有的逻辑都是在 `onChange` 中激发调用的。

由于 `onChange` 是在文字发生变化后才会调用，因此，方案二会导致视图二度刷新，不过考虑到文字录入的应用场景，性能损失可以忽略（
如使用属性包装器进一步对数值同字符串进行链接，可能会进一步增加视图的刷新次数）。

> 可以在 [ Github ](https://github.com/fatbobman/TextFieldFomatAndValidateDemo)
> 上下载本文的 Demo 代码。

## 两种方案的比较

- 效率

由于方案一在每次录入时仅需刷新一次视图，因此理论上其执行效率要高于方案二，不过在实际使用中，二者都可以提供流畅、及时的交互效果。

- 支持的类型种类

方案一可以直接使用多种数据类型，方案二中需在 TextField 的构造方法中将原始数值转换成对应格式的字符串。方案二的演示代码中，可以通过 `result` 获取字符串对应的数值。

- 可选值支持

方案一采用的 TextField 构造方法（支持 formatter）并不支持可选值类型，必须要提供初始值。不利于判断用户是否录入新的信息（更多的信息可参阅
[ 如何在 SwiftUI 中创建一个实时响应的 Form ](/zh/posts/swiftui-input-form/) ）。

方案二中允许不提供初始值，支持可选值。

另外，在方案一中如果将所有的字符都清空，绑定变量仍将有数值（原 API 行为），容易造成用户在录入时的困惑。

- 可持续性（SwiftUI 向后兼容性）

方案二由于完全采用 SwiftUI 方式编写，因此其可持续性从理论上应强于方案一。不过除非 SwiftUI
对背后的实现逻辑进行了较大修改，否则方案一在最近几个版本中仍会正常运行，而且方案一可以支持更早版本的 SwiftUI。

- 对其他修饰方法的兼容性

无论方案一还是方案二都满足了本文之前提出的对官方 API 的完全兼容，在没有损失的情况下获得了其他功能的提升。

## 总结

每个开发者都希望为用户提供一个高效、优雅的交互环境。本文仅涉及了 TextField 的部分内容，在【SwiftUI TextField
进阶】的其他篇幅中，我们将探讨更多的技巧和思路，让开发者在 SwiftUI 中创建不一样的文本录入体验。

# SwiftUI + Core Data App 的内存占用优化之旅

尽管 SwiftUI 的惰性容器以及 Core Data 都有各自的内存占用优化机制，但随着应用视图内容的复杂（ 图文混排
），越来越多的开发者遇到了内存占用巨大甚至由此导致 App 崩溃的情况。本文将通过对一个演示 App 进行逐步内存优化的方式（ 由原先显示 100
条数据要占用 1.6 GB 内存，优化至显示数百条数据仅需 200 多 MB 内存 ），让读者对 SwiftUI
视图的存续期、惰性视图中子视图的生命周期、托管对象的惰值特性以及持久化存储协调器的行缓存等内容有更多的了解。

> 可在 [ 此处
> ](https://github.com/fatbobman/BlogCodes/tree/main/Memory_Optimization)
> 下载本文所需的代码

## 一个内存占用量巨大的 App

本节中，我们将创建一个在 List 中对 Core Data 数据进行浏览的演示 App。

本例中，Core Data 的数据模型非常简单，只有两个 Entity ：Item 和 Picture。Item 与 Picture
之间是一对一的关系。为了尽量不影响 SQLite 数据库的操作性能，我们为 Picture 的 data 属性启用了 `Allows External
Storage` 选项。

![Item_Entity](https://cdn.fatbobman.com/image-20230307132541444.png)

![Picture_Entity](https://cdn.fatbobman.com/image-20230307132631527.png)

> 开启 `Allows External Storage` 后，SQLite 会自动将尺寸大于一定要求（ 100 KB ）的 Binary
> 数据以文件的形式保存在与数据库文件同级目录的隐藏子目录中。数据库字段中仅保存与该文件对应的文件 ID （ 50 个字节
> ）。通常为了保证数据库的性能，开发者会为尺寸较大的 Binary 属性开启这一选项。

列表视图相当简单：

    struct ContentView: View {
        @Environment(\.managedObjectContext) private var viewContext
        @FetchRequest(
            sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
            animation: .default)
        private var items: FetchedResults<Item>

        var body: some View {
            NavigationView {
                VStack {
                    List {
                        ForEach(items) { item in
                            ItemCell(item: item)
                        }
                    }
                }
            }
        }
    }

单元格视图也是采用了常见的形式：

    struct ItemCell: View {
        @ObservedObject var item: Item
        let imageSize: CGSize = .init(width: 120, height: 160)
        var body: some View {
            HStack {
                Text(self.item.timestamp?.timeIntervalSince1970 ?? 0, format: .number)
                if let data = item.picture?.data, let uiImage = UIImage(data: data), let image = Image(uiImage: uiImage) {
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: self.imageSize.width, height: self.imageSize.height)
                }
            }
            .frame(minWidth: .zero, maxWidth: .infinity)
        }
    }

生成数据后，运行后显示的状态如下：

![image-20230307133812557](https://cdn.fatbobman.com/image-20230307133812557.png)

> **Add 100** 按钮将创建 100 条记录， **记录数** 为当前的数据条数， **内存占用** 为当前 App
> 的内存占用情况。具体实现可查看本文演示代码。

在我们创建完 100 条数据后，重启应用（ 重启可以更精准地测量内存占用情况 ）并滚动列表至底部。此时该应用的内存占用为 **1.6 GB**
左右。此时请不要惊讶，你可以尝试点击添加数据按钮继续增加数据，再次滚动到底部，你将看到更加令人震惊的内存占用数值，不过有极大的可能会看不到（ 应用已经崩溃了
）。

![无优化滚动至底截屏](https://cdn.fatbobman.com/image-20230307114637079.png)

从 Instruments 的分析来看，随着列表的滚动，内存占用持续增加中。

![无优化效果](https://cdn.fatbobman.com/image-20230307103505927.png)

相信任何开发者都无法容忍这种内存占用的情况出现。下文中，我们将对这段代码进行逐步优化，以达到最终可用的程度。

## 第一轮优化：对视图 body 值进行优化

在第一轮优化中，我们会首先尝试从 SwiftUI 的角度入手。

SwiftUI 的惰性视图容器拥有对符合 DynamicViewContent 协议的内容（ 通过 ForEach 生成的内容
）进行优化的能力。在正常的情况下（ 惰性容器中仅包含一个 ForEach ，且子视图没有使用 id 添加显式标识
），惰性容器仅会创建当前可见范围内的子视图实例，并对其 body 进行求值（ 渲染 ）。

当子视图进入惰性容器的可视区域时，SwiftUI 会调用它的 onAppear 闭包，子视图退出可视区域时，会调用 onDisappear
闭包。开发者通常会利用这两个调用时机来实现数据准备和善后工作。

尽管从表面上来看，惰性容器仅会在视图进入可视区域时才会对其进行操作， **但一旦该视图被显示过（ body 被求过值
），即使该视图离开可视区域，SwiftUI 仍会保存视图的 body 值** 。这意味着， **在惰性容器中，视图一经创建，其存续期将与该容器一致** （
容器不销毁，则视图将始终存续 ）。

在本例中，子视图的 body 值中一定会包含用于显示的图片数据，因此，即使该视图已经被显示过（ 滚动出显示区域 ），该视图的 body
值仍将占用不小的内存。

我们可以通过在 onAppear 以及 onDisappear 中对图片的显示与否（ 变量 show ）进行控制（ 迫使 SwiftUI 对视图的 body
重新求值 ），从而减少因上述原因所增加的内存占用。

对 Cell 视图代码（ `ItemCell.swift` ）进行如下调整：

    struct ItemCell: View {
        @ObservedObject var item: Item
        @Environment(\.managedObjectContext) var viewContext
        let imageSize: CGSize = .init(width: 120, height: 160)
        @State var show = true
        var body: some View {
            HStack {
                if show { // 仅当处于惰性容器可视区域时采显示内容
                    Text(self.item.timestamp?.timeIntervalSince1970 ?? 0, format: .number)
                    if let data = item.picture?.data, let uiImage = UIImage(data: data), let image = Image(uiImage: uiImage) {
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(width: self.imageSize.width, height: self.imageSize.height)
                    }
                }
            }
            .frame(minWidth: .zero, maxWidth: .infinity)
            .onAppear {
                show = true // 进入可视区域时显示
            }
            .onDisappear {
                show = false // 退出可视区域时不显示
            }
        }
    }

通过上面简单的改动，当前 App 的内存占用情况便有了显著的改善。滚动到底部后（ 100 条数据 ），内存的占用将在 500 MB 左右。

![binary-store-in-external- iPhone 14 Pro - 2023-03-07 at 11.33.27.2023-03-07
11_35_01](https://cdn.fatbobman.com/binary-store-in-
external-%20iPhone%2014%20Pro%20-%202023-03-07%20at%2011.33.27.2023-03-07%2011_35_01.gif)

> Instruments 会导致优化后的结果显示不准确，内存占用数据将以 App 中的显示以及 Xcode Navigator 的 Debug
> 栏内容为准。如果滚动过快，可能会导致内存占用增大。估计与系统无暇进行清理操作有关。

![Navigator-Debug](https://cdn.fatbobman.com/image-20230307141701153.png)

尽管上述优化技巧可能会对滚动的流畅度产生一定的影响（ 视觉上不明显 ），不过考虑到它所带来的巨大收益，在本例中应该是一个相当不错的选择。

> 同未优化过的代码一样，随着数据量的增大，内存的占用也将随之提高。在 400 条记录的情况下，滚动到底部，内存占用值差不多是 1.75
> GB。尽管我们节省了差不多 70% 的内存占用，但仍无法完全满足需求。

## 第二轮优化：让托管对象回归惰性状态

在第二轮优化中，我们将尝试从 Core Data 中找寻解决之道。

首先，我们需要对托管对象的惰值特性以及协调器的“行缓存”概念有所了解。

### 存储协调器的行缓存（ Row cache in coordinator ）

在 Core Data Stack 的多层结构中，存储协调器（ NSPersistentStoreCoordinator
）正好处于持久化存储与托管上下文之间。其向托管上下文以及持久化存储提供了单个的统一接口，一个协调器便可以应对多个上下文以及多个持久化存储。

![coreDataStack](https://cdn.fatbobman.com/coreDataStack.svg)

在协调器具备的众多功能中，“行缓存”是其中很有特点的一个。所谓行缓存，便是指当 Core Data 从 SQLite
中获取数据时，首先将数据以接近原始存储格式的形式保存在行缓存（ 内存 ）中。并根据上下文的需要，用对应的数据向特定的托管对象进行填充（ 实例化
）。行缓存的真正意义在于，在有多个托管上下文（ NSMangedObjectContext ）与协调器关联时，对于同一条记录（
NSManagedObjectID 一致 ）的内容，无需进行多次 IO 操作，可以直接从行缓存中获取（ 如果可以命中的话 ）。

从当今移动开发的角度来说，行缓存好像存在的意义不大，但考虑到 Core Data
的前身主要用来处理金融类数据业务，在此种场景中，行缓存可以带来相当可观的收益。

由于行缓存机制的存在，当我们通过 Core Data 从数据库中获取某个数据时（ 例如图片 ），行缓存中会有一份副本。

### 托管对象的惰值特性

托管对象（ NSManagedObject ）除了只能在创建其的托管上下文中进行操作外，按需填充也是托管对象的重要特性之一。

在开发者通过创建一个 Request （ NSFetchRequest ）从数据库中获取查询结果时，除非特别将 Request 的
returnsObjectsAsFaults 属性设置为 false ，否则托管上下文并不会给托管对象的托管属性（ @NSManaged
）返回真正的数据。只有在访问这些托管属性时，Core Data 才会为托管对象进行数据填充（
如果行缓存中有，从缓存中取；如果没有则将数据从数据库中搬运到行缓存后再从缓存中取 ）。

惰值特性是 Core Data 的重要特性之一。它保证了，只在真正对数据有需求时，才对数据进行获取（ 实例化
）。在提高了性能的同时，也尽量减少了对内存的占用。

在本例中，只有视图首次出现在 List 的可视区域时，Item 才会被填充数据。

在托管对象从惰值状态（ Fault ）脱离后，只有在几种特定的条件下，才会重新转换为惰值。例如通过调用 refresh 或
refreshAllObjects 方法。

除非特别设置 relationshipKeyPathsForPrefetching 属性，否则除了实体（ Entity ）自身的属性（ Attribute
）外，Core Data 对与 Entity 有关联的关系（ Relationship ）也采用了默认的惰性填充规则（ 即使
returnsObjectsAsFaults 为 false ）。

### 数据的多份拷贝

当图片数据从 SQLite 经 Core Data 最终通过 SwiftUI 显示时，实际上在内存中至少保存了三份拷贝：

- 行缓存
- 托管对象上下文（ 托管对象被填充后 ）
- 显示该图片的 SwiftUI 视图（ body 的值中 ）

在第一轮优化中，我们通过显示控制，修改了离开可视区域的视图 body 值（ 删除了一份 Copy
）。如果我们能够在视图离开可视区域时，能让托管对象重新进入惰值状态，或许又能节省一部分内存。

> 由于一个协调器可以对应多个上下文，如果在另一个上下文中，指向同一个图片的另一个托管对象也进行了填充，那么就又会多出一个 Copy

### 不成功的优化

在首轮优化后的代码基础上，做如下添加：

           .onDisappear {
                show = false
                // 在视图离开可视区域时，尝试让 Item 以及对应的 Picture 对象返回惰值状态
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    viewContext.refresh(item, mergeChanges: false)
                    if let picture = item.picture {
                        viewContext.refresh(picture, mergeChanges: false)
                    }
                }
            }

修改后运行程序，我们会惊异地发现 —— **几乎没有变化** ！

**原因何在** ？？？

通过代码检查托管对象会发现，尽管托管对象已经转为惰性状态，但实际上并没有节省多少内存。这是因为，我们在定义 Picture 的 data 属性时，设置了 `Allows External Storage` 选项。这意味着，在托管对象上下文中，data 属性即使在填充后也仅有 50 个字节（ 文件 ID ）。

> 目前无法找到 Core Data
> 在行缓存以及上下文中处理这些外置二进制数据的任何资料。不过通过实验中分析，这些数据肯定是被缓存的，且在被加载后，并不会因为返回惰值而自动从内存中清除

因此，即使我们将托管对象返回成惰值状态，也仅能节省极少的内存占用（ 在本例中几乎可以忽略不计 ）。

### 效果有限但潜力不小的优化

为了能对图片数据在上下文中的表现有更加精准的控制，我修改了 data 属性的设置，取消了 `Allows External Storage` 选项。

> 为了保证程序顺利运行，需要从模拟器（ 或真机 ）上首先删除 App，然后再重新安装

相较于第一轮的优化，本次优化后内存占用有了一定的改善（ 幅度不到 100 MB ）。

![binary-store-in-Sqlite- iPhone 14 Pro - 2023-03-07 at 11.23.52.2023-03-07
11_26_42](https://cdn.fatbobman.com/binary-store-in-
Sqlite-%20iPhone%2014%20Pro%20-%202023-03-07%20at%2011.23.52.2023-03-07%2011_26_42.gif)

尽管本轮优化的效果一般（ 且数据增加后，内存占用仍呈线性增长 ），但至少表明是有机会从 Core Data 中找到可优化的角度。

## 终极优化：私有上下文 + 不持有托管对象

### 思路

在第二轮优化中，尽管通过将托管对象转换为惰值解决了一部分内存占用问题，但存在于行缓存中的数据始终还是无法得到有效清除。是否有可能将上下文以及行缓存中数据所占空间一并优化掉？

为了减少内存占用，Core Data 对于不需要的数据空间采用积极的释放策略。如果一个托管对象失去了强引用，那么 Core Data
将很快便释放掉它所占用的上下文中的内存空间。如果一条记录（ 数据库中的数据
），无论哪个上下文中都没有与其对应的托管对象，那么也将快速地清理其所占用的行缓存空间。

也就是说， **如果我们能让数据仅在视图出现在惰性容器可见范围内，才创建一个指向该数据的托管对象，并且在视图离开可视区域时，删除该对象（ 放弃引用
），那么就可以通过 Core Data 自身的内存释放机制来完成本轮优化** 。

根据上述原理，我们将尝试如下过程：

- 在 onAppear 的闭包中，通过私有上下文创建一个 Picture 对象
- 将 data 属性的数据转换成 Image，并保存在视图中的一个 Source of truth 中
- 在视图显示该 Image
- onAppear 闭包运行结束时，Picture 对象将自动被释放
- 在 onDisapper 中清除 Source of truth 中的内容（ 设置为 nil ）

按照预想，由于该 Picture 托管对象仅存活于视图的 onAppear block 中，闭包执行完毕后，Core Data
会自动释放上下文以及行缓存中对应的数据。

代码如下：

    struct ItemCell: View {
        @ObservedObject var item: Item
        @State var image: Image?
        @Environment(\.managedObjectContext) var viewContext
        let imageSize: CGSize = .init(width: 120, height: 160)
        @State var show = true
        var body: some View {
            HStack {
                if show {
                    Text(self.item.timestamp?.timeIntervalSince1970 ?? 0, format: .number)
                    if let image = image {
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(width: self.imageSize.width, height: self.imageSize.height)
                    } else {
                        Rectangle()
                            .frame(width: self.imageSize.width, height: self.imageSize.height)
                    }
                }
            }
            .frame(minWidth: .zero, maxWidth: .infinity)
            .onAppear {
                show = true
                Task {
                    if let objectID = item.picture?.objectID { // 获取 ObjectID 并不会触发惰性填充
                        let imageData: Data? = await PersistenceController.shared.container.performBackgroundTask { context in
                            if let picture = try? context.existingObject(with: objectID) as? Picture, let data = picture.data {
                                return data
                            } else { return nil }
                        }
                        if let imageData {
                            image = Image(uiImage: UIImage(data: imageData)!)
                        }
                    }
                }
            }
            .onDisappear {
                show = false
                image = nil
            }
        }
    }

**理想很丰满，现实很骨感** ，执行上述代码后，内存并不会有很大的改善。问题又出现在什么地方呢？

### 释放不积极的 @State

上面代码的问题，是因为我们使用了声明为 @State 的变量来暂存 Image。在惰性容器中，与积极释放 body 所占内存容量的策略不同，@State
对应值的释放并不积极。即使我们在 onDisappear 中将该变量设置为 nil，但 SwiftUI 并没有释放之前它所占用的空间。

以下面的代码举例：

    struct MemeoryReleaseDemoByState: View {
        @State var data: Data?
        @State var memory: Float = 0
        var body: some View {
            VStack {
                Text("memory :\(memory)")
                Button("Generate Data") {
                    data = Data(repeating: 0, count: 10000000)
                    memory = reportMemory()
                }
                Button("Release Memory") {
                    data = nil
                    memory = reportMemory()
                }
            }
            .onAppear{
                memory = reportMemory() // reportMemory 将报告当前 app 的内存占用，实现请查看本文范例代码
            }
        }
    }

> 首先点击 “Generate Data”，然后点击 “Release Memory”，你会发现尽管 data 设置为 nil，但 app
> 所占据的内存空间并没有减少

在这种情况下，我们可以通过引用类型来创建一个 Holder，通过该持有器，解决释放不积极的问题。

    struct MemeoryReleaseDemoByStateObject: View {
        @StateObject var holder = Holder()
        @State var memory: Float = 0
        var body: some View {
            VStack {
                Text("memory :\(memory)")
                Button("Generate Data") {
                    holder.data = Data(repeating: 0, count: 10000000)
                    memory = reportMemory()
                }
                Button("ReleaseMemory") {
                    holder.data = nil
                    memory = reportMemory()
                }
            }
            .onAppear{
                memory = reportMemory()
            }
        }

        class Holder:ObservableObject {
            @Published var data:Data?
        }
    }

> SwiftUI 只会持有 @StateObject 所对应实例的引用，实例中属性数据的释放仍遵循标准的 Swift 语言逻辑。因此，通过
> Holder，我们可以按照自己的想法释放不需要的内存

修改后的代码：

    struct ItemCell: View {
        @ObservedObject var item: Item
        @StateObject var imageHolder = ImageHolder()
        @Environment(\.managedObjectContext) var viewContext
        let imageSize: CGSize = .init(width: 120, height: 160)
        @State var show = true
        var body: some View {
            HStack {
                if show {
                    Text(self.item.timestamp?.timeIntervalSince1970 ?? 0, format: .number)
                    if let image = imageHolder.image {
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(width: self.imageSize.width, height: self.imageSize.height)
                    } else {
                        Rectangle()
                            .frame(width: self.imageSize.width, height: self.imageSize.height)
                    }
                }
            }
            .frame(minWidth: .zero, maxWidth: .infinity)
            .onAppear {
                show = true
                Task {
                    if let objectID = item.picture?.objectID {
                        let imageData: Data? = await PersistenceController.shared.container.performBackgroundTask { context in
                            if let picture = try? context.existingObject(with: objectID) as? Picture, let data = picture.data {
                                return data
                            } else { return nil }
                        }
                        if let imageData {
                            imageHolder.image = Image(uiImage: UIImage(data: imageData)!)
                        }
                    }
                }
            }
            .onDisappear {
                show = false
                self.imageHolder.image = nil
            }
        }
    }

    class ImageHolder: ObservableObject {
        @Published var image: Image?
    }

在最终的代码中，我们对图片数据在内存中的三个备份实现了有效的控制。在同一时间（ 理想情况下 ），只有出现在可视区域的图片数据才会保存在内存中。

![privateContext- iPhone 14 Pro - 2023-03-07 at 11.39.00.2023-03-07
11_40_09](https://cdn.fatbobman.com/privateContext-%20iPhone%2014%20Pro%20-%202023-03-07%20at%2011.39.00.2023-03-07%2011_40_09.gif)

可以加大检测力度，即使在生成了 400 条记录的情况下，内存占用也仍然被控制在一个相当理想的状态（ 下图为 400 条数据滚动到底部的内存占用情况 ）。

![私有上下文滚动至底截屏](https://cdn.fatbobman.com/image-20230307114909422.png)

至此，我们终于完成了对该段代码的优化，无需再担心其可能因占用内存过大而导致的崩溃。

## 总结

SwiftUI 的惰性容器使用起来很方便，并且通过 @FetchRequest 与 Core Data
配合也很方便，这在一定程度上导致开发者有了轻视的心理，认为 SwiftUI + Core Data
会为我们处理一切。但在有些情况下，我们仍然需要通过自己对两者的深入理解对代码进行高度优化才能取得预期的效果。

# 聊一下在 SwiftUI 中使用 CoreData

本文并非一个教你如何在 SwiftUI 下使用 CoreData 的教程。主要探讨的是在我近一年的 SwiftUI 开发中使用 CoreData
的教训、经验、心得。

## SwiftUI lifecycle 中如何声明持久化存储和上下文

在 XCode 12 中，苹果新增了 SwiftUI lifecycle，让 App 完全的 SwiftUI
化。不过这就需要我们使用新的方法来声明持久化存储和上下文。

好像是从 beta 6 开始，XCode 12 提供了基于 SwiftUI lifecycle 的 CoreData 模板

    @main
    struct CoreDataTestApp: App {
        //持久化声明
        let persistenceController = PersistenceController.shared

        var body: some Scene {
            WindowGroup {
                ContentView()
                    .environment(\.managedObjectContext, persistenceController.container.viewContext)
              //上下文注入
            }
        }
    }

在它的 Presitence 中，添加了用于 preview 的持久化定义

    struct PersistenceController {
        static let shared = PersistenceController()

        static var preview: PersistenceController = {
            let result = PersistenceController(inMemory: true)
            let viewContext = result.container.viewContext
            //根据你的实际需要，创建用于 preview 的数据
            for _ in 0..<10 {
                let newItem = Item(context: viewContext)
                newItem.timestamp = Date()
            }
            do {
                try viewContext.save()
            } catch {
                let nsError = error as NSError
                fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
            }
            return result
        }()

        let container: NSPersistentCloudKitContainer
        //如果是用于 preview 便将数据保存在内存而非 sqlite 中
        init(inMemory: Bool = false) {
            container = NSPersistentCloudKitContainer(name: "Shared")
            if inMemory {
                container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: "/dev/null")
            }
            container.loadPersistentStores(completionHandler: { (storeDescription, error) in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
        }
    }

虽然对于用于 preview 的持久化设置并不完美，不过苹果也意识到了在 SwiftUI 1.0 中的一个很大问题，无法 preview
使用了@FetchRequest 的视图。

由于在官方 CoreData 模板出现前，我已经开始了我的项目构建，因此，我使用了下面的方式来声明

    struct HealthNotesApp:App{
      static let coreDataStack = CoreDataStack(modelName: "Model") //Model.xcdatemodeld
      static let context = DataNoteApp.coreDataStack.managedContext
      static var storeRoot = Store()
       @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate
      WindowGroup {
            rootView()
                .environmentObject(store)
                .environment(\.managedObjectContext, DataNoteApp.context)
      }
    }

在 UIKit App Delegate 中，我们可以使用如下代码在 App 任意位置获取上下文

    let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext

但由于我们已经没有办法在 SwiftUI lifecycle 中如此使用，通过上面的声明我们可以利用下面的方法在全局获取想要的上下文或其他想要获得的对象

    let context = HealthNotesApp.context

比如在 delegate 中

    class AppDelegate:NSObject,UIApplicationDelegate{

        let send = HealthNotesApp.storeRoot.send

        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {

            logDebug("app startup on ios")

            send(.loadNote)
            return true
        }

        func applicationDidFinishLaunching(_ application: UIApplication){

            logDebug("app quit on ios")
            send(.counter(.save))

        }

    }

    //或者直接操作数据库，都是可以的

## 如何动态设置 @FetchRequest

在 SwiftUI 中，如果无需复杂的数据操作，使用 CoreData 是非常方便的。在完成 xcdatamodeld 的设置后，我们就可以在 View
中轻松的操作数据了。

我们通常使用如下语句来获取某个 entity 的数据

    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \Student.studentId, ascending: true)],
                  predicate:NSPredicate(format: "age > 10"),
                  animation: .default)
    private var students: FetchedResults<Student>

不过如此使用的话，查询条件将无法改变，如果想根据需要调整查询条件，可以使用下面的方法。

健康笔记 2 中的部分代码：

    struct rootView:View{
        @State var predicate:NSPredicate? = nil
        @State var sort = NSSortDescriptor(key: "date", ascending: false)
        @StateObject var searchStore = SearchStore()
        @EnvironmentObject var store:Store
        var body:some View{
          VStack {
           SearchBar(text: $searchStore.searchText) //搜索框
           MemoList(predicate: predicate, sort: sort,searching:searchStore.showSearch)
            }
          .onChange(of: searchStore.text){ _ in
              getMemos()
          }
        }

           //读取指定范围的 memo
        func getMemos() {
            var predicators:[NSPredicate] = []
            if !searchStore.searchText.isEmpty && searchStore.showSearch {
                //memo 内容或者 item 名称包含关键字
                predicators.append(NSPredicate(format: "itemData.item.name contains[cd] %@ OR content contains[cd] %@", searchStore.searchText,searchStore.searchText))
            }
            if star {
                predicators.append(NSPredicate(format: "star = true"))
            }

            switch store.state.memo{
            case .all:
                break
            case .memo:
                if !searchStore.searchText.isEmpty && noteOption == 1 {
                    break
                }
                else {
                    predicators.append(NSPredicate(format: "itemData.item.note = nil"))
                }
            case .note(let note):
                if !searchStore.searchText.isEmpty && noteOption == 1 {
                    break
                }
                else {
                    predicators.append(NSPredicate(format: "itemData.item.note = %@", note))
                }
            }

            withAnimation(.easeInOut){
                predicate =  NSCompoundPredicate(type: NSCompoundPredicate.LogicalType.and, subpredicates: predicators)
                sort =  NSSortDescriptor(key: "date", ascending: ascending)
            }
        }
    }

上述代码会根据搜索关键字以及一些其他的范围条件，动态的创建 predicate，从而获得所需的数据。

对于类似查询这样的操作，最好配合上 Combine 来限制数据获取的频次

例如：

    class SearchStore:ObservableObject{
        @Published var searchText = ""
        @Published var text = ""
        @Published var showSearch = false

        private var cancellables:[AnyCancellable] = []

        func registerPublisher(){
            $searchText
                .removeDuplicates()
                .debounce(for: 0.4, scheduler: DispatchQueue.main)
                .assign(to: &$text)
        }

        func removePublisher(){
            cancellables.removeAll()
        }

    }

上述所有代码均缺失了很大部分，仅做思路上的说明

## 增加转换层方便代码开发

在开发健康笔记 1.0 的时候我经常被类似下面的代码所烦恼

    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \Student.name, ascending: true)],
                  animation: .default)
    private var students: FetchedResults<Student>

    ForEach(students){ student in
      Text(student.name ?? "")
      Text(String(student.date ?? Date()))
    }

在 CoreData 中，设置 Attribute，很多时候并不能完全如愿。

好几个类型是可选的，比如 String，UUID 等，如果在已发布的 app，将新增的 attribute
其改为不可选，并设置默认值，将极大的增加迁移的难度。另外，如果使用了 NSPersistentCloudKitContainer, 由于 Cloudkit
的 atrribute 和 CoreData 并不相同，XCode 会强制你将很多 Attribute 改成你不希望的样式。

为了提高开发效率，并为未来的修改留出灵活、充分的更改空间，在健康笔记 2.0 的开发中，我为每个 NSManagedObject 都增加了一个便于在
View 和其他数据操作中使用的中间层。

例如：

    @objc(Student)
    public class Student: NSManagedObject,Identifiable {
        @NSManaged public var name: String?
        @NSmanaged public var birthdate: Date?
    }

    public struct StudentViewModel: Identifiable{
        let name:String
        let birthdate:String
    }

    extension Student{
       var viewModel:StudentViewModel(
            name:name ?? ""
            birthdate:(birthdate ?? Date()).toString() //举例
       )

    }

如此一来，在 View 中调用将非常方便，同时即使更改 entity 的设置，整个程序的代码修改量也将显著降低。

    ForEach(students){ student in
      let student = student.viewModel
      Text(student.name)
      Text(student.birthdate)
    }

同时，对于数据的其他操作，我也都通过这个 viewModel 来完成。

比如：

    //MARK: 通过 ViewModel 生成 Note 数据，所有的 prepare 动作都需要显示调用 _coreDataSave()
        func _prepareNote(_ viewModel:NoteViewModel) -> Note{
            let note = Note(context: context )
            note.id = viewModel.id
            note.index = Int32(viewModel.index)
            note.createDate = viewModel.createDate
            note.name = viewModel.name
            note.source = Int32(viewModel.source)
            note.descriptionContent = viewModel.descriptionContent
            note.color = viewModel.color.rawValue
            return note
        }

        //MARK: 更新 Note 数据，仍需显示调用 save
        func _updateNote(_ note:Note,_ viewModel:NoteViewModel) -> Note {
            note.name = viewModel.name
            note.source = Int32(viewModel.source)
            note.descriptionContent = viewModel.descriptionContent
            note.color = viewModel.color.rawValue
            return note
        }

    func newNote(noteViewModel:NoteViewModel) -> AnyPublisher<AppAction,Never> {
           let _ = _prepareNote(noteViewModel)
           if  !_coreDataSave() {
                logDebug("新建 Note 出现错误")
           }
           return Just(AppAction.none).eraseToAnyPublisher()
        }

    func editNote(note:Note,newNoteViewModel:NoteViewModel) -> AnyPublisher<AppAction,Never>{
            let _ = _updateNote(note, newNoteViewModel)
            if !_coreDataSave() {
                logDebug("更新 Note 出现错误")
            }
            return Just(AppAction.none).eraseToAnyPublisher()
    }

在 View 中调用

    Button("New"){
          let noteViewModel = NoteViewModel(createDate: Date(), descriptionContent: myState.noteDescription, id: UUID(), index: -1, name: myState.noteName, source: 0, color: .none)
         store.send(.newNote(noteViewModel: noteViewModel))
         presentationMode.wrappedValue.dismiss()
    }

从而将可选值或者类型转换控制在最小范围

## 使用 NSPersistentCloudKitContainer 需要注意的问题

从 iOS 13 开始，苹果提供了 NSPersistentCloudKitContainer，让 app 可以以最简单的方式享有了数据库云同步功能。

不过在使用中，我们需要注意几个问题。

- Attribute 在上一节提高过，由于 Cloudkit 的数据设定和 CoreData 并不完全兼容，因此如果你在项目初始阶段是使用 NSPersistentContainer 进行开发的，当将代码改成 NSPersistentCloudKitContainer 后，XCode 可能会提示你某些 Attribute 不兼容的情况。如果你采用了中间层处理数据，修改起来会很方便，否则你需要对已完成的代码做出不少的修改和调整。我通常为了开发调试的效率，只有到最后的时候才会使用 NSPersistentCloudKitContainer，因此这个问题会比较突出。

- 合并策略 奇怪的是，在 XCode 的 CoreData（点选使用 CloudKit）默认模板中，并没有设定合并策略。如果没有设置的话，当 app 的数据进行云同步时，时长会出现合并错误，并且@FetchRequest 也并不会在有数据发生变动时对 View 进行刷新。因此我们需要自己明确数据的合并策略。

        lazy var persistentContainer: NSPersistentCloudKitContainer = {
            let container = NSPersistentCloudKitContainer(name: modelName)
            container.loadPersistentStores(completionHandler: { (storeDescription, error) in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
            //需要显式表明下面的合并策略，否则会出现合并错误！
            container.viewContext.automaticallyMergesChangesFromParent = true
            container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
            return container
        }()

- 调试信息 当打开云同步后，在调试信息中将出现大量的数据同步调试信息，严重影响了对于其他调试信息的观察。虽然可以通过启动命令屏蔽掉数据同步信息，但有时候我还是需要对其进行观察的。目前我使用了一个临时的解决方案。

  #if !targetEnvironment(macCatalyst) && canImport(OSLog)
  import OSLog
  let logger = Logger.init(subsystem: "com.fatbobman.DataNote", category: "main") //调试用
  func logDebug(_ text:String,enable:Bool = true){
  #if DEBUG
  if enable {
  logger.debug("\(text)")
  }
  #endif
  }
  #else
  func logDebug(_ text:String,enable:Bool = true){
  print(text,"$$$$")
  }
  #endif

对于需要显示调试信息的地方

      logDebug("数据格式错误")

然后通过在 Debug 窗口中将 Filter 设置为 $$$$ 来屏蔽掉暂时不想看到的其他信息

## 不要用 SQL 的思维限制了 CoreData 的能力

CoreData 虽然主要是采用 Sqlite 来作为数据存储方案，不过对于它的数据对象操作不要完全套用 Sql 中的惯用思维。

一些例子

排序：

    //Sql 式的
    NSSortDescriptor(key: "name", ascending: true)
    //更 CoreData 化，不会出现拼写错误
    NSSortDescriptor(keyPath: \Student.name, ascending: true)

在断言中不适用子查询而直接比较对象：

    NSPredicate(format: "itemData.item.name = %@",name)

Count:

    func _getCount(entity:String,predicate:NSPredicate?) -> Int{
            let fetchRequest = NSFetchRequest<NSNumber>(entityName: entity)
            fetchRequest.predicate = predicate
            fetchRequest.resultType = .countResultType

            do {
                let results  = try context.fetch(fetchRequest)
                let count = results.first!.intValue
                return count
            }
            catch {
                #if DEBUG
                logDebug("\(error.localizedDescription)")
                #endif
                return 0
            }
        }

或者更加简单的 count

    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \Student.name, ascending: true)],
                  animation: .default)
    private var students: FetchedResults<Student>

    sutudents.count

对于数据量不大的情况，我们也可以不采用上面的动态 predicate 方式，在 View 中直接对获取后的数据进行操作，比如：

    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \Student.name, ascending: true)],
                  animation: .default)
    private var studentDatas: FetchedResults<Student>
    @State var students:[Student] = []
    var body:some View{
      List{
            ForEach(students){ student in
               Text(student.viewModel.name)
             }
            }
            .onReceive(studentDatas.publisher){ _ in
                students = studentDatas.filter{ student in
                    student.viewModel.age > 10
                }
            }
       }
    }

总之数据皆对象。

# Core Data 是如何在 SQLite 中保存数据的

Core Data 是一个具备数据持久化能力的对象图框架。相同的对象图在不同的持久化存储类型中（ SQLite
、XML）的数据组织结构差别较大。如果你浏览过 Core Data 生成的 SQLite
数据库文件，一定会见过其中包含不少奇怪的表和字段。本文将对这些表和字段进行介绍，或许可以换个角度帮助你解开部分疑惑，例如： Core Data
为什么不需要主键、NSManagedObjectID 是如何构成的、保存冲突的判断依据是什么。

## 如何获取 Core Data 的 SQLite 数据库文件

可以通过以下集中方法获取到 Core Data 生成的 SQLite 数据库文件：

- 直接获取文件的存储地址

在代码中（ 通常放置在 Core Data Stack 中，更多有关 Stack 的信息，请参阅 [ 掌握 Core Data Stack
](/zh/posts/masteringofcoredatastack/) ）直接打印持久化存储的保存位置，是最直接、高效的获取手段：

    container.loadPersistentStores(completionHandler: { _, error in
        if let error = error as NSError? {
            fatalError("Unresolved error \(error), \(error.userInfo)")
        }
    })

    #if DEBUG
    // 如果你有多个存储，且保存在不同的目录，需依次将其打印出来
    if let url = container.persistentStoreCoordinator.persistentStores.first?.url {
        print(url)
    }
    #endif

![image-20220528103822780](https://cdn.fatbobman.com/image-20220528103822780.png)

在 Finder 中通过快捷键（ ⇧⌘ G ）或菜单命令（ 前往文件夹 ）可以直接到达文件所在的位置。

![image-20220528103959218](https://cdn.fatbobman.com/image-20220528103959218.png)

- 启用调试参数

如果你在项目中开启了 Core Data 的调试信息输出，那么可以直接在调试信息的顶部找到数据库的路径地址。

    -com.apple.CoreData.CloudKitDebug 1

> 更多有关调试参数的内容，请参阅 [ Core Data with CloudKit（四）—— 调试、测试、迁移及其他
> ](/zh/posts/coredatawithcloudkit-4/#%E5%85%B3%E9%97%AD%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA)

- 通过断点查找

在应用执行过程中，通过任意断点暂停程序的执行，在调试窗口中输入如下命令，即可获得应用在沙盒中的根路径。

    po NSHomeDirectory()

- 第三方工具

一些第三方工具（例如 RocketSim）提供了直接访问模拟器中 App 目录的功能。

![rocketSim_get_URL](https://cdn.fatbobman.com/rocketSim_get_URL.png)

> 读者最好能在打开一个由 Core Data 生成的 SQLite 数据库文件的情况下继续阅读接下来的内容

## 基础的表与字段

所谓基础的表与字段是指，在没有启用其他附加功能（持久化历史跟踪、Core Data With CloudKit）的情况下，Core Data
为了满足基本功能而在 SQLite 数据库中创建的表（ 非实体表 ）和在实体表中创建的特殊字段。

### 实体对应的表

下图为使用 Xcode Core Data 模板创建的项目的数据库结构（仅定义了一个实体 Item，且 Item 只有一个属性 timestamp
），其中实体 Item 在 SQLite 中对应的表是 ZITEM 。

![tableAndFieldInCoreData_tableList1](https://cdn.fatbobman.com/tableAndFieldInCoreData_tableList1.png)

Core Data 按照如下规则将数据模型中的实体转换成 SQLite 的格式：

- 实体对应的表名为 Z + 实体名称（全部大写），本例中为 ZITEM

- 实体中属性对应的字段为 Z + 属性名称（全部大写），本例中为 ZTIMESTAMP

- 对于大写后名称一致的属性（属性在定义时是大小写敏感的），将为其他重名属性添加编号。如 Item 有两个属性 timestamp 和 timeStamp ，将在表中创建两个字段 ZTIMESTAMP 及 ZTIMESTAMP 1

- 为每个实体表添加三个特殊字段： Z_PK、Z_ENT、Z_OPT（均为 INTEGER 类型）

- 如实体定义中包含关系，在实体表中为关系创建对应的字段或创建对应的中间关系表（详细内容见后文）

#### Z_ENT 字段

每个实体表均在 Z_PRIMARYKEY 表（下文详述）中进行了登记。该字段与登记记录的 Z_ENT 一致。可以将其视为表的 ID 。

#### Z_PK 字段

从 1 开始递增的整数，可以将其视为表的主键。Z_PK + Z_ENT （ 主键 + 表 ID ）是 Core Data 在特定 SQLite
数据文件中查找具体条目的关键。

#### Z_OPT 字段

数据记录版本号。每一次对数据的修改，均会导致该值加一。

### Z_PRIMARYKEY 表

Z_PRIMARYKEY 表是实现通过 Z_PK + Z_ENT 定位数据的基础。它的主要作用有：

- 对 Core Data 在 SQLite 中创建的表（所有需要通过 Z_PK + Z_ENT 定位记录的表，不包括 Z_PRIMARYKEY、Z_METADATA、Z_MODELCACHE）进行登记
- 标注实体之间的关系（仅针对抽象实体）
- 记录实体的名称（数据模型中定义的名称）
- 记录每个登记表当前已使用的最大 Z_PK 值

#### Z_ENT

表的 ID。实体表会从编号 1 开始，而为其他系统功能创建的表会从编号 16000 开始。下图展示了实体 Memo 表中的 Z_ENT 与 Memo 在
Z_PRIMARYKEY 表中记录的 Z_Ent 字段的对应关系。

![tableAndFieldInCoreData_z_ent_1](https://cdn.fatbobman.com/tableAndFieldInCoreData_z_ent_1.png)

![tableAndFieldInCoreData_z_ent_2](https://cdn.fatbobman.com/tableAndFieldInCoreData_z_ent_2.png)

#### Z_NAME 字段

实体在数据模型中的名称（大小写敏感），用于从 URL 反向查找对应数据（ 具体应用见下文 ）。

#### Z_SUPER 字段

如果实体为某个实体（ [ Abstract Entity
](https://developer.apple.com/documentation/coredata/modeling_data/configuring_entities)
）的子实体，该值对应其父实体的 Z_ENT 。0 表示该实体没有父实体。下图展示了当 Item 为抽象实体，ItemSub 为它的子实体时 Z_SUPER
的情况。

![tableAndFieldInCoreData_z_super_1](https://cdn.fatbobman.com/tableAndFieldInCoreData_z_super_1.png)

![tableAndFieldInCoreData_z_super_2](https://cdn.fatbobman.com/tableAndFieldInCoreData_z_super_2.png)

#### Z_MAX 字段

标记了每个登记表最后使用的 Z_PK 值。在创建新的实体数据时，Core Data 将从 Z_PRIMARYKEY 表中找到对应实体最后使用的 Z_PK
值（ Z_MAX ），在此值基础上加一，作为新记录的 Z_PK 值，并更新该实体对应的 Z_MAX 值。

### Z_METADATA 表

Z_METADATA 表中记录了与当前 SQLite 文件有关的信息，包括：版本、标识符以及其他元数据。

#### Z_UUID 字段

当前数据库文件的 ID 标识（ UUID 类型）。可以通过托管对象协调器获取该值。在将 NSManagedObjectID 转换成可存储的 URL
时，该值表示对应的持久化存储。

#### Z_PLIST 字段

采用 Plist 的格式存储的有关持久化存储的元数据（ 不包含持久化存储的 UUID 标识
）。可以通过持久化存储协调器来读取或添加数据。如有需要，开发者还可以在其中保存与数据库无关的数据（ 可以将其视为通过 Core Data
的数据库文件保存程序配置的另类用法 ）。

    let coordinate = container.persistentStoreCoordinator
    guard let store = coordinate.persistentStores.first else {
        fatalError()
    }
    var metadata = coordinate.metadata(for: store) // 获取元数据（ Z_PLIST + Z_UUID ）
    metadata["Author"] = "fat" // 添加新的元数据
    store.metadata = metadata

    try! container.viewContext.save() // 除了在创建新的持久化存储时添加 metadata 外，其他情况下添加的数据都需要显式调用上下文的 save 方法来完成持久化

下图为将 Z_PLIST 中的数据（ BLOB 格式 ）导出成 Plist 格式后的情况：

![tableAndFieldInCoreData_z_plist](https://cdn.fatbobman.com/tableAndFieldInCoreData_z_plist.png)

#### Z_VERSION 字段

具体作用未知（估计为 Core Data 的 SQLite 格式版本），当前始终为 1 。

### Z_MODELCACHE 表

尽管 Core Data 在 Z_METADATA 表中的 Z_PLIST 中保留了当前使用的数据模型版本的签名信息，但由于 Z_PLIST
的内容是可更改的，因此为了确保应用正在使用的数据模型版本与 SQLite 文件中的完全一致，Core Data 在 Z_MODELCACHE
表中保存了一份与当前 SQLite 数据对应的数据模型的缓存版本 （某种 mom 或 omo 的变体）。

Z_MODELCACHE 中的缓存数据和元数据中的数据模型签名共同为数据模型的版本验证和版本迁移提供了保障。

## 从数据库结构中得到的收获

在对 SQLite 的表和字段有了一定的了解后，一些困扰 Core Data 开发者的问题或许就会得到有效的解释。

### 为什么不需要主键

Core Data 通过实体表对应的 Z_MAX 自动为每条新增记录添加了自增主键数据。因此在 Core Data
定义数据模型时，开发者无须为实体特别定义主键属性（事实上也无法创建自增主键）。

### NSManagedObjectID 的构成

托管对象的 NSManagedObjectID 由：数据库 ID + 表 ID + 实体表中的主键共同构成。在 SQLite 中对应的字段为 Z_UUID

- Z_ENT + Z_PK 。通过将 NSManagedObjectID 转换成可存储格式的 URL ，可以将它的构成清晰地展示出来。

  let url = itemSub.objectID.uriRepresentation()

![tableAndFieldInCoreData_nsmanagedObjectID_url](https://cdn.fatbobman.com/tableAndFieldInCoreData_nsmanagedObjectID_url.png)

【 文件（持久化存储）+ 表 + 行 】的信息组合也将帮助 Core Data 实现从 URL 转换为对应的托管对象。

    let url = URL(string:"x-coredata://E8B22CEA-8316-45E7-BC08-3FBA516F962C/ItemSub/p1")!

    if let objectID = container.persistentStoreCoordinator.managedObjectID(forURIRepresentation: url) {
        if let itemSub = container.viewContext.object(with: objectID) as? ItemSub {
            ...
        }
    }

> 更多有关从 URL 转换成托管对象的内容请参阅 [ 在 Spotlight 中展示应用中的 Core Data 数据
> ](/zh/posts/spotlight/#oncontinueuseractivity) 。

### 如何在数据库中标识关系

Core Data 利用了在同一个数据库中仅需依靠 Z_ENT + Z_PK
即可定位记录的特性来实现了在不同的实体之间标注关系的工作。为了节省空间，Core Data 仅保存了每个关系记录的 Z_PK 数据，Z_ENT
则直接由数据模型从 Z_PRIMARYKEY 表中获取。

在数据库中创建关系的规则为：

- 一对多

“一”的一侧不创建新的字段，在“多”的一侧为关系创建新的字段，该字段对应“一”的 Z_PK 值。字段名称为 Z + 关系名称（大写）

- 一对一

关系两端都添加新的字段，分别为对应数据的 Z_PK 值

- 多对多

关系两端都不添加新的字段，创建一个表示该多对多关系的新表，并在其中逐行添加关系两侧数据的 Z_PK 值。

下图中，Item 与 Tag 为多对多关系，Core Data 创建了 Z_2 TAGS 表来管理该关系数据。

![image-20220528162005978](https://cdn.fatbobman.com/image-20220528162005978.png)

> 在启用了抽象实体的情况下，除了记录对应关系数据的 Z_PK 值外，还会添加一个字段以记录该数据具体属于哪个 Z_ENT （ 父实体或某个子实体）。

### 保存冲突的判断

Core Data 在保存数据时，通过乐观锁的方式来判断是否会出现保存冲突的情况。而乐观锁的判断依据则是根据每条记录的 Z_OPT 数据，采用了版本号机制。

在数据进行持久化时，如果 Core Data 发现上下文的数据快照中的 Z_OPT 数据与行缓存中的不一致，或者行缓存中的 Z_OPT
与数据库文件不一致，均会认为是发生了保存冲突。

> 更多有关保存冲突的内容，请参阅 [ 关于 Core Data 并发编程的几点提示
> ](/zh/posts/concurrencyofcoredata/#%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5)
> 。

## 用于持久化历史跟踪的表

在 CoreData 中，如果你的数据保存形式是
SQLite（绝大多数的开发者都采用此种方式）且启用了持久化历史跟踪功能，无论数据库中的数据有了何种变化（删除、添加、修改等），调用此数据库并注册了该通知的应用，都会收到一个“数据库有变化”的系统提醒。

近几年随着 App Group、小组件、Core Data with CloudKit 、Core Data in Spotlight
等功能的应用，越来越多的 Core Data 应用中都主动或被动地开启了持久化历史跟踪选项。在启用了该功能后（ `desc.setOption(true
as NSNumber,forKey: NSPersistentHistoryTrackingKey)` ），Core Data 会在 SQLite
中新建三张表来管理和记录事务，并且会在 Z_PRIMARYKEY 表中登记这三张表的信息。

> 更多详细的有关持久化历史跟踪的内容，请参阅 [ 在 CoreData 中使用持久化历史跟踪
> ](/zh/posts/persistenthistorytracking/) 。

![tableAndFieldInCoreData_persistent_history_tracing_tables](https://cdn.fatbobman.com/tableAndFieldInCoreData_persistent_history_tracing_tables.png)

![image-20220528172620831](https://cdn.fatbobman.com/image-20220528172620831.png)

### Z_ATRANSACTIONSTRING 表

为了能够分辨事务（ Transaction ）的来源，事务的产生者需要为托管对象上下文设置事务作者，Core Data 将所有的事务作者的信息都汇总在
Z_ATRANSACTIONSTRING 表中。

    container.viewContext.transactionAuthor = "fatbobman"

如果开发者也为上下文也设置了名称，那么 Core Data 也将为该上下文名称创建一条记录

    container.viewContext.name = "viewContext"

![tableAndFieldInCoreData_atransactionString](https://cdn.fatbobman.com/tableAndFieldInCoreData_atransactionString.png)

Core Data 还会为一些其他的系统功能创建默认的作者记录。在处理事务时，应忽略这些系统作者产生的事务。

> Z_PK 和 Z_ENT 的含义与上文中一致，后文将不再赘述

### Z_ATRANSACTION 表

你可以将持久化历史跟踪的事务理解为在 Core Data 中的某一次持久化过程（比如调用上下文的 save 方法）。Core Data
将与某次事务有关的信息保存在 Z_ATRANSACTION 表中。其中最为关键的信息是事务创建的时间和事务作者。

![image-20220528174541292](https://cdn.fatbobman.com/image-20220528174541292.png)

#### ZAUTHORTS 字段

对应 Z_ATRANSACTIONSTRING 表中的事务作者的 Z_PK 。上图中对应的是 Z_ATRANSACTIONSTRING 中的 Z_PK 为
1 的 fatbobman 。

#### ZCONTEXTNAMETS 字段

如果为创建事务的上下文设置了名称，则该字段对应上下文名称在 Z_ATRANSACTIONSTRING 表中的记录的 Z_PK 。上图对应的是
viewContext 。

#### ZTIMESTAMP 字段

事务的创建时间。

#### ZQUERYGEN 字段

如果为托管对象上下文设置了锁定查询令牌（ [ NSQueryGenerationToken
](https://developer.apple.com/documentation/coredata/nsquerygenerationtoken)
），那么事务记录中还会将当时的查询令牌保存在 ZQUERYGEN 字段中 ( BLOB 类型 )。

    try? container.viewContext.setQueryGenerationFrom(.current)

### Z_ACHANGE 表

在一次事务中，通常会包含若干个数据操作（创建、更改、删除）。Core Data 将每个数据操作都保持在 Z_CHANGE 表中，并通过 Z_PK
与特定的事务进行关联。

![tableAndFieldInCoreData_change](https://cdn.fatbobman.com/tableAndFieldInCoreData_change.png)

#### ZCHANGETYPE 字段

数据操作类型：0 新建 1 更新 2 删除

#### ZENTITY 字段

操作对应的实体表的 Z_ENT

#### ZENTITYPK 字段

操作对应的数据记录在实体表中的 Z_PK

#### ZTRANSACTIONID 字段

操作对应的事务在 Z_ATRANSACTION 表中的 Z_PK

### 从 SQLite 角度认识持久化历史跟踪

#### 创建事务

在持久化历史跟踪中，创建事务的工作是由 Core Data 自动完成的，大概的流程如下：

- 从 Z_PRIMARYKEY 表中获取 Z_ATRANSACTION 的 Z_MAX
- 使用 Z_PK （ Z_MAX + 1 ） + Z_ENT ( 事务表在 Z_PRIMARYKEY 中对应的 Z_ENT ) + 作者 ID + 时间戳在 Z_ATRANSACTION 中创建新事务记录，并更新 Z_MAX
- 获取 Z_ACHANGE 的 Z_MAX
- 在 Z_ACHANGE 中逐条创建数据操作记录

#### 查询事务

因为数据库中只保存了事务创建的时间戳，因此无论采用哪种查询方式（时间 Date、令牌 NSPersistentHistoryToken、事务
NSPersistentHistoryTransaction ）最终都会转换成比较时间戳的方式。

- 时间戳晚于上次当前应用的查询时间
- 作者不是当前 App 的作者或其他系统功能作者
- 获取满足上述条件的全部 Z_CHANGE 记录

#### 合并事务

事务中提取的数据操作记录（ Z_ACHANGE ）中包含了完整的操作类型、对应的实例数据位置等信息，按图索骥从数据库中提取实体数据（ Z_PK +
Z_ENT ）并将其合并（ 转换成 NSManagedObjectID ）到指定的上下文中。

#### 删除事务

- 查询并提取时间戳早于全部作者（ 包含当前应用作者，但不包含系统功能作者 ）的最后查询时间的事务
- 删除上述事务（ Z_ATRANSACTION ）及其对应的操作数据（ Z_ACHANGE ）。

> 了解上述过程对理解 [ Persistent History Tracking Kit
> ](https://github.com/fatbobman/PersistentHistoryTrackingKit) 的代码很有帮助

## 其他

如果你的应用使用了 [ Core Data with CloudKit ](/zh/posts/coredatawithcloudkit-1/)
，那么在浏览 SQLite 数据结构时你将获得进一步的惊喜（😱）。Core Data 将创建更多的表来处理与 CloudKit
的同步事宜。考虑到表的复杂性和篇幅，就不继续展开了。不过有了上文的基础，了解它们的用途也并非很困难。

下图为开启了私有数据库同步功能后 SQLite 中新增的系统表：

![image-20220528201143040](https://cdn.fatbobman.com/image-20220528201143040.png)

这些表主要记载了：CloudKit 私有域信息、上次同步时间、上次同步令牌、导出操作日志、导入操作日志、待导出数据、Core Data 关系与
CloudKit 关系对照表、本地数据对应的 CKRecordName、本地数据的 CKRecord 完整镜像（ 共享公共数据库 ）等等信息。

随着 Core Data 功能的不断增加，将来可能会看到更多的系统功能表。

## 总结

撰写本文的主要目的是对我近段时间来的零散研究进行汇总，方便日后查询。因此即便你已经完全掌握了 Core Data
的外部存储结构，但最好还是尽量不要直接对数据库进行操作，苹果可能在任何时刻改变它的底层实现。

# 如何判断 ScrollView、List 是否正在滚动中

判断一个可滚动控件（ ScrollView、List ）是否处于滚动状态在某些场景下具有重要的作用。比如在 [ SwipeCell
](https://github.com/fatbobman/SwipeCell)
中，需要在可滚动组件开始滚动时，自动关闭已经打开的侧滑菜单。遗憾的是，SwiftUI 并没有提供这方面的 API 。本文将介绍几种在 SwiftUI
中获取当前滚动状态的方法，每种方法都有各自的优势和局限性。

![isScrolling_2022-09-12_10.26.06.2022-09-12
10_28_09](https://cdn.fatbobman.com/isScrolling_2022-09-12_10.26.06.2022-09-12%2010_28_09.gif)

## 方法一：Introspect

> 可在 [ 此处 ](https://github.com/fatbobman/BlogCodes/tree/main/ScrollStatus)
> 获取本节的代码

在 UIKit（ AppKit ）中，开发者可以通过 Delegate 的方式获知当前的滚动状态，主要依靠以下三个方法：

- `scrollViewDidScroll(_ scrollView: UIScrollView)`

开始滚动时调用此方法

- `scrollViewDidEndDecelerating(_ scrollView: UIScrollView)`

手指滑动可滚动区域后（ 此时手指已经离开 ），滚动逐渐减速，在滚动停止时会调用此方法

- `scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool)`

手指拖动结束后（ 手指离开时 ），调用此方法

在 SwiftUI 中，很多的视图控件是对 UIKit（ AppKit ）控件的二次包装。因此，我们可以通过访问其背后的 UIKit 控件的方式（ 使用 [
Introspect ](https://github.com/siteline/SwiftUI-Introspect) ）来实现本文的需求。

    final class ScrollDelegate: NSObject, UITableViewDelegate, UIScrollViewDelegate {
        var isScrolling: Binding<Bool>?

        func scrollViewDidScroll(_ scrollView: UIScrollView) {
            if let isScrolling = isScrolling?.wrappedValue,!isScrolling {
                self.isScrolling?.wrappedValue = true
            }
        }

        func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
            if let isScrolling = isScrolling?.wrappedValue, isScrolling {
                self.isScrolling?.wrappedValue = false
            }
        }

        // 手指缓慢拖动可滚动控件，手指离开后，decelerate 为 false，因此并不会调用 scrollViewDidEndDecelerating 方法
        func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
            if !decelerate {
                if let isScrolling = isScrolling?.wrappedValue, isScrolling {
                    self.isScrolling?.wrappedValue = false
                }
            }
        }
    }

    extension View {
        func scrollStatusByIntrospect(isScrolling: Binding<Bool>) -> some View {
            modifier(ScrollStatusByIntrospectModifier(isScrolling: isScrolling))
        }
    }

    struct ScrollStatusByIntrospectModifier: ViewModifier {
        @State var delegate = ScrollDelegate()
        @Binding var isScrolling: Bool
        func body(content: Content) -> some View {
            content
                .onAppear {
                    self.delegate.isScrolling = $isScrolling
                }
                // 同时支持 ScrollView 和 List
                .introspectScrollView { scrollView in
                    scrollView.delegate = delegate
                }
                .introspectTableView { tableView in
                    tableView.delegate = delegate
                }
        }
    }

调用方法：

    struct ScrollStatusByIntrospect: View {
        @State var isScrolling = false
        var body: some View {
            VStack {
                Text("isScrolling: \(isScrolling1 ? "True" : "False")")
                List {
                    ForEach(0..<100) { i in
                        Text("id:\(i)")
                    }
                }
                .scrollStatusByIntrospect(isScrolling: $isScrolling)
            }
        }
    }

### 方案一优点

- 准确
- 及时
- 系统负担小

### 方案一缺点

- 向后兼容性差

SwiftUI 随时可能会改变控件的内部实现方式，这种情况已经多次出现。目前 SwiftUI 在内部的实现上去 UIKit（ AppKit
）化很明显，比如， **本节介绍的方法在 SwiftUI 4.0 中已经失效**

## 方法二：Runloop

> 我第一次接触 Runloop 是在学习 Combine 的时候，直到我碰到 Timer 的闭包并没有按照预期被调用时才对其进行了一定的了解

Runloop 是一个事件处理循环。当没有事件时，Runloop 会进入休眠状态，而有事件时，Runloop 会调用对应的 Handler。

Runloop 与线程是绑定的。在应用程序启动的时候，主线程的 Runloop 会被自动创建并启动。

Runloop 拥有多种模式（ Mode ），它只会运行在一个模式之下。如果想切换 Mode，必须先退出 loop 然后再重新指定一个 Mode 进入。

在绝大多数的时间里，Runloop 都处于 kCFRunLoopDefaultMode（ default
）模式中，当可滚动控件处于滚动状态时，为了保证滚动的效率，系统会将 Runloop 切换至 UITrackingRunLoopMode（ tracking
）模式下。

本节采用的方法便是利用了上述特性，通过创建绑定于不同 Runloop 模式下的 TimerPublisher ，实现对滚动状态的判断。

    final class ExclusionStore: ObservableObject {
        @Published var isScrolling = false
        // 当 Runloop 处于 default（ kCFRunLoopDefaultMode ）模式时，每隔 0.1 秒会发送一个时间信号
        private let idlePublisher = Timer.publish(every: 0.1, on: .main, in: .default).autoconnect()
        // 当 Runloop 处于 tracking（ UITrackingRunLoopMode ）模式时，每隔 0.1 秒会发送一个时间信号
        private let scrollingPublisher = Timer.publish(every: 0.1, on: .main, in: .tracking).autoconnect()

        private var publisher: some Publisher {
            scrollingPublisher
                .map { _ in 1 } // 滚动时，发送 1
                .merge(with:
                    idlePublisher
                        .map { _ in 0 } // 不滚动时，发送 0
                )
        }

        var cancellable: AnyCancellable?

        init() {
            cancellable = publisher
                .receive(on: DispatchQueue.main)
                .sink(receiveCompletion: { _ in }, receiveValue: { output in
                    guard let value = output as? Int else { return }
                    if value == 1,!self.isScrolling {
                        self.isScrolling = true
                    }
                    if value == 0, self.isScrolling {
                        self.isScrolling = false
                    }
                })
        }
    }

    struct ScrollStatusMonitorExclusionModifier: ViewModifier {
        @StateObject private var store = ExclusionStore()
        @Binding var isScrolling: Bool
        func body(content: Content) -> some View {
            content
                .environment(\.isScrolling, store.isScrolling)
                .onChange(of: store.isScrolling) { value in
                    isScrolling = value
                }
                .onDisappear {
                    store.cancellable = nil // 防止内存泄露
                }
        }
    }

### 方案二优点

- 具备与 Delegate 方式几乎一致的准确性和及时性
- 实现的逻辑非常简单

### 方案二缺点

- 只能运行于 iOS 系统

在 macOS 下的 eventTracking 模式中，该方案的表现并不理想

- 屏幕中只能有一个可滚动控件

由于任意可滚动控件滚动时，都会导致主线程的 Runloop 切换至 tracing 模式，因此无法有效地区分滚动是由那个控件造成的

## 方法三：PreferenceKey

在 SwiftUI 中，子视图可以通过 preference 视图修饰器向其祖先视图传递信息（ PreferenceKey ）。preference 与
onChange 的调用时机非常类似，只有在值发生改变后才会传递数据。

在 ScrollView、List 发生滚动时，它们内部的子视图的位置也将发生改变。我们将以是否可以持续接收到它们的位置信息为依据判断当前是否处于滚动状态。

    final class CommonStore: ObservableObject {
        @Published var isScrolling = false
        private var timestamp = Date()

        let preferencePublisher = PassthroughSubject<Int, Never>()
        let timeoutPublisher = PassthroughSubject<Int, Never>()

        private var publisher: some Publisher {
            preferencePublisher
                .dropFirst(2) // 改善进入视图时可能出现的状态抖动
                .handleEvents(
                    receiveOutput: { _ in
                        self.timestamp = Date()
                        // 如果 0.15 秒后没有继续收到位置变化的信号，则发送滚动状态停止的信号
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
                            if Date().timeIntervalSince(self.timestamp) > 0.1 {
                                self.timeoutPublisher.send(0)
                            }
                        }
                    }
                )
                .merge(with: timeoutPublisher)
        }

        var cancellable: AnyCancellable?

        init() {
            cancellable = publisher
                .receive(on: DispatchQueue.main)
                .sink(receiveCompletion: { _ in }, receiveValue: { output in
                    guard let value = output as? Int else { return }
                    if value == 1,!self.isScrolling {
                        self.isScrolling = true
                    }
                    if value == 0, self.isScrolling {
                        self.isScrolling = false
                    }
                })
        }
    }

    public struct MinValueKey: PreferenceKey {
        public static var defaultValue: CGRect = .zero
        public static func reduce(value: inout CGRect, nextValue: () -> CGRect) {
            value = nextValue()
        }
    }

    struct ScrollStatusMonitorCommonModifier: ViewModifier {
        @StateObject private var store = CommonStore()
        @Binding var isScrolling: Bool
        func body(content: Content) -> some View {
            content
                .environment(\.isScrolling, store.isScrolling)
                .onChange(of: store.isScrolling) { value in
                    isScrolling = value
                }
            // 接收来自子视图的位置信息
                .onPreferenceChange(MinValueKey.self) { _ in
                    store.preferencePublisher.send(1) // 我们不关心具体的位置信息，只需将其标注为滚动中
                }
                .onDisappear {
                    store.cancellable = nil
                }
        }
    }

    // 添加与 ScrollView、List 的子视图之上，用于在位置发生变化时发送信息
    func scrollSensor() -> some View {
        overlay(
            GeometryReader { proxy in
                Color.clear
                    .preference(
                        key: MinValueKey.self,
                        value: proxy.frame(in: .global)
                    )
            }
        )
    }

### 方案三优点

- 支持多平台（ iOS、macOS、macCatalyst ）
- 拥有较好的前后兼容性

### 方案三缺点

- 需要为可滚动容器的子视图添加修饰器

对于 ScrollView + VStack（ HStack ）这类的组合，只需为可滚动视图添加一个 scrollSensor 即可。对于
List、ScrollView + LazyVStack（ LazyHStack ）这类的组合，需要为每个子视图都添加一个 scrollSensor。

- 判断的准确度没有前两种方式高

当可滚动组件中的内容出现了非滚动引起的尺寸或位置的变化（ 例如 List 中某个视图的尺寸发生了动态变化
），本方式会误判断为发生了滚动，但在视图的变化结束后，状态会马上恢复到滚动结束

滚动开始后（ 状态已变化为滚动中 ），保持手指处于按压状态并停止滑动，此方式会将此时视为滚动结束，而前两种方式仍会保持滚动中的状态直到手指结束按压

## IsScrolling

我将后两种解决方案打包做成了一个库 —— [ IsScrolling ](https://github.com/fatbobman/IsScrolling)
以方便大家使用。其中 exclusion 对应着 Runloop 原理、common 对应着 PreferenceKey 解决方案。

使用范例（ exclusion ）：

    struct VStackExclusionDemo: View {
        @State var isScrolling = false
        var body: some View {
            VStack {
                ScrollView {
                    VStack {
                        ForEach(0..<100) { i in
                            CellView(index: i) // no need to add sensor in exclusion mode
                        }
                    }
                }
                .scrollStatusMonitor($isScrolling, monitorMode: .exclusion) // add scrollStatusMonitor to get scroll status
            }
        }
    }

使用范例（ common ）：

    struct ListCommonDemo: View {
        @State var isScrolling = false
        var body: some View {
            VStack {
                List {
                    ForEach(0..<100) { i in
                        CellView(index: i)
                            .scrollSensor() // Need to add sensor for each subview
                    }
                }
                .scrollStatusMonitor($isScrolling, monitorMode: .common)
            }
        }
    }

## 总结

SwiftUI 仍在高速进化中，很多积极的变化并不会立即体现出来。待 SwiftUI 更多的底层实现不再依赖 UIKit（ AppKit ）之时，才会是它
API 的爆发期。

希望本文能够对你有所帮助。同时也欢迎你通过 [ Twitter ](https://twitter.com/fatbobman) 、 [ Discord
频道 ](https://discord.gg/ApqXmy5pQJ) 或博客的留言板与我进行交流。

# Core Data with CloudKit（二） —— 同步本地数据库到 iCloud 私有数据库

本篇文章中，我们将探讨 `Core Data with CloudKit` 应用中最常见的场景——将本地数据库同步到 `iCloud`
私有数据库。我们将从几个层面逐步展开：

- 在新项目中直接支持 `Core Data with CloudKit`
- 创建可同步 `Model` 的注意事项
- 在现有项目 `Core Date` 中添加 `Host in CloudKit` 支持
- 有选择的同步数据

> 本文使用的开发环境为 `Xcode 12.5` 。关于私有数据库的概念，请参阅 [ Core Data with CloudKit （一） ——
> 基础 ](/zh/posts/coredatawithcloudkit-1/) 。如想实际操作本文内容，需要拥有 [ Apple Developer
> Program ](https://developer.apple.com/programs/) 账号。

## 快速指南

在应用程序中启用 `Core Data with CloudKit` 功能，只需要以下几步：

1. 使用 `NSPersistentCloudKitContainer`
2. 在 `项目 Target` 的 `Signing&Capablities` 中添加 `CloudKit` 支持
3. 为项目创建或指定 `CloudKit container`
4. 在 `项目 Target` 的 `Signing&Capablities` 中添加 `background` 支持
5. 配置 `NSPersistentStoreDescription` 以及 `viewContext`
6. 检查 `Data Model` 是否满足同步的要求

## 在新项目中直接支持 Core Data with CloudKit

在最近几年苹果不断完善 `Xcode` 的 `Core Data 模版` ，直接使用自带模版来新建一个支持 `Core Data with
CloudKit` 的项目是最便捷的入手方式。

### 创建新的 Xcode 项目

创建新项目，在项目设置界面勾选 `Use Core Data` 及 `Host in CloudKit` （早期版本为 `Use CloudKit` ），并设置开发团队（ `Team` ）

![image-20210806180200853](https://cdn.fatbobman.com/image-20210806180200853-8244122.png)

设定保存地址后，Xcode 将使用预置模版为你生成包含 `Core Data with CloudKit` 支持的项目文档。

> Xcode 可能会提醒新项目代码有错误，如果觉得烦只需要 Build 一下项目即可取消错误提示（生成 NSManagoedObject
> Subclass）

接下来，我们根据 **快速指南** 逐步操作。

### 设置 PersistentCloudKitContainer

`Persistence.swift` 是官方模版创建的 `Core Data Stack` 。由于在创建项目的时候已经选择了 `Host in
CloudKit` ，因此模版代码已直接使用 `NSPersistentCloudKitContianer` 替代 `NSPersistentContianer` ，无需进行修改。

    let container: NSPersistentCloudKitContainer

### 启用 CloudKit

点击项目中对应的 `Target` ，选择 `Signing&Capabilities` 。点击 `+Capability` 查找 `icloud` 添加 `CloudKit` 支持。

![image-20210806185136390](https://cdn.fatbobman.com/image-20210806185136390-8247097.png)

![image-20210806185247739](https://cdn.fatbobman.com/image-20210806185247739-8247169.png)

勾选 `CloudKit` 。点击 `+` ，输入 `CloudKit container` 名称。Xcode 会在你 `CloutKit
container` 名称的前面自动添加 `iCloud.` 。 `container` 的名称通常采用反向域名的方式，无需和项目或 `BundleID` 一致。 _如果没有配置开发者团队，将无法创建`container` 。 _

![image-20210808091434886](https://cdn.fatbobman.com/image-20210808091434886.png)

_在添加了`CloudKit` 支持后，Xcode 会自动为你添加 `Push Notifications` 功能，原因我们在上一篇聊过。 _

### 启用后台通知

继续点击 `+Capability` ，搜索 `backgroud` 并添加，勾选 `Remote notifications`

![image-20210806190813361](https://cdn.fatbobman.com/image-20210806190813361-8248094.png)

此功能让你的应用程序能够响应云端数据内容变化时推送的 **静默通知** 。

### 配置 NSPersistentStoreDescription 和 viewContext

查看当前项目中的 `.xcdatamodeld` 文件， `CONFIGURATIONS` 中只有一个默认配置 `Default`
，点击可以看到，右侧的 `Used with CloudKit` 已经被勾选上了。

![image-20210806193028530](https://cdn.fatbobman.com/image-20210806193028530-8249430.png)

如果开发者没有在 `Data Model Editor` 中自定义 `Configuration` ，如果勾选了 `Used with
CloudKit` ， `Core Data` 会使用选定的 `Cloudkit container` 设置
“cloudKitContainerOptions `。因此在当前的` Persistence.swift `代码中，我们无需对`
NSPersistentStoreDescription `做任何额外设置（我们会在后面的章节介绍如何设置`
NSPersistentStoreDescription`）。

在 `Persistence.swift` 对上下文做如下配置：

    container.loadPersistentStores(completionHandler: { (storeDescription, error) in
           if let error = error as NSError? {
                  ...
                    fatalError("Unresolved error \(error), \(error.userInfo)")
            }
    })
    //添加如下代码
    container.viewContext.automaticallyMergesChangesFromParent = true
    container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
    do {
          try container.viewContext.setQueryGenerationFrom(.current)
    } catch {
         fatalError("Failed to pin viewContext to the current generation:\(error)")
    }

`container.viewContext.automaticallyMergesChangesFromParent = true`
让视图上下文自动合并服务器端同步（ `import` ）来的数据。使用 `@FetchRequest` 或 `NSFetchedResultsController` 的视图可以将数据变化及时反应在 UI 上。

`container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy` 设定合并冲突策略。如果不设置该属性， `Core Data` 会默认使用 `NSErrorMergePolicy`
作为冲突解决策略（所有冲突都不处理，直接报错），这会导致 `iCloud` 的数据无法正确合并到本地数据库。

`Core Data` 预设了四种合并冲突策略，分别为：

- NSMergeByPropertyStoreTrumpMergePolicy

逐属性比较，如果持久化数据和内存数据都改变且冲突，持久化数据胜出

- NSMergeByPropertyObjectTrumpMergePolicy

逐属性比较，如果持久化数据和内存数据都改变且冲突，内存数据胜出

- NSOverwriteMergePolicy

内存数据永远胜出

- NSRollbackMergePolicy

持久化数据永远胜出

对于 `Core Data with CloudKit` 这样的使用场景，通常会选择 `NSMergeByPropertyObjectTrumpMergePolicy` 。

`setQueryGenerationFrom(.current)`
这个是在最近才出现在苹果的文档和例程中的。目的是避免在数据导入期间应用程序产生的数据变化和导入数据不一致而可能出现的不稳定情况。尽管在我两年多的使用中，基本没有遇到过这种情况，但我还是推荐大家在代码中增加上下文快照的锁定以提高稳定性。

> 直到 `Xcode 13 beta4` 苹果仍然没有在预置的 `Core Data with CloudKit`
> 模版中添加上下文的设置，这导致使用原版模版导入数据的行为会和预期有出入，对初学者不很友好。

### 检查 Data Model 是否满足同步的要求

模版项目的 Data Model 非常简单，只有一个 `Entity` 且只有一个 `Attribute` ，当下无需做调整。 `Data
Model` 的同步适用规则会在下个章节详细介绍。

![image-20210806204211377](https://cdn.fatbobman.com/image-20210806204211377-8253732.png)

### 修改 ContentView. swift

> **提醒** ：模版生成的 ContentView. swift 是不完整的，需修改后方能正确显示。

        var body: some View {
            NavigationView { // 添加 NavigationView
                List {
                    ForEach(items) { item in
                        Text("Item at \(item.timestamp!, formatter: itemFormatter)")
                    }
                    .onDelete(perform: deleteItems)
                }
                .toolbar {
                    HStack { // 添加 HStack
                        EditButton()
                        Button(action: addItem) {
                            Label("Add Item", systemImage: "plus")
                        }
                    }
                }
            }
        }

修改后，可以正常显示 Toolbar 按钮了。

至此，我们已经完成了一个支持 `Core Data with CloudKit` 的项目了。

### 运行

在模拟器上或实机上 **设置并登录相同的`iCloud` 账户 ** ，只有同一个账户才能访问同一个 `iCloud` 私有数据库。

下面的动图，是在一台实机（ `Airplay` 投屏）和一个模拟器上的运行效果。

![syncToPrivateDB](https://cdn.fatbobman.com/syncToPrivateDB-8292698.gif)

_视频经过剪辑，数据的同步时间通常为 15-20 秒左右。_

从模拟器上进行的操作（添加、删除）通常会在 15-20
秒中左右会反应到实机上；但从实机上进行的操作，则需要将模拟器切换到后台再返回前台才能在模拟器中体现出来（因为模拟器不支持静默通知响应）。如果是在两个模拟器间进行测试，两端都需要做类似操作。

苹果文档对同步+分发的时间描述为不超过 1 分钟，在实际使用中通常都会在 10-30 秒左右。支持批量数据更新，无需担心大量数据更新的效率问题。

当数据发生变化时，控制台会有大量的调试信息产生，之后会有专文涉及更多关于调试方面的内容。

## 创建可同步 Model 的注意事项

要在 `Core Data` 和 `CloudKit` 数据库之间完美地传递记录，最好对双方的数据结构类型有一定的了解，具体请参阅 [ Core
Data with CloudKit （一） —— 基础 ](/zh/posts/coredatawithcloudkit-1/) 。

`CloudKit Schema` 并不支持 `Core Data Model` 的所有功能、配置，因此在设计可同步的 `Core Data`
项目时，请注意以下限制，并确保你创建了一个兼容的数据模型。

### Enitites

- **`CloudKit Sechma` 不支持 `Core Data` 的唯一限制（ `Unique constraints` ） **

`Core Data` 的 `Unique constraints` 需要 `SQLite` 提供支持， `CloudKit`
本身并非关系型数据库，因此不支持并不意外。

    CREATE UNIQUE INDEX Z_Movie_UNIQUE_color_colors ON ZMOVIE (ZCOLOR COLLATE BINARY ASC, ZCOLORS COLLATE BINARY ASC)

![image-20210807090639166](https://cdn.fatbobman.com/image-20210807090639166-8298400.png)

### Attributes

- **不可以有即为`非可选值` 又 `没有默认值` 的属性。允许：可选、有默认值、可选 + 有默认值 **

![image-20210807091044353](https://cdn.fatbobman.com/image-20210807091044353-8298645.png)

上图中的属性 `非 Optional` 且 `没有 Default Value` 是不兼容的形式， `Xcode` 会报错。

- **不支持`Undefined` 类型 ** ![image-20210808073123665](https://cdn.fatbobman.com/image-20210808073123665-8379084.png)

### Relationships

- **所有的 relationship 必须设置为可选（`Optional` ） **
- **所有的 relationship 必须有逆向（`Invers` ）关系 **
- **不支持`Deny` 的删除规则 **
- **不支持有序关系（`Ordered` ） **

`CloudKit` 本来也有一种类似于 `Core Data` 关系类型的对象—— `CKReference` 。不过该对象最多只能支持对应
750 条记录，无法满足大多数 `Core Data` 应用场景的需要， `CloudKit` 采用将 `Core Data` 的关系转换成 `Record Name` （ `UUID` 字符串形式）逐条对应，这导致 `CloudKit` 可能不会原子化（ `atomically`
）地保存关系变化，因此对关系的定义做出了较严格的限制。

在 `Core Data` 日常始终中，多数的关系定义还是能满足上述的要求。

### Configurations

- **实体（`Entity` ）不得与其他配置（ `Configuration` ）中的实体建立 `relationship` **

官方文档中这个限制我比较困惑，因为即使不采用网络同步，开发者也通常不会为两个 `Configuration` 中的实体建立 `relationship` 。如果需要建立联系，通常会采用创建 `Fetched Properties` 。

![image-20210807094550677](https://cdn.fatbobman.com/image-20210807094550677-8300752.png)

> 在启用 `CloudKit` 同步后，如果 `Model` 不满足同步兼容条件时 `Xcode` 会报错提醒开发者。在将已有项目更改为支持
> `Core Data with CloudKit` 时，可能需要对代码做出一定的修改。

## 在现有 Core Data 项目中添加 Host in CloudKit 支持

有了模版项目的基础，将 `Core Data` 项目升级为支持 `Core Data with CloudKit` 也就非常容易了：

- 使用 `NSPersistentCloudKitContainer` 替换 `NSPersistentContainer`
- 添加 `CloudKit` 、 `background` 功能并添加 `CloudKit container`
- 配置上下文

以下两点仍需提醒：

### `CloudKit container` 无法认证

添加 `CloudKit container` 时，有时候会出现无法认证的情况。尤其是添加一个已经创建的 `container`
，该情况几乎必然发生。

    CoreData: error: CoreData+CloudKit: -[NSCloudKitMirroringDelegate recoverFromPartialError:forStore:inMonitor:]block_invoke(1943): <NSCloudKitMirroringDelegate: 0x282430000>: Found unknown error as part of a partial failure: <CKError 0x28112d500: "Permission Failure" (10/2007); server message = "Invalid bundle ID for container"; uuid = ; container ID = "iCloud.Appname">

解决的方法为：登录开发者账户-> `Certificates,Identifiers&Profiles` -> `Identifiers App
IDs` ，选择对应的 `BundleID` ，配置 `iCloud` ，点击 `Edit` ，重新配置 `container` 。

![image-20210807100856319](https://cdn.fatbobman.com/image-20210807100856319-8302137.png)

### 使用自定义的 `NSPersistentStoreDescription`

有些开发者喜欢自定义 `NSPersistentDescription` （即使只有一个 `Configuration` ）,
这种情况下，需要显式为 `NSPersistentDescription` 设置 `cloudKitContainerOptions` ，例如：

    let cloudStoreDescription = NSPersistentStoreDescription(url: cloudStoreLocation)
    cloudStoreDescription.configuration = "Cloud"

    cloudStoreDescription.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: "your.containerID")

即使不将 `Model Editor` 中的 `Configuration` 设置为 `Used with CloudKit`
，网络同步功能同样生效。勾选 `Used with CloudKit` 的最大好处是： `Xcode` 会帮你检查 `Model` 是否兼容 `CloudKit` 。

## 有选择的同步数据

在实际应用中，有某些场景我们想有选择性地对数据进行同步。通过在 `Data Model Editor` 中定义多个 `Configuration`
，可以帮助我们实现对数据同步的控制。

配置 `Configuration` 非常简单，只需将 `Entity` 拖入其中即可。

### 在不同的 Configuration 中放置不同的 Enitity

假设以下场景，我们有一个 `Entity` —— `Catch` ，用于作为本地数据缓存，其中的数据不需要同步到 iCloud 上。

> 苹果的官方文档以及其他探讨 Configuration 的资料基本上都是针对类似上述这种情况

我们创建两个 `Configuration` ：

- local—— `Catch`
- cloud——其他需要同步的 `Entities`

采用类似如下的代码：

    let cloudURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
                  .appendingPathComponent("cloud.sqlite")
    let localURL = FileManager.default.urls(for:.documentDirectory, in:.userDomainMask).first!
                  .appendingPathComponent("local.sqlite")

    let cloudDesc = NSPersistentStoreDescription(url: cloudURL)
    cloudDesc.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: "your.cloudKit.container")
    cloudDesc.configuration = "cloud"

    let localDesc = NSPersistentStoreDescription(url: localURL)
    localDesc.configuration = "local"

    container.persistentStoreDescriptions = [cloudDesc,localDesc]

只有 `Configuration cloud` 中的 `Entities` 数据会被同步到 `iCloud` 上。

_我们不可以在跨`Configuration` 的 `Entity` 之间创建 `relationship` ，如确有需要可以使用 `Fetched Preoperties` 达到受限的近似效果 _

### 在不同的 Configuration 中放置同一个 Entity

如果想对**同一个 `Entity` **的数据进行同步控制（部分同步），可以使用下面的方案。

场景如下：假设有一个 `Entity` —— `Movie` ，无论出于什么理由，你只想对其中的部分数据进行同步。

- 为 `Movie` 增加一个 `Attribute` —— `local:Bool` （本地数据为 `true` ，同步数据为 `false` ）

- 创建两个 `Configuration` —— `cloud` 、 `local` ，在两个 `Configuration` 中都添加上 `Moive`

- 采用和上面一样的代码，在 `NSPersistentCloudKitContainer` 中添加两个 `Description`

当 `fetch Movie` 的时候， `NSPersistentCoordinator` 会自动合并处理两个 `Store` 里面的 `Moive` 记录。不过当写入 `Movie` 实例时，协调器只会将实例写到最先包含 `Movie` 的 `Description`
，因此需要特别注意添加的顺序。

比如 `container.persistentStoreDescriptions = [cloudDesc,localDesc]` ，在 `container.viewContext` 中新建的 `Movie` 会写入到 `cloud.sqlite` 中

- 创建一个 `NSPersistentContainer` 命名为 `localContainer` ，只包含 `localDesc` （多 `container` 方案）

- 在 `localDesc` 上开启 `Persistent History Tracking`

- 使用 `localContainer` 创建上下文写入 `Movie` 实例（实例将只保存到本地，而不进行网络同步）

- 处理 `NSPersistentStoreRemoteChange` 通知，将从 `localContainer` 中写入的数据合并到 `container` 的 `viewContext` 中

以上方案需要使用 `Persistent History Tracking` ，更多资料可以查看我的另一篇文章 [ 【在 CoreData
中使用持久化历史跟踪】 ](/zh/posts/persistenthistorytracking/) 。

## 总结

在本文中，我们探讨了如何实现将本地数据库同步到 `iCloud` 私有数据库。

下一篇文章让我们一起探讨如何使用 `CloudKit` 仪表台。从另一个角度认识 `Core Data with CloudKit` 。

# 在 SwiftUI 中制作可以控制取消手势的 Sheet

> 在前面的两篇文章中，我们探讨了如何制作一个可以判断是否进行了修改的表单，以及如何统一管理 app 各个层级 View 的弹出
> Sheet。今天我们将他们合并在一起，完成整个项目的最终目的——在 Sheet 中制作一个可以实时响应的表单，并且 sheet
> 会感觉表单的情况响应取消手势。

[ 在 SwiftUI 中，根据需求弹出不同的 Sheet ](/zh/posts/swiftui-multisheet/)

[ 如何在 SwiftUI 中创建一个实时响应的 Form ](/zh/posts/swiftui-input-form/)

## 由来

在之前 Form 的例子中，虽然我们可以根据表单是否进行了修改来对 cancel、edit 等做出不同的响应，但是我们并没有办法控制用户直接使用手势来取消
sheet，为了不让用户绕过程序的判断检查，不得已使用了 fullScreenCover 来规避手势取消。不过在实际使用中，尽管全屏 sheet
提供了更多的屏幕可用空间，但还是会给使用者带来了操作逻辑不统一的体验。

在去年，我使用的解决方案是，屏蔽 sheet 的拖动手势。

     .highPriorityGesture(DragGesture())

这也是没有办法的办法。

后来，SwiftUI-lab 中，Javier 提出了他的解决方案 [ Dismiss Gesture for SwiftUI Modals
](https://swiftui-lab.com/modal-dismiss-gesture/)
。这个方案基本上实现了我想要的全部功能。不过这个方案看起来有些怪异。

1. 数据和 sheet 控制混合在一起
2. 对于 sheet 的控制过于繁琐，而且不直观

前段时间 [ mobilinked
](https://gist.github.com/mobilinked/9b6086b3760bcf1e5432932dad0813c0)
编写了一段用于控制 sheet 的代码，结构精巧，使用简单。

本文对于 sheet 的控制采用了 mobilinked 的基础代码，并针对 Form 的响应做出了对应的修改。

在进行下面的代码说明前，如果你还没有阅读前两篇文章的话，请阅读后再继续。

## 目标

1. 表单对输入的内容进行实时检查（是否有错误，是否有空白项）
2. 表单将根据当前的状态决定是否允许 sheet 进行手势取消
3. 当用户进行手势取消时，如果表单已经进行了修改，需要用户二次确认是否取消

## 代码简介

由于本文代码中多数部分同 Form 示例代码类似，所以仅简述一下新增及修改的部分。

SheetManager

    public class AIOSheetManager:ObservableObject{
        @Published  var action:AllInOneSheetAction?
        var unlock:Bool = false //false 时无法下滑 dismiss, 由 form 程序维护
        var type:AllInOneSheetType = .sheet //sheet or fullScreenCover
        var dismissControl:Bool = true //是否启动 dismiss 阻止开关，true 启动阻止

        @Published var showSheet = false
        @Published var showFullCoverScreen = false

        var dismissed = PassthroughSubject<Bool,Never>()
        var dismissAction:(() -> Void)? = nil

        enum AllInOneSheetType{
            case fullScreenCover
            case sheet
        }
    }

sheet 控制代码

    struct MbModalHackView: UIViewControllerRepresentable {
        let manager:AIOSheetManager

        func makeUIViewController(context: UIViewControllerRepresentableContext<MbModalHackView>) -> UIViewController {
            UIViewController()
        }

        func updateUIViewController(_ uiViewController: UIViewController, context: UIViewControllerRepresentableContext<MbModalHackView>) {
            rootViewController(of: uiViewController).presentationController?.delegate = context.coordinator
        }

        private func rootViewController(of uiViewController: UIViewController) -> UIViewController {
            if let parent = uiViewController.parent {
                return rootViewController(of: parent)
            }
            else {
                return uiViewController
            }
        }

        func makeCoordinator() -> Coordinator {
            Coordinator(manager: manager)
        }

        class Coordinator: NSObject, UIAdaptivePresentationControllerDelegate {
            let manager:AIOSheetManager
            init(manager:AIOSheetManager){
                self.manager = manager
            }
            func presentationControllerShouldDismiss(_ presentationController: UIPresentationController) -> Bool {
                guard manager.dismissControl else {return true}
                return manager.unlock
            }

            //当阻止取消时，发送用户要求取消 sheet 命令
            func presentationControllerDidAttemptToDismiss(_ presentationController: UIPresentationController){
                manager.dismissed.send(true)
            }
        }
    }

    extension View {
        public func allowAutoDismiss(_ manager:AIOSheetManager) -> some View {
            self
                .background(MbModalHackView(manager: manager))

        }
    }

包装

    struct XSheet:ViewModifier{
        @EnvironmentObject var manager:AIOSheetManager
        @EnvironmentObject var store:Store
        @Environment(\.managedObjectContext) var context
        var onDismiss:()->Void{
            return {
                (manager.dismissAction ?? {})()
                manager.dismissAction = nil
                manager.action = nil
                manager.showSheet = false
                manager.showFullCoverScreen = false
            }
        }
        func body(content: Content) -> some View {
            ZStack{
                content

                Color.clear
                    .sheet(isPresented: $manager.showSheet,onDismiss: onDismiss){
                            if let action = manager.action
                            {
                                reducer(action)
                                .allowAutoDismiss(manager)
                                .environmentObject(manager)
                            }

                    }

                Color.clear
                    .fullScreenCover(isPresented: $manager.showFullCoverScreen,onDismiss: onDismiss){
                            if let action = manager.action
                            {
                                reducer(action)
                                    .allowAutoDismiss(manager)
                                    .environmentObject(manager)
                            }
                    }
            }
            .onChange(of: manager.action){ action in
                guard action != nil else {
                    manager.showSheet = false
                    manager.showFullCoverScreen = false
                    return
                }
                if manager.type == .sheet {
                    manager.showSheet = true
                }
                if manager.type == .fullScreenCover{
                    manager.showFullCoverScreen = true
                }
            }
        }
    }

    enum AllInOneSheetAction:Identifiable,Equatable{
        case show(student:Student)
        case edit(student:Student)
        case new

        var id:UUID{UUID()}
    }

    extension XSheet{
        func reducer(_ action:AllInOneSheetAction) -> some View{
            switch action{
            case .show(let student):
                return StudentManager(action:.show, student:student)
            case .new:
                return StudentManager(action: .new, student: nil)
            case .edit(let student):
                return StudentManager(action:.edit,student: student)
            }
        }
    }

    extension View{
        func xsheet() -> some View{
            self
                .modifier(XSheet())
        }
    }

调用方式

    NavigationView{
        ...
    }
    .xsheet()

    Button("New"){
             sheetManager.type = .sheet  //当前支持两种方式 sheet fullScreenCover
             sheetManager.dismissControl = true //打开控制
             sheetManager.action = .new   //设置统一 sheet 的 action
                  }

Form 代码的修改

为了让我们的表单代码能够管理 sheet，并且可以响应用户的取消手势，对 Form 代码做了如下的修改：

        @State private var changed = false{
            didSet{
                //控制 sheet 是否允许 dismiss
                if action == .show {
                    sheetManager.unlock = true
                }
                else {
                    sheetManager.unlock = !changed
                }
            }
        }





    新增
     .onReceive(sheetManager.dismissed){ value in
                    delConfirm.toggle()
                }

详细代码请访问我的 [ github ](https://github.com/fatbobman/DismissConfirmSheet)

# AttributedString —— 不仅仅让文字更漂亮

在 WWDC 2021 上，苹果为开发者带来了有一个期待已久的功能——AttributedString，这意味着 Swift 开发人员不再需要使用基于
Objective-C 的 NSAttributedString 来创建样式化文本。本文将对其做全面的介绍并演示如何创建自定义属性。

## 初步印象

AttributedString
是具有单个字符或字符范围的属性的字符串。属性提供了一些特征，如用于显示的视觉风格、用于无障碍引导以及用于在数据源之间进行链接的超链接数据等。

下面的代码将生成一个包含粗体以及超链接的属性字符串。

    var attributedString = AttributedString("请访问肘子的博客")
    let zhouzi = attributedString.range(of: "肘子")!  // 获取肘子二字的范围（Range）
    attributedString[zhouzi].inlinePresentationIntent = .stronglyEmphasized // 设置属性——粗体
    let blog = attributedString.range(of: "博客")!
    attributedString[blog].link = URL(string: "https://fatbobman.com")! // 设置属性——超链接

![image-20211007165456612](https://cdn.fatbobman.com/image-20211007165456612.png)

在 WWDC 2021 之前，SwiftUI 没有提供对属性字符串的支持，如果我们希望显示具有丰富样式的文本，通常会采用以下三种方式：

- 将 UIKit 或 AppKit 控件包装成 SwiftUI 控件，在其中显示 NSAttributedString
- 通过代码将 NSAttributedString 转换成对应的 SwiftUI 布局代码
- 使用 SwiftUI 的原生控件组合显示

下面的文字随着 SwiftUI 版本的变化，可采取的手段也在不断地增加（不使用 NSAttributedString）：

![image-20211006163659029](https://cdn.fatbobman.com/image-20211006163659029.png)

_**SwiftUI 1.0** _

        @ViewBuilder
        var helloView:some View{
            HStack(alignment:.lastTextBaseline, spacing:0){
                Text("Hello").font(.title).foregroundColor(.red)
                Text(" world").font(.callout).foregroundColor(.cyan)
            }
        }

_**SwiftUI 2.0** _

SwiftUI 2.0 增强了 Text 的功能，我们可以将不同的 Text 通过 `+` 合并显示

        var helloText:Text {
            Text("Hello").font(.title).foregroundColor(.red) + Text(" world").font(.callout).foregroundColor(.cyan)
        }

_**SwiftUI 3.0** _

除了上述的方法外，Text 添加了对 AttributedString 的原生支持

        var helloAttributedString:AttributedString {
            var hello = AttributedString("Hello")
            hello.font = .title.bold()
            hello.foregroundColor = .red
            var world = AttributedString(" world")
            world.font = .callout
            world.foregroundColor = .cyan
            return hello + world
        }

        Text(helloAttributedString)

> 单纯看上面的例子，并不能看到 AttributedString 有什么优势。相信随着继续阅读本文，你会发现 AttributedString
> 可以实现太多以前想做而无法做到的功能和效果。

## AttributedString vs NSAttributedString

AttributedString 基本上可以看作是 NSAttributedString 的 Swift
实现，两者在功能和内在逻辑上差别不大。但由于形成年代、核心代码语言等，两者之间仍有不少的区别。本节将从多个方面对它们进行比较。

### 类型

AttributedString 是值类型的，这也是它同由 Objective-C 构建的
NSAttributedString（引用类型）之间最大的区别。这意味着它可以通过 Swift 的值语义，像其他值一样被传递、复制和改变。

NSAttributedString 可变或不可变需不同的定义

    let hello = NSMutableAttributedString("hello")
    let world = NSAttributedString(" world")
    hello.append(world)

AttributedString

    var hello = AttributedString("hello")
    let world = AttributedString(" world")
    hello.append(world)

### 安全性

在 AttributedString 中需要使用 Swift 的点或键语法按名称访问属性，不仅可以保证类型安全，而且可以获得编译时检查的优势。

AttributedString 中基本不采用 NSAttributedString 如下的属性访问方式，极大的减少出错几率

    // 可能出现类型不匹配
    let attributes: [NSAttributedString.Key: Any] = [
        .font: UIFont.systemFont(ofSize: 72),
        .foregroundColor: UIColor.white,
    ]

### 本地化支持

Attributed 提供了原生的本地化字符串支持，并可为本地化字符串添加了特定属性。

    var localizableString = AttributedString(localized: "Hello \(Date.now,format: .dateTime) world",locale: Locale(identifier: "zh-cn"),option:.applyReplacementIndexAttribute)

### Formatter 支持

同为 WWDC 2021 中推出的新 Formatter API 全面支持了 AttributedString
类型的格式化输出。我们可以轻松实现过去无法完成的工作。

    var dateString: AttributedString {
            var attributedString = Date.now.formatted(.dateTime
                .hour()
                .minute()
                .weekday()
                .attributed
            )
            let weekContainer = AttributeContainer()
                .dateField(.weekday)
            let colorContainer = AttributeContainer()
                .foregroundColor(.red)
            attributedString.replaceAttributes(weekContainer, with: colorContainer)
            return attributedString
    }

    Text(dateString)

![image-20211006183053713](https://cdn.fatbobman.com/image-20211006183053713.png)

> 更多关于新 Formatter API 同 AttributedString 配合范例，请参阅 [ WWDC 2021 新 Formatter
> API：新老比较及如何自定义 ](/zh/posts/newformatter/)

### SwiftUI 集成

SwiftUI 的 Text 组件提供了对 AttributedString 的原生支持，改善了一个 SwiftUI 的长期痛点（不过
TextField、TextEdit 仍不支持）。

AttributedString 同时提供了 SwiftUI、UIKit、AppKit 三种框架的可用属性。UIKit 或 AppKit 的控件同样可以渲染
AttributedString（需经过转换）。

### 支持的文件格式

AttributedString 目前仅具备对 Markdown 格式文本进行解析的能力。同 NSAttributedString 支持
Markdown、rtf、doc、HTML 相比仍有很大差距。

### 转换

苹果为 AttributedString 和 NSAttributedString 提供了相互转换的能力。

    // AttributedString -> NSAttributedString
    let nsString = NSMutableAttributedString("hello")
    var attributedString = AttributedString(nsString)

    // NSAttribuedString -> AttributedString
    var attString = AttributedString("hello")
    attString.uiKit.foregroundColor = .red
    let nsString1 = NSAttributedString(attString)

开发者可以充分利用两者各自的优势进行开发。比如：

- 用 NSAttributedString 解析 HTML，然后转换成 AttributedString 调用
- 用 AttributedString 创建类型安全的字符串，在显示时转换成 NSAttributedString

## 基础

本节中，我们将对 AttributedString 中的一些重要概念做介绍，并通过代码片段展示 AttributedString 更多的用法。

### AttributedStringKey

AttributedStringKey 定义了 AttributedString 属性名称和类型。通过点语法或
KeyPath，在保证类型安全的前提进行快捷访问。

    var string = AttributedString("hello world")
    // 使用点语法
    string.font = .callout
    let font = string.font

    // 使用 KeyPath
    let font = string[keyPath:\.font]

除了使用系统预置的大量属性外，我们也可以创建自己的属性。例如：

    enum OutlineColorAttribute : AttributedStringKey {
        typealias Value = Color // 属性类型
        static let name = "OutlineColor" // 属性名称
    }

    string.outlineColor = .blue

> 我们可以使用点语法或 KeyPath 对 AttributedString、AttributedSubString、AttributeContainer
> 以及 AttributedString. Runs. Run 的属性进行访问。更多用法参照本文其他的代码片段。

### AttributeContainer

AttributeContainer 是属性容器。通过配置 container，我们可以一次性地为属性字符串（或片段）设置、替换、合并大量的属性。

_**设置属性** _

    var attributedString = AttributedString("Swift")
    string.foregroundColor = .red

    var container = AttributeContainer()
    container.inlinePresentationIntent = .strikethrough
    container.font = .caption
    container.backgroundColor = .pink
    container.foregroundColor = .green //将覆盖原来的 red

    attributedString.setAttributes(container) // attributdString 此时拥有四个属性内容

_**替换属性** _

    var container = AttributeContainer()
    container.inlinePresentationIntent = .strikethrough
    container.font = .caption
    container.backgroundColor = .pink
    container.foregroundColor = .green
    attributedString.setAttributes(container)
    // 此时 attributedString 有四个属性内容 font、backgroundColor、foregroundColor、inlinePresentationIntent

    // 被替换的属性
    var container1 = AttributeContainer()
    container1.foregroundColor = .green
    container1.font = .caption

    // 将要替换的属性
    var container2 = AttributeContainer()
    container2.link = URL(string: "https://www.swift.org")

    // 被替换属性 contianer1 的属性键值内容全部符合才可替换，比如 continaer1 的 foregroundColor 为。red 将不进行替换
    attributedString.replaceAttributes(container1, with: container2)
    // 替换后 attributedString 有三个属性内容 backgroundColor、inlinePresentationIntent、link

_**合并属性** _

    var container = AttributeContainer()
    container.inlinePresentationIntent = .strikethrough
    container.font = .caption
    container.backgroundColor = .pink
    container.foregroundColor = .green
    attributedString.setAttributes(container)
    // 此时 attributedString 有四个属性内容 font、backgroundColor、foregroundColor、inlinePresentationIntent

    var container2 = AttributeContainer()
    container2.foregroundColor = .red
    container2.link = URL(string: "www.swift.org")

    attributedString.mergeAttributes(container2,mergePolicy: .keepNew)
    // 合并后 attributedString 有五个属性 ，font、backgroundColor、foregroundColor、inlinePresentationIntent 及 link
    // foreground 为。red
    // 属性冲突时，通过 mergePolicy 选择合并策略 .keepNew（默认） 或 .keepCurrent

### AttributeScope

属性范围是系统框架定义的属性集合，将适合某个特定域中的属性定义在一个范围内，一方面便于管理，另一方面也解决了不同框架下相同属性名称对应类型不一致的问题。

目前，AttributedString 提供了 5 个预置的 Scope，分别为

- foundation

包含有关 Formatter、Markdown、URL 以及语言变形方面的属性

- swiftUI

可以在 SwiftUI 下被渲染的属性，例如 foregroundColor、backgroundColor、font 等。目前支持的属性明显少于
uiKit 和 appKit。估计待日后 SwiftUI 提供更多的显示支持后会逐步补上其他暂不支持的属性。

- uiKit

可以在 UIKit 下被渲染的属性。

- appKit

可以在 AppKit 下被渲染的属性

- accessibility

适用于无障碍的属性，用于提高引导访问的可用性。

在 swiftUI、uiKit 和 appKit 三个 scope 中存在很多的同名属性（比如 foregroundColor），在访问时需注意以下几点：

- 当 Xcode 无法正确推断该适用哪个 Scope 中的属性时，请显式标明对应的 AttributeScope

  uiKitString.uiKit.foregroundColor = .red //UIColor
  appKitString.appKit.backgroundColor = .yellow //NSColor

- 三个框架的同名属性并不能互转，如想字符串同时支持多框架显示（代码复用），请分别为不同 Scope 的同名属性赋值

  attributedString.swiftUI.foregroundColor = .red
  attributedString.uiKit.foregroundColor = .red
  attributedString.appKit.foregroundColor = .red

  // 转换成 NSAttributedString，可以只转换指定的 Scope 属性
  let nsString = try! NSAttributedString(attributedString, including: \.uiKit)

- 为了提高兼容性，部分功能相同的属性，可以在 foundation 中设置。

  attributedString.inlinePresentationIntent = .stronglyEmphasized //相当于 bold

- swiftUI、uiKit 和 appKit 三个 Scope 在定义时，都已经分别包含了 foundation 和 accessibility。因此在转换时即使只指定单一框架，foundation 和 accessibility 的属性也均可正常转换。我们在自定义 Scope 时，最好也遵守该原则。

  let nsString = try! NSAttributedString(attributedString, including: \.appKit)
  // attributedString 中属于 foundation 和 accessibility 的属性也将一并被转换

### 视图

在属性字符串中，属性和文本可以被独立访问，AttributedString 提供了三种视图方便开发者从另一个维度访问所需的内容。

#### Character 和 unicodeScalar 视图

这两个视图提供了类似 NSAttributedString 的 string
属性的功能，让开发者可以在纯文本的维度操作数据。两个视图的唯一区别是类型不同，简单来说，你可以把 ChareacterView 看作是 Charecter
集合，而 UnicodeScalarView 看作是 Unicode 标量合集。

字符串长度

    var attributedString = AttributedString("Swift")
    attributedString.characters.count // 5

长度 2

    let attributedString = AttributedString("hello 👩🏽‍🦳")
    attributedString.characters.count // 7
    attributedString.unicodeScalars.count // 10

转换成字符串

    String(attributedString.characters) // "Swift"

替换字符串

    var attributedString = AttributedString("hello world")
    let range = attributedString.range(of: "hello")!
    attributedString.characters.replaceSubrange(range, with: "good")
    // good world , 替换后的 good 仍会保留 hello 所在位置的所有属性

#### Runs 视图

AttributedString 的属性视图。每个 Run 对应一个属性完全一致的字符串片段。用 for-in 语法来迭代 AttributedString
的 runs 属性。

_**只有一个 Run** _

整个属性字符串中所有的字符属性都一致

    let attributedString = AttribuedString("Core Data")
    print(attributedString)
    // Core Data {}
    print(attributedString.runs.count) // 1

_**两个 Run** _

属性字符串 `coreData` ， `Core` 和 `Data` 两个片段的属性不相同，因此产生了两个 Run

    var coreData = AttributedString("Core")
    coreData.font = .title
    coreData.foregroundColor = .green
    coreData.append(AttributedString(" Data"))

    for run in coreData.runs { //runs.count = 2
        print(run)
    }

    // Core {
    //      SwiftUI.Font = Font(provider: SwiftUI.(unknown context at $7fff5cd3a0a0).FontBox<SwiftUI.Font.(unknown context at $7fff5cd66db0).TextStyleProvider>)
    //      SwiftUI.ForegroundColor = green
    //      }
    // Data {}

_**多个 Run** _

    var multiRunString = AttributedString("The attributed runs of the attributed string, as a view into the underlying string.")
    while let range = multiRunString.range(of: "attributed") {
        multiRunString.characters.replaceSubrange(range, with: "attributed".uppercased())
        multiRunString[range].inlinePresentationIntent = .stronglyEmphasized
    }
    var n = 0
    for run in multiRunString.runs {
        n += 1
    }
    // n = 5

最终结果：The **ATTRIBUTED** runs of the **ATTRIBUTED** string, as a view into the
underlying string.

_**利用 Run 的 range 进行属性设置** _

    // 继续使用上文的 multiRunString
    // 将所有非强调字符设置为黄色
    for run in multiRunString.runs {
        guard run.inlinePresentationIntent != .stronglyEmphasized else {continue}
        multiRunString[run.range].foregroundColor = .yellow
    }

_**通过 Runs 获取指定的属性** _

    // 将颜色为黄色且为粗体的文字改成红色
    for (color,intent,range) in multiRunString.runs[\.foregroundColor,\.inlinePresentationIntent] {
        if color == .yellow && intent == .stronglyEmphasized {
            multiRunString[range].foregroundColor = .red
        }
    }

_**通过 Run 的 attributes 收集所有使用到的属性** _

    var totalKeysContainer = AttributeContainer()
    for run in multiRunString.runs{
        let container = run.attributes
        totalKeysContainer.merge(container)
    }

> 使用 Runs 视图可以方便的从众多属性中获取到需要的信息

_**不使用 Runs 视图，达到类似的效果** _

    multiRunString.transformingAttributes(\.foregroundColor,\.font){ color,font in
        if color.value == .yellow && font.value == .title {
            multiRunString[color.range].backgroundColor = .green
        }
    }

> 尽管没有直接调用 Runs 视图，不过 transformingAttributes 闭包的调用时机同 Runs
> 的时机是一致的。transformingAttributes 最多支持获取 5 个属性。

### Range

在本文之前的代码中，已经多次使用过 Range 来对属性字符串的内容进行访问或修改。

对属性字符串中局部内容的属性进行修改可以使用两种方式：

- 通过 Range
- 通过 AttributedContainer

_**通过关键字获取 Range** _

    // 从属性字符串的结尾向前查找，返回第一个满足关键字的 range（忽略大小写）
    if let range = multiRunString.range(of: "Attributed", options: [.backwards, .caseInsensitive]) {
        multiRunString[range].link = URL(string: "https://www.apple.com")
    }

_**使用 Runs 或 transformingAttributes 获取 Range** _

之前的例子中已反复使用

_**通过本文视图获取 Range** _

    if let lowBound = multiRunString.characters.firstIndex(of: "r"),
       let upperBound = multiRunString.characters.firstIndex(of: ","),
       lowBound < upperBound
    {
        multiRunString[lowBound...upperBound].foregroundColor = .brown
    }

## 本地化

### 创建本地化属性字符串

    // Localizable Chinese
    "hello" = "你好";
    // Localizable English
    "hello" = "hello";

    let attributedString = AttributedString(localized: "hello")

在英文和中文环境中，将分别显示为 `hello` 和 `你好`

> 目前本地化的 AttributedString 只能显示为当前系统设置的语言，并不能指定成某个特定的语言

    var hello = AttributedString(localized: "hello")
    if let range = hello.range(of: "h") {
        hello[range].foregroundColor = .red
    }

本地化字符串的文字内容将随系统语言而变化，上面的代码在中文环境下将无法获取到 range。需针对不同的语言做调整。

### replacementIndex

可以为本地化字符串的插值内容设定 index（通过 `applyReplacementIndexAttribute` ）, 方便在本地化内容中查找

    // Localizable Chinese
    "world %@ %@" = "%@ 世界 %@";
    // Localizable English
    "world %@ %@" = "world %@ %@";

    var world = AttributedString(localized: "world \("👍") \("🥩")",options: .applyReplacementIndexAttribute) // 创建属性字符串时，将按照插值顺序设定 index ，👍 index == 1 🥩 index == 2

    for (index,range) in world.runs[\.replacementIndex] {
        switch index {
            case 1:
                world[range].baselineOffset = 20
                world[range].font = .title
            case 2:
                world[range].backgroundColor = .blue
            default:
                world[range].inlinePresentationIntent = .strikethrough
        }
    }

在中文和英文环境中，分别为：

![image-20211007083048701](https://cdn.fatbobman.com/image-20211007083048701-3566650.png)

![image-20211007083115822](https://cdn.fatbobman.com/image-20211007083115822.png)

### 使用 locale 设定字符串插值中的 Formatter

     AttributedString(localized: "\(Date.now, format: Date.FormatStyle(date: .long))", locale: Locale(identifier: "zh-cn"))
    // 即使在英文环境中也会显示 2021 年 10 月 7 日

### 用 Formatter 生成属性字符串

            var dateString = Date.now.formatted(.dateTime.year().month().day().attributed)
            dateString.transformingAttributes(\.dateField) { dateField in
                switch dateField.value {
                case .month:
                    dateString[dateField.range].foregroundColor = .red
                case .day:
                    dateString[dateField.range].foregroundColor = .green
                case .year:
                    dateString[dateField.range].foregroundColor = .blue
                default:
                    break
                }
            }

![image-20211007084630319](https://cdn.fatbobman.com/image-20211007084630319.png)

### Markdown 符号

从 SwiftUI 3.0 开始，Text 已经对部分 Markdown
标签提供了支持。在本地化的属性字符串中，也提供了类似的功能，并且会在字符串中设置对应的属性。提供了更高的灵活性。

    var markdownString = AttributedString(localized: "**Hello** ~world~ _!_")
    for (inlineIntent,range) in markdownString.runs[\.inlinePresentationIntent] {
        guard let inlineIntent = inlineIntent else {continue}
        switch inlineIntent{
            case .stronglyEmphasized:
                markdownString[range].foregroundColor = .red
            case .emphasized:
                markdownString[range].foregroundColor = .green
            case .strikethrough:
                markdownString[range].foregroundColor = .blue
            default:
                break
        }
    }

![image-20211007085859409](https://cdn.fatbobman.com/image-20211007085859409.png)

## Markdown 解析

AttributedString 不仅可以在本地化字符串中支持部分的 Markdown 标签，并且提供了一个完整的 Markdown 解析器。

支持从 String、Data 或 URL 中解析 Markdown 文本内容。

比如：

    let mdString = try! AttributedString(markdown: "# Title\n**hello**\n")
    print(mdString)

    // 解析结果
    Title {
        NSPresentationIntent = [header 1 (id 1)]
    }
    hello {
        NSInlinePresentationIntent = NSInlinePresentationIntent(rawValue: 2)
        NSPresentationIntent = [paragraph (id 2)]
    }

解析后会将文字风格和标签设置在 `inlinePresentationIntent` 和 `presentationIntent` 中。

- inlinePresentationIntent

字符性质：比如粗体、斜体、代码、引用等

- presentationIntent

段落属性：比如段落、表格、列表等。一个 Run 中，presentationIntent 可能会有多个内容，用 component 来获取。

README. md

    #  Hello

    ## Header2

    hello **world**

    * first
    * second

    > test `print("hello world")`

    | row1 | row2 |
    | ---- | ---- |
    | 34   | 135  |

    [新 Formatter 介绍](/posts/newFormatter/)

解析代码：

    let url = Bundle.main.url(forResource: "README", withExtension: "md")!
    var markdownString = try! AttributedString(contentsOf: url,baseURL: URL(string: "https://fatbobman.com"))

解析后结果（节选）：

    Hello {
        NSPresentationIntent = [header 1 (id 1)]
    }
    Header2 {
        NSPresentationIntent = [header 2 (id 2)]
    }
    first {
        NSPresentationIntent = [paragraph (id 6), listItem 1 (id 5), unorderedList (id 4)]
    }

    test  {
        NSPresentationIntent = [paragraph (id 10), blockQuote (id 9)]
    }
    print("hello world") {
        NSPresentationIntent = [paragraph (id 10), blockQuote (id 9)]
        NSInlinePresentationIntent = NSInlinePresentationIntent(rawValue: 4)
    }
    row1 {
        NSPresentationIntent = [tableCell 0 (id 13), tableHeaderRow (id 12), table [Foundation.PresentationIntent.TableColumn(alignment: Foundation.PresentationIntent.TableColumn.Alignment.left), Foundation.PresentationIntent.TableColumn(alignment: Foundation.PresentationIntent.TableColumn.Alignment.left)] (id 11)]
    }
    row2 {
        NSPresentationIntent = [tableCell 1 (id 14), tableHeaderRow (id 12), table [Foundation.PresentationIntent.TableColumn(alignment: Foundation.PresentationIntent.TableColumn.Alignment.left), Foundation.PresentationIntent.TableColumn(alignment: Foundation.PresentationIntent.TableColumn.Alignment.left)] (id 11)]
    }
    新 Formatter 介绍 {
        NSPresentationIntent = [paragraph (id 18)]
        NSLink = /posts/newFormatter/ -- https://fatbobman.com
    }

解析后的内容包括段落属性、标题号、表格列数、行数、对齐方式等。缩紧、标号等其他信息可以在代码中可以通过枚举关联值来处理。

大致的代码如下：

    for run in markdownString.runs {
        if let inlinePresentationIntent = run.inlinePresentationIntent {
            switch inlinePresentationIntent {
            case .strikethrough:
                print("删除线")
            case .stronglyEmphasized:
                print("粗体")
            default:
                break
            }
        }
        if let presentationIntent = run.presentationIntent {
            for component in presentationIntent.components {
                switch component.kind{
                    case .codeBlock(let languageHint):
                        print(languageHint)
                    case .header(let level):
                        print(level)
                    case .paragraph:
                        let paragraphID = component.identity
                    default:
                        break
                }
            }
        }
    }

> SwiftUI 并不支持 presentationIntent 附加信息的渲染。如果想获得理想的显示效果，请自行编写视觉风格设置代码。

## 自定义属性

使用自定义属性，不仅有利于开发者创建更符合自身要求的属性字符串，而且通过在 Markdown
文本中添加自定义属性信息，进一步降低信息和代码的耦合度，提高灵活度。

自定义属性的基本流程为：

- 创建自定义 AttributedStringKey

为每个需要添加的属性创建一个符合 Attributed 协议的数据类型。

- 创建自定义 AttributeScope 并扩展 AttributeScopes

创建自己的 Scope，并在其中添加所有的自定义属性。为了方便自定义属性集被用于需要指定 Scope 的场合，在自定义 Scope
中推荐嵌套入需要的系统框架 Scope（swiftUI、uiKit、appKit）。并在 AttributeScopes 中添加上自定义的 Scope。

- 扩展 AttributeDynamicLookup（支持点语法）

在 AttributeDynamicLookup 中创建符合自定义 Scope 的下标方法。为点语法、KeyPath 提供动态支持。

### 实例 1：创建 id 属性

本例中我们将创建一个名称为 id 的属性。

    struct MyIDKey:AttributedStringKey {
        typealias Value = Int // 属性内容的类型。类型需要符合 Hashable
        static var name: String = "id" // 属性字符串内部保存的名称
    }

    extension AttributeScopes{
        public struct MyScope:AttributeScope{
            let id:MyIDKey  // 点语法调用的名称
            let swiftUI:SwiftUIAttributes // 在我的 Scope 中将系统框架 swiftUI 也添加进来
        }

        var myScope:MyScope.Type{
            MyScope.self
        }
    }

    extension AttributeDynamicLookup{
        subscript<T>(dynamicMember keyPath:KeyPath<AttributeScopes.MyScope,T>) -> T where T:AttributedStringKey {
            self[T.self]
        }
    }

调用

    var attribtedString = AttributedString("hello world")
    attribtedString.id = 34
    print(attribtedString)

    // Output
    hello world {
        id = 34
    }

### 实例 2：创建枚举属性，并支持 Markdown 解析

如果我们希望自己创建的属性可以在 Markdown 文本中被解析，需要让自定义的属性符合 `CodeableAttributedStringKey`
以及 `MarkdownDecodableAttributedStringKye`

    // 自定义属性的数据类型不限，只要满足需要的协议即可
    enum PriorityKey:CodableAttributedStringKey,MarkdownDecodableAttributedStringKey{
        public enum Priority:String,Codable{ //如需在 Markdown 中解析，需要将 raw 类型设置为 String, 并符合 Codable
            case low
            case normal
            case high
        }

        static var name: String = "priority"
        typealias Value = Priority
    }

    extension AttributeScopes{
        public struct MyScope:AttributeScope{
            let id:MyIDKey
            let priority:PriorityKey // 将新创建的 Key 也添加到自定义的 Scope 中
            let swiftUI:SwiftUIAttributes
        }

        var myScope:MyScope.Type{
            MyScope.self
        }
    }

> 在 Markdown 中使用 `^[text](属性名称：属性值)` 来标记自定义属性

调用

    // 在 Markdown 文本中解析自定义属性时，需指明 Scope。
    var attributedString = AttributedString(localized: "^[hello world](priority:'low')",including: \.myScope)
    print(attributedString)

    // Output
    hello world {
        priority = low
        NSLanguage = en
    }

### 实例 3：创建多参数的属性

    enum SizeKey:CodableAttributedStringKey,MarkdownDecodableAttributedStringKey{
        public struct Size:Codable,Hashable{
            let width:Double
            let height:Double
        }

        static var name: String = "size"
        typealias Value = Size
    }

    // 在 Scope 中添加
    let size:SizeKey

调用

    // 多参数在{}内添加
    let attributedString = AttributedString(localized: "^[hello world](size:{width:343.3,height:200.3},priority:'high')",including: \.myScope)
    print(attributedString)

    // Output
    ello world {
        priority = high
        size = Size(width: 343.3, height: 200.3)
        NSLanguage = en
    }

> 在 [ WWDC 2021 新 Formatter API ](/zh/posts/newformatter/) 一文中，还有在 Formatter
> 中使用自定义属性的案例

## 总结

在 AttributedString 之前，多数开发者将属性字符串主要用于文本的显示样式描述，随着可以在 Markdown
文本中添加自定义属性，相信很快就会有开发者扩展 AttributedString 的用途，将其应用到更多的场景中。

# 用 NavigationViewKit 增强 SwiftUI 的导航视图

最近一直在为我的 iOS 健康管理 app [ 健康笔记 3.0 ](/healthnotes/) 做前期的准备工作。

由于 SwiftUI 原生提供的导航手段能力有限，因此在之前的版本中，NavigationView 总是使用的不是那么的顺手。有以下几个我不满意的地方：

- 缺少直接返回根视图的便捷手段
- 无法通过代码（不通过 `NavigationLink` ）跳转到新视图
- 双栏模式（ `DoubleColumnNavigationViewStyle` ）下显示风格不统一
- 在 iPad 下，无法在竖屏（Portrait）模式下保持双栏状态

因此，在这次开发的准备阶段，我写了一个针对 NavigationView 的扩展库—— [ NavigationViewKit
](https://github.com/fatbobman/NavigationViewKit) 。该扩展遵循以下几个原则：

- 非破坏性

任何新添加的功能都不能影响当前 SwiftUI 提供的原生功能，尤其是不能影响例如 `Toolbar` 、 `NavigationLink` 在
NavigationView 中的表现

- 尽可能便于使用

仅需极少的代码便可使用新增功能

- SwiftUI 原生风格

扩展功能的调用方法尽可能同原生 SwiftUI 方式类似

> 请访问 Github 下载 [ NavigationViewKit
> ](https://github.com/fatbobman/NavigationViewKit)

## NavigationViewManager

### 简介

开发者对 NavigationView 最大抱怨之一就是不支持便捷的返回根视图手段。目前常用的解决方案有两种：

- 重新包装 `UINavigationController`

好的包装确实可以使用到 `UINavigationController` 提供的众多功能，不过非常容易同 SwiftUI
中的原生方法相冲突，鱼和熊掌不可兼得

- 使用程序化的 `NavigationLink`

通过撤销根视图的程序化的 `NavigationLink` （通常是 `isActive` ）来返回。此种手段将限制 `NavigationLink` 的种类选择，另外不利于从非视图代码中实现。

`NavigationViewManager` 是 NavigationViewKit 中提供的导航视图管理器，它提供如下功能：

- 可以管理应用程序中全部的 NavigationView
- 支持从 NavigationView 下的任意视图通过代码直接返回根视图
- 在 NavigationView 下的任意视图中通过代码直接跳转到新视图（无需在视图中描述 `NavigationLink` ）
- 通过 `NotificatiionCenter` ，指定应用程序中的任意 NavigationView 返回根视图
- 通过 `NotificatiionCenter` ，让应用程序中任意的 NavigationView 跳转到新视图
- 支持转场动画的开启关闭

### 注册 NavigationView

由于 `NavigationgViewManager` 支持多导航视图管理，因此需要为每个受管理的导航视图进行注册。

    import NavigationViewKit
    NavigationView {
                List(0..<10) { _ in
                    NavigationLink("abc", destination: DetailView())
                }
            }
            .navigationViewManager(for: "nv1", afterBackDo: {print("back to root") })

`navigationViewManager` 是一个 View 扩展，定义如下：

    extension View {
        public func navigationViewManager(for tag: String, afterBackDo cleanAction: @escaping () -> Void = {}) -> some View
    }

`for` 为当前注册的 `NavigationView` 的名称（或 tag）， `afterBackDo` 为当转到根视图后执行的代码段。

应用程序中每个被管理的 `NavigationView` 的 tag 需唯一。

### 从视图中返回根视图

在注册过的 `NavigationView` 的任意子视图中，可以通过下面的代码实现返回根视图：

    @Environment(\.navigationManager) var nvmanager

    Button("back to root view") {
        nvmanager.wrappedValue.popToRoot(tag:"nv1"){
               print("other back")
               }
    }

`popToRoot` 定义如下：

    func popToRoot(tag: String, animated: Bool = true, action: @escaping () -> Void = {})

`tag` 为当前 NavigationView 的注册 Tag， `animated` 设置返回根视图时是否显示转场动画， `action`
为进一步的善后代码段。该段代码将执行在注册代码段（ `afterBackDo` ）之后，主要用于传递当前视图中的数据。

可以通过

    @Environment(\.currentNaviationViewName) var tag

获取到当前 NavigationView 的注册 Tag，便于视图在不同的 NavigtionView 中复用

    struct DetailView: View {
        @Environment(\.navigationManager) var nvmanager
        @Environment(\.currentNaviationViewName) var tag
        var body: some View {
            VStack {
                Button("back to root view") {
                    if let tag = tag {
                        nvmanager.wrappedValue.popToRoot(tag:tag,animated: false) {
                            print("other back")
                        }
                    }
                }
            }
        }
    }

### 使用 NotificationCenter 返回根视图

由于 NavigationViewManager 在我的 app 中主要的用途是处理 `Deep Link`
，绝大多数的时间都不是在视图代码中调用的。因此 NavigationViewManager 提供了基于 `NotificationCenter`
的类似方法。

在代码中使用：

    let backToRootItem = NavigationViewManager.BackToRootItem(tag: "nv1", animated: false, action: {})
    NotificationCenter.default.post(name: .NavigationViewManagerBackToRoot, object: backToRootItem)

让指定的 NavigationView 返回到根视图。

演示如下：

![backToRootDemo](https://cdn.fatbobman.com/backToRootDemo.gif)

### 从视图中跳转到新视图

在视图代码中使用：

    @Environment(\.navigationManager) var nvmanager

    Button("go to new View"){
            nvmanager.wrappedValue.pushView(tag:"nv1",animated: true){
                Text("New View")
                    .navigationTitle("new view")
            }
    }

`pushView` 的定义如下：

    func pushView<V: View>(tag: String, animated: Bool = true, @ViewBuilder view: () -> V)

`tag` 为 NavigationView 的注册 Tag， `animation` 设置是否显示转场动画， `view`
为新视图。视图中支持 SwiftUI 原生的所有定义，例如 `toolbar` 、 `navigationTitle` 等。

目前在启用转场动画时，title 和 toolbar 会在转场动画后才显示，观感稍有不足。日后尝试解决。

### 使用 NotificationCenter 跳转到新视图

在代码中：

    let pushViewItem = NavigationViewManager.PushViewItem(tag: "nv1", animated: false) {
                        AnyView(
                            Text("New View")
                                .navigationTitle("第四级视图")
                        )
                    }
    NotificationCenter.default.post(name:.NavigationViewManagerPushView, object: pushViewItem)

通过 NotificationCenter 跳转视图时，视图需转换为 `AnyView` 。

演示：

![pushViewDemo-1925280](https://cdn.fatbobman.com/pushViewDemo-1925280.gif)

## DoubleColoumnJustForPadNavigationViewStyle

`DoubleColoumnJustForPadNavigationViewStyle` 是 `DoubleColoumnNavigationViewStyle` 的修改版，其目的是改善当 iPhone 和 iPad 使用同一套代码时， `DoubleColoumnNavigationViewStyle` 在 iPhone Max 上横屏时的表现同其他 iPhone 机型不同。

当 iPhone Max 横屏时，NavigationView 的表现会同 iPad 一样双列显示，让应用程序在不同 iPhone 上的表现不一致。

使用 `DoubleColoumnJustForPadNavigationViewStyle` 时，iPhone Max 在横屏时仍呈现 `StackNavigationViewStyle` 的式样。

使用方法：

    NavigationView{
       ...
    }
    .navigationViewStyle(DoubleColoumnJustForPadNavigationViewStyle())

在 swift 5.5 下可以直接使用

    .navigationViewStyle(.columnsForPad)

## TipOnceDoubleColumnNavigationViewStyle

当前 `DoubleColumnNavigationViewStyle` 在 iPad
上横竖屏的表现不同。当竖屏时，左侧栏默认会隐藏，容易让新用户无所适从。

`TipOnceDoubleColumnNavigationViewStyle` 会在 iPad
首次进入竖屏状态时，将左侧栏显示在右侧栏上方，提醒使用者。该提醒只会进行一次。提醒后旋转了方向，再次进入竖屏状态则不会二次触发提醒。

    NavigationView{
       ...
    }
    .navigationViewStyle(TipOnceDoubleColumnNavigationViewStyle())

在 Swift 5.5 下可以直接使用

    .navigationViewStyle(.tipColumns)

演示：

![TipOnceDoubleColumnNavigationViewStyleDemo](https://cdn.fatbobman.com/TipOnceDoubleColumnNavigationViewStyleDemo.gif)

## FixDoubleColumnNavigationViewStyle

在 [ 健康笔记 ](/healthnotes/) 中，我希望 iPad 版本无论在横屏或竖屏时，都始终能够保持两栏显示的状态，且左侧栏不可隐藏。

我之前使用了 HStack 套两个 NavigationView 来达到这个效果：

![image-20210831194932840](https://cdn.fatbobman.com/image-20210831194932840.png)

现在，可以直接 NavigationViewKit 中的 `FixDoubleColumnNavigationViewStyle` 轻松实现上述效果。

    NavigationView{
       ...
    }
    .navigationViewStyle(FixDoubleColumnNavigationViewStyle(widthForLandscape: 350, widthForPortrait:250))

并且可以为横屏竖屏两种状态分别设置左侧栏宽度。

演示：

![FixDoubleColumnNavigationViewStyleDemo](https://cdn.fatbobman.com/FixDoubleColumnNavigationViewStyleDemo.gif)

## 总结

NavigationViewKit 目前功能还比较少，我会根据自己的使用需要，逐步增加新的功能。

如果你在使用中发现问题或者有其他需求，请在 Github 上提交 Issue 或在我的博客中留言。

请访问 Github 下载 [ NavigationViewKit
](https://github.com/fatbobman/NavigationViewKit)

# 用苹果官方 API 实现 iOS 备忘录的扫描文稿功能

iOS 系统自带的备忘录（Notes）在其质朴名称下提供了众多强大的功能，扫描文稿是我使用较多的功能之一。很早前便想在【 [ 健康笔记
](/healthnotes/) 】之中提供类似的功能，但考虑到其涉及的知识点较多，迟迟没有下手。最近在空闲时，将近年 WWDC
中涉及该功能实现的专题梳理、学习了一遍，受益匪浅。苹果官方早已为我们准备了所需的一切工具。本文将介绍如何通过
VisionKit、Vision、NaturalLanguage、CoreSpotlight 等系统框架实现与备忘录扫描文稿类似的功能。

## 用 VisionKit 拍摄适合识别的图片

### VisionKit 介绍

VisionKit 是一个小框架，可以让你的应用程序使用系统的文档扫描仪。使用 VNDocumentCameraViewController
呈现覆盖整个屏幕的相机视图。通过在视图控制器中实现
VNDocumentCameraViewControllerDelegate，接收来自文档相机的回调，例如完成扫描。

通过同备忘录（Notes）一致的文档扫描外观，让开发者获得拍摄及图片处理能力（透视变换、颜色处理等）。

![IMG_1938](https://cdn.fatbobman.com/IMG_1938.jpeg)

### VisionKit 使用方法

VisionKit 框架目标明确、无需配置，使用异常简单。

#### 在 app 中申请相机的使用权限

在 info 中添加 NSCameraUsageDescription 键，填写使用相机的原因。

![image-20211109184955837](https://cdn.fatbobman.com/image-20211109184955837.png)

### 创建 VNDocumentCameraViewController

VNDocumentCameraViewController 并没有提供任何的配置选项，只需要声明一个它的实例便可使用。

下面的代码为在 SwiftUI 中使用的方式：

    import VisionKit

    struct VNCameraView: UIViewControllerRepresentable {
        @Binding var pages:[ScanPage]
        @Environment(\.dismiss) var dismiss

        typealias UIViewControllerType = VNDocumentCameraViewController

        func makeUIViewController(context: Context) -> VNDocumentCameraViewController {
            let controller = VNDocumentCameraViewController()
            controller.delegate = context.coordinator
            return controller
        }

        func updateUIViewController(_ uiViewController: VNDocumentCameraViewController, context: Context) {}

        func makeCoordinator() -> VNCameraCoordinator {
            VNCameraCoordinator(pages: $pages,dismiss: dismiss)
        }
    }

    struct ScanPage: Identifiable {
        let id = UUID()
        let image: UIImage
    }

#### 实现 VNDocumentCameraViewControllerDelegate

VNDocumentCameraViewControllerDelegate 提供了三个回调方法

- documentCameraViewController (\_ controller: VNDocumentCameraViewController, didFinishWith scan: VNDocumentCameraScan)

告诉委托，用户已成功从文档相机保存扫描的文档

- documentCameraViewControllerDidCancel (\_ controller: VNDocumentCameraViewController)

告诉委托，用户已从文档扫描仪相机中取消。

- documentCameraViewController (\_ controller: VNDocumentCameraViewController, didFailWithError error: Error)

告诉委托，当相机视图控制器处于活动状态时，文档扫描失败。

    final class VNCameraCoordinator: NSObject, VNDocumentCameraViewControllerDelegate {
        @Binding var pages:[ScanPage]
        var dismiss:DismissAction

        func documentCameraViewController(_ controller: VNDocumentCameraViewController, didFinishWith scan: VNDocumentCameraScan) {
            for i in 0..<scan.pageCount{
                let scanPage = ScanPage(image: scan.imageOfPage(at: i))
                pages.append(scanPage)
            }
            dismiss()
        }

        func documentCameraViewControllerDidCancel(_ controller: VNDocumentCameraViewController) {
            dismiss()
        }

        func documentCameraViewController(_ controller: VNDocumentCameraViewController, didFailWithError error: Error) {
            dismiss()
        }

        init(pages:Binding<[ScanPage]>,dismiss:DismissAction) {
            self._pages = pages
            self.dismiss = dismiss
        }
    }

VisionKit 允许使用者连续扫描图片。通过 pageCount 可以查询图片数量，并用 imageOfPage 分别获取。

> 用户应将扫描图片的方向调整到正确的显示状态，便于下一步的文字识别。

#### 在视图中调用

    struct ContentView: View {
        @State var scanPages = [ScanPage]()
        @State var scan = false
        var body: some View {
            VStack {
                Button("Scan") {
                    scan.toggle()
                }
                List {
                    ForEach(scanPages, id: \.id) { page in
                        HStack{
                        Image(uiImage: page.image)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(height: 100)
                        }
                    }
                }
                .fullScreenCover(isPresented: $scan) {
                    VNCameraView(pages: $scanPages)
                        .ignoresSafeArea()
                }
            }
        }
    }

至此，你已经获得了同 Notes 完全一致的拍摄扫描图片的功能。

## 用 Vision 进行文字识别

### Vision 介绍

相较 VisionKit 的小巧，Vision 则是一个功能强大、使用范围广泛的大型框架。它应用了计算机视觉算法，对输入的图像和视频执行各种任务。

Vision 框架可以执行人脸和人脸特征点检测、文本检测、条形码识别、图像配准和目标跟踪。Vision 还允许使用自定义的 Core ML
模型来完成分类或物体检测等任务。

在本例中，我们仅需使用 Vision 提供的文本检测（text detection）功能。

### 如何使用 Vision 进行文字识别

Vision 能够检测和识别图像中的多语言文本，识别过程完全在设备本地进行，保证了用户的隐私。Vision 提供了两种文本的检测路径（算法），分别为
Fast（快速）和
Accurate（精确）。快速非常适合实时读取号码之类的场景，在本例中，由于我们需要对整个文档进行文字处理，选择使用神经网络算法的精确路径更加合适。

在 Vision 中无论进行哪个种类的识别计算，大致的流程都差不太多。

- 为 Vision 准备输入图像

Vision 使用 VNImageRequestHandler 处理基于图像的请求，并假定图像是直立的，所以在传递图像时要考虑到方向。在本例中，我们将使用
VNDocumentCameraViewController 提供的图像进行处理。

- 创建 Vision Request

首先使用要处理的图像创建一个 VNImageRequestHandler 对象。

接下来创建 VNImageBasedRequest 提出识别需求（request）。针对每种识别类型都有对应的 VNImageBasedRequest
子类，本例中，识别文本对应的 request 为 VNRecognizeTextRequest。

可以对同一张图片提出多个 request，只需创建并捆绑所有的请求到 VNImageRequestHandler 的实例即可。

- 解释检测结果

可以通过两种方式访问检测结果：一、调用 perform 后检查 results 属性。二、在创建 request
对象时，设置回调方法检索识别信息。回调结果可能包含多个观察结果（observations），需要循环观察数组以处理每个观察结果。

大概的代码如下：

    import Vision

    func processImage(image: UIImage) -> String {
        guard let cgImage = image.cgImage else {
            fatalError()
        }
        var result = ""
        let request = VNRecognizeTextRequest { request, _ in
            guard let observations = request.results as? [VNRecognizedTextObservation] else { return }
            let recognizedStrings = observations.compactMap { observation in
                observation.topCandidates(1).first?.string
            }
            result = recognizedStrings.joined(separator: " ")
        }
        request.recognitionLevel = .accurate // 采用精确路径
        request.recognitionLanguages = ["zh-Hans", "en-US"] // 设置识别的语言

        let requestHandler = VNImageRequestHandler(cgImage: cgImage)
        do {
            try requestHandler.perform([request])
        } catch {
            print("error:\(error)")
        }
        return result
    }

每个被识别的文本段可能包含多个识别结果，通过 topCandidates (n) 设置最多返回几个候选结果。

recognitionLanguages 定义了语言处理和文本识别过程中语言的使用顺序，识别中文时，需将中文设置在首位。

需要识别的文档：

![截屏 2021-11-09 下午
4.37.28](https://cdn.fatbobman.com/%E6%88%AA%E5%B1%8F2021-11-09%20%E4%B8%8B%E5%8D%884.37.28.png)

> 此类文档并不适合进行自然语言处理（除非进行大量的深度学习），但健康笔记中将主要保存的此种类型的内容。

识别结果：

    InBody 身体水分 TinBody770) ID 15904113359 身高 年𠳕 性别 75 男性 测式日期/时间 (（透析）） 172cm
    (1946.07.10） 2021,10.09. 16:39 身体水分组成 身体水分组成 身体水分含量（(L） 60 0O 100 110 120 130
    100 170 32.5 身体总水分 32 5t 30 0AA . 细胞内水分 (） 70 10 GO 100 10 ％ 網舶内水分 19 9L 22 7-277
    19.9 细胞外水分 12.6L (13 号 170 細胞外水分 (L) HOF 00 100 110 120 13o 140 160 170 % 节段水分分析
    12.6 右上肢 1.80 L ( 201-279 细胞外水分比率分析 左上肢 2.00 L 2 07-2 79 低每准 魃干 16 8t 17 4 213
    细胞外水分比事 0.320 0.340 0360 0 380 0.300 0.400 0410 0 420 0.430 0 440 0 450 右下胶 5.65L ( 6
    08-743 0.390 左下肢 5.72 L ( 6 08-743 节段水分分析 人体成分分析 蛋白质 8.7 kg ( 9B~120 标准 无机盐
    2.83 hg 3.38~4 14 右上肢 (L) 70 85 100 15 130 45 160 175 1G0 205 1.80 体脂肪 30.0 xg ( 7.8-156
    左上肢 (L) 55 70 85 100 115 130 145 175 去脂体重 44.0 Mg ( 49 8~00 9 2.00 骨矿物质含量 2.37 kg (
    279~3.41 躯干 (L) 70 80 90 100 110 120 130 40 150 160 170 肌肉脂肪分析 16.8 体重 74.0 xg 55 3-
    74.9 右下肢 (L) 80 90 100 110 120 130 40 150 160 170 % 5.65 骨骼肌含量 23.9 kg 27 8-34 0 肌肉量
    41.6 kg 47.0-57 4 左下肢 (L) 70 80 90 100 110 120 130 140 150 160 170 ％ 5.72 体脂肪含量 30.0
    kg ( 7.8~156 肥胖分析 节段细胞外水分比率分析 BMI 25.0 kg/m ( 18.5~25 .0 体脂百分比 40.5% (10.0~200
    0 43 0.42 研究项目- 浮肿 基础代谢宰 1321 kcal ( 1593~1865 腰臀比 1.07 0.80~0.90 0.395 腹围 102.1
    cm 轻度浮肿 0 39 0.389 0.393 内脏脂肪面积 171.8 cm3 肥胖度 90~110 0 38 0.379 114 % 正常 0.376 身体
    细胞量 28.5 kg ( 32.5~39.7 0 37 上臂围度 32.4 cm 0 36 上臂肌肉围度 27.5 cm 右上肢 左上肢 躯干 右下肢
    左下肢 TBW/FFM 73.9% 去脂体重指数 身体水分历史记录 14.9 kg/m' 脂肪量指数 10.1 kg/m' 体重 (kg) 86.1
    79.1 81.0 79.3 73.5 74.0 全身相位角 ¢( 50xz] 4.6 身体总水分 39.9 35.8 37.1 43.6 35. 32.5 生物电阻
    抗- 细胞内水分 (L) 23.7 22.0 22.9 26.2 右上肢 左上肢躯千 右下肢 左下胶 21.1 19.9 ZQ) 1 MHlz/438.4
    383.5 35.6 331.9 323.0 5 g.428.0 374.7 34.4 324.1 315.2 细胞外水分（L） 16.2 13.8 14.2 17.4
    14.0 50 k1/ 377.9 334.7 31.0 294.0 285.0 12.6 250 H12/345.4 306.2 27.2 275.1 265.0 500 MHz
    334.7 296.9 25.8 270.1 259.4 细胞外水分比率 0.406 0.386 0.383 0.400 0.398 0.390 1000 &H2/
    328.6. 291.3 23.9 265.7 255.3 ：最近 口全部 1903 28 20 01.22: 20.05 20  20 08 24 21 07 01:21
    10.09 129 11 13 11.34 16.31 ：1639 Ver Lookin Body120 32a6- SN. C71600359 Copyrgh(g 1296-by
    InBody Co. Lat Au Pghs resaned BR-Chinese-00-B-140129

> 识别的结果同文档打印品质、拍摄角度、光线质量有密切关系。

## 用 NaturalLanguage 对文本进行关键字提取

健康笔记是一个以记录数据为核心的
app。为其添加文稿扫描功能是为了满足使用者对检查的纸质结果进行集中归档、整理的需要。因此，只需要从识别的文字中提取适量的查询关键字保存即可。

### NaturalLanguage 介绍

NaturalLanguage
是用于分析自然语言文本并推断其特定语言元数据的框架。它提供各种自然语言处理（NLP）功能，支持许多不同的语言和脚本。使用该框架将自然语言文本分割成段落、句子或单词，并对这些片段的信息进行标记，如词性、词汇类别、词组、脚本和语言。

使用这个框架可以执行如下任务：

- 语言识别（Language identification）

自动检测一段文本的语言

- 分词（Tokenization）

将一段文本分解成语言单位或代号

- 词性标注（Parts-of-speech tagging）

用词性标记单个单词

- 词性还原（Lemmatization）

根据词形分析推导出词干

- 实体识别（Named entity recognition）

将标记物识别为人名、地名或组织名称

### 提取关键字的思路

在本例中，身体检查报告的版式对文本识别不很友好（使用者将提交各种样式的报告结果，很难做有针对性的深度学习），对识别结果做词性标注、或实体识别也比较困难。因此我只做了以下几个步骤：

- 预处理

去除掉影响 Tokenization 的符号。本例中由于文字是从 VNRecognizeTextRequest 中获得，因此并不存在可能导致
tokenization 崩溃的控制字符。

- Tokenization（分词同时去除无用的信息）

创建 NLTokenizer 实例，进行分词。大致的代码如下：

      let tokenizer = NLTokenizer(unit: .word) // 分词器操作的粒度级别
      tokenizer.setLanguage(.simplifiedChinese) // 设置要分词的文本的语言
      tokenizer.string = text
      var tokenResult = [String]()
      tokenizer.enumerateTokens(in: text.startIndex..<text.endIndex) { tokenRange, attribute in
          let str = String(text[tokenRange])
          if attribute != .numeric, stopWords[str] == nil, str.count > 1 {
                    tokenResult.append(str)
          }
          return true
      }

- 去重

去除重复的内容。

经过以上操作，上文中的图片最后获得如下内容（为 Spotlight 优化）：

    inbody 身体水分身高性别男性日期时间透析组成含量细胞hof 分析上肢比率右下下肢人体成分蛋白质标准无机盐脂肪
    体重矿物质躯干肌肉骨骼bmi 百分比研究项目浮肿基础代谢腹围轻度内脏面积肥胖度正常上臂围度tbw ffm 指数历史
    记录全身相位生物电阻左下mhlz 最近全部ver lookin copyrgh lat pghs resaned chinese

> 本人并没有 NLP 方面的知识和经验，上述的处理过程仅凭自己的感觉，如有错误，欢迎指正。通过优化文本的识别行高、丰富 stopWords 和
> customWords、以及搭配词性判断，应该可以获得更好的结果。 **扫描图片的质量对最终结果影响最大** 。

## 用 CoreSpotlight 实现全文检索

除了可以将文本保存在 Core Data 中进行检索外，我们也可以将其添加到系统索引中方便用户使用 Spotlight 进行搜索。

关于如何将数据添加至 Spotlight 以及如何在 app 中调用 Spotlight 进行检索的内容，请参阅我的另一篇文章 [ 在 Spotlight
中展示应用中的 Core Data 数据 ](/zh/posts/spotlight/) 。

## 总结

一个看似并不容易的功能，即使开发者没有相关的知识和经验储备，仅通过使用系统提供的 API 也可以实现的有模有样。官方 API
已可以应对一般的场景需求，值得为苹果的付出点赞。

> 有朋友在看到本文后关心以上功能对程序容量的影响。我的测试程序在使用了 VisionKit、Vision、NaturalLanguage、SwiftUI
> 框架功能后容量为 330 KB，对容量的影响可以忽略不计。这也是使用系统 API 给我们带来的另一大优势。
